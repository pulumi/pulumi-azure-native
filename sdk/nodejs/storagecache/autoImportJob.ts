// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as enums from "../types/enums";
import * as utilities from "../utilities";

/**
 * An auto import job instance. Follows Azure Resource Manager standards: https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/resource-api-reference.md
 *
 * Uses Azure REST API version 2025-07-01.
 */
export class AutoImportJob extends pulumi.CustomResource {
    /**
     * Get an existing AutoImportJob resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, opts?: pulumi.CustomResourceOptions): AutoImportJob {
        return new AutoImportJob(name, undefined as any, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'azure-native:storagecache:AutoImportJob';

    /**
     * Returns true if the given object is an instance of AutoImportJob.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is AutoImportJob {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === AutoImportJob.__pulumiType;
    }

    /**
     * The administrative status of the auto import job. Possible values: 'Enable', 'Disable'. Passing in a value of 'Disable' will disable the current active auto import job. By default it is set to 'Enable'.
     */
    declare public readonly adminStatus: pulumi.Output<string | undefined>;
    /**
     * An array of blob paths/prefixes that get auto imported to the cluster namespace. It has '/' as the default value. Number of maximum allowed paths is 100.
     */
    declare public readonly autoImportPrefixes: pulumi.Output<string[] | undefined>;
    /**
     * The Azure API version of the resource.
     */
    declare public /*out*/ readonly azureApiVersion: pulumi.Output<string>;
    /**
     * The storage account blob change feed status of the auto import job.
     */
    declare public /*out*/ readonly blobSyncEvents: pulumi.Output<outputs.storagecache.AutoImportJobResponseBlobSyncEvents>;
    /**
     * How the auto import job will handle conflicts. For example, if the auto import job is trying to bring in a directory, but a file is at that path, how it handles it. Fail indicates that the auto import job should stop immediately and not do anything with the conflict. Skip indicates that it should pass over the conflict. OverwriteIfDirty causes the auto import job to delete and re-import the file or directory if it is a conflicting type, is dirty, or is currently released. OverwriteAlways extends OverwriteIfDirty to include releasing files that had been restored but were not dirty. Please reference https://learn.microsoft.com/en-us/azure/azure-managed-lustre/blob-integration#conflict-resolution-mode for a thorough explanation of these resolution modes.
     */
    declare public readonly conflictResolutionMode: pulumi.Output<string | undefined>;
    /**
     * Whether or not to enable deletions during auto import. This only affects overwrite-dirty.
     */
    declare public readonly enableDeletions: pulumi.Output<boolean | undefined>;
    /**
     * Number of directories imported during full scan.
     */
    declare public /*out*/ readonly importedDirectories: pulumi.Output<number>;
    /**
     * Number of files imported during full scan.
     */
    declare public /*out*/ readonly importedFiles: pulumi.Output<number>;
    /**
     * Number of symlinks imported during full scan.
     */
    declare public /*out*/ readonly importedSymlinks: pulumi.Output<number>;
    /**
     * The time (in UTC) of the last completed auto import job.
     */
    declare public /*out*/ readonly lastCompletionTimeUTC: pulumi.Output<string>;
    /**
     * The time (in UTC) the latest auto import job started.
     */
    declare public /*out*/ readonly lastStartedTimeUTC: pulumi.Output<string>;
    /**
     * The geo-location where the resource lives
     */
    declare public readonly location: pulumi.Output<string>;
    /**
     * Total non-conflict-oriented errors (e.g., OS errors) Import will tolerate before exiting with failure. -1 means infinite. 0 means exit immediately on any error.
     */
    declare public readonly maximumErrors: pulumi.Output<number | undefined>;
    /**
     * The name of the resource
     */
    declare public /*out*/ readonly name: pulumi.Output<string>;
    /**
     * Number of preexisting directories during full scan.
     */
    declare public /*out*/ readonly preexistingDirectories: pulumi.Output<number>;
    /**
     * Number of preexisting files during full scan.
     */
    declare public /*out*/ readonly preexistingFiles: pulumi.Output<number>;
    /**
     * Number of preexisting symlinks during full scan.
     */
    declare public /*out*/ readonly preexistingSymlinks: pulumi.Output<number>;
    /**
     * ARM provisioning state.
     */
    declare public /*out*/ readonly provisioningState: pulumi.Output<string>;
    /**
     * Rate of blob import during full scan.
     */
    declare public /*out*/ readonly rateOfBlobImport: pulumi.Output<number>;
    /**
     * Rate of blobs walked during full scan.
     */
    declare public /*out*/ readonly rateOfBlobWalk: pulumi.Output<number>;
    /**
     * Date and time of when the full scan ended.
     */
    declare public /*out*/ readonly scanEndTime: pulumi.Output<string>;
    /**
     * Date and time of when the currently running full scan began.
     */
    declare public /*out*/ readonly scanStartTime: pulumi.Output<string>;
    /**
     * The state of the auto import operation.
     */
    declare public /*out*/ readonly state: pulumi.Output<string>;
    /**
     * Server-defined status code for auto import job.
     */
    declare public /*out*/ readonly statusCode: pulumi.Output<string>;
    /**
     * Server-defined status message for auto import job.
     */
    declare public /*out*/ readonly statusMessage: pulumi.Output<string>;
    /**
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     */
    declare public /*out*/ readonly systemData: pulumi.Output<outputs.storagecache.SystemDataResponse>;
    /**
     * Resource tags.
     */
    declare public readonly tags: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * Total number of blobs imported during full scan.
     */
    declare public /*out*/ readonly totalBlobsImported: pulumi.Output<number>;
    /**
     * Total number of blobs walked during full scan.
     */
    declare public /*out*/ readonly totalBlobsWalked: pulumi.Output<number>;
    /**
     * Total conflicts encountered during full scan.
     */
    declare public /*out*/ readonly totalConflicts: pulumi.Output<number>;
    /**
     * Total errors encountered during full scan.
     */
    declare public /*out*/ readonly totalErrors: pulumi.Output<number>;
    /**
     * The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
     */
    declare public /*out*/ readonly type: pulumi.Output<string>;

    /**
     * Create a AutoImportJob resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: AutoImportJobArgs, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (!opts.id) {
            if (args?.amlFilesystemName === undefined && !opts.urn) {
                throw new Error("Missing required property 'amlFilesystemName'");
            }
            if (args?.resourceGroupName === undefined && !opts.urn) {
                throw new Error("Missing required property 'resourceGroupName'");
            }
            resourceInputs["adminStatus"] = (args?.adminStatus) ?? "Enable";
            resourceInputs["amlFilesystemName"] = args?.amlFilesystemName;
            resourceInputs["autoImportJobName"] = args?.autoImportJobName;
            resourceInputs["autoImportPrefixes"] = args?.autoImportPrefixes;
            resourceInputs["conflictResolutionMode"] = (args?.conflictResolutionMode) ?? "Skip";
            resourceInputs["enableDeletions"] = (args?.enableDeletions) ?? false;
            resourceInputs["location"] = args?.location;
            resourceInputs["maximumErrors"] = args?.maximumErrors;
            resourceInputs["resourceGroupName"] = args?.resourceGroupName;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["azureApiVersion"] = undefined /*out*/;
            resourceInputs["blobSyncEvents"] = undefined /*out*/;
            resourceInputs["importedDirectories"] = undefined /*out*/;
            resourceInputs["importedFiles"] = undefined /*out*/;
            resourceInputs["importedSymlinks"] = undefined /*out*/;
            resourceInputs["lastCompletionTimeUTC"] = undefined /*out*/;
            resourceInputs["lastStartedTimeUTC"] = undefined /*out*/;
            resourceInputs["name"] = undefined /*out*/;
            resourceInputs["preexistingDirectories"] = undefined /*out*/;
            resourceInputs["preexistingFiles"] = undefined /*out*/;
            resourceInputs["preexistingSymlinks"] = undefined /*out*/;
            resourceInputs["provisioningState"] = undefined /*out*/;
            resourceInputs["rateOfBlobImport"] = undefined /*out*/;
            resourceInputs["rateOfBlobWalk"] = undefined /*out*/;
            resourceInputs["scanEndTime"] = undefined /*out*/;
            resourceInputs["scanStartTime"] = undefined /*out*/;
            resourceInputs["state"] = undefined /*out*/;
            resourceInputs["statusCode"] = undefined /*out*/;
            resourceInputs["statusMessage"] = undefined /*out*/;
            resourceInputs["systemData"] = undefined /*out*/;
            resourceInputs["totalBlobsImported"] = undefined /*out*/;
            resourceInputs["totalBlobsWalked"] = undefined /*out*/;
            resourceInputs["totalConflicts"] = undefined /*out*/;
            resourceInputs["totalErrors"] = undefined /*out*/;
            resourceInputs["type"] = undefined /*out*/;
        } else {
            resourceInputs["adminStatus"] = undefined /*out*/;
            resourceInputs["autoImportPrefixes"] = undefined /*out*/;
            resourceInputs["azureApiVersion"] = undefined /*out*/;
            resourceInputs["blobSyncEvents"] = undefined /*out*/;
            resourceInputs["conflictResolutionMode"] = undefined /*out*/;
            resourceInputs["enableDeletions"] = undefined /*out*/;
            resourceInputs["importedDirectories"] = undefined /*out*/;
            resourceInputs["importedFiles"] = undefined /*out*/;
            resourceInputs["importedSymlinks"] = undefined /*out*/;
            resourceInputs["lastCompletionTimeUTC"] = undefined /*out*/;
            resourceInputs["lastStartedTimeUTC"] = undefined /*out*/;
            resourceInputs["location"] = undefined /*out*/;
            resourceInputs["maximumErrors"] = undefined /*out*/;
            resourceInputs["name"] = undefined /*out*/;
            resourceInputs["preexistingDirectories"] = undefined /*out*/;
            resourceInputs["preexistingFiles"] = undefined /*out*/;
            resourceInputs["preexistingSymlinks"] = undefined /*out*/;
            resourceInputs["provisioningState"] = undefined /*out*/;
            resourceInputs["rateOfBlobImport"] = undefined /*out*/;
            resourceInputs["rateOfBlobWalk"] = undefined /*out*/;
            resourceInputs["scanEndTime"] = undefined /*out*/;
            resourceInputs["scanStartTime"] = undefined /*out*/;
            resourceInputs["state"] = undefined /*out*/;
            resourceInputs["statusCode"] = undefined /*out*/;
            resourceInputs["statusMessage"] = undefined /*out*/;
            resourceInputs["systemData"] = undefined /*out*/;
            resourceInputs["tags"] = undefined /*out*/;
            resourceInputs["totalBlobsImported"] = undefined /*out*/;
            resourceInputs["totalBlobsWalked"] = undefined /*out*/;
            resourceInputs["totalConflicts"] = undefined /*out*/;
            resourceInputs["totalErrors"] = undefined /*out*/;
            resourceInputs["type"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const aliasOpts = { aliases: [{ type: "azure-native:storagecache/v20250701:AutoImportJob" }] };
        opts = pulumi.mergeOptions(opts, aliasOpts);
        super(AutoImportJob.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * The set of arguments for constructing a AutoImportJob resource.
 */
export interface AutoImportJobArgs {
    /**
     * The administrative status of the auto import job. Possible values: 'Enable', 'Disable'. Passing in a value of 'Disable' will disable the current active auto import job. By default it is set to 'Enable'.
     */
    adminStatus?: pulumi.Input<string | enums.storagecache.AdminStatus>;
    /**
     * Name for the AML file system. Allows alphanumerics, underscores, and hyphens. Start and end with alphanumeric.
     */
    amlFilesystemName: pulumi.Input<string>;
    /**
     * Name for the auto import job. Allows alphanumerics, underscores, and hyphens. Start and end with alphanumeric.
     */
    autoImportJobName?: pulumi.Input<string>;
    /**
     * An array of blob paths/prefixes that get auto imported to the cluster namespace. It has '/' as the default value. Number of maximum allowed paths is 100.
     */
    autoImportPrefixes?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * How the auto import job will handle conflicts. For example, if the auto import job is trying to bring in a directory, but a file is at that path, how it handles it. Fail indicates that the auto import job should stop immediately and not do anything with the conflict. Skip indicates that it should pass over the conflict. OverwriteIfDirty causes the auto import job to delete and re-import the file or directory if it is a conflicting type, is dirty, or is currently released. OverwriteAlways extends OverwriteIfDirty to include releasing files that had been restored but were not dirty. Please reference https://learn.microsoft.com/en-us/azure/azure-managed-lustre/blob-integration#conflict-resolution-mode for a thorough explanation of these resolution modes.
     */
    conflictResolutionMode?: pulumi.Input<string | enums.storagecache.ConflictResolutionMode>;
    /**
     * Whether or not to enable deletions during auto import. This only affects overwrite-dirty.
     */
    enableDeletions?: pulumi.Input<boolean>;
    /**
     * The geo-location where the resource lives
     */
    location?: pulumi.Input<string>;
    /**
     * Total non-conflict-oriented errors (e.g., OS errors) Import will tolerate before exiting with failure. -1 means infinite. 0 means exit immediately on any error.
     */
    maximumErrors?: pulumi.Input<number>;
    /**
     * The name of the resource group. The name is case insensitive.
     */
    resourceGroupName: pulumi.Input<string>;
    /**
     * Resource tags.
     */
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}
