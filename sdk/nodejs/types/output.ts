// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export namespace aad {
    /**
     * Domain Security Settings
     */
    export interface DomainSecuritySettingsResponse {
        /**
         * A flag to determine whether or not NtlmV1 is enabled or disabled.
         */
        ntlmV1?: string;
        /**
         * A flag to determine whether or not SyncNtlmPasswords is enabled or disabled.
         */
        syncNtlmPasswords?: string;
        /**
         * A flag to determine whether or not TlsV1 is enabled or disabled.
         */
        tlsV1?: string;
    }

    /**
     * Properties of the Domain Service.
     */
    export interface DomainServicePropertiesResponse {
        /**
         * Deployment Id
         */
        deploymentId: string;
        /**
         * The name of the Azure domain that the user would like to deploy Domain Services to.
         */
        domainName?: string;
        /**
         * DomainSecurity Settings
         */
        domainSecuritySettings?: outputs.aad.DomainSecuritySettingsResponse;
        /**
         * Enabled or Disabled flag to turn on Group-based filtered sync
         */
        filteredSync?: string;
        /**
         * Secure LDAP Settings
         */
        ldapsSettings?: outputs.aad.LdapsSettingsResponse;
        /**
         * Notification Settings
         */
        notificationSettings?: outputs.aad.NotificationSettingsResponse;
        /**
         * the current deployment or provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * List of ReplicaSets
         */
        replicaSets?: outputs.aad.ReplicaSetResponse[];
        /**
         * SyncOwner ReplicaSet Id
         */
        syncOwner: string;
        /**
         * Azure Active Directory Tenant Id
         */
        tenantId: string;
        /**
         * Data Model Version
         */
        version: number;
    }

    /**
     * Health Alert Description
     */
    export interface HealthAlertResponse {
        /**
         * Health Alert Id
         */
        id: string;
        /**
         * Health Alert Issue
         */
        issue: string;
        /**
         * Health Alert Last Detected DateTime
         */
        lastDetected: string;
        /**
         * Health Alert Name
         */
        name: string;
        /**
         * Health Alert Raised DateTime
         */
        raised: string;
        /**
         * Health Alert TSG Link
         */
        resolutionUri: string;
        /**
         * Health Alert Severity
         */
        severity: string;
    }

    /**
     * Health Monitor Description
     */
    export interface HealthMonitorResponse {
        /**
         * Health Monitor Details
         */
        details: string;
        /**
         * Health Monitor Id
         */
        id: string;
        /**
         * Health Monitor Name
         */
        name: string;
    }

    /**
     * Secure LDAP Settings
     */
    export interface LdapsSettingsResponse {
        /**
         * NotAfter DateTime of configure ldaps certificate.
         */
        certificateNotAfter: string;
        /**
         * Thumbprint of configure ldaps certificate.
         */
        certificateThumbprint: string;
        /**
         * A flag to determine whether or not Secure LDAP access over the internet is enabled or disabled.
         */
        externalAccess?: string;
        /**
         * A flag to determine whether or not Secure LDAP is enabled or disabled.
         */
        ldaps?: string;
        /**
         * The certificate required to configure Secure LDAP. The parameter passed here should be a base64encoded representation of the certificate pfx file.
         */
        pfxCertificate?: string;
        /**
         * The password to decrypt the provided Secure LDAP certificate pfx file.
         */
        pfxCertificatePassword?: string;
        /**
         * Public certificate used to configure secure ldap.
         */
        publicCertificate: string;
    }

    /**
     * Settings for notification
     */
    export interface NotificationSettingsResponse {
        /**
         * The list of additional recipients
         */
        additionalRecipients?: string[];
        /**
         * Should domain controller admins be notified
         */
        notifyDcAdmins?: string;
        /**
         * Should global admins be notified
         */
        notifyGlobalAdmins?: string;
    }

    /**
     * Replica Set Definition
     */
    export interface ReplicaSetResponse {
        /**
         * List of Domain Controller IP Address
         */
        domainControllerIpAddress: string[];
        /**
         * External access ip address.
         */
        externalAccessIpAddress: string;
        /**
         * List of Domain Health Alerts
         */
        healthAlerts: outputs.aad.HealthAlertResponse[];
        /**
         * Last domain evaluation run DateTime
         */
        healthLastEvaluated: string;
        /**
         * List of Domain Health Monitors
         */
        healthMonitors: outputs.aad.HealthMonitorResponse[];
        /**
         * Virtual network location
         */
        location?: string;
        /**
         * ReplicaSet Id
         */
        replicaSetId: string;
        /**
         * Status of Domain Service instance
         */
        serviceStatus: string;
        /**
         * The name of the virtual network that Domain Services will be deployed on. The id of the subnet that Domain Services will be deployed on. /virtualNetwork/vnetName/subnets/subnetName.
         */
        subnetId?: string;
        /**
         * Virtual network site id
         */
        vnetSiteId: string;
    }
}

export namespace analysisservices {
    /**
     * Properties of Analysis Services resource.
     */
    export interface AnalysisServicesServerPropertiesResponse {
        /**
         * A collection of AS server administrators
         */
        asAdministrators?: outputs.analysisservices.ServerAdministratorsResponse;
        /**
         * The SAS container URI to the backup container.
         */
        backupBlobContainerUri?: string;
        /**
         * The gateway details configured for the AS server.
         */
        gatewayDetails?: outputs.analysisservices.GatewayDetailsResponse;
        /**
         * The firewall settings for the AS server.
         */
        ipV4FirewallSettings?: outputs.analysisservices.IPv4FirewallSettingsResponse;
        /**
         * The current deployment state of Analysis Services resource. The provisioningState is to indicate states for resource provisioning.
         */
        provisioningState: string;
        /**
         * How the read-write server's participation in the query pool is controlled.<br/>It can have the following values: <ul><li>readOnly - indicates that the read-write server is intended not to participate in query operations</li><li>all - indicates that the read-write server can participate in query operations</li></ul>Specifying readOnly when capacity is 1 results in error.
         */
        querypoolConnectionMode?: string;
        /**
         * The full name of the Analysis Services resource.
         */
        serverFullName: string;
        /**
         * The current state of Analysis Services resource. The state is to indicate more states outside of resource provisioning.
         */
        state: string;
    }

    /**
     * The gateway details.
     */
    export interface GatewayDetailsResponse {
        /**
         * Uri of the DMTS cluster.
         */
        dmtsClusterUri: string;
        /**
         * Gateway object id from in the DMTS cluster for the gateway resource.
         */
        gatewayObjectId: string;
        /**
         * Gateway resource to be associated with the server.
         */
        gatewayResourceId?: string;
    }

    /**
     * The detail of firewall rule.
     */
    export interface IPv4FirewallRuleResponse {
        /**
         * The rule name.
         */
        firewallRuleName?: string;
        /**
         * The end range of IPv4.
         */
        rangeEnd?: string;
        /**
         * The start range of IPv4.
         */
        rangeStart?: string;
    }

    /**
     * An array of firewall rules.
     */
    export interface IPv4FirewallSettingsResponse {
        /**
         * The indicator of enabling PBI service.
         */
        enablePowerBIService?: boolean;
        /**
         * An array of firewall rules.
         */
        firewallRules?: outputs.analysisservices.IPv4FirewallRuleResponse[];
    }

    /**
     * Represents the SKU name and Azure pricing tier for Analysis Services resource.
     */
    export interface ResourceSkuResponse {
        /**
         * The number of instances in the read only query pool.
         */
        capacity?: number;
        /**
         * Name of the SKU level.
         */
        name: string;
        /**
         * The name of the Azure pricing tier to which the SKU applies.
         */
        tier?: string;
    }

    /**
     * An array of administrator user identities.
     */
    export interface ServerAdministratorsResponse {
        /**
         * An array of administrator user identities.
         */
        members?: string[];
    }
}

export namespace apimanagement {
    /**
     * Description of an additional API Management resource location.
     */
    export interface AdditionalLocationResponse {
        /**
         * Property only valid for an Api Management service deployed in multiple locations. This can be used to disable the gateway in this additional location.
         */
        disableGateway?: boolean;
        /**
         * Gateway URL of the API Management service in the Region.
         */
        gatewayRegionalUrl: string;
        /**
         * The location name of the additional region among Azure Data center regions.
         */
        location: string;
        /**
         * Private Static Load Balanced IP addresses of the API Management service which is deployed in an Internal Virtual Network in a particular additional location. Available only for Basic, Standard and Premium SKU.
         */
        privateIPAddresses: string[];
        /**
         * Public Static Load Balanced IP addresses of the API Management service in the additional location. Available only for Basic, Standard and Premium SKU.
         */
        publicIPAddresses: string[];
        /**
         * SKU properties of the API Management service.
         */
        sku: outputs.apimanagement.ApiManagementServiceSkuPropertiesResponse;
        /**
         * Virtual network configuration for the location.
         */
        virtualNetworkConfiguration?: outputs.apimanagement.VirtualNetworkConfigurationResponse;
    }

    /**
     * Api Entity Properties
     */
    export interface ApiContractPropertiesResponse {
        /**
         * Describes the Revision of the Api. If no value is provided, default revision 1 is created
         */
        apiRevision?: string;
        /**
         * Description of the Api Revision.
         */
        apiRevisionDescription?: string;
        /**
         * Indicates the Version identifier of the API if the API is versioned
         */
        apiVersion?: string;
        /**
         * Description of the Api Version.
         */
        apiVersionDescription?: string;
        /**
         * Version set details
         */
        apiVersionSet?: outputs.apimanagement.ApiVersionSetContractDetailsResponse;
        /**
         * A resource identifier for the related ApiVersionSet.
         */
        apiVersionSetId?: string;
        /**
         * Collection of authentication settings included into this API.
         */
        authenticationSettings?: outputs.apimanagement.AuthenticationSettingsContractResponse;
        /**
         * Description of the API. May include HTML formatting tags.
         */
        description?: string;
        /**
         * API name. Must be 1 to 300 characters long.
         */
        displayName?: string;
        /**
         * Indicates if API revision is current api revision.
         */
        isCurrent?: boolean;
        /**
         * Indicates if API revision is accessible via the gateway.
         */
        isOnline: boolean;
        /**
         * Relative URL uniquely identifying this API and all of its resource paths within the API Management service instance. It is appended to the API endpoint base URL specified during the service instance creation to form a public URL for this API.
         */
        path: string;
        /**
         * Describes on which protocols the operations in this API can be invoked.
         */
        protocols?: string[];
        /**
         * Absolute URL of the backend service implementing this API. Cannot be more than 2000 characters long.
         */
        serviceUrl?: string;
        /**
         * API identifier of the source API.
         */
        sourceApiId?: string;
        /**
         * Protocols over which API is made available.
         */
        subscriptionKeyParameterNames?: outputs.apimanagement.SubscriptionKeyParameterNamesContractResponse;
        /**
         * Specifies whether an API or Product subscription is required for accessing the API.
         */
        subscriptionRequired?: boolean;
        /**
         * Type of API.
         */
        type?: string;
    }

    /**
     * Identity properties of the Api Management service resource.
     */
    export interface ApiManagementServiceIdentityResponse {
        /**
         * The principal id of the identity.
         */
        principalId: string;
        /**
         * The client tenant id of the identity.
         */
        tenantId: string;
        /**
         * The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the service.
         */
        type: string;
        /**
         * The list of user identities associated with the resource. The user identity 
         * dictionary key references will be ARM resource ids in the form: 
         * '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/
         *     providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
         */
        userAssignedIdentities?: {[key: string]: string};
    }

    /**
     * Properties of an API Management service resource description.
     */
    export interface ApiManagementServicePropertiesResponse {
        /**
         * Additional datacenter locations of the API Management service.
         */
        additionalLocations?: outputs.apimanagement.AdditionalLocationResponse[];
        /**
         * Control Plane Apis version constraint for the API Management service.
         */
        apiVersionConstraint?: outputs.apimanagement.ApiVersionConstraintResponse;
        /**
         * List of Certificates that need to be installed in the API Management service. Max supported certificates that can be installed is 10.
         */
        certificates?: outputs.apimanagement.CertificateConfigurationResponse[];
        /**
         * Creation UTC date of the API Management service.The date conforms to the following format: `yyyy-MM-ddTHH:mm:ssZ` as specified by the ISO 8601 standard.
         */
        createdAtUtc: string;
        /**
         * Custom properties of the API Management service.</br>Setting `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Ciphers.TripleDes168` will disable the cipher TLS_RSA_WITH_3DES_EDE_CBC_SHA for all TLS(1.0, 1.1 and 1.2).</br>Setting `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Protocols.Tls11` can be used to disable just TLS 1.1.</br>Setting `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Protocols.Tls10` can be used to disable TLS 1.0 on an API Management service.</br>Setting `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Backend.Protocols.Tls11` can be used to disable just TLS 1.1 for communications with backends.</br>Setting `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Backend.Protocols.Tls10` can be used to disable TLS 1.0 for communications with backends.</br>Setting `Microsoft.WindowsAzure.ApiManagement.Gateway.Protocols.Server.Http2` can be used to enable HTTP2 protocol on an API Management service.</br>Not specifying any of these properties on PATCH operation will reset omitted properties' values to their defaults. For all the settings except Http2 the default value is `True` if the service was created on or before April 1st 2018 and `False` otherwise. Http2 setting's default value is `False`.</br></br>You can disable any of next ciphers by using settings `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Ciphers.[cipher_name]`: TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_128_GCM_SHA256, TLS_RSA_WITH_AES_256_CBC_SHA256, TLS_RSA_WITH_AES_128_CBC_SHA256, TLS_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA. For example, `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Ciphers.TLS_RSA_WITH_AES_128_CBC_SHA256`:`false`. The default value is `true` for them.  Note: next ciphers can't be disabled since they are required by Azure CloudService internal components: TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_256_GCM_SHA384
         */
        customProperties?: {[key: string]: string};
        /**
         * DEveloper Portal endpoint URL of the API Management service.
         */
        developerPortalUrl: string;
        /**
         * Property only valid for an Api Management service deployed in multiple locations. This can be used to disable the gateway in master region.
         */
        disableGateway?: boolean;
        /**
         * Property only meant to be used for Consumption SKU Service. This enforces a client certificate to be presented on each request to the gateway. This also enables the ability to authenticate the certificate in the policy on the gateway.
         */
        enableClientCertificate?: boolean;
        /**
         * Gateway URL of the API Management service in the Default Region.
         */
        gatewayRegionalUrl: string;
        /**
         * Gateway URL of the API Management service.
         */
        gatewayUrl: string;
        /**
         * Custom hostname configuration of the API Management service.
         */
        hostnameConfigurations?: outputs.apimanagement.HostnameConfigurationResponse[];
        /**
         * Management API endpoint URL of the API Management service.
         */
        managementApiUrl: string;
        /**
         * Email address from which the notification will be sent.
         */
        notificationSenderEmail?: string;
        /**
         * Publisher portal endpoint Url of the API Management service.
         */
        portalUrl: string;
        /**
         * Private Static Load Balanced IP addresses of the API Management service in Primary region which is deployed in an Internal Virtual Network. Available only for Basic, Standard and Premium SKU.
         */
        privateIPAddresses: string[];
        /**
         * The current provisioning state of the API Management service which can be one of the following: Created/Activating/Succeeded/Updating/Failed/Stopped/Terminating/TerminationFailed/Deleted.
         */
        provisioningState: string;
        /**
         * Public Static Load Balanced IP addresses of the API Management service in Primary region. Available only for Basic, Standard and Premium SKU.
         */
        publicIPAddresses: string[];
        /**
         * Publisher email.
         */
        publisherEmail: string;
        /**
         * Publisher name.
         */
        publisherName: string;
        /**
         * SCM endpoint URL of the API Management service.
         */
        scmUrl: string;
        /**
         * The provisioning state of the API Management service, which is targeted by the long running operation started on the service.
         */
        targetProvisioningState: string;
        /**
         * Virtual network configuration of the API Management service.
         */
        virtualNetworkConfiguration?: outputs.apimanagement.VirtualNetworkConfigurationResponse;
        /**
         * The type of VPN in which API Management service needs to be configured in. None (Default Value) means the API Management service is not part of any Virtual Network, External means the API Management deployment is set up inside a Virtual Network having an Internet Facing Endpoint, and Internal means that API Management deployment is setup inside a Virtual Network having an Intranet Facing Endpoint only.
         */
        virtualNetworkType?: string;
    }

    /**
     * API Management service resource SKU properties.
     */
    export interface ApiManagementServiceSkuPropertiesResponse {
        /**
         * Capacity of the SKU (number of deployed units of the SKU). For Consumption SKU capacity must be specified as 0.
         */
        capacity: number;
        /**
         * Name of the Sku.
         */
        name: string;
    }

    /**
     * API Release details
     */
    export interface ApiReleaseContractPropertiesResponse {
        /**
         * Identifier of the API the release belongs to.
         */
        apiId?: string;
        /**
         * The time the API was released. The date conforms to the following format: yyyy-MM-ddTHH:mm:ssZ as specified by the ISO 8601 standard.
         */
        createdDateTime: string;
        /**
         * Release Notes
         */
        notes?: string;
        /**
         * The time the API release was updated.
         */
        updatedDateTime: string;
    }

    /**
     * Control Plane Apis version constraint for the API Management service.
     */
    export interface ApiVersionConstraintResponse {
        /**
         * Limit control plane API calls to API Management service with version equal to or newer than this value.
         */
        minApiVersion?: string;
    }

    /**
     * An API Version Set contains the common configuration for a set of API Versions relating 
     */
    export interface ApiVersionSetContractDetailsResponse {
        /**
         * Description of API Version Set.
         */
        description?: string;
        /**
         * Identifier for existing API Version Set. Omit this value to create a new Version Set.
         */
        id?: string;
        /**
         * The display Name of the API Version Set.
         */
        name?: string;
        /**
         * Name of HTTP header parameter that indicates the API Version if versioningScheme is set to `header`.
         */
        versionHeaderName?: string;
        /**
         * Name of query parameter that indicates the API Version if versioningScheme is set to `query`.
         */
        versionQueryName?: string;
        /**
         * An value that determines where the API Version identifer will be located in a HTTP request.
         */
        versioningScheme?: string;
    }

    /**
     * Properties of an API Version Set.
     */
    export interface ApiVersionSetContractPropertiesResponse {
        /**
         * Description of API Version Set.
         */
        description?: string;
        /**
         * Name of API Version Set
         */
        displayName: string;
        /**
         * Name of HTTP header parameter that indicates the API Version if versioningScheme is set to `header`.
         */
        versionHeaderName?: string;
        /**
         * Name of query parameter that indicates the API Version if versioningScheme is set to `query`.
         */
        versionQueryName?: string;
        /**
         * An value that determines where the API Version identifer will be located in a HTTP request.
         */
        versioningScheme: string;
    }

    /**
     * API Authentication Settings.
     */
    export interface AuthenticationSettingsContractResponse {
        /**
         * OAuth2 Authentication settings
         */
        oAuth2?: outputs.apimanagement.OAuth2AuthenticationSettingsContractResponse;
        /**
         * OpenID Connect Authentication Settings
         */
        openid?: outputs.apimanagement.OpenIdAuthenticationSettingsContractResponse;
    }

    /**
     * External OAuth authorization server settings Properties.
     */
    export interface AuthorizationServerContractPropertiesResponse {
        /**
         * OAuth authorization endpoint. See http://tools.ietf.org/html/rfc6749#section-3.2.
         */
        authorizationEndpoint: string;
        /**
         * HTTP verbs supported by the authorization endpoint. GET must be always present. POST is optional.
         */
        authorizationMethods?: string[];
        /**
         * Specifies the mechanism by which access token is passed to the API. 
         */
        bearerTokenSendingMethods?: string[];
        /**
         * Method of authentication supported by the token endpoint of this authorization server. Possible values are Basic and/or Body. When Body is specified, client credentials and other parameters are passed within the request body in the application/x-www-form-urlencoded format.
         */
        clientAuthenticationMethod?: string[];
        /**
         * Client or app id registered with this authorization server.
         */
        clientId: string;
        /**
         * Optional reference to a page where client or app registration for this authorization server is performed. Contains absolute URL to entity being referenced.
         */
        clientRegistrationEndpoint: string;
        /**
         * Client or app secret registered with this authorization server. This property will not be filled on 'GET' operations! Use '/listSecrets' POST request to get the value.
         */
        clientSecret?: string;
        /**
         * Access token scope that is going to be requested by default. Can be overridden at the API level. Should be provided in the form of a string containing space-delimited values.
         */
        defaultScope?: string;
        /**
         * Description of the authorization server. Can contain HTML formatting tags.
         */
        description?: string;
        /**
         * User-friendly authorization server name.
         */
        displayName: string;
        /**
         * Form of an authorization grant, which the client uses to request the access token.
         */
        grantTypes: string[];
        /**
         * Can be optionally specified when resource owner password grant type is supported by this authorization server. Default resource owner password.
         */
        resourceOwnerPassword?: string;
        /**
         * Can be optionally specified when resource owner password grant type is supported by this authorization server. Default resource owner username.
         */
        resourceOwnerUsername?: string;
        /**
         * If true, authorization server will include state parameter from the authorization request to its response. Client may use state parameter to raise protocol security.
         */
        supportState?: boolean;
        /**
         * Additional parameters required by the token endpoint of this authorization server represented as an array of JSON objects with name and value string properties, i.e. {"name" : "name value", "value": "a value"}.
         */
        tokenBodyParameters?: outputs.apimanagement.TokenBodyParameterContractResponse[];
        /**
         * OAuth token endpoint. Contains absolute URI to entity being referenced.
         */
        tokenEndpoint?: string;
    }

    /**
     * Authorization header information.
     */
    export interface BackendAuthorizationHeaderCredentialsResponse {
        /**
         * Authentication Parameter value.
         */
        parameter: string;
        /**
         * Authentication Scheme name.
         */
        scheme: string;
    }

    /**
     * Parameters supplied to the Create Backend operation.
     */
    export interface BackendContractPropertiesResponse {
        /**
         * Backend Credentials Contract Properties
         */
        credentials?: outputs.apimanagement.BackendCredentialsContractResponse;
        /**
         * Backend Description.
         */
        description?: string;
        /**
         * Backend Properties contract
         */
        properties?: outputs.apimanagement.BackendPropertiesResponse;
        /**
         * Backend communication protocol.
         */
        protocol: string;
        /**
         * Backend Proxy Contract Properties
         */
        proxy?: outputs.apimanagement.BackendProxyContractResponse;
        /**
         * Management Uri of the Resource in External System. This url can be the Arm Resource Id of Logic Apps, Function Apps or Api Apps.
         */
        resourceId?: string;
        /**
         * Backend Title.
         */
        title?: string;
        /**
         * Backend TLS Properties
         */
        tls?: outputs.apimanagement.BackendTlsPropertiesResponse;
        /**
         * Runtime Url of the Backend.
         */
        url: string;
    }

    /**
     * Details of the Credentials used to connect to Backend.
     */
    export interface BackendCredentialsContractResponse {
        /**
         * Authorization header authentication
         */
        authorization?: outputs.apimanagement.BackendAuthorizationHeaderCredentialsResponse;
        /**
         * List of Client Certificate Thumbprint.
         */
        certificate?: string[];
        /**
         * Header Parameter description.
         */
        header?: {[key: string]: string};
        /**
         * Query Parameter description.
         */
        query?: {[key: string]: string};
    }

    /**
     * Properties specific to the Backend Type.
     */
    export interface BackendPropertiesResponse {
        /**
         * Backend Service Fabric Cluster Properties
         */
        serviceFabricCluster?: outputs.apimanagement.BackendServiceFabricClusterPropertiesResponse;
    }

    /**
     * Details of the Backend WebProxy Server to use in the Request to Backend.
     */
    export interface BackendProxyContractResponse {
        /**
         * Password to connect to the WebProxy Server
         */
        password?: string;
        /**
         * WebProxy Server AbsoluteUri property which includes the entire URI stored in the Uri instance, including all fragments and query strings.
         */
        url: string;
        /**
         * Username to connect to the WebProxy server
         */
        username?: string;
    }

    /**
     * Properties of the Service Fabric Type Backend.
     */
    export interface BackendServiceFabricClusterPropertiesResponse {
        /**
         * The client certificate thumbprint for the management endpoint.
         */
        clientCertificatethumbprint: string;
        /**
         * The cluster management endpoint.
         */
        managementEndpoints: string[];
        /**
         * Maximum number of retries while attempting resolve the partition.
         */
        maxPartitionResolutionRetries?: number;
        /**
         * Thumbprints of certificates cluster management service uses for tls communication
         */
        serverCertificateThumbprints?: string[];
        /**
         * Server X509 Certificate Names Collection
         */
        serverX509Names?: outputs.apimanagement.X509CertificateNameResponse[];
    }

    /**
     * Properties controlling TLS Certificate Validation.
     */
    export interface BackendTlsPropertiesResponse {
        /**
         * Flag indicating whether SSL certificate chain validation should be done when using self-signed certificates for this backend host.
         */
        validateCertificateChain?: boolean;
        /**
         * Flag indicating whether SSL certificate name validation should be done when using self-signed certificates for this backend host.
         */
        validateCertificateName?: boolean;
    }

    /**
     * Body logging settings.
     */
    export interface BodyDiagnosticSettingsResponse {
        /**
         * Number of request body bytes to log.
         */
        bytes?: number;
    }

    /**
     * Properties of the Cache contract.
     */
    export interface CacheContractPropertiesResponse {
        /**
         * Runtime connection string to cache
         */
        connectionString: string;
        /**
         * Cache description
         */
        description?: string;
        /**
         * Original uri of entity in external system cache points to
         */
        resourceId?: string;
    }

    /**
     * Certificate configuration which consist of non-trusted intermediates and root certificates.
     */
    export interface CertificateConfigurationResponse {
        /**
         * Certificate information.
         */
        certificate?: outputs.apimanagement.CertificateInformationResponse;
        /**
         * Certificate Password.
         */
        certificatePassword?: string;
        /**
         * Base64 Encoded certificate.
         */
        encodedCertificate?: string;
        /**
         * The System.Security.Cryptography.x509certificates.StoreName certificate store location. Only Root and CertificateAuthority are valid locations.
         */
        storeName: string;
    }

    /**
     * Properties of the Certificate contract.
     */
    export interface CertificateContractPropertiesResponse {
        /**
         * Expiration date of the certificate. The date conforms to the following format: `yyyy-MM-ddTHH:mm:ssZ` as specified by the ISO 8601 standard.
         */
        expirationDate: string;
        /**
         * Subject attribute of the certificate.
         */
        subject: string;
        /**
         * Thumbprint of the certificate.
         */
        thumbprint: string;
    }

    /**
     * SSL certificate information.
     */
    export interface CertificateInformationResponse {
        /**
         * Expiration date of the certificate. The date conforms to the following format: `yyyy-MM-ddTHH:mm:ssZ` as specified by the ISO 8601 standard.
         */
        expiry: string;
        /**
         * Subject of the certificate.
         */
        subject: string;
        /**
         * Thumbprint of the certificate.
         */
        thumbprint: string;
    }

    export interface ContentItemContractPropertiesResponse {
    }

    export interface ContentTypeContractPropertiesResponse {
        /**
         * Content type description.
         */
        description?: string;
        /**
         * Content type identifier
         */
        id?: string;
        /**
         * Content type name. Must be 1 to 250 characters long.
         */
        name?: string;
        /**
         * Content type schema.
         */
        schema?: {[key: string]: string};
        /**
         * Content type version.
         */
        version?: string;
    }

    /**
     * Diagnostic Entity Properties
     */
    export interface DiagnosticContractPropertiesResponse {
        /**
         * Specifies for what type of messages sampling settings should not apply.
         */
        alwaysLog?: string;
        /**
         * Diagnostic settings for incoming/outgoing HTTP messages to the Backend
         */
        backend?: outputs.apimanagement.PipelineDiagnosticSettingsResponse;
        /**
         * Diagnostic settings for incoming/outgoing HTTP messages to the Gateway.
         */
        frontend?: outputs.apimanagement.PipelineDiagnosticSettingsResponse;
        /**
         * Sets correlation protocol to use for Application Insights diagnostics.
         */
        httpCorrelationProtocol?: string;
        /**
         * Log the ClientIP. Default is false.
         */
        logClientIp?: boolean;
        /**
         * Resource Id of a target logger.
         */
        loggerId: string;
        /**
         * Sampling settings for Diagnostic.
         */
        sampling?: outputs.apimanagement.SamplingSettingsResponse;
        /**
         * The verbosity level applied to traces emitted by trace policies.
         */
        verbosity?: string;
    }

    /**
     * Email Template Contract properties.
     */
    export interface EmailTemplateContractPropertiesResponse {
        /**
         * Email Template Body. This should be a valid XDocument
         */
        body: string;
        /**
         * Description of the Email Template.
         */
        description?: string;
        /**
         * Whether the template is the default template provided by Api Management or has been edited.
         */
        isDefault: boolean;
        /**
         * Email Template Parameter values.
         */
        parameters?: outputs.apimanagement.EmailTemplateParametersContractPropertiesResponse[];
        /**
         * Subject of the Template.
         */
        subject: string;
        /**
         * Title of the Template.
         */
        title?: string;
    }

    /**
     * Email Template Parameter contract.
     */
    export interface EmailTemplateParametersContractPropertiesResponse {
        /**
         * Template parameter description.
         */
        description?: string;
        /**
         * Template parameter name.
         */
        name?: string;
        /**
         * Template parameter title.
         */
        title?: string;
    }

    /**
     * Properties of the Gateway contract.
     */
    export interface GatewayContractPropertiesResponse {
        /**
         * Gateway description
         */
        description?: string;
        /**
         * Gateway location.
         */
        locationData?: outputs.apimanagement.ResourceLocationDataContractResponse;
    }

    /**
     * Gateway hostname configuration details.
     */
    export interface GatewayHostnameConfigurationContractPropertiesResponse {
        /**
         * Identifier of Certificate entity that will be used for TLS connection establishment
         */
        certificateId?: string;
        /**
         * Hostname value. Supports valid domain name, partial or full wildcard
         */
        hostname?: string;
        /**
         * Determines whether gateway requests client certificate
         */
        negotiateClientCertificate?: boolean;
    }

    /**
     * Group contract Properties.
     */
    export interface GroupContractPropertiesResponse {
        /**
         * true if the group is one of the three system groups (Administrators, Developers, or Guests); otherwise false.
         */
        builtIn: boolean;
        /**
         * Group description. Can contain HTML formatting tags.
         */
        description?: string;
        /**
         * Group name.
         */
        displayName: string;
        /**
         * For external groups, this property contains the id of the group from the external identity provider, e.g. for Azure Active Directory `aad://<tenant>.onmicrosoft.com/groups/<group object id>`; otherwise the value is null.
         */
        externalId?: string;
        /**
         * Group type.
         */
        type?: string;
    }

    /**
     * Custom hostname configuration.
     */
    export interface HostnameConfigurationResponse {
        /**
         * Certificate information.
         */
        certificate?: outputs.apimanagement.CertificateInformationResponse;
        /**
         * Certificate Password.
         */
        certificatePassword?: string;
        /**
         * Specify true to setup the certificate associated with this Hostname as the Default SSL Certificate. If a client does not send the SNI header, then this will be the certificate that will be challenged. The property is useful if a service has multiple custom hostname enabled and it needs to decide on the default ssl certificate. The setting only applied to Proxy Hostname Type.
         */
        defaultSslBinding?: boolean;
        /**
         * Base64 Encoded certificate.
         */
        encodedCertificate?: string;
        /**
         * Hostname to configure on the Api Management service.
         */
        hostName: string;
        /**
         * Url to the KeyVault Secret containing the Ssl Certificate. If absolute Url containing version is provided, auto-update of ssl certificate will not work. This requires Api Management service to be configured with MSI. The secret should be of type *application/x-pkcs12*
         */
        keyVaultId?: string;
        /**
         * Specify true to always negotiate client certificate on the hostname. Default Value is false.
         */
        negotiateClientCertificate?: boolean;
        /**
         * Hostname type.
         */
        type: string;
    }

    /**
     * Http message diagnostic settings.
     */
    export interface HttpMessageDiagnosticResponse {
        /**
         * Body logging settings.
         */
        body?: outputs.apimanagement.BodyDiagnosticSettingsResponse;
        /**
         * Array of HTTP Headers to log.
         */
        headers?: string[];
    }

    /**
     * The external Identity Providers like Facebook, Google, Microsoft, Twitter or Azure Active Directory which can be used to enable access to the API Management service developer portal for all users.
     */
    export interface IdentityProviderContractPropertiesResponse {
        /**
         * List of Allowed Tenants when configuring Azure Active Directory login.
         */
        allowedTenants?: string[];
        /**
         * OpenID Connect discovery endpoint hostname for AAD or AAD B2C.
         */
        authority?: string;
        /**
         * Client Id of the Application in the external Identity Provider. It is App ID for Facebook login, Client ID for Google login, App ID for Microsoft.
         */
        clientId: string;
        /**
         * Client secret of the Application in external Identity Provider, used to authenticate login request. For example, it is App Secret for Facebook login, API Key for Google login, Public Key for Microsoft. This property will not be filled on 'GET' operations! Use '/listSecrets' POST request to get the value.
         */
        clientSecret?: string;
        /**
         * Password Reset Policy Name. Only applies to AAD B2C Identity Provider.
         */
        passwordResetPolicyName?: string;
        /**
         * Profile Editing Policy Name. Only applies to AAD B2C Identity Provider.
         */
        profileEditingPolicyName?: string;
        /**
         * Signin Policy Name. Only applies to AAD B2C Identity Provider.
         */
        signinPolicyName?: string;
        /**
         * The TenantId to use instead of Common when logging into Active Directory
         */
        signinTenant?: string;
        /**
         * Signup Policy Name. Only applies to AAD B2C Identity Provider.
         */
        signupPolicyName?: string;
        /**
         * Identity Provider Type identifier.
         */
        type?: string;
    }

    /**
     * Issue Attachment contract Properties.
     */
    export interface IssueAttachmentContractPropertiesResponse {
        /**
         * An HTTP link or Base64-encoded binary data.
         */
        content: string;
        /**
         * Either 'link' if content is provided via an HTTP link or the MIME type of the Base64-encoded binary data provided in the 'content' property.
         */
        contentFormat: string;
        /**
         * Filename by which the binary data will be saved.
         */
        title: string;
    }

    /**
     * Issue Comment contract Properties.
     */
    export interface IssueCommentContractPropertiesResponse {
        /**
         * Date and time when the comment was created.
         */
        createdDate?: string;
        /**
         * Comment text.
         */
        text: string;
        /**
         * A resource identifier for the user who left the comment.
         */
        userId: string;
    }

    /**
     * Issue contract Properties.
     */
    export interface IssueContractPropertiesResponse {
        /**
         * A resource identifier for the API the issue was created for.
         */
        apiId?: string;
        /**
         * Date and time when the issue was created.
         */
        createdDate?: string;
        /**
         * Text describing the issue.
         */
        description: string;
        /**
         * Status of the issue.
         */
        state?: string;
        /**
         * The issue title.
         */
        title: string;
        /**
         * A resource identifier for the user created the issue.
         */
        userId: string;
    }

    /**
     * The Logger entity in API Management represents an event sink that you can use to log API Management events. Currently the Logger entity supports logging API Management events to Azure Event Hubs.
     */
    export interface LoggerContractPropertiesResponse {
        /**
         * The name and SendRule connection string of the event hub for azureEventHub logger.
         * Instrumentation key for applicationInsights logger.
         */
        credentials: {[key: string]: string};
        /**
         * Logger description.
         */
        description?: string;
        /**
         * Whether records are buffered in the logger before publishing. Default is assumed to be true.
         */
        isBuffered?: boolean;
        /**
         * Logger type.
         */
        loggerType: string;
        /**
         * Azure Resource Id of a log target (either Azure Event Hub resource or Azure Application Insights resource).
         */
        resourceId?: string;
    }

    /**
     * NamedValue Contract properties.
     */
    export interface NamedValueContractPropertiesResponse {
        /**
         * Unique name of NamedValue. It may contain only letters, digits, period, dash, and underscore characters.
         */
        displayName: string;
        /**
         * Determines whether the value is a secret and should be encrypted or not. Default value is false.
         */
        secret?: boolean;
        /**
         * Optional tags that when provided can be used to filter the NamedValue list.
         */
        tags?: string[];
        /**
         * Value of the NamedValue. Can contain policy expressions. It may not be empty or consist only of whitespace. This property will not be filled on 'GET' operations! Use '/listSecrets' POST request to get the value.
         */
        value?: string;
    }

    /**
     * API OAuth2 Authentication settings details.
     */
    export interface OAuth2AuthenticationSettingsContractResponse {
        /**
         * OAuth authorization server identifier.
         */
        authorizationServerId?: string;
        /**
         * operations scope.
         */
        scope?: string;
    }

    /**
     * API OAuth2 Authentication settings details.
     */
    export interface OpenIdAuthenticationSettingsContractResponse {
        /**
         * How to send token to the server.
         */
        bearerTokenSendingMethods?: string[];
        /**
         * OAuth authorization server identifier.
         */
        openidProviderId?: string;
    }

    /**
     * OpenID Connect Providers Contract.
     */
    export interface OpenidConnectProviderContractPropertiesResponse {
        /**
         * Client ID of developer console which is the client application.
         */
        clientId: string;
        /**
         * Client Secret of developer console which is the client application.
         */
        clientSecret?: string;
        /**
         * User-friendly description of OpenID Connect Provider.
         */
        description?: string;
        /**
         * User-friendly OpenID Connect Provider name.
         */
        displayName: string;
        /**
         * Metadata endpoint URI.
         */
        metadataEndpoint: string;
    }

    /**
     * Operation Contract Properties
     */
    export interface OperationContractPropertiesResponse {
        /**
         * Description of the operation. May include HTML formatting tags.
         */
        description?: string;
        /**
         * Operation Name.
         */
        displayName: string;
        /**
         * A Valid HTTP Operation Method. Typical Http Methods like GET, PUT, POST but not limited by only them.
         */
        method: string;
        /**
         * Operation Policies
         */
        policies?: string;
        /**
         * An entity containing request details.
         */
        request?: outputs.apimanagement.RequestContractResponse;
        /**
         * Array of Operation responses.
         */
        responses?: outputs.apimanagement.ResponseContractResponse[];
        /**
         * Collection of URL template parameters.
         */
        templateParameters?: outputs.apimanagement.ParameterContractResponse[];
        /**
         * Relative URL template identifying the target resource for this operation. May include parameters. Example: /customers/{cid}/orders/{oid}/?date={date}
         */
        urlTemplate: string;
    }

    /**
     * Operation parameters details.
     */
    export interface ParameterContractResponse {
        /**
         * Default parameter value.
         */
        defaultValue?: string;
        /**
         * Parameter description.
         */
        description?: string;
        /**
         * Parameter name.
         */
        name: string;
        /**
         * Specifies whether parameter is required or not.
         */
        required?: boolean;
        /**
         * Parameter type.
         */
        type: string;
        /**
         * Parameter values.
         */
        values?: string[];
    }

    /**
     * Diagnostic settings for incoming/outgoing HTTP messages to the Gateway.
     */
    export interface PipelineDiagnosticSettingsResponse {
        /**
         * Diagnostic settings for request.
         */
        request?: outputs.apimanagement.HttpMessageDiagnosticResponse;
        /**
         * Diagnostic settings for response.
         */
        response?: outputs.apimanagement.HttpMessageDiagnosticResponse;
    }

    /**
     * Policy contract Properties.
     */
    export interface PolicyContractPropertiesResponse {
        /**
         * Format of the policyContent.
         */
        format?: string;
        /**
         * Contents of the Policy as defined by the format.
         */
        value: string;
    }

    /**
     * Product profile.
     */
    export interface ProductContractPropertiesResponse {
        /**
         * whether subscription approval is required. If false, new subscriptions will be approved automatically enabling developers to call the product’s APIs immediately after subscribing. If true, administrators must manually approve the subscription before the developer can any of the product’s APIs. Can be present only if subscriptionRequired property is present and has a value of false.
         */
        approvalRequired?: boolean;
        /**
         * Product description. May include HTML formatting tags.
         */
        description?: string;
        /**
         * Product name.
         */
        displayName: string;
        /**
         * whether product is published or not. Published products are discoverable by users of developer portal. Non published products are visible only to administrators. Default state of Product is notPublished.
         */
        state?: string;
        /**
         * Whether a product subscription is required for accessing APIs included in this product. If true, the product is referred to as "protected" and a valid subscription key is required for a request to an API included in the product to succeed. If false, the product is referred to as "open" and requests to an API included in the product can be made without a subscription key. If property is omitted when creating a new product it's value is assumed to be true.
         */
        subscriptionRequired?: boolean;
        /**
         * Whether the number of subscriptions a user can have to this product at the same time. Set to null or omit to allow unlimited per user subscriptions. Can be present only if subscriptionRequired property is present and has a value of false.
         */
        subscriptionsLimit?: number;
        /**
         * Product terms of use. Developers trying to subscribe to the product will be presented and required to accept these terms before they can complete the subscription process.
         */
        terms?: string;
    }

    /**
     * Property Contract properties.
     */
    export interface PropertyContractPropertiesResponse {
        /**
         * Unique name of Property. It may contain only letters, digits, period, dash, and underscore characters.
         */
        displayName: string;
        /**
         * Determines whether the value is a secret and should be encrypted or not. Default value is false.
         */
        secret?: boolean;
        /**
         * Optional tags that when provided can be used to filter the property list.
         */
        tags?: string[];
        /**
         * Value of the property. Can contain policy expressions. It may not be empty or consist only of whitespace.
         */
        value: string;
    }

    /**
     * Operation request/response representation details.
     */
    export interface RepresentationContractResponse {
        /**
         * Specifies a registered or custom content type for this representation, e.g. application/xml.
         */
        contentType: string;
        /**
         * Collection of form parameters. Required if 'contentType' value is either 'application/x-www-form-urlencoded' or 'multipart/form-data'..
         */
        formParameters?: outputs.apimanagement.ParameterContractResponse[];
        /**
         * An example of the representation.
         */
        sample?: string;
        /**
         * Schema identifier. Applicable only if 'contentType' value is neither 'application/x-www-form-urlencoded' nor 'multipart/form-data'.
         */
        schemaId?: string;
        /**
         * Type name defined by the schema. Applicable only if 'contentType' value is neither 'application/x-www-form-urlencoded' nor 'multipart/form-data'.
         */
        typeName?: string;
    }

    /**
     * Operation request details.
     */
    export interface RequestContractResponse {
        /**
         * Operation request description.
         */
        description?: string;
        /**
         * Collection of operation request headers.
         */
        headers?: outputs.apimanagement.ParameterContractResponse[];
        /**
         * Collection of operation request query parameters.
         */
        queryParameters?: outputs.apimanagement.ParameterContractResponse[];
        /**
         * Collection of operation request representations.
         */
        representations?: outputs.apimanagement.RepresentationContractResponse[];
    }

    /**
     * Resource location data properties.
     */
    export interface ResourceLocationDataContractResponse {
        /**
         * The city or locality where the resource is located.
         */
        city?: string;
        /**
         * The country or region where the resource is located.
         */
        countryOrRegion?: string;
        /**
         * The district, state, or province where the resource is located.
         */
        district?: string;
        /**
         * A canonical name for the geographic or physical location.
         */
        name: string;
    }

    /**
     * Operation response details.
     */
    export interface ResponseContractResponse {
        /**
         * Operation response description.
         */
        description?: string;
        /**
         * Collection of operation response headers.
         */
        headers?: outputs.apimanagement.ParameterContractResponse[];
        /**
         * Collection of operation response representations.
         */
        representations?: outputs.apimanagement.RepresentationContractResponse[];
        /**
         * Operation response HTTP status code.
         */
        statusCode: number;
    }

    /**
     * Sampling settings for Diagnostic.
     */
    export interface SamplingSettingsResponse {
        /**
         * Rate of sampling for fixed-rate sampling.
         */
        percentage?: number;
        /**
         * Sampling type.
         */
        samplingType?: string;
    }

    /**
     * API Schema create or update contract Properties.
     */
    export interface SchemaContractPropertiesResponse {
        /**
         * Must be a valid a media type used in a Content-Type header as defined in the RFC 2616. Media type of the schema document (e.g. application/json, application/xml). </br> - `Swagger` Schema use `application/vnd.ms-azure-apim.swagger.definitions+json` </br> - `WSDL` Schema use `application/vnd.ms-azure-apim.xsd+xml` </br> - `OpenApi` Schema use `application/vnd.oai.openapi.components+json` </br> - `WADL Schema` use `application/vnd.ms-azure-apim.wadl.grammars+xml`.
         */
        contentType: string;
        /**
         * Create or update Properties of the Schema Document.
         */
        document?: outputs.apimanagement.SchemaDocumentPropertiesResponse;
    }

    /**
     * Schema Document Properties.
     */
    export interface SchemaDocumentPropertiesResponse {
        /**
         * Types definitions. Used for Swagger/OpenAPI schemas only, null otherwise.
         */
        definitions?: {[key: string]: string};
        /**
         * Json escaped string defining the document representing the Schema. Used for schemas other than Swagger/OpenAPI.
         */
        value?: string;
    }

    /**
     * Subscription details.
     */
    export interface SubscriptionContractPropertiesResponse {
        /**
         * Determines whether tracing is enabled
         */
        allowTracing?: boolean;
        /**
         * Subscription creation date. The date conforms to the following format: `yyyy-MM-ddTHH:mm:ssZ` as specified by the ISO 8601 standard.
         */
        createdDate: string;
        /**
         * The name of the subscription, or null if the subscription has no name.
         */
        displayName?: string;
        /**
         * Date when subscription was cancelled or expired. The setting is for audit purposes only and the subscription is not automatically cancelled. The subscription lifecycle can be managed by using the `state` property. The date conforms to the following format: `yyyy-MM-ddTHH:mm:ssZ` as specified by the ISO 8601 standard.
         */
        endDate?: string;
        /**
         * Subscription expiration date. The setting is for audit purposes only and the subscription is not automatically expired. The subscription lifecycle can be managed by using the `state` property. The date conforms to the following format: `yyyy-MM-ddTHH:mm:ssZ` as specified by the ISO 8601 standard.
         */
        expirationDate?: string;
        /**
         * Upcoming subscription expiration notification date. The date conforms to the following format: `yyyy-MM-ddTHH:mm:ssZ` as specified by the ISO 8601 standard.
         */
        notificationDate?: string;
        /**
         * The user resource identifier of the subscription owner. The value is a valid relative URL in the format of /users/{userId} where {userId} is a user identifier.
         */
        ownerId?: string;
        /**
         * Subscription primary key. This property will not be filled on 'GET' operations! Use '/listSecrets' POST request to get the value.
         */
        primaryKey?: string;
        /**
         * Scope like /products/{productId} or /apis or /apis/{apiId}.
         */
        scope: string;
        /**
         * Subscription secondary key. This property will not be filled on 'GET' operations! Use '/listSecrets' POST request to get the value.
         */
        secondaryKey?: string;
        /**
         * Subscription activation date. The setting is for audit purposes only and the subscription is not automatically activated. The subscription lifecycle can be managed by using the `state` property. The date conforms to the following format: `yyyy-MM-ddTHH:mm:ssZ` as specified by the ISO 8601 standard.
         */
        startDate?: string;
        /**
         * Subscription state. Possible states are * active – the subscription is active, * suspended – the subscription is blocked, and the subscriber cannot call any APIs of the product, * submitted – the subscription request has been made by the developer, but has not yet been approved or rejected, * rejected – the subscription request has been denied by an administrator, * cancelled – the subscription has been cancelled by the developer or administrator, * expired – the subscription reached its expiration date and was deactivated.
         */
        state: string;
        /**
         * Optional subscription comment added by an administrator when the state is changed to the 'rejected'.
         */
        stateComment?: string;
    }

    /**
     * Subscription key parameter names details.
     */
    export interface SubscriptionKeyParameterNamesContractResponse {
        /**
         * Subscription key header name.
         */
        header?: string;
        /**
         * Subscription key query string parameter name.
         */
        query?: string;
    }

    /**
     * Tag contract Properties.
     */
    export interface TagContractPropertiesResponse {
        /**
         * Tag name.
         */
        displayName: string;
    }

    /**
     * TagDescription contract Properties.
     */
    export interface TagDescriptionContractPropertiesResponse {
        /**
         * Description of the Tag.
         */
        description?: string;
        /**
         * Tag name.
         */
        displayName?: string;
        /**
         * Description of the external resources describing the tag.
         */
        externalDocsDescription?: string;
        /**
         * Absolute URL of external resources describing the tag.
         */
        externalDocsUrl?: string;
        /**
         * Identifier of the tag in the form of /tags/{tagId}
         */
        tagId?: string;
    }

    /**
     * OAuth acquire token request body parameter (www-url-form-encoded).
     */
    export interface TokenBodyParameterContractResponse {
        /**
         * body parameter name.
         */
        name: string;
        /**
         * body parameter value.
         */
        value: string;
    }

    /**
     * User profile.
     */
    export interface UserContractPropertiesResponse {
        /**
         * Email address.
         */
        email?: string;
        /**
         * First name.
         */
        firstName?: string;
        /**
         * Collection of groups user is part of.
         */
        groups: outputs.apimanagement.GroupContractPropertiesResponse[];
        /**
         * Collection of user identities.
         */
        identities?: outputs.apimanagement.UserIdentityContractResponse[];
        /**
         * Last name.
         */
        lastName?: string;
        /**
         * Optional note about a user set by the administrator.
         */
        note?: string;
        /**
         * Date of user registration. The date conforms to the following format: `yyyy-MM-ddTHH:mm:ssZ` as specified by the ISO 8601 standard.
         */
        registrationDate?: string;
        /**
         * Account state. Specifies whether the user is active or not. Blocked users are unable to sign into the developer portal or call any APIs of subscribed products. Default state is Active.
         */
        state?: string;
    }

    /**
     * User identity details.
     */
    export interface UserIdentityContractResponse {
        /**
         * Identifier value within provider.
         */
        id?: string;
        /**
         * Identity provider name.
         */
        provider?: string;
    }

    /**
     * Configuration of a virtual network to which API Management service is deployed.
     */
    export interface VirtualNetworkConfigurationResponse {
        /**
         * The full resource ID of a subnet in a virtual network to deploy the API Management service in.
         */
        subnetResourceId?: string;
        /**
         * The name of the subnet.
         */
        subnetname: string;
        /**
         * The virtual network ID. This is typically a GUID. Expect a null GUID by default.
         */
        vnetid: string;
    }

    /**
     * Properties of server X509Names.
     */
    export interface X509CertificateNameResponse {
        /**
         * Thumbprint for the Issuer of the Certificate.
         */
        issuerCertificateThumbprint?: string;
        /**
         * Common Name of the Certificate.
         */
        name?: string;
    }
}

export namespace appconfiguration {
    /**
     * The properties of a configuration store.
     */
    export interface ConfigurationStorePropertiesResponse {
        /**
         * The creation date of configuration store.
         */
        creationDate: string;
        /**
         * The encryption settings of the configuration store.
         */
        encryption?: outputs.appconfiguration.EncryptionPropertiesResponse;
        /**
         * The DNS endpoint where the configuration store API will be available.
         */
        endpoint: string;
        /**
         * The list of private endpoint connections that are set up for this resource.
         */
        privateEndpointConnections: outputs.appconfiguration.PrivateEndpointConnectionReferenceResponse[];
        /**
         * The provisioning state of the configuration store.
         */
        provisioningState: string;
        /**
         * Control permission for data plane traffic coming from public networks while private endpoint is enabled.
         */
        publicNetworkAccess?: string;
    }

    /**
     * The encryption settings for a configuration store.
     */
    export interface EncryptionPropertiesResponse {
        /**
         * Key vault properties.
         */
        keyVaultProperties?: outputs.appconfiguration.KeyVaultPropertiesResponse;
    }

    /**
     * Settings concerning key vault encryption for a configuration store.
     */
    export interface KeyVaultPropertiesResponse {
        /**
         * The client id of the identity which will be used to access key vault.
         */
        identityClientId?: string;
        /**
         * The URI of the key vault key used to encrypt data.
         */
        keyIdentifier?: string;
    }

    /**
     * Properties of a private endpoint connection.
     */
    export interface PrivateEndpointConnectionPropertiesResponse {
        /**
         * The resource of private endpoint.
         */
        privateEndpoint?: outputs.appconfiguration.PrivateEndpointResponse;
        /**
         * A collection of information about the state of the connection between service consumer and provider.
         */
        privateLinkServiceConnectionState: outputs.appconfiguration.PrivateLinkServiceConnectionStateResponse;
        /**
         * The provisioning status of the private endpoint connection.
         */
        provisioningState: string;
    }

    /**
     * A reference to a related private endpoint connection.
     */
    export interface PrivateEndpointConnectionReferenceResponse {
        /**
         * The resource ID.
         */
        id: string;
        /**
         * The name of the resource.
         */
        name: string;
        /**
         * The properties of a private endpoint connection.
         */
        properties?: outputs.appconfiguration.PrivateEndpointConnectionPropertiesResponse;
        /**
         * The type of the resource.
         */
        type: string;
    }

    /**
     * Private endpoint which a connection belongs to.
     */
    export interface PrivateEndpointResponse {
        /**
         * The resource Id for private endpoint
         */
        id?: string;
    }

    /**
     * The state of a private link service connection.
     */
    export interface PrivateLinkServiceConnectionStateResponse {
        /**
         * Any action that is required beyond basic workflow (approve/ reject/ disconnect)
         */
        actionsRequired: string;
        /**
         * The private link service connection description.
         */
        description?: string;
        /**
         * The private link service connection status.
         */
        status?: string;
    }

    /**
     * An identity that can be associated with a resource.
     */
    export interface ResourceIdentityResponse {
        /**
         * The principal id of the identity. This property will only be provided for a system-assigned identity.
         */
        principalId: string;
        /**
         * The tenant id associated with the resource's identity. This property will only be provided for a system-assigned identity.
         */
        tenantId: string;
        /**
         * The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user-assigned identities. The type 'None' will remove any identities.
         */
        type?: string;
        /**
         * The list of user-assigned identities associated with the resource. The user-assigned identity dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
         */
        userAssignedIdentities?: {[key: string]: string};
    }

    /**
     * Describes a configuration store SKU.
     */
    export interface SkuResponse {
        /**
         * The SKU name of the configuration store.
         */
        name: string;
    }
}

export namespace authorization {
    /**
     * Lock owner properties.
     */
    export interface ManagementLockOwnerResponse {
        /**
         * The application ID of the lock owner.
         */
        applicationId?: string;
    }

    /**
     * The lock properties.
     */
    export interface ManagementLockPropertiesResponse {
        /**
         * The level of the lock. Possible values are: NotSpecified, CanNotDelete, ReadOnly. CanNotDelete means authorized users are able to read and modify the resources, but not delete. ReadOnly means authorized users can only read from a resource, but they can't modify or delete it.
         */
        level: string;
        /**
         * Notes about the lock. Maximum of 512 characters.
         */
        notes?: string;
        /**
         * The owners of the lock.
         */
        owners?: outputs.authorization.ManagementLockOwnerResponse[];
    }

    /**
     * The parameter definitions for parameters used in the policy. The keys are the parameter names.
     */
    export interface ParameterDefinitionsResponse {
    }

    /**
     * The parameter values for the policy rule. The keys are the parameter names.
     */
    export interface ParameterValuesResponse {
    }

    /**
     * The policy definition group.
     */
    export interface PolicyDefinitionGroupResponse {
        /**
         * A resource ID of a resource that contains additional metadata about the group.
         */
        additionalMetadataId?: string;
        /**
         * The group's category.
         */
        category?: string;
        /**
         * The group's description.
         */
        description?: string;
        /**
         * The group's display name.
         */
        displayName?: string;
        /**
         * The name of the group.
         */
        name: string;
    }

    /**
     * The policy definition properties.
     */
    export interface PolicyDefinitionPropertiesResponse {
        /**
         * The policy definition description.
         */
        description?: string;
        /**
         * The display name of the policy definition.
         */
        displayName?: string;
        /**
         * The policy definition metadata.  Metadata is an open ended object and is typically a collection of key value pairs.
         */
        metadata?: {[key: string]: string};
        /**
         * The policy definition mode. Some examples are All, Indexed, Microsoft.KeyVault.Data.
         */
        mode?: string;
        /**
         * The parameter definitions for parameters used in the policy rule. The keys are the parameter names.
         */
        parameters?: outputs.authorization.ParameterDefinitionsResponse;
        /**
         * The policy rule.
         */
        policyRule?: {[key: string]: string};
        /**
         * The type of policy definition. Possible values are NotSpecified, BuiltIn, Custom, and Static.
         */
        policyType?: string;
    }

    /**
     * The policy definition reference.
     */
    export interface PolicyDefinitionReferenceResponse {
        /**
         * The name of the groups that this policy definition reference belongs to.
         */
        groupNames?: string[];
        /**
         * The parameter values for the referenced policy rule. The keys are the parameter names.
         */
        parameters?: outputs.authorization.ParameterValuesResponse;
        /**
         * The ID of the policy definition or policy set definition.
         */
        policyDefinitionId: string;
        /**
         * A unique id (within the policy set definition) for this policy definition reference.
         */
        policyDefinitionReferenceId?: string;
    }

    /**
     * The policy set definition properties.
     */
    export interface PolicySetDefinitionPropertiesResponse {
        /**
         * The policy set definition description.
         */
        description?: string;
        /**
         * The display name of the policy set definition.
         */
        displayName?: string;
        /**
         * The policy set definition metadata.  Metadata is an open ended object and is typically a collection of key value pairs.
         */
        metadata?: {[key: string]: string};
        /**
         * The policy set definition parameters that can be used in policy definition references.
         */
        parameters?: outputs.authorization.ParameterDefinitionsResponse;
        /**
         * The metadata describing groups of policy definition references within the policy set definition.
         */
        policyDefinitionGroups?: outputs.authorization.PolicyDefinitionGroupResponse[];
        /**
         * An array of policy definition references.
         */
        policyDefinitions: outputs.authorization.PolicyDefinitionReferenceResponse[];
        /**
         * The type of policy definition. Possible values are NotSpecified, BuiltIn, Custom, and Static.
         */
        policyType?: string;
    }
}

export namespace automation {
    /**
     * The properties of the create advanced schedule monthly occurrence.
     */
    export interface AdvancedScheduleMonthlyOccurrenceResponse {
        /**
         * Day of the occurrence. Must be one of monday, tuesday, wednesday, thursday, friday, saturday, sunday.
         */
        day?: string;
        /**
         * Occurrence of the week within the month. Must be between 1 and 5
         */
        occurrence?: number;
    }

    /**
     * The properties of the create Advanced Schedule.
     */
    export interface AdvancedScheduleResponse {
        /**
         * Days of the month that the job should execute on. Must be between 1 and 31.
         */
        monthDays?: number[];
        /**
         * Occurrences of days within a month.
         */
        monthlyOccurrences?: outputs.automation.AdvancedScheduleMonthlyOccurrenceResponse[];
        /**
         * Days of the week that the job should execute on.
         */
        weekDays?: string[];
    }

    /**
     * Definition of the account property.
     */
    export interface AutomationAccountPropertiesResponse {
        /**
         * Gets the creation time.
         */
        creationTime: string;
        /**
         * Gets or sets the description.
         */
        description?: string;
        /**
         * Gets or sets the last modified by.
         */
        lastModifiedBy?: string;
        /**
         * Gets the last modified time.
         */
        lastModifiedTime: string;
        /**
         * Gets or sets the SKU of account.
         */
        sku?: outputs.automation.SkuResponse;
        /**
         * Gets status of account.
         */
        state: string;
    }

    /**
     * Properties of the certificate.
     */
    export interface CertificatePropertiesResponse {
        /**
         * Gets the creation time.
         */
        creationTime: string;
        /**
         * Gets or sets the description.
         */
        description?: string;
        /**
         * Gets the expiry time of the certificate.
         */
        expiryTime: string;
        /**
         * Gets the is exportable flag of the certificate.
         */
        isExportable: boolean;
        /**
         * Gets the last modified time.
         */
        lastModifiedTime: string;
        /**
         * Gets the thumbprint of the certificate.
         */
        thumbprint: string;
    }

    /**
     * Definition of the connection properties.
     */
    export interface ConnectionPropertiesResponse {
        /**
         * Gets or sets the connectionType of the connection.
         */
        connectionType?: outputs.automation.ConnectionTypeAssociationPropertyResponse;
        /**
         * Gets the creation time.
         */
        creationTime: string;
        /**
         * Gets or sets the description.
         */
        description?: string;
        /**
         * Gets the field definition values of the connection.
         */
        fieldDefinitionValues: {[key: string]: string};
        /**
         * Gets the last modified time.
         */
        lastModifiedTime: string;
    }

    /**
     * The connection type property associated with the entity.
     */
    export interface ConnectionTypeAssociationPropertyResponse {
        /**
         * Gets or sets the name of the connection type.
         */
        name?: string;
    }

    /**
     * Properties of the connection type.
     */
    export interface ConnectionTypePropertiesResponse {
        /**
         * Gets the creation time.
         */
        creationTime: string;
        /**
         * Gets or sets the description.
         */
        description?: string;
        /**
         * Gets the field definitions of the connection type.
         */
        fieldDefinitions: {[key: string]: string};
        /**
         * Gets or sets a Boolean value to indicate if the connection type is global.
         */
        isGlobal?: boolean;
        /**
         * Gets or sets the last modified time.
         */
        lastModifiedTime?: string;
    }

    /**
     * Definition of the runbook property type.
     */
    export interface ContentHashResponse {
        /**
         * Gets or sets the content hash algorithm used to hash the content.
         */
        algorithm: string;
        /**
         * Gets or sets expected hash value of the content.
         */
        value: string;
    }

    /**
     * Definition of the content link.
     */
    export interface ContentLinkResponse {
        /**
         * Gets or sets the hash.
         */
        contentHash?: outputs.automation.ContentHashResponse;
        /**
         * Gets or sets the uri of the runbook content.
         */
        uri?: string;
        /**
         * Gets or sets the version of the content.
         */
        version?: string;
    }

    /**
     * Definition of the content source.
     */
    export interface ContentSourceResponse {
        /**
         * Gets or sets the hash.
         */
        hash?: outputs.automation.ContentHashResponse;
        /**
         * Gets or sets the content source type.
         */
        type?: string;
        /**
         * Gets or sets the value of the content. This is based on the content source type.
         */
        value?: string;
        /**
         * Gets or sets the version of the content.
         */
        version?: string;
    }

    /**
     * Definition of the credential properties
     */
    export interface CredentialPropertiesResponse {
        /**
         * Gets the creation time.
         */
        creationTime: string;
        /**
         * Gets or sets the description.
         */
        description?: string;
        /**
         * Gets the last modified time.
         */
        lastModifiedTime: string;
        /**
         * Gets the user name of the credential.
         */
        userName: string;
    }

    /**
     * The Dsc configuration property associated with the entity.
     */
    export interface DscConfigurationAssociationPropertyResponse {
        /**
         * Gets or sets the name of the Dsc configuration.
         */
        name?: string;
    }

    /**
     * Definition of the configuration property type.
     */
    export interface DscConfigurationPropertiesResponse {
        /**
         * Gets or sets the creation time.
         */
        creationTime?: string;
        /**
         * Gets or sets the description.
         */
        description?: string;
        /**
         * Gets or sets the job count of the configuration.
         */
        jobCount?: number;
        /**
         * Gets or sets the last modified time.
         */
        lastModifiedTime?: string;
        /**
         * Gets or sets verbose log option.
         */
        logVerbose?: boolean;
        /**
         * Gets the number of compiled node configurations.
         */
        nodeConfigurationCount?: number;
        /**
         * Gets or sets the configuration parameters.
         */
        parameters?: {[key: string]: string};
        /**
         * Gets or sets the provisioning state of the configuration.
         */
        provisioningState?: string;
        /**
         * Gets or sets the source.
         */
        source?: outputs.automation.ContentSourceResponse;
        /**
         * Gets or sets the state of the configuration.
         */
        state?: string;
    }

    /**
     * Properties for the DscNodeConfiguration
     */
    export interface DscNodeConfigurationPropertiesResponse {
        /**
         * Gets or sets the configuration of the node.
         */
        configuration?: outputs.automation.DscConfigurationAssociationPropertyResponse;
        /**
         * Gets or sets creation time.
         */
        creationTime?: string;
        /**
         * If a new build version of NodeConfiguration is required.
         */
        incrementNodeConfigurationBuild?: boolean;
        /**
         * Gets or sets the last modified time.
         */
        lastModifiedTime?: string;
        /**
         * Number of nodes with this node configuration assigned
         */
        nodeCount?: number;
        /**
         * Source of node configuration.
         */
        source?: string;
    }

    /**
     * Definition of job schedule parameters.
     */
    export interface JobSchedulePropertiesResponse {
        /**
         * Gets or sets the id of job schedule.
         */
        jobScheduleId?: string;
        /**
         * Gets or sets the parameters of the job schedule.
         */
        parameters?: {[key: string]: string};
        /**
         * Gets or sets the hybrid worker group that the scheduled job should run on.
         */
        runOn?: string;
        /**
         * Gets or sets the runbook.
         */
        runbook?: outputs.automation.RunbookAssociationPropertyResponse;
        /**
         * Gets or sets the schedule.
         */
        schedule?: outputs.automation.ScheduleAssociationPropertyResponse;
    }

    /**
     * Automation key which is used to register a DSC Node
     */
    export interface KeyResponse {
        /**
         * Automation key name.
         */
        KeyName: string;
        /**
         * Automation key permissions.
         */
        Permissions: string;
        /**
         * Value of the Automation Key used for registration.
         */
        Value: string;
    }

    /**
     * Definition of the module error info type.
     */
    export interface ModuleErrorInfoResponse {
        /**
         * Gets or sets the error code.
         */
        code?: string;
        /**
         * Gets or sets the error message.
         */
        message?: string;
    }

    /**
     * Definition of the module property type.
     */
    export interface ModulePropertiesResponse {
        /**
         * Gets or sets the activity count of the module.
         */
        activityCount?: number;
        /**
         * Gets or sets the contentLink of the module.
         */
        contentLink?: outputs.automation.ContentLinkResponse;
        /**
         * Gets or sets the creation time.
         */
        creationTime?: string;
        /**
         * Gets or sets the description.
         */
        description?: string;
        /**
         * Gets or sets the error info of the module.
         */
        error?: outputs.automation.ModuleErrorInfoResponse;
        /**
         * Gets or sets type of module, if its composite or not.
         */
        isComposite?: boolean;
        /**
         * Gets or sets the isGlobal flag of the module.
         */
        isGlobal?: boolean;
        /**
         * Gets or sets the last modified time.
         */
        lastModifiedTime?: string;
        /**
         * Gets or sets the provisioning state of the module.
         */
        provisioningState?: string;
        /**
         * Gets or sets the size in bytes of the module.
         */
        sizeInBytes?: number;
        /**
         * Gets or sets the version of the module.
         */
        version?: string;
    }

    /**
     * The runbook property associated with the entity.
     */
    export interface RunbookAssociationPropertyResponse {
        /**
         * Gets or sets the name of the runbook.
         */
        name?: string;
    }

    export interface RunbookDraftResponse {
        /**
         * Gets or sets the creation time of the runbook draft.
         */
        creationTime?: string;
        /**
         * Gets or sets the draft runbook content link.
         */
        draftContentLink?: outputs.automation.ContentLinkResponse;
        /**
         * Gets or sets whether runbook is in edit mode.
         */
        inEdit?: boolean;
        /**
         * Gets or sets the last modified time of the runbook draft.
         */
        lastModifiedTime?: string;
        /**
         * Gets or sets the runbook output types.
         */
        outputTypes?: string[];
        /**
         * Gets or sets the runbook draft parameters.
         */
        parameters?: {[key: string]: string};
    }

    /**
     * Definition of the runbook property type.
     */
    export interface RunbookPropertiesResponse {
        /**
         * Gets or sets the creation time.
         */
        creationTime?: string;
        /**
         * Gets or sets the description.
         */
        description?: string;
        /**
         * Gets or sets the draft runbook properties.
         */
        draft?: outputs.automation.RunbookDraftResponse;
        /**
         * Gets or sets the job count of the runbook.
         */
        jobCount?: number;
        /**
         * Gets or sets the last modified by.
         */
        lastModifiedBy?: string;
        /**
         * Gets or sets the last modified time.
         */
        lastModifiedTime?: string;
        /**
         * Gets or sets the option to log activity trace of the runbook.
         */
        logActivityTrace?: number;
        /**
         * Gets or sets progress log option.
         */
        logProgress?: boolean;
        /**
         * Gets or sets verbose log option.
         */
        logVerbose?: boolean;
        /**
         * Gets or sets the runbook output types.
         */
        outputTypes?: string[];
        /**
         * Gets or sets the runbook parameters.
         */
        parameters?: {[key: string]: string};
        /**
         * Gets or sets the provisioning state of the runbook.
         */
        provisioningState?: string;
        /**
         * Gets or sets the published runbook content link.
         */
        publishContentLink?: outputs.automation.ContentLinkResponse;
        /**
         * Gets or sets the type of the runbook.
         */
        runbookType?: string;
        /**
         * Gets or sets the state of the runbook.
         */
        state?: string;
    }

    /**
     * The schedule property associated with the entity.
     */
    export interface ScheduleAssociationPropertyResponse {
        /**
         * Gets or sets the name of the Schedule.
         */
        name?: string;
    }

    /**
     * Definition of schedule parameters.
     */
    export interface SchedulePropertiesResponse {
        /**
         * Gets or sets the advanced schedule.
         */
        advancedSchedule?: outputs.automation.AdvancedScheduleResponse;
        /**
         * Gets or sets the creation time.
         */
        creationTime?: string;
        /**
         * Gets or sets the description.
         */
        description?: string;
        /**
         * Gets or sets the end time of the schedule.
         */
        expiryTime?: string;
        /**
         * Gets or sets the expiry time's offset in minutes.
         */
        expiryTimeOffsetMinutes?: number;
        /**
         * Gets or sets the frequency of the schedule.
         */
        frequency?: string;
        /**
         * Gets or sets the interval of the schedule.
         */
        interval?: {[key: string]: string};
        /**
         * Gets or sets a value indicating whether this schedule is enabled.
         */
        isEnabled?: boolean;
        /**
         * Gets or sets the last modified time.
         */
        lastModifiedTime?: string;
        /**
         * Gets or sets the next run time of the schedule.
         */
        nextRun?: string;
        /**
         * Gets or sets the next run time's offset in minutes.
         */
        nextRunOffsetMinutes?: number;
        /**
         * Gets or sets the start time of the schedule.
         */
        startTime?: string;
        /**
         * Gets the start time's offset in minutes.
         */
        startTimeOffsetMinutes: number;
        /**
         * Gets or sets the time zone of the schedule.
         */
        timeZone?: string;
    }

    /**
     * The account SKU.
     */
    export interface SkuResponse {
        /**
         * Gets or sets the SKU capacity.
         */
        capacity?: number;
        /**
         * Gets or sets the SKU family.
         */
        family?: string;
        /**
         * Gets or sets the SKU name of the account.
         */
        name: string;
    }

    /**
     * Definition of the variable properties
     */
    export interface VariablePropertiesResponse {
        /**
         * Gets or sets the creation time.
         */
        creationTime?: string;
        /**
         * Gets or sets the description.
         */
        description?: string;
        /**
         * Gets or sets the encrypted flag of the variable.
         */
        isEncrypted?: boolean;
        /**
         * Gets or sets the last modified time.
         */
        lastModifiedTime?: string;
        /**
         * Gets or sets the value of the variable.
         */
        value?: string;
    }

    /**
     * Definition of the watcher properties
     */
    export interface WatcherPropertiesResponse {
        /**
         * Gets or sets the creation time.
         */
        creationTime: string;
        /**
         * Gets or sets the description.
         */
        description?: string;
        /**
         * Gets or sets the frequency at which the watcher is invoked.
         */
        executionFrequencyInSeconds?: number;
        /**
         * Details of the user who last modified the watcher.
         */
        lastModifiedBy: string;
        /**
         * Gets or sets the last modified time.
         */
        lastModifiedTime: string;
        /**
         * Gets or sets the name of the script the watcher is attached to, i.e. the name of an existing runbook.
         */
        scriptName?: string;
        /**
         * Gets or sets the parameters of the script.
         */
        scriptParameters?: {[key: string]: string};
        /**
         * Gets or sets the name of the hybrid worker group the watcher will run on.
         */
        scriptRunOn?: string;
        /**
         * Gets the current status of the watcher.
         */
        status: string;
    }

    /**
     * Definition of the webhook properties
     */
    export interface WebhookPropertiesResponse {
        /**
         * Gets or sets the creation time.
         */
        creationTime?: string;
        /**
         * Gets or sets the description.
         */
        description?: string;
        /**
         * Gets or sets the expiry time.
         */
        expiryTime?: string;
        /**
         * Gets or sets the value of the enabled flag of the webhook.
         */
        isEnabled?: boolean;
        /**
         * Gets or sets the last invoked time.
         */
        lastInvokedTime?: string;
        /**
         * Details of the user who last modified the Webhook
         */
        lastModifiedBy?: string;
        /**
         * Gets or sets the last modified time.
         */
        lastModifiedTime?: string;
        /**
         * Gets or sets the parameters of the job that is created when the webhook calls the runbook it is associated with.
         */
        parameters?: {[key: string]: string};
        /**
         * Gets or sets the name of the hybrid worker group the webhook job will run on.
         */
        runOn?: string;
        /**
         * Gets or sets the runbook the webhook is associated with.
         */
        runbook?: outputs.automation.RunbookAssociationPropertyResponse;
        /**
         * Gets or sets the webhook uri.
         */
        uri?: string;
    }
}

export namespace avs {
    /**
     * An ExpressRoute Circuit
     */
    export interface CircuitResponse {
        /**
         * Identifier of the ExpressRoute Circuit (Microsoft Colo only)
         */
        expressRouteID: string;
        /**
         * ExpressRoute Circuit private peering identifier
         */
        expressRoutePrivatePeeringID: string;
        /**
         * CIDR of primary subnet
         */
        primarySubnet: string;
        /**
         * CIDR of secondary subnet
         */
        secondarySubnet: string;
    }

    /**
     * The properties of a cluster
     */
    export interface ClusterPropertiesResponse {
        /**
         * The identity
         */
        clusterId: number;
        /**
         * The cluster size
         */
        clusterSize: number;
        /**
         * The hosts
         */
        hosts: string[];
        /**
         * The state of the cluster provisioning
         */
        provisioningState: string;
    }

    /**
     * Endpoint addresses
     */
    export interface EndpointsResponse {
        /**
         * Endpoint for the HCX Cloud Manager
         */
        hcxCloudManager: string;
        /**
         * Endpoint for the NSX-T Data Center manager
         */
        nsxtManager: string;
        /**
         * Endpoint for Virtual Center Server Appliance
         */
        vcsa: string;
    }

    /**
     * The properties of an ExpressRoute Circuit Authorization resource
     */
    export interface ExpressRouteAuthorizationPropertiesResponse {
        /**
         * The ID of the ExpressRoute Circuit Authorization
         */
        expressRouteAuthorizationId: string;
        /**
         * The key of the ExpressRoute Circuit Authorization
         */
        expressRouteAuthorizationKey: string;
        /**
         * The state of the  ExpressRoute Circuit Authorization provisioning
         */
        provisioningState: string;
    }

    /**
     * The properties of an HCX Enterprise Site
     */
    export interface HcxEnterpriseSitePropertiesResponse {
        /**
         * The activation key
         */
        activationKey: string;
        /**
         * The status of the HCX Enterprise Site
         */
        status: string;
    }

    /**
     * vCenter Single Sign On Identity Source
     */
    export interface IdentitySourceResponse {
        /**
         * The domain's NetBIOS name
         */
        alias?: string;
        /**
         * The base distinguished name for groups
         */
        baseGroupDN?: string;
        /**
         * The base distinguished name for users
         */
        baseUserDN?: string;
        /**
         * The domain's dns name
         */
        domain?: string;
        /**
         * The name of the identity source
         */
        name?: string;
        /**
         * The password of the Active Directory user with a minimum of read-only access to Base DN for users and groups.
         */
        password?: string;
        /**
         * Primary server URL
         */
        primaryServer?: string;
        /**
         * Secondary server URL
         */
        secondaryServer?: string;
        /**
         * Protect LDAP communication using SSL certificate (LDAPS)
         */
        ssl?: string;
        /**
         * The ID of an Active Directory user with a minimum of read-only access to Base DN for users and group
         */
        username?: string;
    }

    /**
     * The properties of a default cluster
     */
    export interface ManagementClusterResponse {
        /**
         * The identity
         */
        clusterId: number;
        /**
         * The cluster size
         */
        clusterSize: number;
        /**
         * The hosts
         */
        hosts: string[];
    }

    /**
     * The properties of a private cloud resource
     */
    export interface PrivateCloudPropertiesResponse {
        /**
         * An ExpressRoute Circuit
         */
        circuit?: outputs.avs.CircuitResponse;
        /**
         * The endpoints
         */
        endpoints: outputs.avs.EndpointsResponse;
        /**
         * vCenter Single Sign On Identity Sources
         */
        identitySources?: outputs.avs.IdentitySourceResponse[];
        /**
         * Connectivity to internet is enabled or disabled
         */
        internet?: string;
        /**
         * The default cluster used for management
         */
        managementCluster: outputs.avs.ManagementClusterResponse;
        /**
         * Network used to access vCenter Server and NSX-T Manager
         */
        managementNetwork: string;
        /**
         * The block of addresses should be unique across VNet in your subscription as well as on-premise. Make sure the CIDR format is conformed to (A.B.C.D/X) where A,B,C,D are between 0 and 255, and X is between 0 and 22
         */
        networkBlock: string;
        /**
         * Thumbprint of the NSX-T Manager SSL certificate
         */
        nsxtCertificateThumbprint: string;
        /**
         * Optionally, set the NSX-T Manager password when the private cloud is created
         */
        nsxtPassword?: string;
        /**
         * Used for virtual machine cold migration, cloning, and snapshot migration
         */
        provisioningNetwork: string;
        /**
         * The provisioning state
         */
        provisioningState: string;
        /**
         * Thumbprint of the vCenter Server SSL certificate
         */
        vcenterCertificateThumbprint: string;
        /**
         * Optionally, set the vCenter admin password when the private cloud is created
         */
        vcenterPassword?: string;
        /**
         * Used for live migration of virtual machines
         */
        vmotionNetwork: string;
    }

    /**
     * The resource model definition representing SKU
     */
    export interface SkuResponse {
        /**
         * The name of the SKU.
         */
        name: string;
    }
}

export namespace azurestack {
    /**
     * Customer subscription properties.
     */
    export interface CustomerSubscriptionPropertiesResponse {
        /**
         * Tenant Id.
         */
        tenantId?: string;
    }

    /**
     * Data disk image.
     */
    export interface DataDiskImageResponse {
        /**
         * The LUN.
         */
        lun: number;
        /**
         * SAS key for source blob.
         */
        sourceBlobSasUri: string;
    }

    /**
     * Product information.
     */
    export interface ExtendedProductPropertiesResponse {
        /**
         * Specifies kind of compute role included in the package.
         */
        computeRole: string;
        /**
         * List of attached data disks.
         */
        dataDiskImages: outputs.azurestack.DataDiskImageResponse[];
        /**
         * Specifies if product is a Virtual Machine Extension.
         */
        isSystemExtension: boolean;
        /**
         * OS disk image used by product.
         */
        osDiskImage: outputs.azurestack.OsDiskImageResponse;
        /**
         * Specifies a download location where content can be downloaded from.
         */
        sourceBlob: outputs.azurestack.UriResponse;
        /**
         * Indicates if specified product supports multiple extensions.
         */
        supportMultipleExtensions: boolean;
        /**
         * Specifies product version.
         */
        version: string;
        /**
         * Specifies operating system used by the product.
         */
        vmOsType: string;
        /**
         * Indicates if virtual machine Scale Set is enabled in the specified product.
         */
        vmScaleSetEnabled: boolean;
    }

    /**
     * OS disk image.
     */
    export interface OsDiskImageResponse {
        /**
         * OS operating system type.
         */
        operatingSystem: string;
        /**
         * SAS key for source blob.
         */
        sourceBlobSasUri: string;
    }

    /**
     * Properties portion of the registration resource.
     */
    export interface RegistrationPropertiesResponse {
        /**
         * Specifies the billing mode for the Azure Stack registration.
         */
        billingModel?: string;
        /**
         * The identifier of the registered Azure Stack.
         */
        cloudId?: string;
        /**
         * The object identifier associated with the Azure Stack connecting to Azure.
         */
        objectId?: string;
    }

    /**
     * The URI.
     */
    export interface UriResponse {
        /**
         * The URI.
         */
        uri: string;
    }
}

export namespace batch {
    /**
     * Properties of an application package
     */
    export interface ApplicationPackagePropertiesResponse {
        /**
         * The format of the application package, if the package is active.
         */
        format: string;
        /**
         * The time at which the package was last activated, if the package is active.
         */
        lastActivationTime: string;
        /**
         * The current state of the application package.
         */
        state: string;
        /**
         * The URL for the application package in Azure Storage.
         */
        storageUrl: string;
        /**
         * The UTC time at which the Azure Storage URL will expire.
         */
        storageUrlExpiry: string;
    }

    export interface ApplicationPackageReferenceResponse {
        id: string;
        /**
         * If this is omitted, and no default version is specified for this application, the request fails with the error code InvalidApplicationPackageReferences. If you are calling the REST API directly, the HTTP status code is 409.
         */
        version?: string;
    }

    /**
     * The properties associated with the Application.
     */
    export interface ApplicationPropertiesResponse {
        /**
         * A value indicating whether packages within the application may be overwritten using the same version string.
         */
        allowUpdates?: boolean;
        /**
         * The package to use if a client requests the application but does not specify a version. This property can only be set to the name of an existing package.
         */
        defaultVersion?: string;
        /**
         * The display name for the application.
         */
        displayName?: string;
    }

    export interface AutoScaleRunErrorResponse {
        /**
         * An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
         */
        code: string;
        details?: outputs.batch.AutoScaleRunErrorResponse[];
        /**
         * A message describing the error, intended to be suitable for display in a user interface.
         */
        message: string;
    }

    export interface AutoScaleRunResponse {
        error?: outputs.batch.AutoScaleRunErrorResponse;
        evaluationTime: string;
        /**
         * Each variable value is returned in the form $variable=value, and variables are separated by semicolons.
         */
        results?: string;
    }

    export interface AutoScaleSettingsResponse {
        /**
         * If omitted, the default value is 15 minutes (PT15M).
         */
        evaluationInterval?: string;
        formula: string;
    }

    /**
     * Contains information about the auto-storage account associated with a Batch account.
     */
    export interface AutoStoragePropertiesResponse {
        /**
         * The UTC time at which storage keys were last synchronized with the Batch account.
         */
        lastKeySync: string;
        /**
         * The resource ID of the storage account to be used for auto-storage account.
         */
        storageAccountId: string;
    }

    export interface AutoUserSpecificationResponse {
        /**
         * The default value is nonAdmin.
         */
        elevationLevel?: string;
        /**
         * The default value is Pool. If the pool is running Windows a value of Task should be specified if stricter isolation between tasks is required. For example, if the task mutates the registry in a way which could impact other tasks, or if certificates have been specified on the pool which should not be accessible by normal tasks but should be accessible by start tasks.
         */
        scope?: string;
    }

    export interface AzureBlobFileSystemConfigurationResponse {
        /**
         * This property is mutually exclusive with sasKey and one must be specified.
         */
        accountKey?: string;
        accountName: string;
        /**
         * These are 'net use' options in Windows and 'mount' options in Linux.
         */
        blobfuseOptions?: string;
        containerName: string;
        /**
         * All file systems are mounted relative to the Batch mounts directory, accessible via the AZ_BATCH_NODE_MOUNTS_DIR environment variable.
         */
        relativeMountPath: string;
        /**
         * This property is mutually exclusive with accountKey and one must be specified.
         */
        sasKey?: string;
    }

    export interface AzureFileShareConfigurationResponse {
        accountKey: string;
        accountName: string;
        /**
         * This is of the form 'https://{account}.file.core.windows.net/'.
         */
        azureFileUrl: string;
        /**
         * These are 'net use' options in Windows and 'mount' options in Linux.
         */
        mountOptions?: string;
        /**
         * All file systems are mounted relative to the Batch mounts directory, accessible via the AZ_BATCH_NODE_MOUNTS_DIR environment variable.
         */
        relativeMountPath: string;
    }

    /**
     * The identity of the Batch account, if configured. This is only used when the user specifies 'Microsoft.KeyVault' as their Batch account encryption configuration.
     */
    export interface BatchAccountIdentityResponse {
        /**
         * The principal id of the Batch account. This property will only be provided for a system assigned identity.
         */
        principalId: string;
        /**
         * The tenant id associated with the Batch account. This property will only be provided for a system assigned identity.
         */
        tenantId: string;
        /**
         * The type of identity used for the Batch account.
         */
        type: string;
    }

    /**
     * Account specific properties.
     */
    export interface BatchAccountPropertiesResponse {
        /**
         * The account endpoint used to interact with the Batch service.
         */
        accountEndpoint: string;
        activeJobAndJobScheduleQuota: number;
        /**
         * Contains information about the auto-storage account associated with a Batch account.
         */
        autoStorage: outputs.batch.AutoStoragePropertiesResponse;
        /**
         * For accounts with PoolAllocationMode set to UserSubscription, quota is managed on the subscription so this value is not returned.
         */
        dedicatedCoreQuota: number;
        /**
         * A list of the dedicated core quota per Virtual Machine family for the Batch account. For accounts with PoolAllocationMode set to UserSubscription, quota is managed on the subscription so this value is not returned.
         */
        dedicatedCoreQuotaPerVMFamily: outputs.batch.VirtualMachineFamilyCoreQuotaResponse[];
        /**
         * Batch is transitioning its core quota system for dedicated cores to be enforced per Virtual Machine family. During this transitional phase, the dedicated core quota per Virtual Machine family may not yet be enforced. If this flag is false, dedicated core quota is enforced via the old dedicatedCoreQuota property on the account and does not consider Virtual Machine family. If this flag is true, dedicated core quota is enforced via the dedicatedCoreQuotaPerVMFamily property on the account, and the old dedicatedCoreQuota does not apply.
         */
        dedicatedCoreQuotaPerVMFamilyEnforced: boolean;
        /**
         * Configures how customer data is encrypted inside the Batch account. By default, accounts are encrypted using a Microsoft managed key. For additional control, a customer-managed key can be used instead.
         */
        encryption: outputs.batch.EncryptionPropertiesResponse;
        /**
         * Identifies the Azure key vault associated with a Batch account.
         */
        keyVaultReference: outputs.batch.KeyVaultReferenceResponse;
        /**
         * For accounts with PoolAllocationMode set to UserSubscription, quota is managed on the subscription so this value is not returned.
         */
        lowPriorityCoreQuota: number;
        /**
         * The allocation mode for creating pools in the Batch account.
         */
        poolAllocationMode: string;
        poolQuota: number;
        /**
         * List of private endpoint connections associated with the Batch account
         */
        privateEndpointConnections: outputs.batch.PrivateEndpointConnectionResponse[];
        /**
         * The provisioned state of the resource
         */
        provisioningState: string;
        /**
         * If not specified, the default value is 'enabled'.
         */
        publicNetworkAccess: string;
    }

    export interface CIFSMountConfigurationResponse {
        /**
         * These are 'net use' options in Windows and 'mount' options in Linux.
         */
        mountOptions?: string;
        password: string;
        /**
         * All file systems are mounted relative to the Batch mounts directory, accessible via the AZ_BATCH_NODE_MOUNTS_DIR environment variable.
         */
        relativeMountPath: string;
        source: string;
        username: string;
    }

    /**
     * Certificate properties.
     */
    export interface CertificatePropertiesResponse {
        /**
         * This is only returned when the certificate provisioningState is 'Failed'.
         */
        deleteCertificateError: outputs.batch.DeleteCertificateErrorResponse;
        /**
         * The format of the certificate - either Pfx or Cer. If omitted, the default is Pfx.
         */
        format?: string;
        /**
         * The previous provisioned state of the resource
         */
        previousProvisioningState: string;
        previousProvisioningStateTransitionTime: string;
        provisioningState: string;
        provisioningStateTransitionTime: string;
        /**
         * The public key of the certificate.
         */
        publicData: string;
        /**
         * This must match the thumbprint from the name.
         */
        thumbprint?: string;
        /**
         * This must match the first portion of the certificate name. Currently required to be 'SHA1'.
         */
        thumbprintAlgorithm?: string;
    }

    export interface CertificateReferenceResponse {
        id: string;
        /**
         * The default value is currentUser. This property is applicable only for pools configured with Windows nodes (that is, created with cloudServiceConfiguration, or with virtualMachineConfiguration using a Windows image reference). For Linux compute nodes, the certificates are stored in a directory inside the task working directory and an environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the task to query for this location. For certificates with visibility of 'remoteUser', a 'certs' directory is created in the user's home directory (e.g., /home/{user-name}/certs) and certificates are placed in that directory.
         */
        storeLocation?: string;
        /**
         * This property is applicable only for pools configured with Windows nodes (that is, created with cloudServiceConfiguration, or with virtualMachineConfiguration using a Windows image reference). Common store names include: My, Root, CA, Trust, Disallowed, TrustedPeople, TrustedPublisher, AuthRoot, AddressBook, but any custom store name can also be used. The default value is My.
         */
        storeName?: string;
        visibility?: string[];
    }

    export interface CloudServiceConfigurationResponse {
        /**
         * Possible values are: 2 - OS Family 2, equivalent to Windows Server 2008 R2 SP1. 3 - OS Family 3, equivalent to Windows Server 2012. 4 - OS Family 4, equivalent to Windows Server 2012 R2. 5 - OS Family 5, equivalent to Windows Server 2016. 6 - OS Family 6, equivalent to Windows Server 2019. For more information, see Azure Guest OS Releases (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
         */
        osFamily: string;
        /**
         * The default value is * which specifies the latest operating system version for the specified OS family.
         */
        osVersion?: string;
    }

    export interface ContainerConfigurationResponse {
        /**
         * This is the full image reference, as would be specified to "docker pull". An image will be sourced from the default Docker registry unless the image is fully qualified with an alternative registry.
         */
        containerImageNames?: string[];
        /**
         * If any images must be downloaded from a private registry which requires credentials, then those credentials must be provided here.
         */
        containerRegistries?: outputs.batch.ContainerRegistryResponse[];
        type: string;
    }

    export interface ContainerRegistryResponse {
        password: string;
        /**
         * If omitted, the default is "docker.io".
         */
        registryServer?: string;
        username: string;
    }

    /**
     * Settings which will be used by the data disks associated to Compute Nodes in the Pool. When using attached data disks, you need to mount and format the disks from within a VM to use them.
     */
    export interface DataDiskResponse {
        /**
         * Values are:
         *
         *  none - The caching mode for the disk is not enabled.
         *  readOnly - The caching mode for the disk is read only.
         *  readWrite - The caching mode for the disk is read and write.
         *
         *  The default value for caching is none. For information about the caching options see: https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/27/exploring-windows-azure-drives-disks-and-images/.
         */
        caching?: string;
        diskSizeGB: number;
        /**
         * The lun is used to uniquely identify each data disk. If attaching multiple disks, each should have a distinct lun.
         */
        lun: number;
        /**
         * If omitted, the default is "Standard_LRS". Values are:
         *
         *  Standard_LRS - The data disk should use standard locally redundant storage.
         *  Premium_LRS - The data disk should use premium locally redundant storage.
         */
        storageAccountType?: string;
    }

    /**
     * An error response from the Batch service.
     */
    export interface DeleteCertificateErrorResponse {
        /**
         * An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
         */
        code: string;
        /**
         * A list of additional details about the error.
         */
        details?: outputs.batch.DeleteCertificateErrorResponse[];
        /**
         * A message describing the error, intended to be suitable for display in a user interface.
         */
        message: string;
        /**
         * The target of the particular error. For example, the name of the property in error.
         */
        target?: string;
    }

    export interface DeploymentConfigurationResponse {
        /**
         * This property and virtualMachineConfiguration are mutually exclusive and one of the properties must be specified. This property cannot be specified if the Batch account was created with its poolAllocationMode property set to 'UserSubscription'.
         */
        cloudServiceConfiguration?: outputs.batch.CloudServiceConfigurationResponse;
        /**
         * This property and cloudServiceConfiguration are mutually exclusive and one of the properties must be specified.
         */
        virtualMachineConfiguration?: outputs.batch.VirtualMachineConfigurationResponse;
    }

    /**
     * The disk encryption configuration applied on compute nodes in the pool. Disk encryption configuration is not supported on Linux pool created with Virtual Machine Image or Shared Image Gallery Image.
     */
    export interface DiskEncryptionConfigurationResponse {
        /**
         * On Linux pool, only "TemporaryDisk" is supported; on Windows pool, "OsDisk" and "TemporaryDisk" must be specified.
         */
        targets?: string[];
    }

    /**
     * Configures how customer data is encrypted inside the Batch account. By default, accounts are encrypted using a Microsoft managed key. For additional control, a customer-managed key can be used instead.
     */
    export interface EncryptionPropertiesResponse {
        /**
         * Type of the key source.
         */
        keySource?: string;
        /**
         * Additional details when using Microsoft.KeyVault
         */
        keyVaultProperties?: outputs.batch.KeyVaultPropertiesResponse;
    }

    export interface EnvironmentSettingResponse {
        name: string;
        value?: string;
    }

    export interface FixedScaleSettingsResponse {
        /**
         * If omitted, the default value is Requeue.
         */
        nodeDeallocationOption?: string;
        /**
         * The default value is 15 minutes. Timeout values use ISO 8601 format. For example, use PT10M for 10 minutes. The minimum value is 5 minutes. If you specify a value less than 5 minutes, the Batch service rejects the request with an error; if you are calling the REST API directly, the HTTP status code is 400 (Bad Request).
         */
        resizeTimeout?: string;
        /**
         * At least one of targetDedicatedNodes, targetLowPriorityNodes must be set.
         */
        targetDedicatedNodes?: number;
        /**
         * At least one of targetDedicatedNodes, targetLowPriorityNodes must be set.
         */
        targetLowPriorityNodes?: number;
    }

    export interface ImageReferenceResponse {
        /**
         * This property is mutually exclusive with other properties. The Shared Image Gallery image must have replicas in the same region as the Azure Batch account. For information about the firewall settings for the Batch node agent to communicate with the Batch service see https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
         */
        id?: string;
        /**
         * For example, UbuntuServer or WindowsServer.
         */
        offer?: string;
        /**
         * For example, Canonical or MicrosoftWindowsServer.
         */
        publisher?: string;
        /**
         * For example, 18.04-LTS or 2019-Datacenter.
         */
        sku?: string;
        /**
         * A value of 'latest' can be specified to select the latest version of an image. If omitted, the default is 'latest'.
         */
        version?: string;
    }

    export interface InboundNatPoolResponse {
        /**
         * This must be unique within a Batch pool. Acceptable values are between 1 and 65535 except for 22, 3389, 29876 and 29877 as these are reserved. If any reserved values are provided the request fails with HTTP status code 400.
         */
        backendPort: number;
        /**
         * Acceptable values range between 1 and 65534 except ports from 50000 to 55000 which are reserved by the Batch service. All ranges within a pool must be distinct and cannot overlap. If any reserved or overlapping values are provided the request fails with HTTP status code 400.
         */
        frontendPortRangeEnd: number;
        /**
         * Acceptable values range between 1 and 65534 except ports from 50000 to 55000 which are reserved. All ranges within a pool must be distinct and cannot overlap. If any reserved or overlapping values are provided the request fails with HTTP status code 400.
         */
        frontendPortRangeStart: number;
        /**
         * The name must be unique within a Batch pool, can contain letters, numbers, underscores, periods, and hyphens. Names must start with a letter or number, must end with a letter, number, or underscore, and cannot exceed 77 characters.  If any invalid values are provided the request fails with HTTP status code 400.
         */
        name: string;
        /**
         * The maximum number of rules that can be specified across all the endpoints on a Batch pool is 25. If no network security group rules are specified, a default rule will be created to allow inbound access to the specified backendPort. If the maximum number of network security group rules is exceeded the request fails with HTTP status code 400.
         */
        networkSecurityGroupRules?: outputs.batch.NetworkSecurityGroupRuleResponse[];
        protocol: string;
    }

    /**
     * KeyVault configuration when using an encryption KeySource of Microsoft.KeyVault.
     */
    export interface KeyVaultPropertiesResponse {
        /**
         * Full path to the versioned secret. Example https://mykeyvault.vault.azure.net/keys/testkey/6e34a81fef704045975661e297a4c053. To be usable the following prerequisites must be met:
         *
         *  The Batch Account has a System Assigned identity
         *  The account identity has been granted Key/Get, Key/Unwrap and Key/Wrap permissions
         *  The KeyVault has soft-delete and purge protection enabled
         */
        keyIdentifier?: string;
    }

    /**
     * Identifies the Azure key vault associated with a Batch account.
     */
    export interface KeyVaultReferenceResponse {
        /**
         * The resource ID of the Azure key vault associated with the Batch account.
         */
        id: string;
        /**
         * The URL of the Azure key vault associated with the Batch account.
         */
        url: string;
    }

    export interface LinuxUserConfigurationResponse {
        /**
         * The uid and gid properties must be specified together or not at all. If not specified the underlying operating system picks the gid.
         */
        gid?: number;
        /**
         * The private key must not be password protected. The private key is used to automatically configure asymmetric-key based authentication for SSH between nodes in a Linux pool when the pool's enableInterNodeCommunication property is true (it is ignored if enableInterNodeCommunication is false). It does this by placing the key pair into the user's .ssh directory. If not specified, password-less SSH is not configured between nodes (no modification of the user's .ssh directory is done).
         */
        sshPrivateKey?: string;
        /**
         * The uid and gid properties must be specified together or not at all. If not specified the underlying operating system picks the uid.
         */
        uid?: number;
    }

    /**
     * The Batch service does not assign any meaning to this metadata; it is solely for the use of user code.
     */
    export interface MetadataItemResponse {
        name: string;
        value: string;
    }

    export interface MountConfigurationResponse {
        /**
         * This property is mutually exclusive with all other properties.
         */
        azureBlobFileSystemConfiguration?: outputs.batch.AzureBlobFileSystemConfigurationResponse;
        /**
         * This property is mutually exclusive with all other properties.
         */
        azureFileShareConfiguration?: outputs.batch.AzureFileShareConfigurationResponse;
        /**
         * This property is mutually exclusive with all other properties.
         */
        cifsMountConfiguration?: outputs.batch.CIFSMountConfigurationResponse;
        /**
         * This property is mutually exclusive with all other properties.
         */
        nfsMountConfiguration?: outputs.batch.NFSMountConfigurationResponse;
    }

    export interface NFSMountConfigurationResponse {
        /**
         * These are 'net use' options in Windows and 'mount' options in Linux.
         */
        mountOptions?: string;
        /**
         * All file systems are mounted relative to the Batch mounts directory, accessible via the AZ_BATCH_NODE_MOUNTS_DIR environment variable.
         */
        relativeMountPath: string;
        source: string;
    }

    /**
     * The network configuration for a pool.
     */
    export interface NetworkConfigurationResponse {
        /**
         * Pool endpoint configuration is only supported on pools with the virtualMachineConfiguration property.
         */
        endpointConfiguration?: outputs.batch.PoolEndpointConfigurationResponse;
        /**
         * This property is only supported on Pools with the virtualMachineConfiguration property.
         */
        publicIPAddressConfiguration?: outputs.batch.PublicIPAddressConfigurationResponse;
        /**
         * The virtual network must be in the same region and subscription as the Azure Batch account. The specified subnet should have enough free IP addresses to accommodate the number of nodes in the pool. If the subnet doesn't have enough free IP addresses, the pool will partially allocate compute nodes and a resize error will occur. The 'MicrosoftAzureBatch' service principal must have the 'Classic Virtual Machine Contributor' Role-Based Access Control (RBAC) role for the specified VNet. The specified subnet must allow communication from the Azure Batch service to be able to schedule tasks on the compute nodes. This can be verified by checking if the specified VNet has any associated Network Security Groups (NSG). If communication to the compute nodes in the specified subnet is denied by an NSG, then the Batch service will set the state of the compute nodes to unusable. If the specified VNet has any associated Network Security Groups (NSG), then a few reserved system ports must be enabled for inbound communication. For pools created with a virtual machine configuration, enable ports 29876 and 29877, as well as port 22 for Linux and port 3389 for Windows. For pools created with a cloud service configuration, enable ports 10100, 20100, and 30100. Also enable outbound connections to Azure Storage on port 443. For cloudServiceConfiguration pools, only 'classic' VNETs are supported. For more details see: https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration
         */
        subnetId?: string;
    }

    export interface NetworkSecurityGroupRuleResponse {
        access: string;
        /**
         * Priorities within a pool must be unique and are evaluated in order of priority. The lower the number the higher the priority. For example, rules could be specified with order numbers of 150, 250, and 350. The rule with the order number of 150 takes precedence over the rule that has an order of 250. Allowed priorities are 150 to 4096. If any reserved or duplicate values are provided the request fails with HTTP status code 400.
         */
        priority: number;
        /**
         * Valid values are a single IP address (i.e. 10.10.10.10), IP subnet (i.e. 192.168.1.0/24), default tag, or * (for all addresses).  If any other values are provided the request fails with HTTP status code 400.
         */
        sourceAddressPrefix: string;
        /**
         * Valid values are '*' (for all ports 0 - 65535) or arrays of ports or port ranges (i.e. 100-200). The ports should in the range of 0 to 65535 and the port ranges or ports can't overlap. If any other values are provided the request fails with HTTP status code 400. Default value will be *.
         */
        sourcePortRanges?: string[];
    }

    export interface PoolEndpointConfigurationResponse {
        /**
         * The maximum number of inbound NAT pools per Batch pool is 5. If the maximum number of inbound NAT pools is exceeded the request fails with HTTP status code 400.
         */
        inboundNatPools: outputs.batch.InboundNatPoolResponse[];
    }

    /**
     * Pool properties.
     */
    export interface PoolPropertiesResponse {
        allocationState: string;
        allocationStateTransitionTime: string;
        /**
         * The list of application licenses must be a subset of available Batch service application licenses. If a license is requested which is not supported, pool creation will fail.
         */
        applicationLicenses?: string[];
        /**
         * Changes to application package references affect all new compute nodes joining the pool, but do not affect compute nodes that are already in the pool until they are rebooted or reimaged. There is a maximum of 10 application package references on any given pool.
         */
        applicationPackages?: outputs.batch.ApplicationPackageReferenceResponse[];
        /**
         * This property is set only if the pool automatically scales, i.e. autoScaleSettings are used.
         */
        autoScaleRun: outputs.batch.AutoScaleRunResponse;
        /**
         * For Windows compute nodes, the Batch service installs the certificates to the specified certificate store and location. For Linux compute nodes, the certificates are stored in a directory inside the task working directory and an environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the task to query for this location. For certificates with visibility of 'remoteUser', a 'certs' directory is created in the user's home directory (e.g., /home/{user-name}/certs) and certificates are placed in that directory.
         */
        certificates?: outputs.batch.CertificateReferenceResponse[];
        creationTime: string;
        currentDedicatedNodes: number;
        currentLowPriorityNodes: number;
        /**
         * Using CloudServiceConfiguration specifies that the nodes should be creating using Azure Cloud Services (PaaS), while VirtualMachineConfiguration uses Azure Virtual Machines (IaaS).
         */
        deploymentConfiguration?: outputs.batch.DeploymentConfigurationResponse;
        /**
         * The display name need not be unique and can contain any Unicode characters up to a maximum length of 1024.
         */
        displayName?: string;
        /**
         * This imposes restrictions on which nodes can be assigned to the pool. Enabling this value can reduce the chance of the requested number of nodes to be allocated in the pool. If not specified, this value defaults to 'Disabled'.
         */
        interNodeCommunication?: string;
        /**
         * This is the last time at which the pool level data, such as the targetDedicatedNodes or autoScaleSettings, changed. It does not factor in node-level changes such as a compute node changing state.
         */
        lastModified: string;
        /**
         * The default value is 1. The maximum value is the smaller of 4 times the number of cores of the vmSize of the pool or 256.
         */
        maxTasksPerNode?: number;
        /**
         * The Batch service does not assign any meaning to metadata; it is solely for the use of user code.
         */
        metadata?: outputs.batch.MetadataItemResponse[];
        /**
         * This supports Azure Files, NFS, CIFS/SMB, and Blobfuse.
         */
        mountConfiguration?: outputs.batch.MountConfigurationResponse[];
        /**
         * The network configuration for a pool.
         */
        networkConfiguration?: outputs.batch.NetworkConfigurationResponse;
        provisioningState: string;
        provisioningStateTransitionTime: string;
        /**
         * Describes either the current operation (if the pool AllocationState is Resizing) or the previously completed operation (if the AllocationState is Steady).
         */
        resizeOperationStatus: outputs.batch.ResizeOperationStatusResponse;
        /**
         * Defines the desired size of the pool. This can either be 'fixedScale' where the requested targetDedicatedNodes is specified, or 'autoScale' which defines a formula which is periodically reevaluated. If this property is not specified, the pool will have a fixed scale with 0 targetDedicatedNodes.
         */
        scaleSettings?: outputs.batch.ScaleSettingsResponse;
        /**
         * In an PATCH (update) operation, this property can be set to an empty object to remove the start task from the pool.
         */
        startTask?: outputs.batch.StartTaskResponse;
        /**
         * If not specified, the default is spread.
         */
        taskSchedulingPolicy?: outputs.batch.TaskSchedulingPolicyResponse;
        userAccounts?: outputs.batch.UserAccountResponse[];
        /**
         * For information about available sizes of virtual machines for Cloud Services pools (pools created with cloudServiceConfiguration), see Sizes for Cloud Services (https://azure.microsoft.com/documentation/articles/cloud-services-sizes-specs/). Batch supports all Cloud Services VM sizes except ExtraSmall. For information about available VM sizes for pools using images from the Virtual Machines Marketplace (pools created with virtualMachineConfiguration) see Sizes for Virtual Machines (Linux) (https://azure.microsoft.com/documentation/articles/virtual-machines-linux-sizes/) or Sizes for Virtual Machines (Windows) (https://azure.microsoft.com/documentation/articles/virtual-machines-windows-sizes/). Batch supports all Azure VM sizes except STANDARD_A0 and those with premium storage (STANDARD_GS, STANDARD_DS, and STANDARD_DSV2 series).
         */
        vmSize?: string;
    }

    /**
     * Private endpoint connection properties.
     */
    export interface PrivateEndpointConnectionPropertiesResponse {
        /**
         * The private endpoint of the private endpoint connection.
         */
        privateEndpoint?: outputs.batch.PrivateEndpointResponse;
        /**
         * The private link service connection state of the private endpoint connection
         */
        privateLinkServiceConnectionState?: outputs.batch.PrivateLinkServiceConnectionStateResponse;
        provisioningState: string;
    }

    /**
     * Contains information about a private link resource.
     */
    export interface PrivateEndpointConnectionResponse {
        /**
         * The ETag of the resource, used for concurrency statements.
         */
        etag: string;
        /**
         * The ID of the resource.
         */
        id: string;
        /**
         * The name of the resource.
         */
        name: string;
        /**
         * The properties associated with the private endpoint connection.
         */
        properties?: outputs.batch.PrivateEndpointConnectionPropertiesResponse;
        /**
         * The type of the resource.
         */
        type: string;
    }

    /**
     * The private endpoint of the private endpoint connection.
     */
    export interface PrivateEndpointResponse {
        id: string;
    }

    /**
     * The private link service connection state of the private endpoint connection
     */
    export interface PrivateLinkServiceConnectionStateResponse {
        actionRequired: string;
        description?: string;
        status: string;
    }

    /**
     * The public IP Address configuration of the networking configuration of a Pool.
     */
    export interface PublicIPAddressConfigurationResponse {
        /**
         * The number of IPs specified here limits the maximum size of the Pool - 50 dedicated nodes or 20 low-priority nodes can be allocated for each public IP. For example, a pool needing 150 dedicated VMs would need at least 3 public IPs specified. Each element of this collection is of the form: /subscriptions/{subscription}/resourceGroups/{group}/providers/Microsoft.Network/publicIPAddresses/{ip}.
         */
        ipAddressIds?: string[];
        /**
         * The default value is BatchManaged
         */
        provision?: string;
    }

    export interface ResizeErrorResponse {
        /**
         * An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
         */
        code: string;
        details?: outputs.batch.ResizeErrorResponse[];
        /**
         * A message describing the error, intended to be suitable for display in a user interface.
         */
        message: string;
    }

    /**
     * Describes either the current operation (if the pool AllocationState is Resizing) or the previously completed operation (if the AllocationState is Steady).
     */
    export interface ResizeOperationStatusResponse {
        /**
         * This property is set only if an error occurred during the last pool resize, and only when the pool allocationState is Steady.
         */
        errors?: outputs.batch.ResizeErrorResponse[];
        /**
         * The default value is requeue.
         */
        nodeDeallocationOption?: string;
        /**
         * The default value is 15 minutes. The minimum value is 5 minutes. If you specify a value less than 5 minutes, the Batch service returns an error; if you are calling the REST API directly, the HTTP status code is 400 (Bad Request).
         */
        resizeTimeout?: string;
        startTime?: string;
        targetDedicatedNodes?: number;
        targetLowPriorityNodes?: number;
    }

    export interface ResourceFileResponse {
        /**
         * The autoStorageContainerName, storageContainerUrl and httpUrl properties are mutually exclusive and one of them must be specified.
         */
        autoStorageContainerName?: string;
        /**
         * The property is valid only when autoStorageContainerName or storageContainerUrl is used. This prefix can be a partial filename or a subdirectory. If a prefix is not specified, all the files in the container will be downloaded.
         */
        blobPrefix?: string;
        /**
         * This property applies only to files being downloaded to Linux compute nodes. It will be ignored if it is specified for a resourceFile which will be downloaded to a Windows node. If this property is not specified for a Linux node, then a default value of 0770 is applied to the file.
         */
        fileMode?: string;
        /**
         * If the httpUrl property is specified, the filePath is required and describes the path which the file will be downloaded to, including the filename. Otherwise, if the autoStorageContainerName or storageContainerUrl property is specified, filePath is optional and is the directory to download the files to. In the case where filePath is used as a directory, any directory structure already associated with the input data will be retained in full and appended to the specified filePath directory. The specified relative path cannot break out of the task's working directory (for example by using '..').
         */
        filePath?: string;
        /**
         * The autoStorageContainerName, storageContainerUrl and httpUrl properties are mutually exclusive and one of them must be specified. If the URL is Azure Blob Storage, it must be readable using anonymous access; that is, the Batch service does not present any credentials when downloading the blob. There are two ways to get such a URL for a blob in Azure storage: include a Shared Access Signature (SAS) granting read permissions on the blob, or set the ACL for the blob or its container to allow public access.
         */
        httpUrl?: string;
        /**
         * The autoStorageContainerName, storageContainerUrl and httpUrl properties are mutually exclusive and one of them must be specified. This URL must be readable and listable using anonymous access; that is, the Batch service does not present any credentials when downloading the blob. There are two ways to get such a URL for a blob in Azure storage: include a Shared Access Signature (SAS) granting read and list permissions on the blob, or set the ACL for the blob or its container to allow public access.
         */
        storageContainerUrl?: string;
    }

    /**
     * Defines the desired size of the pool. This can either be 'fixedScale' where the requested targetDedicatedNodes is specified, or 'autoScale' which defines a formula which is periodically reevaluated. If this property is not specified, the pool will have a fixed scale with 0 targetDedicatedNodes.
     */
    export interface ScaleSettingsResponse {
        /**
         * This property and fixedScale are mutually exclusive and one of the properties must be specified.
         */
        autoScale?: outputs.batch.AutoScaleSettingsResponse;
        /**
         * This property and autoScale are mutually exclusive and one of the properties must be specified.
         */
        fixedScale?: outputs.batch.FixedScaleSettingsResponse;
    }

    /**
     * In some cases the start task may be re-run even though the node was not rebooted. Due to this, start tasks should be idempotent and exit gracefully if the setup they're performing has already been done. Special care should be taken to avoid start tasks which create breakaway process or install/launch services from the start task working directory, as this will block Batch from being able to re-run the start task.
     */
    export interface StartTaskResponse {
        /**
         * The command line does not run under a shell, and therefore cannot take advantage of shell features such as environment variable expansion. If you want to take advantage of such features, you should invoke the shell in the command line, for example using "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux. Required if any other properties of the startTask are specified.
         */
        commandLine?: string;
        /**
         * When this is specified, all directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the root of Azure Batch directories on the node) are mapped into the container, all task environment variables are mapped into the container, and the task command line is executed in the container.
         */
        containerSettings?: outputs.batch.TaskContainerSettingsResponse;
        environmentSettings?: outputs.batch.EnvironmentSettingResponse[];
        /**
         * The Batch service retries a task if its exit code is nonzero. Note that this value specifically controls the number of retries. The Batch service will try the task once, and may then retry up to this limit. For example, if the maximum retry count is 3, Batch tries the task up to 4 times (one initial try and 3 retries). If the maximum retry count is 0, the Batch service does not retry the task. If the maximum retry count is -1, the Batch service retries the task without limit.
         */
        maxTaskRetryCount?: number;
        resourceFiles?: outputs.batch.ResourceFileResponse[];
        /**
         * If omitted, the task runs as a non-administrative user unique to the task.
         */
        userIdentity?: outputs.batch.UserIdentityResponse;
        /**
         * If true and the start task fails on a compute node, the Batch service retries the start task up to its maximum retry count (maxTaskRetryCount). If the task has still not completed successfully after all retries, then the Batch service marks the compute node unusable, and will not schedule tasks to it. This condition can be detected via the node state and scheduling error detail. If false, the Batch service will not wait for the start task to complete. In this case, other tasks can start executing on the compute node while the start task is still running; and even if the start task fails, new tasks will continue to be scheduled on the node. The default is true.
         */
        waitForSuccess?: boolean;
    }

    export interface TaskContainerSettingsResponse {
        /**
         * These additional options are supplied as arguments to the "docker create" command, in addition to those controlled by the Batch Service.
         */
        containerRunOptions?: string;
        /**
         * This is the full image reference, as would be specified to "docker pull". If no tag is provided as part of the image name, the tag ":latest" is used as a default.
         */
        imageName: string;
        /**
         * This setting can be omitted if was already provided at pool creation.
         */
        registry?: outputs.batch.ContainerRegistryResponse;
        workingDirectory?: string;
    }

    export interface TaskSchedulingPolicyResponse {
        nodeFillType: string;
    }

    export interface UserAccountResponse {
        /**
         * nonAdmin - The auto user is a standard user without elevated access. admin - The auto user is a user with elevated access and operates with full Administrator permissions. The default value is nonAdmin.
         */
        elevationLevel?: string;
        /**
         * This property is ignored if specified on a Windows pool. If not specified, the user is created with the default options.
         */
        linuxUserConfiguration?: outputs.batch.LinuxUserConfigurationResponse;
        name: string;
        password: string;
        /**
         * This property can only be specified if the user is on a Windows pool. If not specified and on a Windows pool, the user is created with the default options.
         */
        windowsUserConfiguration?: outputs.batch.WindowsUserConfigurationResponse;
    }

    /**
     * Specify either the userName or autoUser property, but not both.
     */
    export interface UserIdentityResponse {
        /**
         * The userName and autoUser properties are mutually exclusive; you must specify one but not both.
         */
        autoUser?: outputs.batch.AutoUserSpecificationResponse;
        /**
         * The userName and autoUser properties are mutually exclusive; you must specify one but not both.
         */
        userName?: string;
    }

    export interface VirtualMachineConfigurationResponse {
        /**
         * If specified, setup is performed on each node in the pool to allow tasks to run in containers. All regular tasks and job manager tasks run on this pool must specify the containerSettings property, and all other tasks may specify it.
         */
        containerConfiguration?: outputs.batch.ContainerConfigurationResponse;
        /**
         * This property must be specified if the compute nodes in the pool need to have empty data disks attached to them.
         */
        dataDisks?: outputs.batch.DataDiskResponse[];
        /**
         * If specified, encryption is performed on each node in the pool during node provisioning.
         */
        diskEncryptionConfiguration?: outputs.batch.DiskEncryptionConfigurationResponse;
        imageReference: outputs.batch.ImageReferenceResponse;
        /**
         * This only applies to images that contain the Windows operating system, and should only be used when you hold valid on-premises licenses for the nodes which will be deployed. If omitted, no on-premises licensing discount is applied. Values are:
         *
         *  Windows_Server - The on-premises license is for Windows Server.
         *  Windows_Client - The on-premises license is for Windows Client.
         */
        licenseType?: string;
        /**
         * The Batch node agent is a program that runs on each node in the pool, and provides the command-and-control interface between the node and the Batch service. There are different implementations of the node agent, known as SKUs, for different operating systems. You must specify a node agent SKU which matches the selected image reference. To get the list of supported node agent SKUs along with their list of verified image references, see the 'List supported node agent SKUs' operation.
         */
        nodeAgentSkuId: string;
        /**
         * This property must not be specified if the imageReference specifies a Linux OS image.
         */
        windowsConfiguration?: outputs.batch.WindowsConfigurationResponse;
    }

    /**
     * A VM Family and its associated core quota for the Batch account.
     */
    export interface VirtualMachineFamilyCoreQuotaResponse {
        /**
         * The core quota for the VM family for the Batch account.
         */
        coreQuota: number;
        /**
         * The Virtual Machine family name.
         */
        name: string;
    }

    export interface WindowsConfigurationResponse {
        /**
         * If omitted, the default value is true.
         */
        enableAutomaticUpdates?: boolean;
    }

    export interface WindowsUserConfigurationResponse {
        /**
         * Specifies login mode for the user. The default value for VirtualMachineConfiguration pools is interactive mode and for CloudServiceConfiguration pools is batch mode.
         */
        loginMode?: string;
    }
}

export namespace batchai {
    /**
     * Azure Application Insights information for performance counters reporting.
     */
    export interface AppInsightsReferenceResponse {
        /**
         * Azure Application Insights component resource ID.
         */
        component: outputs.batchai.ResourceIdResponse;
        /**
         * Value of the Azure Application Insights instrumentation key.
         */
        instrumentationKey?: string;
        /**
         * KeyVault Store and Secret which contains Azure Application Insights instrumentation key. One of instrumentationKey or instrumentationKeySecretReference must be specified.
         */
        instrumentationKeySecretReference?: outputs.batchai.KeyVaultSecretReferenceResponse;
    }

    /**
     * Auto-scale settings for the cluster. The system automatically scales the cluster up and down (within minimumNodeCount and maximumNodeCount) based on the number of queued and running jobs assigned to the cluster.
     */
    export interface AutoScaleSettingsResponse {
        /**
         * The number of compute nodes to allocate on cluster creation. Note that this value is used only during cluster creation. Default: 0.
         */
        initialNodeCount?: number;
        /**
         * The maximum number of compute nodes the cluster can have.
         */
        maximumNodeCount: number;
        /**
         * The minimum number of compute nodes the Batch AI service will try to allocate for the cluster. Note, the actual number of nodes can be less than the specified value if the subscription has not enough quota to fulfill the request.
         */
        minimumNodeCount: number;
    }

    /**
     * Azure Blob Storage Container mounting configuration.
     */
    export interface AzureBlobFileSystemReferenceResponse {
        /**
         * Name of the Azure storage account.
         */
        accountName: string;
        /**
         * Name of the Azure Blob Storage container to mount on the cluster.
         */
        containerName: string;
        /**
         * Information about the Azure storage credentials.
         */
        credentials: outputs.batchai.AzureStorageCredentialsInfoResponse;
        /**
         * Mount options for mounting blobfuse file system.
         */
        mountOptions?: string;
        /**
         * The relative path on the compute node where the Azure File container will be mounted. Note that all cluster level containers will be mounted under $AZ_BATCHAI_MOUNT_ROOT location and all job level containers will be mounted under $AZ_BATCHAI_JOB_MOUNT_ROOT.
         */
        relativeMountPath: string;
    }

    /**
     * Azure File Share mounting configuration.
     */
    export interface AzureFileShareReferenceResponse {
        /**
         * Name of the Azure storage account.
         */
        accountName: string;
        /**
         * URL to access the Azure File.
         */
        azureFileUrl: string;
        /**
         * Information about the Azure storage credentials.
         */
        credentials: outputs.batchai.AzureStorageCredentialsInfoResponse;
        /**
         * File mode for directories on the mounted file share. Default value: 0777.
         */
        directoryMode?: string;
        /**
         * File mode for files on the mounted file share. Default value: 0777.
         */
        fileMode?: string;
        /**
         * The relative path on the compute node where the Azure File share will be mounted. Note that all cluster level file shares will be mounted under $AZ_BATCHAI_MOUNT_ROOT location and all job level file shares will be mounted under $AZ_BATCHAI_JOB_MOUNT_ROOT.
         */
        relativeMountPath: string;
    }

    /**
     * Azure storage account credentials.
     */
    export interface AzureStorageCredentialsInfoResponse {
        /**
         * Storage account key. One of accountKey or accountKeySecretReference must be specified.
         */
        accountKey?: string;
        /**
         * Information about KeyVault secret storing the storage account key. One of accountKey or accountKeySecretReference must be specified.
         */
        accountKeySecretReference?: outputs.batchai.KeyVaultSecretReferenceResponse;
    }

    /**
     * An error response from the Batch AI service.
     */
    export interface BatchAIErrorResponse {
        /**
         * An identifier of the error. Codes are invariant and are intended to be consumed programmatically.
         */
        code: string;
        /**
         * A list of additional details about the error.
         */
        details: outputs.batchai.NameValuePairResponse[];
        /**
         * A message describing the error, intended to be suitable for display in a user interface.
         */
        message: string;
    }

    /**
     * CNTK (aka Microsoft Cognitive Toolkit) job settings.
     */
    export interface CNTKsettingsResponse {
        /**
         * Command line arguments that need to be passed to the python script or cntk executable.
         */
        commandLineArgs?: string;
        /**
         * Specifies the path of the BrainScript config file. This property can be specified only if the languageType is 'BrainScript'.
         */
        configFilePath?: string;
        /**
         * The language to use for launching CNTK (aka Microsoft Cognitive Toolkit) job. Valid values are 'BrainScript' or 'Python'.
         */
        languageType?: string;
        /**
         * Number of processes to launch for the job execution. The default value for this property is equal to nodeCount property
         */
        processCount?: number;
        /**
         * The path to the Python interpreter. This property can be specified only if the languageType is 'Python'.
         */
        pythonInterpreterPath?: string;
        /**
         * Python script to execute. This property can be specified only if the languageType is 'Python'.
         */
        pythonScriptFilePath?: string;
    }

    /**
     * Caffe2 job settings.
     */
    export interface Caffe2SettingsResponse {
        /**
         * Command line arguments that need to be passed to the python script.
         */
        commandLineArgs?: string;
        /**
         * The path to the Python interpreter.
         */
        pythonInterpreterPath?: string;
        /**
         * The python script to execute.
         */
        pythonScriptFilePath: string;
    }

    /**
     * Caffe job settings.
     */
    export interface CaffeSettingsResponse {
        /**
         * Command line arguments that need to be passed to the Caffe job.
         */
        commandLineArgs?: string;
        /**
         * Path of the config file for the job. This property cannot be specified if pythonScriptFilePath is specified.
         */
        configFilePath?: string;
        /**
         * Number of processes to launch for the job execution. The default value for this property is equal to nodeCount property
         */
        processCount?: number;
        /**
         * The path to the Python interpreter. The property can be specified only if the pythonScriptFilePath is specified.
         */
        pythonInterpreterPath?: string;
        /**
         * Python script to execute. This property cannot be specified if configFilePath is specified.
         */
        pythonScriptFilePath?: string;
    }

    /**
     * Chainer job settings.
     */
    export interface ChainerSettingsResponse {
        /**
         * Command line arguments that need to be passed to the python script.
         */
        commandLineArgs?: string;
        /**
         * Number of processes to launch for the job execution. The default value for this property is equal to nodeCount property
         */
        processCount?: number;
        /**
         * The path to the Python interpreter.
         */
        pythonInterpreterPath?: string;
        /**
         * The python script to execute.
         */
        pythonScriptFilePath: string;
    }

    /**
     * Cluster properties.
     */
    export interface ClusterPropertiesResponse {
        /**
         * Allocation state of the cluster. Possible values are: steady - Indicates that the cluster is not resizing. There are no changes to the number of compute nodes in the cluster in progress. A cluster enters this state when it is created and when no operations are being performed on the cluster to change the number of compute nodes. resizing - Indicates that the cluster is resizing; that is, compute nodes are being added to or removed from the cluster.
         */
        allocationState: string;
        /**
         * The time at which the cluster entered its current allocation state.
         */
        allocationStateTransitionTime: string;
        /**
         * The time when the cluster was created.
         */
        creationTime: string;
        /**
         * The number of compute nodes currently assigned to the cluster.
         */
        currentNodeCount: number;
        /**
         * Collection of errors encountered by various compute nodes during node setup.
         */
        errors: outputs.batchai.BatchAIErrorResponse[];
        /**
         * Setup (mount file systems, performance counters settings and custom setup task) to be performed on each compute node in the cluster.
         */
        nodeSetup?: outputs.batchai.NodeSetupResponse;
        /**
         * Counts of various node states on the cluster.
         */
        nodeStateCounts: outputs.batchai.NodeStateCountsResponse;
        /**
         * Provisioning state of the cluster. Possible value are: creating - Specifies that the cluster is being created. succeeded - Specifies that the cluster has been created successfully. failed - Specifies that the cluster creation has failed. deleting - Specifies that the cluster is being deleted.
         */
        provisioningState: string;
        /**
         * Time when the provisioning state was changed.
         */
        provisioningStateTransitionTime: string;
        /**
         * Scale settings of the cluster.
         */
        scaleSettings?: outputs.batchai.ScaleSettingsResponse;
        /**
         * Virtual network subnet resource ID the cluster nodes belong to.
         */
        subnet?: outputs.batchai.ResourceIdResponse;
        /**
         * Administrator user account settings which can be used to SSH to compute nodes.
         */
        userAccountSettings?: outputs.batchai.UserAccountSettingsResponse;
        /**
         * Virtual machine configuration (OS image) of the compute nodes. All nodes in a cluster have the same OS image configuration.
         */
        virtualMachineConfiguration?: outputs.batchai.VirtualMachineConfigurationResponse;
        /**
         * VM priority of cluster nodes.
         */
        vmPriority?: string;
        /**
         * The size of the virtual machines in the cluster. All nodes in a cluster have the same VM size.
         */
        vmSize?: string;
    }

    /**
     * Docker container settings.
     */
    export interface ContainerSettingsResponse {
        /**
         * Information about docker image and docker registry to download the container from.
         */
        imageSourceRegistry: outputs.batchai.ImageSourceRegistryResponse;
        /**
         * Size of /dev/shm. Please refer to docker documentation for supported argument formats.
         */
        shmSize?: string;
    }

    /**
     * Custom MPI job settings.
     */
    export interface CustomMpiSettingsResponse {
        /**
         * The command line to be executed by mpi runtime on each compute node.
         */
        commandLine: string;
        /**
         * Number of processes to launch for the job execution. The default value for this property is equal to nodeCount property
         */
        processCount?: number;
    }

    /**
     * Custom tool kit job settings.
     */
    export interface CustomToolkitSettingsResponse {
        /**
         * The command line to execute on the master node.
         */
        commandLine?: string;
    }

    /**
     * Data disks settings.
     */
    export interface DataDisksResponse {
        /**
         * Caching type for the disks. Available values are none (default), readonly, readwrite. Caching type can be set only for VM sizes supporting premium storage.
         */
        cachingType?: string;
        /**
         * Number of data disks attached to the File Server. If multiple disks attached, they will be configured in RAID level 0.
         */
        diskCount: number;
        /**
         * Disk size in GB for the blank data disks.
         */
        diskSizeInGB: number;
        /**
         * Type of storage account to be used on the disk. Possible values are: Standard_LRS or Premium_LRS. Premium storage account type can only be used with VM sizes supporting premium storage.
         */
        storageAccountType: string;
    }

    /**
     * An environment variable definition.
     */
    export interface EnvironmentVariableResponse {
        /**
         * The name of the environment variable.
         */
        name: string;
        /**
         * The value of the environment variable.
         */
        value: string;
    }

    /**
     * An environment variable with secret value definition.
     */
    export interface EnvironmentVariableWithSecretValueResponse {
        /**
         * The name of the environment variable to store the secret value.
         */
        name: string;
        /**
         * The value of the environment variable. This value will never be reported back by Batch AI.
         */
        value?: string;
        /**
         * KeyVault store and secret which contains the value for the environment variable. One of value or valueSecretReference must be provided.
         */
        valueSecretReference?: outputs.batchai.KeyVaultSecretReferenceResponse;
    }

    /**
     * Experiment properties.
     */
    export interface ExperimentPropertiesResponse {
        /**
         * Time when the Experiment was created.
         */
        creationTime: string;
        /**
         * The provisioned state of the experiment
         */
        provisioningState: string;
        /**
         * The time at which the experiment entered its current provisioning state.
         */
        provisioningStateTransitionTime: string;
    }

    /**
     * File properties.
     */
    export interface FilePropertiesResponse {
        /**
         * The file of the size.
         */
        contentLength: number;
        /**
         * The time at which the file was last modified.
         */
        lastModified: string;
    }

    /**
     * Properties of the file or directory.
     */
    export interface FileResponse {
        /**
         * URL to download the corresponding file. The downloadUrl is not returned for directories.
         */
        downloadUrl: string;
        /**
         * Type of the file. Possible values are file and directory.
         */
        fileType: string;
        /**
         * Name of the file.
         */
        name: string;
        /**
         * The properties associated with the file. The properties are not returned for directories.
         */
        properties?: outputs.batchai.FilePropertiesResponse;
    }

    /**
     * File Server properties.
     */
    export interface FileServerPropertiesResponse {
        /**
         * Time when the FileServer was created.
         */
        creationTime: string;
        /**
         * Information about disks attached to File Server VM.
         */
        dataDisks?: outputs.batchai.DataDisksResponse;
        /**
         * File Server mount settings.
         */
        mountSettings: outputs.batchai.MountSettingsResponse;
        /**
         * Provisioning state of the File Server. Possible values: creating - The File Server is getting created; updating - The File Server creation has been accepted and it is getting updated; deleting - The user has requested that the File Server be deleted, and it is in the process of being deleted; failed - The File Server creation has failed with the specified error code. Details about the error code are specified in the message field; succeeded - The File Server creation has succeeded.
         */
        provisioningState: string;
        /**
         * Time when the provisioning state was changed.
         */
        provisioningStateTransitionTime: string;
        /**
         * SSH configuration for accessing the File Server node.
         */
        sshConfiguration?: outputs.batchai.SshConfigurationResponse;
        /**
         * File Server virtual network subnet resource ID.
         */
        subnet?: outputs.batchai.ResourceIdResponse;
        /**
         * VM size of the File Server.
         */
        vmSize?: string;
    }

    /**
     * File Server mounting configuration.
     */
    export interface FileServerReferenceResponse {
        /**
         * Resource ID of the existing File Server to be mounted.
         */
        fileServer: outputs.batchai.ResourceIdResponse;
        /**
         * Mount options to be passed to mount command.
         */
        mountOptions?: string;
        /**
         * The relative path on the compute node where the File Server will be mounted. Note that all cluster level file servers will be mounted under $AZ_BATCHAI_MOUNT_ROOT location and all job level file servers will be mounted under $AZ_BATCHAI_JOB_MOUNT_ROOT.
         */
        relativeMountPath: string;
        /**
         * File Server directory that needs to be mounted. If this property is not specified, the entire File Server will be mounted.
         */
        sourceDirectory?: string;
    }

    /**
     * Specifies the settings for Horovod job.
     */
    export interface HorovodSettingsResponse {
        /**
         * Command line arguments that need to be passed to the python script.
         */
        commandLineArgs?: string;
        /**
         * Number of processes to launch for the job execution. The default value for this property is equal to nodeCount property
         */
        processCount?: number;
        /**
         * The path to the Python interpreter.
         */
        pythonInterpreterPath?: string;
        /**
         * The python script to execute.
         */
        pythonScriptFilePath: string;
    }

    /**
     * The OS image reference.
     */
    export interface ImageReferenceResponse {
        /**
         * Offer of the image.
         */
        offer: string;
        /**
         * Publisher of the image.
         */
        publisher: string;
        /**
         * SKU of the image.
         */
        sku: string;
        /**
         * Version of the image.
         */
        version?: string;
        /**
         * The ARM resource identifier of the virtual machine image for the compute nodes. This is of the form /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/images/{imageName}. The virtual machine image must be in the same region and subscription as the cluster. For information about the firewall settings for the Batch node agent to communicate with the Batch service see https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration. Note, you need to provide publisher, offer and sku of the base OS image of which the custom image has been derived from.
         */
        virtualMachineImageId?: string;
    }

    /**
     * Information about docker image for the job.
     */
    export interface ImageSourceRegistryResponse {
        /**
         * Credentials to access the private docker repository.
         */
        credentials?: outputs.batchai.PrivateRegistryCredentialsResponse;
        /**
         * The name of the image in the image repository.
         */
        image: string;
        /**
         * URL for image repository.
         */
        serverUrl?: string;
    }

    /**
     * Input directory for the job.
     */
    export interface InputDirectoryResponse {
        /**
         * The ID for the input directory. The job can use AZ_BATCHAI_INPUT_<id> environment variable to find the directory path, where <id> is the value of id attribute.
         */
        id: string;
        /**
         * The path to the input directory.
         */
        path: string;
    }

    /**
     * Job preparation settings.
     */
    export interface JobPreparationResponse {
        /**
         * The command line to execute. If containerSettings is specified on the job, this commandLine will be executed in the same container as job. Otherwise it will be executed on the node.
         */
        commandLine: string;
    }

    /**
     * Job properties.
     */
    export interface JobPropertiesResponse {
        /**
         * Caffe2 job settings.
         */
        caffe2Settings?: outputs.batchai.Caffe2SettingsResponse;
        /**
         * Caffe job settings.
         */
        caffeSettings?: outputs.batchai.CaffeSettingsResponse;
        /**
         * Chainer job settings.
         */
        chainerSettings?: outputs.batchai.ChainerSettingsResponse;
        /**
         * Resource ID of the cluster associated with the job.
         */
        cluster?: outputs.batchai.ResourceIdResponse;
        /**
         * CNTK (aka Microsoft Cognitive Toolkit) job settings.
         */
        cntkSettings?: outputs.batchai.CNTKsettingsResponse;
        /**
         * Constraints associated with the Job.
         */
        constraints?: outputs.batchai.JobPropertiesResponseProperties;
        /**
         * If the container was downloaded as part of cluster setup then the same container image will be used. If not provided, the job will run on the VM.
         */
        containerSettings?: outputs.batchai.ContainerSettingsResponse;
        /**
         * The creation time of the job.
         */
        creationTime: string;
        /**
         * Custom MPI job settings.
         */
        customMpiSettings?: outputs.batchai.CustomMpiSettingsResponse;
        /**
         * Custom tool kit job settings.
         */
        customToolkitSettings?: outputs.batchai.CustomToolkitSettingsResponse;
        /**
         * A collection of user defined environment variables to be setup for the job.
         */
        environmentVariables?: outputs.batchai.EnvironmentVariableResponse[];
        /**
         * Information about the execution of a job.
         */
        executionInfo?: outputs.batchai.JobPropertiesResponseProperties;
        /**
         * The current state of the job. Possible values are: queued - The job is queued and able to run. A job enters this state when it is created, or when it is awaiting a retry after a failed run. running - The job is running on a compute cluster. This includes job-level preparation such as downloading resource files or set up container specified on the job - it does not necessarily mean that the job command line has started executing. terminating - The job is terminated by the user, the terminate operation is in progress. succeeded - The job has completed running successfully and exited with exit code 0. failed - The job has finished unsuccessfully (failed with a non-zero exit code) and has exhausted its retry limit. A job is also marked as failed if an error occurred launching the job.
         */
        executionState: string;
        /**
         * The time at which the job entered its current execution state.
         */
        executionStateTransitionTime: string;
        /**
         * Specifies the settings for Horovod job.
         */
        horovodSettings?: outputs.batchai.HorovodSettingsResponse;
        /**
         * A list of input directories for the job.
         */
        inputDirectories?: outputs.batchai.InputDirectoryResponse[];
        /**
         * A segment of job's output directories path created by Batch AI. Batch AI creates job's output directories under an unique path to avoid conflicts between jobs. This value contains a path segment generated by Batch AI to make the path unique and can be used to find the output directory on the node or mounted filesystem.
         */
        jobOutputDirectoryPathSegment: string;
        /**
         * The specified actions will run on all the nodes that are part of the job
         */
        jobPreparation?: outputs.batchai.JobPreparationResponse;
        /**
         * Collection of mount volumes available to the job during execution. These volumes are mounted before the job execution and unmounted after the job completion. The volumes are mounted at location specified by $AZ_BATCHAI_JOB_MOUNT_ROOT environment variable.
         */
        mountVolumes?: outputs.batchai.MountVolumesResponse;
        /**
         * The job will be gang scheduled on that many compute nodes
         */
        nodeCount?: number;
        /**
         * A list of output directories for the job.
         */
        outputDirectories?: outputs.batchai.OutputDirectoryResponse[];
        /**
         * The provisioned state of the Batch AI job
         */
        provisioningState: string;
        /**
         * The time at which the job entered its current provisioning state.
         */
        provisioningStateTransitionTime: string;
        /**
         * pyTorch job settings.
         */
        pyTorchSettings?: outputs.batchai.PyTorchSettingsResponse;
        /**
         * Scheduling priority associated with the job.
         */
        schedulingPriority?: string;
        /**
         * A collection of user defined environment variables with secret values to be setup for the job. Server will never report values of these variables back.
         */
        secrets?: outputs.batchai.EnvironmentVariableWithSecretValueResponse[];
        /**
         * The path where the Batch AI service stores stdout, stderror and execution log of the job.
         */
        stdOutErrPathPrefix?: string;
        /**
         * TensorFlow job settings.
         */
        tensorFlowSettings?: outputs.batchai.TensorFlowSettingsResponse;
        /**
         * Possible values are: cntk, tensorflow, caffe, caffe2, chainer, pytorch, custom, custommpi, horovod.
         */
        toolType?: string;
    }

    /**
     * Constraints associated with the Job.
     */
    export interface JobPropertiesResponseProperties {
        /**
         * Max time the job can run. Default value: 1 week.
         */
        maxWallClockTime?: string;
    }

    /**
     * Key Vault Secret reference.
     */
    export interface KeyVaultSecretReferenceResponse {
        /**
         * The URL referencing a secret in the Key Vault.
         */
        secretUrl: string;
        /**
         * Fully qualified resource identifier of the Key Vault.
         */
        sourceVault: outputs.batchai.ResourceIdResponse;
    }

    /**
     * Manual scale settings for the cluster.
     */
    export interface ManualScaleSettingsResponse {
        /**
         * An action to be performed when the cluster size is decreasing. The default value is requeue.
         */
        nodeDeallocationOption?: string;
        /**
         * The desired number of compute nodes in the Cluster. Default is 0.
         */
        targetNodeCount: number;
    }

    /**
     * File Server mount Information.
     */
    export interface MountSettingsResponse {
        /**
         * Internal IP address of the File Server which can be used to access the File Server from within the subnet.
         */
        fileServerInternalIP?: string;
        /**
         * Public IP address of the File Server which can be used to SSH to the node from outside of the subnet.
         */
        fileServerPublicIP?: string;
        /**
         * Path where the data disks are mounted on the File Server.
         */
        mountPoint?: string;
    }

    /**
     * Details of volumes to mount on the cluster.
     */
    export interface MountVolumesResponse {
        /**
         * A collection of Azure Blob Containers that are to be mounted to the cluster nodes.
         */
        azureBlobFileSystems?: outputs.batchai.AzureBlobFileSystemReferenceResponse[];
        /**
         * A collection of Azure File Shares that are to be mounted to the cluster nodes.
         */
        azureFileShares?: outputs.batchai.AzureFileShareReferenceResponse[];
        /**
         * A collection of Batch AI File Servers that are to be mounted to the cluster nodes.
         */
        fileServers?: outputs.batchai.FileServerReferenceResponse[];
        /**
         * A collection of unmanaged file systems that are to be mounted to the cluster nodes.
         */
        unmanagedFileSystems?: outputs.batchai.UnmanagedFileSystemReferenceResponse[];
    }

    /**
     * Name-value pair.
     */
    export interface NameValuePairResponse {
        /**
         * The name in the name-value pair.
         */
        name?: string;
        /**
         * The value in the name-value pair.
         */
        value?: string;
    }

    /**
     * Node setup settings.
     */
    export interface NodeSetupResponse {
        /**
         * Mount volumes to be available to setup task and all jobs executing on the cluster. The volumes will be mounted at location specified by $AZ_BATCHAI_MOUNT_ROOT environment variable.
         */
        mountVolumes?: outputs.batchai.MountVolumesResponse;
        /**
         * Settings for performance counters collecting and uploading.
         */
        performanceCountersSettings?: outputs.batchai.PerformanceCountersSettingsResponse;
        /**
         * Setup task to run on cluster nodes when nodes got created or rebooted. The setup task code needs to be idempotent. Generally the setup task is used to download static data that is required for all jobs that run on the cluster VMs and/or to download/install software.
         */
        setupTask?: outputs.batchai.SetupTaskResponse;
    }

    /**
     * Counts of various compute node states on the cluster.
     */
    export interface NodeStateCountsResponse {
        /**
         * Number of compute nodes in idle state.
         */
        idleNodeCount: number;
        /**
         * Number of compute nodes which are leaving the cluster.
         */
        leavingNodeCount: number;
        /**
         * Number of compute nodes which are being prepared.
         */
        preparingNodeCount: number;
        /**
         * Number of compute nodes which are running jobs.
         */
        runningNodeCount: number;
        /**
         * Number of compute nodes which are in unusable state.
         */
        unusableNodeCount: number;
    }

    /**
     * Output directory for the job.
     */
    export interface OutputDirectoryResponse {
        /**
         * The ID of the output directory. The job can use AZ_BATCHAI_OUTPUT_<id> environment variable to find the directory path, where <id> is the value of id attribute.
         */
        id: string;
        /**
         * The prefix path where the output directory will be created. Note, this is an absolute path to prefix. E.g. $AZ_BATCHAI_MOUNT_ROOT/MyNFS/MyLogs. The full path to the output directory by combining pathPrefix, jobOutputDirectoryPathSegment (reported by get job) and pathSuffix.
         */
        pathPrefix: string;
        /**
         * The suffix path where the output directory will be created. E.g. models. You can find the full path to the output directory by combining pathPrefix, jobOutputDirectoryPathSegment (reported by get job) and pathSuffix.
         */
        pathSuffix?: string;
    }

    /**
     * Performance counters reporting settings.
     */
    export interface PerformanceCountersSettingsResponse {
        /**
         * Azure Application Insights information for performance counters reporting. If provided, Batch AI will upload node performance counters to the corresponding Azure Application Insights account.
         */
        appInsightsReference: outputs.batchai.AppInsightsReferenceResponse;
    }

    /**
     * Credentials to access a container image in a private repository.
     */
    export interface PrivateRegistryCredentialsResponse {
        /**
         * User password to login to the docker repository. One of password or passwordSecretReference must be specified.
         */
        password?: string;
        /**
         * KeyVault Secret storing the password. Users can store their secrets in Azure KeyVault and pass it to the Batch AI service to integrate with KeyVault. One of password or passwordSecretReference must be specified.
         */
        passwordSecretReference?: outputs.batchai.KeyVaultSecretReferenceResponse;
        /**
         * User name to login to the repository.
         */
        username: string;
    }

    /**
     * pyTorch job settings.
     */
    export interface PyTorchSettingsResponse {
        /**
         * Command line arguments that need to be passed to the python script.
         */
        commandLineArgs?: string;
        /**
         * Type of the communication backend for distributed jobs. Valid values are 'TCP', 'Gloo' or 'MPI'. Not required for non-distributed jobs.
         */
        communicationBackend?: string;
        /**
         * Number of processes to launch for the job execution. The default value for this property is equal to nodeCount property
         */
        processCount?: number;
        /**
         * The path to the Python interpreter.
         */
        pythonInterpreterPath?: string;
        /**
         * The python script to execute.
         */
        pythonScriptFilePath: string;
    }

    /**
     * Login details to SSH to a compute node in cluster.
     */
    export interface RemoteLoginInformationResponse {
        /**
         * Public IP address of the compute node.
         */
        ipAddress: string;
        /**
         * ID of the compute node.
         */
        nodeId: string;
        /**
         * SSH port number of the node.
         */
        port: number;
    }

    /**
     * Represents a resource ID. For example, for a subnet, it is the resource URL for the subnet.
     */
    export interface ResourceIdResponse {
        /**
         * The ID of the resource
         */
        id: string;
    }

    /**
     * At least one of manual or autoScale settings must be specified. Only one of manual or autoScale settings can be specified. If autoScale settings are specified, the system automatically scales the cluster up and down (within the supplied limits) based on the pending jobs on the cluster.
     */
    export interface ScaleSettingsResponse {
        /**
         * Auto-scale settings for the cluster.
         */
        autoScale?: outputs.batchai.AutoScaleSettingsResponse;
        /**
         * Manual scale settings for the cluster.
         */
        manual?: outputs.batchai.ManualScaleSettingsResponse;
    }

    /**
     * Specifies a setup task which can be used to customize the compute nodes of the cluster.
     */
    export interface SetupTaskResponse {
        /**
         * The command line to be executed on each cluster's node after it being allocated or rebooted. The command is executed in a bash subshell as a root.
         */
        commandLine: string;
        /**
         * A collection of user defined environment variables to be set for setup task.
         */
        environmentVariables?: outputs.batchai.EnvironmentVariableResponse[];
        /**
         * A collection of user defined environment variables with secret values to be set for the setup task. Server will never report values of these variables back.
         */
        secrets?: outputs.batchai.EnvironmentVariableWithSecretValueResponse[];
        /**
         * The prefix of a path where the Batch AI service will upload the stdout, stderr and execution log of the setup task.
         */
        stdOutErrPathPrefix: string;
        /**
         * A path segment appended by Batch AI to stdOutErrPathPrefix to form a path where stdout, stderr and execution log of the setup task will be uploaded. Batch AI creates the setup task output directories under an unique path to avoid conflicts between different clusters. The full path can be obtained by concatenation of stdOutErrPathPrefix and stdOutErrPathSuffix.
         */
        stdOutErrPathSuffix: string;
    }

    /**
     * SSH configuration.
     */
    export interface SshConfigurationResponse {
        /**
         * List of source IP ranges to allow SSH connection from. The default value is '*' (all source IPs are allowed). Maximum number of IP ranges that can be specified is 400.
         */
        publicIPsToAllow?: string[];
        /**
         * Settings for administrator user account to be created on a node. The account can be used to establish SSH connection to the node.
         */
        userAccountSettings: outputs.batchai.UserAccountSettingsResponse;
    }

    /**
     * TensorFlow job settings.
     */
    export interface TensorFlowSettingsResponse {
        /**
         * Command line arguments that need to be passed to the python script for the master task.
         */
        masterCommandLineArgs?: string;
        /**
         * Command line arguments that need to be passed to the python script for the parameter server. Optional for single process jobs.
         */
        parameterServerCommandLineArgs?: string;
        /**
         * The number of parameter server tasks. If specified, the value must be less than or equal to nodeCount. If not specified, the default value is equal to 1 for distributed TensorFlow training. This property can be specified only for distributed TensorFlow training.
         */
        parameterServerCount?: number;
        /**
         * The path to the Python interpreter.
         */
        pythonInterpreterPath?: string;
        /**
         * The python script to execute.
         */
        pythonScriptFilePath: string;
        /**
         * Command line arguments that need to be passed to the python script for the worker task. Optional for single process jobs.
         */
        workerCommandLineArgs?: string;
        /**
         * The number of worker tasks. If specified, the value must be less than or equal to (nodeCount * numberOfGPUs per VM). If not specified, the default value is equal to nodeCount. This property can be specified only for distributed TensorFlow training.
         */
        workerCount?: number;
    }

    /**
     * Unmanaged file system mounting configuration.
     */
    export interface UnmanagedFileSystemReferenceResponse {
        /**
         * Mount command line. Note, Batch AI will append mount path to the command on its own.
         */
        mountCommand: string;
        /**
         * The relative path on the compute node where the unmanaged file system will be mounted. Note that all cluster level unmanaged file systems will be mounted under $AZ_BATCHAI_MOUNT_ROOT location and all job level unmanaged file systems will be mounted under $AZ_BATCHAI_JOB_MOUNT_ROOT.
         */
        relativeMountPath: string;
    }

    /**
     * Settings for user account that gets created on each on the nodes of a cluster.
     */
    export interface UserAccountSettingsResponse {
        /**
         * Name of the administrator user account which can be used to SSH to nodes.
         */
        adminUserName: string;
        /**
         * Password of the administrator user account.
         */
        adminUserPassword?: string;
        /**
         * SSH public key of the administrator user account.
         */
        adminUserSshPublicKey?: string;
    }

    /**
     * VM configuration.
     */
    export interface VirtualMachineConfigurationResponse {
        /**
         * OS image reference for cluster nodes.
         */
        imageReference?: outputs.batchai.ImageReferenceResponse;
    }

    /**
     * Workspace specific properties.
     */
    export interface WorkspacePropertiesResponse {
        /**
         * Time when the Workspace was created.
         */
        creationTime: string;
        /**
         * The provisioned state of the Workspace
         */
        provisioningState: string;
        /**
         * The time at which the workspace entered its current provisioning state.
         */
        provisioningStateTransitionTime: string;
    }
}

export namespace botservice {
    /**
     * The parameters to provide for the Bot.
     */
    export interface BotPropertiesResponse {
        /**
         * Collection of channels for which the bot is configured
         */
        configuredChannels: string[];
        /**
         * The description of the bot
         */
        description?: string;
        /**
         * The Application Insights key
         */
        developerAppInsightKey?: string;
        /**
         * The Application Insights Api Key
         */
        developerAppInsightsApiKey?: string;
        /**
         * The Application Insights App Id
         */
        developerAppInsightsApplicationId?: string;
        /**
         * The Name of the bot
         */
        displayName: string;
        /**
         * Collection of channels for which the bot is enabled
         */
        enabledChannels: string[];
        /**
         * The bot's endpoint
         */
        endpoint: string;
        /**
         * The bot's endpoint version
         */
        endpointVersion: string;
        /**
         * The Icon Url of the bot
         */
        iconUrl?: string;
        /**
         * Collection of LUIS App Ids
         */
        luisAppIds?: string[];
        /**
         * The LUIS Key
         */
        luisKey?: string;
        /**
         * Microsoft App Id for the bot
         */
        msaAppId: string;
    }

    /**
     * Channel definition
     */
    export interface ChannelResponse {
        /**
         * The channel name
         */
        channelName: string;
    }

    /**
     * Extra Parameter in a Connection Setting Properties to indicate service provider specific properties
     */
    export interface ConnectionSettingParameterResponse {
        /**
         * Key for the Connection Setting Parameter.
         */
        key?: string;
        /**
         * Value associated with the Connection Setting Parameter.
         */
        value?: string;
    }

    /**
     * Properties for a Connection Setting Item
     */
    export interface ConnectionSettingPropertiesResponse {
        /**
         * Client Id associated with the Connection Setting.
         */
        clientId?: string;
        /**
         * Client Secret associated with the Connection Setting
         */
        clientSecret?: string;
        /**
         * Service Provider Parameters associated with the Connection Setting
         */
        parameters?: outputs.botservice.ConnectionSettingParameterResponse[];
        /**
         * Scopes associated with the Connection Setting
         */
        scopes?: string;
        /**
         * Service Provider Display Name associated with the Connection Setting
         */
        serviceProviderDisplayName?: string;
        /**
         * Service Provider Id associated with the Connection Setting
         */
        serviceProviderId?: string;
        /**
         * Setting Id set by the service for the Connection Setting.
         */
        settingId: string;
    }

    /**
     * The SKU of the cognitive services account.
     */
    export interface SkuResponse {
        /**
         * The sku name
         */
        name: string;
        /**
         * Gets the sku tier. This is based on the SKU name.
         */
        tier: string;
    }
}

export namespace cache {
    /**
     * Redis cache access keys.
     */
    export interface RedisAccessKeysResponse {
        /**
         * The current primary key that clients can use to authenticate with Redis cache.
         */
        primaryKey: string;
        /**
         * The current secondary key that clients can use to authenticate with Redis cache.
         */
        secondaryKey: string;
    }

    /**
     * Specifies a range of IP addresses permitted to connect to the cache
     */
    export interface RedisFirewallRulePropertiesResponse {
        /**
         * highest IP address included in the range
         */
        endIP: string;
        /**
         * lowest IP address included in the range
         */
        startIP: string;
    }

    /**
     * Properties of a linked server to be returned in get/put response
     */
    export interface RedisLinkedServerPropertiesResponse {
        /**
         * Fully qualified resourceId of the linked redis cache.
         */
        linkedRedisCacheId: string;
        /**
         * Location of the linked redis cache.
         */
        linkedRedisCacheLocation: string;
        /**
         * Terminal state of the link between primary and secondary redis cache.
         */
        provisioningState: string;
        /**
         * Role of the linked server.
         */
        serverRole: string;
    }

    /**
     * Linked server Id
     */
    export interface RedisLinkedServerResponse {
        /**
         * Linked server Id.
         */
        id: string;
    }

    /**
     * Properties of the redis cache.
     */
    export interface RedisPropertiesResponse {
        /**
         * The keys of the Redis cache - not set if this object is not the response to Create or Update redis cache
         */
        accessKeys: outputs.cache.RedisAccessKeysResponse;
        /**
         * Specifies whether the non-ssl Redis server port (6379) is enabled.
         */
        enableNonSslPort?: boolean;
        /**
         * Redis host name.
         */
        hostName: string;
        /**
         * List of the linked servers associated with the cache
         */
        linkedServers: outputs.cache.RedisLinkedServerResponse[];
        /**
         * Optional: requires clients to use a specified TLS version (or higher) to connect (e,g, '1.0', '1.1', '1.2')
         */
        minimumTlsVersion?: string;
        /**
         * Redis non-SSL port.
         */
        port: number;
        /**
         * Redis instance provisioning status.
         */
        provisioningState: string;
        /**
         * All Redis Settings. Few possible keys: rdb-backup-enabled,rdb-storage-connection-string,rdb-backup-frequency,maxmemory-delta,maxmemory-policy,notify-keyspace-events,maxmemory-samples,slowlog-log-slower-than,slowlog-max-len,list-max-ziplist-entries,list-max-ziplist-value,hash-max-ziplist-entries,hash-max-ziplist-value,set-max-intset-entries,zset-max-ziplist-entries,zset-max-ziplist-value etc.
         */
        redisConfiguration?: {[key: string]: string};
        /**
         * Redis version.
         */
        redisVersion: string;
        /**
         * The number of shards to be created on a Premium Cluster Cache.
         */
        shardCount?: number;
        /**
         * The SKU of the Redis cache to deploy.
         */
        sku: outputs.cache.SkuResponse;
        /**
         * Redis SSL port.
         */
        sslPort: number;
        /**
         * Static IP address. Required when deploying a Redis cache inside an existing Azure Virtual Network.
         */
        staticIP?: string;
        /**
         * The full resource ID of a subnet in a virtual network to deploy the Redis cache in. Example format: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/Microsoft.{Network|ClassicNetwork}/VirtualNetworks/vnet1/subnets/subnet1
         */
        subnetId?: string;
        /**
         * A dictionary of tenant settings
         */
        tenantSettings?: {[key: string]: string};
    }

    /**
     * List of patch schedules for a Redis cache.
     */
    export interface ScheduleEntriesResponse {
        /**
         * List of patch schedules for a Redis cache.
         */
        scheduleEntries: outputs.cache.ScheduleEntryResponse[];
    }

    /**
     * Patch schedule entry for a Premium Redis Cache.
     */
    export interface ScheduleEntryResponse {
        /**
         * Day of the week when a cache can be patched.
         */
        dayOfWeek: string;
        /**
         * ISO8601 timespan specifying how much time cache patching can take. 
         */
        maintenanceWindow?: string;
        /**
         * Start hour after which cache patching can start.
         */
        startHourUtc: number;
    }

    /**
     * SKU parameters supplied to the create Redis operation.
     */
    export interface SkuResponse {
        /**
         * The size of the Redis cache to deploy. Valid values: for C (Basic/Standard) family (0, 1, 2, 3, 4, 5, 6), for P (Premium) family (1, 2, 3, 4).
         */
        capacity: number;
        /**
         * The SKU family to use. Valid values: (C, P). (C = Basic/Standard, P = Premium).
         */
        family: string;
        /**
         * The type of Redis cache to deploy. Valid values: (Basic, Standard, Premium)
         */
        name: string;
    }
}

export namespace cdn {
    /**
     * Defines the ARM Resource ID for the linked endpoints
     */
    export interface CdnEndpointResponse {
        /**
         * ARM Resource ID string.
         */
        id?: string;
    }

    /**
     * Defines CDN web application firewall policy properties.
     */
    export interface CdnWebApplicationFirewallPolicyPropertiesResponse {
        /**
         * Describes custom rules inside the policy.
         */
        customRules?: outputs.cdn.CustomRuleListResponse;
        /**
         * Describes Azure CDN endpoints associated with this Web Application Firewall policy.
         */
        endpointLinks: outputs.cdn.CdnEndpointResponse[];
        /**
         * Describes managed rules inside the policy.
         */
        managedRules?: outputs.cdn.ManagedRuleSetListResponse;
        /**
         * Describes  policySettings for policy
         */
        policySettings?: outputs.cdn.PolicySettingsResponse;
        /**
         * Provisioning state of the WebApplicationFirewallPolicy.
         */
        provisioningState: string;
        /**
         * Describes rate limit rules inside the policy.
         */
        rateLimitRules?: outputs.cdn.RateLimitRuleListResponse;
        resourceState: string;
    }

    /**
     * The JSON object that contains the properties of the custom domain to create.
     */
    export interface CustomDomainPropertiesResponse {
        /**
         * Provisioning status of Custom Https of the custom domain.
         */
        customHttpsProvisioningState: string;
        /**
         * Provisioning substate shows the progress of custom HTTPS enabling/disabling process step by step.
         */
        customHttpsProvisioningSubstate: string;
        /**
         * The host name of the custom domain. Must be a domain name.
         */
        hostName: string;
        /**
         * Provisioning status of the custom domain.
         */
        provisioningState: string;
        /**
         * Resource status of the custom domain.
         */
        resourceState: string;
        /**
         * Special validation or data may be required when delivering CDN to some regions due to local compliance reasons. E.g. ICP license number of a custom domain is required to deliver content in China.
         */
        validationData?: string;
    }

    /**
     * Defines contents of custom rules
     */
    export interface CustomRuleListResponse {
        /**
         * List of rules
         */
        rules?: outputs.cdn.CustomRuleResponse[];
    }

    /**
     * Defines the common attributes for a custom rule that can be included in a waf policy
     */
    export interface CustomRuleResponse {
        /**
         * Describes what action to be applied when rule matches
         */
        action: string;
        /**
         * Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
         */
        enabledState?: string;
        /**
         * List of match conditions.
         */
        matchConditions: outputs.cdn.MatchConditionResponse[];
        /**
         * Defines the name of the custom rule
         */
        name: string;
        /**
         * Defines in what order this rule be evaluated in the overall list of custom rules
         */
        priority: number;
    }

    /**
     * Properties of the origin group created on the CDN endpoint.
     */
    export interface DeepCreatedOriginGroupPropertiesResponse {
        /**
         * Health probe settings to the origin that is used to determine the health of the origin.
         */
        healthProbeSettings?: outputs.cdn.HealthProbeParametersResponse;
        /**
         * The source of the content being delivered via CDN within given origin group.
         */
        origins: outputs.cdn.ResourceReferenceResponse[];
        /**
         * The JSON object that contains the properties to determine origin health using real requests/responses.This property is currently not supported.
         */
        responseBasedOriginErrorDetectionSettings?: outputs.cdn.ResponseBasedOriginErrorDetectionParametersResponse;
        /**
         * Time in minutes to shift the traffic to the endpoint gradually when an unhealthy endpoint comes healthy or a new endpoint is added. Default is 10 mins. This property is currently not supported.
         */
        trafficRestorationTimeToHealedOrNewEndpointsInMinutes?: number;
    }

    /**
     * The origin group for CDN content which is added when creating a CDN endpoint. Traffic is sent to the origins within the origin group based on origin health.
     */
    export interface DeepCreatedOriginGroupResponse {
        /**
         * Origin group name which must be unique within the endpoint.
         */
        name: string;
        /**
         * Properties of the origin group created on the CDN endpoint.
         */
        properties?: outputs.cdn.DeepCreatedOriginGroupPropertiesResponse;
    }

    /**
     * Properties of the origin created on the CDN endpoint.
     */
    export interface DeepCreatedOriginPropertiesResponse {
        /**
         * Origin is enabled for load balancing or not. By default, origin is always enabled.
         */
        enabled?: boolean;
        /**
         * The address of the origin. It can be a domain name, IPv4 address, or IPv6 address. This should be unique across all origins in an endpoint.
         */
        hostName: string;
        /**
         * The value of the HTTP port. Must be between 1 and 65535.
         */
        httpPort?: number;
        /**
         * The value of the HTTPS port. Must be between 1 and 65535.
         */
        httpsPort?: number;
        /**
         * The host header value sent to the origin with each request. If you leave this blank, the request hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and Cloud Services require this host header value to match the origin hostname by default.
         */
        originHostHeader?: string;
        /**
         * Priority of origin in given origin group for load balancing. Higher priorities will not be used for load balancing if any lower priority origin is healthy.Must be between 1 and 5.
         */
        priority?: number;
        /**
         * Weight of the origin in given origin group for load balancing. Must be between 1 and 1000
         */
        weight?: number;
    }

    /**
     * The main origin of CDN content which is added when creating a CDN endpoint.
     */
    export interface DeepCreatedOriginResponse {
        /**
         * Origin name which must be unique within the endpoint. 
         */
        name: string;
        /**
         * Properties of the origin created on the CDN endpoint.
         */
        properties?: outputs.cdn.DeepCreatedOriginPropertiesResponse;
    }

    /**
     * An action for the delivery rule.
     */
    export interface DeliveryRuleActionResponse {
        /**
         * The name of the action for the delivery rule.
         */
        name: string;
    }

    /**
     * A condition for the delivery rule.
     */
    export interface DeliveryRuleConditionResponse {
        /**
         * The name of the condition for the delivery rule.
         */
        name: string;
    }

    /**
     * A rule that specifies a set of actions and conditions
     */
    export interface DeliveryRuleResponse {
        /**
         * A list of actions that are executed when all the conditions of a rule are satisfied.
         */
        actions: outputs.cdn.DeliveryRuleActionResponse[];
        /**
         * A list of conditions that must be matched for the actions to be executed
         */
        conditions?: outputs.cdn.DeliveryRuleConditionResponse[];
        /**
         * Name of the rule
         */
        name?: string;
        /**
         * The order in which the rules are applied for the endpoint. Possible values {0,1,2,3,………}. A rule with a lesser order will be applied before a rule with a greater order. Rule with order 0 is a special rule. It does not require any condition and actions listed in it will always be applied.
         */
        order: number;
    }

    /**
     * The JSON object that contains the properties required to create an endpoint.
     */
    export interface EndpointPropertiesResponse {
        /**
         * List of content types on which compression applies. The value should be a valid MIME type.
         */
        contentTypesToCompress?: string[];
        /**
         * A reference to the origin group.
         */
        defaultOriginGroup?: outputs.cdn.ResourceReferenceResponse;
        /**
         * A policy that specifies the delivery rules to be used for an endpoint.
         */
        deliveryPolicy?: outputs.cdn.EndpointPropertiesUpdateParametersResponseProperties;
        /**
         * List of rules defining the user's geo access within a CDN endpoint. Each geo filter defines an access rule to a specified path or content, e.g. block APAC for path /pictures/
         */
        geoFilters?: outputs.cdn.GeoFilterResponse[];
        /**
         * The host name of the endpoint structured as {endpointName}.{DNSZone}, e.g. contoso.azureedge.net
         */
        hostName: string;
        /**
         * Indicates whether content compression is enabled on CDN. Default value is false. If compression is enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on CDN when requested content is smaller than 1 byte or larger than 1 MB.
         */
        isCompressionEnabled?: boolean;
        /**
         * Indicates whether HTTP traffic is allowed on the endpoint. Default value is true. At least one protocol (HTTP or HTTPS) must be allowed.
         */
        isHttpAllowed?: boolean;
        /**
         * Indicates whether HTTPS traffic is allowed on the endpoint. Default value is true. At least one protocol (HTTP or HTTPS) must be allowed.
         */
        isHttpsAllowed?: boolean;
        /**
         * Specifies what scenario the customer wants this CDN endpoint to optimize for, e.g. Download, Media services. With this information, CDN can apply scenario driven optimization.
         */
        optimizationType?: string;
        /**
         * The origin groups comprising of origins that are used for load balancing the traffic based on availability.
         */
        originGroups?: outputs.cdn.DeepCreatedOriginGroupResponse[];
        /**
         * The host header value sent to the origin with each request. This property at Endpoint is only allowed when endpoint uses single origin and can be overridden by the same property specified at origin.If you leave this blank, the request hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and Cloud Services require this host header value to match the origin hostname by default.
         */
        originHostHeader?: string;
        /**
         * A directory path on the origin that CDN can use to retrieve content from, e.g. contoso.cloudapp.net/originpath.
         */
        originPath?: string;
        /**
         * The source of the content being delivered via CDN.
         */
        origins: outputs.cdn.DeepCreatedOriginResponse[];
        /**
         * Path to a file hosted on the origin which helps accelerate delivery of the dynamic content and calculate the most optimal routes for the CDN. This is relative to the origin path. This property is only relevant when using a single origin.
         */
        probePath?: string;
        /**
         * Provisioning status of the endpoint.
         */
        provisioningState: string;
        /**
         * Defines how CDN caches requests that include query strings. You can ignore any query strings when caching, bypass caching to prevent requests that contain query strings from being cached, or cache every request with a unique URL.
         */
        queryStringCachingBehavior?: string;
        /**
         * Resource status of the endpoint.
         */
        resourceState: string;
        /**
         * List of keys used to validate the signed URL hashes.
         */
        urlSigningKeys?: outputs.cdn.UrlSigningKeyResponse[];
        /**
         * Defines the Web Application Firewall policy for the endpoint (if applicable)
         */
        webApplicationFirewallPolicyLink?: outputs.cdn.EndpointPropertiesUpdateParametersResponseProperties;
    }

    /**
     * A policy that specifies the delivery rules to be used for an endpoint.
     */
    export interface EndpointPropertiesUpdateParametersResponseProperties {
        /**
         * User-friendly description of the policy.
         */
        description?: string;
        /**
         * A list of the delivery rules.
         */
        rules: outputs.cdn.DeliveryRuleResponse[];
    }

    /**
     * Rules defining user's geo access within a CDN endpoint.
     */
    export interface GeoFilterResponse {
        /**
         * Action of the geo filter, i.e. allow or block access.
         */
        action: string;
        /**
         * Two letter country codes defining user country access in a geo filter, e.g. AU, MX, US.
         */
        countryCodes: string[];
        /**
         * Relative path applicable to geo filter. (e.g. '/mypictures', '/mypicture/kitty.jpg', and etc.)
         */
        relativePath: string;
    }

    /**
     * The JSON object that contains the properties to send health probes to origin.
     */
    export interface HealthProbeParametersResponse {
        /**
         * The number of seconds between health probes.Default is 240sec.
         */
        probeIntervalInSeconds?: number;
        /**
         * The path relative to the origin that is used to determine the health of the origin.
         */
        probePath?: string;
        /**
         * Protocol to use for health probe.
         */
        probeProtocol?: string;
        /**
         * The type of health probe request that is made.
         */
        probeRequestType?: string;
    }

    /**
     * The JSON object that represents the range for http status codes
     */
    export interface HttpErrorRangeParametersResponse {
        /**
         * The inclusive start of the http status code range.
         */
        begin?: number;
        /**
         * The inclusive end of the http status code range.
         */
        end?: number;
    }

    /**
     * Describes the parameters for using a user's KeyVault for URL Signing Key.
     */
    export interface KeyVaultSigningKeyParametersResponse {
        /**
         * Resource group of the user's Key Vault containing the secret
         */
        resourceGroupName: string;
        /**
         * The name of secret in Key Vault.
         */
        secretName: string;
        /**
         * The version(GUID) of secret in Key Vault.
         */
        secretVersion: string;
        /**
         * Subscription Id of the user's Key Vault containing the secret
         */
        subscriptionId: string;
        /**
         * The name of the user's Key Vault containing the secret
         */
        vaultName: string;
    }

    /**
     * Defines a managed rule group override setting.
     */
    export interface ManagedRuleGroupOverrideResponse {
        /**
         * Describes the managed rule group within the rule set to override
         */
        ruleGroupName: string;
        /**
         * List of rules that will be disabled. If none specified, all rules in the group will be disabled.
         */
        rules?: outputs.cdn.ManagedRuleOverrideResponse[];
    }

    /**
     * Defines a managed rule group override setting.
     */
    export interface ManagedRuleOverrideResponse {
        /**
         * Describes the override action to be applied when rule matches.
         */
        action?: string;
        /**
         * Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
         */
        enabledState?: string;
        /**
         * Identifier for the managed rule.
         */
        ruleId: string;
    }

    /**
     * Defines the list of managed rule sets for the policy.
     */
    export interface ManagedRuleSetListResponse {
        /**
         * List of rule sets.
         */
        managedRuleSets?: outputs.cdn.ManagedRuleSetResponse[];
    }

    /**
     * Defines a managed rule set.
     */
    export interface ManagedRuleSetResponse {
        /**
         * Verizon only : If the rule set supports anomaly detection mode, this describes the threshold for blocking requests.
         */
        anomalyScore?: number;
        /**
         * Defines the rule overrides to apply to the rule set.
         */
        ruleGroupOverrides?: outputs.cdn.ManagedRuleGroupOverrideResponse[];
        /**
         * Defines the rule set type to use.
         */
        ruleSetType: string;
        /**
         * Defines the version of the rule set to use.
         */
        ruleSetVersion: string;
    }

    /**
     * Define match conditions
     */
    export interface MatchConditionResponse {
        /**
         * List of possible match values.
         */
        matchValue: string[];
        /**
         * Match variable to compare against.
         */
        matchVariable: string;
        /**
         * Describes if the result of this condition should be negated.
         */
        negateCondition?: boolean;
        /**
         * Describes operator to be matched
         */
        operator: string;
        /**
         * Selector can used to match a specific key for QueryString, Cookies, RequestHeader or PostArgs.
         */
        selector?: string;
        /**
         * List of transforms.
         */
        transforms?: string[];
    }

    /**
     * The JSON object that contains the properties of the origin group.
     */
    export interface OriginGroupPropertiesResponse {
        /**
         * Health probe settings to the origin that is used to determine the health of the origin.
         */
        healthProbeSettings?: outputs.cdn.HealthProbeParametersResponse;
        /**
         * The source of the content being delivered via CDN within given origin group.
         */
        origins: outputs.cdn.ResourceReferenceResponse[];
        /**
         * Provisioning status of the origin group.
         */
        provisioningState: string;
        /**
         * Resource status of the origin group.
         */
        resourceState: string;
        /**
         * The JSON object that contains the properties to determine origin health using real requests/responses. This property is currently not supported.
         */
        responseBasedOriginErrorDetectionSettings?: outputs.cdn.ResponseBasedOriginErrorDetectionParametersResponse;
        /**
         * Time in minutes to shift the traffic to the endpoint gradually when an unhealthy endpoint comes healthy or a new endpoint is added. Default is 10 mins. This property is currently not supported.
         */
        trafficRestorationTimeToHealedOrNewEndpointsInMinutes?: number;
    }

    /**
     * The JSON object that contains the properties of the origin.
     */
    export interface OriginPropertiesResponse {
        /**
         * Origin is enabled for load balancing or not
         */
        enabled?: boolean;
        /**
         * The address of the origin. Domain names, IPv4 addresses, and IPv6 addresses are supported.This should be unique across all origins in an endpoint.
         */
        hostName: string;
        /**
         * The value of the HTTP port. Must be between 1 and 65535.
         */
        httpPort?: number;
        /**
         * The value of the HTTPS port. Must be between 1 and 65535.
         */
        httpsPort?: number;
        /**
         * The host header value sent to the origin with each request. If you leave this blank, the request hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and Cloud Services require this host header value to match the origin hostname by default. This overrides the host header defined at Endpoint
         */
        originHostHeader?: string;
        /**
         * Priority of origin in given origin group for load balancing. Higher priorities will not be used for load balancing if any lower priority origin is healthy.Must be between 1 and 5
         */
        priority?: number;
        /**
         * Provisioning status of the origin.
         */
        provisioningState: string;
        /**
         * Resource status of the origin.
         */
        resourceState: string;
        /**
         * Weight of the origin in given origin group for load balancing. Must be between 1 and 1000
         */
        weight?: number;
    }

    /**
     * Defines contents of a web application firewall global configuration
     */
    export interface PolicySettingsResponse {
        /**
         * If the action type is block, customer can override the response body. The body must be specified in base64 encoding.
         */
        defaultCustomBlockResponseBody?: string;
        /**
         * If the action type is block, this field defines the default customer overridable http response status code.
         */
        defaultCustomBlockResponseStatusCode?: number;
        /**
         * If action type is redirect, this field represents the default redirect URL for the client.
         */
        defaultRedirectUrl?: string;
        /**
         * describes if the policy is in enabled state or disabled state
         */
        enabledState?: string;
        /**
         * Describes if it is in detection mode or prevention mode at policy level.
         */
        mode?: string;
    }

    /**
     * The JSON object that contains the properties required to create a profile.
     */
    export interface ProfilePropertiesResponse {
        /**
         * Provisioning status of the profile.
         */
        provisioningState: string;
        /**
         * Resource status of the profile.
         */
        resourceState: string;
    }

    /**
     * Defines contents of rate limit rules
     */
    export interface RateLimitRuleListResponse {
        /**
         * List of rules
         */
        rules?: outputs.cdn.RateLimitRuleResponse[];
    }

    /**
     * Defines a rate limiting rule that can be included in a waf policy
     */
    export interface RateLimitRuleResponse {
        /**
         * Describes what action to be applied when rule matches
         */
        action: string;
        /**
         * Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
         */
        enabledState?: string;
        /**
         * List of match conditions.
         */
        matchConditions: outputs.cdn.MatchConditionResponse[];
        /**
         * Defines the name of the custom rule
         */
        name: string;
        /**
         * Defines in what order this rule be evaluated in the overall list of custom rules
         */
        priority: number;
        /**
         * Defines rate limit duration. Default is 1 minute.
         */
        rateLimitDurationInMinutes: number;
        /**
         * Defines rate limit threshold.
         */
        rateLimitThreshold: number;
    }

    /**
     * Reference to another resource.
     */
    export interface ResourceReferenceResponse {
        /**
         * Resource ID.
         */
        id?: string;
    }

    /**
     * The JSON object that contains the properties to determine origin health using real requests/responses.
     */
    export interface ResponseBasedOriginErrorDetectionParametersResponse {
        /**
         * The list of Http status code ranges that are considered as server errors for origin and it is marked as unhealthy.
         */
        httpErrorRanges?: outputs.cdn.HttpErrorRangeParametersResponse[];
        /**
         * Type of response errors for real user requests for which origin will be deemed unhealthy
         */
        responseBasedDetectedErrorTypes?: string;
        /**
         * The percentage of failed requests in the sample where failover should trigger.
         */
        responseBasedFailoverThresholdPercentage?: number;
    }

    /**
     * The pricing tier (defines a CDN provider, feature list and rate) of the CDN profile.
     */
    export interface SkuResponse {
        /**
         * Name of the pricing tier.
         */
        name?: string;
    }

    /**
     * Url signing key
     */
    export interface UrlSigningKeyResponse {
        /**
         * Defines the customer defined key Id. This id will exist in the incoming request to indicate the key used to form the hash.
         */
        keyId: string;
        /**
         * Defines the parameters for using customer key vault for Url Signing Key.
         */
        keySourceParameters: outputs.cdn.KeyVaultSigningKeyParametersResponse;
    }
}

export namespace certificateregistration {
    /**
     * AppServiceCertificateOrder resource specific properties
     */
    export interface AppServiceCertificateOrderResponseProperties {
        /**
         * Reasons why App Service Certificate is not renewable at the current moment.
         */
        appServiceCertificateNotRenewableReasons: string[];
        /**
         * <code>true</code> if the certificate should be automatically renewed when it expires; otherwise, <code>false</code>.
         */
        autoRenew?: boolean;
        /**
         * State of the Key Vault secret.
         */
        certificates?: {[key: string]: string};
        /**
         * Last CSR that was created for this order.
         */
        csr?: string;
        /**
         * Certificate distinguished name.
         */
        distinguishedName?: string;
        /**
         * Domain verification token.
         */
        domainVerificationToken: string;
        /**
         * Certificate expiration time.
         */
        expirationTime: string;
        /**
         * Intermediate certificate.
         */
        intermediate: outputs.certificateregistration.CertificateDetailsResponse;
        /**
         * <code>true</code> if private key is external; otherwise, <code>false</code>.
         */
        isPrivateKeyExternal: boolean;
        /**
         * Certificate key size.
         */
        keySize?: number;
        /**
         * Certificate last issuance time.
         */
        lastCertificateIssuanceTime: string;
        /**
         * Time stamp when the certificate would be auto renewed next
         */
        nextAutoRenewalTimeStamp: string;
        /**
         * Certificate product type.
         */
        productType: string;
        /**
         * Status of certificate order.
         */
        provisioningState: string;
        /**
         * Root certificate.
         */
        root: outputs.certificateregistration.CertificateDetailsResponse;
        /**
         * Current serial number of the certificate.
         */
        serialNumber: string;
        /**
         * Signed certificate.
         */
        signedCertificate: outputs.certificateregistration.CertificateDetailsResponse;
        /**
         * Current order status.
         */
        status: string;
        /**
         * Duration in years (must be between 1 and 3).
         */
        validityInYears?: number;
    }

    /**
     * Key Vault container for a certificate that is purchased through Azure.
     */
    export interface AppServiceCertificateResponse {
        /**
         * Key Vault resource Id.
         */
        keyVaultId?: string;
        /**
         * Key Vault secret name.
         */
        keyVaultSecretName?: string;
        /**
         * Status of the Key Vault secret.
         */
        provisioningState: string;
    }

    /**
     * SSL certificate details.
     */
    export interface CertificateDetailsResponse {
        /**
         * Certificate Issuer.
         */
        issuer: string;
        /**
         * Date Certificate is valid to.
         */
        notAfter: string;
        /**
         * Date Certificate is valid from.
         */
        notBefore: string;
        /**
         * Raw certificate data.
         */
        rawData: string;
        /**
         * Certificate Serial Number.
         */
        serialNumber: string;
        /**
         * Certificate Signature algorithm.
         */
        signatureAlgorithm: string;
        /**
         * Certificate Subject.
         */
        subject: string;
        /**
         * Certificate Thumbprint.
         */
        thumbprint: string;
        /**
         * Certificate Version.
         */
        version: number;
    }

}

export namespace cognitiveservices {
    /**
     * The api properties for special APIs.
     */
    export interface CognitiveServicesAccountApiPropertiesResponse {
        /**
         * (Personalization Only) The flag to enable statistics of Bing Search.
         */
        eventHubConnectionString?: string;
        /**
         * (QnAMaker Only) The runtime endpoint of QnAMaker.
         */
        qnaRuntimeEndpoint?: string;
        /**
         * (Bing Search Only) The flag to enable statistics of Bing Search.
         */
        statisticsEnabled?: boolean;
        /**
         * (Personalization Only) The storage account connection string.
         */
        storageAccountConnectionString?: string;
    }

    /**
     * Properties of Cognitive Services account.
     */
    export interface CognitiveServicesAccountPropertiesResponse {
        /**
         * The api properties for special APIs.
         */
        apiProperties?: outputs.cognitiveservices.CognitiveServicesAccountApiPropertiesResponse;
        /**
         * Gets the capabilities of the cognitive services account. Each item indicates the capability of a specific feature. The values are read-only and for reference only.
         */
        capabilities: outputs.cognitiveservices.SkuCapabilityResponse[];
        /**
         * Optional subdomain name used for token-based authentication.
         */
        customSubDomainName?: string;
        /**
         * The encryption properties for this resource.
         */
        encryption?: outputs.cognitiveservices.EncryptionResponse;
        /**
         * Endpoint of the created account.
         */
        endpoint: string;
        /**
         * The internal identifier.
         */
        internalId: string;
        /**
         * A collection of rules governing the accessibility from specific network locations.
         */
        networkAcls?: outputs.cognitiveservices.NetworkRuleSetResponse;
        /**
         * The private endpoint connection associated with the Cognitive Services account.
         */
        privateEndpointConnections?: outputs.cognitiveservices.PrivateEndpointConnectionResponse[];
        /**
         * Gets the status of the cognitive services account at the time the operation was called.
         */
        provisioningState: string;
        /**
         * Whether or not public endpoint access is allowed for this account. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
         */
        publicNetworkAccess?: string;
        /**
         * The storage accounts for this resource.
         */
        userOwnedStorage?: outputs.cognitiveservices.UserOwnedStorageResponse[];
    }

    /**
     * Properties to configure Encryption
     */
    export interface EncryptionResponse {
        /**
         * Enumerates the possible value of keySource for Encryption
         */
        keySource?: string;
        /**
         * Properties of KeyVault
         */
        keyVaultProperties?: outputs.cognitiveservices.KeyVaultPropertiesResponse;
    }

    /**
     * Managed service identity.
     */
    export interface IdentityResponse {
        /**
         * Principal Id of managed service identity.
         */
        principalId: string;
        /**
         * Tenant of managed service identity.
         */
        tenantId: string;
        /**
         * Type of managed service identity.
         */
        type?: string;
        /**
         * The list of user assigned identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
         */
        userAssignedIdentities?: {[key: string]: string};
    }

    /**
     * A rule governing the accessibility from a specific ip address or ip range.
     */
    export interface IpRuleResponse {
        /**
         * An IPv4 address range in CIDR notation, such as '124.56.78.91' (simple IP address) or '124.56.78.0/24' (all addresses that start with 124.56.78).
         */
        value: string;
    }

    /**
     * Properties to configure keyVault Properties
     */
    export interface KeyVaultPropertiesResponse {
        /**
         * Name of the Key from KeyVault
         */
        keyName?: string;
        /**
         * Uri of KeyVault
         */
        keyVaultUri?: string;
        /**
         * Version of the Key from KeyVault
         */
        keyVersion?: string;
    }

    /**
     * A set of rules governing the network accessibility.
     */
    export interface NetworkRuleSetResponse {
        /**
         * The default action when no rule from ipRules and from virtualNetworkRules match. This is only used after the bypass property has been evaluated.
         */
        defaultAction?: string;
        /**
         * The list of IP address rules.
         */
        ipRules?: outputs.cognitiveservices.IpRuleResponse[];
        /**
         * The list of virtual network rules.
         */
        virtualNetworkRules?: outputs.cognitiveservices.VirtualNetworkRuleResponse[];
    }

    /**
     * Properties of the PrivateEndpointConnectProperties.
     */
    export interface PrivateEndpointConnectionPropertiesResponse {
        /**
         * The private link resource group ids.
         */
        groupIds?: string[];
        /**
         * The resource of private end point.
         */
        privateEndpoint?: outputs.cognitiveservices.PrivateEndpointResponse;
        /**
         * A collection of information about the state of the connection between service consumer and provider.
         */
        privateLinkServiceConnectionState: outputs.cognitiveservices.PrivateLinkServiceConnectionStateResponse;
    }

    /**
     * The Private Endpoint Connection resource.
     */
    export interface PrivateEndpointConnectionResponse {
        /**
         * Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
         */
        id: string;
        /**
         * The name of the resource
         */
        name: string;
        /**
         * Resource properties.
         */
        properties?: outputs.cognitiveservices.PrivateEndpointConnectionPropertiesResponse;
        /**
         * The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
         */
        type: string;
    }

    /**
     * The Private Endpoint resource.
     */
    export interface PrivateEndpointResponse {
        /**
         * The ARM identifier for Private Endpoint
         */
        id: string;
    }

    /**
     * A collection of information about the state of the connection between service consumer and provider.
     */
    export interface PrivateLinkServiceConnectionStateResponse {
        /**
         * A message indicating if changes on the service provider require any updates on the consumer.
         */
        actionRequired?: string;
        /**
         * The reason for approval/rejection of the connection.
         */
        description?: string;
        /**
         * Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
         */
        status?: string;
    }

    /**
     * SkuCapability indicates the capability of a certain feature.
     */
    export interface SkuCapabilityResponse {
        /**
         * The name of the SkuCapability.
         */
        name?: string;
        /**
         * The value of the SkuCapability.
         */
        value?: string;
    }

    /**
     * The SKU of the cognitive services account.
     */
    export interface SkuResponse {
        /**
         * Gets or sets the sku name. Required for account creation, optional for update.
         */
        name: string;
        /**
         * Gets the sku tier. This is based on the SKU name.
         */
        tier: string;
    }

    /**
     * The user owned storage for Cognitive Services account.
     */
    export interface UserOwnedStorageResponse {
        /**
         * Full resource id of a Microsoft.Storage resource.
         */
        resourceId?: string;
    }

    /**
     * A rule governing the accessibility from a specific virtual network.
     */
    export interface VirtualNetworkRuleResponse {
        /**
         * Full resource id of a vnet subnet, such as '/subscriptions/subid/resourceGroups/rg1/providers/Microsoft.Network/virtualNetworks/test-vnet/subnets/subnet1'.
         */
        id: string;
        /**
         * Ignore missing vnet service endpoint or not.
         */
        ignoreMissingVnetServiceEndpoint?: boolean;
        /**
         * Gets the state of virtual network rule.
         */
        state?: string;
    }
}

export namespace compute {
    /**
     * Enables or disables a capability on the virtual machine or virtual machine scale set.
     */
    export interface AdditionalCapabilitiesResponse {
        /**
         * The flag that enables or disables a capability to have one or more managed data disks with UltraSSD_LRS storage account type on the VM or VMSS. Managed disks with storage account type UltraSSD_LRS can be added to a virtual machine or virtual machine scale set only if this property is enabled.
         */
        ultraSSDEnabled?: boolean;
    }

    /**
     * Specifies additional XML formatted information that can be included in the Unattend.xml file, which is used by Windows Setup. Contents are defined by setting name, component name, and the pass in which the content is applied.
     */
    export interface AdditionalUnattendContentResponse {
        /**
         * The component name. Currently, the only allowable value is Microsoft-Windows-Shell-Setup.
         */
        componentName?: string;
        /**
         * Specifies the XML formatted content that is added to the unattend.xml file for the specified path and component. The XML must be less than 4KB and must include the root element for the setting or feature that is being inserted.
         */
        content?: string;
        /**
         * The pass name. Currently, the only allowable value is OobeSystem.
         */
        passName?: string;
        /**
         * Specifies the name of the setting to which the content applies. Possible values are: FirstLogonCommands and AutoLogon.
         */
        settingName?: string;
    }

    /**
     * The API entity reference.
     */
    export interface ApiEntityReferenceResponse {
        /**
         * The ARM resource id in the form of /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/...
         */
        id?: string;
    }

    /**
     * Information about the guest configuration assignment.
     */
    export interface AssignmentInfoResponse {
        /**
         * Information about the configuration.
         */
        configuration?: outputs.compute.ConfigurationInfoResponse;
        /**
         * Name of the guest configuration assignment.
         */
        name: string;
    }

    /**
     * Reason and code for the compliance of the guest configuration assignment resource.
     */
    export interface AssignmentReportResourceComplianceReasonResponse {
        /**
         * Code for the compliance of the guest configuration assignment resource.
         */
        code: string;
        /**
         * Reason for the compliance of the guest configuration assignment resource.
         */
        phrase: string;
    }

    /**
     * The guest configuration assignment resource.
     */
    export interface AssignmentReportResourceResponse {
        /**
         * A value indicating compliance status of the machine for the assigned guest configuration.
         */
        complianceStatus: string;
        /**
         * Properties of a guest configuration assignment resource.
         */
        properties: {[key: string]: string};
        /**
         * Compliance reason and reason code for a resource.
         */
        reasons?: outputs.compute.AssignmentReportResourceComplianceReasonResponse[];
    }

    export interface AssignmentReportResponse {
        /**
         * Configuration details of the guest configuration assignment.
         */
        assignment?: outputs.compute.AssignmentInfoResponse;
        /**
         * A value indicating compliance status of the machine for the assigned guest configuration.
         */
        complianceStatus: string;
        /**
         * End date and time of the guest configuration assignment compliance status check.
         */
        endTime: string;
        /**
         * ARM resource id of the report for the guest configuration assignment.
         */
        id: string;
        /**
         * Type of report, Consistency or Initial
         */
        operationType: string;
        /**
         * GUID that identifies the guest configuration assignment report under a subscription, resource group.
         */
        reportId: string;
        /**
         * The list of resources for which guest configuration assignment compliance is checked.
         */
        resources?: outputs.compute.AssignmentReportResourceResponse[];
        /**
         * Start date and time of the guest configuration assignment compliance status check.
         */
        startTime: string;
        /**
         * Information about the VM.
         */
        vm?: outputs.compute.VMInfoResponse;
    }

    /**
     * The configuration parameters used for performing automatic OS upgrade.
     */
    export interface AutomaticOSUpgradePolicyResponse {
        /**
         * Whether OS image rollback feature should be disabled. Default value is false.
         */
        disableAutomaticRollback?: boolean;
        /**
         * Indicates whether OS upgrades should automatically be applied to scale set instances in a rolling fashion when a newer version of the OS image becomes available. Default value is false. <br><br> If this is set to true for Windows based scale sets, [enableAutomaticUpdates](https://docs.microsoft.com/dotnet/api/microsoft.azure.management.compute.models.windowsconfiguration.enableautomaticupdates?view=azure-dotnet) is automatically set to false and cannot be set to true.
         */
        enableAutomaticOSUpgrade?: boolean;
    }

    /**
     * Specifies the configuration parameters for automatic repairs on the virtual machine scale set.
     */
    export interface AutomaticRepairsPolicyResponse {
        /**
         * Specifies whether automatic repairs should be enabled on the virtual machine scale set. The default value is false.
         */
        enabled?: boolean;
        /**
         * The amount of time for which automatic repairs are suspended due to a state change on VM. The grace time starts after the state change has completed. This helps avoid premature or accidental repairs. The time duration should be specified in ISO 8601 format. The minimum allowed grace period is 30 minutes (PT30M), which is also the default value. The maximum allowed grace period is 90 minutes (PT90M).
         */
        gracePeriod?: string;
    }

    /**
     * The instance view of a resource.
     */
    export interface AvailabilitySetPropertiesResponse {
        /**
         * Fault Domain count.
         */
        platformFaultDomainCount?: number;
        /**
         * Update Domain count.
         */
        platformUpdateDomainCount?: number;
        /**
         * Specifies information about the proximity placement group that the availability set should be assigned to. <br><br>Minimum api-version: 2018-04-01.
         */
        proximityPlacementGroup?: outputs.compute.SubResourceResponse;
        /**
         * The resource status information.
         */
        statuses: outputs.compute.InstanceViewStatusResponse[];
        /**
         * A list of references to all virtual machines in the availability set.
         */
        virtualMachines?: outputs.compute.SubResourceResponse[];
    }

    /**
     * Specifies the billing related details of a Azure Spot VM or VMSS. <br><br>Minimum api-version: 2019-03-01.
     */
    export interface BillingProfileResponse {
        /**
         * Specifies the maximum price you are willing to pay for a Azure Spot VM/VMSS. This price is in US Dollars. <br><br> This price will be compared with the current Azure Spot price for the VM size. Also, the prices are compared at the time of create/update of Azure Spot VM/VMSS and the operation will only succeed if  the maxPrice is greater than the current Azure Spot price. <br><br> The maxPrice will also be used for evicting a Azure Spot VM/VMSS if the current Azure Spot price goes beyond the maxPrice after creation of VM/VMSS. <br><br> Possible values are: <br><br> - Any decimal value greater than zero. Example: 0.01538 <br><br> -1 – indicates default price to be up-to on-demand. <br><br> You can set the maxPrice to -1 to indicate that the Azure Spot VM/VMSS should not be evicted for price reasons. Also, the default max price is -1 if it is not provided by you. <br><br>Minimum api-version: 2019-03-01.
         */
        maxPrice?: number;
    }

    /**
     * The instance view of a virtual machine boot diagnostics.
     */
    export interface BootDiagnosticsInstanceViewResponse {
        /**
         * The console screenshot blob URI. <br><br>NOTE: This will **not** be set if boot diagnostics is currently enabled with managed storage.
         */
        consoleScreenshotBlobUri: string;
        /**
         * The serial console log blob Uri. <br><br>NOTE: This will **not** be set if boot diagnostics is currently enabled with managed storage.
         */
        serialConsoleLogBlobUri: string;
        /**
         * The boot diagnostics status information for the VM. <br><br> NOTE: It will be set only if there are errors encountered in enabling boot diagnostics.
         */
        status: outputs.compute.InstanceViewStatusResponse;
    }

    /**
     * Boot Diagnostics is a debugging feature which allows you to view Console Output and Screenshot to diagnose VM status. <br><br> You can easily view the output of your console log. <br><br> Azure also enables you to see a screenshot of the VM from the hypervisor.
     */
    export interface BootDiagnosticsResponse {
        /**
         * Whether boot diagnostics should be enabled on the Virtual Machine.
         */
        enabled?: boolean;
        /**
         * Uri of the storage account to use for placing the console output and screenshot. <br><br>If storageUri is not specified while enabling boot diagnostics, managed storage will be used.
         */
        storageUri?: string;
    }

    /**
     * Information about the configuration.
     */
    export interface ConfigurationInfoResponse {
        /**
         * Name of the configuration.
         */
        name: string;
        /**
         * Version of the configuration.
         */
        version: string;
    }

    /**
     * Represents a configuration parameter.
     */
    export interface ConfigurationParameterResponse {
        /**
         * Name of the configuration parameter.
         */
        name?: string;
        /**
         * Value of the configuration parameter.
         */
        value?: string;
    }

    /**
     * Configuration setting of LCM (Local Configuration Manager).
     */
    export interface ConfigurationSettingResponse {
        /**
         * Specifies what happens after a reboot during the application of a configuration. The possible values are ContinueConfiguration and StopConfiguration
         */
        actionAfterReboot?: string;
        /**
         * If true - new configurations downloaded from the pull service are allowed to overwrite the old ones on the target node. Otherwise, false
         */
        allowModuleOverwrite?: string;
        /**
         * Specifies how the LCM(Local Configuration Manager) actually applies the configuration to the target nodes. Possible values are ApplyOnly, ApplyAndMonitor, and ApplyAndAutoCorrect.
         */
        configurationMode?: string;
        /**
         * How often, in minutes, the current configuration is checked and applied. This property is ignored if the ConfigurationMode property is set to ApplyOnly. The default value is 15.
         */
        configurationModeFrequencyMins?: number;
        /**
         * Set this to true to automatically reboot the node after a configuration that requires reboot is applied. Otherwise, you will have to manually reboot the node for any configuration that requires it. The default value is false. To use this setting when a reboot condition is enacted by something other than DSC (such as Windows Installer), combine this setting with the xPendingReboot module.
         */
        rebootIfNeeded?: string;
        /**
         * The time interval, in minutes, at which the LCM checks a pull service to get updated configurations. This value is ignored if the LCM is not configured in pull mode. The default value is 30.
         */
        refreshFrequencyMins?: number;
    }

    /**
     * Data used when creating a disk.
     */
    export interface CreationDataResponse {
        /**
         * This enumerates the possible sources of a disk's creation.
         */
        createOption: string;
        /**
         * Required if creating from a Gallery Image. The id of the ImageDiskReference will be the ARM id of the shared galley image version from which to create a disk.
         */
        galleryImageReference?: outputs.compute.ImageDiskReferenceResponse;
        /**
         * Disk source information.
         */
        imageReference?: outputs.compute.ImageDiskReferenceResponse;
        /**
         * If createOption is Copy, this is the ARM id of the source snapshot or disk.
         */
        sourceResourceId?: string;
        /**
         * If this field is set, this is the unique id identifying the source of this resource.
         */
        sourceUniqueId: string;
        /**
         * If createOption is Import, this is the URI of a blob to be imported into a managed disk.
         */
        sourceUri?: string;
        /**
         * Required if createOption is Import. The Azure Resource Manager identifier of the storage account containing the blob to import as a disk.
         */
        storageAccountId?: string;
        /**
         * If createOption is Upload, this is the size of the contents of the upload including the VHD footer. This value should be between 20972032 (20 MiB + 512 bytes for the VHD footer) and 35183298347520 bytes (32 TiB + 512 bytes for the VHD footer).
         */
        uploadSizeBytes?: number;
    }

    /**
     * Contains encryption settings for a data disk image.
     */
    export interface DataDiskImageEncryptionResponse {
        /**
         * A relative URI containing the resource ID of the disk encryption set.
         */
        diskEncryptionSetId?: string;
        /**
         * This property specifies the logical unit number of the data disk. This value is used to identify data disks within the Virtual Machine and therefore must be unique for each data disk attached to the Virtual Machine.
         */
        lun: number;
    }

    /**
     * Describes a data disk.
     */
    export interface DataDiskResponse {
        /**
         * Specifies the caching requirements. <br><br> Possible values are: <br><br> **None** <br><br> **ReadOnly** <br><br> **ReadWrite** <br><br> Default: **None for Standard storage. ReadOnly for Premium storage**
         */
        caching?: string;
        /**
         * Specifies how the virtual machine should be created.<br><br> Possible values are:<br><br> **Attach** \u2013 This value is used when you are using a specialized disk to create the virtual machine.<br><br> **FromImage** \u2013 This value is used when you are using an image to create the virtual machine. If you are using a platform image, you also use the imageReference element described above. If you are using a marketplace image, you  also use the plan element previously described.
         */
        createOption: string;
        /**
         * Specifies the Read-Write IOPS for the managed disk when StorageAccountType is UltraSSD_LRS. Returned only for VirtualMachine ScaleSet VM disks. Can be updated only via updates to the VirtualMachine Scale Set.
         */
        diskIOPSReadWrite: number;
        /**
         * Specifies the bandwidth in MB per second for the managed disk when StorageAccountType is UltraSSD_LRS. Returned only for VirtualMachine ScaleSet VM disks. Can be updated only via updates to the VirtualMachine Scale Set.
         */
        diskMBpsReadWrite: number;
        /**
         * Specifies the size of an empty data disk in gigabytes. This element can be used to overwrite the size of the disk in a virtual machine image. <br><br> This value cannot be larger than 1023 GB
         */
        diskSizeGB?: number;
        /**
         * The source user image virtual hard disk. The virtual hard disk will be copied before being attached to the virtual machine. If SourceImage is provided, the destination virtual hard drive must not exist.
         */
        image?: outputs.compute.VirtualHardDiskResponse;
        /**
         * Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM.
         */
        lun: number;
        /**
         * The managed disk parameters.
         */
        managedDisk?: outputs.compute.ManagedDiskParametersResponse;
        /**
         * The disk name.
         */
        name?: string;
        /**
         * Specifies whether the data disk is in process of detachment from the VirtualMachine/VirtualMachineScaleset
         */
        toBeDetached?: boolean;
        /**
         * The virtual hard disk.
         */
        vhd?: outputs.compute.VirtualHardDiskResponse;
        /**
         * Specifies whether writeAccelerator should be enabled or disabled on the disk.
         */
        writeAcceleratorEnabled?: boolean;
    }

    /**
     * Represents the dedicated host unutilized capacity in terms of a specific VM size.
     */
    export interface DedicatedHostAllocatableVMResponse {
        /**
         * Maximum number of VMs of size vmSize that can fit in the dedicated host's remaining capacity.
         */
        count?: number;
        /**
         * VM size in terms of which the unutilized capacity is represented.
         */
        vmSize?: string;
    }

    /**
     * Dedicated host unutilized capacity.
     */
    export interface DedicatedHostAvailableCapacityResponse {
        /**
         * The unutilized capacity of the dedicated host represented in terms of each VM size that is allowed to be deployed to the dedicated host.
         */
        allocatableVMs?: outputs.compute.DedicatedHostAllocatableVMResponse[];
    }

    export interface DedicatedHostGroupInstanceViewResponse {
        /**
         * List of instance view of the dedicated hosts under the dedicated host group.
         */
        hosts?: outputs.compute.DedicatedHostInstanceViewWithNameResponse[];
    }

    /**
     * Dedicated Host Group Properties.
     */
    export interface DedicatedHostGroupPropertiesResponse {
        /**
         * A list of references to all dedicated hosts in the dedicated host group.
         */
        hosts: outputs.compute.SubResourceReadOnlyResponse[];
        /**
         * The dedicated host group instance view, which has the list of instance view of the dedicated hosts under the dedicated host group.
         */
        instanceView: outputs.compute.DedicatedHostGroupInstanceViewResponse;
        /**
         * Number of fault domains that the host group can span.
         */
        platformFaultDomainCount: number;
        /**
         * Specifies whether virtual machines or virtual machine scale sets can be placed automatically on the dedicated host group. Automatic placement means resources are allocated on dedicated hosts, that are chosen by Azure, under the dedicated host group. The value is defaulted to 'true' when not provided. <br><br>Minimum api-version: 2020-06-01.
         */
        supportAutomaticPlacement?: boolean;
    }

    /**
     * The instance view of a dedicated host.
     */
    export interface DedicatedHostInstanceViewResponse {
        /**
         * Specifies the unique id of the dedicated physical machine on which the dedicated host resides.
         */
        assetId: string;
        /**
         * Unutilized capacity of the dedicated host.
         */
        availableCapacity?: outputs.compute.DedicatedHostAvailableCapacityResponse;
        /**
         * The resource status information.
         */
        statuses?: outputs.compute.InstanceViewStatusResponse[];
    }

    /**
     * The instance view of a dedicated host that includes the name of the dedicated host. It is used for the response to the instance view of a dedicated host group.
     */
    export interface DedicatedHostInstanceViewWithNameResponse {
        /**
         * Specifies the unique id of the dedicated physical machine on which the dedicated host resides.
         */
        assetId: string;
        /**
         * Unutilized capacity of the dedicated host.
         */
        availableCapacity?: outputs.compute.DedicatedHostAvailableCapacityResponse;
        /**
         * The name of the dedicated host.
         */
        name: string;
        /**
         * The resource status information.
         */
        statuses?: outputs.compute.InstanceViewStatusResponse[];
    }

    /**
     * Properties of the dedicated host.
     */
    export interface DedicatedHostPropertiesResponse {
        /**
         * Specifies whether the dedicated host should be replaced automatically in case of a failure. The value is defaulted to 'true' when not provided.
         */
        autoReplaceOnFailure?: boolean;
        /**
         * A unique id generated and assigned to the dedicated host by the platform. <br><br> Does not change throughout the lifetime of the host.
         */
        hostId: string;
        /**
         * The dedicated host instance view.
         */
        instanceView: outputs.compute.DedicatedHostInstanceViewResponse;
        /**
         * Specifies the software license type that will be applied to the VMs deployed on the dedicated host. <br><br> Possible values are: <br><br> **None** <br><br> **Windows_Server_Hybrid** <br><br> **Windows_Server_Perpetual** <br><br> Default: **None**
         */
        licenseType?: string;
        /**
         * Fault domain of the dedicated host within a dedicated host group.
         */
        platformFaultDomain?: number;
        /**
         * The provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * The date when the host was first provisioned.
         */
        provisioningTime: string;
        /**
         * A list of references to all virtual machines in the Dedicated Host.
         */
        virtualMachines: outputs.compute.SubResourceReadOnlyResponse[];
    }

    /**
     * Specifies the boot diagnostic settings state. <br><br>Minimum api-version: 2015-06-15.
     */
    export interface DiagnosticsProfileResponse {
        /**
         * Boot Diagnostics is a debugging feature which allows you to view Console Output and Screenshot to diagnose VM status. <br><br> You can easily view the output of your console log. <br><br> Azure also enables you to see a screenshot of the VM from the hypervisor.
         */
        bootDiagnostics?: outputs.compute.BootDiagnosticsResponse;
    }

    /**
     * Describes the parameters of ephemeral disk settings that can be specified for operating system disk. <br><br> NOTE: The ephemeral disk settings can only be specified for managed disk.
     */
    export interface DiffDiskSettingsResponse {
        /**
         * Specifies the ephemeral disk settings for operating system disk.
         */
        option?: string;
        /**
         * Specifies the ephemeral disk placement for operating system disk.<br><br> Possible values are: <br><br> **CacheDisk** <br><br> **ResourceDisk** <br><br> Default: **CacheDisk** if one is configured for the VM size otherwise **ResourceDisk** is used.<br><br> Refer to VM size documentation for Windows VM at https://docs.microsoft.com/en-us/azure/virtual-machines/windows/sizes and Linux VM at https://docs.microsoft.com/en-us/azure/virtual-machines/linux/sizes to check which VM sizes exposes a cache disk.
         */
        placement?: string;
    }

    /**
     * Describes the disallowed disk types.
     */
    export interface DisallowedResponse {
        /**
         * A list of disk types.
         */
        diskTypes?: string[];
    }

    export interface DiskAccessPropertiesResponse {
        /**
         * A readonly collection of private endpoint connections created on the disk. Currently only one endpoint connection is supported.
         */
        privateEndpointConnections: outputs.compute.PrivateEndpointConnectionResponse[];
        /**
         * The disk access resource provisioning state.
         */
        provisioningState: string;
        /**
         * The time when the disk access was created.
         */
        timeCreated: string;
    }

    /**
     * Describes the parameter of customer managed disk encryption set resource id that can be specified for disk. <br><br> NOTE: The disk encryption set resource id can only be specified for managed disk. Please refer https://aka.ms/mdssewithcmkoverview for more details.
     */
    export interface DiskEncryptionSetParametersResponse {
        /**
         * Resource Id
         */
        id?: string;
    }

    /**
     * Describes a Encryption Settings for a Disk
     */
    export interface DiskEncryptionSettingsResponse {
        /**
         * Specifies the location of the disk encryption key, which is a Key Vault Secret.
         */
        diskEncryptionKey?: outputs.compute.KeyVaultSecretReferenceResponse;
        /**
         * Specifies whether disk encryption should be enabled on the virtual machine.
         */
        enabled?: boolean;
        /**
         * Specifies the location of the key encryption key in Key Vault.
         */
        keyEncryptionKey?: outputs.compute.KeyVaultKeyReferenceResponse;
    }

    /**
     * The instance view of the disk.
     */
    export interface DiskInstanceViewResponse {
        /**
         * Specifies the encryption settings for the OS Disk. <br><br> Minimum api-version: 2015-06-15
         */
        encryptionSettings?: outputs.compute.DiskEncryptionSettingsResponse[];
        /**
         * The disk name.
         */
        name?: string;
        /**
         * The resource status information.
         */
        statuses?: outputs.compute.InstanceViewStatusResponse[];
    }

    /**
     * Disk resource properties.
     */
    export interface DiskPropertiesResponse {
        /**
         * Disk source information. CreationData information cannot be changed after the disk has been created.
         */
        creationData: outputs.compute.CreationDataResponse;
        /**
         * ARM id of the DiskAccess resource for using private endpoints on disks.
         */
        diskAccessId?: string;
        /**
         * The total number of IOPS that will be allowed across all VMs mounting the shared disk as ReadOnly. One operation can transfer between 4k and 256k bytes.
         */
        diskIOPSReadOnly?: number;
        /**
         * The number of IOPS allowed for this disk; only settable for UltraSSD disks. One operation can transfer between 4k and 256k bytes.
         */
        diskIOPSReadWrite?: number;
        /**
         * The total throughput (MBps) that will be allowed across all VMs mounting the shared disk as ReadOnly. MBps means millions of bytes per second - MB here uses the ISO notation, of powers of 10.
         */
        diskMBpsReadOnly?: number;
        /**
         * The bandwidth allowed for this disk; only settable for UltraSSD disks. MBps means millions of bytes per second - MB here uses the ISO notation, of powers of 10.
         */
        diskMBpsReadWrite?: number;
        /**
         * The size of the disk in bytes. This field is read only.
         */
        diskSizeBytes: number;
        /**
         * If creationData.createOption is Empty, this field is mandatory and it indicates the size of the disk to create. If this field is present for updates or creation with other options, it indicates a resize. Resizes are only allowed if the disk is not attached to a running VM, and can only increase the disk's size.
         */
        diskSizeGB?: number;
        /**
         * The state of the disk.
         */
        diskState: string;
        /**
         * Encryption property can be used to encrypt data at rest with customer managed keys or platform managed keys.
         */
        encryption?: outputs.compute.EncryptionResponse;
        /**
         * Encryption settings collection used for Azure Disk Encryption, can contain multiple encryption settings per disk or snapshot.
         */
        encryptionSettingsCollection?: outputs.compute.EncryptionSettingsCollectionResponse;
        /**
         * The hypervisor generation of the Virtual Machine. Applicable to OS disks only.
         */
        hyperVGeneration?: string;
        /**
         * The maximum number of VMs that can attach to the disk at the same time. Value greater than one indicates a disk that can be mounted on multiple VMs at the same time.
         */
        maxShares?: number;
        /**
         * Policy for accessing the disk via network.
         */
        networkAccessPolicy?: string;
        /**
         * The Operating System type.
         */
        osType?: string;
        /**
         * The disk provisioning state.
         */
        provisioningState: string;
        /**
         * Details of the list of all VMs that have the disk attached. maxShares should be set to a value greater than one for disks to allow attaching them to multiple VMs.
         */
        shareInfo: outputs.compute.ShareInfoElementResponse[];
        /**
         * The time when the disk was created.
         */
        timeCreated: string;
        /**
         * Unique Guid identifying the resource.
         */
        uniqueId: string;
    }

    /**
     * The disks sku name. Can be Standard_LRS, Premium_LRS, StandardSSD_LRS, or UltraSSD_LRS.
     */
    export interface DiskSkuResponse {
        /**
         * The sku name.
         */
        name?: string;
        /**
         * The sku tier.
         */
        tier: string;
    }

    /**
     * Optional. Allows users to provide customer managed keys for encrypting the OS and data disks in the gallery artifact.
     */
    export interface EncryptionImagesResponse {
        /**
         * A list of encryption specifications for data disk images.
         */
        dataDiskImages?: outputs.compute.DataDiskImageEncryptionResponse[];
        /**
         * Contains encryption settings for an OS disk image.
         */
        osDiskImage?: outputs.compute.OSDiskImageEncryptionResponse;
    }

    /**
     * Encryption at rest settings for disk or snapshot
     */
    export interface EncryptionResponse {
        /**
         * ResourceId of the disk encryption set to use for enabling encryption at rest.
         */
        diskEncryptionSetId?: string;
        /**
         * The type of key used to encrypt the data of the disk.
         */
        type?: string;
    }

    /**
     * The managed identity for the disk encryption set. It should be given permission on the key vault before it can be used to encrypt disks.
     */
    export interface EncryptionSetIdentityResponse {
        /**
         * The object id of the Managed Identity Resource. This will be sent to the RP from ARM via the x-ms-identity-principal-id header in the PUT request if the resource has a systemAssigned(implicit) identity
         */
        principalId: string;
        /**
         * The tenant id of the Managed Identity Resource. This will be sent to the RP from ARM via the x-ms-client-tenant-id header in the PUT request if the resource has a systemAssigned(implicit) identity
         */
        tenantId: string;
        /**
         * The type of Managed Identity used by the DiskEncryptionSet. Only SystemAssigned is supported.
         */
        type?: string;
    }

    export interface EncryptionSetPropertiesResponse {
        /**
         * The key vault key which is currently used by this disk encryption set.
         */
        activeKey?: outputs.compute.KeyVaultAndKeyReferenceResponse;
        /**
         * The type of key used to encrypt the data of the disk.
         */
        encryptionType?: string;
        /**
         * A readonly collection of key vault keys previously used by this disk encryption set while a key rotation is in progress. It will be empty if there is no ongoing key rotation.
         */
        previousKeys: outputs.compute.KeyVaultAndKeyReferenceResponse[];
        /**
         * The disk encryption set provisioning state.
         */
        provisioningState: string;
    }

    /**
     * Encryption settings for disk or snapshot
     */
    export interface EncryptionSettingsCollectionResponse {
        /**
         * Set this flag to true and provide DiskEncryptionKey and optional KeyEncryptionKey to enable encryption. Set this flag to false and remove DiskEncryptionKey and KeyEncryptionKey to disable encryption. If EncryptionSettings is null in the request object, the existing settings remain unchanged.
         */
        enabled: boolean;
        /**
         * A collection of encryption settings, one for each disk volume.
         */
        encryptionSettings?: outputs.compute.EncryptionSettingsElementResponse[];
        /**
         * Describes what type of encryption is used for the disks. Once this field is set, it cannot be overwritten. '1.0' corresponds to Azure Disk Encryption with AAD app.'1.1' corresponds to Azure Disk Encryption.
         */
        encryptionSettingsVersion?: string;
    }

    /**
     * Encryption settings for one disk volume.
     */
    export interface EncryptionSettingsElementResponse {
        /**
         * Key Vault Secret Url and vault id of the disk encryption key
         */
        diskEncryptionKey?: outputs.compute.KeyVaultAndSecretReferenceResponse;
        /**
         * Key Vault Key Url and vault id of the key encryption key. KeyEncryptionKey is optional and when provided is used to unwrap the disk encryption key.
         */
        keyEncryptionKey?: outputs.compute.KeyVaultAndKeyReferenceResponse;
    }

    /**
     * Describes the properties of a gallery Application Definition.
     */
    export interface GalleryApplicationPropertiesResponse {
        /**
         * The description of this gallery Application Definition resource. This property is updatable.
         */
        description?: string;
        /**
         * The end of life date of the gallery Application Definition. This property can be used for decommissioning purposes. This property is updatable.
         */
        endOfLifeDate?: string;
        /**
         * The Eula agreement for the gallery Application Definition.
         */
        eula?: string;
        /**
         * The privacy statement uri.
         */
        privacyStatementUri?: string;
        /**
         * The release note uri.
         */
        releaseNoteUri?: string;
        /**
         * This property allows you to specify the supported type of the OS that application is built for. <br><br> Possible values are: <br><br> **Windows** <br><br> **Linux**
         */
        supportedOSType: string;
    }

    /**
     * Describes the properties of a gallery Image Version.
     */
    export interface GalleryApplicationVersionPropertiesResponse {
        /**
         * The provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * The publishing profile of a gallery Image Version.
         */
        publishingProfile: outputs.compute.GalleryApplicationVersionPublishingProfileResponse;
        /**
         * This is the replication status of the gallery Image Version.
         */
        replicationStatus: outputs.compute.ReplicationStatusResponse;
    }

    /**
     * The publishing profile of a gallery Image Version.
     */
    export interface GalleryApplicationVersionPublishingProfileResponse {
        /**
         * Optional. May be used to help process this file. The type of file contained in the source, e.g. zip, json, etc.
         */
        contentType?: string;
        /**
         * Optional. Whether or not this application reports health.
         */
        enableHealthCheck?: boolean;
        /**
         * The end of life date of the gallery Image Version. This property can be used for decommissioning purposes. This property is updatable.
         */
        endOfLifeDate?: string;
        /**
         * If set to true, Virtual Machines deployed from the latest version of the Image Definition won't use this Image Version.
         */
        excludeFromLatest?: boolean;
        /**
         * The timestamp for when the gallery Image Version is published.
         */
        publishedDate: string;
        /**
         * The number of replicas of the Image Version to be created per region. This property would take effect for a region when regionalReplicaCount is not specified. This property is updatable.
         */
        replicaCount?: number;
        /**
         * The source image from which the Image Version is going to be created.
         */
        source: outputs.compute.UserArtifactSourceResponse;
        /**
         * Specifies the storage account type to be used to store the image. This property is not updatable.
         */
        storageAccountType?: string;
        /**
         * The target regions where the Image Version is going to be replicated to. This property is updatable.
         */
        targetRegions?: outputs.compute.TargetRegionResponse[];
    }

    /**
     * The gallery artifact version source.
     */
    export interface GalleryArtifactVersionSourceResponse {
        /**
         * The id of the gallery artifact version source. Can specify a disk uri, snapshot uri, or user image.
         */
        id?: string;
    }

    /**
     * This is the data disk image.
     */
    export interface GalleryDataDiskImageResponse {
        /**
         * The host caching of the disk. Valid values are 'None', 'ReadOnly', and 'ReadWrite'
         */
        hostCaching?: string;
        /**
         * This property specifies the logical unit number of the data disk. This value is used to identify data disks within the Virtual Machine and therefore must be unique for each data disk attached to the Virtual Machine.
         */
        lun: number;
        /**
         * This property indicates the size of the VHD to be created.
         */
        sizeInGB: number;
        /**
         * The gallery artifact version source.
         */
        source?: outputs.compute.GalleryArtifactVersionSourceResponse;
    }

    /**
     * Describes the gallery unique name.
     */
    export interface GalleryIdentifierResponse {
        /**
         * The unique name of the Shared Image Gallery. This name is generated automatically by Azure.
         */
        uniqueName: string;
    }

    /**
     * This is the gallery Image Definition identifier.
     */
    export interface GalleryImageIdentifierResponse {
        /**
         * The name of the gallery Image Definition offer.
         */
        offer: string;
        /**
         * The name of the gallery Image Definition publisher.
         */
        publisher: string;
        /**
         * The name of the gallery Image Definition SKU.
         */
        sku: string;
    }

    /**
     * Describes the properties of a gallery Image Definition.
     */
    export interface GalleryImagePropertiesResponse {
        /**
         * The description of this gallery Image Definition resource. This property is updatable.
         */
        description?: string;
        /**
         * Describes the disallowed disk types.
         */
        disallowed?: outputs.compute.DisallowedResponse;
        /**
         * The end of life date of the gallery Image Definition. This property can be used for decommissioning purposes. This property is updatable.
         */
        endOfLifeDate?: string;
        /**
         * The Eula agreement for the gallery Image Definition.
         */
        eula?: string;
        /**
         * The hypervisor generation of the Virtual Machine. Applicable to OS disks only.
         */
        hyperVGeneration?: string;
        /**
         * This is the gallery Image Definition identifier.
         */
        identifier: outputs.compute.GalleryImageIdentifierResponse;
        /**
         * This property allows the user to specify whether the virtual machines created under this image are 'Generalized' or 'Specialized'.
         */
        osState: string;
        /**
         * This property allows you to specify the type of the OS that is included in the disk when creating a VM from a managed image. <br><br> Possible values are: <br><br> **Windows** <br><br> **Linux**
         */
        osType: string;
        /**
         * The privacy statement uri.
         */
        privacyStatementUri?: string;
        /**
         * The provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * Describes the gallery Image Definition purchase plan. This is used by marketplace images.
         */
        purchasePlan?: outputs.compute.ImagePurchasePlanResponse;
        /**
         * The properties describe the recommended machine configuration for this Image Definition. These properties are updatable.
         */
        recommended?: outputs.compute.RecommendedMachineConfigurationResponse;
        /**
         * The release note uri.
         */
        releaseNoteUri?: string;
    }

    /**
     * Describes the properties of a gallery Image Version.
     */
    export interface GalleryImageVersionPropertiesResponse {
        /**
         * The provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * The publishing profile of a gallery Image Version.
         */
        publishingProfile?: outputs.compute.GalleryImageVersionPublishingProfileResponse;
        /**
         * This is the replication status of the gallery Image Version.
         */
        replicationStatus: outputs.compute.ReplicationStatusResponse;
        /**
         * This is the storage profile of a Gallery Image Version.
         */
        storageProfile: outputs.compute.GalleryImageVersionStorageProfileResponse;
    }

    /**
     * The publishing profile of a gallery Image Version.
     */
    export interface GalleryImageVersionPublishingProfileResponse {
        /**
         * The end of life date of the gallery Image Version. This property can be used for decommissioning purposes. This property is updatable.
         */
        endOfLifeDate?: string;
        /**
         * If set to true, Virtual Machines deployed from the latest version of the Image Definition won't use this Image Version.
         */
        excludeFromLatest?: boolean;
        /**
         * The timestamp for when the gallery Image Version is published.
         */
        publishedDate: string;
        /**
         * The number of replicas of the Image Version to be created per region. This property would take effect for a region when regionalReplicaCount is not specified. This property is updatable.
         */
        replicaCount?: number;
        /**
         * Specifies the storage account type to be used to store the image. This property is not updatable.
         */
        storageAccountType?: string;
        /**
         * The target regions where the Image Version is going to be replicated to. This property is updatable.
         */
        targetRegions?: outputs.compute.TargetRegionResponse[];
    }

    /**
     * This is the storage profile of a Gallery Image Version.
     */
    export interface GalleryImageVersionStorageProfileResponse {
        /**
         * A list of data disk images.
         */
        dataDiskImages?: outputs.compute.GalleryDataDiskImageResponse[];
        /**
         * This is the OS disk image.
         */
        osDiskImage?: outputs.compute.GalleryOSDiskImageResponse;
        /**
         * The gallery artifact version source.
         */
        source?: outputs.compute.GalleryArtifactVersionSourceResponse;
    }

    /**
     * This is the OS disk image.
     */
    export interface GalleryOSDiskImageResponse {
        /**
         * The host caching of the disk. Valid values are 'None', 'ReadOnly', and 'ReadWrite'
         */
        hostCaching?: string;
        /**
         * This property indicates the size of the VHD to be created.
         */
        sizeInGB: number;
        /**
         * The gallery artifact version source.
         */
        source?: outputs.compute.GalleryArtifactVersionSourceResponse;
    }

    /**
     * Describes the properties of a Shared Image Gallery.
     */
    export interface GalleryPropertiesResponse {
        /**
         * The description of this Shared Image Gallery resource. This property is updatable.
         */
        description?: string;
        /**
         * Describes the gallery unique name.
         */
        identifier?: outputs.compute.GalleryIdentifierResponse;
        /**
         * The provisioning state, which only appears in the response.
         */
        provisioningState: string;
    }

    /**
     * Guest configuration assignment properties.
     */
    export interface GuestConfigurationAssignmentPropertiesResponse {
        /**
         * Combined hash of the configuration package and parameters.
         */
        assignmentHash: string;
        /**
         * A value indicating compliance status of the machine for the assigned guest configuration.
         */
        complianceStatus: string;
        /**
         * The source which initiated the guest configuration assignment. Ex: Azure Policy
         */
        context?: string;
        /**
         * The guest configuration to assign.
         */
        guestConfiguration?: outputs.compute.GuestConfigurationNavigationResponse;
        /**
         * Date and time when last compliance status was checked.
         */
        lastComplianceStatusChecked: string;
        /**
         * Last reported guest configuration assignment report.
         */
        latestAssignmentReport?: outputs.compute.AssignmentReportResponse;
        /**
         * Id of the latest report for the guest configuration assignment. 
         */
        latestReportId: string;
        /**
         * The provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * VM resource Id.
         */
        targetResourceId: string;
    }

    /**
     * Guest configuration is an artifact that encapsulates DSC configuration and its dependencies. The artifact is a zip file containing DSC configuration (as MOF) and dependent resources and other dependencies like modules.
     */
    export interface GuestConfigurationNavigationResponse {
        /**
         * The configuration parameters for the guest configuration.
         */
        configurationParameter?: outputs.compute.ConfigurationParameterResponse[];
        /**
         * The configuration setting for the guest configuration.
         */
        configurationSetting?: outputs.compute.ConfigurationSettingResponse;
        /**
         * Combined hash of the guest configuration package and configuration parameters.
         */
        contentHash: string;
        /**
         * Uri of the storage where guest configuration package is uploaded.
         */
        contentUri: string;
        /**
         * Kind of the guest configuration. For example:DSC
         */
        kind?: string;
        /**
         * Name of the guest configuration.
         */
        name?: string;
        /**
         * Version of the guest configuration.
         */
        version?: string;
    }

    /**
     * Specifies the hardware settings for the virtual machine.
     */
    export interface HardwareProfileResponse {
        /**
         * Specifies the size of the virtual machine. For more information about virtual machine sizes, see [Sizes for virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-sizes?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json). <br><br> The available VM sizes depend on region and availability set. For a list of available sizes use these APIs:  <br><br> [List all available virtual machine sizes in an availability set](https://docs.microsoft.com/rest/api/compute/availabilitysets/listavailablesizes) <br><br> [List all available virtual machine sizes in a region](https://docs.microsoft.com/rest/api/compute/virtualmachinesizes/list) <br><br> [List all available virtual machine sizes for resizing](https://docs.microsoft.com/rest/api/compute/virtualmachines/listavailablesizes)
         */
        vmSize?: string;
    }

    /**
     * Describes a data disk.
     */
    export interface ImageDataDiskResponse {
        /**
         * The Virtual Hard Disk.
         */
        blobUri?: string;
        /**
         * Specifies the caching requirements. <br><br> Possible values are: <br><br> **None** <br><br> **ReadOnly** <br><br> **ReadWrite** <br><br> Default: **None for Standard storage. ReadOnly for Premium storage**
         */
        caching?: string;
        /**
         * Specifies the customer managed disk encryption set resource id for the managed image disk.
         */
        diskEncryptionSet?: outputs.compute.DiskEncryptionSetParametersResponse;
        /**
         * Specifies the size of empty data disks in gigabytes. This element can be used to overwrite the name of the disk in a virtual machine image. <br><br> This value cannot be larger than 1023 GB
         */
        diskSizeGB?: number;
        /**
         * Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM.
         */
        lun: number;
        /**
         * The managedDisk.
         */
        managedDisk?: outputs.compute.SubResourceResponse;
        /**
         * The snapshot.
         */
        snapshot?: outputs.compute.SubResourceResponse;
        /**
         * Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with data disks, it cannot be used with OS Disk.
         */
        storageAccountType?: string;
    }

    /**
     * The source image used for creating the disk.
     */
    export interface ImageDiskReferenceResponse {
        /**
         * A relative uri containing either a Platform Image Repository or user image reference.
         */
        id: string;
        /**
         * If the disk is created from an image's data disk, this is an index that indicates which of the data disks in the image to use. For OS disks, this field is null.
         */
        lun?: number;
    }

    /**
     * Describes an Operating System disk.
     */
    export interface ImageOSDiskResponse {
        /**
         * The Virtual Hard Disk.
         */
        blobUri?: string;
        /**
         * Specifies the caching requirements. <br><br> Possible values are: <br><br> **None** <br><br> **ReadOnly** <br><br> **ReadWrite** <br><br> Default: **None for Standard storage. ReadOnly for Premium storage**
         */
        caching?: string;
        /**
         * Specifies the customer managed disk encryption set resource id for the managed image disk.
         */
        diskEncryptionSet?: outputs.compute.DiskEncryptionSetParametersResponse;
        /**
         * Specifies the size of empty data disks in gigabytes. This element can be used to overwrite the name of the disk in a virtual machine image. <br><br> This value cannot be larger than 1023 GB
         */
        diskSizeGB?: number;
        /**
         * The managedDisk.
         */
        managedDisk?: outputs.compute.SubResourceResponse;
        /**
         * The OS State.
         */
        osState: string;
        /**
         * This property allows you to specify the type of the OS that is included in the disk if creating a VM from a custom image. <br><br> Possible values are: <br><br> **Windows** <br><br> **Linux**
         */
        osType: string;
        /**
         * The snapshot.
         */
        snapshot?: outputs.compute.SubResourceResponse;
        /**
         * Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with data disks, it cannot be used with OS Disk.
         */
        storageAccountType?: string;
    }

    /**
     * Describes the properties of an Image.
     */
    export interface ImagePropertiesResponse {
        /**
         * Gets the HyperVGenerationType of the VirtualMachine created from the image
         */
        hyperVGeneration?: string;
        /**
         * The provisioning state.
         */
        provisioningState: string;
        /**
         * The source virtual machine from which Image is created.
         */
        sourceVirtualMachine?: outputs.compute.SubResourceResponse;
        /**
         * Specifies the storage settings for the virtual machine disks.
         */
        storageProfile?: outputs.compute.ImageStorageProfileResponse;
    }

    /**
     * Describes the gallery Image Definition purchase plan. This is used by marketplace images.
     */
    export interface ImagePurchasePlanResponse {
        /**
         * The plan ID.
         */
        name?: string;
        /**
         * The product ID.
         */
        product?: string;
        /**
         * The publisher ID.
         */
        publisher?: string;
    }

    /**
     * Specifies information about the image to use. You can specify information about platform images, marketplace images, or virtual machine images. This element is required when you want to use a platform image, marketplace image, or virtual machine image, but is not used in other creation operations. NOTE: Image reference publisher and offer can only be set when you create the scale set.
     */
    export interface ImageReferenceResponse {
        /**
         * Specifies in decimal numbers, the version of platform image or marketplace image used to create the virtual machine. This readonly field differs from 'version', only if the value specified in 'version' field is 'latest'.
         */
        exactVersion: string;
        /**
         * Resource Id
         */
        id?: string;
        /**
         * Specifies the offer of the platform image or marketplace image used to create the virtual machine.
         */
        offer?: string;
        /**
         * The image publisher.
         */
        publisher?: string;
        /**
         * The image SKU.
         */
        sku?: string;
        /**
         * Specifies the version of the platform image or marketplace image used to create the virtual machine. The allowed formats are Major.Minor.Build or 'latest'. Major, Minor, and Build are decimal numbers. Specify 'latest' to use the latest version of an image available at deploy time. Even if you use 'latest', the VM image will not automatically update after deploy time even if a new version becomes available.
         */
        version?: string;
    }

    /**
     * Describes a storage profile.
     */
    export interface ImageStorageProfileResponse {
        /**
         * Specifies the parameters that are used to add a data disk to a virtual machine. <br><br> For more information about disks, see [About disks and VHDs for Azure virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
         */
        dataDisks?: outputs.compute.ImageDataDiskResponse[];
        /**
         * Specifies information about the operating system disk used by the virtual machine. <br><br> For more information about disks, see [About disks and VHDs for Azure virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
         */
        osDisk?: outputs.compute.ImageOSDiskResponse;
        /**
         * Specifies whether an image is zone resilient or not. Default is false. Zone resilient images can be created only in regions that provide Zone Redundant Storage (ZRS).
         */
        zoneResilient?: boolean;
    }

    /**
     * Instance view status.
     */
    export interface InstanceViewStatusResponse {
        /**
         * The status code.
         */
        code?: string;
        /**
         * The short localizable label for the status.
         */
        displayStatus?: string;
        /**
         * The level code.
         */
        level?: string;
        /**
         * The detailed status message, including for alerts and error messages.
         */
        message?: string;
        /**
         * The time of the status.
         */
        time?: string;
    }

    /**
     * Key Vault Key Url and vault id of KeK, KeK is optional and when provided is used to unwrap the encryptionKey
     */
    export interface KeyVaultAndKeyReferenceResponse {
        /**
         * Url pointing to a key or secret in KeyVault
         */
        keyUrl: string;
        /**
         * Resource id of the KeyVault containing the key or secret
         */
        sourceVault: outputs.compute.SourceVaultResponse;
    }

    /**
     * Key Vault Secret Url and vault id of the encryption key 
     */
    export interface KeyVaultAndSecretReferenceResponse {
        /**
         * Url pointing to a key or secret in KeyVault
         */
        secretUrl: string;
        /**
         * Resource id of the KeyVault containing the key or secret
         */
        sourceVault: outputs.compute.SourceVaultResponse;
    }

    /**
     * Describes a reference to Key Vault Key
     */
    export interface KeyVaultKeyReferenceResponse {
        /**
         * The URL referencing a key encryption key in Key Vault.
         */
        keyUrl: string;
        /**
         * The relative URL of the Key Vault containing the key.
         */
        sourceVault: outputs.compute.SubResourceResponse;
    }

    /**
     * Describes a reference to Key Vault Secret
     */
    export interface KeyVaultSecretReferenceResponse {
        /**
         * The URL referencing a secret in a Key Vault.
         */
        secretUrl: string;
        /**
         * The relative URL of the Key Vault containing the secret.
         */
        sourceVault: outputs.compute.SubResourceResponse;
    }

    /**
     * Specifies the Linux operating system settings on the virtual machine. <br><br>For a list of supported Linux distributions, see [Linux on Azure-Endorsed Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-endorsed-distros?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json) <br><br> For running non-endorsed distributions, see [Information for Non-Endorsed Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-create-upload-generic?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
     */
    export interface LinuxConfigurationResponse {
        /**
         * Specifies whether password authentication should be disabled.
         */
        disablePasswordAuthentication?: boolean;
        /**
         * Indicates whether virtual machine agent should be provisioned on the virtual machine. <br><br> When this property is not specified in the request body, default behavior is to set it to true.  This will ensure that VM Agent is installed on the VM so that extensions can be added to the VM later.
         */
        provisionVMAgent?: boolean;
        /**
         * Specifies the ssh key configuration for a Linux OS.
         */
        ssh?: outputs.compute.SshConfigurationResponse;
    }

    /**
     * Maintenance Operation Status.
     */
    export interface MaintenanceRedeployStatusResponse {
        /**
         * True, if customer is allowed to perform Maintenance.
         */
        isCustomerInitiatedMaintenanceAllowed?: boolean;
        /**
         * Message returned for the last Maintenance Operation.
         */
        lastOperationMessage?: string;
        /**
         * The Last Maintenance Operation Result Code.
         */
        lastOperationResultCode?: string;
        /**
         * End Time for the Maintenance Window.
         */
        maintenanceWindowEndTime?: string;
        /**
         * Start Time for the Maintenance Window.
         */
        maintenanceWindowStartTime?: string;
        /**
         * End Time for the Pre Maintenance Window.
         */
        preMaintenanceWindowEndTime?: string;
        /**
         * Start Time for the Pre Maintenance Window.
         */
        preMaintenanceWindowStartTime?: string;
    }

    /**
     * The parameters of a managed disk.
     */
    export interface ManagedDiskParametersResponse {
        /**
         * Specifies the customer managed disk encryption set resource id for the managed disk.
         */
        diskEncryptionSet?: outputs.compute.DiskEncryptionSetParametersResponse;
        /**
         * Resource Id
         */
        id?: string;
        /**
         * Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with data disks, it cannot be used with OS Disk.
         */
        storageAccountType?: string;
    }

    /**
     * Describes a network interface reference properties.
     */
    export interface NetworkInterfaceReferencePropertiesResponse {
        /**
         * Specifies the primary network interface in case the virtual machine has more than 1 network interface.
         */
        primary?: boolean;
    }

    /**
     * Describes a network interface reference.
     */
    export interface NetworkInterfaceReferenceResponse {
        /**
         * Resource Id
         */
        id?: string;
        /**
         * Describes a network interface reference properties.
         */
        properties?: outputs.compute.NetworkInterfaceReferencePropertiesResponse;
    }

    /**
     * Specifies the network interfaces of the virtual machine.
     */
    export interface NetworkProfileResponse {
        /**
         * Specifies the list of resource Ids for the network interfaces associated with the virtual machine.
         */
        networkInterfaces?: outputs.compute.NetworkInterfaceReferenceResponse[];
    }

    /**
     * Contains encryption settings for an OS disk image.
     */
    export interface OSDiskImageEncryptionResponse {
        /**
         * A relative URI containing the resource ID of the disk encryption set.
         */
        diskEncryptionSetId?: string;
    }

    /**
     * Specifies information about the operating system disk used by the virtual machine. <br><br> For more information about disks, see [About disks and VHDs for Azure virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
     */
    export interface OSDiskResponse {
        /**
         * Specifies the caching requirements. <br><br> Possible values are: <br><br> **None** <br><br> **ReadOnly** <br><br> **ReadWrite** <br><br> Default: **None** for Standard storage. **ReadOnly** for Premium storage.
         */
        caching?: string;
        /**
         * Specifies how the virtual machine should be created.<br><br> Possible values are:<br><br> **Attach** \u2013 This value is used when you are using a specialized disk to create the virtual machine.<br><br> **FromImage** \u2013 This value is used when you are using an image to create the virtual machine. If you are using a platform image, you also use the imageReference element described above. If you are using a marketplace image, you  also use the plan element previously described.
         */
        createOption: string;
        /**
         * Specifies the ephemeral Disk Settings for the operating system disk used by the virtual machine.
         */
        diffDiskSettings?: outputs.compute.DiffDiskSettingsResponse;
        /**
         * Specifies the size of an empty data disk in gigabytes. This element can be used to overwrite the size of the disk in a virtual machine image. <br><br> This value cannot be larger than 1023 GB
         */
        diskSizeGB?: number;
        /**
         * Specifies the encryption settings for the OS Disk. <br><br> Minimum api-version: 2015-06-15
         */
        encryptionSettings?: outputs.compute.DiskEncryptionSettingsResponse;
        /**
         * The source user image virtual hard disk. The virtual hard disk will be copied before being attached to the virtual machine. If SourceImage is provided, the destination virtual hard drive must not exist.
         */
        image?: outputs.compute.VirtualHardDiskResponse;
        /**
         * The managed disk parameters.
         */
        managedDisk?: outputs.compute.ManagedDiskParametersResponse;
        /**
         * The disk name.
         */
        name?: string;
        /**
         * This property allows you to specify the type of the OS that is included in the disk if creating a VM from user-image or a specialized VHD. <br><br> Possible values are: <br><br> **Windows** <br><br> **Linux**
         */
        osType?: string;
        /**
         * The virtual hard disk.
         */
        vhd?: outputs.compute.VirtualHardDiskResponse;
        /**
         * Specifies whether writeAccelerator should be enabled or disabled on the disk.
         */
        writeAcceleratorEnabled?: boolean;
    }

    /**
     * Specifies the operating system settings for the virtual machine. Some of the settings cannot be changed once VM is provisioned.
     */
    export interface OSProfileResponse {
        /**
         * Specifies the password of the administrator account. <br><br> **Minimum-length (Windows):** 8 characters <br><br> **Minimum-length (Linux):** 6 characters <br><br> **Max-length (Windows):** 123 characters <br><br> **Max-length (Linux):** 72 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\W_]) <br><br> **Disallowed values:** "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1", "Password22", "iloveyou!" <br><br> For resetting the password, see [How to reset the Remote Desktop service or its login password in a Windows VM](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-reset-rdp?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) <br><br> For resetting root password, see [Manage users, SSH, and check or repair disks on Azure Linux VMs using the VMAccess Extension](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-vmaccess-extension?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json#reset-root-password)
         */
        adminPassword?: string;
        /**
         * Specifies the name of the administrator account. <br><br> This property cannot be updated after the VM is created. <br><br> **Windows-only restriction:** Cannot end in "." <br><br> **Disallowed values:** "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123", "a", "actuser", "adm", "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server", "sql", "support", "support_388945a0", "sys", "test2", "test3", "user4", "user5". <br><br> **Minimum-length (Linux):** 1  character <br><br> **Max-length (Linux):** 64 characters <br><br> **Max-length (Windows):** 20 characters  <br><br><li> For root access to the Linux VM, see [Using root privileges on Linux virtual machines in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-use-root-privileges?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)<br><li> For a list of built-in system users on Linux that should not be used in this field, see [Selecting User Names for Linux on Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-usernames?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
         */
        adminUsername?: string;
        /**
         * Specifies whether extension operations should be allowed on the virtual machine. <br><br>This may only be set to False when no extensions are present on the virtual machine.
         */
        allowExtensionOperations?: boolean;
        /**
         * Specifies the host OS name of the virtual machine. <br><br> This name cannot be updated after the VM is created. <br><br> **Max-length (Windows):** 15 characters <br><br> **Max-length (Linux):** 64 characters. <br><br> For naming conventions and restrictions see [Azure infrastructure services implementation guidelines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-infrastructure-subscription-accounts-guidelines?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json#1-naming-conventions).
         */
        computerName?: string;
        /**
         * Specifies a base-64 encoded string of custom data. The base-64 encoded string is decoded to a binary array that is saved as a file on the Virtual Machine. The maximum length of the binary array is 65535 bytes. <br><br> **Note: Do not pass any secrets or passwords in customData property** <br><br> This property cannot be updated after the VM is created. <br><br> customData is passed to the VM to be saved as a file, for more information see [Custom Data on Azure VMs](https://azure.microsoft.com/en-us/blog/custom-data-and-cloud-init-on-windows-azure/) <br><br> For using cloud-init for your Linux VM, see [Using cloud-init to customize a Linux VM during creation](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-cloud-init?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
         */
        customData?: string;
        /**
         * Specifies the Linux operating system settings on the virtual machine. <br><br>For a list of supported Linux distributions, see [Linux on Azure-Endorsed Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-endorsed-distros?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json) <br><br> For running non-endorsed distributions, see [Information for Non-Endorsed Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-create-upload-generic?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
         */
        linuxConfiguration?: outputs.compute.LinuxConfigurationResponse;
        /**
         * Specifies whether the guest provision signal is required to infer provision success of the virtual machine.  **Note: This property is for private testing only, and all customers must not set the property to false.**
         */
        requireGuestProvisionSignal?: boolean;
        /**
         * Specifies set of certificates that should be installed onto the virtual machine.
         */
        secrets?: outputs.compute.VaultSecretGroupResponse[];
        /**
         * Specifies Windows operating system settings on the virtual machine.
         */
        windowsConfiguration?: outputs.compute.WindowsConfigurationResponse;
    }

    export interface PatchSettingsResponse {
        /**
         * Specifies the mode of in-guest patching to IaaS virtual machine.<br /><br /> Possible values are:<br /><br /> **Manual** - You  control the application of patches to a virtual machine. You do this by applying patches manually inside the VM. In this mode, automatic updates are disabled; the property WindowsConfiguration.enableAutomaticUpdates must be false<br /><br /> **AutomaticByOS** - The virtual machine will automatically be updated by the OS. The property WindowsConfiguration.enableAutomaticUpdates must be true. <br /><br /> ** AutomaticByPlatform** - the virtual machine will automatically updated by the OS. The properties provisionVMAgent and WindowsConfiguration.enableAutomaticUpdates must be true 
         */
        patchMode?: string;
    }

    /**
     * Specifies information about the marketplace image used to create the virtual machine. This element is only used for marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic use.  In the Azure portal, find the marketplace image that you want to use and then click **Want to deploy programmatically, Get Started ->**. Enter any required information and then click **Save**.
     */
    export interface PlanResponse {
        /**
         * The plan ID.
         */
        name?: string;
        /**
         * Specifies the product of the image from the marketplace. This is the same value as Offer under the imageReference element.
         */
        product?: string;
        /**
         * The promotion code.
         */
        promotionCode?: string;
        /**
         * The publisher ID.
         */
        publisher?: string;
    }

    /**
     * Properties of the PrivateEndpointConnectProperties.
     */
    export interface PrivateEndpointConnectionPropertiesResponse {
        /**
         * The resource of private end point.
         */
        privateEndpoint?: outputs.compute.PrivateEndpointResponse;
        /**
         * A collection of information about the state of the connection between DiskAccess and Virtual Network.
         */
        privateLinkServiceConnectionState: outputs.compute.PrivateLinkServiceConnectionStateResponse;
        /**
         * The provisioning state of the private endpoint connection resource.
         */
        provisioningState?: string;
    }

    /**
     * The Private Endpoint Connection resource.
     */
    export interface PrivateEndpointConnectionResponse {
        /**
         * private endpoint connection Id
         */
        id: string;
        /**
         * private endpoint connection name
         */
        name: string;
        /**
         * Resource properties.
         */
        properties?: outputs.compute.PrivateEndpointConnectionPropertiesResponse;
        /**
         * private endpoint connection type
         */
        type: string;
    }

    /**
     * The Private Endpoint resource.
     */
    export interface PrivateEndpointResponse {
        /**
         * The ARM identifier for Private Endpoint
         */
        id: string;
    }

    /**
     * A collection of information about the state of the connection between service consumer and provider.
     */
    export interface PrivateLinkServiceConnectionStateResponse {
        /**
         * A message indicating if changes on the service provider require any updates on the consumer.
         */
        actionsRequired?: string;
        /**
         * The reason for approval/rejection of the connection.
         */
        description?: string;
        /**
         * Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
         */
        status?: string;
    }

    /**
     * Describes the properties of a Proximity Placement Group.
     */
    export interface ProximityPlacementGroupPropertiesResponse {
        /**
         * A list of references to all availability sets in the proximity placement group.
         */
        availabilitySets: outputs.compute.SubResourceWithColocationStatusResponse[];
        /**
         * Describes colocation status of the Proximity Placement Group.
         */
        colocationStatus?: outputs.compute.InstanceViewStatusResponse;
        /**
         * Specifies the type of the proximity placement group. <br><br> Possible values are: <br><br> **Standard** : Co-locate resources within an Azure region or Availability Zone. <br><br> **Ultra** : For future use.
         */
        proximityPlacementGroupType?: string;
        /**
         * A list of references to all virtual machine scale sets in the proximity placement group.
         */
        virtualMachineScaleSets: outputs.compute.SubResourceWithColocationStatusResponse[];
        /**
         * A list of references to all virtual machines in the proximity placement group.
         */
        virtualMachines: outputs.compute.SubResourceWithColocationStatusResponse[];
    }

    /**
     * The properties describe the recommended machine configuration for this Image Definition. These properties are updatable.
     */
    export interface RecommendedMachineConfigurationResponse {
        /**
         * Describes the resource range.
         */
        memory?: outputs.compute.ResourceRangeResponse;
        /**
         * Describes the resource range.
         */
        vCPUs?: outputs.compute.ResourceRangeResponse;
    }

    /**
     * This is the regional replication status.
     */
    export interface RegionalReplicationStatusResponse {
        /**
         * The details of the replication status.
         */
        details: string;
        /**
         * It indicates progress of the replication job.
         */
        progress: number;
        /**
         * The region to which the gallery Image Version is being replicated to.
         */
        region: string;
        /**
         * This is the regional replication state.
         */
        state: string;
    }

    /**
     * This is the replication status of the gallery Image Version.
     */
    export interface ReplicationStatusResponse {
        /**
         * This is the aggregated replication status based on all the regional replication status flags.
         */
        aggregatedState: string;
        /**
         * This is a summary of replication status for each region.
         */
        summary: outputs.compute.RegionalReplicationStatusResponse[];
    }

    /**
     * Describes the resource range.
     */
    export interface ResourceRangeResponse {
        /**
         * The maximum number of the resource.
         */
        max?: number;
        /**
         * The minimum number of the resource.
         */
        min?: number;
    }

    /**
     * The configuration parameters used while performing a rolling upgrade.
     */
    export interface RollingUpgradePolicyResponse {
        /**
         * The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability. The default value for this parameter is 20%.
         */
        maxBatchInstancePercent?: number;
        /**
         * The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch. The default value for this parameter is 20%.
         */
        maxUnhealthyInstancePercent?: number;
        /**
         * The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts. The default value for this parameter is 20%.
         */
        maxUnhealthyUpgradedInstancePercent?: number;
        /**
         * The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format. The default value is 0 seconds (PT0S).
         */
        pauseTimeBetweenBatches?: string;
    }

    /**
     * Describes a scale-in policy for a virtual machine scale set.
     */
    export interface ScaleInPolicyResponse {
        /**
         * The rules to be followed when scaling-in a virtual machine scale set. <br><br> Possible values are: <br><br> **Default** When a virtual machine scale set is scaled in, the scale set will first be balanced across zones if it is a zonal scale set. Then, it will be balanced across Fault Domains as far as possible. Within each Fault Domain, the virtual machines chosen for removal will be the newest ones that are not protected from scale-in. <br><br> **OldestVM** When a virtual machine scale set is being scaled-in, the oldest virtual machines that are not protected from scale-in will be chosen for removal. For zonal virtual machine scale sets, the scale set will first be balanced across zones. Within each zone, the oldest virtual machines that are not protected will be chosen for removal. <br><br> **NewestVM** When a virtual machine scale set is being scaled-in, the newest virtual machines that are not protected from scale-in will be chosen for removal. For zonal virtual machine scale sets, the scale set will first be balanced across zones. Within each zone, the newest virtual machines that are not protected will be chosen for removal. <br><br>
         */
        rules?: string[];
    }

    export interface ScheduledEventsProfileResponse {
        /**
         * Specifies Terminate Scheduled Event related configurations.
         */
        terminateNotificationProfile?: outputs.compute.TerminateNotificationProfileResponse;
    }

    /**
     * Specifies the Security profile settings for the virtual machine or virtual machine scale set.
     */
    export interface SecurityProfileResponse {
        /**
         * This property can be used by user in the request to enable or disable the Host Encryption for the virtual machine or virtual machine scale set. This will enable the encryption for all the disks including Resource/Temp disk at host itself. <br><br> Default: The Encryption at host will be disabled unless this property is set to true for the resource.
         */
        encryptionAtHost?: boolean;
    }

    export interface ShareInfoElementResponse {
        /**
         * A relative URI containing the ID of the VM that has the disk attached.
         */
        vmUri: string;
    }

    /**
     * Describes a virtual machine scale set sku. NOTE: If the new VM SKU is not supported on the hardware the scale set is currently on, you need to deallocate the VMs in the scale set before you modify the SKU name.
     */
    export interface SkuResponse {
        /**
         * Specifies the number of virtual machines in the scale set.
         */
        capacity?: number;
        /**
         * The sku name.
         */
        name?: string;
        /**
         * Specifies the tier of virtual machines in a scale set.<br /><br /> Possible Values:<br /><br /> **Standard**<br /><br /> **Basic**
         */
        tier?: string;
    }

    /**
     * Snapshot resource properties.
     */
    export interface SnapshotPropertiesResponse {
        /**
         * Disk source information. CreationData information cannot be changed after the disk has been created.
         */
        creationData: outputs.compute.CreationDataResponse;
        /**
         * ARM id of the DiskAccess resource for using private endpoints on disks.
         */
        diskAccessId?: string;
        /**
         * The size of the disk in bytes. This field is read only.
         */
        diskSizeBytes: number;
        /**
         * If creationData.createOption is Empty, this field is mandatory and it indicates the size of the disk to create. If this field is present for updates or creation with other options, it indicates a resize. Resizes are only allowed if the disk is not attached to a running VM, and can only increase the disk's size.
         */
        diskSizeGB?: number;
        /**
         * Encryption property can be used to encrypt data at rest with customer managed keys or platform managed keys.
         */
        encryption?: outputs.compute.EncryptionResponse;
        /**
         * Encryption settings collection used be Azure Disk Encryption, can contain multiple encryption settings per disk or snapshot.
         */
        encryptionSettingsCollection?: outputs.compute.EncryptionSettingsCollectionResponse;
        /**
         * The hypervisor generation of the Virtual Machine. Applicable to OS disks only.
         */
        hyperVGeneration?: string;
        /**
         * Whether a snapshot is incremental. Incremental snapshots on the same disk occupy less space than full snapshots and can be diffed.
         */
        incremental?: boolean;
        /**
         * Policy for accessing the disk via network.
         */
        networkAccessPolicy?: string;
        /**
         * The Operating System type.
         */
        osType?: string;
        /**
         * The disk provisioning state.
         */
        provisioningState: string;
        /**
         * The time when the snapshot was created.
         */
        timeCreated: string;
        /**
         * Unique Guid identifying the resource.
         */
        uniqueId: string;
    }

    /**
     * The snapshots sku name. Can be Standard_LRS, Premium_LRS, or Standard_ZRS.
     */
    export interface SnapshotSkuResponse {
        /**
         * The sku name.
         */
        name?: string;
        /**
         * The sku tier.
         */
        tier: string;
    }

    /**
     * The vault id is an Azure Resource Manager Resource id in the form /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}
     */
    export interface SourceVaultResponse {
        /**
         * Resource Id
         */
        id?: string;
    }

    /**
     * SSH configuration for Linux based VMs running on Azure
     */
    export interface SshConfigurationResponse {
        /**
         * The list of SSH public keys used to authenticate with linux based VMs.
         */
        publicKeys?: outputs.compute.SshPublicKeyResponse[];
    }

    /**
     * Properties of the SSH public key.
     */
    export interface SshPublicKeyResourcePropertiesResponse {
        /**
         * SSH public key used to authenticate to a virtual machine through ssh. If this property is not initially provided when the resource is created, the publicKey property will be populated when generateKeyPair is called. If the public key is provided upon resource creation, the provided public key needs to be at least 2048-bit and in ssh-rsa format.
         */
        publicKey?: string;
    }

    /**
     * Contains information about SSH certificate public key and the path on the Linux VM where the public key is placed.
     */
    export interface SshPublicKeyResponse {
        /**
         * SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Linux VMs in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-mac-create-ssh-keys?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
         */
        keyData?: string;
        /**
         * Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
         */
        path?: string;
    }

    /**
     * Specifies the storage settings for the virtual machine disks.
     */
    export interface StorageProfileResponse {
        /**
         * Specifies the parameters that are used to add a data disk to a virtual machine. <br><br> For more information about disks, see [About disks and VHDs for Azure virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
         */
        dataDisks?: outputs.compute.DataDiskResponse[];
        /**
         * Specifies information about the image to use. You can specify information about platform images, marketplace images, or virtual machine images. This element is required when you want to use a platform image, marketplace image, or virtual machine image, but is not used in other creation operations.
         */
        imageReference?: outputs.compute.ImageReferenceResponse;
        /**
         * Specifies information about the operating system disk used by the virtual machine. <br><br> For more information about disks, see [About disks and VHDs for Azure virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
         */
        osDisk?: outputs.compute.OSDiskResponse;
    }

    export interface SubResourceReadOnlyResponse {
        /**
         * Resource Id
         */
        id: string;
    }

    export interface SubResourceResponse {
        /**
         * Resource Id
         */
        id?: string;
    }

    export interface SubResourceWithColocationStatusResponse {
        /**
         * Describes colocation status of a resource in the Proximity Placement Group.
         */
        colocationStatus?: outputs.compute.InstanceViewStatusResponse;
        /**
         * Resource Id
         */
        id?: string;
    }

    /**
     * Describes the target region information.
     */
    export interface TargetRegionResponse {
        /**
         * Optional. Allows users to provide customer managed keys for encrypting the OS and data disks in the gallery artifact.
         */
        encryption?: outputs.compute.EncryptionImagesResponse;
        /**
         * The name of the region.
         */
        name: string;
        /**
         * The number of replicas of the Image Version to be created per region. This property is updatable.
         */
        regionalReplicaCount?: number;
        /**
         * Specifies the storage account type to be used to store the image. This property is not updatable.
         */
        storageAccountType?: string;
    }

    export interface TerminateNotificationProfileResponse {
        /**
         * Specifies whether the Terminate Scheduled event is enabled or disabled.
         */
        enable?: boolean;
        /**
         * Configurable length of time a Virtual Machine being deleted will have to potentially approve the Terminate Scheduled Event before the event is auto approved (timed out). The configuration must be specified in ISO 8601 format, the default value is 5 minutes (PT5M)
         */
        notBeforeTimeout?: string;
    }

    /**
     * Describes an upgrade policy - automatic, manual, or rolling.
     */
    export interface UpgradePolicyResponse {
        /**
         * Configuration parameters used for performing automatic OS Upgrade.
         */
        automaticOSUpgradePolicy?: outputs.compute.AutomaticOSUpgradePolicyResponse;
        /**
         * Specifies the mode of an upgrade to virtual machines in the scale set.<br /><br /> Possible values are:<br /><br /> **Manual** - You  control the application of updates to virtual machines in the scale set. You do this by using the manualUpgrade action.<br /><br /> **Automatic** - All virtual machines in the scale set are  automatically updated at the same time.
         */
        mode?: string;
        /**
         * The configuration parameters used while performing a rolling upgrade.
         */
        rollingUpgradePolicy?: outputs.compute.RollingUpgradePolicyResponse;
    }

    /**
     * The source image from which the Image Version is going to be created.
     */
    export interface UserArtifactSourceResponse {
        /**
         * Required. The fileName of the artifact.
         */
        fileName: string;
        /**
         * Required. The mediaLink of the artifact, must be a readable storage blob.
         */
        mediaLink: string;
    }

    /**
     * Information about the VM.
     */
    export interface VMInfoResponse {
        /**
         * Azure resource Id of the VM.
         */
        id: string;
        /**
         * UUID(Universally Unique Identifier) of the VM.
         */
        uuid: string;
    }

    /**
     * Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
     */
    export interface VaultCertificateResponse {
        /**
         * For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name &lt;UppercaseThumbprint&gt;.crt for the X509 certificate file and &lt;UppercaseThumbprint&gt;.prv for private key. Both of these files are .pem formatted.
         */
        certificateStore?: string;
        /**
         * This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
         */
        certificateUrl?: string;
    }

    /**
     * Describes a set of certificates which are all in the same Key Vault.
     */
    export interface VaultSecretGroupResponse {
        /**
         * The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
         */
        sourceVault?: outputs.compute.SubResourceResponse;
        /**
         * The list of key vault references in SourceVault which contain certificates.
         */
        vaultCertificates?: outputs.compute.VaultCertificateResponse[];
    }

    /**
     * Describes the uri of a disk.
     */
    export interface VirtualHardDiskResponse {
        /**
         * Specifies the virtual hard disk's uri.
         */
        uri?: string;
    }

    /**
     * The instance view of the VM Agent running on the virtual machine.
     */
    export interface VirtualMachineAgentInstanceViewResponse {
        /**
         * The virtual machine extension handler instance view.
         */
        extensionHandlers?: outputs.compute.VirtualMachineExtensionHandlerInstanceViewResponse[];
        /**
         * The resource status information.
         */
        statuses?: outputs.compute.InstanceViewStatusResponse[];
        /**
         * The VM Agent full version.
         */
        vmAgentVersion?: string;
    }

    /**
     * The instance view of a virtual machine extension handler.
     */
    export interface VirtualMachineExtensionHandlerInstanceViewResponse {
        /**
         * The extension handler status.
         */
        status?: outputs.compute.InstanceViewStatusResponse;
        /**
         * Specifies the type of the extension; an example is "CustomScriptExtension".
         */
        type?: string;
        /**
         * Specifies the version of the script handler.
         */
        typeHandlerVersion?: string;
    }

    /**
     * The instance view of a virtual machine extension.
     */
    export interface VirtualMachineExtensionInstanceViewResponse {
        /**
         * The virtual machine extension name.
         */
        name?: string;
        /**
         * The resource status information.
         */
        statuses?: outputs.compute.InstanceViewStatusResponse[];
        /**
         * The resource status information.
         */
        substatuses?: outputs.compute.InstanceViewStatusResponse[];
        /**
         * Specifies the type of the extension; an example is "CustomScriptExtension".
         */
        type?: string;
        /**
         * Specifies the version of the script handler.
         */
        typeHandlerVersion?: string;
    }

    /**
     * Describes the properties of a Virtual Machine Extension.
     */
    export interface VirtualMachineExtensionPropertiesResponse {
        /**
         * Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
         */
        autoUpgradeMinorVersion?: boolean;
        /**
         * How the extension handler should be forced to update even if the extension configuration has not changed.
         */
        forceUpdateTag?: string;
        /**
         * The virtual machine extension instance view.
         */
        instanceView?: outputs.compute.VirtualMachineExtensionInstanceViewResponse;
        /**
         * The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
         */
        protectedSettings?: {[key: string]: string};
        /**
         * The provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * The name of the extension handler publisher.
         */
        publisher?: string;
        /**
         * Json formatted public settings for the extension.
         */
        settings?: {[key: string]: string};
        /**
         * Specifies the type of the extension; an example is "CustomScriptExtension".
         */
        type?: string;
        /**
         * Specifies the version of the script handler.
         */
        typeHandlerVersion?: string;
    }

    /**
     * Describes a Virtual Machine Extension.
     */
    export interface VirtualMachineExtensionResponse {
        /**
         * Resource Id
         */
        id: string;
        /**
         * Resource location
         */
        location: string;
        /**
         * Resource name
         */
        name: string;
        /**
         * Describes the properties of a Virtual Machine Extension.
         */
        properties?: outputs.compute.VirtualMachineExtensionPropertiesResponse;
        /**
         * Resource tags
         */
        tags?: {[key: string]: string};
        /**
         * Resource type
         */
        type: string;
    }

    /**
     * The health status of the VM.
     */
    export interface VirtualMachineHealthStatusResponse {
        /**
         * The health status information for the VM.
         */
        status: outputs.compute.InstanceViewStatusResponse;
    }

    /**
     * Identity for the virtual machine.
     */
    export interface VirtualMachineIdentityResponse {
        /**
         * The principal id of virtual machine identity. This property will only be provided for a system assigned identity.
         */
        principalId: string;
        /**
         * The tenant id associated with the virtual machine. This property will only be provided for a system assigned identity.
         */
        tenantId: string;
        /**
         * The type of identity used for the virtual machine. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual machine.
         */
        type?: string;
        /**
         * The list of user identities associated with the Virtual Machine. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
         */
        userAssignedIdentities?: {[key: string]: string};
    }

    /**
     * The instance view of a virtual machine.
     */
    export interface VirtualMachineInstanceViewResponse {
        /**
         * Resource id of the dedicated host, on which the virtual machine is allocated through automatic placement, when the virtual machine is associated with a dedicated host group that has automatic placement enabled. <br><br>Minimum api-version: 2020-06-01.
         */
        assignedHost: string;
        /**
         * Boot Diagnostics is a debugging feature which allows you to view Console Output and Screenshot to diagnose VM status. <br><br> You can easily view the output of your console log. <br><br> Azure also enables you to see a screenshot of the VM from the hypervisor.
         */
        bootDiagnostics?: outputs.compute.BootDiagnosticsInstanceViewResponse;
        /**
         * The computer name assigned to the virtual machine.
         */
        computerName?: string;
        /**
         * The virtual machine disk information.
         */
        disks?: outputs.compute.DiskInstanceViewResponse[];
        /**
         * The extensions information.
         */
        extensions?: outputs.compute.VirtualMachineExtensionInstanceViewResponse[];
        /**
         * Specifies the HyperVGeneration Type associated with a resource
         */
        hyperVGeneration?: string;
        /**
         * The Maintenance Operation status on the virtual machine.
         */
        maintenanceRedeployStatus?: outputs.compute.MaintenanceRedeployStatusResponse;
        /**
         * The Operating System running on the virtual machine.
         */
        osName?: string;
        /**
         * The version of Operating System running on the virtual machine.
         */
        osVersion?: string;
        /**
         * Specifies the fault domain of the virtual machine.
         */
        platformFaultDomain?: number;
        /**
         * Specifies the update domain of the virtual machine.
         */
        platformUpdateDomain?: number;
        /**
         * The Remote desktop certificate thumbprint.
         */
        rdpThumbPrint?: string;
        /**
         * The resource status information.
         */
        statuses?: outputs.compute.InstanceViewStatusResponse[];
        /**
         * The VM Agent running on the virtual machine.
         */
        vmAgent?: outputs.compute.VirtualMachineAgentInstanceViewResponse;
        /**
         * The health status for the VM.
         */
        vmHealth: outputs.compute.VirtualMachineHealthStatusResponse;
    }

    /**
     * Describes the properties of a Virtual Machine.
     */
    export interface VirtualMachinePropertiesResponse {
        /**
         * Specifies additional capabilities enabled or disabled on the virtual machine.
         */
        additionalCapabilities?: outputs.compute.AdditionalCapabilitiesResponse;
        /**
         * Specifies information about the availability set that the virtual machine should be assigned to. Virtual machines specified in the same availability set are allocated to different nodes to maximize availability. For more information about availability sets, see [Manage the availability of virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-manage-availability?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json). <br><br> For more information on Azure planned maintenance, see [Planned maintenance for virtual machines in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-planned-maintenance?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) <br><br> Currently, a VM can only be added to availability set at creation time. The availability set to which the VM is being added should be under the same resource group as the availability set resource. An existing VM cannot be added to an availability set. <br><br>This property cannot exist along with a non-null properties.virtualMachineScaleSet reference.
         */
        availabilitySet?: outputs.compute.SubResourceResponse;
        /**
         * Specifies the billing related details of a Azure Spot virtual machine. <br><br>Minimum api-version: 2019-03-01.
         */
        billingProfile?: outputs.compute.BillingProfileResponse;
        /**
         * Specifies the boot diagnostic settings state. <br><br>Minimum api-version: 2015-06-15.
         */
        diagnosticsProfile?: outputs.compute.DiagnosticsProfileResponse;
        /**
         * Specifies the eviction policy for the Azure Spot virtual machine and Azure Spot scale set. <br><br>For Azure Spot virtual machines, both 'Deallocate' and 'Delete' are supported and the minimum api-version is 2019-03-01. <br><br>For Azure Spot scale sets, both 'Deallocate' and 'Delete' are supported and the minimum api-version is 2017-10-30-preview.
         */
        evictionPolicy?: string;
        /**
         * Specifies the time alloted for all extensions to start. The time duration should be between 15 minutes and 120 minutes (inclusive) and should be specified in ISO 8601 format. The default value is 90 minutes (PT1H30M). <br><br> Minimum api-version: 2020-06-01
         */
        extensionsTimeBudget?: string;
        /**
         * Specifies the hardware settings for the virtual machine.
         */
        hardwareProfile?: outputs.compute.HardwareProfileResponse;
        /**
         * Specifies information about the dedicated host that the virtual machine resides in. <br><br>Minimum api-version: 2018-10-01.
         */
        host?: outputs.compute.SubResourceResponse;
        /**
         * Specifies information about the dedicated host group that the virtual machine resides in. <br><br>Minimum api-version: 2020-06-01. <br><br>NOTE: User cannot specify both host and hostGroup properties.
         */
        hostGroup?: outputs.compute.SubResourceResponse;
        /**
         * The virtual machine instance view.
         */
        instanceView: outputs.compute.VirtualMachineInstanceViewResponse;
        /**
         * Specifies that the image or disk that is being used was licensed on-premises. This element is only used for images that contain the Windows Server operating system. <br><br> Possible values are: <br><br> Windows_Client <br><br> Windows_Server <br><br> If this element is included in a request for an update, the value must match the initial value. This value cannot be updated. <br><br> For more information, see [Azure Hybrid Use Benefit for Windows Server](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-hybrid-use-benefit-licensing?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) <br><br> Minimum api-version: 2015-06-15
         */
        licenseType?: string;
        /**
         * Specifies the network interfaces of the virtual machine.
         */
        networkProfile?: outputs.compute.NetworkProfileResponse;
        /**
         * Specifies the operating system settings used while creating the virtual machine. Some of the settings cannot be changed once VM is provisioned.
         */
        osProfile?: outputs.compute.OSProfileResponse;
        /**
         * Specifies the priority for the virtual machine. <br><br>Minimum api-version: 2019-03-01
         */
        priority?: string;
        /**
         * The provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * Specifies information about the proximity placement group that the virtual machine should be assigned to. <br><br>Minimum api-version: 2018-04-01.
         */
        proximityPlacementGroup?: outputs.compute.SubResourceResponse;
        /**
         * Specifies the Security related profile settings for the virtual machine.
         */
        securityProfile?: outputs.compute.SecurityProfileResponse;
        /**
         * Specifies the storage settings for the virtual machine disks.
         */
        storageProfile?: outputs.compute.StorageProfileResponse;
        /**
         * Specifies information about the virtual machine scale set that the virtual machine should be assigned to. Virtual machines specified in the same virtual machine scale set are allocated to different nodes to maximize availability. Currently, a VM can only be added to virtual machine scale set at creation time. An existing VM cannot be added to a virtual machine scale set. <br><br>This property cannot exist along with a non-null properties.availabilitySet reference. <br><br>Minimum api‐version: 2019‐03‐01
         */
        virtualMachineScaleSet?: outputs.compute.SubResourceResponse;
        /**
         * Specifies the VM unique ID which is a 128-bits identifier that is encoded and stored in all Azure IaaS VMs SMBIOS and can be read using platform BIOS commands.
         */
        vmId: string;
    }

    /**
     * Describes a virtual machine scale set data disk.
     */
    export interface VirtualMachineScaleSetDataDiskResponse {
        /**
         * Specifies the caching requirements. <br><br> Possible values are: <br><br> **None** <br><br> **ReadOnly** <br><br> **ReadWrite** <br><br> Default: **None for Standard storage. ReadOnly for Premium storage**
         */
        caching?: string;
        /**
         * The create option.
         */
        createOption: string;
        /**
         * Specifies the Read-Write IOPS for the managed disk. Should be used only when StorageAccountType is UltraSSD_LRS. If not specified, a default value would be assigned based on diskSizeGB.
         */
        diskIOPSReadWrite?: number;
        /**
         * Specifies the bandwidth in MB per second for the managed disk. Should be used only when StorageAccountType is UltraSSD_LRS. If not specified, a default value would be assigned based on diskSizeGB.
         */
        diskMBpsReadWrite?: number;
        /**
         * Specifies the size of an empty data disk in gigabytes. This element can be used to overwrite the size of the disk in a virtual machine image. <br><br> This value cannot be larger than 1023 GB
         */
        diskSizeGB?: number;
        /**
         * Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM.
         */
        lun: number;
        /**
         * The managed disk parameters.
         */
        managedDisk?: outputs.compute.VirtualMachineScaleSetManagedDiskParametersResponse;
        /**
         * The disk name.
         */
        name?: string;
        /**
         * Specifies whether writeAccelerator should be enabled or disabled on the disk.
         */
        writeAcceleratorEnabled?: boolean;
    }

    /**
     * Describes a virtual machine scale set extension profile.
     */
    export interface VirtualMachineScaleSetExtensionProfileResponse {
        /**
         * The virtual machine scale set child extension resources.
         */
        extensions?: outputs.compute.VirtualMachineScaleSetExtensionResponse[];
        /**
         * Specifies the time alloted for all extensions to start. The time duration should be between 15 minutes and 120 minutes (inclusive) and should be specified in ISO 8601 format. The default value is 90 minutes (PT1H30M). <br><br> Minimum api-version: 2020-06-01
         */
        extensionsTimeBudget?: string;
    }

    /**
     * Describes the properties of a Virtual Machine Scale Set Extension.
     */
    export interface VirtualMachineScaleSetExtensionPropertiesResponse {
        /**
         * Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
         */
        autoUpgradeMinorVersion?: boolean;
        /**
         * If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
         */
        forceUpdateTag?: string;
        /**
         * The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
         */
        protectedSettings?: {[key: string]: string};
        /**
         * Collection of extension names after which this extension needs to be provisioned.
         */
        provisionAfterExtensions?: string[];
        /**
         * The provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * The name of the extension handler publisher.
         */
        publisher?: string;
        /**
         * Json formatted public settings for the extension.
         */
        settings?: {[key: string]: string};
        /**
         * Specifies the type of the extension; an example is "CustomScriptExtension".
         */
        type?: string;
        /**
         * Specifies the version of the script handler.
         */
        typeHandlerVersion?: string;
    }

    /**
     * Describes a Virtual Machine Scale Set Extension.
     */
    export interface VirtualMachineScaleSetExtensionResponse {
        /**
         * Resource Id
         */
        id: string;
        /**
         * The name of the extension.
         */
        name?: string;
        /**
         * Describes the properties of a Virtual Machine Scale Set Extension.
         */
        properties?: outputs.compute.VirtualMachineScaleSetExtensionPropertiesResponse;
        /**
         * Resource type
         */
        type: string;
    }

    /**
     * Describes a virtual machine scale set network profile's IP configuration properties.
     */
    export interface VirtualMachineScaleSetIPConfigurationPropertiesResponse {
        /**
         * Specifies an array of references to backend address pools of application gateways. A scale set can reference backend address pools of multiple application gateways. Multiple scale sets cannot use the same application gateway.
         */
        applicationGatewayBackendAddressPools?: outputs.compute.SubResourceResponse[];
        /**
         * Specifies an array of references to application security group.
         */
        applicationSecurityGroups?: outputs.compute.SubResourceResponse[];
        /**
         * Specifies an array of references to backend address pools of load balancers. A scale set can reference backend address pools of one public and one internal load balancer. Multiple scale sets cannot use the same basic sku load balancer.
         */
        loadBalancerBackendAddressPools?: outputs.compute.SubResourceResponse[];
        /**
         * Specifies an array of references to inbound Nat pools of the load balancers. A scale set can reference inbound nat pools of one public and one internal load balancer. Multiple scale sets cannot use the same basic sku load balancer.
         */
        loadBalancerInboundNatPools?: outputs.compute.SubResourceResponse[];
        /**
         * Specifies the primary network interface in case the virtual machine has more than 1 network interface.
         */
        primary?: boolean;
        /**
         * Available from Api-Version 2017-03-30 onwards, it represents whether the specific ipconfiguration is IPv4 or IPv6. Default is taken as IPv4.  Possible values are: 'IPv4' and 'IPv6'.
         */
        privateIPAddressVersion?: string;
        /**
         * The publicIPAddressConfiguration.
         */
        publicIPAddressConfiguration?: outputs.compute.VirtualMachineScaleSetPublicIPAddressConfigurationResponse;
        /**
         * Specifies the identifier of the subnet.
         */
        subnet?: outputs.compute.ApiEntityReferenceResponse;
    }

    /**
     * Describes a virtual machine scale set network profile's IP configuration.
     */
    export interface VirtualMachineScaleSetIPConfigurationResponse {
        /**
         * Resource Id
         */
        id?: string;
        /**
         * The IP configuration name.
         */
        name: string;
        /**
         * Describes a virtual machine scale set network profile's IP configuration properties.
         */
        properties?: outputs.compute.VirtualMachineScaleSetIPConfigurationPropertiesResponse;
    }

    /**
     * Identity for the virtual machine scale set.
     */
    export interface VirtualMachineScaleSetIdentityResponse {
        /**
         * The principal id of virtual machine scale set identity. This property will only be provided for a system assigned identity.
         */
        principalId: string;
        /**
         * The tenant id associated with the virtual machine scale set. This property will only be provided for a system assigned identity.
         */
        tenantId: string;
        /**
         * The type of identity used for the virtual machine scale set. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual machine scale set.
         */
        type?: string;
        /**
         * The list of user identities associated with the virtual machine scale set. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
         */
        userAssignedIdentities?: {[key: string]: string};
    }

    /**
     * Contains the IP tag associated with the public IP address.
     */
    export interface VirtualMachineScaleSetIpTagResponse {
        /**
         * IP tag type. Example: FirstPartyUsage.
         */
        ipTagType?: string;
        /**
         * IP tag associated with the public IP. Example: SQL, Storage etc.
         */
        tag?: string;
    }

    /**
     * Describes the parameters of a ScaleSet managed disk.
     */
    export interface VirtualMachineScaleSetManagedDiskParametersResponse {
        /**
         * Specifies the customer managed disk encryption set resource id for the managed disk.
         */
        diskEncryptionSet?: outputs.compute.DiskEncryptionSetParametersResponse;
        /**
         * Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with data disks, it cannot be used with OS Disk.
         */
        storageAccountType?: string;
    }

    /**
     * Describes a virtual machines scale sets network configuration's DNS settings.
     */
    export interface VirtualMachineScaleSetNetworkConfigurationDnsSettingsResponse {
        /**
         * List of DNS servers IP addresses
         */
        dnsServers?: string[];
    }

    /**
     * Describes a virtual machine scale set network profile's IP configuration.
     */
    export interface VirtualMachineScaleSetNetworkConfigurationPropertiesResponse {
        /**
         * The dns settings to be applied on the network interfaces.
         */
        dnsSettings?: outputs.compute.VirtualMachineScaleSetNetworkConfigurationDnsSettingsResponse;
        /**
         * Specifies whether the network interface is accelerated networking-enabled.
         */
        enableAcceleratedNetworking?: boolean;
        /**
         * Whether IP forwarding enabled on this NIC.
         */
        enableIPForwarding?: boolean;
        /**
         * Specifies the IP configurations of the network interface.
         */
        ipConfigurations: outputs.compute.VirtualMachineScaleSetIPConfigurationResponse[];
        /**
         * The network security group.
         */
        networkSecurityGroup?: outputs.compute.SubResourceResponse;
        /**
         * Specifies the primary network interface in case the virtual machine has more than 1 network interface.
         */
        primary?: boolean;
    }

    /**
     * Describes a virtual machine scale set network profile's network configurations.
     */
    export interface VirtualMachineScaleSetNetworkConfigurationResponse {
        /**
         * Resource Id
         */
        id?: string;
        /**
         * The network configuration name.
         */
        name: string;
        /**
         * Describes a virtual machine scale set network profile's IP configuration.
         */
        properties?: outputs.compute.VirtualMachineScaleSetNetworkConfigurationPropertiesResponse;
    }

    /**
     * Describes a virtual machine scale set network profile.
     */
    export interface VirtualMachineScaleSetNetworkProfileResponse {
        /**
         * A reference to a load balancer probe used to determine the health of an instance in the virtual machine scale set. The reference will be in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/probes/{probeName}'.
         */
        healthProbe?: outputs.compute.ApiEntityReferenceResponse;
        /**
         * The list of network configurations.
         */
        networkInterfaceConfigurations?: outputs.compute.VirtualMachineScaleSetNetworkConfigurationResponse[];
    }

    /**
     * Describes a virtual machine scale set operating system disk.
     */
    export interface VirtualMachineScaleSetOSDiskResponse {
        /**
         * Specifies the caching requirements. <br><br> Possible values are: <br><br> **None** <br><br> **ReadOnly** <br><br> **ReadWrite** <br><br> Default: **None for Standard storage. ReadOnly for Premium storage**
         */
        caching?: string;
        /**
         * Specifies how the virtual machines in the scale set should be created.<br><br> The only allowed value is: **FromImage** \u2013 This value is used when you are using an image to create the virtual machine. If you are using a platform image, you also use the imageReference element described above. If you are using a marketplace image, you  also use the plan element previously described.
         */
        createOption: string;
        /**
         * Specifies the ephemeral disk Settings for the operating system disk used by the virtual machine scale set.
         */
        diffDiskSettings?: outputs.compute.DiffDiskSettingsResponse;
        /**
         * Specifies the size of the operating system disk in gigabytes. This element can be used to overwrite the size of the disk in a virtual machine image. <br><br> This value cannot be larger than 1023 GB
         */
        diskSizeGB?: number;
        /**
         * Specifies information about the unmanaged user image to base the scale set on.
         */
        image?: outputs.compute.VirtualHardDiskResponse;
        /**
         * The managed disk parameters.
         */
        managedDisk?: outputs.compute.VirtualMachineScaleSetManagedDiskParametersResponse;
        /**
         * The disk name.
         */
        name?: string;
        /**
         * This property allows you to specify the type of the OS that is included in the disk if creating a VM from user-image or a specialized VHD. <br><br> Possible values are: <br><br> **Windows** <br><br> **Linux**
         */
        osType?: string;
        /**
         * Specifies the container urls that are used to store operating system disks for the scale set.
         */
        vhdContainers?: string[];
        /**
         * Specifies whether writeAccelerator should be enabled or disabled on the disk.
         */
        writeAcceleratorEnabled?: boolean;
    }

    /**
     * Describes a virtual machine scale set OS profile.
     */
    export interface VirtualMachineScaleSetOSProfileResponse {
        /**
         * Specifies the password of the administrator account. <br><br> **Minimum-length (Windows):** 8 characters <br><br> **Minimum-length (Linux):** 6 characters <br><br> **Max-length (Windows):** 123 characters <br><br> **Max-length (Linux):** 72 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\W_]) <br><br> **Disallowed values:** "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1", "Password22", "iloveyou!" <br><br> For resetting the password, see [How to reset the Remote Desktop service or its login password in a Windows VM](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-reset-rdp?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) <br><br> For resetting root password, see [Manage users, SSH, and check or repair disks on Azure Linux VMs using the VMAccess Extension](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-vmaccess-extension?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json#reset-root-password)
         */
        adminPassword?: string;
        /**
         * Specifies the name of the administrator account. <br><br> **Windows-only restriction:** Cannot end in "." <br><br> **Disallowed values:** "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123", "a", "actuser", "adm", "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server", "sql", "support", "support_388945a0", "sys", "test2", "test3", "user4", "user5". <br><br> **Minimum-length (Linux):** 1  character <br><br> **Max-length (Linux):** 64 characters <br><br> **Max-length (Windows):** 20 characters  <br><br><li> For root access to the Linux VM, see [Using root privileges on Linux virtual machines in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-use-root-privileges?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)<br><li> For a list of built-in system users on Linux that should not be used in this field, see [Selecting User Names for Linux on Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-usernames?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
         */
        adminUsername?: string;
        /**
         * Specifies the computer name prefix for all of the virtual machines in the scale set. Computer name prefixes must be 1 to 15 characters long.
         */
        computerNamePrefix?: string;
        /**
         * Specifies a base-64 encoded string of custom data. The base-64 encoded string is decoded to a binary array that is saved as a file on the Virtual Machine. The maximum length of the binary array is 65535 bytes. <br><br> For using cloud-init for your VM, see [Using cloud-init to customize a Linux VM during creation](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-cloud-init?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
         */
        customData?: string;
        /**
         * Specifies the Linux operating system settings on the virtual machine. <br><br>For a list of supported Linux distributions, see [Linux on Azure-Endorsed Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-endorsed-distros?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json) <br><br> For running non-endorsed distributions, see [Information for Non-Endorsed Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-create-upload-generic?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
         */
        linuxConfiguration?: outputs.compute.LinuxConfigurationResponse;
        /**
         * Specifies set of certificates that should be installed onto the virtual machines in the scale set.
         */
        secrets?: outputs.compute.VaultSecretGroupResponse[];
        /**
         * Specifies Windows operating system settings on the virtual machine.
         */
        windowsConfiguration?: outputs.compute.WindowsConfigurationResponse;
    }

    /**
     * Describes the properties of a Virtual Machine Scale Set.
     */
    export interface VirtualMachineScaleSetPropertiesResponse {
        /**
         * Specifies additional capabilities enabled or disabled on the Virtual Machines in the Virtual Machine Scale Set. For instance: whether the Virtual Machines have the capability to support attaching managed data disks with UltraSSD_LRS storage account type.
         */
        additionalCapabilities?: outputs.compute.AdditionalCapabilitiesResponse;
        /**
         * Policy for automatic repairs.
         */
        automaticRepairsPolicy?: outputs.compute.AutomaticRepairsPolicyResponse;
        /**
         * When Overprovision is enabled, extensions are launched only on the requested number of VMs which are finally kept. This property will hence ensure that the extensions do not run on the extra overprovisioned VMs.
         */
        doNotRunExtensionsOnOverprovisionedVMs?: boolean;
        /**
         * Specifies information about the dedicated host group that the virtual machine scale set resides in. <br><br>Minimum api-version: 2020-06-01.
         */
        hostGroup?: outputs.compute.SubResourceResponse;
        /**
         * Specifies whether the Virtual Machine Scale Set should be overprovisioned.
         */
        overprovision?: boolean;
        /**
         * Fault Domain count for each placement group.
         */
        platformFaultDomainCount?: number;
        /**
         * The provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * Specifies information about the proximity placement group that the virtual machine scale set should be assigned to. <br><br>Minimum api-version: 2018-04-01.
         */
        proximityPlacementGroup?: outputs.compute.SubResourceResponse;
        /**
         * Specifies the scale-in policy that decides which virtual machines are chosen for removal when a Virtual Machine Scale Set is scaled-in.
         */
        scaleInPolicy?: outputs.compute.ScaleInPolicyResponse;
        /**
         * When true this limits the scale set to a single placement group, of max size 100 virtual machines. NOTE: If singlePlacementGroup is true, it may be modified to false. However, if singlePlacementGroup is false, it may not be modified to true.
         */
        singlePlacementGroup?: boolean;
        /**
         * Specifies the ID which uniquely identifies a Virtual Machine Scale Set.
         */
        uniqueId: string;
        /**
         * The upgrade policy.
         */
        upgradePolicy?: outputs.compute.UpgradePolicyResponse;
        /**
         * The virtual machine profile.
         */
        virtualMachineProfile?: outputs.compute.VirtualMachineScaleSetVMProfileResponse;
        /**
         * Whether to force strictly even Virtual Machine distribution cross x-zones in case there is zone outage.
         */
        zoneBalance?: boolean;
    }

    /**
     * Describes a virtual machines scale sets network configuration's DNS settings.
     */
    export interface VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsResponse {
        /**
         * The Domain name label.The concatenation of the domain name label and vm index will be the domain name labels of the PublicIPAddress resources that will be created
         */
        domainNameLabel: string;
    }

    /**
     * Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration
     */
    export interface VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesResponse {
        /**
         * The dns settings to be applied on the publicIP addresses .
         */
        dnsSettings?: outputs.compute.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsResponse;
        /**
         * The idle timeout of the public IP address.
         */
        idleTimeoutInMinutes?: number;
        /**
         * The list of IP tags associated with the public IP address.
         */
        ipTags?: outputs.compute.VirtualMachineScaleSetIpTagResponse[];
        /**
         * Available from Api-Version 2019-07-01 onwards, it represents whether the specific ipconfiguration is IPv4 or IPv6. Default is taken as IPv4. Possible values are: 'IPv4' and 'IPv6'.
         */
        publicIPAddressVersion?: string;
        /**
         * The PublicIPPrefix from which to allocate publicIP addresses.
         */
        publicIPPrefix?: outputs.compute.SubResourceResponse;
    }

    /**
     * Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration
     */
    export interface VirtualMachineScaleSetPublicIPAddressConfigurationResponse {
        /**
         * The publicIP address configuration name.
         */
        name: string;
        /**
         * Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration
         */
        properties?: outputs.compute.VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesResponse;
    }

    /**
     * Describes a virtual machine scale set storage profile.
     */
    export interface VirtualMachineScaleSetStorageProfileResponse {
        /**
         * Specifies the parameters that are used to add data disks to the virtual machines in the scale set. <br><br> For more information about disks, see [About disks and VHDs for Azure virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
         */
        dataDisks?: outputs.compute.VirtualMachineScaleSetDataDiskResponse[];
        /**
         * Specifies information about the image to use. You can specify information about platform images, marketplace images, or virtual machine images. This element is required when you want to use a platform image, marketplace image, or virtual machine image, but is not used in other creation operations.
         */
        imageReference?: outputs.compute.ImageReferenceResponse;
        /**
         * Specifies information about the operating system disk used by the virtual machines in the scale set. <br><br> For more information about disks, see [About disks and VHDs for Azure virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
         */
        osDisk?: outputs.compute.VirtualMachineScaleSetOSDiskResponse;
    }

    /**
     * The instance view of a virtual machine scale set VM.
     */
    export interface VirtualMachineScaleSetVMInstanceViewResponse {
        /**
         * Resource id of the dedicated host, on which the virtual machine is allocated through automatic placement, when the virtual machine is associated with a dedicated host group that has automatic placement enabled. <br><br>Minimum api-version: 2020-06-01.
         */
        assignedHost: string;
        /**
         * Boot Diagnostics is a debugging feature which allows you to view Console Output and Screenshot to diagnose VM status. <br><br> You can easily view the output of your console log. <br><br> Azure also enables you to see a screenshot of the VM from the hypervisor.
         */
        bootDiagnostics?: outputs.compute.BootDiagnosticsInstanceViewResponse;
        /**
         * The disks information.
         */
        disks?: outputs.compute.DiskInstanceViewResponse[];
        /**
         * The extensions information.
         */
        extensions?: outputs.compute.VirtualMachineExtensionInstanceViewResponse[];
        /**
         * The Maintenance Operation status on the virtual machine.
         */
        maintenanceRedeployStatus?: outputs.compute.MaintenanceRedeployStatusResponse;
        /**
         * The placement group in which the VM is running. If the VM is deallocated it will not have a placementGroupId.
         */
        placementGroupId?: string;
        /**
         * The Fault Domain count.
         */
        platformFaultDomain?: number;
        /**
         * The Update Domain count.
         */
        platformUpdateDomain?: number;
        /**
         * The Remote desktop certificate thumbprint.
         */
        rdpThumbPrint?: string;
        /**
         * The resource status information.
         */
        statuses?: outputs.compute.InstanceViewStatusResponse[];
        /**
         * The VM Agent running on the virtual machine.
         */
        vmAgent?: outputs.compute.VirtualMachineAgentInstanceViewResponse;
        /**
         * The health status for the VM.
         */
        vmHealth: outputs.compute.VirtualMachineHealthStatusResponse;
    }

    /**
     * Describes a virtual machine scale set VM network profile.
     */
    export interface VirtualMachineScaleSetVMNetworkProfileConfigurationResponse {
        /**
         * The list of network configurations.
         */
        networkInterfaceConfigurations?: outputs.compute.VirtualMachineScaleSetNetworkConfigurationResponse[];
    }

    /**
     * Describes a virtual machine scale set virtual machine profile.
     */
    export interface VirtualMachineScaleSetVMProfileResponse {
        /**
         * Specifies the billing related details of a Azure Spot VMSS. <br><br>Minimum api-version: 2019-03-01.
         */
        billingProfile?: outputs.compute.BillingProfileResponse;
        /**
         * Specifies the boot diagnostic settings state. <br><br>Minimum api-version: 2015-06-15.
         */
        diagnosticsProfile?: outputs.compute.DiagnosticsProfileResponse;
        /**
         * Specifies the eviction policy for the Azure Spot virtual machine and Azure Spot scale set. <br><br>For Azure Spot virtual machines, both 'Deallocate' and 'Delete' are supported and the minimum api-version is 2019-03-01. <br><br>For Azure Spot scale sets, both 'Deallocate' and 'Delete' are supported and the minimum api-version is 2017-10-30-preview.
         */
        evictionPolicy?: string;
        /**
         * Specifies a collection of settings for extensions installed on virtual machines in the scale set.
         */
        extensionProfile?: outputs.compute.VirtualMachineScaleSetExtensionProfileResponse;
        /**
         * Specifies that the image or disk that is being used was licensed on-premises. This element is only used for images that contain the Windows Server operating system. <br><br> Possible values are: <br><br> Windows_Client <br><br> Windows_Server <br><br> If this element is included in a request for an update, the value must match the initial value. This value cannot be updated. <br><br> For more information, see [Azure Hybrid Use Benefit for Windows Server](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-hybrid-use-benefit-licensing?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) <br><br> Minimum api-version: 2015-06-15
         */
        licenseType?: string;
        /**
         * Specifies properties of the network interfaces of the virtual machines in the scale set.
         */
        networkProfile?: outputs.compute.VirtualMachineScaleSetNetworkProfileResponse;
        /**
         * Specifies the operating system settings for the virtual machines in the scale set.
         */
        osProfile?: outputs.compute.VirtualMachineScaleSetOSProfileResponse;
        /**
         * Specifies the priority for the virtual machines in the scale set. <br><br>Minimum api-version: 2017-10-30-preview
         */
        priority?: string;
        /**
         * Specifies Scheduled Event related configurations.
         */
        scheduledEventsProfile?: outputs.compute.ScheduledEventsProfileResponse;
        /**
         * Specifies the Security related profile settings for the virtual machines in the scale set.
         */
        securityProfile?: outputs.compute.SecurityProfileResponse;
        /**
         * Specifies the storage settings for the virtual machine disks.
         */
        storageProfile?: outputs.compute.VirtualMachineScaleSetStorageProfileResponse;
    }

    /**
     * Describes the properties of a virtual machine scale set virtual machine.
     */
    export interface VirtualMachineScaleSetVMPropertiesResponse {
        /**
         * Specifies additional capabilities enabled or disabled on the virtual machine in the scale set. For instance: whether the virtual machine has the capability to support attaching managed data disks with UltraSSD_LRS storage account type.
         */
        additionalCapabilities?: outputs.compute.AdditionalCapabilitiesResponse;
        /**
         * Specifies information about the availability set that the virtual machine should be assigned to. Virtual machines specified in the same availability set are allocated to different nodes to maximize availability. For more information about availability sets, see [Manage the availability of virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-manage-availability?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json). <br><br> For more information on Azure planned maintenance, see [Planned maintenance for virtual machines in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-planned-maintenance?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) <br><br> Currently, a VM can only be added to availability set at creation time. An existing VM cannot be added to an availability set.
         */
        availabilitySet?: outputs.compute.SubResourceResponse;
        /**
         * Specifies the boot diagnostic settings state. <br><br>Minimum api-version: 2015-06-15.
         */
        diagnosticsProfile?: outputs.compute.DiagnosticsProfileResponse;
        /**
         * Specifies the hardware settings for the virtual machine.
         */
        hardwareProfile?: outputs.compute.HardwareProfileResponse;
        /**
         * The virtual machine instance view.
         */
        instanceView: outputs.compute.VirtualMachineScaleSetVMInstanceViewResponse;
        /**
         * Specifies whether the latest model has been applied to the virtual machine.
         */
        latestModelApplied: boolean;
        /**
         * Specifies that the image or disk that is being used was licensed on-premises. This element is only used for images that contain the Windows Server operating system. <br><br> Possible values are: <br><br> Windows_Client <br><br> Windows_Server <br><br> If this element is included in a request for an update, the value must match the initial value. This value cannot be updated. <br><br> For more information, see [Azure Hybrid Use Benefit for Windows Server](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-hybrid-use-benefit-licensing?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) <br><br> Minimum api-version: 2015-06-15
         */
        licenseType?: string;
        /**
         * Specifies whether the model applied to the virtual machine is the model of the virtual machine scale set or the customized model for the virtual machine.
         */
        modelDefinitionApplied: string;
        /**
         * Specifies the network interfaces of the virtual machine.
         */
        networkProfile?: outputs.compute.NetworkProfileResponse;
        /**
         * Specifies the network profile configuration of the virtual machine.
         */
        networkProfileConfiguration?: outputs.compute.VirtualMachineScaleSetVMNetworkProfileConfigurationResponse;
        /**
         * Specifies the operating system settings for the virtual machine.
         */
        osProfile?: outputs.compute.OSProfileResponse;
        /**
         * Specifies the protection policy of the virtual machine.
         */
        protectionPolicy?: outputs.compute.VirtualMachineScaleSetVMProtectionPolicyResponse;
        /**
         * The provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * Specifies the Security related profile settings for the virtual machine.
         */
        securityProfile?: outputs.compute.SecurityProfileResponse;
        /**
         * Specifies the storage settings for the virtual machine disks.
         */
        storageProfile?: outputs.compute.StorageProfileResponse;
        /**
         * Azure VM unique ID.
         */
        vmId: string;
    }

    /**
     * The protection policy of a virtual machine scale set VM.
     */
    export interface VirtualMachineScaleSetVMProtectionPolicyResponse {
        /**
         * Indicates that the virtual machine scale set VM shouldn't be considered for deletion during a scale-in operation.
         */
        protectFromScaleIn?: boolean;
        /**
         * Indicates that model updates or actions (including scale-in) initiated on the virtual machine scale set should not be applied to the virtual machine scale set VM.
         */
        protectFromScaleSetActions?: boolean;
    }

    /**
     * Describes Windows Remote Management configuration of the VM
     */
    export interface WinRMConfigurationResponse {
        /**
         * The list of Windows Remote Management listeners
         */
        listeners?: outputs.compute.WinRMListenerResponse[];
    }

    /**
     * Describes Protocol and thumbprint of Windows Remote Management listener
     */
    export interface WinRMListenerResponse {
        /**
         * This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
         */
        certificateUrl?: string;
        /**
         * Specifies the protocol of WinRM listener. <br><br> Possible values are: <br>**http** <br><br> **https**
         */
        protocol?: string;
    }

    /**
     * Specifies Windows operating system settings on the virtual machine.
     */
    export interface WindowsConfigurationResponse {
        /**
         * Specifies additional base-64 encoded XML formatted information that can be included in the Unattend.xml file, which is used by Windows Setup.
         */
        additionalUnattendContent?: outputs.compute.AdditionalUnattendContentResponse[];
        /**
         * Indicates whether Automatic Updates is enabled for the Windows virtual machine. Default value is true. <br><br> For virtual machine scale sets, this property can be updated and updates will take effect on OS reprovisioning.
         */
        enableAutomaticUpdates?: boolean;
        /**
         * Specifies settings related to in-guest patching (KBs).
         */
        patchSettings?: outputs.compute.PatchSettingsResponse;
        /**
         * Indicates whether virtual machine agent should be provisioned on the virtual machine. <br><br> When this property is not specified in the request body, default behavior is to set it to true.  This will ensure that VM Agent is installed on the VM so that extensions can be added to the VM later.
         */
        provisionVMAgent?: boolean;
        /**
         * Specifies the time zone of the virtual machine. e.g. "Pacific Standard Time". <br><br> Possible values can be [TimeZoneInfo.Id](https://docs.microsoft.com/en-us/dotnet/api/system.timezoneinfo.id?#System_TimeZoneInfo_Id) value from time zones returned by [TimeZoneInfo.GetSystemTimeZones](https://docs.microsoft.com/en-us/dotnet/api/system.timezoneinfo.getsystemtimezones).
         */
        timeZone?: string;
        /**
         * Specifies the Windows Remote Management listeners. This enables remote Windows PowerShell.
         */
        winRM?: outputs.compute.WinRMConfigurationResponse;
    }
}

export namespace containerinstance {
    /**
     * The properties of the Azure File volume. Azure File shares are mounted as volumes.
     */
    export interface AzureFileVolumeResponse {
        /**
         * The flag indicating whether the Azure File shared mounted as a volume is read-only.
         */
        readOnly?: boolean;
        /**
         * The name of the Azure File share to be mounted as a volume.
         */
        shareName: string;
        /**
         * The storage account access key used to access the Azure File share.
         */
        storageAccountKey?: string;
        /**
         * The name of the storage account that contains the Azure File share.
         */
        storageAccountName: string;
    }

    /**
     * The container execution command, for liveness or readiness probe
     */
    export interface ContainerExecResponse {
        /**
         * The commands to execute within the container.
         */
        command?: string[];
    }

    /**
     * Container group diagnostic information.
     */
    export interface ContainerGroupDiagnosticsResponse {
        /**
         * Container group log analytics information.
         */
        logAnalytics?: outputs.containerinstance.LogAnalyticsResponse;
    }

    /**
     * Identity for the container group.
     */
    export interface ContainerGroupIdentityResponse {
        /**
         * The principal id of the container group identity. This property will only be provided for a system assigned identity.
         */
        principalId: string;
        /**
         * The tenant id associated with the container group. This property will only be provided for a system assigned identity.
         */
        tenantId: string;
        /**
         * The type of identity used for the container group. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the container group.
         */
        type?: string;
        /**
         * The list of user identities associated with the container group. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
         */
        userAssignedIdentities?: {[key: string]: string};
    }

    /**
     * Container group network profile information.
     */
    export interface ContainerGroupNetworkProfileResponse {
        /**
         * The identifier for a network profile.
         */
        id: string;
    }

    /**
     * The container group properties
     */
    export interface ContainerGroupResponseProperties {
        /**
         * The containers within the container group.
         */
        containers: outputs.containerinstance.ContainerResponse[];
        /**
         * The diagnostic information for a container group.
         */
        diagnostics?: outputs.containerinstance.ContainerGroupDiagnosticsResponse;
        /**
         * The DNS config information for a container group.
         */
        dnsConfig?: outputs.containerinstance.DnsConfigurationResponse;
        /**
         * The encryption properties for a container group.
         */
        encryptionProperties?: outputs.containerinstance.EncryptionPropertiesResponse;
        /**
         * The image registry credentials by which the container group is created from.
         */
        imageRegistryCredentials?: outputs.containerinstance.ImageRegistryCredentialResponse[];
        /**
         * The init containers for a container group.
         */
        initContainers?: outputs.containerinstance.InitContainerDefinitionResponse[];
        /**
         * The instance view of the container group. Only valid in response.
         */
        instanceView: outputs.containerinstance.ContainerGroupResponseProperties;
        /**
         * The IP address type of the container group.
         */
        ipAddress?: outputs.containerinstance.IpAddressResponse;
        /**
         * The network profile information for a container group.
         */
        networkProfile?: outputs.containerinstance.ContainerGroupNetworkProfileResponse;
        /**
         * The operating system type required by the containers in the container group.
         */
        osType: string;
        /**
         * The provisioning state of the container group. This only appears in the response.
         */
        provisioningState: string;
        /**
         * Restart policy for all containers within the container group. 
         * - `Always` Always restart
         * - `OnFailure` Restart on failure
         * - `Never` Never restart
         */
        restartPolicy?: string;
        /**
         * The SKU for a container group.
         */
        sku?: string;
        /**
         * The list of volumes that can be mounted by containers in this container group.
         */
        volumes?: outputs.containerinstance.VolumeResponse[];
    }

    /**
     * The container Http Get settings, for liveness or readiness probe
     */
    export interface ContainerHttpGetResponse {
        /**
         * The path to probe.
         */
        path?: string;
        /**
         * The port number to probe.
         */
        port: number;
        /**
         * The scheme.
         */
        scheme?: string;
    }

    /**
     * The port exposed on the container instance.
     */
    export interface ContainerPortResponse {
        /**
         * The port number exposed within the container group.
         */
        port: number;
        /**
         * The protocol associated with the port.
         */
        protocol?: string;
    }

    /**
     * The container probe, for liveness or readiness
     */
    export interface ContainerProbeResponse {
        /**
         * The execution command to probe
         */
        exec?: outputs.containerinstance.ContainerExecResponse;
        /**
         * The failure threshold.
         */
        failureThreshold?: number;
        /**
         * The Http Get settings to probe
         */
        httpGet?: outputs.containerinstance.ContainerHttpGetResponse;
        /**
         * The initial delay seconds.
         */
        initialDelaySeconds?: number;
        /**
         * The period seconds.
         */
        periodSeconds?: number;
        /**
         * The success threshold.
         */
        successThreshold?: number;
        /**
         * The timeout seconds.
         */
        timeoutSeconds?: number;
    }

    /**
     * The container instance properties.
     */
    export interface ContainerPropertiesResponse {
        /**
         * The commands to execute within the container instance in exec form.
         */
        command?: string[];
        /**
         * The environment variables to set in the container instance.
         */
        environmentVariables?: outputs.containerinstance.EnvironmentVariableResponse[];
        /**
         * The name of the image used to create the container instance.
         */
        image: string;
        /**
         * The instance view of the container instance. Only valid in response.
         */
        instanceView: outputs.containerinstance.ContainerPropertiesResponseProperties;
        /**
         * The liveness probe.
         */
        livenessProbe?: outputs.containerinstance.ContainerProbeResponse;
        /**
         * The exposed ports on the container instance.
         */
        ports?: outputs.containerinstance.ContainerPortResponse[];
        /**
         * The readiness probe.
         */
        readinessProbe?: outputs.containerinstance.ContainerProbeResponse;
        /**
         * The resource requirements of the container instance.
         */
        resources: outputs.containerinstance.ResourceRequirementsResponse;
        /**
         * The volume mounts available to the container instance.
         */
        volumeMounts?: outputs.containerinstance.VolumeMountResponse[];
    }

    /**
     * The instance view of the container instance. Only valid in response.
     */
    export interface ContainerPropertiesResponseProperties {
        /**
         * Current container instance state.
         */
        currentState: outputs.containerinstance.ContainerStateResponse;
        /**
         * The events of the container instance.
         */
        events: outputs.containerinstance.EventResponse[];
        /**
         * Previous container instance state.
         */
        previousState: outputs.containerinstance.ContainerStateResponse;
        /**
         * The number of times that the container instance has been restarted.
         */
        restartCount: number;
    }

    /**
     * A container instance.
     */
    export interface ContainerResponse {
        /**
         * The user-provided name of the container instance.
         */
        name: string;
        /**
         * The properties of the container instance.
         */
        properties: outputs.containerinstance.ContainerPropertiesResponse;
    }

    /**
     * The container instance state.
     */
    export interface ContainerStateResponse {
        /**
         * The human-readable status of the container instance state.
         */
        detailStatus: string;
        /**
         * The container instance exit codes correspond to those from the `docker run` command.
         */
        exitCode: number;
        /**
         * The date-time when the container instance state finished.
         */
        finishTime: string;
        /**
         * The date-time when the container instance state started.
         */
        startTime: string;
        /**
         * The state of the container instance.
         */
        state: string;
    }

    /**
     * DNS configuration for the container group.
     */
    export interface DnsConfigurationResponse {
        /**
         * The DNS servers for the container group.
         */
        nameServers: string[];
        /**
         * The DNS options for the container group.
         */
        options?: string;
        /**
         * The DNS search domains for hostname lookup in the container group.
         */
        searchDomains?: string;
    }

    /**
     * The empty directory volume.
     */
    export interface EmptyDirVolumeResponse {
    }

    /**
     * The container group encryption properties.
     */
    export interface EncryptionPropertiesResponse {
        /**
         * The encryption key name.
         */
        keyName: string;
        /**
         * The encryption key version.
         */
        keyVersion: string;
        /**
         * The keyvault base url.
         */
        vaultBaseUrl: string;
    }

    /**
     * The environment variable to set within the container instance.
     */
    export interface EnvironmentVariableResponse {
        /**
         * The name of the environment variable.
         */
        name: string;
        /**
         * The value of the secure environment variable.
         */
        secureValue?: string;
        /**
         * The value of the environment variable.
         */
        value?: string;
    }

    /**
     * A container group or container instance event.
     */
    export interface EventResponse {
        /**
         * The count of the event.
         */
        count: number;
        /**
         * The date-time of the earliest logged event.
         */
        firstTimestamp: string;
        /**
         * The date-time of the latest logged event.
         */
        lastTimestamp: string;
        /**
         * The event message.
         */
        message: string;
        /**
         * The event name.
         */
        name: string;
        /**
         * The event type.
         */
        type: string;
    }

    /**
     * Represents a volume that is populated with the contents of a git repository
     */
    export interface GitRepoVolumeResponse {
        /**
         * Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
         */
        directory?: string;
        /**
         * Repository URL
         */
        repository: string;
        /**
         * Commit hash for the specified revision.
         */
        revision?: string;
    }

    /**
     * The GPU resource.
     */
    export interface GpuResourceResponse {
        /**
         * The count of the GPU resource.
         */
        count: number;
        /**
         * The SKU of the GPU resource.
         */
        sku: string;
    }

    /**
     * Image registry credential.
     */
    export interface ImageRegistryCredentialResponse {
        /**
         * The password for the private registry.
         */
        password?: string;
        /**
         * The Docker image registry server without a protocol such as "http" and "https".
         */
        server: string;
        /**
         * The username for the private registry.
         */
        username: string;
    }

    /**
     * The init container definition.
     */
    export interface InitContainerDefinitionResponse {
        /**
         * The name for the init container.
         */
        name: string;
        /**
         * The properties for the init container.
         */
        properties: outputs.containerinstance.InitContainerPropertiesDefinitionResponse;
    }

    /**
     * The init container definition properties.
     */
    export interface InitContainerPropertiesDefinitionResponse {
        /**
         * The command to execute within the init container in exec form.
         */
        command?: string[];
        /**
         * The environment variables to set in the init container.
         */
        environmentVariables?: outputs.containerinstance.EnvironmentVariableResponse[];
        /**
         * The image of the init container.
         */
        image?: string;
        /**
         * The instance view of the init container. Only valid in response.
         */
        instanceView: outputs.containerinstance.InitContainerPropertiesDefinitionResponseProperties;
        /**
         * The volume mounts available to the init container.
         */
        volumeMounts?: outputs.containerinstance.VolumeMountResponse[];
    }

    /**
     * The instance view of the init container. Only valid in response.
     */
    export interface InitContainerPropertiesDefinitionResponseProperties {
        /**
         * The current state of the init container.
         */
        currentState: outputs.containerinstance.ContainerStateResponse;
        /**
         * The events of the init container.
         */
        events: outputs.containerinstance.EventResponse[];
        /**
         * The previous state of the init container.
         */
        previousState: outputs.containerinstance.ContainerStateResponse;
        /**
         * The number of times that the init container has been restarted.
         */
        restartCount: number;
    }

    /**
     * IP address for the container group.
     */
    export interface IpAddressResponse {
        /**
         * The Dns name label for the IP.
         */
        dnsNameLabel?: string;
        /**
         * The FQDN for the IP.
         */
        fqdn: string;
        /**
         * The IP exposed to the public internet.
         */
        ip?: string;
        /**
         * The list of ports exposed on the container group.
         */
        ports: outputs.containerinstance.PortResponse[];
        /**
         * Specifies if the IP is exposed to the public internet or private VNET.
         */
        type: string;
    }

    /**
     * Container group log analytics information.
     */
    export interface LogAnalyticsResponse {
        /**
         * The log type to be used.
         */
        logType?: string;
        /**
         * Metadata for log analytics.
         */
        metadata?: {[key: string]: string};
        /**
         * The workspace id for log analytics
         */
        workspaceId: string;
        /**
         * The workspace key for log analytics
         */
        workspaceKey: string;
    }

    /**
     * The port exposed on the container group.
     */
    export interface PortResponse {
        /**
         * The port number.
         */
        port: number;
        /**
         * The protocol associated with the port.
         */
        protocol?: string;
    }

    /**
     * The resource limits.
     */
    export interface ResourceLimitsResponse {
        /**
         * The CPU limit of this container instance.
         */
        cpu?: number;
        /**
         * The GPU limit of this container instance.
         */
        gpu?: outputs.containerinstance.GpuResourceResponse;
        /**
         * The memory limit in GB of this container instance.
         */
        memoryInGB?: number;
    }

    /**
     * The resource requests.
     */
    export interface ResourceRequestsResponse {
        /**
         * The CPU request of this container instance.
         */
        cpu: number;
        /**
         * The GPU request of this container instance.
         */
        gpu?: outputs.containerinstance.GpuResourceResponse;
        /**
         * The memory request in GB of this container instance.
         */
        memoryInGB: number;
    }

    /**
     * The resource requirements.
     */
    export interface ResourceRequirementsResponse {
        /**
         * The resource limits of this container instance.
         */
        limits?: outputs.containerinstance.ResourceLimitsResponse;
        /**
         * The resource requests of this container instance.
         */
        requests: outputs.containerinstance.ResourceRequestsResponse;
    }

    /**
     * The secret volume.
     */
    export interface SecretVolumeResponse {
    }

    /**
     * The properties of the volume mount.
     */
    export interface VolumeMountResponse {
        /**
         * The path within the container where the volume should be mounted. Must not contain colon (:).
         */
        mountPath: string;
        /**
         * The name of the volume mount.
         */
        name: string;
        /**
         * The flag indicating whether the volume mount is read-only.
         */
        readOnly?: boolean;
    }

    /**
     * The properties of the volume.
     */
    export interface VolumeResponse {
        /**
         * The Azure File volume.
         */
        azureFile?: outputs.containerinstance.AzureFileVolumeResponse;
        /**
         * The empty directory volume.
         */
        emptyDir?: outputs.containerinstance.EmptyDirVolumeResponse;
        /**
         * The git repo volume.
         */
        gitRepo?: outputs.containerinstance.GitRepoVolumeResponse;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The secret volume.
         */
        secret?: outputs.containerinstance.SecretVolumeResponse;
    }
}

export namespace containerregistry {
    /**
     * The agent that initiated the event. For most situations, this could be from the authorization context of the request.
     */
    export interface ActorResponse {
        /**
         * The subject or username associated with the request context that generated the event.
         */
        name?: string;
    }

    /**
     * The properties that determine the run agent configuration.
     */
    export interface AgentPropertiesResponse {
        /**
         * The CPU configuration in terms of number of cores required for the run.
         */
        cpu?: number;
    }

    /**
     * The authorization properties for accessing the source code repository.
     */
    export interface AuthInfoResponse {
        /**
         * Time in seconds that the token remains valid
         */
        expiresIn?: number;
        /**
         * The refresh token used to refresh the access token.
         */
        refreshToken?: string;
        /**
         * The scope of the access token.
         */
        scope?: string;
        /**
         * The access token used to access the source control provider.
         */
        token: string;
        /**
         * The type of Auth token.
         */
        tokenType: string;
    }

    /**
     * Properties that describe a base image dependency.
     */
    export interface BaseImageDependencyResponse {
        /**
         * The sha256-based digest of the image manifest.
         */
        digest?: string;
        /**
         * The registry login server.
         */
        registry?: string;
        /**
         * The repository name.
         */
        repository?: string;
        /**
         * The tag name.
         */
        tag?: string;
        /**
         * The type of the base image dependency.
         */
        type?: string;
    }

    /**
     * The trigger based on base image dependency.
     */
    export interface BaseImageTriggerResponse {
        /**
         * The type of the auto trigger for base image dependency updates.
         */
        baseImageTriggerType: string;
        /**
         * The name of the trigger.
         */
        name: string;
        /**
         * The current status of trigger.
         */
        status?: string;
    }

    /**
     * The parameters that describes a set of credentials that will be used when a run is invoked.
     */
    export interface CredentialsResponse {
        /**
         * Describes the credential parameters for accessing other custom registries. The key
         * for the dictionary item will be the registry login server (myregistry.azurecr.io) and
         * the value of the item will be the registry credentials for accessing the registry.
         */
        customRegistries?: {[key: string]: string};
        /**
         * Describes the credential parameters for accessing the source registry.
         */
        sourceRegistry?: outputs.containerregistry.SourceRegistryCredentialsResponse;
    }

    /**
     * The content of the event request message.
     */
    export interface EventContentResponse {
        /**
         * The action that encompasses the provided event.
         */
        action?: string;
        /**
         * The agent that initiated the event. For most situations, this could be from the authorization context of the request.
         */
        actor?: outputs.containerregistry.ActorResponse;
        /**
         * The event ID.
         */
        id?: string;
        /**
         * The request that generated the event.
         */
        request?: outputs.containerregistry.RequestResponse;
        /**
         * The registry node that generated the event. Put differently, while the actor initiates the event, the source generates it.
         */
        source?: outputs.containerregistry.SourceResponse;
        /**
         * The target of the event.
         */
        target?: outputs.containerregistry.TargetResponse;
        /**
         * The time at which the event occurred.
         */
        timestamp?: string;
    }

    /**
     * The event request message sent to the service URI.
     */
    export interface EventRequestMessageResponse {
        /**
         * The content of the event request message.
         */
        content?: outputs.containerregistry.EventContentResponse;
        /**
         * The headers of the event request message.
         */
        headers?: {[key: string]: string};
        /**
         * The HTTP method used to send the event request message.
         */
        method?: string;
        /**
         * The URI used to send the event request message.
         */
        requestUri?: string;
        /**
         * The HTTP message version.
         */
        version?: string;
    }

    /**
     * The event for a webhook.
     */
    export interface EventResponse {
        /**
         * The event request message sent to the service URI.
         */
        eventRequestMessage?: outputs.containerregistry.EventRequestMessageResponse;
        /**
         * The event response message received from the service URI.
         */
        eventResponseMessage?: outputs.containerregistry.EventResponseMessageResponse;
        /**
         * The event ID.
         */
        id?: string;
    }

    /**
     * The event response message received from the service URI.
     */
    export interface EventResponseMessageResponse {
        /**
         * The content of the event response message.
         */
        content?: string;
        /**
         * The headers of the event response message.
         */
        headers?: {[key: string]: string};
        /**
         * The reason phrase of the event response message.
         */
        reasonPhrase?: string;
        /**
         * The status code of the event response message.
         */
        statusCode?: string;
        /**
         * The HTTP message version.
         */
        version?: string;
    }

    /**
     * IP rule with specific IP or IP range in CIDR format.
     */
    export interface IPRuleResponse {
        /**
         * The action of IP ACL rule.
         */
        action?: string;
        /**
         * Specifies the IP or IP range in CIDR format. Only IPV4 address is allowed.
         */
        value: string;
    }

    /**
     * Managed identity for the resource.
     */
    export interface IdentityPropertiesResponse {
        /**
         * The principal ID of resource identity.
         */
        principalId?: string;
        /**
         * The tenant ID of resource.
         */
        tenantId?: string;
        /**
         * The identity type.
         */
        type?: string;
        /**
         * The list of user identities associated with the resource. The user identity 
         * dictionary key references will be ARM resource ids in the form: 
         * '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/
         *     providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
         */
        userAssignedIdentities?: {[key: string]: string};
    }

    /**
     * The network rule set for a container registry.
     */
    export interface NetworkRuleSetResponse {
        /**
         * The default action of allow or deny when no other rules match.
         */
        defaultAction: string;
        /**
         * The IP ACL rules.
         */
        ipRules?: outputs.containerregistry.IPRuleResponse[];
        /**
         * The virtual network rules.
         */
        virtualNetworkRules?: outputs.containerregistry.VirtualNetworkRuleResponse[];
    }

    /**
     * The platform properties against which the run has to happen.
     */
    export interface PlatformPropertiesResponse {
        /**
         * The OS architecture.
         */
        architecture?: string;
        /**
         * The operating system type required for the run.
         */
        os: string;
        /**
         * Variant of the CPU.
         */
        variant?: string;
    }

    /**
     * The policies for a container registry.
     */
    export interface PoliciesResponse {
        /**
         * The quarantine policy for a container registry.
         */
        quarantinePolicy?: outputs.containerregistry.QuarantinePolicyResponse;
        /**
         * The retention policy for a container registry.
         */
        retentionPolicy?: outputs.containerregistry.RetentionPolicyResponse;
        /**
         * The content trust policy for a container registry.
         */
        trustPolicy?: outputs.containerregistry.TrustPolicyResponse;
    }

    /**
     * The quarantine policy for a container registry.
     */
    export interface QuarantinePolicyResponse {
        /**
         * The value that indicates whether the policy is enabled or not.
         */
        status?: string;
    }

    /**
     * The login password for the container registry.
     */
    export interface RegistryPasswordResponse {
        /**
         * The password name.
         */
        name?: string;
        /**
         * The password value.
         */
        value?: string;
    }

    /**
     * The properties of a container registry.
     */
    export interface RegistryPropertiesResponse {
        /**
         * The value that indicates whether the admin user is enabled.
         */
        adminUserEnabled?: boolean;
        /**
         * The creation date of the container registry in ISO8601 format.
         */
        creationDate: string;
        /**
         * The URL that can be used to log into the container registry.
         */
        loginServer: string;
        /**
         * The network rule set for a container registry.
         */
        networkRuleSet?: outputs.containerregistry.NetworkRuleSetResponse;
        /**
         * The policies for a container registry.
         */
        policies?: outputs.containerregistry.PoliciesResponse;
        /**
         * The provisioning state of the container registry at the time the operation was called.
         */
        provisioningState: string;
        /**
         * The status of the container registry at the time the operation was called.
         */
        status: outputs.containerregistry.StatusResponse;
        /**
         * The properties of the storage account for the container registry. Only applicable to Classic SKU.
         */
        storageAccount?: outputs.containerregistry.StorageAccountPropertiesResponse;
    }

    /**
     * The properties of a replication.
     */
    export interface ReplicationPropertiesResponse {
        /**
         * The provisioning state of the replication at the time the operation was called.
         */
        provisioningState: string;
        /**
         * The status of the replication at the time the operation was called.
         */
        status: outputs.containerregistry.StatusResponse;
    }

    /**
     * The request that generated the event.
     */
    export interface RequestResponse {
        /**
         * The IP or hostname and possibly port of the client connection that initiated the event. This is the RemoteAddr from the standard http request.
         */
        addr?: string;
        /**
         * The externally accessible hostname of the registry instance, as specified by the http host header on incoming requests.
         */
        host?: string;
        /**
         * The ID of the request that initiated the event.
         */
        id?: string;
        /**
         * The request method that generated the event.
         */
        method?: string;
        /**
         * The user agent header of the request.
         */
        useragent?: string;
    }

    /**
     * The retention policy for a container registry.
     */
    export interface RetentionPolicyResponse {
        /**
         * The number of days to retain an untagged manifest after which it gets purged.
         */
        days?: number;
        /**
         * The timestamp when the policy was last updated.
         */
        lastUpdatedTime: string;
        /**
         * The value that indicates whether the policy is enabled or not.
         */
        status?: string;
    }

    /**
     * The SKU of a container registry.
     */
    export interface SkuResponse {
        /**
         * The SKU name of the container registry. Required for registry creation.
         */
        name: string;
        /**
         * The SKU tier based on the SKU name.
         */
        tier: string;
    }

    /**
     * The properties of the source code repository.
     */
    export interface SourcePropertiesResponse {
        /**
         * The branch name of the source code.
         */
        branch?: string;
        /**
         * The full URL to the source code repository
         */
        repositoryUrl: string;
        /**
         * The authorization properties for accessing the source code repository and to set up
         * webhooks for notifications.
         */
        sourceControlAuthProperties?: outputs.containerregistry.AuthInfoResponse;
        /**
         * The type of source control service.
         */
        sourceControlType: string;
    }

    /**
     * Describes the credential parameters for accessing the source registry.
     */
    export interface SourceRegistryCredentialsResponse {
        /**
         * The authentication mode which determines the source registry login scope. The credentials for the source registry
         * will be generated using the given scope. These credentials will be used to login to
         * the source registry during the run.
         */
        loginMode?: string;
    }

    /**
     * The registry node that generated the event. Put differently, while the actor initiates the event, the source generates it.
     */
    export interface SourceResponse {
        /**
         * The IP or hostname and the port of the registry node that generated the event. Generally, this will be resolved by os.Hostname() along with the running port.
         */
        addr?: string;
        /**
         * The running instance of an application. Changes after each restart.
         */
        instanceID?: string;
    }

    /**
     * The properties of a source based trigger.
     */
    export interface SourceTriggerResponse {
        /**
         * The name of the trigger.
         */
        name: string;
        /**
         * The properties that describes the source(code) for the task.
         */
        sourceRepository: outputs.containerregistry.SourcePropertiesResponse;
        /**
         * The source event corresponding to the trigger.
         */
        sourceTriggerEvents: string[];
        /**
         * The current status of trigger.
         */
        status?: string;
    }

    /**
     * The status of an Azure resource at the time the operation was called.
     */
    export interface StatusResponse {
        /**
         * The short label for the status.
         */
        displayStatus: string;
        /**
         * The detailed message for the status, including alerts and error messages.
         */
        message: string;
        /**
         * The timestamp when the status was changed to the current value.
         */
        timestamp: string;
    }

    /**
     * The properties of a storage account for a container registry. Only applicable to Classic SKU.
     */
    export interface StorageAccountPropertiesResponse {
        /**
         * The resource ID of the storage account.
         */
        id: string;
    }

    /**
     * The target of the event.
     */
    export interface TargetResponse {
        /**
         * The digest of the content, as defined by the Registry V2 HTTP API Specification.
         */
        digest?: string;
        /**
         * The number of bytes of the content. Same as Size field.
         */
        length?: number;
        /**
         * The MIME type of the referenced object.
         */
        mediaType?: string;
        /**
         * The name of the artifact.
         */
        name?: string;
        /**
         * The repository name.
         */
        repository?: string;
        /**
         * The number of bytes of the content. Same as Length field.
         */
        size?: number;
        /**
         * The tag name.
         */
        tag?: string;
        /**
         * The direct URL to the content.
         */
        url?: string;
        /**
         * The version of the artifact.
         */
        version?: string;
    }

    /**
     * The properties of a task.
     */
    export interface TaskPropertiesResponse {
        /**
         * The machine configuration of the run agent.
         */
        agentConfiguration?: outputs.containerregistry.AgentPropertiesResponse;
        /**
         * The creation date of task.
         */
        creationDate: string;
        /**
         * The properties that describes a set of credentials that will be used when this run is invoked.
         */
        credentials?: outputs.containerregistry.CredentialsResponse;
        /**
         * The platform properties against which the run has to happen.
         */
        platform: outputs.containerregistry.PlatformPropertiesResponse;
        /**
         * The provisioning state of the task.
         */
        provisioningState: string;
        /**
         * The current status of task.
         */
        status?: string;
        /**
         * The properties of a task step.
         */
        step: outputs.containerregistry.TaskStepPropertiesResponse;
        /**
         * Run timeout in seconds.
         */
        timeout?: number;
        /**
         * The properties that describe all triggers for the task.
         */
        trigger?: outputs.containerregistry.TriggerPropertiesResponse;
    }

    /**
     * Base properties for any task step.
     */
    export interface TaskStepPropertiesResponse {
        /**
         * List of base image dependencies for a step.
         */
        baseImageDependencies: outputs.containerregistry.BaseImageDependencyResponse[];
        /**
         * The token (git PAT or SAS token of storage account blob) associated with the context for a step.
         */
        contextAccessToken?: string;
        /**
         * The URL(absolute or relative) of the source context for the task step.
         */
        contextPath?: string;
        /**
         * The type of the step.
         */
        type: string;
    }

    /**
     * The properties of a timer trigger.
     */
    export interface TimerTriggerResponse {
        /**
         * The name of the trigger.
         */
        name: string;
        /**
         * The CRON expression for the task schedule
         */
        schedule: string;
        /**
         * The current status of trigger.
         */
        status?: string;
    }

    /**
     * The properties of a trigger.
     */
    export interface TriggerPropertiesResponse {
        /**
         * The trigger based on base image dependencies.
         */
        baseImageTrigger?: outputs.containerregistry.BaseImageTriggerResponse;
        /**
         * The collection of triggers based on source code repository.
         */
        sourceTriggers?: outputs.containerregistry.SourceTriggerResponse[];
        /**
         * The collection of timer triggers.
         */
        timerTriggers?: outputs.containerregistry.TimerTriggerResponse[];
    }

    /**
     * The content trust policy for a container registry.
     */
    export interface TrustPolicyResponse {
        /**
         * The value that indicates whether the policy is enabled or not.
         */
        status?: string;
        /**
         * The type of trust policy.
         */
        type?: string;
    }

    /**
     * Virtual network rule.
     */
    export interface VirtualNetworkRuleResponse {
        /**
         * The action of virtual network rule.
         */
        action?: string;
        /**
         * Resource ID of a subnet, for example: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
         */
        id: string;
    }

    /**
     * The properties of a webhook.
     */
    export interface WebhookPropertiesResponse {
        /**
         * The list of actions that trigger the webhook to post notifications.
         */
        actions: string[];
        /**
         * The provisioning state of the webhook at the time the operation was called.
         */
        provisioningState: string;
        /**
         * The scope of repositories where the event can be triggered. For example, 'foo:*' means events for all tags under repository 'foo'. 'foo:bar' means events for 'foo:bar' only. 'foo' is equivalent to 'foo:latest'. Empty means all events.
         */
        scope?: string;
        /**
         * The status of the webhook at the time the operation was called.
         */
        status?: string;
    }
}

export namespace containerservice {
    /**
     * Profile for enabling a user to access a managed cluster.
     */
    export interface AccessProfileResponse {
        /**
         * Base64-encoded Kubernetes configuration file.
         */
        kubeConfig?: string;
    }

    /**
     * Settings for upgrading an agentpool
     */
    export interface AgentPoolUpgradeSettingsResponse {
        /**
         * Count or percentage of additional nodes to be added during upgrade. If empty uses AKS default
         */
        maxSurge?: string;
    }

    /**
     * Profile for the container service agent pool.
     */
    export interface ContainerServiceAgentPoolProfileResponse {
        /**
         * Number of agents (VMs) to host docker containers. Allowed values must be in the range of 1 to 100 (inclusive). The default value is 1. 
         */
        count?: number;
        /**
         * DNS prefix to be used to create the FQDN for the agent pool.
         */
        dnsPrefix?: string;
        /**
         * FQDN for the agent pool.
         */
        fqdn: string;
        /**
         * Unique name of the agent pool profile in the context of the subscription and resource group.
         */
        name: string;
        /**
         * OS Disk Size in GB to be used to specify the disk size for every machine in this master/agent pool. If you specify 0, it will apply the default osDisk size according to the vmSize specified.
         */
        osDiskSizeGB?: outputs.containerservice.ContainerServiceOSDiskResponse;
        /**
         * OsType to be used to specify os type. Choose from Linux and Windows. Default to Linux.
         */
        osType?: string;
        /**
         * Ports number array used to expose on this agent pool. The default opened ports are different based on your choice of orchestrator.
         */
        ports?: number[];
        /**
         * Storage profile specifies what kind of storage used. Choose from StorageAccount and ManagedDisks. Leave it empty, we will choose for you based on the orchestrator choice.
         */
        storageProfile?: string;
        /**
         * Size of agent VMs.
         */
        vmSize: string;
        /**
         * VNet SubnetID specifies the VNet's subnet identifier.
         */
        vnetSubnetID?: string;
    }

    /**
     * Properties to configure a custom container service cluster.
     */
    export interface ContainerServiceCustomProfileResponse {
        /**
         * The name of the custom orchestrator to use.
         */
        orchestrator: string;
    }

    /**
     * Profile for diagnostics on the container service cluster.
     */
    export interface ContainerServiceDiagnosticsProfileResponse {
        /**
         * Profile for diagnostics on the container service VMs.
         */
        vmDiagnostics: outputs.containerservice.ContainerServiceVMDiagnosticsResponse;
    }

    /**
     * Profile for Linux VMs in the container service cluster.
     */
    export interface ContainerServiceLinuxProfileResponse {
        /**
         * The administrator username to use for Linux VMs.
         */
        adminUsername: string;
        /**
         * SSH configuration for Linux-based VMs running on Azure.
         */
        ssh: outputs.containerservice.ContainerServiceSshConfigurationResponse;
    }

    /**
     * Profile for the container service master.
     */
    export interface ContainerServiceMasterProfileResponse {
        /**
         * Number of masters (VMs) in the container service cluster. Allowed values are 1, 3, and 5. The default value is 1.
         */
        count?: number;
        /**
         * DNS prefix to be used to create the FQDN for the master pool.
         */
        dnsPrefix: string;
        /**
         * FirstConsecutiveStaticIP used to specify the first static ip of masters.
         */
        firstConsecutiveStaticIP?: string;
        /**
         * FQDN for the master pool.
         */
        fqdn: string;
        /**
         * OS Disk Size in GB to be used to specify the disk size for every machine in this master/agent pool. If you specify 0, it will apply the default osDisk size according to the vmSize specified.
         */
        osDiskSizeGB?: outputs.containerservice.ContainerServiceOSDiskResponse;
        /**
         * Storage profile specifies what kind of storage used. Choose from StorageAccount and ManagedDisks. Leave it empty, we will choose for you based on the orchestrator choice.
         */
        storageProfile?: string;
        /**
         * Size of agent VMs.
         */
        vmSize: string;
        /**
         * VNet SubnetID specifies the VNet's subnet identifier.
         */
        vnetSubnetID?: string;
    }

    /**
     * Profile of network configuration.
     */
    export interface ContainerServiceNetworkProfileResponse {
        /**
         * An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range specified in serviceCidr.
         */
        dnsServiceIP?: string;
        /**
         * A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes service address range.
         */
        dockerBridgeCidr?: string;
        /**
         * Profile of the cluster load balancer.
         */
        loadBalancerProfile?: outputs.containerservice.ManagedClusterLoadBalancerProfileResponse;
        /**
         * The load balancer sku for the managed cluster.
         */
        loadBalancerSku?: string;
        /**
         * Network mode used for building Kubernetes network.
         */
        networkMode?: string;
        /**
         * Network plugin used for building Kubernetes network.
         */
        networkPlugin?: string;
        /**
         * Network policy used for building Kubernetes network.
         */
        networkPolicy?: string;
        /**
         * The outbound (egress) routing method.
         */
        outboundType?: string;
        /**
         * A CIDR notation IP range from which to assign pod IPs when kubenet is used.
         */
        podCidr?: string;
        /**
         * A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP ranges.
         */
        serviceCidr?: string;
    }

    /**
     * OS Disk Size in GB to be used to specify the disk size for every machine in this master/agent pool. If you specify 0, it will apply the default osDisk size according to the vmSize specified.
     */
    export interface ContainerServiceOSDiskResponse {
    }

    /**
     * Profile for the container service orchestrator.
     */
    export interface ContainerServiceOrchestratorProfileResponse {
        /**
         * The orchestrator to use to manage container service cluster resources. Valid values are Kubernetes, Swarm, DCOS, DockerCE and Custom.
         */
        orchestratorType: string;
        /**
         * The version of the orchestrator to use. You can specify the major.minor.patch part of the actual version.For example, you can specify version as "1.6.11".
         */
        orchestratorVersion?: string;
    }

    /**
     * Properties of the container service.
     */
    export interface ContainerServicePropertiesResponse {
        /**
         * Properties of the agent pool.
         */
        agentPoolProfiles?: outputs.containerservice.ContainerServiceAgentPoolProfileResponse[];
        /**
         * Properties to configure a custom container service cluster.
         */
        customProfile?: outputs.containerservice.ContainerServiceCustomProfileResponse;
        /**
         * Profile for diagnostics in the container service cluster.
         */
        diagnosticsProfile?: outputs.containerservice.ContainerServiceDiagnosticsProfileResponse;
        /**
         * Profile for Linux VMs in the container service cluster.
         */
        linuxProfile: outputs.containerservice.ContainerServiceLinuxProfileResponse;
        /**
         * Profile for the container service master.
         */
        masterProfile: outputs.containerservice.ContainerServiceMasterProfileResponse;
        /**
         * Profile for the container service orchestrator.
         */
        orchestratorProfile: outputs.containerservice.ContainerServiceOrchestratorProfileResponse;
        /**
         * The current deployment or provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * Information about a service principal identity for the cluster to use for manipulating Azure APIs. Exact one of secret or keyVaultSecretRef need to be specified.
         */
        servicePrincipalProfile?: outputs.containerservice.ContainerServiceServicePrincipalProfileResponse;
        /**
         * Profile for Windows VMs in the container service cluster.
         */
        windowsProfile?: outputs.containerservice.ContainerServiceWindowsProfileResponse;
    }

    /**
     * Information about a service principal identity for the cluster to use for manipulating Azure APIs. Either secret or keyVaultSecretRef must be specified.
     */
    export interface ContainerServiceServicePrincipalProfileResponse {
        /**
         * The ID for the service principal.
         */
        clientId: string;
        /**
         * Reference to a secret stored in Azure Key Vault.
         */
        keyVaultSecretRef?: outputs.containerservice.KeyVaultSecretRefResponse;
        /**
         * The secret password associated with the service principal in plain text.
         */
        secret?: string;
    }

    /**
     * SSH configuration for Linux-based VMs running on Azure.
     */
    export interface ContainerServiceSshConfigurationResponse {
        /**
         * The list of SSH public keys used to authenticate with Linux-based VMs. Only expect one key specified.
         */
        publicKeys: outputs.containerservice.ContainerServiceSshPublicKeyResponse[];
    }

    /**
     * Contains information about SSH certificate public key data.
     */
    export interface ContainerServiceSshPublicKeyResponse {
        /**
         * Certificate public key used to authenticate with VMs through SSH. The certificate must be in PEM format with or without headers.
         */
        keyData: string;
    }

    /**
     * Profile for diagnostics on the container service VMs.
     */
    export interface ContainerServiceVMDiagnosticsResponse {
        /**
         * Whether the VM diagnostic agent is provisioned on the VM.
         */
        enabled: boolean;
        /**
         * The URI of the storage account where diagnostics are stored.
         */
        storageUri: string;
    }

    /**
     * Profile for Windows VMs in the container service cluster.
     */
    export interface ContainerServiceWindowsProfileResponse {
        /**
         * The administrator password to use for Windows VMs.
         */
        adminPassword: string;
        /**
         * The administrator username to use for Windows VMs.
         */
        adminUsername: string;
    }

    /**
     * The credential result response.
     */
    export interface CredentialResultResponse {
        /**
         * The name of the credential.
         */
        name: string;
        /**
         * Base64-encoded Kubernetes configuration file.
         */
        value: string;
    }

    /**
     * Reference to a secret stored in Azure Key Vault.
     */
    export interface KeyVaultSecretRefResponse {
        /**
         * The secret name.
         */
        secretName: string;
        /**
         * Key vault identifier.
         */
        vaultID: string;
        /**
         * The secret version.
         */
        version?: string;
    }

    /**
     * AADProfile specifies attributes for Azure Active Directory integration.
     */
    export interface ManagedClusterAADProfileResponse {
        /**
         * AAD group object IDs that will have admin role of the cluster.
         */
        adminGroupObjectIDs?: string[];
        /**
         * The client AAD application ID.
         */
        clientAppID?: string;
        /**
         * Whether to enable Azure RBAC for Kubernetes authorization.
         */
        enableAzureRBAC?: boolean;
        /**
         * Whether to enable managed AAD.
         */
        managed?: boolean;
        /**
         * The server AAD application ID.
         */
        serverAppID?: string;
        /**
         * The server AAD application secret.
         */
        serverAppSecret?: string;
        /**
         * The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription.
         */
        tenantID?: string;
    }

    /**
     * Access profile for managed cluster API server.
     */
    export interface ManagedClusterAPIServerAccessProfileResponse {
        /**
         * Authorized IP Ranges to kubernetes API server.
         */
        authorizedIPRanges?: string[];
        /**
         * Whether to create the cluster as a private cluster or not.
         */
        enablePrivateCluster?: boolean;
    }

    /**
     * Properties for the container service agent pool profile.
     */
    export interface ManagedClusterAgentPoolProfilePropertiesResponse {
        /**
         * Availability zones for nodes. Must use VirtualMachineScaleSets AgentPoolType.
         */
        availabilityZones?: string[];
        /**
         * Number of agents (VMs) to host docker containers. Allowed values must be in the range of 0 to 100 (inclusive) for user pools and in the range of 1 to 100 (inclusive) for system pools. The default value is 1.
         */
        count?: number;
        /**
         * Whether to enable auto-scaler
         */
        enableAutoScaling?: boolean;
        /**
         * Enable public IP for nodes
         */
        enableNodePublicIP?: boolean;
        /**
         * Maximum number of nodes for auto-scaling
         */
        maxCount?: number;
        /**
         * Maximum number of pods that can run on a node.
         */
        maxPods?: number;
        /**
         * Minimum number of nodes for auto-scaling
         */
        minCount?: number;
        /**
         * AgentPoolMode represents mode of an agent pool
         */
        mode?: string;
        /**
         * Version of node image
         */
        nodeImageVersion?: string;
        /**
         * Agent pool node labels to be persisted across all nodes in agent pool.
         */
        nodeLabels?: {[key: string]: string};
        /**
         * Taints added to new nodes during node pool create and scale. For example, key=value:NoSchedule.
         */
        nodeTaints?: string[];
        /**
         * Version of orchestrator specified when creating the managed cluster.
         */
        orchestratorVersion?: string;
        /**
         * OS Disk Size in GB to be used to specify the disk size for every machine in this master/agent pool. If you specify 0, it will apply the default osDisk size according to the vmSize specified.
         */
        osDiskSizeGB?: outputs.containerservice.ContainerServiceOSDiskResponse;
        /**
         * OsType to be used to specify os type. Choose from Linux and Windows. Default to Linux.
         */
        osType?: string;
        /**
         * The current deployment or provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * The ID for Proximity Placement Group.
         */
        proximityPlacementGroupID?: string;
        /**
         * ScaleSetEvictionPolicy to be used to specify eviction policy for Spot virtual machine scale set. Default to Delete.
         */
        scaleSetEvictionPolicy?: string;
        /**
         * ScaleSetPriority to be used to specify virtual machine scale set priority. Default to regular.
         */
        scaleSetPriority?: string;
        /**
         * SpotMaxPrice to be used to specify the maximum price you are willing to pay in US Dollars. Possible values are any decimal value greater than zero or -1 which indicates default price to be up-to on-demand.
         */
        spotMaxPrice?: outputs.containerservice.SpotMaxPriceResponse;
        /**
         * Agent pool tags to be persisted on the agent pool virtual machine scale set.
         */
        tags?: {[key: string]: string};
        /**
         * AgentPoolType represents types of an agent pool
         */
        type?: string;
        /**
         * Settings for upgrading the agentpool
         */
        upgradeSettings?: outputs.containerservice.AgentPoolUpgradeSettingsResponse;
        /**
         * Size of agent VMs.
         */
        vmSize?: string;
        /**
         * VNet SubnetID specifies the VNet's subnet identifier.
         */
        vnetSubnetID?: string;
    }

    /**
     * Profile for the container service agent pool.
     */
    export interface ManagedClusterAgentPoolProfileResponse {
        /**
         * Availability zones for nodes. Must use VirtualMachineScaleSets AgentPoolType.
         */
        availabilityZones?: string[];
        /**
         * Number of agents (VMs) to host docker containers. Allowed values must be in the range of 0 to 100 (inclusive) for user pools and in the range of 1 to 100 (inclusive) for system pools. The default value is 1.
         */
        count?: number;
        /**
         * Whether to enable auto-scaler
         */
        enableAutoScaling?: boolean;
        /**
         * Enable public IP for nodes
         */
        enableNodePublicIP?: boolean;
        /**
         * Maximum number of nodes for auto-scaling
         */
        maxCount?: number;
        /**
         * Maximum number of pods that can run on a node.
         */
        maxPods?: number;
        /**
         * Minimum number of nodes for auto-scaling
         */
        minCount?: number;
        /**
         * AgentPoolMode represents mode of an agent pool
         */
        mode?: string;
        /**
         * Unique name of the agent pool profile in the context of the subscription and resource group.
         */
        name: string;
        /**
         * Version of node image
         */
        nodeImageVersion?: string;
        /**
         * Agent pool node labels to be persisted across all nodes in agent pool.
         */
        nodeLabels?: {[key: string]: string};
        /**
         * Taints added to new nodes during node pool create and scale. For example, key=value:NoSchedule.
         */
        nodeTaints?: string[];
        /**
         * Version of orchestrator specified when creating the managed cluster.
         */
        orchestratorVersion?: string;
        /**
         * OS Disk Size in GB to be used to specify the disk size for every machine in this master/agent pool. If you specify 0, it will apply the default osDisk size according to the vmSize specified.
         */
        osDiskSizeGB?: outputs.containerservice.ContainerServiceOSDiskResponse;
        /**
         * OsType to be used to specify os type. Choose from Linux and Windows. Default to Linux.
         */
        osType?: string;
        /**
         * The current deployment or provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * The ID for Proximity Placement Group.
         */
        proximityPlacementGroupID?: string;
        /**
         * ScaleSetEvictionPolicy to be used to specify eviction policy for Spot virtual machine scale set. Default to Delete.
         */
        scaleSetEvictionPolicy?: string;
        /**
         * ScaleSetPriority to be used to specify virtual machine scale set priority. Default to regular.
         */
        scaleSetPriority?: string;
        /**
         * SpotMaxPrice to be used to specify the maximum price you are willing to pay in US Dollars. Possible values are any decimal value greater than zero or -1 which indicates default price to be up-to on-demand.
         */
        spotMaxPrice?: outputs.containerservice.SpotMaxPriceResponse;
        /**
         * Agent pool tags to be persisted on the agent pool virtual machine scale set.
         */
        tags?: {[key: string]: string};
        /**
         * AgentPoolType represents types of an agent pool
         */
        type?: string;
        /**
         * Settings for upgrading the agentpool
         */
        upgradeSettings?: outputs.containerservice.AgentPoolUpgradeSettingsResponse;
        /**
         * Size of agent VMs.
         */
        vmSize?: string;
        /**
         * VNet SubnetID specifies the VNet's subnet identifier.
         */
        vnetSubnetID?: string;
    }

    /**
     * Identity for the managed cluster.
     */
    export interface ManagedClusterIdentityResponse {
        /**
         * The principal id of the system assigned identity which is used by master components.
         */
        principalId: string;
        /**
         * The tenant id of the system assigned identity which is used by master components.
         */
        tenantId: string;
        /**
         * The type of identity used for the managed cluster. Type 'SystemAssigned' will use an implicitly created identity in master components and an auto-created user assigned identity in MC_ resource group in agent nodes. Type 'None' will not use MSI for the managed cluster, service principal will be used instead.
         */
        type?: string;
        /**
         * The user identity associated with the managed cluster. This identity will be used in control plane and only one user assigned identity is allowed. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
         */
        userAssignedIdentities?: {[key: string]: string};
    }

    /**
     * Profile of the managed cluster load balancer.
     */
    export interface ManagedClusterLoadBalancerProfileResponse {
        /**
         * Desired number of allocated SNAT ports per VM. Allowed values must be in the range of 0 to 64000 (inclusive). The default value is 0 which results in Azure dynamically allocating ports.
         */
        allocatedOutboundPorts?: number;
        /**
         * The effective outbound IP resources of the cluster load balancer.
         */
        effectiveOutboundIPs?: outputs.containerservice.ResourceReferenceResponse[];
        /**
         * Desired outbound flow idle timeout in minutes. Allowed values must be in the range of 4 to 120 (inclusive). The default value is 30 minutes.
         */
        idleTimeoutInMinutes?: number;
        /**
         * Desired managed outbound IPs for the cluster load balancer.
         */
        managedOutboundIPs?: outputs.containerservice.ManagedClusterLoadBalancerProfileResponseProperties;
        /**
         * Desired outbound IP Prefix resources for the cluster load balancer.
         */
        outboundIPPrefixes?: outputs.containerservice.ManagedClusterLoadBalancerProfileResponseProperties;
        /**
         * Desired outbound IP resources for the cluster load balancer.
         */
        outboundIPs?: outputs.containerservice.ManagedClusterLoadBalancerProfileResponseProperties;
    }

    /**
     * Desired managed outbound IPs for the cluster load balancer.
     */
    export interface ManagedClusterLoadBalancerProfileResponseProperties {
        /**
         * Desired number of outbound IP created/managed by Azure for the cluster load balancer. Allowed values must be in the range of 1 to 100 (inclusive). The default value is 1. 
         */
        count?: number;
    }

    /**
     * Properties of the managed cluster.
     */
    export interface ManagedClusterPropertiesResponse {
        /**
         * Profile of Azure Active Directory configuration.
         */
        aadProfile?: outputs.containerservice.ManagedClusterAADProfileResponse;
        /**
         * Profile of managed cluster add-on.
         */
        addonProfiles?: {[key: string]: string};
        /**
         * Properties of the agent pool.
         */
        agentPoolProfiles?: outputs.containerservice.ManagedClusterAgentPoolProfileResponse[];
        /**
         * Access profile for managed cluster API server.
         */
        apiServerAccessProfile?: outputs.containerservice.ManagedClusterAPIServerAccessProfileResponse;
        /**
         * Parameters to be applied to the cluster-autoscaler when enabled
         */
        autoScalerProfile?: outputs.containerservice.ManagedClusterPropertiesResponseProperties;
        /**
         * ResourceId of the disk encryption set to use for enabling encryption at rest.
         */
        diskEncryptionSetID?: string;
        /**
         * DNS prefix specified when creating the managed cluster.
         */
        dnsPrefix?: string;
        /**
         * (PREVIEW) Whether to enable Kubernetes Pod security policy.
         */
        enablePodSecurityPolicy?: boolean;
        /**
         * Whether to enable Kubernetes Role-Based Access Control.
         */
        enableRBAC?: boolean;
        /**
         * FQDN for the master pool.
         */
        fqdn: string;
        /**
         * Identities associated with the cluster.
         */
        identityProfile?: {[key: string]: string};
        /**
         * Version of Kubernetes specified when creating the managed cluster.
         */
        kubernetesVersion?: string;
        /**
         * Profile for Linux VMs in the container service cluster.
         */
        linuxProfile?: outputs.containerservice.ContainerServiceLinuxProfileResponse;
        /**
         * The max number of agent pools for the managed cluster.
         */
        maxAgentPools: number;
        /**
         * Profile of network configuration.
         */
        networkProfile?: outputs.containerservice.ContainerServiceNetworkProfileResponse;
        /**
         * Name of the resource group containing agent pool nodes.
         */
        nodeResourceGroup?: string;
        /**
         * FQDN of private cluster.
         */
        privateFQDN: string;
        /**
         * The current deployment or provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * Information about a service principal identity for the cluster to use for manipulating Azure APIs.
         */
        servicePrincipalProfile?: outputs.containerservice.ManagedClusterServicePrincipalProfileResponse;
        /**
         * Profile for Windows VMs in the container service cluster.
         */
        windowsProfile?: outputs.containerservice.ManagedClusterWindowsProfileResponse;
    }

    /**
     * Parameters to be applied to the cluster-autoscaler when enabled
     */
    export interface ManagedClusterPropertiesResponseProperties {
    }

    export interface ManagedClusterSKUResponse {
        /**
         * Name of a managed cluster SKU.
         */
        name?: string;
        /**
         * Tier of a managed cluster SKU.
         */
        tier?: string;
    }

    /**
     * Information about a service principal identity for the cluster to use for manipulating Azure APIs.
     */
    export interface ManagedClusterServicePrincipalProfileResponse {
        /**
         * The ID for the service principal.
         */
        clientId: string;
        /**
         * The secret password associated with the service principal in plain text.
         */
        secret?: string;
    }

    /**
     * Profile for Windows VMs in the container service cluster.
     */
    export interface ManagedClusterWindowsProfileResponse {
        /**
         * The administrator password to use for Windows VMs.
         */
        adminPassword?: string;
        /**
         * The administrator username to use for Windows VMs.
         */
        adminUsername: string;
    }

    /**
     * Represents the OpenShift networking configuration
     */
    export interface NetworkProfileResponse {
        /**
         * CIDR of the Vnet to peer.
         */
        peerVnetId?: string;
        /**
         * CIDR for the OpenShift Vnet.
         */
        vnetCidr?: string;
        /**
         * ID of the Vnet created for OSA cluster.
         */
        vnetId?: string;
    }

    /**
     * Defines the configuration of the OpenShift cluster VMs.
     */
    export interface OpenShiftManagedClusterAgentPoolProfileResponse {
        /**
         * Number of agents (VMs) to host docker containers.
         */
        count: number;
        /**
         * Unique name of the pool profile in the context of the subscription and resource group.
         */
        name: string;
        /**
         * OsType to be used to specify os type. Choose from Linux and Windows. Default to Linux.
         */
        osType?: string;
        /**
         * Define the role of the AgentPoolProfile.
         */
        role?: string;
        /**
         * Subnet CIDR for the peering.
         */
        subnetCidr?: string;
        /**
         * Size of agent VMs.
         */
        vmSize: string;
    }

    /**
     * Defines all possible authentication profiles for the OpenShift cluster.
     */
    export interface OpenShiftManagedClusterAuthProfileResponse {
        /**
         * Type of authentication profile to use.
         */
        identityProviders?: outputs.containerservice.OpenShiftManagedClusterIdentityProviderResponse[];
    }

    /**
     * Structure for any Identity provider.
     */
    export interface OpenShiftManagedClusterBaseIdentityProviderResponse {
        /**
         * The kind of the provider.
         */
        kind: string;
    }

    /**
     * Defines the configuration of the identity providers to be used in the OpenShift cluster.
     */
    export interface OpenShiftManagedClusterIdentityProviderResponse {
        /**
         * Name of the provider.
         */
        name?: string;
        /**
         * Configuration of the provider.
         */
        provider?: outputs.containerservice.OpenShiftManagedClusterBaseIdentityProviderResponse;
    }

    /**
     * OpenShiftManagedClusterMaterPoolProfile contains configuration for OpenShift master VMs.
     */
    export interface OpenShiftManagedClusterMasterPoolProfileResponse {
        /**
         * Number of masters (VMs) to host docker containers. The default value is 3.
         */
        count: number;
        /**
         * Unique name of the master pool profile in the context of the subscription and resource group.
         */
        name?: string;
        /**
         * OsType to be used to specify os type. Choose from Linux and Windows. Default to Linux.
         */
        osType?: string;
        /**
         * Subnet CIDR for the peering.
         */
        subnetCidr?: string;
        /**
         * Size of agent VMs.
         */
        vmSize: string;
    }

    /**
     * Properties of the OpenShift managed cluster.
     */
    export interface OpenShiftManagedClusterPropertiesResponse {
        /**
         * Configuration of OpenShift cluster VMs.
         */
        agentPoolProfiles?: outputs.containerservice.OpenShiftManagedClusterAgentPoolProfileResponse[];
        /**
         * Configures OpenShift authentication.
         */
        authProfile?: outputs.containerservice.OpenShiftManagedClusterAuthProfileResponse;
        /**
         * Version of OpenShift specified when creating the cluster.
         */
        clusterVersion: string;
        /**
         * Service generated FQDN for OpenShift API server loadbalancer internal hostname.
         */
        fqdn: string;
        /**
         * Configuration for OpenShift master VMs.
         */
        masterPoolProfile?: outputs.containerservice.OpenShiftManagedClusterMasterPoolProfileResponse;
        /**
         * Configuration for OpenShift networking.
         */
        networkProfile?: outputs.containerservice.NetworkProfileResponse;
        /**
         * Version of OpenShift specified when creating the cluster.
         */
        openShiftVersion: string;
        /**
         * The current deployment or provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * Service generated FQDN for OpenShift API server.
         */
        publicHostname: string;
        /**
         * Configuration for OpenShift router(s).
         */
        routerProfiles?: outputs.containerservice.OpenShiftRouterProfileResponse[];
    }

    /**
     * Represents an OpenShift router
     */
    export interface OpenShiftRouterProfileResponse {
        /**
         * Auto-allocated FQDN for the OpenShift router.
         */
        fqdn: string;
        /**
         * Name of the router profile.
         */
        name?: string;
        /**
         * DNS subdomain for OpenShift router.
         */
        publicSubdomain: string;
    }

    /**
     * Properties of a private endpoint connection.
     */
    export interface PrivateEndpointConnectionPropertiesResponse {
        /**
         * The resource of private endpoint.
         */
        privateEndpoint?: outputs.containerservice.PrivateEndpointResponse;
        /**
         * A collection of information about the state of the connection between service consumer and provider.
         */
        privateLinkServiceConnectionState: outputs.containerservice.PrivateLinkServiceConnectionStateResponse;
        /**
         * The current provisioning state.
         */
        provisioningState: string;
    }

    /**
     * Private endpoint which a connection belongs to.
     */
    export interface PrivateEndpointResponse {
        /**
         * The resource Id for private endpoint
         */
        id?: string;
    }

    /**
     * The state of a private link service connection.
     */
    export interface PrivateLinkServiceConnectionStateResponse {
        /**
         * The private link service connection description.
         */
        description?: string;
        /**
         * The private link service connection status.
         */
        status?: string;
    }

    /**
     * Used for establishing the purchase context of any 3rd Party artifact through MarketPlace.
     */
    export interface PurchasePlanResponse {
        /**
         * The plan ID.
         */
        name?: string;
        /**
         * Specifies the product of the image from the marketplace. This is the same value as Offer under the imageReference element.
         */
        product?: string;
        /**
         * The promotion code.
         */
        promotionCode?: string;
        /**
         * The plan ID.
         */
        publisher?: string;
    }

    /**
     * A reference to an Azure resource.
     */
    export interface ResourceReferenceResponse {
        /**
         * The fully qualified Azure resource id.
         */
        id?: string;
    }

    /**
     * SpotMaxPrice to be used to specify the maximum price you are willing to pay in US Dollars. Possible values are any decimal value greater than zero or -1 which indicates default price to be up-to on-demand.
     */
    export interface SpotMaxPriceResponse {
    }
}

export namespace core {
    /**
     * The resource group properties.
     */
    export interface ResourceGroupPropertiesResponse {
        /**
         * The provisioning state. 
         */
        provisioningState: string;
    }
}

export namespace customerinsights {
    /**
     * The AssignmentPrincipal
     */
    export interface AssignmentPrincipalResponse {
        /**
         * The principal id being assigned to.
         */
        principalId: string;
        /**
         * Other metadata for the principal.
         */
        principalMetadata?: {[key: string]: string};
        /**
         * The Type of the principal ID.
         */
        principalType: string;
    }

    /**
     * Connector mapping property availability.
     */
    export interface ConnectorMappingAvailabilityResponse {
        /**
         * The frequency to update.
         */
        frequency?: string;
        /**
         * The interval of the given frequency to use.
         */
        interval: number;
    }

    /**
     * The complete operation.
     */
    export interface ConnectorMappingCompleteOperationResponse {
        /**
         * The type of completion operation.
         */
        completionOperationType?: string;
        /**
         * The destination folder where files will be moved to once the import is done.
         */
        destinationFolder?: string;
    }

    /**
     * The error management.
     */
    export interface ConnectorMappingErrorManagementResponse {
        /**
         * The error limit allowed while importing data.
         */
        errorLimit?: number;
        /**
         * The type of error management to use for the mapping.
         */
        errorManagementType: string;
    }

    /**
     * Connector mapping property format.
     */
    export interface ConnectorMappingFormatResponse {
        /**
         * The oData language.
         */
        acceptLanguage?: string;
        /**
         * Character separating array elements.
         */
        arraySeparator?: string;
        /**
         * The character that signifies a break between columns.
         */
        columnDelimiter?: string;
        /**
         * The type mapping format.
         */
        formatType: string;
        /**
         * Quote character, used to indicate enquoted fields.
         */
        quoteCharacter?: string;
        /**
         * Escape character for quotes, can be the same as the quoteCharacter.
         */
        quoteEscapeCharacter?: string;
    }

    /**
     * The connector mapping properties.
     */
    export interface ConnectorMappingPropertiesResponse {
        /**
         * The availability of mapping property.
         */
        availability: outputs.customerinsights.ConnectorMappingAvailabilityResponse;
        /**
         * The operation after import is done.
         */
        completeOperation: outputs.customerinsights.ConnectorMappingCompleteOperationResponse;
        /**
         * The error management setting for the mapping.
         */
        errorManagement: outputs.customerinsights.ConnectorMappingErrorManagementResponse;
        /**
         * The file filter for the mapping.
         */
        fileFilter?: string;
        /**
         * The folder path for the mapping.
         */
        folderPath?: string;
        /**
         * The format of mapping property.
         */
        format: outputs.customerinsights.ConnectorMappingFormatResponse;
        /**
         * If the file contains a header or not.
         */
        hasHeader?: boolean;
        /**
         * Ingestion mapping information at property level.
         */
        structure: outputs.customerinsights.ConnectorMappingStructureResponse[];
    }

    /**
     * The connector mapping definition.
     */
    export interface ConnectorMappingResponse {
        /**
         * The connector mapping name
         */
        connectorMappingName: string;
        /**
         * The connector name.
         */
        connectorName: string;
        /**
         * Type of connector.
         */
        connectorType?: string;
        /**
         * The created time.
         */
        created: string;
        /**
         * The DataFormat ID.
         */
        dataFormatId: string;
        /**
         * The description of the connector mapping.
         */
        description?: string;
        /**
         * Display name for the connector mapping.
         */
        displayName?: string;
        /**
         * Defines which entity type the file should map to.
         */
        entityType: string;
        /**
         * The mapping entity name.
         */
        entityTypeName: string;
        /**
         * The last modified time.
         */
        lastModified: string;
        /**
         * The properties of the mapping.
         */
        mappingProperties: outputs.customerinsights.ConnectorMappingPropertiesResponse;
        /**
         * The next run time based on customer's settings.
         */
        nextRunTime: string;
        /**
         * The RunId.
         */
        runId: string;
        /**
         * State of connector mapping.
         */
        state: string;
        /**
         * The hub name.
         */
        tenantId: string;
    }

    /**
     * Connector mapping property structure.
     */
    export interface ConnectorMappingStructureResponse {
        /**
         * The column name of the import file.
         */
        columnName: string;
        /**
         * Custom format specifier for input parsing.
         */
        customFormatSpecifier?: string;
        /**
         * Indicates if the column is encrypted.
         */
        isEncrypted?: boolean;
        /**
         * The property name of the mapping entity.
         */
        propertyName: string;
    }

    /**
     * Properties of connector.
     */
    export interface ConnectorResponse {
        /**
         * ID of the connector.
         */
        connectorId: number;
        /**
         * Name of the connector.
         */
        connectorName?: string;
        /**
         * The connector properties.
         */
        connectorProperties: {[key: string]: string};
        /**
         * Type of connector.
         */
        connectorType: string;
        /**
         * The created time.
         */
        created: string;
        /**
         * Description of the connector.
         */
        description?: string;
        /**
         * Display name of the connector.
         */
        displayName?: string;
        /**
         * If this is an internal connector.
         */
        isInternal?: boolean;
        /**
         * The last modified time.
         */
        lastModified: string;
        /**
         * State of connector.
         */
        state: string;
        /**
         * The hub name.
         */
        tenantId: string;
    }

    /**
     * The data source precedence is a way to know the precedence of each data source.
     */
    export interface DataSourcePrecedenceResponse {
        /**
         * Data Source is a way for us to know the source of instances. A single type can have data coming in from multiple places. In activities we use this to determine precedence rules.
         */
        dataSource?: outputs.customerinsights.DataSourceResponse;
        /**
         * the precedence value.
         */
        precedence?: number;
    }

    /**
     * Data Source is a way for us to know the source of instances. A single type can have data coming in from multiple places. In activities we use this to determine precedence rules.
     */
    export interface DataSourceResponse {
        /**
         * The data source reference id.
         */
        dataSourceReferenceId: string;
        /**
         * The data source type.
         */
        dataSourceType: string;
        /**
         * The data source ID.
         */
        id: number;
        /**
         * The data source name
         */
        name: string;
        /**
         * The data source status.
         */
        status: string;
    }

    /**
     * Hub billing info.
     */
    export interface HubBillingInfoFormatResponse {
        /**
         * The maximum number of units can be used.  One unit is 10,000 Profiles and 100,000 Interactions.
         */
        maxUnits?: number;
        /**
         * The minimum number of units will be billed. One unit is 10,000 Profiles and 100,000 Interactions.
         */
        minUnits?: number;
        /**
         * The sku name.
         */
        skuName?: string;
    }

    /**
     * Properties of hub.
     */
    export interface HubPropertiesFormatResponse {
        /**
         * API endpoint URL of the hub.
         */
        apiEndpoint: string;
        /**
         * Billing settings of the hub.
         */
        hubBillingInfo?: outputs.customerinsights.HubBillingInfoFormatResponse;
        /**
         * Provisioning state of the hub.
         */
        provisioningState: string;
        /**
         * The bit flags for enabled hub features. Bit 0 is set to 1 indicates graph is enabled, or disabled if set to 0. Bit 1 is set to 1 indicates the hub is disabled, or enabled if set to 0.
         */
        tenantFeatures?: number;
        /**
         * Web endpoint URL of the hub.
         */
        webEndpoint: string;
    }

    /**
     * The KPI alias.
     */
    export interface KpiAliasResponse {
        /**
         * KPI alias name.
         */
        aliasName: string;
        /**
         * The expression.
         */
        expression: string;
    }

    /**
     * Defines the KPI Threshold limits.
     */
    export interface KpiDefinitionResponse {
        /**
         * The aliases.
         */
        aliases?: outputs.customerinsights.KpiAliasResponse[];
        /**
         * The calculation window.
         */
        calculationWindow: string;
        /**
         * Name of calculation window field.
         */
        calculationWindowFieldName?: string;
        /**
         * Localized description for the KPI.
         */
        description?: {[key: string]: string};
        /**
         * Localized display name for the KPI.
         */
        displayName?: {[key: string]: string};
        /**
         * The mapping entity type.
         */
        entityType: string;
        /**
         * The mapping entity name.
         */
        entityTypeName: string;
        /**
         * The computation expression for the KPI.
         */
        expression: string;
        /**
         * The KPI extracts.
         */
        extracts?: outputs.customerinsights.KpiExtractResponse[];
        /**
         * The filter expression for the KPI.
         */
        filter?: string;
        /**
         * The computation function for the KPI.
         */
        function: string;
        /**
         * the group by properties for the KPI.
         */
        groupBy?: string[];
        /**
         * The KPI GroupByMetadata.
         */
        groupByMetadata: outputs.customerinsights.KpiGroupByMetadataResponse[];
        /**
         * The KPI name.
         */
        kpiName: string;
        /**
         * The participant profiles.
         */
        participantProfilesMetadata: outputs.customerinsights.KpiParticipantProfilesMetadataResponse[];
        /**
         * Provisioning state.
         */
        provisioningState: string;
        /**
         * The hub name.
         */
        tenantId: string;
        /**
         * The KPI thresholds.
         */
        thresHolds?: outputs.customerinsights.KpiThresholdsResponse;
        /**
         * The unit of measurement for the KPI.
         */
        unit?: string;
    }

    /**
     * The KPI extract.
     */
    export interface KpiExtractResponse {
        /**
         * The expression.
         */
        expression: string;
        /**
         * KPI extract name.
         */
        extractName: string;
    }

    /**
     * The KPI GroupBy field metadata.
     */
    export interface KpiGroupByMetadataResponse {
        /**
         * The display name.
         */
        displayName?: {[key: string]: string};
        /**
         * The name of the field.
         */
        fieldName?: string;
        /**
         * The type of the field.
         */
        fieldType?: string;
    }

    /**
     * The KPI participant profile metadata.
     */
    export interface KpiParticipantProfilesMetadataResponse {
        /**
         * Name of the type.
         */
        typeName: string;
    }

    /**
     * Defines the KPI Threshold limits.
     */
    export interface KpiThresholdsResponse {
        /**
         * Whether or not the KPI is an increasing KPI.
         */
        increasingKpi: boolean;
        /**
         * The lower threshold limit.
         */
        lowerLimit: number;
        /**
         * The upper threshold limit.
         */
        upperLimit: number;
    }

    /**
     * The definition of Link.
     */
    export interface LinkDefinitionResponse {
        /**
         * Localized descriptions for the Link.
         */
        description?: {[key: string]: string};
        /**
         * Localized display name for the Link.
         */
        displayName?: {[key: string]: string};
        /**
         * The link name.
         */
        linkName: string;
        /**
         * The set of properties mappings between the source and target Types.
         */
        mappings?: outputs.customerinsights.TypePropertiesMappingResponse[];
        /**
         * Determines whether this link is supposed to create or delete instances if Link is NOT Reference Only.
         */
        operationType?: string;
        /**
         * The properties that represent the participating profile.
         */
        participantPropertyReferences: outputs.customerinsights.ParticipantPropertyReferenceResponse[];
        /**
         * Provisioning state.
         */
        provisioningState: string;
        /**
         * Indicating whether the link is reference only link. This flag is ignored if the Mappings are defined. If the mappings are not defined and it is set to true, links processing will not create or update profiles.
         */
        referenceOnly?: boolean;
        /**
         * Type of source entity.
         */
        sourceEntityType: string;
        /**
         * Name of the source Entity Type.
         */
        sourceEntityTypeName: string;
        /**
         * Type of target entity.
         */
        targetEntityType: string;
        /**
         * Name of the target Entity Type.
         */
        targetEntityTypeName: string;
        /**
         * The hub name.
         */
        tenantId: string;
    }

    /**
     * The participant profile property reference.
     */
    export interface ParticipantProfilePropertyReferenceResponse {
        /**
         * The source interaction property that maps to the target profile property.
         */
        interactionPropertyName: string;
        /**
         * The target profile property that maps to the source interaction property.
         */
        profilePropertyName: string;
    }

    /**
     * The participant property reference.
     */
    export interface ParticipantPropertyReferenceResponse {
        /**
         * The source property that maps to the target property.
         */
        sourcePropertyName: string;
        /**
         * The target property that maps to the source property.
         */
        targetPropertyName: string;
    }

    /**
     * The prediction definition.
     */
    export interface PredictionResponse {
        /**
         * Whether do auto analyze.
         */
        autoAnalyze: boolean;
        /**
         * Description of the prediction.
         */
        description?: {[key: string]: string};
        /**
         * Display name of the prediction.
         */
        displayName?: {[key: string]: string};
        /**
         * The prediction grades.
         */
        grades?: outputs.customerinsights.PredictionResponseProperties[];
        /**
         * Interaction types involved in the prediction.
         */
        involvedInteractionTypes?: string[];
        /**
         * KPI types involved in the prediction.
         */
        involvedKpiTypes?: string[];
        /**
         * Relationships involved in the prediction.
         */
        involvedRelationships?: string[];
        /**
         * Definition of the link mapping of prediction.
         */
        mappings: outputs.customerinsights.PredictionResponseProperties;
        /**
         * Negative outcome expression.
         */
        negativeOutcomeExpression: string;
        /**
         * Positive outcome expression.
         */
        positiveOutcomeExpression: string;
        /**
         * Name of the prediction.
         */
        predictionName?: string;
        /**
         * Primary profile type.
         */
        primaryProfileType: string;
        /**
         * Provisioning state.
         */
        provisioningState: string;
        /**
         * Scope expression.
         */
        scopeExpression: string;
        /**
         * Score label.
         */
        scoreLabel: string;
        /**
         * System generated entities.
         */
        systemGeneratedEntities: outputs.customerinsights.PredictionResponseProperties;
        /**
         * The hub name.
         */
        tenantId: string;
    }

    /**
     * The definition of a prediction grade.
     */
    export interface PredictionResponseProperties {
        /**
         * Name of the grade.
         */
        gradeName?: string;
        /**
         * Maximum score threshold.
         */
        maxScoreThreshold?: number;
        /**
         * Minimum score threshold.
         */
        minScoreThreshold?: number;
    }

    /**
     * Valid enum values in case of an enum property.
     */
    export interface ProfileEnumValidValuesFormatResponse {
        /**
         * Localized names of the enum member.
         */
        localizedValueNames?: {[key: string]: string};
        /**
         * The integer value of the enum member.
         */
        value?: number;
    }

    /**
     * The profile type definition.
     */
    export interface ProfileTypeDefinitionResponse {
        /**
         * The api entity set name. This becomes the odata entity set name for the entity Type being referred in this object.
         */
        apiEntitySetName?: string;
        /**
         * The attributes for the Type.
         */
        attributes?: {[key: string]: string};
        /**
         * Localized descriptions for the property.
         */
        description?: {[key: string]: string};
        /**
         * Localized display names for the property.
         */
        displayName?: {[key: string]: string};
        /**
         * Type of entity.
         */
        entityType?: string;
        /**
         * The properties of the Profile.
         */
        fields?: outputs.customerinsights.PropertyDefinitionResponse[];
        /**
         * The instance count.
         */
        instancesCount?: number;
        /**
         * Large Image associated with the Property or EntityType.
         */
        largeImage?: string;
        /**
         * The last changed time for the type definition.
         */
        lastChangedUtc: string;
        /**
         * Any custom localized attributes for the Type.
         */
        localizedAttributes?: {[key: string]: string};
        /**
         * Medium Image associated with the Property or EntityType.
         */
        mediumImage?: string;
        /**
         * Provisioning state.
         */
        provisioningState: string;
        /**
         * The schema org link. This helps ACI identify and suggest semantic models.
         */
        schemaItemTypeLink?: string;
        /**
         * Small Image associated with the Property or EntityType.
         */
        smallImage?: string;
        /**
         * The strong IDs.
         */
        strongIds?: outputs.customerinsights.StrongIdResponse[];
        /**
         * The hub name.
         */
        tenantId: string;
        /**
         * The timestamp property name. Represents the time when the interaction or profile update happened.
         */
        timestampFieldName?: string;
        /**
         * The name of the entity.
         */
        typeName?: string;
    }

    /**
     * Property definition.
     */
    export interface PropertyDefinitionResponse {
        /**
         * Array value separator for properties with isArray set.
         */
        arrayValueSeparator?: string;
        /**
         * This is specific to interactions modeled as activities. Data sources are used to determine where data is stored and also in precedence rules.
         */
        dataSourcePrecedenceRules: outputs.customerinsights.DataSourcePrecedenceResponse[];
        /**
         * Describes valid values for an enum property.
         */
        enumValidValues?: outputs.customerinsights.ProfileEnumValidValuesFormatResponse[];
        /**
         * Name of the property.
         */
        fieldName: string;
        /**
         * Type of the property.
         */
        fieldType: string;
        /**
         * Indicates if the property is actually an array of the fieldType above on the data api.
         */
        isArray?: boolean;
        /**
         * Whether property is available in graph or not.
         */
        isAvailableInGraph?: boolean;
        /**
         * Indicates if the property is an enum.
         */
        isEnum?: boolean;
        /**
         * Indicates if the property is an flag enum.
         */
        isFlagEnum?: boolean;
        /**
         * Whether the property is an Image.
         */
        isImage?: boolean;
        /**
         * Whether the property is a localized string.
         */
        isLocalizedString?: boolean;
        /**
         * Whether the property is a name or a part of name.
         */
        isName?: boolean;
        /**
         * Whether property value is required on instances, IsRequired field only for Interaction. Profile Instance will not check for required field.
         */
        isRequired?: boolean;
        /**
         * Max length of string. Used only if type is string.
         */
        maxLength?: number;
        /**
         * The ID associated with the property.
         */
        propertyId?: string;
        /**
         * URL encoded schema.org item prop link for the property.
         */
        schemaItemPropLink?: string;
    }

    /**
     * The definition of Relationship.
     */
    export interface RelationshipDefinitionResponse {
        /**
         * The Relationship Cardinality.
         */
        cardinality?: string;
        /**
         * Localized descriptions for the Relationship.
         */
        description?: {[key: string]: string};
        /**
         * Localized display name for the Relationship.
         */
        displayName?: {[key: string]: string};
        /**
         * The expiry date time in UTC.
         */
        expiryDateTimeUtc?: string;
        /**
         * The properties of the Relationship.
         */
        fields?: outputs.customerinsights.PropertyDefinitionResponse[];
        /**
         * Optional property to be used to map fields in profile to their strong ids in related profile.
         */
        lookupMappings?: outputs.customerinsights.RelationshipTypeMappingResponse[];
        /**
         * Profile type.
         */
        profileType: string;
        /**
         * Provisioning state.
         */
        provisioningState: string;
        /**
         * Related profile being referenced.
         */
        relatedProfileType: string;
        /**
         * The relationship guid id.
         */
        relationshipGuidId: string;
        /**
         * The Relationship name.
         */
        relationshipName: string;
        /**
         * The hub name.
         */
        tenantId: string;
    }

    /**
     * The definition of relationship link.
     */
    export interface RelationshipLinkDefinitionResponse {
        /**
         * Localized descriptions for the Relationship Link.
         */
        description?: {[key: string]: string};
        /**
         * Localized display name for the Relationship Link.
         */
        displayName?: {[key: string]: string};
        /**
         * The InteractionType associated with the Relationship Link.
         */
        interactionType: string;
        /**
         * The name of the Relationship Link.
         */
        linkName: string;
        /**
         * The mappings between Interaction and Relationship fields.
         */
        mappings?: outputs.customerinsights.RelationshipLinkFieldMappingResponse[];
        /**
         * The property references for the Profile of the Relationship.
         */
        profilePropertyReferences: outputs.customerinsights.ParticipantProfilePropertyReferenceResponse[];
        /**
         * Provisioning state.
         */
        provisioningState: string;
        /**
         * The property references for the Related Profile of the Relationship.
         */
        relatedProfilePropertyReferences: outputs.customerinsights.ParticipantProfilePropertyReferenceResponse[];
        /**
         * The relationship guid id.
         */
        relationshipGuidId: string;
        /**
         * The Relationship associated with the Link.
         */
        relationshipName: string;
        /**
         * The hub name.
         */
        tenantId: string;
    }

    /**
     * The fields mapping for Relationships.
     */
    export interface RelationshipLinkFieldMappingResponse {
        /**
         * The field name on the Interaction Type.
         */
        interactionFieldName: string;
        /**
         * Link type.
         */
        linkType?: string;
        /**
         * The field name on the Relationship metadata.
         */
        relationshipFieldName: string;
    }

    /**
     * Map a field of profile to its corresponding StrongId in Related Profile.
     */
    export interface RelationshipTypeFieldMappingResponse {
        /**
         * Specifies the fieldName in profile.
         */
        profileFieldName: string;
        /**
         * Specifies the KeyProperty (from StrongId) of the related profile.
         */
        relatedProfileKeyProperty: string;
    }

    /**
     * Maps fields in Profile to their corresponding StrongIds in Related Profile.
     */
    export interface RelationshipTypeMappingResponse {
        /**
         * Maps a profile property with the StrongId of related profile. This is an array to support StrongIds that are composite key as well.
         */
        fieldMappings: outputs.customerinsights.RelationshipTypeFieldMappingResponse[];
    }

    /**
     * The resource set description.
     */
    export interface ResourceSetDescriptionResponse {
        /**
         * The elements included in the set.
         */
        elements?: string[];
        /**
         * The elements that are not included in the set, in case elements contains '*' indicating 'all'.
         */
        exceptions?: string[];
    }

    /**
     * The Role Assignment definition.
     */
    export interface RoleAssignmentResponse {
        /**
         * The name of the metadata object.
         */
        assignmentName: string;
        /**
         * Widget types set for the assignment.
         */
        conflationPolicies?: outputs.customerinsights.ResourceSetDescriptionResponse;
        /**
         * Connectors set for the assignment.
         */
        connectors?: outputs.customerinsights.ResourceSetDescriptionResponse;
        /**
         * Localized description for the metadata.
         */
        description?: {[key: string]: string};
        /**
         * Localized display names for the metadata.
         */
        displayName?: {[key: string]: string};
        /**
         * Interactions set for the assignment.
         */
        interactions?: outputs.customerinsights.ResourceSetDescriptionResponse;
        /**
         * Kpis set for the assignment.
         */
        kpis?: outputs.customerinsights.ResourceSetDescriptionResponse;
        /**
         * Links set for the assignment.
         */
        links?: outputs.customerinsights.ResourceSetDescriptionResponse;
        /**
         * The principals being assigned to.
         */
        principals: outputs.customerinsights.AssignmentPrincipalResponse[];
        /**
         * Profiles set for the assignment.
         */
        profiles?: outputs.customerinsights.ResourceSetDescriptionResponse;
        /**
         * Provisioning state.
         */
        provisioningState: string;
        /**
         * The Role assignments set for the relationship links.
         */
        relationshipLinks?: outputs.customerinsights.ResourceSetDescriptionResponse;
        /**
         * The Role assignments set for the relationships.
         */
        relationships?: outputs.customerinsights.ResourceSetDescriptionResponse;
        /**
         * Type of roles.
         */
        role: string;
        /**
         * The Role assignments set for the assignment.
         */
        roleAssignments?: outputs.customerinsights.ResourceSetDescriptionResponse;
        /**
         * Sas Policies set for the assignment.
         */
        sasPolicies?: outputs.customerinsights.ResourceSetDescriptionResponse;
        /**
         * The Role assignments set for the assignment.
         */
        segments?: outputs.customerinsights.ResourceSetDescriptionResponse;
        /**
         * The hub name.
         */
        tenantId: string;
        /**
         * Views set for the assignment.
         */
        views?: outputs.customerinsights.ResourceSetDescriptionResponse;
        /**
         * Widget types set for the assignment.
         */
        widgetTypes?: outputs.customerinsights.ResourceSetDescriptionResponse;
    }

    /**
     * Property/Properties which represent a unique ID.
     */
    export interface StrongIdResponse {
        /**
         * Localized descriptions.
         */
        description?: {[key: string]: string};
        /**
         * Localized display name.
         */
        displayName?: {[key: string]: string};
        /**
         * The properties which make up the unique ID.
         */
        keyPropertyNames: string[];
        /**
         * The Name identifying the strong ID.
         */
        strongIdName: string;
    }

    /**
     * Metadata for a Link's property mapping.
     */
    export interface TypePropertiesMappingResponse {
        /**
         * Link type.
         */
        linkType?: string;
        /**
         *  Property name on the source Entity Type.
         */
        sourcePropertyName: string;
        /**
         * Property name on the target Entity Type.
         */
        targetPropertyName: string;
    }

    /**
     * The view in Customer 360 web application.
     */
    export interface ViewResponse {
        /**
         * Date time when view was last modified.
         */
        changed: string;
        /**
         * Date time when view was created.
         */
        created: string;
        /**
         * View definition.
         */
        definition: string;
        /**
         * Localized display name for the view.
         */
        displayName?: {[key: string]: string};
        /**
         * the hub name.
         */
        tenantId: string;
        /**
         * the user ID.
         */
        userId?: string;
        /**
         * Name of the view.
         */
        viewName: string;
    }
}

export namespace databox {
    /**
     * Contact Details.
     */
    export interface ContactDetailsResponse {
        /**
         * Contact name of the person.
         */
        contactName: string;
        /**
         * List of Email-ids to be notified about job progress.
         */
        emailList: string[];
        /**
         * Mobile number of the contact person.
         */
        mobile?: string;
        /**
         * Notification preference for a job stage.
         */
        notificationPreference?: outputs.databox.NotificationPreferenceResponse[];
        /**
         * Phone number of the contact person.
         */
        phone: string;
        /**
         * Phone extension number of the contact person.
         */
        phoneExtension?: string;
    }

    /**
     * Details for log generated during copy.
     */
    export interface CopyLogDetailsResponse {
        /**
         * Indicates the type of job details.
         */
        copyLogDetailsType: string;
    }

    /**
     * Dc Access Security code for device.
     */
    export interface DcAccessSecurityCodeResponse {
        /**
         * Dc Access Code for dispatching from DC.
         */
        forwardDcAccessCode?: string;
        /**
         * Dc Access code for dropping off at DC.
         */
        reverseDcAccessCode?: string;
    }

    /**
     * Details of the destination storage accounts.
     */
    export interface DestinationAccountDetailsResponse {
        /**
         * Arm Id of the destination where the data has to be moved.
         */
        accountId?: string;
        /**
         * Data Destination Type.
         */
        dataDestinationType: string;
        /**
         * Share password to be shared by all shares in SA.
         */
        sharePassword?: string;
    }

    /**
     * Top level error for the job.
     */
    export interface ErrorResponse {
        /**
         * Error code that can be used to programmatically identify the error.
         */
        code: string;
        /**
         * Describes the error in detail and provides debugging information.
         */
        message: string;
    }

    /**
     * Additional delivery info.
     */
    export interface JobDeliveryInfoResponse {
        /**
         * Scheduled date time.
         */
        scheduledDateTime?: string;
    }

    /**
     * Job details.
     */
    export interface JobDetailsResponse {
        /**
         * Shared access key to download the chain of custody logs
         */
        chainOfCustodySasKey: string;
        /**
         * Contact details for notification and shipping.
         */
        contactDetails: outputs.databox.ContactDetailsResponse;
        /**
         * List of copy log details.
         */
        copyLogDetails: outputs.databox.CopyLogDetailsResponse[];
        /**
         * Delivery package shipping details.
         */
        deliveryPackage: outputs.databox.PackageShippingDetailsResponse;
        /**
         * Destination account details.
         */
        destinationAccountDetails: outputs.databox.DestinationAccountDetailsResponse[];
        /**
         * Error details for failure. This is optional.
         */
        errorDetails: outputs.databox.JobErrorDetailsResponse[];
        /**
         * The expected size of the data, which needs to be transferred in this job, in terabytes.
         */
        expectedDataSizeInTerabytes?: number;
        /**
         * Indicates the type of job details.
         */
        jobDetailsType: string;
        /**
         * List of stages that run in the job.
         */
        jobStages: outputs.databox.JobStagesResponse[];
        /**
         * Preferences for the order.
         */
        preferences?: outputs.databox.PreferencesResponse;
        /**
         * Return package shipping details.
         */
        returnPackage: outputs.databox.PackageShippingDetailsResponse;
        /**
         * Shared access key to download the return shipment label
         */
        reverseShipmentLabelSasKey: string;
        /**
         * Shipping address of the customer.
         */
        shippingAddress: outputs.databox.ShippingAddressResponse;
    }

    /**
     * Job Error Details for providing the information and recommended action.
     */
    export interface JobErrorDetailsResponse {
        /**
         * Code for the error.
         */
        errorCode: number;
        /**
         * Message for the error.
         */
        errorMessage: string;
        /**
         * Contains the non localized exception message
         */
        exceptionMessage: string;
        /**
         * Recommended action for the error.
         */
        recommendedAction: string;
    }

    /**
     * Job Properties
     */
    export interface JobPropertiesResponse {
        /**
         * Reason for cancellation.
         */
        cancellationReason: string;
        /**
         * Delivery Info of Job.
         */
        deliveryInfo?: outputs.databox.JobDeliveryInfoResponse;
        /**
         * Delivery type of Job.
         */
        deliveryType?: string;
        /**
         * Details of a job run. This field will only be sent for expand details filter.
         */
        details?: outputs.databox.JobDetailsResponse;
        /**
         * Top level error for the job.
         */
        error: outputs.databox.ErrorResponse;
        /**
         * Describes whether the job is cancellable or not.
         */
        isCancellable: boolean;
        /**
         * Flag to indicate cancellation of scheduled job.
         */
        isCancellableWithoutFee: boolean;
        /**
         * Describes whether the job is deletable or not.
         */
        isDeletable: boolean;
        /**
         * Describes whether the shipping address is editable or not.
         */
        isShippingAddressEditable: boolean;
        /**
         * Time at which the job was started in UTC ISO 8601 format.
         */
        startTime: string;
        /**
         * Name of the stage which is in progress.
         */
        status: string;
    }

    /**
     * The base class for the secrets
     */
    export interface JobSecretsResponse {
        /**
         * Dc Access Security Code for Customer Managed Shipping
         */
        dcAccessSecurityCode?: outputs.databox.DcAccessSecurityCodeResponse;
        /**
         * Used to indicate what type of job secrets object.
         */
        jobSecretsType: string;
    }

    /**
     * Job stages.
     */
    export interface JobStagesResponse {
        /**
         * Display name of the job stage.
         */
        displayName: string;
        /**
         * Error details for the stage.
         */
        errorDetails: outputs.databox.JobErrorDetailsResponse[];
        /**
         * Job Stage Details
         */
        jobStageDetails: {[key: string]: string};
        /**
         * Name of the job stage.
         */
        stageName: string;
        /**
         * Status of the job stage.
         */
        stageStatus: string;
        /**
         * Time for the job stage in UTC ISO 8601 format.
         */
        stageTime: string;
    }

    /**
     * Notification preference for a job stage.
     */
    export interface NotificationPreferenceResponse {
        /**
         * Notification is required or not.
         */
        sendNotification: boolean;
        /**
         * Name of the stage.
         */
        stageName: string;
    }

    /**
     * Shipping details.
     */
    export interface PackageShippingDetailsResponse {
        /**
         * Name of the carrier.
         */
        carrierName: string;
        /**
         * Tracking Id of shipment.
         */
        trackingId: string;
        /**
         * Url where shipment can be tracked.
         */
        trackingUrl: string;
    }

    /**
     * Preferences related to the order
     */
    export interface PreferencesResponse {
        /**
         * Preferred Data Center Region.
         */
        preferredDataCenterRegion?: string[];
        /**
         * Preferences related to the shipment logistics of the sku.
         */
        transportPreferences?: outputs.databox.TransportPreferencesResponse;
    }

    /**
     * Shipping address where customer wishes to receive the device.
     */
    export interface ShippingAddressResponse {
        /**
         * Type of address.
         */
        addressType?: string;
        /**
         * Name of the City.
         */
        city?: string;
        /**
         * Name of the company.
         */
        companyName?: string;
        /**
         * Name of the Country.
         */
        country: string;
        /**
         * Postal code.
         */
        postalCode: string;
        /**
         * Name of the State or Province.
         */
        stateOrProvince?: string;
        /**
         * Street Address line 1.
         */
        streetAddress1: string;
        /**
         * Street Address line 2.
         */
        streetAddress2?: string;
        /**
         * Street Address line 3.
         */
        streetAddress3?: string;
        /**
         * Extended Zip Code.
         */
        zipExtendedCode?: string;
    }

    /**
     * The Sku.
     */
    export interface SkuResponse {
        /**
         * The display name of the sku.
         */
        displayName?: string;
        /**
         * The sku family.
         */
        family?: string;
        /**
         * The sku name.
         */
        name: string;
    }

    /**
     * Preferences related to the shipment logistics of the sku
     */
    export interface TransportPreferencesResponse {
        /**
         * Indicates Shipment Logistics type that the customer preferred.
         */
        preferredShipmentType: string;
    }

    /**
     * Unencrypted credentials for accessing device.
     */
    export interface UnencryptedCredentialsResponse {
        /**
         * Name of the job.
         */
        jobName: string;
        /**
         * Secrets related to this job.
         */
        jobSecrets: outputs.databox.JobSecretsResponse;
    }
}

export namespace databoxedge {
    /**
     * The shipping address of the customer.
     */
    export interface AddressResponse {
        /**
         * The address line1.
         */
        addressLine1: string;
        /**
         * The address line2.
         */
        addressLine2?: string;
        /**
         * The address line3.
         */
        addressLine3?: string;
        /**
         * The city name.
         */
        city: string;
        /**
         * The country name.
         */
        country: string;
        /**
         * The postal code.
         */
        postalCode: string;
        /**
         * The state name.
         */
        state: string;
    }

    /**
     * Represent the secrets intended for encryption with asymmetric key pair.
     */
    export interface AsymmetricEncryptedSecretResponse {
        /**
         * The algorithm used to encrypt "Value".
         */
        encryptionAlgorithm: string;
        /**
         * Thumbprint certificate used to encrypt \"Value\". If the value is unencrypted, it will be null.
         */
        encryptionCertThumbprint?: string;
        /**
         * The value of the secret.
         */
        value: string;
    }

    /**
     * Azure container mapping of the endpoint.
     */
    export interface AzureContainerInfoResponse {
        /**
         * Container name (Based on the data format specified, this represents the name of Azure Files/Page blob/Block blob).
         */
        containerName: string;
        /**
         * Storage format used for the file represented by the share.
         */
        dataFormat: string;
        /**
         * ID of the storage account credential used to access storage.
         */
        storageAccountCredentialId: string;
    }

    /**
     * The properties of the bandwidth schedule.
     */
    export interface BandwidthSchedulePropertiesResponse {
        /**
         * The days of the week when this schedule is applicable.
         */
        days: string[];
        /**
         * The bandwidth rate in Mbps.
         */
        rateInMbps: number;
        /**
         * The start time of the schedule in UTC.
         */
        start: string;
        /**
         * The stop time of the schedule in UTC.
         */
        stop: string;
    }

    /**
     * The mapping between a particular client IP and the type of access client has on the NFS share.
     */
    export interface ClientAccessRightResponse {
        /**
         * Type of access to be allowed for the client.
         */
        accessPermission: string;
        /**
         * IP of the client.
         */
        client: string;
    }

    /**
     * Contains all the contact details of the customer.
     */
    export interface ContactDetailsResponse {
        /**
         * The name of the company.
         */
        companyName: string;
        /**
         * The contact person name.
         */
        contactPerson: string;
        /**
         * The email list.
         */
        emailList: string[];
        /**
         * The phone number.
         */
        phone: string;
    }

    /**
     * The container properties.
     */
    export interface ContainerPropertiesResponse {
        /**
         * Current status of the container.
         */
        containerStatus: string;
        /**
         * The UTC time when container got created.
         */
        createdDateTime: string;
        /**
         * DataFormat for Container
         */
        dataFormat: string;
        /**
         * Details of the refresh job on this container.
         */
        refreshDetails: outputs.databoxedge.RefreshDetailsResponse;
    }

    /**
     * The properties of the Data Box Edge/Gateway device.
     */
    export interface DataBoxEdgeDevicePropertiesResponse {
        /**
         * Type of compute roles configured.
         */
        configuredRoleTypes: string[];
        /**
         * The Data Box Edge/Gateway device culture.
         */
        culture: string;
        /**
         * The status of the Data Box Edge/Gateway device.
         */
        dataBoxEdgeDeviceStatus?: string;
        /**
         * The Description of the Data Box Edge/Gateway device.
         */
        description?: string;
        /**
         * The device software version number of the device (eg: 1.2.18105.6).
         */
        deviceHcsVersion: string;
        /**
         * The Data Box Edge/Gateway device local capacity in MB.
         */
        deviceLocalCapacity: number;
        /**
         * The Data Box Edge/Gateway device model.
         */
        deviceModel: string;
        /**
         * The Data Box Edge/Gateway device software version.
         */
        deviceSoftwareVersion: string;
        /**
         * The type of the Data Box Edge/Gateway device.
         */
        deviceType: string;
        /**
         * The Data Box Edge/Gateway device name.
         */
        friendlyName?: string;
        /**
         * The description of the Data Box Edge/Gateway device model.
         */
        modelDescription?: string;
        /**
         * The number of nodes in the cluster.
         */
        nodeCount: number;
        /**
         * The Serial Number of Data Box Edge/Gateway device.
         */
        serialNumber: string;
        /**
         * The Data Box Edge/Gateway device timezone.
         */
        timeZone: string;
    }

    /**
     * The share mount point.
     */
    export interface MountPointMapResponse {
        /**
         * Mount point for the share.
         */
        mountPoint: string;
        /**
         * ID of the role to which share is mounted.
         */
        roleId: string;
        /**
         * Role type.
         */
        roleType: string;
        /**
         * ID of the share mounted to the role VM.
         */
        shareId: string;
    }

    /**
     * Order properties.
     */
    export interface OrderPropertiesResponse {
        /**
         * The contact details.
         */
        contactInformation: outputs.databoxedge.ContactDetailsResponse;
        /**
         * Current status of the order.
         */
        currentStatus?: outputs.databoxedge.OrderStatusResponse;
        /**
         * Tracking information for the package delivered to the customer whether it has an original or a replacement device.
         */
        deliveryTrackingInfo: outputs.databoxedge.TrackingInfoResponse[];
        /**
         * List of status changes in the order.
         */
        orderHistory: outputs.databoxedge.OrderStatusResponse[];
        /**
         * Tracking information for the package returned from the customer whether it has an original or a replacement device.
         */
        returnTrackingInfo: outputs.databoxedge.TrackingInfoResponse[];
        /**
         * Serial number of the device.
         */
        serialNumber: string;
        /**
         * The shipping address.
         */
        shippingAddress: outputs.databoxedge.AddressResponse;
    }

    /**
     * Represents a single status change.
     */
    export interface OrderStatusResponse {
        /**
         * Dictionary to hold generic information which is not stored
         * by the already existing properties
         */
        additionalOrderDetails: {[key: string]: string};
        /**
         * Comments related to this status change.
         */
        comments?: string;
        /**
         * Status of the order as per the allowed status types.
         */
        status: string;
        /**
         * Time of status update.
         */
        updateDateTime: string;
    }

    /**
     * Fields for tracking refresh job on the share or container.
     */
    export interface RefreshDetailsResponse {
        /**
         * Indicates the relative path of the error xml for the last refresh job on this particular share or container, if any. This could be a failed job or a successful job.
         */
        errorManifestFile?: string;
        /**
         * If a refresh job is currently in progress on this share or container, this field indicates the ARM resource ID of that job. The field is empty if no job is in progress.
         */
        inProgressRefreshJobId?: string;
        /**
         * Indicates the completed time for the last refresh job on this particular share or container, if any.This could be a failed job or a successful job.
         */
        lastCompletedRefreshJobTimeInUTC?: string;
        /**
         * Indicates the id of the last refresh job on this particular share or container,if any. This could be a failed job or a successful job.
         */
        lastJob?: string;
    }

    /**
     * Specifies the mapping between this particular user and the type of access he has on shares on this device.
     */
    export interface ShareAccessRightResponse {
        /**
         * Type of access to be allowed on the share for this user.
         */
        accessType: string;
        /**
         * The share ID.
         */
        shareId: string;
    }

    /**
     * The share properties.
     */
    export interface SharePropertiesResponse {
        /**
         * Access protocol to be used by the share.
         */
        accessProtocol: string;
        /**
         * Azure container mapping for the share.
         */
        azureContainerInfo?: outputs.databoxedge.AzureContainerInfoResponse;
        /**
         * List of IP addresses and corresponding access rights on the share(required for NFS protocol).
         */
        clientAccessRights?: outputs.databoxedge.ClientAccessRightResponse[];
        /**
         * Data policy of the share.
         */
        dataPolicy?: string;
        /**
         * Description for the share.
         */
        description?: string;
        /**
         * Current monitoring status of the share.
         */
        monitoringStatus: string;
        /**
         * Details of the refresh job on this share.
         */
        refreshDetails?: outputs.databoxedge.RefreshDetailsResponse;
        /**
         * Share mount point to the role.
         */
        shareMappings: outputs.databoxedge.MountPointMapResponse[];
        /**
         * Current status of the share.
         */
        shareStatus: string;
        /**
         * Mapping of users and corresponding access rights on the share (required for SMB protocol).
         */
        userAccessRights?: outputs.databoxedge.UserAccessRightResponse[];
    }

    /**
     * The SKU type.
     */
    export interface SkuResponse {
        /**
         * SKU name.
         */
        name?: string;
        /**
         * The SKU tier. This is based on the SKU name.
         */
        tier?: string;
    }

    /**
     * The storage account credential properties.
     */
    export interface StorageAccountCredentialPropertiesResponse {
        /**
         * Encrypted storage key.
         */
        accountKey?: outputs.databoxedge.AsymmetricEncryptedSecretResponse;
        /**
         * Type of storage accessed on the storage account.
         */
        accountType: string;
        /**
         * Alias for the storage account.
         */
        alias: string;
        /**
         * Blob end point for private clouds.
         */
        blobDomainName?: string;
        /**
         * Connection string for the storage account. Use this string if username and account key are not specified.
         */
        connectionString?: string;
        /**
         * Signifies whether SSL needs to be enabled or not.
         */
        sslStatus: string;
        /**
         * Id of the storage account.
         */
        storageAccountId?: string;
        /**
         * Username for the storage account.
         */
        userName?: string;
    }

    /**
     * The storage account properties.
     */
    export interface StorageAccountPropertiesResponse {
        /**
         * BlobEndpoint of Storage Account
         */
        blobEndpoint: string;
        /**
         * The Container Count. Present only for Storage Accounts with DataPolicy set to Cloud.
         */
        containerCount: number;
        /**
         * Data policy of the storage Account.
         */
        dataPolicy?: string;
        /**
         * Description for the storage Account.
         */
        description?: string;
        /**
         * Storage Account Credential Id
         */
        storageAccountCredentialId?: string;
        /**
         * Current status of the storage account
         */
        storageAccountStatus?: string;
    }

    /**
     * Tracking courier information.
     */
    export interface TrackingInfoResponse {
        /**
         * Name of the carrier used in the delivery.
         */
        carrierName?: string;
        /**
         * Serial number of the device being tracked.
         */
        serialNumber?: string;
        /**
         * Tracking ID of the shipment.
         */
        trackingId?: string;
        /**
         * Tracking URL of the shipment.
         */
        trackingUrl?: string;
    }

    /**
     * The mapping between a particular user and the access type on the SMB share.
     */
    export interface UserAccessRightResponse {
        /**
         * Type of access to be allowed for the user.
         */
        accessType: string;
        /**
         * User ID (already existing in the device).
         */
        userId: string;
    }

    /**
     * The user properties.
     */
    export interface UserPropertiesResponse {
        /**
         * The password details.
         */
        encryptedPassword?: outputs.databoxedge.AsymmetricEncryptedSecretResponse;
        /**
         * List of shares that the user has rights on. This field should not be specified during user creation.
         */
        shareAccessRights?: outputs.databoxedge.ShareAccessRightResponse[];
        /**
         * Type of the user.
         */
        userType: string;
    }
}

export namespace databricks {
    /**
     * AddressSpace contains an array of IP address ranges that can be used by subnets of the virtual network.
     */
    export interface AddressSpaceResponse {
        /**
         * A list of address blocks reserved for this virtual network in CIDR notation.
         */
        addressPrefixes?: string[];
    }

    /**
     * Provides details of the entity that created/updated the workspace.
     */
    export interface CreatedByResponse {
        /**
         * The application ID of the application that initiated the creation of the workspace. For example, Azure Portal.
         */
        applicationId: string;
        /**
         * The Object ID that created the workspace.
         */
        oid: string;
        /**
         * The Personal Object ID corresponding to the object ID above
         */
        puid: string;
    }

    /**
     * The object that contains details of encryption used on the workspace.
     */
    export interface EncryptionResponse {
        /**
         * The name of KeyVault key.
         */
        KeyName?: string;
        /**
         * The encryption keySource (provider). Possible values (case-insensitive):  Default, Microsoft.Keyvault
         */
        keySource?: string;
        /**
         * The Uri of KeyVault.
         */
        keyvaulturi?: string;
        /**
         * The version of KeyVault key.
         */
        keyversion?: string;
    }

    /**
     * The Managed Identity details for storage account.
     */
    export interface ManagedIdentityConfigurationResponse {
        /**
         * The objectId of the Managed Identity that is linked to the Managed Storage account.
         */
        principalId: string;
        /**
         * The tenant Id where the Managed Identity is created.
         */
        tenantId: string;
        /**
         * The type of Identity created. It can be either SystemAssigned or UserAssigned.
         */
        type: string;
    }

    /**
     * SKU for the resource.
     */
    export interface SkuResponse {
        /**
         * The SKU name.
         */
        name: string;
        /**
         * The SKU tier.
         */
        tier?: string;
    }

    /**
     * Properties of the virtual network peering.
     */
    export interface VirtualNetworkPeeringPropertiesFormatResponse {
        /**
         * Whether the forwarded traffic from the VMs in the local virtual network will be allowed/disallowed in remote virtual network.
         */
        allowForwardedTraffic?: boolean;
        /**
         * If gateway links can be used in remote virtual networking to link to this virtual network.
         */
        allowGatewayTransit?: boolean;
        /**
         * Whether the VMs in the local virtual network space would be able to access the VMs in remote virtual network space.
         */
        allowVirtualNetworkAccess?: boolean;
        /**
         * The reference to the databricks virtual network address space.
         */
        databricksAddressSpace?: outputs.databricks.AddressSpaceResponse;
        /**
         *  The remote virtual network should be in the same region. See here to learn more (https://docs.microsoft.com/en-us/azure/databricks/administration-guide/cloud-configurations/azure/vnet-peering).
         */
        databricksVirtualNetwork?: outputs.databricks.VirtualNetworkPeeringPropertiesFormatResponseProperties;
        /**
         * The status of the virtual network peering.
         */
        peeringState: string;
        /**
         * The provisioning state of the virtual network peering resource.
         */
        provisioningState: string;
        /**
         * The reference to the remote virtual network address space.
         */
        remoteAddressSpace?: outputs.databricks.AddressSpaceResponse;
        /**
         *  The remote virtual network should be in the same region. See here to learn more (https://docs.microsoft.com/en-us/azure/databricks/administration-guide/cloud-configurations/azure/vnet-peering).
         */
        remoteVirtualNetwork: outputs.databricks.VirtualNetworkPeeringPropertiesFormatResponseProperties;
        /**
         * If remote gateways can be used on this virtual network. If the flag is set to true, and allowGatewayTransit on remote peering is also true, virtual network will use gateways of remote virtual network for transit. Only one peering can have this flag set to true. This flag cannot be set if virtual network already has a gateway.
         */
        useRemoteGateways?: boolean;
    }

    /**
     *  The remote virtual network should be in the same region. See here to learn more (https://docs.microsoft.com/en-us/azure/databricks/administration-guide/cloud-configurations/azure/vnet-peering).
     */
    export interface VirtualNetworkPeeringPropertiesFormatResponseProperties {
        /**
         * The Id of the databricks virtual network.
         */
        id?: string;
    }

    /**
     * The value which should be used for this field.
     */
    export interface WorkspaceCustomBooleanParameterResponse {
        /**
         * The type of variable that this is
         */
        type?: string;
        /**
         * The value which should be used for this field.
         */
        value: boolean;
    }

    /**
     * Custom Parameters used for Cluster Creation.
     */
    export interface WorkspaceCustomParametersResponse {
        /**
         * The name of the Private Subnet within the Virtual Network
         */
        customPrivateSubnetName?: outputs.databricks.WorkspaceCustomStringParameterResponse;
        /**
         * The name of a Public Subnet within the Virtual Network
         */
        customPublicSubnetName?: outputs.databricks.WorkspaceCustomStringParameterResponse;
        /**
         * The ID of a Virtual Network where this Databricks Cluster should be created
         */
        customVirtualNetworkId?: outputs.databricks.WorkspaceCustomStringParameterResponse;
        /**
         * Should the Public IP be Disabled?
         */
        enableNoPublicIp?: outputs.databricks.WorkspaceCustomBooleanParameterResponse;
        /**
         * Contains the encryption details for Customer-Managed Key (CMK) enabled workspace.
         */
        encryption?: outputs.databricks.WorkspaceEncryptionParameterResponse;
        /**
         * Prepare the workspace for encryption. Enables the Managed Identity for managed storage account.
         */
        prepareEncryption?: outputs.databricks.WorkspaceCustomBooleanParameterResponse;
    }

    /**
     * The Value.
     */
    export interface WorkspaceCustomStringParameterResponse {
        /**
         * The type of variable that this is
         */
        type?: string;
        /**
         * The value which should be used for this field.
         */
        value: string;
    }

    /**
     * The object that contains details of encryption used on the workspace.
     */
    export interface WorkspaceEncryptionParameterResponse {
        /**
         * The type of variable that this is
         */
        type?: string;
        /**
         * The value which should be used for this field.
         */
        value?: outputs.databricks.EncryptionResponse;
    }

    /**
     * The workspace properties.
     */
    export interface WorkspacePropertiesResponse {
        /**
         * The workspace provider authorizations.
         */
        authorizations?: outputs.databricks.WorkspaceProviderAuthorizationResponse[];
        /**
         * Indicates the Object ID, PUID and Application ID of entity that created the workspace.
         */
        createdBy?: outputs.databricks.CreatedByResponse;
        /**
         * Specifies the date and time when the workspace is created.
         */
        createdDateTime?: string;
        /**
         * The managed resource group Id.
         */
        managedResourceGroupId: string;
        /**
         * The workspace's custom parameters.
         */
        parameters?: outputs.databricks.WorkspaceCustomParametersResponse;
        /**
         * The workspace provisioning state.
         */
        provisioningState: string;
        /**
         * The details of Managed Identity of Storage Account
         */
        storageAccountIdentity?: outputs.databricks.ManagedIdentityConfigurationResponse;
        /**
         * The blob URI where the UI definition file is located.
         */
        uiDefinitionUri?: string;
        /**
         * Indicates the Object ID, PUID and Application ID of entity that last updated the workspace.
         */
        updatedBy?: outputs.databricks.CreatedByResponse;
        /**
         * The unique identifier of the databricks workspace in databricks control plane.
         */
        workspaceId: string;
        /**
         * The workspace URL which is of the format 'adb-{workspaceId}.{random}.azuredatabricks.net'
         */
        workspaceUrl: string;
    }

    /**
     * The workspace provider authorization.
     */
    export interface WorkspaceProviderAuthorizationResponse {
        /**
         * The provider's principal identifier. This is the identity that the provider will use to call ARM to manage the workspace resources.
         */
        principalId: string;
        /**
         * The provider's role definition identifier. This role will define all the permissions that the provider must have on the workspace's container resource group. This role definition cannot have permission to delete the resource group.
         */
        roleDefinitionId: string;
    }

}

export namespace datacatalog {
    /**
     * Properties of the data catalog.
     */
    export interface ADCCatalogPropertiesResponse {
        /**
         * Azure data catalog admin list.
         */
        admins?: outputs.datacatalog.PrincipalsResponse[];
        /**
         * Automatic unit adjustment enabled or not.
         */
        enableAutomaticUnitAdjustment?: boolean;
        /**
         * Azure data catalog SKU.
         */
        sku?: string;
        /**
         * Azure data catalog provision status.
         */
        successfullyProvisioned?: boolean;
        /**
         * Azure data catalog units.
         */
        units?: number;
        /**
         * Azure data catalog user list.
         */
        users?: outputs.datacatalog.PrincipalsResponse[];
    }

    /**
     * User principals.
     */
    export interface PrincipalsResponse {
        /**
         * Object Id for the user
         */
        objectId?: string;
        /**
         * UPN of the user.
         */
        upn?: string;
    }
}

export namespace datafactory {
    /**
     * Activity dependency information.
     */
    export interface ActivityDependencyResponse {
        /**
         * Activity name.
         */
        activity: string;
        /**
         * Match-Condition for the dependency.
         */
        dependencyConditions: string[];
    }

    /**
     * A pipeline activity.
     */
    export interface ActivityResponse {
        /**
         * Activity depends on condition.
         */
        dependsOn?: outputs.datafactory.ActivityDependencyResponse[];
        /**
         * Activity description.
         */
        description?: string;
        /**
         * Activity name.
         */
        name: string;
        /**
         * Type of activity.
         */
        type: string;
        /**
         * Activity user properties.
         */
        userProperties?: outputs.datafactory.UserPropertyResponse[];
    }

    /**
     * Azure Data Factory nested object which contains a flow with data movements and transformations.
     */
    export interface DataFlowResponse {
        /**
         * List of tags that can be used for describing the data flow.
         */
        annotations?: {[key: string]: string}[];
        /**
         * The description of the data flow.
         */
        description?: string;
        /**
         * The folder that this data flow is in. If not specified, Data flow will appear at the root level.
         */
        folder?: outputs.datafactory.DataFlowResponseProperties;
        /**
         * Type of data flow.
         */
        type?: string;
    }

    /**
     * The folder that this data flow is in. If not specified, Data flow will appear at the root level.
     */
    export interface DataFlowResponseProperties {
        /**
         * The name of the folder that this data flow is in.
         */
        name?: string;
    }

    /**
     * The Azure Data Factory nested object which identifies data within different data stores, such as tables, files, folders, and documents.
     */
    export interface DatasetResponse {
        /**
         * List of tags that can be used for describing the Dataset.
         */
        annotations?: {[key: string]: string}[];
        /**
         * Dataset description.
         */
        description?: string;
        /**
         * The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
         */
        folder?: outputs.datafactory.DatasetResponseProperties;
        /**
         * Linked service reference.
         */
        linkedServiceName: outputs.datafactory.LinkedServiceReferenceResponse;
        /**
         * Parameters for dataset.
         */
        parameters?: outputs.datafactory.ParameterDefinitionSpecificationResponse;
        /**
         * Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
         */
        schema?: {[key: string]: string};
        /**
         * Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
         */
        structure?: {[key: string]: string};
        /**
         * Type of dataset.
         */
        type: string;
    }

    /**
     * The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
     */
    export interface DatasetResponseProperties {
        /**
         * The name of the folder that this Dataset is in.
         */
        name?: string;
    }

    /**
     * Identity properties of the factory resource.
     */
    export interface FactoryIdentityResponse {
        /**
         * The principal id of the identity.
         */
        principalId: string;
        /**
         * The client tenant id of the identity.
         */
        tenantId: string;
        /**
         * The identity type. Currently the only supported type is 'SystemAssigned'.
         */
        type: string;
    }

    /**
     * Factory resource properties.
     */
    export interface FactoryPropertiesResponse {
        /**
         * Time the factory was created in ISO8601 format.
         */
        createTime: string;
        /**
         * List of parameters for factory.
         */
        globalParameters?: outputs.datafactory.GlobalParameterDefinitionSpecificationResponse;
        /**
         * Factory provisioning state, example Succeeded.
         */
        provisioningState: string;
        /**
         * Git repo information of the factory.
         */
        repoConfiguration?: outputs.datafactory.FactoryRepoConfigurationResponse;
        /**
         * Version of the factory.
         */
        version: string;
    }

    /**
     * Factory's git repo information.
     */
    export interface FactoryRepoConfigurationResponse {
        /**
         * Account name.
         */
        accountName: string;
        /**
         * Collaboration branch.
         */
        collaborationBranch: string;
        /**
         * Last commit id.
         */
        lastCommitId?: string;
        /**
         * Repository name.
         */
        repositoryName: string;
        /**
         * Root folder.
         */
        rootFolder: string;
        /**
         * Type of repo configuration.
         */
        type: string;
    }

    /**
     * Definition of all parameters for an entity.
     */
    export interface GlobalParameterDefinitionSpecificationResponse {
    }

    /**
     * Integration runtime reference type.
     */
    export interface IntegrationRuntimeReferenceResponse {
        /**
         * Arguments for integration runtime.
         */
        parameters?: outputs.datafactory.ParameterValueSpecificationResponse;
        /**
         * Reference integration runtime name.
         */
        referenceName: string;
        /**
         * Type of integration runtime.
         */
        type: string;
    }

    /**
     * Azure Data Factory nested object which serves as a compute resource for activities.
     */
    export interface IntegrationRuntimeResponse {
        /**
         * Integration runtime description.
         */
        description?: string;
        /**
         * Type of integration runtime.
         */
        type: string;
    }

    /**
     * Linked service reference type.
     */
    export interface LinkedServiceReferenceResponse {
        /**
         * Arguments for LinkedService.
         */
        parameters?: outputs.datafactory.ParameterValueSpecificationResponse;
        /**
         * Reference LinkedService name.
         */
        referenceName: string;
        /**
         * Linked service reference type.
         */
        type: string;
    }

    /**
     * The Azure Data Factory nested object which contains the information and credential which can be used to connect with related store or compute resource.
     */
    export interface LinkedServiceResponse {
        /**
         * List of tags that can be used for describing the linked service.
         */
        annotations?: {[key: string]: string}[];
        /**
         * The integration runtime reference.
         */
        connectVia?: outputs.datafactory.IntegrationRuntimeReferenceResponse;
        /**
         * Linked service description.
         */
        description?: string;
        /**
         * Parameters for linked service.
         */
        parameters?: outputs.datafactory.ParameterDefinitionSpecificationResponse;
        /**
         * Type of linked service.
         */
        type: string;
    }

    /**
     * Definition of all parameters for an entity.
     */
    export interface ParameterDefinitionSpecificationResponse {
    }

    /**
     * An object mapping parameter names to argument values.
     */
    export interface ParameterValueSpecificationResponse {
    }

    /**
     * A data factory pipeline.
     */
    export interface PipelineResponse {
        /**
         * List of activities in pipeline.
         */
        activities?: outputs.datafactory.ActivityResponse[];
        /**
         * List of tags that can be used for describing the Pipeline.
         */
        annotations?: {[key: string]: string}[];
        /**
         * The max number of concurrent runs for the pipeline.
         */
        concurrency?: number;
        /**
         * The description of the pipeline.
         */
        description?: string;
        /**
         * The folder that this Pipeline is in. If not specified, Pipeline will appear at the root level.
         */
        folder?: outputs.datafactory.PipelineResponseProperties;
        /**
         * List of parameters for pipeline.
         */
        parameters?: outputs.datafactory.ParameterDefinitionSpecificationResponse;
        /**
         * Dimensions emitted by Pipeline.
         */
        runDimensions?: {[key: string]: string};
        /**
         * List of variables for pipeline.
         */
        variables?: outputs.datafactory.VariableDefinitionSpecificationResponse;
    }

    /**
     * The folder that this Pipeline is in. If not specified, Pipeline will appear at the root level.
     */
    export interface PipelineResponseProperties {
        /**
         * The name of the folder that this Pipeline is in.
         */
        name?: string;
    }

    /**
     * Azure data factory nested object which contains information about creating pipeline run
     */
    export interface TriggerResponse {
        /**
         * List of tags that can be used for describing the trigger.
         */
        annotations?: {[key: string]: string}[];
        /**
         * Trigger description.
         */
        description?: string;
        /**
         * Indicates if trigger is running or not. Updated when Start/Stop APIs are called on the Trigger.
         */
        runtimeState: string;
        /**
         * Trigger type.
         */
        type: string;
    }

    /**
     * User property.
     */
    export interface UserPropertyResponse {
        /**
         * User property name.
         */
        name: string;
        /**
         * User property value. Type: string (or Expression with resultType string).
         */
        value: {[key: string]: string};
    }

    /**
     * Definition of variable for a Pipeline.
     */
    export interface VariableDefinitionSpecificationResponse {
    }
}

export namespace datalakeanalytics {
    /**
     * The compute policy properties.
     */
    export interface ComputePolicyPropertiesResponse {
        /**
         * The maximum degree of parallelism per job this user can use to submit jobs.
         */
        maxDegreeOfParallelismPerJob: number;
        /**
         * The minimum priority per job this user can use to submit jobs.
         */
        minPriorityPerJob: number;
        /**
         * The AAD object identifier for the entity to create a policy for.
         */
        objectId: string;
        /**
         * The type of AAD object the object identifier refers to.
         */
        objectType: string;
    }

    /**
     * Data Lake Analytics compute policy information.
     */
    export interface ComputePolicyResponse {
        /**
         * The resource identifier.
         */
        id: string;
        /**
         * The resource name.
         */
        name: string;
        /**
         * The compute policy properties.
         */
        properties: outputs.datalakeanalytics.ComputePolicyPropertiesResponse;
        /**
         * The resource type.
         */
        type: string;
    }

    /**
     * The account specific properties that are associated with an underlying Data Lake Analytics account. Returned only when retrieving a specific account.
     */
    export interface DataLakeAnalyticsAccountPropertiesResponse {
        /**
         * The unique identifier associated with this Data Lake Analytics account.
         */
        accountId: string;
        /**
         * The list of compute policies associated with this account.
         */
        computePolicies: outputs.datalakeanalytics.ComputePolicyResponse[];
        /**
         * The account creation time.
         */
        creationTime: string;
        /**
         * The commitment tier in use for the current month.
         */
        currentTier: string;
        /**
         * The list of Data Lake Store accounts associated with this account.
         */
        dataLakeStoreAccounts: outputs.datalakeanalytics.DataLakeStoreAccountInformationResponse[];
        /**
         * The default Data Lake Store account associated with this account.
         */
        defaultDataLakeStoreAccount: string;
        /**
         * The full CName endpoint for this account.
         */
        endpoint: string;
        /**
         * The current state of allowing or disallowing IPs originating within Azure through the firewall. If the firewall is disabled, this is not enforced.
         */
        firewallAllowAzureIps: string;
        /**
         * The list of firewall rules associated with this account.
         */
        firewallRules: outputs.datalakeanalytics.FirewallRuleResponse[];
        /**
         * The current state of the IP address firewall for this account.
         */
        firewallState: string;
        /**
         * The account last modified time.
         */
        lastModifiedTime: string;
        /**
         * The maximum supported degree of parallelism for this account.
         */
        maxDegreeOfParallelism: number;
        /**
         * The maximum supported degree of parallelism per job for this account.
         */
        maxDegreeOfParallelismPerJob: number;
        /**
         * The maximum supported jobs running under the account at the same time.
         */
        maxJobCount: number;
        /**
         * The minimum supported priority per job for this account.
         */
        minPriorityPerJob: number;
        /**
         * The commitment tier for the next month.
         */
        newTier: string;
        /**
         * The provisioning status of the Data Lake Analytics account.
         */
        provisioningState: string;
        /**
         * The number of days that job metadata is retained.
         */
        queryStoreRetention: number;
        /**
         * The state of the Data Lake Analytics account.
         */
        state: string;
        /**
         * The list of Azure Blob Storage accounts associated with this account.
         */
        storageAccounts: outputs.datalakeanalytics.StorageAccountInformationResponse[];
        /**
         * The system defined maximum supported degree of parallelism for this account, which restricts the maximum value of parallelism the user can set for the account.
         */
        systemMaxDegreeOfParallelism: number;
        /**
         * The system defined maximum supported jobs running under the account at the same time, which restricts the maximum number of running jobs the user can set for the account.
         */
        systemMaxJobCount: number;
    }

    /**
     * The Data Lake Store account properties.
     */
    export interface DataLakeStoreAccountInformationPropertiesResponse {
        /**
         * The optional suffix for the Data Lake Store account.
         */
        suffix: string;
    }

    /**
     * Data Lake Store account information.
     */
    export interface DataLakeStoreAccountInformationResponse {
        /**
         * The resource identifier.
         */
        id: string;
        /**
         * The resource name.
         */
        name: string;
        /**
         * The Data Lake Store account properties.
         */
        properties: outputs.datalakeanalytics.DataLakeStoreAccountInformationPropertiesResponse;
        /**
         * The resource type.
         */
        type: string;
    }

    /**
     * The firewall rule properties.
     */
    export interface FirewallRulePropertiesResponse {
        /**
         * The end IP address for the firewall rule. This can be either ipv4 or ipv6. Start and End should be in the same protocol.
         */
        endIpAddress: string;
        /**
         * The start IP address for the firewall rule. This can be either ipv4 or ipv6. Start and End should be in the same protocol.
         */
        startIpAddress: string;
    }

    /**
     * Data Lake Analytics firewall rule information.
     */
    export interface FirewallRuleResponse {
        /**
         * The resource identifier.
         */
        id: string;
        /**
         * The resource name.
         */
        name: string;
        /**
         * The firewall rule properties.
         */
        properties: outputs.datalakeanalytics.FirewallRulePropertiesResponse;
        /**
         * The resource type.
         */
        type: string;
    }

    /**
     * SAS token information.
     */
    export interface SasTokenInformationResponse {
        /**
         * The access token for the associated Azure Storage Container.
         */
        accessToken: string;
    }

    /**
     * The Azure Storage account properties.
     */
    export interface StorageAccountInformationPropertiesResponse {
        /**
         * The optional suffix for the storage account.
         */
        suffix: string;
    }

    /**
     * Azure Storage account information.
     */
    export interface StorageAccountInformationResponse {
        /**
         * The resource identifier.
         */
        id: string;
        /**
         * The resource name.
         */
        name: string;
        /**
         * The Azure Storage account properties.
         */
        properties: outputs.datalakeanalytics.StorageAccountInformationPropertiesResponse;
        /**
         * The resource type.
         */
        type: string;
    }
}

export namespace datalakestore {
    /**
     * Data Lake Store account properties information.
     */
    export interface DataLakeStoreAccountPropertiesResponse {
        /**
         * The unique identifier associated with this Data Lake Store account.
         */
        accountId: string;
        /**
         * The account creation time.
         */
        creationTime: string;
        /**
         * The commitment tier in use for the current month.
         */
        currentTier: string;
        /**
         * The default owner group for all new folders and files created in the Data Lake Store account.
         */
        defaultGroup: string;
        /**
         * The Key Vault encryption configuration.
         */
        encryptionConfig: outputs.datalakestore.EncryptionConfigResponse;
        /**
         * The current state of encryption provisioning for this Data Lake Store account.
         */
        encryptionProvisioningState: string;
        /**
         * The current state of encryption for this Data Lake Store account.
         */
        encryptionState: string;
        /**
         * The full CName endpoint for this account.
         */
        endpoint: string;
        /**
         * The current state of allowing or disallowing IPs originating within Azure through the firewall. If the firewall is disabled, this is not enforced.
         */
        firewallAllowAzureIps: string;
        /**
         * The list of firewall rules associated with this Data Lake Store account.
         */
        firewallRules: outputs.datalakestore.FirewallRuleResponse[];
        /**
         * The current state of the IP address firewall for this Data Lake Store account.
         */
        firewallState: string;
        /**
         * The account last modified time.
         */
        lastModifiedTime: string;
        /**
         * The commitment tier to use for next month.
         */
        newTier: string;
        /**
         * The provisioning status of the Data Lake Store account.
         */
        provisioningState: string;
        /**
         * The state of the Data Lake Store account.
         */
        state: string;
        /**
         * The current state of the trusted identity provider feature for this Data Lake Store account.
         */
        trustedIdProviderState: string;
        /**
         * The list of trusted identity providers associated with this Data Lake Store account.
         */
        trustedIdProviders: outputs.datalakestore.TrustedIdProviderResponse[];
        /**
         * The list of virtual network rules associated with this Data Lake Store account.
         */
        virtualNetworkRules: outputs.datalakestore.VirtualNetworkRuleResponse[];
    }

    /**
     * The encryption configuration for the account.
     */
    export interface EncryptionConfigResponse {
        /**
         * The Key Vault information for connecting to user managed encryption keys.
         */
        keyVaultMetaInfo?: outputs.datalakestore.KeyVaultMetaInfoResponse;
        /**
         * The type of encryption configuration being used. Currently the only supported types are 'UserManaged' and 'ServiceManaged'.
         */
        type: string;
    }

    /**
     * The encryption identity properties.
     */
    export interface EncryptionIdentityResponse {
        /**
         * The principal identifier associated with the encryption.
         */
        principalId: string;
        /**
         * The tenant identifier associated with the encryption.
         */
        tenantId: string;
        /**
         * The type of encryption being used. Currently the only supported type is 'SystemAssigned'.
         */
        type: string;
    }

    /**
     * The firewall rule properties.
     */
    export interface FirewallRulePropertiesResponse {
        /**
         * The end IP address for the firewall rule. This can be either ipv4 or ipv6. Start and End should be in the same protocol.
         */
        endIpAddress: string;
        /**
         * The start IP address for the firewall rule. This can be either ipv4 or ipv6. Start and End should be in the same protocol.
         */
        startIpAddress: string;
    }

    /**
     * Data Lake Store firewall rule information.
     */
    export interface FirewallRuleResponse {
        /**
         * The resource identifier.
         */
        id: string;
        /**
         * The resource name.
         */
        name: string;
        /**
         * The firewall rule properties.
         */
        properties: outputs.datalakestore.FirewallRulePropertiesResponse;
        /**
         * The resource type.
         */
        type: string;
    }

    /**
     * Metadata information used by account encryption.
     */
    export interface KeyVaultMetaInfoResponse {
        /**
         * The name of the user managed encryption key.
         */
        encryptionKeyName: string;
        /**
         * The version of the user managed encryption key.
         */
        encryptionKeyVersion: string;
        /**
         * The resource identifier for the user managed Key Vault being used to encrypt.
         */
        keyVaultResourceId: string;
    }

    /**
     * The trusted identity provider properties.
     */
    export interface TrustedIdProviderPropertiesResponse {
        /**
         * The URL of this trusted identity provider.
         */
        idProvider: string;
    }

    /**
     * Data Lake Store trusted identity provider information.
     */
    export interface TrustedIdProviderResponse {
        /**
         * The resource identifier.
         */
        id: string;
        /**
         * The resource name.
         */
        name: string;
        /**
         * The trusted identity provider properties.
         */
        properties: outputs.datalakestore.TrustedIdProviderPropertiesResponse;
        /**
         * The resource type.
         */
        type: string;
    }

    /**
     * The virtual network rule properties.
     */
    export interface VirtualNetworkRulePropertiesResponse {
        /**
         * The resource identifier for the subnet.
         */
        subnetId: string;
    }

    /**
     * Data Lake Store virtual network rule information.
     */
    export interface VirtualNetworkRuleResponse {
        /**
         * The resource identifier.
         */
        id: string;
        /**
         * The resource name.
         */
        name: string;
        /**
         * The virtual network rule properties.
         */
        properties: outputs.datalakestore.VirtualNetworkRulePropertiesResponse;
        /**
         * The resource type.
         */
        type: string;
    }
}

export namespace datamigration {
}

export namespace datashare {
    /**
     * Account property bag.
     */
    export interface AccountPropertiesResponse {
        /**
         * Time at which the account was created.
         */
        createdAt: string;
        /**
         * Provisioning state of the Account
         */
        provisioningState: string;
        /**
         * Email of the user who created the resource
         */
        userEmail: string;
        /**
         * Name of the user who created the resource
         */
        userName: string;
    }

    /**
     * Identity of resource
     */
    export interface IdentityResponse {
        /**
         * service principal Id
         */
        principalId: string;
        /**
         * Tenant Id
         */
        tenantId: string;
        /**
         * Identity Type
         */
        type?: string;
    }

    /**
     * Invitation property bag.
     */
    export interface InvitationPropertiesResponse {
        /**
         * unique invitation id
         */
        invitationId: string;
        /**
         * The status of the invitation.
         */
        invitationStatus: string;
        /**
         * The time the recipient responded to the invitation.
         */
        respondedAt: string;
        /**
         * Gets the time at which the invitation was sent.
         */
        sentAt: string;
        /**
         * The target Azure AD Id. Can't be combined with email.
         */
        targetActiveDirectoryId?: string;
        /**
         * The email the invitation is directed to.
         */
        targetEmail?: string;
        /**
         * The target user or application Id that invitation is being sent to.
         * Must be specified along TargetActiveDirectoryId. This enables sending
         * invitations to specific users or applications in an AD tenant.
         */
        targetObjectId?: string;
        /**
         * Email of the user who created the resource
         */
        userEmail: string;
        /**
         * Name of the user who created the resource
         */
        userName: string;
    }

    /**
     * Share property bag.
     */
    export interface SharePropertiesResponse {
        /**
         * Time at which the share was created.
         */
        createdAt: string;
        /**
         * Share description.
         */
        description?: string;
        /**
         * Gets or sets the provisioning state
         */
        provisioningState: string;
        /**
         * Share kind.
         */
        shareKind?: string;
        /**
         * Share terms.
         */
        terms?: string;
        /**
         * Email of the user who created the resource
         */
        userEmail: string;
        /**
         * Name of the user who created the resource
         */
        userName: string;
    }

    /**
     * Share subscription property bag.
     */
    export interface ShareSubscriptionPropertiesResponse {
        /**
         * Time at which the share subscription was created.
         */
        createdAt: string;
        /**
         * The invitation id.
         */
        invitationId: string;
        /**
         * Email of the provider who created the resource
         */
        providerEmail: string;
        /**
         * Name of the provider who created the resource
         */
        providerName: string;
        /**
         * Tenant name of the provider who created the resource
         */
        providerTenantName: string;
        /**
         * Provisioning state of the share subscription
         */
        provisioningState: string;
        /**
         * Description of share
         */
        shareDescription: string;
        /**
         * Kind of share
         */
        shareKind: string;
        /**
         * Name of the share
         */
        shareName: string;
        /**
         * Gets the current status of share subscription.
         */
        shareSubscriptionStatus: string;
        /**
         * Terms of a share
         */
        shareTerms: string;
        /**
         * Source share location.
         */
        sourceShareLocation: string;
        /**
         * Email of the user who created the resource
         */
        userEmail: string;
        /**
         * Name of the user who created the resource
         */
        userName: string;
    }

    /**
     * A ShareSubscriptionSynchronization data transfer object.
     */
    export interface ShareSubscriptionSynchronizationResponse {
        /**
         * Synchronization duration
         */
        durationMs: number;
        /**
         * End time of synchronization
         */
        endTime: string;
        /**
         * message of Synchronization
         */
        message: string;
        /**
         * start time of synchronization
         */
        startTime: string;
        /**
         * Raw Status
         */
        status: string;
        /**
         * Synchronization id
         */
        synchronizationId: string;
        /**
         * Synchronization Mode
         */
        synchronizationMode: string;
    }

    /**
     * A ShareSynchronization data transfer object.
     */
    export interface ShareSynchronizationResponse {
        /**
         * Email of the user who created the synchronization
         */
        consumerEmail?: string;
        /**
         * Name of the user who created the synchronization
         */
        consumerName?: string;
        /**
         * Tenant name of the consumer who created the synchronization
         */
        consumerTenantName?: string;
        /**
         * synchronization duration
         */
        durationMs?: number;
        /**
         * End time of synchronization
         */
        endTime?: string;
        /**
         * message of synchronization
         */
        message?: string;
        /**
         * start time of synchronization
         */
        startTime?: string;
        /**
         * Raw Status
         */
        status?: string;
        /**
         * Synchronization id
         */
        synchronizationId?: string;
        /**
         * Synchronization mode
         */
        synchronizationMode: string;
    }

    /**
     * A view of synchronization setting added by the provider
     */
    export interface SourceShareSynchronizationSettingResponse {
        /**
         * Kind of synchronization
         */
        kind: string;
    }

    /**
     * Synchronization details at data set level
     */
    export interface SynchronizationDetailsResponse {
        /**
         * Id of data set
         */
        dataSetId: string;
        /**
         * Type of the data set
         */
        dataSetType: string;
        /**
         * Duration of data set level copy
         */
        durationMs: number;
        /**
         * End time of data set level copy
         */
        endTime: string;
        /**
         * The number of files read from the source data set
         */
        filesRead: number;
        /**
         * The number of files written into the sink data set
         */
        filesWritten: number;
        /**
         * Error message if any
         */
        message: string;
        /**
         * Name of the data set
         */
        name: string;
        /**
         * The number of files copied into the sink data set
         */
        rowsCopied: number;
        /**
         * The number of rows read from the source data set.
         */
        rowsRead: number;
        /**
         * The size of the data read from the source data set in bytes
         */
        sizeRead: number;
        /**
         * The size of the data written into the sink data set in bytes
         */
        sizeWritten: number;
        /**
         * Start time of data set level copy
         */
        startTime: string;
        /**
         * Raw Status
         */
        status: string;
        /**
         * The vCore units consumed for the data set synchronization
         */
        vCore: number;
    }
}

export namespace dbformariadb {
    /**
     * The properties of a database.
     */
    export interface DatabasePropertiesResponse {
        /**
         * The charset of the database.
         */
        charset?: string;
        /**
         * The collation of the database.
         */
        collation?: string;
    }

    /**
     * The properties of a server firewall rule.
     */
    export interface FirewallRulePropertiesResponse {
        /**
         * The end IP address of the server firewall rule. Must be IPv4 format.
         */
        endIpAddress: string;
        /**
         * The start IP address of the server firewall rule. Must be IPv4 format.
         */
        startIpAddress: string;
    }

    /**
     * Properties of a private endpoint connection.
     */
    export interface PrivateEndpointConnectionPropertiesResponse {
        /**
         * Private endpoint which the connection belongs to.
         */
        privateEndpoint?: outputs.dbformariadb.PrivateEndpointPropertyResponse;
        /**
         * Connection state of the private endpoint connection.
         */
        privateLinkServiceConnectionState?: outputs.dbformariadb.PrivateLinkServiceConnectionStatePropertyResponse;
        /**
         * State of the private endpoint connection.
         */
        provisioningState: string;
    }

    export interface PrivateEndpointPropertyResponse {
        /**
         * Resource id of the private endpoint.
         */
        id?: string;
    }

    export interface PrivateLinkServiceConnectionStatePropertyResponse {
        /**
         * The actions required for private link service connection.
         */
        actionsRequired: string;
        /**
         * The private link service connection description.
         */
        description: string;
        /**
         * The private link service connection status.
         */
        status: string;
    }

    /**
     * Properties of a private endpoint connection.
     */
    export interface ServerPrivateEndpointConnectionPropertiesResponse {
        /**
         * Private endpoint which the connection belongs to.
         */
        privateEndpoint?: outputs.dbformariadb.PrivateEndpointPropertyResponse;
        /**
         * Connection state of the private endpoint connection.
         */
        privateLinkServiceConnectionState?: outputs.dbformariadb.ServerPrivateLinkServiceConnectionStatePropertyResponse;
        /**
         * State of the private endpoint connection.
         */
        provisioningState: string;
    }

    /**
     * A private endpoint connection under a server
     */
    export interface ServerPrivateEndpointConnectionResponse {
        /**
         * Resource Id of the private endpoint connection.
         */
        id: string;
        /**
         * Private endpoint connection properties
         */
        properties: outputs.dbformariadb.ServerPrivateEndpointConnectionPropertiesResponse;
    }

    export interface ServerPrivateLinkServiceConnectionStatePropertyResponse {
        /**
         * The actions required for private link service connection.
         */
        actionsRequired: string;
        /**
         * The private link service connection description.
         */
        description: string;
        /**
         * The private link service connection status.
         */
        status: string;
    }

    /**
     * The properties of a server.
     */
    export interface ServerPropertiesResponse {
        /**
         * The administrator's login name of a server. Can only be specified when the server is being created (and is required for creation).
         */
        administratorLogin?: string;
        /**
         * Earliest restore point creation time (ISO8601 format)
         */
        earliestRestoreDate?: string;
        /**
         * The fully qualified domain name of a server.
         */
        fullyQualifiedDomainName?: string;
        /**
         * The master server id of a replica server.
         */
        masterServerId?: string;
        /**
         * List of private endpoint connections on a server
         */
        privateEndpointConnections: outputs.dbformariadb.ServerPrivateEndpointConnectionResponse[];
        /**
         * Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
         */
        publicNetworkAccess?: string;
        /**
         * The maximum number of replicas that a master server can have.
         */
        replicaCapacity?: number;
        /**
         * The replication role of the server.
         */
        replicationRole?: string;
        /**
         * Enable ssl enforcement or not when connect to server.
         */
        sslEnforcement?: string;
        /**
         * Storage profile of a server.
         */
        storageProfile?: outputs.dbformariadb.StorageProfileResponse;
        /**
         * A state of a server that is visible to user.
         */
        userVisibleState?: string;
        /**
         * Server version.
         */
        version?: string;
    }

    /**
     * Billing information related properties of a server.
     */
    export interface SkuResponse {
        /**
         * The scale up/out capacity, representing server's compute units.
         */
        capacity?: number;
        /**
         * The family of hardware.
         */
        family?: string;
        /**
         * The name of the sku, typically, tier + family + cores, e.g. B_Gen4_1, GP_Gen5_8.
         */
        name?: string;
        /**
         * The size code, to be interpreted by resource as appropriate.
         */
        size?: string;
        /**
         * The tier of the particular SKU, e.g. Basic.
         */
        tier?: string;
    }

    /**
     * Storage Profile properties of a server
     */
    export interface StorageProfileResponse {
        /**
         * Backup retention days for the server.
         */
        backupRetentionDays?: number;
        /**
         * Enable Geo-redundant or not for server backup.
         */
        geoRedundantBackup?: string;
        /**
         * Enable Storage Auto Grow.
         */
        storageAutogrow?: string;
        /**
         * Max storage allowed for a server.
         */
        storageMB?: number;
    }

    /**
     * Properties of a virtual network rule.
     */
    export interface VirtualNetworkRulePropertiesResponse {
        /**
         * Create firewall rule before the virtual network has vnet service endpoint enabled.
         */
        ignoreMissingVnetServiceEndpoint?: boolean;
        /**
         * Virtual Network Rule State
         */
        state: string;
        /**
         * The ARM resource id of the virtual network subnet.
         */
        virtualNetworkSubnetId: string;
    }
}

export namespace dbformysql {
    /**
     * The properties of a database.
     */
    export interface DatabasePropertiesResponse {
        /**
         * The charset of the database.
         */
        charset?: string;
        /**
         * The collation of the database.
         */
        collation?: string;
    }

    /**
     * The properties of a server firewall rule.
     */
    export interface FirewallRulePropertiesResponse {
        /**
         * The end IP address of the server firewall rule. Must be IPv4 format.
         */
        endIpAddress: string;
        /**
         * The start IP address of the server firewall rule. Must be IPv4 format.
         */
        startIpAddress: string;
    }

    /**
     * Properties of a private endpoint connection.
     */
    export interface PrivateEndpointConnectionPropertiesResponse {
        /**
         * Private endpoint which the connection belongs to.
         */
        privateEndpoint?: outputs.dbformysql.PrivateEndpointPropertyResponse;
        /**
         * Connection state of the private endpoint connection.
         */
        privateLinkServiceConnectionState?: outputs.dbformysql.PrivateLinkServiceConnectionStatePropertyResponse;
        /**
         * State of the private endpoint connection.
         */
        provisioningState: string;
    }

    export interface PrivateEndpointPropertyResponse {
        /**
         * Resource id of the private endpoint.
         */
        id?: string;
    }

    export interface PrivateLinkServiceConnectionStatePropertyResponse {
        /**
         * The actions required for private link service connection.
         */
        actionsRequired: string;
        /**
         * The private link service connection description.
         */
        description: string;
        /**
         * The private link service connection status.
         */
        status: string;
    }

    /**
     * Azure Active Directory identity configuration for a resource.
     */
    export interface ResourceIdentityResponse {
        /**
         * The Azure Active Directory principal id.
         */
        principalId: string;
        /**
         * The Azure Active Directory tenant id.
         */
        tenantId: string;
        /**
         * The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory principal for the resource.
         */
        type?: string;
    }

    /**
     * The properties of an server Administrator.
     */
    export interface ServerAdministratorPropertiesResponse {
        /**
         * The type of administrator.
         */
        administratorType: string;
        /**
         * The server administrator login account name.
         */
        login: string;
        /**
         * The server administrator Sid (Secure ID).
         */
        sid: string;
        /**
         * The server Active Directory Administrator tenant id.
         */
        tenantId: string;
    }

    /**
     * Properties for a key execution.
     */
    export interface ServerKeyPropertiesResponse {
        /**
         * The key creation date.
         */
        creationDate: string;
        /**
         * The key type like 'AzureKeyVault'.
         */
        serverKeyType: string;
        /**
         * The URI of the key.
         */
        uri?: string;
    }

    /**
     * Properties of a private endpoint connection.
     */
    export interface ServerPrivateEndpointConnectionPropertiesResponse {
        /**
         * Private endpoint which the connection belongs to.
         */
        privateEndpoint?: outputs.dbformysql.PrivateEndpointPropertyResponse;
        /**
         * Connection state of the private endpoint connection.
         */
        privateLinkServiceConnectionState?: outputs.dbformysql.ServerPrivateLinkServiceConnectionStatePropertyResponse;
        /**
         * State of the private endpoint connection.
         */
        provisioningState: string;
    }

    /**
     * A private endpoint connection under a server
     */
    export interface ServerPrivateEndpointConnectionResponse {
        /**
         * Resource Id of the private endpoint connection.
         */
        id: string;
        /**
         * Private endpoint connection properties
         */
        properties: outputs.dbformysql.ServerPrivateEndpointConnectionPropertiesResponse;
    }

    export interface ServerPrivateLinkServiceConnectionStatePropertyResponse {
        /**
         * The actions required for private link service connection.
         */
        actionsRequired: string;
        /**
         * The private link service connection description.
         */
        description: string;
        /**
         * The private link service connection status.
         */
        status: string;
    }

    /**
     * The properties of a server.
     */
    export interface ServerPropertiesResponse {
        /**
         * The administrator's login name of a server. Can only be specified when the server is being created (and is required for creation).
         */
        administratorLogin?: string;
        /**
         * Status showing whether the server data encryption is enabled with customer-managed keys.
         */
        byokEnforcement: string;
        /**
         * Earliest restore point creation time (ISO8601 format)
         */
        earliestRestoreDate?: string;
        /**
         * The fully qualified domain name of a server.
         */
        fullyQualifiedDomainName?: string;
        /**
         * Status showing whether the server enabled infrastructure encryption.
         */
        infrastructureEncryption?: string;
        /**
         * The master server id of a replica server.
         */
        masterServerId?: string;
        /**
         * Enforce a minimal Tls version for the server.
         */
        minimalTlsVersion?: string;
        /**
         * List of private endpoint connections on a server
         */
        privateEndpointConnections: outputs.dbformysql.ServerPrivateEndpointConnectionResponse[];
        /**
         * Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
         */
        publicNetworkAccess?: string;
        /**
         * The maximum number of replicas that a master server can have.
         */
        replicaCapacity?: number;
        /**
         * The replication role of the server.
         */
        replicationRole?: string;
        /**
         * Enable ssl enforcement or not when connect to server.
         */
        sslEnforcement?: string;
        /**
         * Storage profile of a server.
         */
        storageProfile?: outputs.dbformysql.StorageProfileResponse;
        /**
         * A state of a server that is visible to user.
         */
        userVisibleState?: string;
        /**
         * Server version.
         */
        version?: string;
    }

    /**
     * Billing information related properties of a server.
     */
    export interface SkuResponse {
        /**
         * The scale up/out capacity, representing server's compute units.
         */
        capacity?: number;
        /**
         * The family of hardware.
         */
        family?: string;
        /**
         * The name of the sku, typically, tier + family + cores, e.g. B_Gen4_1, GP_Gen5_8.
         */
        name?: string;
        /**
         * The size code, to be interpreted by resource as appropriate.
         */
        size?: string;
        /**
         * The tier of the particular SKU, e.g. Basic.
         */
        tier?: string;
    }

    /**
     * Storage Profile properties of a server
     */
    export interface StorageProfileResponse {
        /**
         * Backup retention days for the server.
         */
        backupRetentionDays?: number;
        /**
         * Enable Geo-redundant or not for server backup.
         */
        geoRedundantBackup?: string;
        /**
         * Enable Storage Auto Grow.
         */
        storageAutogrow?: string;
        /**
         * Max storage allowed for a server.
         */
        storageMB?: number;
    }

    /**
     * Properties of a virtual network rule.
     */
    export interface VirtualNetworkRulePropertiesResponse {
        /**
         * Create firewall rule before the virtual network has vnet service endpoint enabled.
         */
        ignoreMissingVnetServiceEndpoint?: boolean;
        /**
         * Virtual Network Rule State
         */
        state: string;
        /**
         * The ARM resource id of the virtual network subnet.
         */
        virtualNetworkSubnetId: string;
    }
}

export namespace dbforpostgresql {
    /**
     * The properties of a database.
     */
    export interface DatabasePropertiesResponse {
        /**
         * The charset of the database.
         */
        charset?: string;
        /**
         * The collation of the database.
         */
        collation?: string;
    }

    /**
     * The properties of a server firewall rule.
     */
    export interface FirewallRulePropertiesResponse {
        /**
         * The end IP address of the server firewall rule. Must be IPv4 format.
         */
        endIpAddress: string;
        /**
         * The start IP address of the server firewall rule. Must be IPv4 format.
         */
        startIpAddress: string;
    }

    /**
     * Properties of a private endpoint connection.
     */
    export interface PrivateEndpointConnectionPropertiesResponse {
        /**
         * Private endpoint which the connection belongs to.
         */
        privateEndpoint?: outputs.dbforpostgresql.PrivateEndpointPropertyResponse;
        /**
         * Connection state of the private endpoint connection.
         */
        privateLinkServiceConnectionState?: outputs.dbforpostgresql.PrivateLinkServiceConnectionStatePropertyResponse;
        /**
         * State of the private endpoint connection.
         */
        provisioningState: string;
    }

    export interface PrivateEndpointPropertyResponse {
        /**
         * Resource id of the private endpoint.
         */
        id?: string;
    }

    export interface PrivateLinkServiceConnectionStatePropertyResponse {
        /**
         * The actions required for private link service connection.
         */
        actionsRequired: string;
        /**
         * The private link service connection description.
         */
        description: string;
        /**
         * The private link service connection status.
         */
        status: string;
    }

    /**
     * Azure Active Directory identity configuration for a resource.
     */
    export interface ResourceIdentityResponse {
        /**
         * The Azure Active Directory principal id.
         */
        principalId: string;
        /**
         * The Azure Active Directory tenant id.
         */
        tenantId: string;
        /**
         * The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory principal for the resource.
         */
        type?: string;
    }

    /**
     * The properties of an server Administrator.
     */
    export interface ServerAdministratorPropertiesResponse {
        /**
         * The type of administrator.
         */
        administratorType: string;
        /**
         * The server administrator login account name.
         */
        login: string;
        /**
         * The server administrator Sid (Secure ID).
         */
        sid: string;
        /**
         * The server Active Directory Administrator tenant id.
         */
        tenantId: string;
    }

    /**
     * Properties for a key execution.
     */
    export interface ServerKeyPropertiesResponse {
        /**
         * The key creation date.
         */
        creationDate: string;
        /**
         * The key type like 'AzureKeyVault'.
         */
        serverKeyType: string;
        /**
         * The URI of the key.
         */
        uri?: string;
    }

    /**
     * Properties of a private endpoint connection.
     */
    export interface ServerPrivateEndpointConnectionPropertiesResponse {
        /**
         * Private endpoint which the connection belongs to.
         */
        privateEndpoint?: outputs.dbforpostgresql.PrivateEndpointPropertyResponse;
        /**
         * Connection state of the private endpoint connection.
         */
        privateLinkServiceConnectionState?: outputs.dbforpostgresql.ServerPrivateLinkServiceConnectionStatePropertyResponse;
        /**
         * State of the private endpoint connection.
         */
        provisioningState: string;
    }

    /**
     * A private endpoint connection under a server
     */
    export interface ServerPrivateEndpointConnectionResponse {
        /**
         * Resource ID of the Private Endpoint Connection.
         */
        id: string;
        /**
         * Private endpoint connection properties
         */
        properties: outputs.dbforpostgresql.ServerPrivateEndpointConnectionPropertiesResponse;
    }

    export interface ServerPrivateLinkServiceConnectionStatePropertyResponse {
        /**
         * The actions required for private link service connection.
         */
        actionsRequired: string;
        /**
         * The private link service connection description.
         */
        description: string;
        /**
         * The private link service connection status.
         */
        status: string;
    }

    /**
     * The properties of a server.
     */
    export interface ServerPropertiesResponse {
        /**
         * The administrator's login name of a server. Can only be specified when the server is being created (and is required for creation).
         */
        administratorLogin?: string;
        /**
         * Status showing whether the server data encryption is enabled with customer-managed keys.
         */
        byokEnforcement: string;
        /**
         * Earliest restore point creation time (ISO8601 format)
         */
        earliestRestoreDate?: string;
        /**
         * The fully qualified domain name of a server.
         */
        fullyQualifiedDomainName?: string;
        /**
         * Status showing whether the server enabled infrastructure encryption.
         */
        infrastructureEncryption?: string;
        /**
         * The master server id of a replica server.
         */
        masterServerId?: string;
        /**
         * Enforce a minimal Tls version for the server.
         */
        minimalTlsVersion?: string;
        /**
         * List of private endpoint connections on a server
         */
        privateEndpointConnections: outputs.dbforpostgresql.ServerPrivateEndpointConnectionResponse[];
        /**
         * Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
         */
        publicNetworkAccess?: string;
        /**
         * The maximum number of replicas that a master server can have.
         */
        replicaCapacity?: number;
        /**
         * The replication role of the server.
         */
        replicationRole?: string;
        /**
         * Enable ssl enforcement or not when connect to server.
         */
        sslEnforcement?: string;
        /**
         * Storage profile of a server.
         */
        storageProfile?: outputs.dbforpostgresql.StorageProfileResponse;
        /**
         * A state of a server that is visible to user.
         */
        userVisibleState?: string;
        /**
         * Server version.
         */
        version?: string;
    }

    /**
     * Billing information related properties of a server.
     */
    export interface SkuResponse {
        /**
         * The scale up/out capacity, representing server's compute units.
         */
        capacity?: number;
        /**
         * The family of hardware.
         */
        family?: string;
        /**
         * The name of the sku, typically, tier + family + cores, e.g. B_Gen4_1, GP_Gen5_8.
         */
        name?: string;
        /**
         * The size code, to be interpreted by resource as appropriate.
         */
        size?: string;
        /**
         * The tier of the particular SKU, e.g. Basic.
         */
        tier?: string;
    }

    /**
     * Storage Profile properties of a server
     */
    export interface StorageProfileResponse {
        /**
         * Backup retention days for the server.
         */
        backupRetentionDays?: number;
        /**
         * Enable Geo-redundant or not for server backup.
         */
        geoRedundantBackup?: string;
        /**
         * Enable Storage Auto Grow.
         */
        storageAutogrow?: string;
        /**
         * Max storage allowed for a server.
         */
        storageMB?: number;
    }

    /**
     * Properties of a virtual network rule.
     */
    export interface VirtualNetworkRulePropertiesResponse {
        /**
         * Create firewall rule before the virtual network has vnet service endpoint enabled.
         */
        ignoreMissingVnetServiceEndpoint?: boolean;
        /**
         * Virtual Network Rule State
         */
        state: string;
        /**
         * The ARM resource id of the virtual network subnet.
         */
        virtualNetworkSubnetId: string;
    }
}

export namespace devices {
    /**
     * The description of an X509 CA Certificate.
     */
    export interface CertificatePropertiesResponse {
        /**
         * The certificate content
         */
        certificate?: string;
        /**
         * The certificate's create date and time.
         */
        created: string;
        /**
         * The certificate's expiration date and time.
         */
        expiry: string;
        /**
         * Determines whether certificate has been verified.
         */
        isVerified: boolean;
        /**
         * The certificate's subject name.
         */
        subject: string;
        /**
         * The certificate's thumbprint.
         */
        thumbprint: string;
        /**
         * The certificate's last update date and time.
         */
        updated: string;
    }

    /**
     * The IoT hub cloud-to-device messaging properties.
     */
    export interface CloudToDevicePropertiesResponse {
        /**
         * The default time to live for cloud-to-device messages in the device queue. See: https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#cloud-to-device-messages.
         */
        defaultTtlAsIso8601?: string;
        /**
         * The properties of the feedback queue for cloud-to-device messages.
         */
        feedback?: outputs.devices.FeedbackPropertiesResponse;
        /**
         * The max delivery count for cloud-to-device messages in the device queue. See: https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#cloud-to-device-messages.
         */
        maxDeliveryCount?: number;
    }

    /**
     * The properties of an enrichment that your IoT hub applies to messages delivered to endpoints.
     */
    export interface EnrichmentPropertiesResponse {
        /**
         * The list of endpoints for which the enrichment is applied to the message.
         */
        endpointNames: string[];
        /**
         * The key or name for the enrichment property.
         */
        key: string;
        /**
         * The value for the enrichment property.
         */
        value: string;
    }

    /**
     * The properties of the fallback route. IoT Hub uses these properties when it routes messages to the fallback endpoint.
     */
    export interface FallbackRoutePropertiesResponse {
        /**
         * The condition which is evaluated in order to apply the fallback route. If the condition is not provided it will evaluate to true by default. For grammar, See: https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-query-language
         */
        condition?: string;
        /**
         * The list of endpoints to which the messages that satisfy the condition are routed to. Currently only 1 endpoint is allowed.
         */
        endpointNames: string[];
        /**
         * Used to specify whether the fallback route is enabled.
         */
        isEnabled: boolean;
        /**
         * The name of the route. The name can only include alphanumeric characters, periods, underscores, hyphens, has a maximum length of 64 characters, and must be unique.
         */
        name?: string;
        /**
         * The source to which the routing rule is to be applied to. For example, DeviceMessages
         */
        source: string;
    }

    /**
     * The properties of the feedback queue for cloud-to-device messages.
     */
    export interface FeedbackPropertiesResponse {
        /**
         * The lock duration for the feedback queue. See: https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#cloud-to-device-messages.
         */
        lockDurationAsIso8601?: string;
        /**
         * The number of times the IoT hub attempts to deliver a message on the feedback queue. See: https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#cloud-to-device-messages.
         */
        maxDeliveryCount?: number;
        /**
         * The period of time for which a message is available to consume before it is expired by the IoT hub. See: https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#cloud-to-device-messages.
         */
        ttlAsIso8601?: string;
    }

    /**
     * the service specific properties of a provisioning service, including keys, linked iot hubs, current state, and system generated properties such as hostname and idScope
     */
    export interface IotDpsPropertiesDescriptionResponse {
        /**
         * Allocation policy to be used by this provisioning service.
         */
        allocationPolicy?: string;
        /**
         * List of authorization keys for a provisioning service.
         */
        authorizationPolicies?: outputs.devices.SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionResponse[];
        /**
         * Device endpoint for this provisioning service.
         */
        deviceProvisioningHostName: string;
        /**
         * Unique identifier of this provisioning service.
         */
        idScope: string;
        /**
         * List of IoT hubs associated with this provisioning service.
         */
        iotHubs?: outputs.devices.IotHubDefinitionDescriptionResponse[];
        /**
         * The IP filter rules.
         */
        ipFilterRules?: outputs.devices.IpFilterRuleResponse[];
        /**
         * The ARM provisioning state of the provisioning service.
         */
        provisioningState?: string;
        /**
         * Service endpoint for provisioning service.
         */
        serviceOperationsHostName: string;
        /**
         * Current state of the provisioning service.
         */
        state?: string;
    }

    /**
     * List of possible provisioning service SKUs.
     */
    export interface IotDpsSkuInfoResponse {
        /**
         * The number of units to provision
         */
        capacity?: number;
        /**
         * Sku name.
         */
        name?: string;
        /**
         * Pricing tier name of the provisioning service.
         */
        tier: string;
    }

    /**
     * Description of the IoT hub.
     */
    export interface IotHubDefinitionDescriptionResponse {
        /**
         * weight to apply for a given iot h.
         */
        allocationWeight?: number;
        /**
         * flag for applying allocationPolicy or not for a given iot hub.
         */
        applyAllocationPolicy?: boolean;
        /**
         * Connection string og the IoT hub.
         */
        connectionString: string;
        /**
         * ARM region of the IoT hub.
         */
        location: string;
        /**
         * Host name of the IoT hub.
         */
        name: string;
    }

    /**
     * Public representation of one of the locations where a resource is provisioned.
     */
    export interface IotHubLocationDescriptionResponse {
        /**
         * The name of the Azure region
         */
        location?: string;
        /**
         * The role of the region, can be either primary or secondary. The primary region is where the IoT hub is currently provisioned. The secondary region is the Azure disaster recovery (DR) paired region and also the region where the IoT hub can failover to.
         */
        role?: string;
    }

    /**
     * The properties of an IoT hub.
     */
    export interface IotHubPropertiesResponse {
        /**
         * The shared access policies you can use to secure a connection to the IoT hub.
         */
        authorizationPolicies?: outputs.devices.SharedAccessSignatureAuthorizationRuleResponse[];
        /**
         * The IoT hub cloud-to-device messaging properties.
         */
        cloudToDevice?: outputs.devices.CloudToDevicePropertiesResponse;
        /**
         * IoT hub comments.
         */
        comments?: string;
        /**
         * If True, file upload notifications are enabled.
         */
        enableFileUploadNotifications?: boolean;
        /**
         * The Event Hub-compatible endpoint properties. The only possible keys to this dictionary is events. This key has to be present in the dictionary while making create or update calls for the IoT hub.
         */
        eventHubEndpoints?: {[key: string]: string};
        /**
         * The capabilities and features enabled for the IoT hub.
         */
        features?: string;
        /**
         * The name of the host.
         */
        hostName: string;
        /**
         * The IP filter rules.
         */
        ipFilterRules?: outputs.devices.IpFilterRuleResponse[];
        /**
         * Primary and secondary location for iot hub
         */
        locations: outputs.devices.IotHubLocationDescriptionResponse[];
        /**
         * The messaging endpoint properties for the file upload notification queue.
         */
        messagingEndpoints?: {[key: string]: string};
        /**
         * Specifies the minimum TLS version to support for this hub. Can be set to "1.2" to have clients that use a TLS version below 1.2 to be rejected.
         */
        minTlsVersion?: string;
        /**
         * Private endpoint connections created on this IotHub
         */
        privateEndpointConnections?: outputs.devices.PrivateEndpointConnectionResponse[];
        /**
         * The provisioning state.
         */
        provisioningState: string;
        /**
         * Whether requests from Public Network are allowed
         */
        publicNetworkAccess?: string;
        /**
         * The routing related properties of the IoT hub. See: https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging
         */
        routing?: outputs.devices.RoutingPropertiesResponse;
        /**
         * The hub state.
         */
        state: string;
        /**
         * The list of Azure Storage endpoints where you can upload files. Currently you can configure only one Azure Storage account and that MUST have its key as $default. Specifying more than one storage account causes an error to be thrown. Not specifying a value for this property when the enableFileUploadNotifications property is set to True, causes an error to be thrown.
         */
        storageEndpoints?: {[key: string]: string};
    }

    /**
     * Information about the SKU of the IoT hub.
     */
    export interface IotHubSkuInfoResponse {
        /**
         * The number of provisioned IoT Hub units. See: https://docs.microsoft.com/azure/azure-subscription-service-limits#iot-hub-limits.
         */
        capacity?: number;
        /**
         * The name of the SKU.
         */
        name: string;
        /**
         * The billing tier for the IoT hub.
         */
        tier: string;
    }

    /**
     * The IP filter rules for the IoT hub.
     */
    export interface IpFilterRuleResponse {
        /**
         * The desired action for requests captured by this rule.
         */
        action: string;
        /**
         * The name of the IP filter rule.
         */
        filterName: string;
        /**
         * A string that contains the IP address range in CIDR notation for the rule.
         */
        ipMask: string;
    }

    /**
     * The properties of a private endpoint connection
     */
    export interface PrivateEndpointConnectionPropertiesResponse {
        /**
         * The private endpoint property of a private endpoint connection
         */
        privateEndpoint?: outputs.devices.PrivateEndpointResponse;
        /**
         * The current state of a private endpoint connection
         */
        privateLinkServiceConnectionState: outputs.devices.PrivateLinkServiceConnectionStateResponse;
    }

    /**
     * The private endpoint connection of an IotHub
     */
    export interface PrivateEndpointConnectionResponse {
        /**
         * The resource identifier.
         */
        id: string;
        /**
         * The resource name.
         */
        name: string;
        /**
         * The properties of a private endpoint connection
         */
        properties: outputs.devices.PrivateEndpointConnectionPropertiesResponse;
        /**
         * The resource type.
         */
        type: string;
    }

    /**
     * The private endpoint property of a private endpoint connection
     */
    export interface PrivateEndpointResponse {
        /**
         * The resource identifier.
         */
        id: string;
    }

    /**
     * The current state of a private endpoint connection
     */
    export interface PrivateLinkServiceConnectionStateResponse {
        /**
         * Actions required for a private endpoint connection
         */
        actionsRequired?: string;
        /**
         * The description for the current state of a private endpoint connection
         */
        description: string;
        /**
         * The status of a private endpoint connection
         */
        status: string;
    }

    /**
     * The properties of a routing rule that your IoT hub uses to route messages to endpoints.
     */
    export interface RoutePropertiesResponse {
        /**
         * The condition that is evaluated to apply the routing rule. If no condition is provided, it evaluates to true by default. For grammar, see: https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-query-language
         */
        condition?: string;
        /**
         * The list of endpoints to which messages that satisfy the condition are routed. Currently only one endpoint is allowed.
         */
        endpointNames: string[];
        /**
         * Used to specify whether a route is enabled.
         */
        isEnabled: boolean;
        /**
         * The name of the route. The name can only include alphanumeric characters, periods, underscores, hyphens, has a maximum length of 64 characters, and must be unique.
         */
        name: string;
        /**
         * The source that the routing rule is to be applied to, such as DeviceMessages.
         */
        source: string;
    }

    /**
     * The properties related to the custom endpoints to which your IoT hub routes messages based on the routing rules. A maximum of 10 custom endpoints are allowed across all endpoint types for paid hubs and only 1 custom endpoint is allowed across all endpoint types for free hubs.
     */
    export interface RoutingEndpointsResponse {
        /**
         * The list of Event Hubs endpoints that IoT hub routes messages to, based on the routing rules. This list does not include the built-in Event Hubs endpoint.
         */
        eventHubs?: outputs.devices.RoutingEventHubPropertiesResponse[];
        /**
         * The list of Service Bus queue endpoints that IoT hub routes the messages to, based on the routing rules.
         */
        serviceBusQueues?: outputs.devices.RoutingServiceBusQueueEndpointPropertiesResponse[];
        /**
         * The list of Service Bus topic endpoints that the IoT hub routes the messages to, based on the routing rules.
         */
        serviceBusTopics?: outputs.devices.RoutingServiceBusTopicEndpointPropertiesResponse[];
        /**
         * The list of storage container endpoints that IoT hub routes messages to, based on the routing rules.
         */
        storageContainers?: outputs.devices.RoutingStorageContainerPropertiesResponse[];
    }

    /**
     * The properties related to an event hub endpoint.
     */
    export interface RoutingEventHubPropertiesResponse {
        /**
         * Method used to authenticate against the event hub endpoint
         */
        authenticationType?: string;
        /**
         * The connection string of the event hub endpoint. 
         */
        connectionString?: string;
        /**
         * The url of the event hub endpoint. It must include the protocol sb://
         */
        endpointUri?: string;
        /**
         * Event hub name on the event hub namespace
         */
        entityPath?: string;
        /**
         * Id of the event hub endpoint
         */
        id?: string;
        /**
         * The name that identifies this endpoint. The name can only include alphanumeric characters, periods, underscores, hyphens and has a maximum length of 64 characters. The following names are reserved:  events, fileNotifications, $default. Endpoint names must be unique across endpoint types.
         */
        name: string;
        /**
         * The name of the resource group of the event hub endpoint.
         */
        resourceGroup?: string;
        /**
         * The subscription identifier of the event hub endpoint.
         */
        subscriptionId?: string;
    }

    /**
     * The routing related properties of the IoT hub. See: https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging
     */
    export interface RoutingPropertiesResponse {
        /**
         * The properties related to the custom endpoints to which your IoT hub routes messages based on the routing rules. A maximum of 10 custom endpoints are allowed across all endpoint types for paid hubs and only 1 custom endpoint is allowed across all endpoint types for free hubs.
         */
        endpoints?: outputs.devices.RoutingEndpointsResponse;
        /**
         * The list of user-provided enrichments that the IoT hub applies to messages to be delivered to built-in and custom endpoints. See: https://aka.ms/telemetryoneventgrid
         */
        enrichments?: outputs.devices.EnrichmentPropertiesResponse[];
        /**
         * The properties of the route that is used as a fall-back route when none of the conditions specified in the 'routes' section are met. This is an optional parameter. When this property is not set, the messages which do not meet any of the conditions specified in the 'routes' section get routed to the built-in eventhub endpoint.
         */
        fallbackRoute?: outputs.devices.FallbackRoutePropertiesResponse;
        /**
         * The list of user-provided routing rules that the IoT hub uses to route messages to built-in and custom endpoints. A maximum of 100 routing rules are allowed for paid hubs and a maximum of 5 routing rules are allowed for free hubs.
         */
        routes?: outputs.devices.RoutePropertiesResponse[];
    }

    /**
     * The properties related to service bus queue endpoint types.
     */
    export interface RoutingServiceBusQueueEndpointPropertiesResponse {
        /**
         * Method used to authenticate against the service bus queue endpoint
         */
        authenticationType?: string;
        /**
         * The connection string of the service bus queue endpoint.
         */
        connectionString?: string;
        /**
         * The url of the service bus queue endpoint. It must include the protocol sb://
         */
        endpointUri?: string;
        /**
         * Queue name on the service bus namespace
         */
        entityPath?: string;
        /**
         * Id of the service bus queue endpoint
         */
        id?: string;
        /**
         * The name that identifies this endpoint. The name can only include alphanumeric characters, periods, underscores, hyphens and has a maximum length of 64 characters. The following names are reserved:  events, fileNotifications, $default. Endpoint names must be unique across endpoint types. The name need not be the same as the actual queue name.
         */
        name: string;
        /**
         * The name of the resource group of the service bus queue endpoint.
         */
        resourceGroup?: string;
        /**
         * The subscription identifier of the service bus queue endpoint.
         */
        subscriptionId?: string;
    }

    /**
     * The properties related to service bus topic endpoint types.
     */
    export interface RoutingServiceBusTopicEndpointPropertiesResponse {
        /**
         * Method used to authenticate against the service bus topic endpoint
         */
        authenticationType?: string;
        /**
         * The connection string of the service bus topic endpoint.
         */
        connectionString?: string;
        /**
         * The url of the service bus topic endpoint. It must include the protocol sb://
         */
        endpointUri?: string;
        /**
         * Queue name on the service bus topic
         */
        entityPath?: string;
        /**
         * Id of the service bus topic endpoint
         */
        id?: string;
        /**
         * The name that identifies this endpoint. The name can only include alphanumeric characters, periods, underscores, hyphens and has a maximum length of 64 characters. The following names are reserved:  events, fileNotifications, $default. Endpoint names must be unique across endpoint types.  The name need not be the same as the actual topic name.
         */
        name: string;
        /**
         * The name of the resource group of the service bus topic endpoint.
         */
        resourceGroup?: string;
        /**
         * The subscription identifier of the service bus topic endpoint.
         */
        subscriptionId?: string;
    }

    /**
     * The properties related to a storage container endpoint.
     */
    export interface RoutingStorageContainerPropertiesResponse {
        /**
         * Method used to authenticate against the storage endpoint
         */
        authenticationType?: string;
        /**
         * Time interval at which blobs are written to storage. Value should be between 60 and 720 seconds. Default value is 300 seconds.
         */
        batchFrequencyInSeconds?: number;
        /**
         * The connection string of the storage account.
         */
        connectionString?: string;
        /**
         * The name of storage container in the storage account.
         */
        containerName: string;
        /**
         * Encoding that is used to serialize messages to blobs. Supported values are 'avro', 'avrodeflate', and 'JSON'. Default value is 'avro'.
         */
        encoding?: string;
        /**
         * The url of the storage endpoint. It must include the protocol https://
         */
        endpointUri?: string;
        /**
         * File name format for the blob. Default format is {iothub}/{partition}/{YYYY}/{MM}/{DD}/{HH}/{mm}. All parameters are mandatory but can be reordered.
         */
        fileNameFormat?: string;
        /**
         * Id of the storage container endpoint
         */
        id?: string;
        /**
         * Maximum number of bytes for each blob written to storage. Value should be between 10485760(10MB) and 524288000(500MB). Default value is 314572800(300MB).
         */
        maxChunkSizeInBytes?: number;
        /**
         * The name that identifies this endpoint. The name can only include alphanumeric characters, periods, underscores, hyphens and has a maximum length of 64 characters. The following names are reserved:  events, fileNotifications, $default. Endpoint names must be unique across endpoint types.
         */
        name: string;
        /**
         * The name of the resource group of the storage account.
         */
        resourceGroup?: string;
        /**
         * The subscription identifier of the storage account.
         */
        subscriptionId?: string;
    }

    /**
     * Description of the shared access key.
     */
    export interface SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionResponse {
        /**
         * Name of the key.
         */
        keyName: string;
        /**
         * Primary SAS key value.
         */
        primaryKey?: string;
        /**
         * Rights that this key has.
         */
        rights: string;
        /**
         * Secondary SAS key value.
         */
        secondaryKey?: string;
    }

    /**
     * The properties of an IoT hub shared access policy.
     */
    export interface SharedAccessSignatureAuthorizationRuleResponse {
        /**
         * The name of the shared access policy.
         */
        keyName: string;
        /**
         * The primary key.
         */
        primaryKey?: string;
        /**
         * The permissions assigned to the shared access policy.
         */
        rights: string;
        /**
         * The secondary key.
         */
        secondaryKey?: string;
    }
}

export namespace devspaces {
    export interface ControllerConnectionDetailsResponse {
        /**
         * Base class for types that supply values used to connect to container orchestrators
         */
        orchestratorSpecificConnectionDetails?: outputs.devspaces.OrchestratorSpecificConnectionDetailsResponse;
    }

    export interface ControllerPropertiesResponse {
        /**
         * DNS name for accessing DataPlane services
         */
        dataPlaneFqdn: string;
        /**
         * DNS suffix for public endpoints running in the Azure Dev Spaces Controller.
         */
        hostSuffix: string;
        /**
         * Provisioning state of the Azure Dev Spaces Controller.
         */
        provisioningState: string;
        /**
         * DNS of the target container host's API server
         */
        targetContainerHostApiServerFqdn: string;
        /**
         * Credentials of the target container host (base64).
         */
        targetContainerHostCredentialsBase64: string;
        /**
         * Resource ID of the target container host
         */
        targetContainerHostResourceId: string;
    }

    /**
     * Base class for types that supply values used to connect to container orchestrators
     */
    export interface OrchestratorSpecificConnectionDetailsResponse {
        /**
         * Gets the Instance type.
         */
        instanceType: string;
    }

    /**
     * Model representing SKU for Azure Dev Spaces Controller.
     */
    export interface SkuResponse {
        /**
         * The name of the SKU for Azure Dev Spaces Controller.
         */
        name: string;
        /**
         * The tier of the SKU for Azure Dev Spaces Controller.
         */
        tier?: string;
    }
}

export namespace devtestlab {
    /**
     * Properties of a schedules applicable to a virtual machine.
     */
    export interface ApplicableSchedulePropertiesResponse {
        /**
         * The auto-shutdown schedule, if one has been set at the lab or lab resource level.
         */
        labVmsShutdown?: outputs.devtestlab.ScheduleResponse;
        /**
         * The auto-startup schedule, if one has been set at the lab or lab resource level.
         */
        labVmsStartup?: outputs.devtestlab.ScheduleResponse;
    }

    /**
     * Schedules applicable to a virtual machine. The schedules may have been defined on a VM or on lab level.
     */
    export interface ApplicableScheduleResponse {
        /**
         * The identifier of the resource.
         */
        id: string;
        /**
         * The location of the resource.
         */
        location?: string;
        /**
         * The name of the resource.
         */
        name: string;
        /**
         * The properties of the resource.
         */
        properties: outputs.devtestlab.ApplicableSchedulePropertiesResponse;
        /**
         * The tags of the resource.
         */
        tags?: {[key: string]: string};
        /**
         * The type of the resource.
         */
        type: string;
    }

    /**
     * Properties of an Azure Resource Manager template parameter.
     */
    export interface ArmTemplateParameterPropertiesResponse {
        /**
         * The name of the template parameter.
         */
        name?: string;
        /**
         * The value of the template parameter.
         */
        value?: string;
    }

    /**
     * Properties of an artifact deployment.
     */
    export interface ArtifactDeploymentStatusPropertiesResponse {
        /**
         * The total count of the artifacts that were successfully applied.
         */
        artifactsApplied?: number;
        /**
         * The deployment status of the artifact.
         */
        deploymentStatus?: string;
        /**
         * The total count of the artifacts that were tentatively applied.
         */
        totalArtifacts?: number;
    }

    /**
     * Properties of an artifact.
     */
    export interface ArtifactInstallPropertiesResponse {
        /**
         * The artifact's identifier.
         */
        artifactId?: string;
        /**
         * The artifact's title.
         */
        artifactTitle?: string;
        /**
         * The status message from the deployment.
         */
        deploymentStatusMessage?: string;
        /**
         * The time that the artifact starts to install on the virtual machine.
         */
        installTime?: string;
        /**
         * The parameters of the artifact.
         */
        parameters?: outputs.devtestlab.ArtifactParameterPropertiesResponse[];
        /**
         * The status of the artifact.
         */
        status?: string;
        /**
         * The status message from the virtual machine extension.
         */
        vmExtensionStatusMessage?: string;
    }

    /**
     * Properties of an artifact parameter.
     */
    export interface ArtifactParameterPropertiesResponse {
        /**
         * The name of the artifact parameter.
         */
        name?: string;
        /**
         * The value of the artifact parameter.
         */
        value?: string;
    }

    /**
     * Properties of an artifact source.
     */
    export interface ArtifactSourcePropertiesResponse {
        /**
         * The folder containing Azure Resource Manager templates.
         */
        armTemplateFolderPath?: string;
        /**
         * The artifact source's branch reference.
         */
        branchRef?: string;
        /**
         * The artifact source's creation date.
         */
        createdDate: string;
        /**
         * The artifact source's display name.
         */
        displayName?: string;
        /**
         * The folder containing artifacts.
         */
        folderPath?: string;
        /**
         * The provisioning status of the resource.
         */
        provisioningState: string;
        /**
         * The security token to authenticate to the artifact source.
         */
        securityToken?: string;
        /**
         * The artifact source's type.
         */
        sourceType?: string;
        /**
         * Indicates if the artifact source is enabled (values: Enabled, Disabled).
         */
        status?: string;
        /**
         * The unique immutable identifier of a resource (Guid).
         */
        uniqueIdentifier: string;
        /**
         * The artifact source's URI.
         */
        uri?: string;
    }

    /**
     * Properties to attach new disk to the Virtual Machine.
     */
    export interface AttachNewDataDiskOptionsResponse {
        /**
         * The name of the disk to be attached.
         */
        diskName?: string;
        /**
         * Size of the disk to be attached in GibiBytes.
         */
        diskSizeGiB?: number;
        /**
         * The storage type for the disk (i.e. Standard, Premium).
         */
        diskType?: string;
    }

    /**
     * Parameters for creating multiple virtual machines as a single action.
     */
    export interface BulkCreationParametersResponse {
        /**
         * The number of virtual machine instances to create.
         */
        instanceCount?: number;
    }

    /**
     * A data disks attached to a virtual machine.
     */
    export interface ComputeDataDiskResponse {
        /**
         * Gets data disk size in GiB.
         */
        diskSizeGiB?: number;
        /**
         * When backed by a blob, the URI of underlying blob.
         */
        diskUri?: string;
        /**
         * When backed by managed disk, this is the ID of the compute disk resource.
         */
        managedDiskId?: string;
        /**
         * Gets data disk name.
         */
        name?: string;
    }

    /**
     * Status information about a virtual machine.
     */
    export interface ComputeVmInstanceViewStatusResponse {
        /**
         * Gets the status Code.
         */
        code?: string;
        /**
         * Gets the short localizable label for the status.
         */
        displayStatus?: string;
        /**
         * Gets the message associated with the status.
         */
        message?: string;
    }

    /**
     * Properties of a virtual machine returned by the Microsoft.Compute API.
     */
    export interface ComputeVmPropertiesResponse {
        /**
         * Gets data disks blob uri for the virtual machine.
         */
        dataDiskIds?: string[];
        /**
         * Gets all data disks attached to the virtual machine.
         */
        dataDisks?: outputs.devtestlab.ComputeDataDiskResponse[];
        /**
         * Gets the network interface ID of the virtual machine.
         */
        networkInterfaceId?: string;
        /**
         * Gets OS disk blob uri for the virtual machine.
         */
        osDiskId?: string;
        /**
         * Gets the OS type of the virtual machine.
         */
        osType?: string;
        /**
         * Gets the statuses of the virtual machine.
         */
        statuses?: outputs.devtestlab.ComputeVmInstanceViewStatusResponse[];
        /**
         * Gets the size of the virtual machine.
         */
        vmSize?: string;
    }

    /**
     * Properties for creating a custom image from a VHD.
     */
    export interface CustomImagePropertiesCustomResponse {
        /**
         * The image name.
         */
        imageName?: string;
        /**
         * The OS type of the custom image (i.e. Windows, Linux)
         */
        osType: string;
        /**
         * Indicates whether sysprep has been run on the VHD.
         */
        sysPrep?: boolean;
    }

    /**
     * Properties for plan on a custom image.
     */
    export interface CustomImagePropertiesFromPlanResponse {
        /**
         * The id of the plan, equivalent to name of the plan
         */
        id?: string;
        /**
         * The offer for the plan from the marketplace image the custom image is derived from
         */
        offer?: string;
        /**
         * The publisher for the plan from the marketplace image the custom image is derived from
         */
        publisher?: string;
    }

    /**
     * Properties for creating a custom image from a virtual machine.
     */
    export interface CustomImagePropertiesFromVmResponse {
        /**
         * The Linux OS information of the VM.
         */
        linuxOsInfo?: outputs.devtestlab.LinuxOsInfoResponse;
        /**
         * The source vm identifier.
         */
        sourceVmId?: string;
        /**
         * The Windows OS information of the VM.
         */
        windowsOsInfo?: outputs.devtestlab.WindowsOsInfoResponse;
    }

    /**
     * Properties of a custom image.
     */
    export interface CustomImagePropertiesResponse {
        /**
         * The author of the custom image.
         */
        author?: string;
        /**
         * The creation date of the custom image.
         */
        creationDate: string;
        /**
         * Storage information about the plan related to this custom image
         */
        customImagePlan?: outputs.devtestlab.CustomImagePropertiesFromPlanResponse;
        /**
         * Storage information about the data disks present in the custom image
         */
        dataDiskStorageInfo?: outputs.devtestlab.DataDiskStorageTypeInfoResponse[];
        /**
         * The description of the custom image.
         */
        description?: string;
        /**
         * Whether or not the custom images underlying offer/plan has been enabled for programmatic deployment
         */
        isPlanAuthorized?: boolean;
        /**
         * The Managed Image Id backing the custom image.
         */
        managedImageId?: string;
        /**
         * The Managed Snapshot Id backing the custom image.
         */
        managedSnapshotId?: string;
        /**
         * The provisioning status of the resource.
         */
        provisioningState: string;
        /**
         * The unique immutable identifier of a resource (Guid).
         */
        uniqueIdentifier: string;
        /**
         * The VHD from which the image is to be created.
         */
        vhd?: outputs.devtestlab.CustomImagePropertiesCustomResponse;
        /**
         * The virtual machine from which the image is to be created.
         */
        vm?: outputs.devtestlab.CustomImagePropertiesFromVmResponse;
    }

    /**
     * Request body for adding a new or existing data disk to a virtual machine.
     */
    export interface DataDiskPropertiesResponse {
        /**
         * Specifies options to attach a new disk to the virtual machine.
         */
        attachNewDataDiskOptions?: outputs.devtestlab.AttachNewDataDiskOptionsResponse;
        /**
         * Specifies the existing lab disk id to attach to virtual machine.
         */
        existingLabDiskId?: string;
        /**
         * Caching option for a data disk (i.e. None, ReadOnly, ReadWrite).
         */
        hostCaching?: string;
    }

    /**
     * Storage information about the data disks present in the custom image
     */
    export interface DataDiskStorageTypeInfoResponse {
        /**
         * Disk Lun
         */
        lun?: string;
        /**
         * Disk Storage Type
         */
        storageType?: string;
    }

    /**
     * Properties of a daily schedule.
     */
    export interface DayDetailsResponse {
        /**
         * The time of day the schedule will occur.
         */
        time?: string;
    }

    /**
     * Properties of a disk.
     */
    export interface DiskPropertiesResponse {
        /**
         * The creation date of the disk.
         */
        createdDate: string;
        /**
         * When backed by a blob, the name of the VHD blob without extension.
         */
        diskBlobName?: string;
        /**
         * The size of the disk in GibiBytes.
         */
        diskSizeGiB?: number;
        /**
         * The storage type for the disk (i.e. Standard, Premium).
         */
        diskType?: string;
        /**
         * When backed by a blob, the URI of underlying blob.
         */
        diskUri?: string;
        /**
         * The host caching policy of the disk (i.e. None, ReadOnly, ReadWrite).
         */
        hostCaching?: string;
        /**
         * The resource ID of the VM to which this disk is leased.
         */
        leasedByLabVmId?: string;
        /**
         * When backed by managed disk, this is the ID of the compute disk resource.
         */
        managedDiskId?: string;
        /**
         * The provisioning status of the resource.
         */
        provisioningState: string;
        /**
         * The unique immutable identifier of a resource (Guid).
         */
        uniqueIdentifier: string;
    }

    /**
     * Properties of an environment deployment.
     */
    export interface EnvironmentDeploymentPropertiesResponse {
        /**
         * The Azure Resource Manager template's identifier.
         */
        armTemplateId?: string;
        /**
         * The parameters of the Azure Resource Manager template.
         */
        parameters?: outputs.devtestlab.ArmTemplateParameterPropertiesResponse[];
    }

    /**
     * Properties of an environment.
     */
    export interface EnvironmentPropertiesResponse {
        /**
         * The display name of the Azure Resource Manager template that produced the environment.
         */
        armTemplateDisplayName?: string;
        /**
         * The creator of the environment.
         */
        createdByUser: string;
        /**
         * The deployment properties of the environment.
         */
        deploymentProperties?: outputs.devtestlab.EnvironmentDeploymentPropertiesResponse;
        /**
         * The provisioning status of the resource.
         */
        provisioningState: string;
        /**
         * The identifier of the resource group containing the environment's resources.
         */
        resourceGroupId: string;
        /**
         * The unique immutable identifier of a resource (Guid).
         */
        uniqueIdentifier: string;
    }

    /**
     * An event to be notified for.
     */
    export interface EventResponse {
        /**
         * The event type for which this notification is enabled (i.e. AutoShutdown, Cost)
         */
        eventName?: string;
    }

    /**
     * Subnet information as returned by the Microsoft.Network API.
     */
    export interface ExternalSubnetResponse {
        /**
         * Gets or sets the identifier.
         */
        id?: string;
        /**
         * Gets or sets the name.
         */
        name?: string;
    }

    /**
     * Information about a VM from which a formula is to be created.
     */
    export interface FormulaPropertiesFromVmResponse {
        /**
         * The identifier of the VM from which a formula is to be created.
         */
        labVmId?: string;
    }

    /**
     * Properties of a formula.
     */
    export interface FormulaPropertiesResponse {
        /**
         * The author of the formula.
         */
        author?: string;
        /**
         * The creation date of the formula.
         */
        creationDate: string;
        /**
         * The description of the formula.
         */
        description?: string;
        /**
         * The content of the formula.
         */
        formulaContent?: outputs.devtestlab.LabVirtualMachineCreationParameterResponse;
        /**
         * The OS type of the formula.
         */
        osType?: string;
        /**
         * The provisioning status of the resource.
         */
        provisioningState: string;
        /**
         * The unique immutable identifier of a resource (Guid).
         */
        uniqueIdentifier: string;
        /**
         * Information about a VM from which a formula is to be created.
         */
        vm?: outputs.devtestlab.FormulaPropertiesFromVmResponse;
    }

    /**
     * The reference information for an Azure Marketplace image.
     */
    export interface GalleryImageReferenceResponse {
        /**
         * The offer of the gallery image.
         */
        offer?: string;
        /**
         * The OS type of the gallery image.
         */
        osType?: string;
        /**
         * The publisher of the gallery image.
         */
        publisher?: string;
        /**
         * The SKU of the gallery image.
         */
        sku?: string;
        /**
         * The version of the gallery image.
         */
        version?: string;
    }

    /**
     * Properties of an hourly schedule.
     */
    export interface HourDetailsResponse {
        /**
         * Minutes of the hour the schedule will run.
         */
        minute?: number;
    }

    /**
     * Properties of a managed identity
     */
    export interface IdentityPropertiesResponse {
        /**
         * The client secret URL of the identity.
         */
        clientSecretUrl?: string;
        /**
         * The principal id of resource identity.
         */
        principalId?: string;
        /**
         * The tenant identifier of resource.
         */
        tenantId?: string;
        /**
         * Managed identity.
         */
        type?: string;
    }

    /**
     * A rule for NAT - exposing a VM's port (backendPort) on the public IP address using a load balancer.
     */
    export interface InboundNatRuleResponse {
        /**
         * The port to which the external traffic will be redirected.
         */
        backendPort?: number;
        /**
         * The external endpoint port of the inbound connection. Possible values range between 1 and 65535, inclusive. If unspecified, a value will be allocated automatically.
         */
        frontendPort?: number;
        /**
         * The transport protocol for the endpoint.
         */
        transportProtocol?: string;
    }

    /**
     * Properties of a lab's announcement banner
     */
    export interface LabAnnouncementPropertiesResponse {
        /**
         * Is the lab announcement active/enabled at this time?
         */
        enabled?: string;
        /**
         * The time at which the announcement expires (null for never)
         */
        expirationDate?: string;
        /**
         * Has this announcement expired?
         */
        expired?: boolean;
        /**
         * The markdown text (if any) that this lab displays in the UI. If left empty/null, nothing will be shown.
         */
        markdown?: string;
        /**
         * The provisioning status of the resource.
         */
        provisioningState: string;
        /**
         * The plain text title for the lab announcement
         */
        title?: string;
        /**
         * The unique immutable identifier of a resource (Guid).
         */
        uniqueIdentifier: string;
    }

    /**
     * Properties of a lab.
     */
    export interface LabPropertiesResponse {
        /**
         * The properties of any lab announcement associated with this lab
         */
        announcement?: outputs.devtestlab.LabAnnouncementPropertiesResponse;
        /**
         * The lab's artifact storage account.
         */
        artifactsStorageAccount: string;
        /**
         * The creation date of the lab.
         */
        createdDate: string;
        /**
         * The lab's default premium storage account.
         */
        defaultPremiumStorageAccount: string;
        /**
         * The lab's default storage account.
         */
        defaultStorageAccount: string;
        /**
         * The access rights to be granted to the user when provisioning an environment
         */
        environmentPermission?: string;
        /**
         * Extended properties of the lab used for experimental features
         */
        extendedProperties?: {[key: string]: string};
        /**
         * Type of storage used by the lab. It can be either Premium or Standard. Default is Premium.
         */
        labStorageType?: string;
        /**
         * The load balancer used to for lab VMs that use shared IP address.
         */
        loadBalancerId: string;
        /**
         * The ordered list of artifact resource IDs that should be applied on all Linux VM creations by default, prior to the artifacts specified by the user.
         */
        mandatoryArtifactsResourceIdsLinux?: string[];
        /**
         * The ordered list of artifact resource IDs that should be applied on all Windows VM creations by default, prior to the artifacts specified by the user.
         */
        mandatoryArtifactsResourceIdsWindows?: string[];
        /**
         * The Network Security Group attached to the lab VMs Network interfaces to restrict open ports.
         */
        networkSecurityGroupId: string;
        /**
         * The lab's premium data disk storage account.
         */
        premiumDataDiskStorageAccount: string;
        /**
         * The setting to enable usage of premium data disks.
         * When its value is 'Enabled', creation of standard or premium data disks is allowed.
         * When its value is 'Disabled', only creation of standard data disks is allowed.
         */
        premiumDataDisks?: string;
        /**
         * The provisioning status of the resource.
         */
        provisioningState: string;
        /**
         * The public IP address for the lab's load balancer.
         */
        publicIpId: string;
        /**
         * The properties of any lab support message associated with this lab
         */
        support?: outputs.devtestlab.LabSupportPropertiesResponse;
        /**
         * The unique immutable identifier of a resource (Guid).
         */
        uniqueIdentifier: string;
        /**
         * The lab's Key vault.
         */
        vaultName: string;
        /**
         * The resource group in which all new lab virtual machines will be created. To let DevTest Labs manage resource group creation, set this value to null.
         */
        vmCreationResourceGroup: string;
    }

    /**
     * Properties of a lab's support banner
     */
    export interface LabSupportPropertiesResponse {
        /**
         * Is the lab support banner active/enabled at this time?
         */
        enabled?: string;
        /**
         * The markdown text (if any) that this lab displays in the UI. If left empty/null, nothing will be shown.
         */
        markdown?: string;
    }

    /**
     * Properties of a VHD in the lab.
     */
    export interface LabVhdResponse {
        /**
         * The URI to the VHD.
         */
        id?: string;
    }

    /**
     * Properties for virtual machine creation.
     */
    export interface LabVirtualMachineCreationParameterPropertiesResponse {
        /**
         * Indicates whether another user can take ownership of the virtual machine
         */
        allowClaim?: boolean;
        /**
         * The artifact deployment status for the virtual machine.
         */
        artifactDeploymentStatus?: outputs.devtestlab.ArtifactDeploymentStatusPropertiesResponse;
        /**
         * The artifacts to be installed on the virtual machine.
         */
        artifacts?: outputs.devtestlab.ArtifactInstallPropertiesResponse[];
        /**
         * The number of virtual machine instances to create.
         */
        bulkCreationParameters?: outputs.devtestlab.BulkCreationParametersResponse;
        /**
         * The resource identifier (Microsoft.Compute) of the virtual machine.
         */
        computeId?: string;
        /**
         * The email address of creator of the virtual machine.
         */
        createdByUser?: string;
        /**
         * The object identifier of the creator of the virtual machine.
         */
        createdByUserId?: string;
        /**
         * The creation date of the virtual machine.
         */
        createdDate?: string;
        /**
         * The custom image identifier of the virtual machine.
         */
        customImageId?: string;
        /**
         * New or existing data disks to attach to the virtual machine after creation
         */
        dataDiskParameters?: outputs.devtestlab.DataDiskPropertiesResponse[];
        /**
         * Indicates whether the virtual machine is to be created without a public IP address.
         */
        disallowPublicIpAddress?: boolean;
        /**
         * The resource ID of the environment that contains this virtual machine, if any.
         */
        environmentId?: string;
        /**
         * The expiration date for VM.
         */
        expirationDate?: string;
        /**
         * The fully-qualified domain name of the virtual machine.
         */
        fqdn?: string;
        /**
         * The Microsoft Azure Marketplace image reference of the virtual machine.
         */
        galleryImageReference?: outputs.devtestlab.GalleryImageReferenceResponse;
        /**
         * Indicates whether this virtual machine uses an SSH key for authentication.
         */
        isAuthenticationWithSshKey?: boolean;
        /**
         * The lab subnet name of the virtual machine.
         */
        labSubnetName?: string;
        /**
         * The lab virtual network identifier of the virtual machine.
         */
        labVirtualNetworkId?: string;
        /**
         * Last known compute power state captured in DTL
         */
        lastKnownPowerState?: string;
        /**
         * The network interface properties.
         */
        networkInterface?: outputs.devtestlab.NetworkInterfacePropertiesResponse;
        /**
         * The notes of the virtual machine.
         */
        notes?: string;
        /**
         * The OS type of the virtual machine.
         */
        osType?: string;
        /**
         * The object identifier of the owner of the virtual machine.
         */
        ownerObjectId?: string;
        /**
         * The user principal name of the virtual machine owner.
         */
        ownerUserPrincipalName?: string;
        /**
         * The password of the virtual machine administrator.
         */
        password?: string;
        /**
         * The id of the plan associated with the virtual machine image
         */
        planId?: string;
        /**
         * Virtual Machine schedules to be created
         */
        scheduleParameters?: outputs.devtestlab.ScheduleCreationParameterResponse[];
        /**
         * The size of the virtual machine.
         */
        size?: string;
        /**
         * The SSH key of the virtual machine administrator.
         */
        sshKey?: string;
        /**
         * Storage type to use for virtual machine (i.e. Standard, Premium).
         */
        storageType?: string;
        /**
         * The user name of the virtual machine.
         */
        userName?: string;
        /**
         * Tells source of creation of lab virtual machine. Output property only.
         */
        virtualMachineCreationSource?: string;
    }

    /**
     * Properties for creating a virtual machine.
     */
    export interface LabVirtualMachineCreationParameterResponse {
        /**
         * The location of the new virtual machine or environment
         */
        location?: string;
        /**
         * The name of the virtual machine or environment
         */
        name?: string;
        /**
         * The properties of the resource.
         */
        properties?: outputs.devtestlab.LabVirtualMachineCreationParameterPropertiesResponse;
        /**
         * The tags of the resource.
         */
        tags?: {[key: string]: string};
    }

    /**
     * Properties of a virtual machine.
     */
    export interface LabVirtualMachinePropertiesResponse {
        /**
         * Indicates whether another user can take ownership of the virtual machine
         */
        allowClaim?: boolean;
        /**
         * The applicable schedule for the virtual machine.
         */
        applicableSchedule: outputs.devtestlab.ApplicableScheduleResponse;
        /**
         * The artifact deployment status for the virtual machine.
         */
        artifactDeploymentStatus?: outputs.devtestlab.ArtifactDeploymentStatusPropertiesResponse;
        /**
         * The artifacts to be installed on the virtual machine.
         */
        artifacts?: outputs.devtestlab.ArtifactInstallPropertiesResponse[];
        /**
         * The resource identifier (Microsoft.Compute) of the virtual machine.
         */
        computeId?: string;
        /**
         * The compute virtual machine properties.
         */
        computeVm: outputs.devtestlab.ComputeVmPropertiesResponse;
        /**
         * The email address of creator of the virtual machine.
         */
        createdByUser?: string;
        /**
         * The object identifier of the creator of the virtual machine.
         */
        createdByUserId?: string;
        /**
         * The creation date of the virtual machine.
         */
        createdDate?: string;
        /**
         * The custom image identifier of the virtual machine.
         */
        customImageId?: string;
        /**
         * New or existing data disks to attach to the virtual machine after creation
         */
        dataDiskParameters?: outputs.devtestlab.DataDiskPropertiesResponse[];
        /**
         * Indicates whether the virtual machine is to be created without a public IP address.
         */
        disallowPublicIpAddress?: boolean;
        /**
         * The resource ID of the environment that contains this virtual machine, if any.
         */
        environmentId?: string;
        /**
         * The expiration date for VM.
         */
        expirationDate?: string;
        /**
         * The fully-qualified domain name of the virtual machine.
         */
        fqdn?: string;
        /**
         * The Microsoft Azure Marketplace image reference of the virtual machine.
         */
        galleryImageReference?: outputs.devtestlab.GalleryImageReferenceResponse;
        /**
         * Indicates whether this virtual machine uses an SSH key for authentication.
         */
        isAuthenticationWithSshKey?: boolean;
        /**
         * The lab subnet name of the virtual machine.
         */
        labSubnetName?: string;
        /**
         * The lab virtual network identifier of the virtual machine.
         */
        labVirtualNetworkId?: string;
        /**
         * Last known compute power state captured in DTL
         */
        lastKnownPowerState?: string;
        /**
         * The network interface properties.
         */
        networkInterface?: outputs.devtestlab.NetworkInterfacePropertiesResponse;
        /**
         * The notes of the virtual machine.
         */
        notes?: string;
        /**
         * The OS type of the virtual machine.
         */
        osType?: string;
        /**
         * The object identifier of the owner of the virtual machine.
         */
        ownerObjectId?: string;
        /**
         * The user principal name of the virtual machine owner.
         */
        ownerUserPrincipalName?: string;
        /**
         * The password of the virtual machine administrator.
         */
        password?: string;
        /**
         * The id of the plan associated with the virtual machine image
         */
        planId?: string;
        /**
         * The provisioning status of the resource.
         */
        provisioningState: string;
        /**
         * Virtual Machine schedules to be created
         */
        scheduleParameters?: outputs.devtestlab.ScheduleCreationParameterResponse[];
        /**
         * The size of the virtual machine.
         */
        size?: string;
        /**
         * The SSH key of the virtual machine administrator.
         */
        sshKey?: string;
        /**
         * Storage type to use for virtual machine (i.e. Standard, Premium).
         */
        storageType?: string;
        /**
         * The unique immutable identifier of a resource (Guid).
         */
        uniqueIdentifier: string;
        /**
         * The user name of the virtual machine.
         */
        userName?: string;
        /**
         * Tells source of creation of lab virtual machine. Output property only.
         */
        virtualMachineCreationSource?: string;
    }

    /**
     * Information about a Linux OS.
     */
    export interface LinuxOsInfoResponse {
        /**
         * The state of the Linux OS (i.e. NonDeprovisioned, DeprovisionRequested, DeprovisionApplied).
         */
        linuxOsState?: string;
    }

    /**
     * Properties of a network interface.
     */
    export interface NetworkInterfacePropertiesResponse {
        /**
         * The DNS name.
         */
        dnsName?: string;
        /**
         * The private IP address.
         */
        privateIpAddress?: string;
        /**
         * The public IP address.
         */
        publicIpAddress?: string;
        /**
         * The resource ID of the public IP address.
         */
        publicIpAddressId?: string;
        /**
         * The RdpAuthority property is a server DNS host name or IP address followed by the service port number for RDP (Remote Desktop Protocol).
         */
        rdpAuthority?: string;
        /**
         * The configuration for sharing a public IP address across multiple virtual machines.
         */
        sharedPublicIpAddressConfiguration?: outputs.devtestlab.SharedPublicIpAddressConfigurationResponse;
        /**
         * The SshAuthority property is a server DNS host name or IP address followed by the service port number for SSH.
         */
        sshAuthority?: string;
        /**
         * The resource ID of the sub net.
         */
        subnetId?: string;
        /**
         * The resource ID of the virtual network.
         */
        virtualNetworkId?: string;
    }

    /**
     * Properties of a schedule.
     */
    export interface NotificationChannelPropertiesResponse {
        /**
         * The creation date of the notification channel.
         */
        createdDate: string;
        /**
         * Description of notification.
         */
        description?: string;
        /**
         * The email recipient to send notifications to (can be a list of semi-colon separated email addresses).
         */
        emailRecipient?: string;
        /**
         * The list of event for which this notification is enabled.
         */
        events?: outputs.devtestlab.EventResponse[];
        /**
         * The locale to use when sending a notification (fallback for unsupported languages is EN).
         */
        notificationLocale?: string;
        /**
         * The provisioning status of the resource.
         */
        provisioningState: string;
        /**
         * The unique immutable identifier of a resource (Guid).
         */
        uniqueIdentifier: string;
        /**
         * The webhook URL to send notifications to.
         */
        webHookUrl?: string;
    }

    /**
     * Notification settings for a schedule.
     */
    export interface NotificationSettingsResponse {
        /**
         * The email recipient to send notifications to (can be a list of semi-colon separated email addresses).
         */
        emailRecipient?: string;
        /**
         * The locale to use when sending a notification (fallback for unsupported languages is EN).
         */
        notificationLocale?: string;
        /**
         * If notifications are enabled for this schedule (i.e. Enabled, Disabled).
         */
        status?: string;
        /**
         * Time in minutes before event at which notification will be sent.
         */
        timeInMinutes?: number;
        /**
         * The webhook URL to which the notification will be sent.
         */
        webhookUrl?: string;
    }

    /**
     * Properties of a Policy.
     */
    export interface PolicyPropertiesResponse {
        /**
         * The creation date of the policy.
         */
        createdDate: string;
        /**
         * The description of the policy.
         */
        description?: string;
        /**
         * The evaluator type of the policy (i.e. AllowedValuesPolicy, MaxValuePolicy).
         */
        evaluatorType?: string;
        /**
         * The fact data of the policy.
         */
        factData?: string;
        /**
         * The fact name of the policy (e.g. LabVmCount, LabVmSize, MaxVmsAllowedPerLab, etc.
         */
        factName?: string;
        /**
         * The provisioning status of the resource.
         */
        provisioningState: string;
        /**
         * The status of the policy.
         */
        status?: string;
        /**
         * The threshold of the policy (i.e. a number for MaxValuePolicy, and a JSON array of values for AllowedValuesPolicy).
         */
        threshold?: string;
        /**
         * The unique immutable identifier of a resource (Guid).
         */
        uniqueIdentifier: string;
    }

    /**
     * Properties of a network port.
     */
    export interface PortResponse {
        /**
         * Backend port of the target virtual machine.
         */
        backendPort?: number;
        /**
         * Protocol type of the port.
         */
        transportProtocol?: string;
    }

    /**
     * Properties for schedule creation.
     */
    export interface ScheduleCreationParameterPropertiesResponse {
        /**
         * If the schedule will occur once each day of the week, specify the daily recurrence.
         */
        dailyRecurrence?: outputs.devtestlab.DayDetailsResponse;
        /**
         * If the schedule will occur multiple times a day, specify the hourly recurrence.
         */
        hourlyRecurrence?: outputs.devtestlab.HourDetailsResponse;
        /**
         * Notification settings.
         */
        notificationSettings?: outputs.devtestlab.NotificationSettingsResponse;
        /**
         * The status of the schedule (i.e. Enabled, Disabled)
         */
        status?: string;
        /**
         * The resource ID to which the schedule belongs
         */
        targetResourceId?: string;
        /**
         * The task type of the schedule (e.g. LabVmsShutdownTask, LabVmAutoStart).
         */
        taskType?: string;
        /**
         * The time zone ID (e.g. Pacific Standard time).
         */
        timeZoneId?: string;
        /**
         * If the schedule will occur only some days of the week, specify the weekly recurrence.
         */
        weeklyRecurrence?: outputs.devtestlab.WeekDetailsResponse;
    }

    /**
     * Properties for creating a schedule.
     */
    export interface ScheduleCreationParameterResponse {
        /**
         * The location of the new virtual machine or environment
         */
        location?: string;
        /**
         * The name of the virtual machine or environment
         */
        name?: string;
        /**
         * The properties of the schedule.
         */
        properties?: outputs.devtestlab.ScheduleCreationParameterPropertiesResponse;
        /**
         * The tags of the resource.
         */
        tags?: {[key: string]: string};
    }

    /**
     * Properties of a schedule.
     */
    export interface SchedulePropertiesResponse {
        /**
         * The creation date of the schedule.
         */
        createdDate: string;
        /**
         * If the schedule will occur once each day of the week, specify the daily recurrence.
         */
        dailyRecurrence?: outputs.devtestlab.DayDetailsResponse;
        /**
         * If the schedule will occur multiple times a day, specify the hourly recurrence.
         */
        hourlyRecurrence?: outputs.devtestlab.HourDetailsResponse;
        /**
         * Notification settings.
         */
        notificationSettings?: outputs.devtestlab.NotificationSettingsResponse;
        /**
         * The provisioning status of the resource.
         */
        provisioningState: string;
        /**
         * The status of the schedule (i.e. Enabled, Disabled)
         */
        status?: string;
        /**
         * The resource ID to which the schedule belongs
         */
        targetResourceId?: string;
        /**
         * The task type of the schedule (e.g. LabVmsShutdownTask, LabVmAutoStart).
         */
        taskType?: string;
        /**
         * The time zone ID (e.g. Pacific Standard time).
         */
        timeZoneId?: string;
        /**
         * The unique immutable identifier of a resource (Guid).
         */
        uniqueIdentifier: string;
        /**
         * If the schedule will occur only some days of the week, specify the weekly recurrence.
         */
        weeklyRecurrence?: outputs.devtestlab.WeekDetailsResponse;
    }

    /**
     * A schedule.
     */
    export interface ScheduleResponse {
        /**
         * The identifier of the resource.
         */
        id: string;
        /**
         * The location of the resource.
         */
        location?: string;
        /**
         * The name of the resource.
         */
        name: string;
        /**
         * The properties of the resource.
         */
        properties: outputs.devtestlab.SchedulePropertiesResponse;
        /**
         * The tags of the resource.
         */
        tags?: {[key: string]: string};
        /**
         * The type of the resource.
         */
        type: string;
    }

    /**
     * Properties of a secret.
     */
    export interface SecretPropertiesResponse {
        /**
         * The provisioning status of the resource.
         */
        provisioningState: string;
        /**
         * The unique immutable identifier of a resource (Guid).
         */
        uniqueIdentifier: string;
        /**
         * The value of the secret for secret creation.
         */
        value?: string;
    }

    /**
     * Properties of a service fabric.
     */
    export interface ServiceFabricPropertiesResponse {
        /**
         * The applicable schedule for the virtual machine.
         */
        applicableSchedule: outputs.devtestlab.ApplicableScheduleResponse;
        /**
         * The resource id of the environment under which the service fabric resource is present
         */
        environmentId?: string;
        /**
         * The backing service fabric resource's id
         */
        externalServiceFabricId?: string;
        /**
         * The provisioning status of the resource.
         */
        provisioningState: string;
        /**
         * The unique immutable identifier of a resource (Guid).
         */
        uniqueIdentifier: string;
    }

    /**
     * Properties of a virtual machine that determine how it is connected to a load balancer.
     */
    export interface SharedPublicIpAddressConfigurationResponse {
        /**
         * The incoming NAT rules
         */
        inboundNatRules?: outputs.devtestlab.InboundNatRuleResponse[];
    }

    /**
     * Property overrides on a subnet of a virtual network.
     */
    export interface SubnetOverrideResponse {
        /**
         * The name given to the subnet within the lab.
         */
        labSubnetName?: string;
        /**
         * The resource ID of the subnet.
         */
        resourceId?: string;
        /**
         * Properties that virtual machines on this subnet will share.
         */
        sharedPublicIpAddressConfiguration?: outputs.devtestlab.SubnetSharedPublicIpAddressConfigurationResponse;
        /**
         * Indicates whether this subnet can be used during virtual machine creation (i.e. Allow, Deny).
         */
        useInVmCreationPermission?: string;
        /**
         * Indicates whether public IP addresses can be assigned to virtual machines on this subnet (i.e. Allow, Deny).
         */
        usePublicIpAddressPermission?: string;
        /**
         * The virtual network pool associated with this subnet.
         */
        virtualNetworkPoolName?: string;
    }

    /**
     * Subnet information.
     */
    export interface SubnetResponse {
        /**
         * The permission policy of the subnet for allowing public IP addresses (i.e. Allow, Deny)).
         */
        allowPublicIp?: string;
        /**
         * The name of the subnet as seen in the lab.
         */
        labSubnetName?: string;
        /**
         * The resource ID of the subnet.
         */
        resourceId?: string;
    }

    /**
     * Configuration for public IP address sharing.
     */
    export interface SubnetSharedPublicIpAddressConfigurationResponse {
        /**
         * Backend ports that virtual machines on this subnet are allowed to expose
         */
        allowedPorts?: outputs.devtestlab.PortResponse[];
    }

    /**
     * Identity attributes of a lab user.
     */
    export interface UserIdentityResponse {
        /**
         * Set to the app Id of the client JWT making the request.
         */
        appId?: string;
        /**
         * Set to the object Id of the client JWT making the request. Not all users have object Id. For CSP (reseller) scenarios for example, object Id is not available.
         */
        objectId?: string;
        /**
         * Set to the principal Id of the client JWT making the request. Service principal will not have the principal Id.
         */
        principalId?: string;
        /**
         * Set to the principal name / UPN of the client JWT making the request.
         */
        principalName?: string;
        /**
         * Set to the tenant ID of the client JWT making the request.
         */
        tenantId?: string;
    }

    /**
     * Properties of a lab user profile.
     */
    export interface UserPropertiesResponse {
        /**
         * The creation date of the user profile.
         */
        createdDate: string;
        /**
         * The identity of the user.
         */
        identity?: outputs.devtestlab.UserIdentityResponse;
        /**
         * The provisioning status of the resource.
         */
        provisioningState: string;
        /**
         * The secret store of the user.
         */
        secretStore?: outputs.devtestlab.UserSecretStoreResponse;
        /**
         * The unique immutable identifier of a resource (Guid).
         */
        uniqueIdentifier: string;
    }

    /**
     * Properties of a user's secret store.
     */
    export interface UserSecretStoreResponse {
        /**
         * The ID of the user's Key vault.
         */
        keyVaultId?: string;
        /**
         * The URI of the user's Key vault.
         */
        keyVaultUri?: string;
    }

    /**
     * Properties of a virtual network.
     */
    export interface VirtualNetworkPropertiesResponse {
        /**
         * The allowed subnets of the virtual network.
         */
        allowedSubnets?: outputs.devtestlab.SubnetResponse[];
        /**
         * The creation date of the virtual network.
         */
        createdDate: string;
        /**
         * The description of the virtual network.
         */
        description?: string;
        /**
         * The Microsoft.Network resource identifier of the virtual network.
         */
        externalProviderResourceId?: string;
        /**
         * The external subnet properties.
         */
        externalSubnets: outputs.devtestlab.ExternalSubnetResponse[];
        /**
         * The provisioning status of the resource.
         */
        provisioningState: string;
        /**
         * The subnet overrides of the virtual network.
         */
        subnetOverrides?: outputs.devtestlab.SubnetOverrideResponse[];
        /**
         * The unique immutable identifier of a resource (Guid).
         */
        uniqueIdentifier: string;
    }

    /**
     * Properties of a weekly schedule.
     */
    export interface WeekDetailsResponse {
        /**
         * The time of the day the schedule will occur.
         */
        time?: string;
        /**
         * The days of the week for which the schedule is set (e.g. Sunday, Monday, Tuesday, etc.).
         */
        weekdays?: string[];
    }

    /**
     * Information about a Windows OS.
     */
    export interface WindowsOsInfoResponse {
        /**
         * The state of the Windows OS (i.e. NonSysprepped, SysprepRequested, SysprepApplied).
         */
        windowsOsState?: string;
    }
}

export namespace documentdb {
    export interface ApiPropertiesResponse {
        /**
         * Describes the ServerVersion of an a MongoDB account.
         */
        serverVersion?: string;
    }

    /**
     * Cosmos DB capability object
     */
    export interface CapabilityResponse {
        /**
         * Name of the Cosmos DB capability. For example, "name": "EnableCassandra". Current values also include "EnableTable" and "EnableGremlin".
         */
        name?: string;
    }

    /**
     * The properties of an Azure Cosmos DB Cassandra keyspace
     */
    export interface CassandraKeyspaceGetPropertiesResponse {
        options?: {[key: string]: string};
        resource?: {[key: string]: string};
    }

    /**
     * The properties of an Azure Cosmos DB Cassandra table
     */
    export interface CassandraTableGetPropertiesResponse {
        options?: {[key: string]: string};
        resource?: {[key: string]: string};
    }

    /**
     * The consistency policy for the Cosmos DB database account.
     */
    export interface ConsistencyPolicyResponse {
        /**
         * The default consistency level and configuration settings of the Cosmos DB account.
         */
        defaultConsistencyLevel: string;
        /**
         * When used with the Bounded Staleness consistency level, this value represents the time amount of staleness (in seconds) tolerated. Accepted range for this value is 5 - 86400. Required when defaultConsistencyPolicy is set to 'BoundedStaleness'.
         */
        maxIntervalInSeconds?: number;
        /**
         * When used with the Bounded Staleness consistency level, this value represents the number of stale requests tolerated. Accepted range for this value is 1 – 2,147,483,647. Required when defaultConsistencyPolicy is set to 'BoundedStaleness'.
         */
        maxStalenessPrefix?: number;
    }

    /**
     * Connection string for the Cosmos DB account
     */
    export interface DatabaseAccountConnectionStringResponse {
        /**
         * Value of the connection string
         */
        connectionString: string;
        /**
         * Description of the connection string
         */
        description: string;
    }

    /**
     * Properties for the database account.
     */
    export interface DatabaseAccountGetPropertiesResponse {
        /**
         * API specific properties.
         */
        apiProperties?: outputs.documentdb.ApiPropertiesResponse;
        /**
         * List of Cosmos DB capabilities for the account
         */
        capabilities?: outputs.documentdb.CapabilityResponse[];
        /**
         * The cassandra connector offer type for the Cosmos DB database C* account.
         */
        connectorOffer?: string;
        /**
         * The consistency policy for the Cosmos DB database account.
         */
        consistencyPolicy?: outputs.documentdb.ConsistencyPolicyResponse;
        /**
         * The offer type for the Cosmos DB database account. Default value: Standard.
         */
        databaseAccountOfferType: string;
        /**
         * Disable write operations on metadata resources (databases, containers, throughput) via account keys
         */
        disableKeyBasedMetadataWriteAccess?: boolean;
        /**
         * The connection endpoint for the Cosmos DB database account.
         */
        documentEndpoint: string;
        /**
         * Flag to indicate whether to enable storage analytics.
         */
        enableAnalyticalStorage?: boolean;
        /**
         * Enables automatic failover of the write region in the rare event that the region is unavailable due to an outage. Automatic failover will result in a new write region for the account and is chosen based on the failover priorities configured for the account.
         */
        enableAutomaticFailover?: boolean;
        /**
         * Enables the cassandra connector on the Cosmos DB C* account
         */
        enableCassandraConnector?: boolean;
        /**
         * Flag to indicate whether Free Tier is enabled.
         */
        enableFreeTier?: boolean;
        /**
         * Enables the account to write in multiple locations
         */
        enableMultipleWriteLocations?: boolean;
        /**
         * An array that contains the regions ordered by their failover priorities.
         */
        failoverPolicies: outputs.documentdb.FailoverPolicyResponse[];
        /**
         * List of IpRules.
         */
        ipRules?: outputs.documentdb.IPRulesResponse;
        /**
         * Flag to indicate whether to enable/disable Virtual Network ACL rules.
         */
        isVirtualNetworkFilterEnabled?: boolean;
        /**
         * The URI of the key vault
         */
        keyVaultKeyUri?: string;
        /**
         * An array that contains all of the locations enabled for the Cosmos DB account.
         */
        locations: outputs.documentdb.LocationResponse[];
        /**
         * List of Private Endpoint Connections configured for the Cosmos DB account.
         */
        privateEndpointConnections: outputs.documentdb.PrivateEndpointConnectionResponse[];
        /**
         * The status of the Cosmos DB account at the time the operation was called. The status can be one of following. 'Creating' – the Cosmos DB account is being created. When an account is in Creating state, only properties that are specified as input for the Create Cosmos DB account operation are returned. 'Succeeded' – the Cosmos DB account is active for use. 'Updating' – the Cosmos DB account is being updated. 'Deleting' – the Cosmos DB account is being deleted. 'Failed' – the Cosmos DB account failed creation. 'DeletionFailed' – the Cosmos DB account deletion failed.
         */
        provisioningState?: string;
        /**
         * Whether requests from Public Network are allowed
         */
        publicNetworkAccess?: string;
        /**
         * An array that contains of the read locations enabled for the Cosmos DB account.
         */
        readLocations: outputs.documentdb.LocationResponse[];
        /**
         * List of Virtual Network ACL rules configured for the Cosmos DB account.
         */
        virtualNetworkRules?: outputs.documentdb.VirtualNetworkRuleResponse[];
        /**
         * An array that contains the write location for the Cosmos DB account.
         */
        writeLocations: outputs.documentdb.LocationResponse[];
    }

    /**
     * The failover policy for a given region of a database account.
     */
    export interface FailoverPolicyResponse {
        /**
         * The failover priority of the region. A failover priority of 0 indicates a write region. The maximum value for a failover priority = (total number of regions - 1). Failover priority values must be unique for each of the regions in which the database account exists.
         */
        failoverPriority?: number;
        /**
         * The unique identifier of the region in which the database account replicates to. Example: &lt;accountName&gt;-&lt;locationName&gt;.
         */
        id: string;
        /**
         * The name of the region in which the database account exists.
         */
        locationName?: string;
    }

    /**
     * The properties of an Azure Cosmos DB SQL database
     */
    export interface GremlinDatabaseGetPropertiesResponse {
        options?: {[key: string]: string};
        resource?: {[key: string]: string};
    }

    /**
     * The properties of an Azure Cosmos DB Gremlin graph
     */
    export interface GremlinGraphGetPropertiesResponse {
        options?: {[key: string]: string};
        resource?: {[key: string]: string};
    }

    /**
     * Array of IpAddressOrRange objects.
     */
    export interface IPRulesResponse {
    }

    /**
     * A region in which the Azure Cosmos DB database account is deployed.
     */
    export interface LocationResponse {
        /**
         * The connection endpoint for the specific region. Example: https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/
         */
        documentEndpoint: string;
        /**
         * The failover priority of the region. A failover priority of 0 indicates a write region. The maximum value for a failover priority = (total number of regions - 1). Failover priority values must be unique for each of the regions in which the database account exists.
         */
        failoverPriority?: number;
        /**
         * The unique identifier of the region within the database account. Example: &lt;accountName&gt;-&lt;locationName&gt;.
         */
        id: string;
        /**
         * Flag to indicate whether or not this region is an AvailabilityZone region
         */
        isZoneRedundant?: boolean;
        /**
         * The name of the region.
         */
        locationName?: string;
        /**
         * The status of the Cosmos DB account at the time the operation was called. The status can be one of following. 'Creating' – the Cosmos DB account is being created. When an account is in Creating state, only properties that are specified as input for the Create Cosmos DB account operation are returned. 'Succeeded' – the Cosmos DB account is active for use. 'Updating' – the Cosmos DB account is being updated. 'Deleting' – the Cosmos DB account is being deleted. 'Failed' – the Cosmos DB account failed creation. 'DeletionFailed' – the Cosmos DB account deletion failed.
         */
        provisioningState?: string;
    }

    /**
     * The properties of an Azure Cosmos DB MongoDB collection
     */
    export interface MongoDBCollectionGetPropertiesResponse {
        options?: {[key: string]: string};
        resource?: {[key: string]: string};
    }

    /**
     * The properties of an Azure Cosmos DB MongoDB database
     */
    export interface MongoDBDatabaseGetPropertiesResponse {
        options?: {[key: string]: string};
        resource?: {[key: string]: string};
    }

    /**
     * Properties of a notebook workspace resource.
     */
    export interface NotebookWorkspacePropertiesResponse {
        /**
         * Specifies the endpoint of Notebook server.
         */
        notebookServerEndpoint: string;
        /**
         * Status of the notebook workspace. Possible values are: Creating, Online, Deleting, Failed, Updating.
         */
        status: string;
    }

    /**
     * Properties of a private endpoint connection.
     */
    export interface PrivateEndpointConnectionPropertiesResponse {
        /**
         * Private endpoint which the connection belongs to.
         */
        privateEndpoint?: outputs.documentdb.PrivateEndpointPropertyResponse;
        /**
         * Connection State of the Private Endpoint Connection.
         */
        privateLinkServiceConnectionState?: outputs.documentdb.PrivateLinkServiceConnectionStatePropertyResponse;
    }

    /**
     * A private endpoint connection
     */
    export interface PrivateEndpointConnectionResponse {
        /**
         * Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
         */
        id: string;
        /**
         * The name of the resource
         */
        name: string;
        /**
         * Resource properties.
         */
        properties?: outputs.documentdb.PrivateEndpointConnectionPropertiesResponse;
        /**
         * The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
         */
        type: string;
    }

    /**
     * Private endpoint which the connection belongs to.
     */
    export interface PrivateEndpointPropertyResponse {
        /**
         * Resource id of the private endpoint.
         */
        id?: string;
    }

    /**
     * Connection State of the Private Endpoint Connection.
     */
    export interface PrivateLinkServiceConnectionStatePropertyResponse {
        /**
         * Any action that is required beyond basic workflow (approve/ reject/ disconnect)
         */
        actionsRequired: string;
        /**
         * The private link service connection status.
         */
        status?: string;
    }

    /**
     * The properties of an Azure Cosmos DB container
     */
    export interface SqlContainerGetPropertiesResponse {
        options?: {[key: string]: string};
        resource?: {[key: string]: string};
    }

    /**
     * The properties of an Azure Cosmos DB SQL database
     */
    export interface SqlDatabaseGetPropertiesResponse {
        options?: {[key: string]: string};
        resource?: outputs.documentdb.SqlDatabaseGetPropertiesResponseProperties;
    }

    export interface SqlDatabaseGetPropertiesResponseProperties {
        /**
         * A system generated property that specified the addressable path of the collections resource.
         */
        _colls?: string;
        /**
         * A system generated property representing the resource etag required for optimistic concurrency control.
         */
        _etag: string;
        /**
         * A system generated property. A unique identifier.
         */
        _rid: string;
        /**
         * A system generated property that denotes the last updated timestamp of the resource.
         */
        _ts: {[key: string]: string};
        /**
         * A system generated property that specifies the addressable path of the users resource.
         */
        _users?: string;
        /**
         * Name of the Cosmos DB SQL database
         */
        id: string;
    }

    /**
     * The properties of an Azure Cosmos DB StoredProcedure
     */
    export interface SqlStoredProcedureGetPropertiesResponse {
        resource?: {[key: string]: string};
    }

    /**
     * The properties of an Azure Cosmos DB trigger
     */
    export interface SqlTriggerGetPropertiesResponse {
        resource?: {[key: string]: string};
    }

    /**
     * The properties of an Azure Cosmos DB userDefinedFunction
     */
    export interface SqlUserDefinedFunctionGetPropertiesResponse {
        resource?: {[key: string]: string};
    }

    /**
     * The properties of an Azure Cosmos Table
     */
    export interface TableGetPropertiesResponse {
        options?: {[key: string]: string};
        resource?: {[key: string]: string};
    }

    /**
     * Tags are a list of key-value pairs that describe the resource. These tags can be used in viewing and grouping this resource (across resource groups). A maximum of 15 tags can be provided for a resource. Each tag must have a key no greater than 128 characters and value no greater than 256 characters. For example, the default experience for a template type is set with "defaultExperience": "Cassandra". Current "defaultExperience" values also include "Table", "Graph", "DocumentDB", and "MongoDB".
     */
    export interface TagsResponse {
    }

    /**
     * Virtual Network ACL Rule object
     */
    export interface VirtualNetworkRuleResponse {
        /**
         * Resource ID of a subnet, for example: /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
         */
        id?: string;
        /**
         * Create firewall rule before the virtual network has vnet service endpoint enabled.
         */
        ignoreMissingVNetServiceEndpoint?: boolean;
    }
}

export namespace domainregistration {
    /**
     * Address information for domain registration.
     */
    export interface AddressResponse {
        /**
         * First line of an Address.
         */
        address1: string;
        /**
         * The second line of the Address. Optional.
         */
        address2?: string;
        /**
         * The city for the address.
         */
        city: string;
        /**
         * The country for the address.
         */
        country: string;
        /**
         * The postal code for the address.
         */
        postalCode: string;
        /**
         * The state or province for the address.
         */
        state: string;
    }

    /**
     * Contact information for domain registration. If 'Domain Privacy' option is not selected then the contact information is made publicly available through the Whois 
     * directories as per ICANN requirements.
     */
    export interface ContactResponse {
        /**
         * Mailing address.
         */
        addressMailing?: outputs.domainregistration.AddressResponse;
        /**
         * Email address.
         */
        email: string;
        /**
         * Fax number.
         */
        fax?: string;
        /**
         * Job title.
         */
        jobTitle?: string;
        /**
         * First name.
         */
        nameFirst: string;
        /**
         * Last name.
         */
        nameLast: string;
        /**
         * Middle name.
         */
        nameMiddle?: string;
        /**
         * Organization contact belongs to.
         */
        organization?: string;
        /**
         * Phone number.
         */
        phone: string;
    }

    /**
     * DomainOwnershipIdentifier resource specific properties
     */
    export interface DomainOwnershipIdentifierResponseProperties {
        /**
         * Ownership Id.
         */
        ownershipId?: string;
    }

    /**
     * Domain purchase consent object, representing acceptance of applicable legal agreements.
     */
    export interface DomainPurchaseConsentResponse {
        /**
         * Timestamp when the agreements were accepted.
         */
        agreedAt?: string;
        /**
         * Client IP address.
         */
        agreedBy?: string;
        /**
         * List of applicable legal agreement keys. This list can be retrieved using ListLegalAgreements API under <code>TopLevelDomain</code> resource.
         */
        agreementKeys?: string[];
    }

    /**
     * Domain resource specific properties
     */
    export interface DomainResponseProperties {
        authCode?: string;
        /**
         * <code>true</code> if the domain should be automatically renewed; otherwise, <code>false</code>.
         */
        autoRenew?: boolean;
        /**
         * Legal agreement consent.
         */
        consent: outputs.domainregistration.DomainPurchaseConsentResponse;
        /**
         * Administrative contact.
         */
        contactAdmin: outputs.domainregistration.ContactResponse;
        /**
         * Billing contact.
         */
        contactBilling: outputs.domainregistration.ContactResponse;
        /**
         * Registrant contact.
         */
        contactRegistrant: outputs.domainregistration.ContactResponse;
        /**
         * Technical contact.
         */
        contactTech: outputs.domainregistration.ContactResponse;
        /**
         * Domain creation timestamp.
         */
        createdTime: string;
        /**
         * Current DNS type
         */
        dnsType?: string;
        /**
         * Azure DNS Zone to use
         */
        dnsZoneId?: string;
        /**
         * Reasons why domain is not renewable.
         */
        domainNotRenewableReasons: string[];
        /**
         * Domain expiration timestamp.
         */
        expirationTime: string;
        /**
         * Timestamp when the domain was renewed last time.
         */
        lastRenewedTime: string;
        /**
         * All hostnames derived from the domain and assigned to Azure resources.
         */
        managedHostNames: outputs.domainregistration.HostNameResponse[];
        /**
         * Name servers.
         */
        nameServers: string[];
        /**
         * <code>true</code> if domain privacy is enabled for this domain; otherwise, <code>false</code>.
         */
        privacy?: boolean;
        /**
         * Domain provisioning state.
         */
        provisioningState: string;
        /**
         * <code>true</code> if Azure can assign this domain to App Service apps; otherwise, <code>false</code>. This value will be <code>true</code> if domain registration status is active and 
         *  it is hosted on name servers Azure has programmatic access to.
         */
        readyForDnsRecordManagement: boolean;
        /**
         * Domain registration status.
         */
        registrationStatus: string;
        /**
         * Target DNS type (would be used for migration)
         */
        targetDnsType?: string;
    }

    /**
     * Details of a hostname derived from a domain.
     */
    export interface HostNameResponse {
        /**
         * Name of the Azure resource the hostname is assigned to. If it is assigned to a Traffic Manager then it will be the Traffic Manager name otherwise it will be the app name.
         */
        azureResourceName?: string;
        /**
         * Type of the Azure resource the hostname is assigned to.
         */
        azureResourceType?: string;
        /**
         * Type of the DNS record.
         */
        customHostNameDnsRecordType?: string;
        /**
         * Type of the hostname.
         */
        hostNameType?: string;
        /**
         * Name of the hostname.
         */
        name?: string;
        /**
         * List of apps the hostname is assigned to. This list will have more than one app only if the hostname is pointing to a Traffic Manager.
         */
        siteNames?: string[];
    }
}

export namespace eventgrid {
    /**
     * ConnectionState information.
     */
    export interface ConnectionStateResponse {
        /**
         * Actions required (if any).
         */
        actionsRequired?: string;
        /**
         * Description of the connection state.
         */
        description?: string;
        /**
         * Status of the connection.
         */
        status?: string;
    }

    /**
     * Properties of the Domain.
     */
    export interface DomainPropertiesResponse {
        /**
         * Endpoint for the domain.
         */
        endpoint: string;
        /**
         * This can be used to restrict traffic from specific IPs instead of all IPs. Note: These are considered only if PublicNetworkAccess is enabled.
         */
        inboundIpRules?: outputs.eventgrid.InboundIpRuleResponse[];
        /**
         * This determines the format that Event Grid should expect for incoming events published to the domain.
         */
        inputSchema?: string;
        /**
         * Information about the InputSchemaMapping which specified the info about mapping event payload.
         */
        inputSchemaMapping?: outputs.eventgrid.InputSchemaMappingResponse;
        /**
         * Metric resource id for the domain.
         */
        metricResourceId: string;
        /**
         * List of private endpoint connections.
         */
        privateEndpointConnections?: outputs.eventgrid.PrivateEndpointConnectionResponse[];
        /**
         * Provisioning state of the domain.
         */
        provisioningState: string;
        /**
         * This determines if traffic is allowed over public network. By default it is enabled. 
         * You can further restrict to specific IPs by configuring <seealso cref="P:Microsoft.Azure.Events.ResourceProvider.Common.Contracts.DomainProperties.InboundIpRules" />
         */
        publicNetworkAccess?: string;
    }

    /**
     * Properties of the Domain Topic.
     */
    export interface DomainTopicPropertiesResponse {
        /**
         * Provisioning state of the domain topic.
         */
        provisioningState?: string;
    }

    export interface InboundIpRuleResponse {
        /**
         * Action to perform based on the match or no match of the IpMask.
         */
        action?: string;
        /**
         * IP Address in CIDR notation e.g., 10.0.0.0/8.
         */
        ipMask?: string;
    }

    /**
     * By default, Event Grid expects events to be in the Event Grid event schema. Specifying an input schema mapping enables publishing to Event Grid using a custom input schema. Currently, the only supported type of InputSchemaMapping is 'JsonInputSchemaMapping'.
     */
    export interface InputSchemaMappingResponse {
        /**
         * Type of the custom mapping
         */
        inputSchemaMappingType: string;
    }

    /**
     * Properties of the private endpoint connection resource.
     */
    export interface PrivateEndpointConnectionPropertiesResponse {
        /**
         * GroupIds from the private link service resource.
         */
        groupIds?: string[];
        /**
         * The Private Endpoint resource for this Connection.
         */
        privateEndpoint?: outputs.eventgrid.PrivateEndpointResponse;
        /**
         * Details about the state of the connection.
         */
        privateLinkServiceConnectionState?: outputs.eventgrid.ConnectionStateResponse;
        /**
         * Provisioning state of the Private Endpoint Connection.
         */
        provisioningState?: string;
    }

    export interface PrivateEndpointConnectionResponse {
        /**
         * Fully qualified identifier of the resource.
         */
        id: string;
        /**
         * Name of the resource.
         */
        name: string;
        /**
         * Properties of the PrivateEndpointConnection.
         */
        properties?: outputs.eventgrid.PrivateEndpointConnectionPropertiesResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * PrivateEndpoint information.
     */
    export interface PrivateEndpointResponse {
        /**
         * The ARM identifier for Private Endpoint.
         */
        id?: string;
    }

    /**
     * Properties of the Topic
     */
    export interface TopicPropertiesResponse {
        /**
         * Endpoint for the topic.
         */
        endpoint: string;
        /**
         * This can be used to restrict traffic from specific IPs instead of all IPs. Note: These are considered only if PublicNetworkAccess is enabled.
         */
        inboundIpRules?: outputs.eventgrid.InboundIpRuleResponse[];
        /**
         * This determines the format that Event Grid should expect for incoming events published to the topic.
         */
        inputSchema?: string;
        /**
         * This enables publishing using custom event schemas. An InputSchemaMapping can be specified to map various properties of a source schema to various required properties of the EventGridEvent schema.
         */
        inputSchemaMapping?: outputs.eventgrid.InputSchemaMappingResponse;
        /**
         * Metric resource id for the topic.
         */
        metricResourceId: string;
        privateEndpointConnections?: outputs.eventgrid.PrivateEndpointConnectionResponse[];
        /**
         * Provisioning state of the topic.
         */
        provisioningState: string;
        /**
         * This determines if traffic is allowed over public network. By default it is enabled. 
         * You can further restrict to specific IPs by configuring <seealso cref="P:Microsoft.Azure.Events.ResourceProvider.Common.Contracts.TopicProperties.InboundIpRules" />
         */
        publicNetworkAccess?: string;
    }
}

export namespace eventhub {
    /**
     * Properties required to the Create Or Update Alias(Disaster Recovery configurations)
     */
    export interface ArmDisasterRecoveryResponseProperties {
        /**
         * Alternate name specified when alias and namespace names are same.
         */
        alternateName?: string;
        /**
         * ARM Id of the Primary/Secondary eventhub namespace name, which is part of GEO DR pairing
         */
        partnerNamespace?: string;
        /**
         * Number of entities pending to be replicated.
         */
        pendingReplicationOperationsCount: number;
        /**
         * Provisioning state of the Alias(Disaster Recovery configuration) - possible values 'Accepted' or 'Succeeded' or 'Failed'
         */
        provisioningState: string;
        /**
         * role of namespace in GEO DR - possible values 'Primary' or 'PrimaryNotReplicating' or 'Secondary'
         */
        role: string;
    }

    /**
     * Properties supplied to create or update AuthorizationRule
     */
    export interface AuthorizationRuleResponseProperties {
        /**
         * The rights associated with the rule.
         */
        rights: string[];
    }

    /**
     * Properties to configure capture description for eventhub
     */
    export interface CaptureDescriptionResponse {
        /**
         * Properties of Destination where capture will be stored. (Storage Account, Blob Names)
         */
        destination?: outputs.eventhub.DestinationResponse;
        /**
         * A value that indicates whether capture description is enabled. 
         */
        enabled?: boolean;
        /**
         * Enumerates the possible values for the encoding format of capture description. Note: 'AvroDeflate' will be deprecated in New API Version
         */
        encoding?: string;
        /**
         * The time window allows you to set the frequency with which the capture to Azure Blobs will happen, value should between 60 to 900 seconds
         */
        intervalInSeconds?: number;
        /**
         * The size window defines the amount of data built up in your Event Hub before an capture operation, value should be between 10485760 to 524288000 bytes
         */
        sizeLimitInBytes?: number;
        /**
         * A value that indicates whether to Skip Empty Archives
         */
        skipEmptyArchives?: boolean;
    }

    /**
     * Single item in List or Get Consumer group operation
     */
    export interface ConsumerGroupResponseProperties {
        /**
         * Exact time the message was created.
         */
        createdAt: string;
        /**
         * The exact time the message was updated.
         */
        updatedAt: string;
        /**
         * User Metadata is a placeholder to store user-defined string data with maximum length 1024. e.g. it can be used to store descriptive data, such as list of teams and their contact information also user-defined configuration settings can be stored.
         */
        userMetadata?: string;
    }

    /**
     * Capture storage details for capture description
     */
    export interface DestinationResponse {
        /**
         * Name for capture destination
         */
        name?: string;
        /**
         * Properties describing the storage account, blob container and archive name format for capture destination
         */
        properties?: outputs.eventhub.DestinationResponseProperties;
    }

    /**
     * Properties describing the storage account, blob container and archive name format for capture destination
     */
    export interface DestinationResponseProperties {
        /**
         * Blob naming convention for archive, e.g. {Namespace}/{EventHub}/{PartitionId}/{Year}/{Month}/{Day}/{Hour}/{Minute}/{Second}. Here all the parameters (Namespace,EventHub .. etc) are mandatory irrespective of order
         */
        archiveNameFormat?: string;
        /**
         * Blob container Name
         */
        blobContainer?: string;
        /**
         * Resource id of the storage account to be used to create the blobs
         */
        storageAccountResourceId?: string;
    }

    /**
     * Namespace properties supplied for create namespace operation.
     */
    export interface EHNamespaceResponseProperties {
        /**
         * The time the Namespace was created.
         */
        createdAt: string;
        /**
         * Value that indicates whether AutoInflate is enabled for eventhub namespace.
         */
        isAutoInflateEnabled?: boolean;
        /**
         * Value that indicates whether Kafka is enabled for eventhub namespace.
         */
        kafkaEnabled?: boolean;
        /**
         * Upper limit of throughput units when AutoInflate is enabled, value should be within 0 to 20 throughput units. ( '0' if AutoInflateEnabled = true)
         */
        maximumThroughputUnits?: number;
        /**
         * Identifier for Azure Insights metrics.
         */
        metricId: string;
        /**
         * Provisioning state of the Namespace.
         */
        provisioningState: string;
        /**
         * Endpoint you can use to perform Service Bus operations.
         */
        serviceBusEndpoint: string;
        /**
         * The time the Namespace was updated.
         */
        updatedAt: string;
    }

    /**
     * Properties supplied to the Create Or Update Event Hub operation.
     */
    export interface EventhubResponseProperties {
        /**
         * Properties of capture description
         */
        captureDescription?: outputs.eventhub.CaptureDescriptionResponse;
        /**
         * Exact time the Event Hub was created.
         */
        createdAt: string;
        /**
         * Number of days to retain the events for this Event Hub, value should be 1 to 7 days
         */
        messageRetentionInDays?: number;
        /**
         * Number of partitions created for the Event Hub, allowed values are from 1 to 32 partitions.
         */
        partitionCount?: number;
        /**
         * Current number of shards on the Event Hub.
         */
        partitionIds: string[];
        /**
         * Enumerates the possible values for the status of the Event Hub.
         */
        status?: string;
        /**
         * The exact time the message was updated.
         */
        updatedAt: string;
    }

    /**
     * SKU parameters supplied to the create namespace operation
     */
    export interface SkuResponse {
        /**
         * The Event Hubs throughput units, value should be 0 to 20 throughput units.
         */
        capacity?: number;
        /**
         * Name of this SKU.
         */
        name: string;
        /**
         * The billing tier of this particular SKU.
         */
        tier?: string;
    }
}

export namespace hdinsight {
    /**
     * Gets the application SSH endpoint
     */
    export interface ApplicationGetEndpointResponse {
        /**
         * The destination port to connect to.
         */
        destinationPort?: number;
        /**
         * The location of the endpoint.
         */
        location?: string;
        /**
         * The public port to connect to.
         */
        publicPort?: number;
    }

    /**
     * Gets the application HTTP endpoints.
     */
    export interface ApplicationGetHttpsEndpointResponse {
        /**
         * The list of access modes for the application.
         */
        accessModes?: string[];
        /**
         * The destination port to connect to.
         */
        destinationPort?: number;
        /**
         * The value indicates whether to disable GatewayAuth.
         */
        disableGatewayAuth?: boolean;
        /**
         * The location of the endpoint.
         */
        location?: string;
        /**
         * The public port to connect to.
         */
        publicPort?: number;
        /**
         * The subdomain suffix of the application.
         */
        subDomainSuffix?: string;
    }

    /**
     * The HDInsight cluster application GET response.
     */
    export interface ApplicationPropertiesResponse {
        /**
         * The application state.
         */
        applicationState: string;
        /**
         * The application type.
         */
        applicationType?: string;
        /**
         * The list of roles in the cluster.
         */
        computeProfile?: outputs.hdinsight.ComputeProfileResponse;
        /**
         * The application create date time.
         */
        createdDate: string;
        /**
         * The list of errors.
         */
        errors?: outputs.hdinsight.ErrorsResponse[];
        /**
         * The list of application HTTPS endpoints.
         */
        httpsEndpoints?: outputs.hdinsight.ApplicationGetHttpsEndpointResponse[];
        /**
         * The list of install script actions.
         */
        installScriptActions?: outputs.hdinsight.RuntimeScriptActionResponse[];
        /**
         * The marketplace identifier.
         */
        marketplaceIdentifier: string;
        /**
         * The provisioning state of the application.
         */
        provisioningState: string;
        /**
         * The list of application SSH endpoints.
         */
        sshEndpoints?: outputs.hdinsight.ApplicationGetEndpointResponse[];
        /**
         * The list of uninstall script actions.
         */
        uninstallScriptActions?: outputs.hdinsight.RuntimeScriptActionResponse[];
    }

    /**
     * The load-based autoscale request parameters
     */
    export interface AutoscaleCapacityResponse {
        /**
         * The maximum instance count of the cluster
         */
        maxInstanceCount?: number;
        /**
         * The minimum instance count of the cluster
         */
        minInstanceCount?: number;
    }

    /**
     * Schedule-based autoscale request parameters
     */
    export interface AutoscaleRecurrenceResponse {
        /**
         * Array of schedule-based autoscale rules
         */
        schedule?: outputs.hdinsight.AutoscaleScheduleResponse[];
        /**
         * The time zone for the autoscale schedule times
         */
        timeZone?: string;
    }

    /**
     * The autoscale request parameters
     */
    export interface AutoscaleResponse {
        /**
         * Parameters for load-based autoscale
         */
        capacity?: outputs.hdinsight.AutoscaleCapacityResponse;
        /**
         * Parameters for schedule-based autoscale
         */
        recurrence?: outputs.hdinsight.AutoscaleRecurrenceResponse;
    }

    /**
     * Parameters for a schedule-based autoscale rule, consisting of an array of days + a time and capacity
     */
    export interface AutoscaleScheduleResponse {
        /**
         * Days of the week for a schedule-based autoscale rule
         */
        days?: string[];
        /**
         * Time and capacity for a schedule-based autoscale rule
         */
        timeAndCapacity?: outputs.hdinsight.AutoscaleTimeAndCapacityResponse;
    }

    /**
     * Time and capacity request parameters
     */
    export interface AutoscaleTimeAndCapacityResponse {
        /**
         * The maximum instance count of the cluster
         */
        maxInstanceCount?: number;
        /**
         * The minimum instance count of the cluster
         */
        minInstanceCount?: number;
        /**
         * 24-hour time in the form xx:xx
         */
        time?: string;
    }

    /**
     * The information of AAD security group.
     */
    export interface ClientGroupInfoResponse {
        /**
         * The AAD security group id.
         */
        groupId?: string;
        /**
         * The AAD security group name.
         */
        groupName?: string;
    }

    /**
     * The cluster definition.
     */
    export interface ClusterDefinitionResponse {
        /**
         * The link to the blueprint.
         */
        blueprint?: string;
        /**
         * The versions of different services in the cluster.
         */
        componentVersion?: {[key: string]: string};
        /**
         * The cluster configurations.
         */
        configurations?: {[key: string]: string};
        /**
         * The type of cluster.
         */
        kind?: string;
    }

    /**
     * The properties of cluster.
     */
    export interface ClusterGetPropertiesResponse {
        /**
         * The cluster definition.
         */
        clusterDefinition: outputs.hdinsight.ClusterDefinitionResponse;
        /**
         * The state of the cluster.
         */
        clusterState?: string;
        /**
         * The version of the cluster.
         */
        clusterVersion?: string;
        /**
         * The compute profile.
         */
        computeProfile?: outputs.hdinsight.ComputeProfileResponse;
        /**
         * The list of connectivity endpoints.
         */
        connectivityEndpoints?: outputs.hdinsight.ConnectivityEndpointResponse[];
        /**
         * The date on which the cluster was created.
         */
        createdDate?: string;
        /**
         * The disk encryption properties.
         */
        diskEncryptionProperties?: outputs.hdinsight.DiskEncryptionPropertiesResponse;
        /**
         * The encryption-in-transit properties.
         */
        encryptionInTransitProperties?: outputs.hdinsight.EncryptionInTransitPropertiesResponse;
        /**
         * The list of errors.
         */
        errors?: outputs.hdinsight.ErrorsResponse[];
        /**
         * The cluster kafka rest proxy configuration.
         */
        kafkaRestProperties?: outputs.hdinsight.KafkaRestPropertiesResponse;
        /**
         * The minimal supported tls version.
         */
        minSupportedTlsVersion?: string;
        /**
         * The network settings.
         */
        networkSettings?: outputs.hdinsight.NetworkSettingsResponse;
        /**
         * The type of operating system.
         */
        osType?: string;
        /**
         * The provisioning state, which only appears in the response.
         */
        provisioningState?: string;
        /**
         * The quota information.
         */
        quotaInfo?: outputs.hdinsight.QuotaInfoResponse;
        /**
         * The security profile.
         */
        securityProfile?: outputs.hdinsight.SecurityProfileResponse;
        /**
         * The cluster tier.
         */
        tier?: string;
    }

    /**
     * Identity for the cluster.
     */
    export interface ClusterIdentityResponse {
        /**
         * The principal id of cluster identity. This property will only be provided for a system assigned identity.
         */
        principalId: string;
        /**
         * The tenant id associated with the cluster. This property will only be provided for a system assigned identity.
         */
        tenantId: string;
        /**
         * The type of identity used for the cluster. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities.
         */
        type?: string;
        /**
         * The list of user identities associated with the cluster. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
         */
        userAssignedIdentities?: {[key: string]: string};
    }

    /**
     * Describes the compute profile.
     */
    export interface ComputeProfileResponse {
        /**
         * The list of roles in the cluster.
         */
        roles?: outputs.hdinsight.RoleResponse[];
    }

    /**
     * The connectivity properties
     */
    export interface ConnectivityEndpointResponse {
        /**
         * The location of the endpoint.
         */
        location?: string;
        /**
         * The name of the endpoint.
         */
        name?: string;
        /**
         * The port to connect to.
         */
        port?: number;
        /**
         * The protocol of the endpoint.
         */
        protocol?: string;
    }

    /**
     * The data disks groups for the role.
     */
    export interface DataDisksGroupsResponse {
        /**
         * ReadOnly. The DiskSize in GB. Do not set this value.
         */
        diskSizeGB: number;
        /**
         * The number of disks per node.
         */
        disksPerNode?: number;
        /**
         * ReadOnly. The storage account type. Do not set this value.
         */
        storageAccountType: string;
    }

    /**
     * The disk encryption properties
     */
    export interface DiskEncryptionPropertiesResponse {
        /**
         * Algorithm identifier for encryption, default RSA-OAEP.
         */
        encryptionAlgorithm?: string;
        /**
         * Key name that is used for enabling disk encryption.
         */
        keyName?: string;
        /**
         * Specific key version that is used for enabling disk encryption.
         */
        keyVersion?: string;
        /**
         * Resource ID of Managed Identity that is used to access the key vault.
         */
        msiResourceId?: string;
        /**
         * Base key vault URI where the customers key is located eg. https://myvault.vault.azure.net
         */
        vaultUri?: string;
    }

    /**
     * The encryption-in-transit properties.
     */
    export interface EncryptionInTransitPropertiesResponse {
        /**
         * Indicates whether or not inter cluster node communication is encrypted in transit.
         */
        isEncryptionInTransitEnabled?: boolean;
    }

    /**
     * The error message associated with the cluster creation.
     */
    export interface ErrorsResponse {
        /**
         * The error code.
         */
        code?: string;
        /**
         * The error message.
         */
        message?: string;
    }

    /**
     * The hardware profile.
     */
    export interface HardwareProfileResponse {
        /**
         * The size of the VM
         */
        vmSize?: string;
    }

    /**
     * The kafka rest proxy configuration which contains AAD security group information.
     */
    export interface KafkaRestPropertiesResponse {
        /**
         * The information of AAD security group.
         */
        clientGroupInfo?: outputs.hdinsight.ClientGroupInfoResponse;
    }

    /**
     * The ssh username, password, and ssh public key.
     */
    export interface LinuxOperatingSystemProfileResponse {
        /**
         * The password.
         */
        password?: string;
        /**
         * The SSH profile.
         */
        sshProfile?: outputs.hdinsight.SshProfileResponse;
        /**
         * The username.
         */
        username?: string;
    }

    /**
     * The network settings.
     */
    export interface NetworkSettingsResponse {
        /**
         * The mechanism through which the cluster will have outbound access to the public network.
         */
        outboundOnlyPublicNetworkAccessType?: string;
        /**
         * Specifies whether public network access is enabled for inbound and outbound, or outbound only.
         */
        publicNetworkAccess?: string;
    }

    /**
     * The Linux operation systems profile.
     */
    export interface OsProfileResponse {
        /**
         * The Linux OS profile.
         */
        linuxOperatingSystemProfile?: outputs.hdinsight.LinuxOperatingSystemProfileResponse;
    }

    /**
     * The quota properties for the cluster.
     */
    export interface QuotaInfoResponse {
        /**
         * The cores used by the cluster.
         */
        coresUsed?: number;
    }

    /**
     * Describes a role on the cluster.
     */
    export interface RoleResponse {
        /**
         * The autoscale configurations.
         */
        autoscale?: outputs.hdinsight.AutoscaleResponse;
        /**
         * The data disks groups for the role.
         */
        dataDisksGroups?: outputs.hdinsight.DataDisksGroupsResponse[];
        /**
         * The hardware profile.
         */
        hardwareProfile?: outputs.hdinsight.HardwareProfileResponse;
        /**
         * The minimum instance count of the cluster.
         */
        minInstanceCount?: number;
        /**
         * The name of the role.
         */
        name?: string;
        /**
         * The operating system profile.
         */
        osProfile?: outputs.hdinsight.OsProfileResponse;
        /**
         * The list of script actions on the role.
         */
        scriptActions?: outputs.hdinsight.ScriptActionResponse[];
        /**
         * The instance count of the cluster.
         */
        targetInstanceCount?: number;
        /**
         * The virtual network profile.
         */
        virtualNetworkProfile?: outputs.hdinsight.VirtualNetworkProfileResponse;
    }

    /**
     * Describes a script action on a running cluster.
     */
    export interface RuntimeScriptActionResponse {
        /**
         * The application name of the script action, if any.
         */
        applicationName: string;
        /**
         * The name of the script action.
         */
        name: string;
        /**
         * The parameters for the script
         */
        parameters?: string;
        /**
         * The list of roles where script will be executed.
         */
        roles: string[];
        /**
         * The URI to the script.
         */
        uri: string;
    }

    /**
     * Describes a script action on role on the cluster.
     */
    export interface ScriptActionResponse {
        /**
         * The name of the script action.
         */
        name: string;
        /**
         * The parameters for the script provided.
         */
        parameters: string;
        /**
         * The URI to the script.
         */
        uri: string;
    }

    /**
     * The security profile which contains Ssh public key for the HDInsight cluster.
     */
    export interface SecurityProfileResponse {
        /**
         * The resource ID of the user's Azure Active Directory Domain Service.
         */
        aaddsResourceId?: string;
        /**
         * Optional. The Distinguished Names for cluster user groups
         */
        clusterUsersGroupDNs?: string[];
        /**
         * The directory type.
         */
        directoryType?: string;
        /**
         * The organization's active directory domain.
         */
        domain?: string;
        /**
         * The domain admin password.
         */
        domainUserPassword?: string;
        /**
         * The domain user account that will have admin privileges on the cluster.
         */
        domainUsername?: string;
        /**
         * The LDAPS protocol URLs to communicate with the Active Directory.
         */
        ldapsUrls?: string[];
        /**
         * User assigned identity that has permissions to read and create cluster-related artifacts in the user's AADDS.
         */
        msiResourceId?: string;
        /**
         * The organizational unit within the Active Directory to place the cluster and service accounts.
         */
        organizationalUnitDN?: string;
    }

    /**
     * The list of SSH public keys.
     */
    export interface SshProfileResponse {
        /**
         * The list of SSH public keys.
         */
        publicKeys?: outputs.hdinsight.SshPublicKeyResponse[];
    }

    /**
     * The SSH public key for the cluster nodes.
     */
    export interface SshPublicKeyResponse {
        /**
         * The certificate for SSH.
         */
        certificateData?: string;
    }

    /**
     * The virtual network properties.
     */
    export interface VirtualNetworkProfileResponse {
        /**
         * The ID of the virtual network.
         */
        id?: string;
        /**
         * The name of the subnet.
         */
        subnet?: string;
    }
}

export namespace healthcareapis {
    /**
     * Setting indicating whether the service has a managed identity associated with it.
     */
    export interface ResourceResponseProperties {
        /**
         * The principal ID of the resource identity.
         */
        principalId: string;
        /**
         * The tenant ID of the resource.
         */
        tenantId: string;
        /**
         * Type of identity being specified, currently SystemAssigned and None are allowed.
         */
        type?: string;
    }

    /**
     * The access policies of the service instance.
     */
    export interface ServiceAccessPoliciesInfoResponse {
    }

    /**
     * Authentication configuration information
     */
    export interface ServiceAuthenticationConfigurationInfoResponse {
        /**
         * The audience url for the service
         */
        audience?: string;
        /**
         * The authority url for the service
         */
        authority?: string;
        /**
         * If the SMART on FHIR proxy is enabled
         */
        smartProxyEnabled?: boolean;
    }

    /**
     * The settings for the CORS configuration of the service instance.
     */
    export interface ServiceCorsConfigurationInfoResponse {
        /**
         * If credentials are allowed via CORS.
         */
        allowCredentials?: boolean;
        /**
         * The headers to be allowed via CORS.
         */
        headers?: string[];
        /**
         * The max age to be allowed via CORS.
         */
        maxAge?: number;
        /**
         * The methods to be allowed via CORS.
         */
        methods?: string[];
        /**
         * The origins to be allowed via CORS.
         */
        origins?: string[];
    }

    /**
     * The settings for the Cosmos DB database backing the service.
     */
    export interface ServiceCosmosDbConfigurationInfoResponse {
        /**
         * The provisioned throughput for the backing database.
         */
        offerThroughput?: number;
    }

    /**
     * Export operation configuration information
     */
    export interface ServiceExportConfigurationInfoResponse {
        /**
         * The name of the default export storage account.
         */
        storageAccountName?: string;
    }

    /**
     * The properties of a service instance.
     */
    export interface ServicesPropertiesResponse {
        /**
         * The access policies of the service instance.
         */
        accessPolicies?: outputs.healthcareapis.ServiceAccessPoliciesInfoResponse;
        /**
         * The authentication configuration for the service instance.
         */
        authenticationConfiguration?: outputs.healthcareapis.ServiceAuthenticationConfigurationInfoResponse;
        /**
         * The settings for the CORS configuration of the service instance.
         */
        corsConfiguration?: outputs.healthcareapis.ServiceCorsConfigurationInfoResponse;
        /**
         * The settings for the Cosmos DB database backing the service.
         */
        cosmosDbConfiguration?: outputs.healthcareapis.ServiceCosmosDbConfigurationInfoResponse;
        /**
         * The settings for the export operation of the service instance.
         */
        exportConfiguration?: outputs.healthcareapis.ServiceExportConfigurationInfoResponse;
        /**
         * The provisioning state.
         */
        provisioningState: string;
    }
}

export namespace hybridcompute {
    /**
     * Information about the guest configuration assignment.
     */
    export interface AssignmentInfoResponse {
        /**
         * Information about the configuration.
         */
        configuration?: outputs.hybridcompute.ConfigurationInfoResponse;
        /**
         * Name of the guest configuration assignment.
         */
        name: string;
    }

    /**
     * Reason and code for the compliance of the guest configuration assignment resource.
     */
    export interface AssignmentReportResourceComplianceReasonResponse {
        /**
         * Code for the compliance of the guest configuration assignment resource.
         */
        code: string;
        /**
         * Reason for the compliance of the guest configuration assignment resource.
         */
        phrase: string;
    }

    /**
     * The guest configuration assignment resource.
     */
    export interface AssignmentReportResourceResponse {
        /**
         * A value indicating compliance status of the machine for the assigned guest configuration.
         */
        complianceStatus: string;
        /**
         * Properties of a guest configuration assignment resource.
         */
        properties: {[key: string]: string};
        /**
         * Compliance reason and reason code for a resource.
         */
        reasons?: outputs.hybridcompute.AssignmentReportResourceComplianceReasonResponse[];
    }

    export interface AssignmentReportResponse {
        /**
         * Configuration details of the guest configuration assignment.
         */
        assignment?: outputs.hybridcompute.AssignmentInfoResponse;
        /**
         * A value indicating compliance status of the machine for the assigned guest configuration.
         */
        complianceStatus: string;
        /**
         * End date and time of the guest configuration assignment compliance status check.
         */
        endTime: string;
        /**
         * ARM resource id of the report for the guest configuration assignment.
         */
        id: string;
        /**
         * Type of report, Consistency or Initial
         */
        operationType: string;
        /**
         * GUID that identifies the guest configuration assignment report under a subscription, resource group.
         */
        reportId: string;
        /**
         * The list of resources for which guest configuration assignment compliance is checked.
         */
        resources?: outputs.hybridcompute.AssignmentReportResourceResponse[];
        /**
         * Start date and time of the guest configuration assignment compliance status check.
         */
        startTime: string;
        /**
         * Information about the VM.
         */
        vm?: outputs.hybridcompute.VMInfoResponse;
    }

    /**
     * Information about the configuration.
     */
    export interface ConfigurationInfoResponse {
        /**
         * Name of the configuration.
         */
        name: string;
        /**
         * Version of the configuration.
         */
        version: string;
    }

    /**
     * Represents a configuration parameter.
     */
    export interface ConfigurationParameterResponse {
        /**
         * Name of the configuration parameter.
         */
        name?: string;
        /**
         * Value of the configuration parameter.
         */
        value?: string;
    }

    /**
     * Configuration setting of LCM (Local Configuration Manager).
     */
    export interface ConfigurationSettingResponse {
        /**
         * Specifies what happens after a reboot during the application of a configuration. The possible values are ContinueConfiguration and StopConfiguration
         */
        actionAfterReboot?: string;
        /**
         * If true - new configurations downloaded from the pull service are allowed to overwrite the old ones on the target node. Otherwise, false
         */
        allowModuleOverwrite?: string;
        /**
         * Specifies how the LCM(Local Configuration Manager) actually applies the configuration to the target nodes. Possible values are ApplyOnly, ApplyAndMonitor, and ApplyAndAutoCorrect.
         */
        configurationMode?: string;
        /**
         * How often, in minutes, the current configuration is checked and applied. This property is ignored if the ConfigurationMode property is set to ApplyOnly. The default value is 15.
         */
        configurationModeFrequencyMins?: number;
        /**
         * Set this to true to automatically reboot the node after a configuration that requires reboot is applied. Otherwise, you will have to manually reboot the node for any configuration that requires it. The default value is false. To use this setting when a reboot condition is enacted by something other than DSC (such as Windows Installer), combine this setting with the xPendingReboot module.
         */
        rebootIfNeeded?: string;
        /**
         * The time interval, in minutes, at which the LCM checks a pull service to get updated configurations. This value is ignored if the LCM is not configured in pull mode. The default value is 30.
         */
        refreshFrequencyMins?: number;
    }

    /**
     * Guest configuration assignment properties.
     */
    export interface GuestConfigurationAssignmentPropertiesResponse {
        /**
         * Combined hash of the configuration package and parameters.
         */
        assignmentHash: string;
        /**
         * A value indicating compliance status of the machine for the assigned guest configuration.
         */
        complianceStatus: string;
        /**
         * The source which initiated the guest configuration assignment. Ex: Azure Policy
         */
        context?: string;
        /**
         * The guest configuration to assign.
         */
        guestConfiguration?: outputs.hybridcompute.GuestConfigurationNavigationResponse;
        /**
         * Date and time when last compliance status was checked.
         */
        lastComplianceStatusChecked: string;
        /**
         * Last reported guest configuration assignment report.
         */
        latestAssignmentReport?: outputs.hybridcompute.AssignmentReportResponse;
        /**
         * Id of the latest report for the guest configuration assignment. 
         */
        latestReportId: string;
        /**
         * The provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * VM resource Id.
         */
        targetResourceId: string;
    }

    /**
     * Guest configuration is an artifact that encapsulates DSC configuration and its dependencies. The artifact is a zip file containing DSC configuration (as MOF) and dependent resources and other dependencies like modules.
     */
    export interface GuestConfigurationNavigationResponse {
        /**
         * The configuration parameters for the guest configuration.
         */
        configurationParameter?: outputs.hybridcompute.ConfigurationParameterResponse[];
        /**
         * The configuration setting for the guest configuration.
         */
        configurationSetting?: outputs.hybridcompute.ConfigurationSettingResponse;
        /**
         * Combined hash of the guest configuration package and configuration parameters.
         */
        contentHash: string;
        /**
         * Uri of the storage where guest configuration package is uploaded.
         */
        contentUri: string;
        /**
         * Kind of the guest configuration. For example:DSC
         */
        kind?: string;
        /**
         * Name of the guest configuration.
         */
        name?: string;
        /**
         * Version of the guest configuration.
         */
        version?: string;
    }

    /**
     * Information about the VM.
     */
    export interface VMInfoResponse {
        /**
         * Azure resource Id of the VM.
         */
        id: string;
        /**
         * UUID(Universally Unique Identifier) of the VM.
         */
        uuid: string;
    }
}

export namespace hybriddata {
    /**
     * The pair of customer secret.
     */
    export interface CustomerSecretResponse {
        /**
         * The encryption algorithm used to encrypt data.
         */
        algorithm: string;
        /**
         * The identifier to the data service input object which this secret corresponds to.
         */
        keyIdentifier: string;
        /**
         * It contains the encrypted customer secret.
         */
        keyValue: string;
    }

    /**
     * Data Store for sources and sinks
     */
    export interface DataStorePropertiesResponse {
        /**
         * List of customer secrets containing a key identifier and key value. The key identifier is a way for the specific data source to understand the key. Value contains customer secret encrypted by the encryptionKeys.
         */
        customerSecrets?: outputs.hybriddata.CustomerSecretResponse[];
        /**
         * The arm id of the data store type.
         */
        dataStoreTypeId: string;
        /**
         * A generic json used differently by each data source type.
         */
        extendedProperties?: {[key: string]: string};
        /**
         * Arm Id for the manager resource to which the data source is associated. This is optional.
         */
        repositoryId?: string;
        /**
         * State of the data source.
         */
        state: string;
    }

    /**
     * Job Definition
     */
    export interface JobDefinitionPropertiesResponse {
        /**
         * List of customer secrets containing a key identifier and key value. The key identifier is a way for the specific data source to understand the key. Value contains customer secret encrypted by the encryptionKeys.
         */
        customerSecrets?: outputs.hybriddata.CustomerSecretResponse[];
        /**
         * A generic json used differently by each data service type.
         */
        dataServiceInput?: {[key: string]: string};
        /**
         * Data Sink Id associated to the job definition.
         */
        dataSinkId: string;
        /**
         * Data Source Id associated to the job definition.
         */
        dataSourceId: string;
        /**
         * Last modified time of the job definition.
         */
        lastModifiedTime?: string;
        /**
         * This is the preferred geo location for the job to run.
         */
        runLocation?: string;
        /**
         * Schedule for running the job definition
         */
        schedules?: outputs.hybriddata.ScheduleResponse[];
        /**
         * State of the job definition.
         */
        state: string;
        /**
         * Enum to detect if user confirmation is required. If not passed will default to NotRequired.
         */
        userConfirmation?: string;
    }

    /**
     * Schedule for the job run.
     */
    export interface ScheduleResponse {
        /**
         * Name of the schedule.
         */
        name?: string;
        /**
         * A list of repetition intervals in ISO 8601 format.
         */
        policyList?: string[];
    }

    /**
     * The sku type.
     */
    export interface SkuResponse {
        /**
         * The sku name. Required for data manager creation, optional for update.
         */
        name?: string;
        /**
         * The sku tier. This is based on the SKU name.
         */
        tier?: string;
    }
}

export namespace importexport {
    /**
     * BitLocker recovery key or password to the specified drive
     */
    export interface DriveBitLockerKeyResponse {
        /**
         * BitLocker recovery key or password
         */
        bitLockerKey?: string;
        /**
         * Drive ID
         */
        driveId?: string;
    }

    /**
     * Provides information about the drive's status
     */
    export interface DriveStatusResponse {
        /**
         * The BitLocker key used to encrypt the drive.
         */
        bitLockerKey?: string;
        /**
         * Bytes successfully transferred for the drive.
         */
        bytesSucceeded?: number;
        /**
         * Detailed status about the data transfer process. This field is not returned in the response until the drive is in the Transferring state.
         */
        copyStatus?: string;
        /**
         * The drive header hash value.
         */
        driveHeaderHash?: string;
        /**
         * The drive's hardware serial number, without spaces.
         */
        driveId?: string;
        /**
         * A URI that points to the blob containing the error log for the data transfer operation.
         */
        errorLogUri?: string;
        /**
         * The relative path of the manifest file on the drive. 
         */
        manifestFile?: string;
        /**
         * The Base16-encoded MD5 hash of the manifest file on the drive.
         */
        manifestHash?: string;
        /**
         * A URI that points to the blob containing the drive manifest file. 
         */
        manifestUri?: string;
        /**
         * Percentage completed for the drive. 
         */
        percentComplete?: number;
        /**
         * The drive's current state. 
         */
        state?: string;
        /**
         * A URI that points to the blob containing the verbose log for the data transfer operation. 
         */
        verboseLogUri?: string;
    }

    /**
     * A property containing information about the blobs to be exported for an export job. This property is required for export jobs, but must not be specified for import jobs.
     */
    export interface ExportResponse {
        /**
         * A list of the blobs to be exported.
         */
        blobList?: outputs.importexport.ExportResponseProperties;
        /**
         * The relative URI to the block blob that contains the list of blob paths or blob path prefixes as defined above, beginning with the container name. If the blob is in root container, the URI must begin with $root. 
         */
        blobListblobPath?: string;
    }

    /**
     * A list of the blobs to be exported.
     */
    export interface ExportResponseProperties {
        /**
         * A collection of blob-path strings.
         */
        blobPath?: string[];
        /**
         * A collection of blob-prefix strings.
         */
        blobPathPrefix?: string[];
    }

    /**
     * Specifies the job properties
     */
    export interface JobDetailsResponse {
        /**
         * Default value is false. Indicates whether the manifest files on the drives should be copied to block blobs.
         */
        backupDriveManifest?: boolean;
        /**
         * Indicates whether a request has been submitted to cancel the job.
         */
        cancelRequested?: boolean;
        /**
         * Contains information about the package being shipped by the customer to the Microsoft data center. 
         */
        deliveryPackage?: outputs.importexport.PackageInfomationResponse;
        /**
         * The virtual blob directory to which the copy logs and backups of drive manifest files (if enabled) will be stored.
         */
        diagnosticsPath?: string;
        /**
         * List of up to ten drives that comprise the job. The drive list is a required element for an import job; it is not specified for export jobs.
         */
        driveList?: outputs.importexport.DriveStatusResponse[];
        /**
         * A property containing information about the blobs to be exported for an export job. This property is included for export jobs only.
         */
        export?: outputs.importexport.ExportResponse;
        /**
         * A blob path that points to a block blob containing a list of blob names that were not exported due to insufficient drive space. If all blobs were exported successfully, then this element is not included in the response.
         */
        incompleteBlobListUri?: string;
        /**
         * The type of job
         */
        jobType?: string;
        /**
         * Default value is Error. Indicates whether error logging or verbose logging will be enabled.
         */
        logLevel?: string;
        /**
         * Overall percentage completed for the job.
         */
        percentComplete?: number;
        /**
         * Specifies the provisioning state of the job.
         */
        provisioningState?: string;
        /**
         * Specifies the return address information for the job. 
         */
        returnAddress?: outputs.importexport.ReturnAddressResponse;
        /**
         * Contains information about the package being shipped from the Microsoft data center to the customer to return the drives. The format is the same as the deliveryPackage property above. This property is not included if the drives have not yet been returned. 
         */
        returnPackage?: outputs.importexport.PackageInfomationResponse;
        /**
         * Specifies the return carrier and customer's account with the carrier. 
         */
        returnShipping?: outputs.importexport.ReturnShippingResponse;
        /**
         * Contains information about the Microsoft datacenter to which the drives should be shipped. 
         */
        shippingInformation?: outputs.importexport.ShippingInformationResponse;
        /**
         * Current state of the job.
         */
        state?: string;
        /**
         * The resource identifier of the storage account where data will be imported to or exported from.
         */
        storageAccountId?: string;
    }

    /**
     * Contains information about the package being shipped by the customer to the Microsoft data center.
     */
    export interface PackageInfomationResponse {
        /**
         * The name of the carrier that is used to ship the import or export drives.
         */
        carrierName: string;
        /**
         * The number of drives included in the package.
         */
        driveCount: number;
        /**
         * The date when the package is shipped.
         */
        shipDate: string;
        /**
         * The tracking number of the package.
         */
        trackingNumber: string;
    }

    /**
     * Specifies the return address information for the job.
     */
    export interface ReturnAddressResponse {
        /**
         * The city name to use when returning the drives.
         */
        city: string;
        /**
         * The country or region to use when returning the drives. 
         */
        countryOrRegion: string;
        /**
         * Email address of the recipient of the returned drives.
         */
        email: string;
        /**
         * Phone number of the recipient of the returned drives.
         */
        phone: string;
        /**
         * The postal code to use when returning the drives.
         */
        postalCode: string;
        /**
         * The name of the recipient who will receive the hard drives when they are returned. 
         */
        recipientName: string;
        /**
         * The state or province to use when returning the drives.
         */
        stateOrProvince?: string;
        /**
         * The first line of the street address to use when returning the drives. 
         */
        streetAddress1: string;
        /**
         * The second line of the street address to use when returning the drives. 
         */
        streetAddress2?: string;
    }

    /**
     * Specifies the return carrier and customer's account with the carrier.
     */
    export interface ReturnShippingResponse {
        /**
         * The customer's account number with the carrier.
         */
        carrierAccountNumber: string;
        /**
         * The carrier's name.
         */
        carrierName: string;
    }

    /**
     * Contains information about the Microsoft datacenter to which the drives should be shipped.
     */
    export interface ShippingInformationResponse {
        /**
         * The city name to use when returning the drives.
         */
        city: string;
        /**
         * The country or region to use when returning the drives. 
         */
        countryOrRegion: string;
        /**
         * Phone number of the recipient of the returned drives.
         */
        phone?: string;
        /**
         * The postal code to use when returning the drives.
         */
        postalCode: string;
        /**
         * The name of the recipient who will receive the hard drives when they are returned. 
         */
        recipientName: string;
        /**
         * The state or province to use when returning the drives.
         */
        stateOrProvince: string;
        /**
         * The first line of the street address to use when returning the drives. 
         */
        streetAddress1: string;
        /**
         * The second line of the street address to use when returning the drives. 
         */
        streetAddress2?: string;
    }
}

export namespace insights {
    /**
     * Properties that define an Application Insights component resource.
     */
    export interface ApplicationInsightsComponentPropertiesResponse {
        /**
         * Application Insights Unique ID for your Application.
         */
        AppId: string;
        /**
         * The unique ID of your application. This field mirrors the 'Name' field and cannot be changed.
         */
        ApplicationId: string;
        /**
         * Type of application being monitored.
         */
        Application_Type: string;
        /**
         * Application Insights component connection string.
         */
        ConnectionString: string;
        /**
         * Creation Date for the Application Insights component, in ISO 8601 format.
         */
        CreationDate: string;
        /**
         * Disable IP masking.
         */
        DisableIpMasking?: boolean;
        /**
         * Used by the Application Insights system to determine what kind of flow this component was created by. This is to be set to 'Bluefield' when creating/updating a component via the REST API.
         */
        Flow_Type?: string;
        /**
         * The unique application ID created when a new application is added to HockeyApp, used for communications with HockeyApp.
         */
        HockeyAppId?: string;
        /**
         * Token used to authenticate communications with between Application Insights and HockeyApp.
         */
        HockeyAppToken: string;
        /**
         * Purge data immediately after 30 days.
         */
        ImmediatePurgeDataOn30Days?: boolean;
        /**
         * Indicates the flow of the ingestion.
         */
        IngestionMode?: string;
        /**
         * Application Insights Instrumentation key. A read-only value that applications can use to identify the destination for all telemetry sent to Azure Application Insights. This value will be supplied upon construction of each new Application Insights component.
         */
        InstrumentationKey: string;
        /**
         * List of linked private link scope resources.
         */
        PrivateLinkScopedResources: outputs.insights.PrivateLinkScopedResourceResponse[];
        /**
         * Describes what tool created this Application Insights component. Customers using this API should set this to the default 'rest'.
         */
        Request_Source?: string;
        /**
         * Retention period in days.
         */
        RetentionInDays?: number;
        /**
         * Percentage of the data produced by the application being monitored that is being sampled for Application Insights telemetry.
         */
        SamplingPercentage?: number;
        /**
         * Azure Tenant Id.
         */
        TenantId: string;
        /**
         * Current state of this component: whether or not is has been provisioned within the resource group it is defined. Users cannot change this value but are able to read from it. Values will include Succeeded, Deploying, Canceled, and Failed.
         */
        provisioningState: string;
    }

    /**
     * An alert action.
     */
    export interface MetricAlertActionResponse {
        /**
         * the id of the action group to use.
         */
        actionGroupId?: string;
        /**
         * The properties of a webhook object.
         */
        webHookProperties?: {[key: string]: string};
    }

    /**
     * The rule criteria that defines the conditions of the alert rule.
     */
    export interface MetricAlertCriteriaResponse {
    }

    /**
     * An alert rule.
     */
    export interface MetricAlertPropertiesResponse {
        /**
         * the array of actions that are performed when the alert rule becomes active, and when an alert condition is resolved.
         */
        actions?: outputs.insights.MetricAlertActionResponse[];
        /**
         * the flag that indicates whether the alert should be auto resolved or not. The default is true.
         */
        autoMitigate?: boolean;
        /**
         * defines the specific alert criteria information.
         */
        criteria: outputs.insights.MetricAlertCriteriaResponse;
        /**
         * the description of the metric alert that will be included in the alert email.
         */
        description: string;
        /**
         * the flag that indicates whether the metric alert is enabled.
         */
        enabled: boolean;
        /**
         * how often the metric alert is evaluated represented in ISO 8601 duration format.
         */
        evaluationFrequency: string;
        /**
         * Last time the rule was updated in ISO8601 format.
         */
        lastUpdatedTime: string;
        /**
         * the list of resource id's that this metric alert is scoped to.
         */
        scopes?: string[];
        /**
         * Alert severity {0, 1, 2, 3, 4}
         */
        severity: number;
        /**
         * the region of the target resource(s) on which the alert is created/updated. Mandatory for MultipleResourceMultipleMetricCriteria.
         */
        targetResourceRegion?: string;
        /**
         * the resource type of the target resource(s) on which the alert is created/updated. Mandatory for MultipleResourceMultipleMetricCriteria.
         */
        targetResourceType?: string;
        /**
         * the period of time (in ISO 8601 duration format) that is used to monitor alert activity based on the threshold.
         */
        windowSize: string;
    }

    /**
     * The private link scope resource reference.
     */
    export interface PrivateLinkScopedResourceResponse {
        /**
         * The full resource Id of the private link scope resource.
         */
        ResourceId?: string;
        /**
         * The private link scope unique Identifier.
         */
        ScopeId?: string;
    }

    /**
     * Geo-physical location to run a web test from. You must specify one or more locations for the test to run from.
     */
    export interface WebTestGeolocationResponse {
        /**
         * Location ID for the webtest to run from.
         */
        Id?: string;
    }

    /**
     * Metadata describing a web test for an Azure resource.
     */
    export interface WebTestPropertiesResponse {
        /**
         * An XML configuration specification for a WebTest.
         */
        Configuration?: outputs.insights.WebTestPropertiesResponseProperties;
        /**
         * Purpose/user defined descriptive test for this WebTest.
         */
        Description?: string;
        /**
         * Is the test actively being monitored.
         */
        Enabled?: boolean;
        /**
         * Interval in seconds between test runs for this WebTest. Default value is 300.
         */
        Frequency?: number;
        /**
         * The kind of web test this is, valid choices are ping and multistep.
         */
        Kind: string;
        /**
         * A list of where to physically run the tests from to give global coverage for accessibility of your application.
         */
        Locations: outputs.insights.WebTestGeolocationResponse[];
        /**
         * User defined name if this WebTest.
         */
        Name: string;
        /**
         * Allow for retries should this WebTest fail.
         */
        RetryEnabled?: boolean;
        /**
         * Unique ID of this WebTest. This is typically the same value as the Name field.
         */
        SyntheticMonitorId: string;
        /**
         * Seconds until this WebTest will timeout and fail. Default value is 30.
         */
        Timeout?: number;
        /**
         * Current state of this component, whether or not is has been provisioned within the resource group it is defined. Users cannot change this value but are able to read from it. Values will include Succeeded, Deploying, Canceled, and Failed.
         */
        provisioningState: string;
    }

    /**
     * An XML configuration specification for a WebTest.
     */
    export interface WebTestPropertiesResponseProperties {
        /**
         * The XML specification of a WebTest to run against an application.
         */
        WebTest?: string;
    }

}

export namespace iotcentral {
    /**
     * The properties of an IoT Central application.
     */
    export interface AppPropertiesResponse {
        /**
         * The ID of the application.
         */
        applicationId: string;
        /**
         * The display name of the application.
         */
        displayName?: string;
        /**
         * The subdomain of the application.
         */
        subdomain?: string;
        /**
         * The ID of the application template, which is a blueprint that defines the characteristics and behaviors of an application. Optional; if not specified, defaults to a blank blueprint and allows the application to be defined from scratch.
         */
        template?: string;
    }

    /**
     * Information about the SKU of the IoT Central application.
     */
    export interface AppSkuInfoResponse {
        /**
         * The name of the SKU.
         */
        name: string;
    }

}

export namespace keyvault {
    /**
     * An identity that have access to the key vault. All identities in the array must use the same tenant ID as the key vault's tenant ID.
     */
    export interface AccessPolicyEntryResponse {
        /**
         *  Application ID of the client making request on behalf of a principal
         */
        applicationId?: string;
        /**
         * The object ID of a user, service principal or security group in the Azure Active Directory tenant for the vault. The object ID must be unique for the list of access policies.
         */
        objectId: string;
        /**
         * Permissions the identity has for keys, secrets and certificates.
         */
        permissions: outputs.keyvault.PermissionsResponse;
        /**
         * The Azure Active Directory tenant ID that should be used for authenticating requests to the key vault.
         */
        tenantId: string;
    }

    /**
     * A rule governing the accessibility of a vault from a specific ip address or ip range.
     */
    export interface IPRuleResponse {
        /**
         * An IPv4 address range in CIDR notation, such as '124.56.78.91' (simple IP address) or '124.56.78.0/24' (all addresses that start with 124.56.78).
         */
        value: string;
    }

    /**
     * A set of rules governing the network accessibility of a vault.
     */
    export interface NetworkRuleSetResponse {
        /**
         * Tells what traffic can bypass network rules. This can be 'AzureServices' or 'None'.  If not specified the default is 'AzureServices'.
         */
        bypass?: string;
        /**
         * The default action when no rule from ipRules and from virtualNetworkRules match. This is only used after the bypass property has been evaluated.
         */
        defaultAction?: string;
        /**
         * The list of IP address rules.
         */
        ipRules?: outputs.keyvault.IPRuleResponse[];
        /**
         * The list of virtual network rules.
         */
        virtualNetworkRules?: outputs.keyvault.VirtualNetworkRuleResponse[];
    }

    /**
     * Permissions the identity has for keys, secrets, certificates and storage.
     */
    export interface PermissionsResponse {
        /**
         * Permissions to certificates
         */
        certificates?: string[];
        /**
         * Permissions to keys
         */
        keys?: string[];
        /**
         * Permissions to secrets
         */
        secrets?: string[];
        /**
         * Permissions to storage accounts
         */
        storage?: string[];
    }

    /**
     * Private endpoint connection item.
     */
    export interface PrivateEndpointConnectionItemResponse {
        /**
         * Private endpoint connection properties.
         */
        properties?: outputs.keyvault.PrivateEndpointConnectionPropertiesResponse;
    }

    /**
     * Properties of the private endpoint connection resource.
     */
    export interface PrivateEndpointConnectionPropertiesResponse {
        /**
         * Properties of the private endpoint object.
         */
        privateEndpoint?: outputs.keyvault.PrivateEndpointResponse;
        /**
         * Approval state of the private link connection.
         */
        privateLinkServiceConnectionState?: outputs.keyvault.PrivateLinkServiceConnectionStateResponse;
        /**
         * Provisioning state of the private endpoint connection.
         */
        provisioningState?: string;
    }

    /**
     * Private endpoint object properties.
     */
    export interface PrivateEndpointResponse {
        /**
         * Full identifier of the private endpoint resource.
         */
        id: string;
    }

    /**
     * An object that represents the approval state of the private link connection.
     */
    export interface PrivateLinkServiceConnectionStateResponse {
        /**
         * A message indicating if changes on the service provider require any updates on the consumer.
         */
        actionRequired?: string;
        /**
         * The reason for approval or rejection.
         */
        description?: string;
        /**
         * Indicates whether the connection has been approved, rejected or removed by the key vault owner.
         */
        status?: string;
    }

    /**
     * SKU details
     */
    export interface SkuResponse {
        /**
         * SKU family name
         */
        family: string;
        /**
         * SKU name to specify whether the key vault is a standard vault or a premium vault.
         */
        name: string;
    }

    /**
     * Properties of the vault
     */
    export interface VaultPropertiesResponse {
        /**
         * An array of 0 to 1024 identities that have access to the key vault. All identities in the array must use the same tenant ID as the key vault's tenant ID. When `createMode` is set to `recover`, access policies are not required. Otherwise, access policies are required.
         */
        accessPolicies?: outputs.keyvault.AccessPolicyEntryResponse[];
        /**
         * The vault's create mode to indicate whether the vault need to be recovered or not.
         */
        createMode?: string;
        /**
         * Property specifying whether protection against purge is enabled for this vault. Setting this property to true activates protection against purge for this vault and its content - only the Key Vault service may initiate a hard, irrecoverable deletion. The setting is effective only if soft delete is also enabled. Enabling this functionality is irreversible - that is, the property does not accept false as its value.
         */
        enablePurgeProtection?: boolean;
        /**
         * Property that controls how data actions are authorized. When true, the key vault will use Role Based Access Control (RBAC) for authorization of data actions, and the access policies specified in vault properties will be  ignored (warning: this is a preview feature). When false, the key vault will use the access policies specified in vault properties, and any policy stored on Azure Resource Manager will be ignored. If null or not specified, the vault is created with the default value of false. Note that management actions are always authorized with RBAC.
         */
        enableRbacAuthorization?: boolean;
        /**
         * Property to specify whether the 'soft delete' functionality is enabled for this key vault. If it's not set to any value(true or false) when creating new key vault, it will be set to true by default. Once set to true, it cannot be reverted to false.
         */
        enableSoftDelete?: boolean;
        /**
         * Property to specify whether Azure Virtual Machines are permitted to retrieve certificates stored as secrets from the key vault.
         */
        enabledForDeployment?: boolean;
        /**
         * Property to specify whether Azure Disk Encryption is permitted to retrieve secrets from the vault and unwrap keys.
         */
        enabledForDiskEncryption?: boolean;
        /**
         * Property to specify whether Azure Resource Manager is permitted to retrieve secrets from the key vault.
         */
        enabledForTemplateDeployment?: boolean;
        /**
         * Rules governing the accessibility of the key vault from specific network locations.
         */
        networkAcls?: outputs.keyvault.NetworkRuleSetResponse;
        /**
         * List of private endpoint connections associated with the key vault.
         */
        privateEndpointConnections: outputs.keyvault.PrivateEndpointConnectionItemResponse[];
        /**
         * SKU details
         */
        sku: outputs.keyvault.SkuResponse;
        /**
         * softDelete data retention days. It accepts >=7 and <=90.
         */
        softDeleteRetentionInDays?: number;
        /**
         * The Azure Active Directory tenant ID that should be used for authenticating requests to the key vault.
         */
        tenantId: string;
        /**
         * The URI of the vault for performing operations on keys and secrets.
         */
        vaultUri?: string;
    }

    /**
     * A rule governing the accessibility of a vault from a specific virtual network.
     */
    export interface VirtualNetworkRuleResponse {
        /**
         * Full resource id of a vnet subnet, such as '/subscriptions/subid/resourceGroups/rg1/providers/Microsoft.Network/virtualNetworks/test-vnet/subnets/subnet1'.
         */
        id: string;
    }
}

export namespace kusto {
    /**
     * Class representing the an attached database configuration properties of kind specific.
     */
    export interface AttachedDatabaseConfigurationPropertiesResponse {
        /**
         * The list of databases from the clusterResourceId which are currently attached to the cluster.
         */
        attachedDatabaseNames: string[];
        /**
         * The resource id of the cluster where the databases you would like to attach reside.
         */
        clusterResourceId: string;
        /**
         * The name of the database which you would like to attach, use * if you want to follow all current and future databases.
         */
        databaseName: string;
        /**
         * The default principals modification kind
         */
        defaultPrincipalsModificationKind: string;
        /**
         * The provisioned state of the resource.
         */
        provisioningState: string;
    }

    /**
     * Azure SKU definition.
     */
    export interface AzureSkuResponse {
        /**
         * The number of instances of the cluster.
         */
        capacity?: number;
        /**
         * SKU name.
         */
        name: string;
        /**
         * SKU tier.
         */
        tier: string;
    }

    /**
     * A class representing cluster principal property.
     */
    export interface ClusterPrincipalPropertiesResponse {
        /**
         * The principal ID assigned to the cluster principal. It can be a user email, application ID, or security group name.
         */
        principalId: string;
        /**
         * The principal name
         */
        principalName: string;
        /**
         * Principal type.
         */
        principalType: string;
        /**
         * The provisioned state of the resource.
         */
        provisioningState: string;
        /**
         * Cluster principal role.
         */
        role: string;
        /**
         * The tenant id of the principal
         */
        tenantId?: string;
        /**
         * The tenant name of the principal
         */
        tenantName: string;
    }

    /**
     * Class representing the Kusto cluster properties.
     */
    export interface ClusterPropertiesResponse {
        /**
         * The cluster data ingestion URI.
         */
        dataIngestionUri: string;
        /**
         * A boolean value that indicates if the cluster's disks are encrypted.
         */
        enableDiskEncryption?: boolean;
        /**
         * A boolean value that indicates if double encryption is enabled.
         */
        enableDoubleEncryption?: boolean;
        /**
         * A boolean value that indicates if the purge operations are enabled.
         */
        enablePurge?: boolean;
        /**
         * A boolean value that indicates if the streaming ingest is enabled.
         */
        enableStreamingIngest?: boolean;
        /**
         * KeyVault properties for the cluster encryption.
         */
        keyVaultProperties?: outputs.kusto.KeyVaultPropertiesResponse;
        /**
         * List of the cluster's language extensions.
         */
        languageExtensions: outputs.kusto.LanguageExtensionsListResponse;
        /**
         * Optimized auto scale definition.
         */
        optimizedAutoscale?: outputs.kusto.OptimizedAutoscaleResponse;
        /**
         * The provisioned state of the resource.
         */
        provisioningState: string;
        /**
         * The state of the resource.
         */
        state: string;
        /**
         * The reason for the cluster's current state.
         */
        stateReason: string;
        /**
         * The cluster's external tenants.
         */
        trustedExternalTenants?: outputs.kusto.TrustedExternalTenantResponse[];
        /**
         * The cluster URI.
         */
        uri: string;
        /**
         * Virtual network definition.
         */
        virtualNetworkConfiguration?: outputs.kusto.VirtualNetworkConfigurationResponse;
    }

    /**
     * A class representing database principal property.
     */
    export interface DatabasePrincipalPropertiesResponse {
        /**
         * The principal ID assigned to the database principal. It can be a user email, application ID, or security group name.
         */
        principalId: string;
        /**
         * The principal name
         */
        principalName: string;
        /**
         * Principal type.
         */
        principalType: string;
        /**
         * The provisioned state of the resource.
         */
        provisioningState: string;
        /**
         * Database principal role.
         */
        role: string;
        /**
         * The tenant id of the principal
         */
        tenantId?: string;
        /**
         * The tenant name of the principal
         */
        tenantName: string;
    }

    /**
     * A class representing database principal entity.
     */
    export interface DatabasePrincipalResponse {
        /**
         * Application id - relevant only for application principal type.
         */
        appId?: string;
        /**
         * Database principal email if exists.
         */
        email?: string;
        /**
         * Database principal fully qualified name.
         */
        fqn?: string;
        /**
         * Database principal name.
         */
        name: string;
        /**
         * Database principal role.
         */
        role: string;
        /**
         * The tenant name of the principal
         */
        tenantName: string;
        /**
         * Database principal type.
         */
        type: string;
    }

    /**
     * A class representing follower database request.
     */
    export interface FollowerDatabaseDefinitionResponse {
        /**
         * Resource name of the attached database configuration in the follower cluster.
         */
        attachedDatabaseConfigurationName: string;
        /**
         * Resource id of the cluster that follows a database owned by this cluster.
         */
        clusterResourceId: string;
        /**
         * The database name owned by this cluster that was followed. * in case following all databases.
         */
        databaseName: string;
    }

    /**
     * Identity for the resource.
     */
    export interface IdentityResponse {
        /**
         * The principal ID of resource identity.
         */
        principalId: string;
        /**
         * The tenant ID of resource.
         */
        tenantId: string;
        /**
         * The identity type.
         */
        type: string;
        /**
         * The list of user identities associated with the Kusto cluster. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
         */
        userAssignedIdentities?: {[key: string]: string};
    }

    /**
     * Properties of the key vault.
     */
    export interface KeyVaultPropertiesResponse {
        /**
         * The name of the key vault key.
         */
        keyName: string;
        /**
         * The Uri of the key vault.
         */
        keyVaultUri: string;
        /**
         * The version of the key vault key.
         */
        keyVersion: string;
    }

    /**
     * The language extension object.
     */
    export interface LanguageExtensionResponse {
        /**
         * The language extension name.
         */
        languageExtensionName?: string;
    }

    /**
     * The list of language extension objects.
     */
    export interface LanguageExtensionsListResponse {
        /**
         * The list of language extensions.
         */
        value?: outputs.kusto.LanguageExtensionResponse[];
    }

    /**
     * A class that contains the optimized auto scale definition.
     */
    export interface OptimizedAutoscaleResponse {
        /**
         * A boolean value that indicate if the optimized autoscale feature is enabled or not.
         */
        isEnabled: boolean;
        /**
         * Maximum allowed instances count.
         */
        maximum: number;
        /**
         * Minimum allowed instances count.
         */
        minimum: number;
        /**
         * The version of the template defined, for instance 1.
         */
        version: number;
    }

    /**
     * Represents a tenant ID that is trusted by the cluster.
     */
    export interface TrustedExternalTenantResponse {
        /**
         * GUID representing an external tenant.
         */
        value?: string;
    }

    /**
     * A class that contains virtual network definition.
     */
    export interface VirtualNetworkConfigurationResponse {
        /**
         * Data management's service public IP address resource id.
         */
        dataManagementPublicIpId: string;
        /**
         * Engine service's public IP address resource id.
         */
        enginePublicIpId: string;
        /**
         * The subnet resource id.
         */
        subnetId: string;
    }

    /**
     * An array represents the availability zones of the cluster.
     */
    export interface ZonesResponse {
    }
}

export namespace labservices {
    /**
     * Properties of an environment
     */
    export interface EnvironmentPropertiesResponse {
        /**
         * The name or email address of the user who has claimed the environment
         */
        claimedByUserName: string;
        /**
         * The AAD object Id of the user who has claimed the environment
         */
        claimedByUserObjectId: string;
        /**
         * The user principal Id of the user who has claimed the environment
         */
        claimedByUserPrincipalId: string;
        /**
         * Is the environment claimed or not
         */
        isClaimed: boolean;
        /**
         * Last known power state of the environment
         */
        lastKnownPowerState: string;
        /**
         * The details of the latest operation. ex: status, error
         */
        latestOperationResult: outputs.labservices.LatestOperationResultResponse;
        /**
         * Network details of the environment
         */
        networkInterface: outputs.labservices.NetworkInterfaceResponse;
        /**
         * When the password was last reset on the environment.
         */
        passwordLastReset: string;
        /**
         * The provisioning status of the resource.
         */
        provisioningState?: string;
        /**
         * The set of a VM and the setting id it was created for
         */
        resourceSets?: outputs.labservices.ResourceSetResponse;
        /**
         * How long the environment has been used by a lab user
         */
        totalUsage: string;
        /**
         * The unique immutable identifier of a resource (Guid).
         */
        uniqueIdentifier?: string;
    }

    /**
     * Properties of an environment setting
     */
    export interface EnvironmentSettingPropertiesResponse {
        /**
         * Describes the user's progress in configuring their environment setting
         */
        configurationState?: string;
        /**
         * Describes the environment and its resource settings
         */
        description?: string;
        /**
         * Time when the template VM was last changed.
         */
        lastChanged: string;
        /**
         * Time when the template VM was last sent for publishing.
         */
        lastPublished: string;
        /**
         * The details of the latest operation. ex: status, error
         */
        latestOperationResult: outputs.labservices.LatestOperationResultResponse;
        /**
         * The provisioning status of the resource.
         */
        provisioningState?: string;
        /**
         * Describes the readiness of this environment setting
         */
        publishingState: string;
        /**
         * The resource specific settings
         */
        resourceSettings: outputs.labservices.ResourceSettingsResponse;
        /**
         * Brief title describing the environment and its resource settings
         */
        title?: string;
        /**
         * The unique immutable identifier of a resource (Guid).
         */
        uniqueIdentifier?: string;
    }

    /**
     * Represents a size category supported by this Lab Account (small, medium or large)
     */
    export interface EnvironmentSizeResponse {
        /**
         * The pay-as-you-go dollar price per hour this size will cost. It does not include discounts and may not reflect the actual price the size will cost. This is the maximum price of all prices within this tier.
         */
        maxPrice: number;
        /**
         * The amount of memory available (in GB). This is the minimum amount of memory within this tier.
         */
        minMemory: number;
        /**
         * The number of cores a VM of this size has. This is the minimum number of cores within this tier.
         */
        minNumberOfCores: number;
        /**
         * The size category
         */
        name?: string;
        /**
         * Represents a set of compute sizes that can serve this given size type
         */
        vmSizes?: outputs.labservices.SizeInfoResponse[];
    }

    /**
     * The gallery image properties
     */
    export interface GalleryImagePropertiesResponse {
        /**
         * The author of the gallery image.
         */
        author: string;
        /**
         * The creation date of the gallery image.
         */
        createdDate: string;
        /**
         * The description of the gallery image.
         */
        description: string;
        /**
         * The icon of the gallery image.
         */
        icon: string;
        /**
         * The image reference of the gallery image.
         */
        imageReference: outputs.labservices.GalleryImageReferenceResponse;
        /**
         * Indicates whether this gallery image is enabled.
         */
        isEnabled?: boolean;
        /**
         * Indicates whether this gallery has been overridden for this lab account
         */
        isOverride?: boolean;
        /**
         * Indicates if the plan has been authorized for programmatic deployment.
         */
        isPlanAuthorized?: boolean;
        /**
         * The details of the latest operation. ex: status, error
         */
        latestOperationResult: outputs.labservices.LatestOperationResultResponse;
        /**
         * The third party plan that applies to this image
         */
        planId: string;
        /**
         * The provisioning status of the resource.
         */
        provisioningState?: string;
        /**
         * The unique immutable identifier of a resource (Guid).
         */
        uniqueIdentifier?: string;
    }

    /**
     * The reference information for an Azure Marketplace image.
     */
    export interface GalleryImageReferenceResponse {
        /**
         * The offer of the gallery image.
         */
        offer?: string;
        /**
         * The OS type of the gallery image.
         */
        osType?: string;
        /**
         * The publisher of the gallery image.
         */
        publisher?: string;
        /**
         * The SKU of the gallery image.
         */
        sku?: string;
        /**
         * The version of the gallery image.
         */
        version?: string;
    }

    /**
     * Properties of a Lab Account.
     */
    export interface LabAccountPropertiesResponse {
        /**
         * Represents if region selection is enabled
         */
        enabledRegionSelection?: boolean;
        /**
         * The details of the latest operation. ex: status, error
         */
        latestOperationResult: outputs.labservices.LatestOperationResultResponse;
        /**
         * The provisioning status of the resource.
         */
        provisioningState?: string;
        /**
         * Represents the size configuration under the lab account
         */
        sizeConfiguration: outputs.labservices.SizeConfigurationPropertiesResponse;
        /**
         * The unique immutable identifier of a resource (Guid).
         */
        uniqueIdentifier?: string;
    }

    /**
     * Properties of a Lab.
     */
    export interface LabPropertiesResponse {
        /**
         * Object id of the user that created the lab.
         */
        createdByObjectId: string;
        /**
         * Lab creator name
         */
        createdByUserPrincipalName: string;
        /**
         * Creation date for the lab
         */
        createdDate: string;
        /**
         * Invitation code that users can use to join a lab.
         */
        invitationCode: string;
        /**
         * The details of the latest operation. ex: status, error
         */
        latestOperationResult: outputs.labservices.LatestOperationResultResponse;
        /**
         * Maximum number of users allowed in the lab.
         */
        maxUsersInLab?: number;
        /**
         * The provisioning status of the resource.
         */
        provisioningState?: string;
        /**
         * The unique immutable identifier of a resource (Guid).
         */
        uniqueIdentifier?: string;
        /**
         * Maximum duration a user can use an environment for in the lab.
         */
        usageQuota?: string;
        /**
         * Lab user access mode (open to all vs. restricted to those listed on the lab).
         */
        userAccessMode?: string;
        /**
         * Maximum value MaxUsersInLab can be set to, as specified by the service
         */
        userQuota: number;
    }

    /**
     * Details of the status of an operation.
     */
    export interface LatestOperationResultResponse {
        /**
         * Error code on failure.
         */
        errorCode: string;
        /**
         * The error message.
         */
        errorMessage: string;
        /**
         * The HttpMethod - PUT/POST/DELETE for the operation.
         */
        httpMethod: string;
        /**
         * The URL to use to check long-running operation status
         */
        operationUrl: string;
        /**
         * Request URI of the operation.
         */
        requestUri: string;
        /**
         * The current status of the operation.
         */
        status: string;
    }

    /**
     * Network details of the environment
     */
    export interface NetworkInterfaceResponse {
        /**
         * PrivateIp address of the Compute VM
         */
        privateIpAddress: string;
        /**
         * Connection information for Windows
         */
        rdpAuthority: string;
        /**
         * Connection information for Linux
         */
        sshAuthority: string;
        /**
         * Username of the VM
         */
        username: string;
    }

    /**
     * Details of a Reference Vm
     */
    export interface ReferenceVmResponse {
        /**
         * The password of the virtual machine. This will be set to null in GET resource API
         */
        password?: string;
        /**
         * The username of the virtual machine
         */
        userName: string;
        /**
         * VM resource Id for the environment
         */
        vmResourceId: string;
        /**
         * The state details for the reference virtual machine.
         */
        vmStateDetails: outputs.labservices.VmStateDetailsResponse;
    }

    /**
     * Represents a VM and the setting Id it was created for.
     */
    export interface ResourceSetResponse {
        /**
         * resourceSettingId for the environment
         */
        resourceSettingId?: string;
        /**
         * VM resource Id for the environment
         */
        vmResourceId?: string;
    }

    /**
     * Represents resource specific settings
     */
    export interface ResourceSettingsResponse {
        /**
         * The translated compute cores of the virtual machine
         */
        cores: number;
        /**
         * The resource id of the gallery image used for creating the virtual machine
         */
        galleryImageResourceId?: string;
        /**
         * The unique id of the resource setting
         */
        id: string;
        /**
         * The name of the image used to created the environment setting
         */
        imageName: string;
        /**
         * Details specific to Reference Vm
         */
        referenceVm: outputs.labservices.ReferenceVmResponse;
        /**
         * The size of the virtual machine
         */
        size?: string;
    }

    /**
     * Represents the size configuration under the lab account
     */
    export interface SizeConfigurationPropertiesResponse {
        /**
         * Represents a list of size categories supported by this Lab Account (Small, Medium, Large)
         */
        environmentSizes?: outputs.labservices.EnvironmentSizeResponse[];
    }

    /**
     * Contains detailed information about a size
     */
    export interface SizeInfoResponse {
        /**
         * Represents the actual compute size, e.g. Standard_A2_v2.
         */
        computeSize?: string;
        /**
         * The amount of memory available (in GB).
         */
        memory?: number;
        /**
         * The number of cores a VM of this size has.
         */
        numberOfCores?: number;
        /**
         * The pay-as-you-go price per hour this size will cost. It does not include discounts and may not reflect the actual price the size will cost.
         */
        price?: number;
    }

    /**
     * Lab User properties
     */
    export interface UserPropertiesResponse {
        /**
         * The user email address, as it was specified during registration.
         */
        email: string;
        /**
         * The user family name, as it was specified during registration.
         */
        familyName: string;
        /**
         * The user given name, as it was specified during registration.
         */
        givenName: string;
        /**
         * The details of the latest operation. ex: status, error
         */
        latestOperationResult: outputs.labservices.LatestOperationResultResponse;
        /**
         * The provisioning status of the resource.
         */
        provisioningState?: string;
        /**
         * The user tenant ID, as it was specified during registration.
         */
        tenantId: string;
        /**
         * How long the user has used his VMs in this lab
         */
        totalUsage: string;
        /**
         * The unique immutable identifier of a resource (Guid).
         */
        uniqueIdentifier?: string;
    }

    /**
     * Details about the state of the reference virtual machine.
     */
    export interface VmStateDetailsResponse {
        /**
         * Last known compute power state captured in DTL
         */
        lastKnownPowerState: string;
        /**
         * The power state of the reference virtual machine.
         */
        powerState: string;
        /**
         * The RdpAuthority property is a server DNS host name or IP address followed by the service port number for RDP (Remote Desktop Protocol).
         */
        rdpAuthority: string;
        /**
         * The SshAuthority property is a server DNS host name or IP address followed by the service port number for SSH.
         */
        sshAuthority: string;
    }
}

export namespace logic {
    /**
     * The AS2 agreement acknowledgement connection settings.
     */
    export interface AS2AcknowledgementConnectionSettingsResponse {
        /**
         * Indicates whether to ignore mismatch in certificate name.
         */
        ignoreCertificateNameMismatch: boolean;
        /**
         * Indicates whether to keep the connection alive.
         */
        keepHttpConnectionAlive: boolean;
        /**
         * Indicates whether to support HTTP status code 'CONTINUE'.
         */
        supportHttpStatusCodeContinue: boolean;
        /**
         * Indicates whether to unfold the HTTP headers.
         */
        unfoldHttpHeaders: boolean;
    }

    /**
     * The integration account AS2 agreement content.
     */
    export interface AS2AgreementContentResponse {
        /**
         * The AS2 one-way receive agreement.
         */
        receiveAgreement: outputs.logic.AS2OneWayAgreementResponse;
        /**
         * The AS2 one-way send agreement.
         */
        sendAgreement: outputs.logic.AS2OneWayAgreementResponse;
    }

    /**
     * The AS2 agreement envelope settings.
     */
    export interface AS2EnvelopeSettingsResponse {
        /**
         * The value indicating whether to auto generate file name.
         */
        autogenerateFileName: boolean;
        /**
         * The template for file name.
         */
        fileNameTemplate: string;
        /**
         * The message content type.
         */
        messageContentType: string;
        /**
         * The value indicating whether to suspend message on file name generation error.
         */
        suspendMessageOnFileNameGenerationError: boolean;
        /**
         * The value indicating whether to transmit file name in mime header.
         */
        transmitFileNameInMimeHeader: boolean;
    }

    /**
     * The AS2 agreement error settings.
     */
    export interface AS2ErrorSettingsResponse {
        /**
         * The value indicating whether to resend message If MDN is not received.
         */
        resendIfMDNNotReceived: boolean;
        /**
         * The value indicating whether to suspend duplicate message.
         */
        suspendDuplicateMessage: boolean;
    }

    /**
     * The AS2 agreement mdn settings.
     */
    export interface AS2MdnSettingsResponse {
        /**
         * The disposition notification to header value.
         */
        dispositionNotificationTo?: string;
        /**
         * The MDN text.
         */
        mdnText?: string;
        /**
         * The signing or hashing algorithm.
         */
        micHashingAlgorithm: string;
        /**
         * The value indicating whether to send or request a MDN.
         */
        needMDN: boolean;
        /**
         * The receipt delivery URL.
         */
        receiptDeliveryUrl?: string;
        /**
         * The value indicating whether to send inbound MDN to message box.
         */
        sendInboundMDNToMessageBox: boolean;
        /**
         * The value indicating whether to send the asynchronous MDN.
         */
        sendMDNAsynchronously: boolean;
        /**
         * The value indicating whether the MDN needs to be signed or not.
         */
        signMDN: boolean;
        /**
         * The value indicating whether to sign the outbound MDN if optional.
         */
        signOutboundMDNIfOptional: boolean;
    }

    /**
     * The AS2 agreement message connection settings.
     */
    export interface AS2MessageConnectionSettingsResponse {
        /**
         * The value indicating whether to ignore mismatch in certificate name.
         */
        ignoreCertificateNameMismatch: boolean;
        /**
         * The value indicating whether to keep the connection alive.
         */
        keepHttpConnectionAlive: boolean;
        /**
         * The value indicating whether to support HTTP status code 'CONTINUE'.
         */
        supportHttpStatusCodeContinue: boolean;
        /**
         * The value indicating whether to unfold the HTTP headers.
         */
        unfoldHttpHeaders: boolean;
    }

    /**
     * The integration account AS2 one-way agreement.
     */
    export interface AS2OneWayAgreementResponse {
        /**
         * The AS2 protocol settings.
         */
        protocolSettings: outputs.logic.AS2ProtocolSettingsResponse;
        /**
         * The receiver business identity
         */
        receiverBusinessIdentity: outputs.logic.BusinessIdentityResponse;
        /**
         * The sender business identity
         */
        senderBusinessIdentity: outputs.logic.BusinessIdentityResponse;
    }

    /**
     * The AS2 agreement protocol settings.
     */
    export interface AS2ProtocolSettingsResponse {
        /**
         * The acknowledgement connection settings.
         */
        acknowledgementConnectionSettings: outputs.logic.AS2AcknowledgementConnectionSettingsResponse;
        /**
         * The envelope settings.
         */
        envelopeSettings: outputs.logic.AS2EnvelopeSettingsResponse;
        /**
         * The error settings.
         */
        errorSettings: outputs.logic.AS2ErrorSettingsResponse;
        /**
         * The MDN settings.
         */
        mdnSettings: outputs.logic.AS2MdnSettingsResponse;
        /**
         * The message connection settings.
         */
        messageConnectionSettings: outputs.logic.AS2MessageConnectionSettingsResponse;
        /**
         * The security settings.
         */
        securitySettings: outputs.logic.AS2SecuritySettingsResponse;
        /**
         * The validation settings.
         */
        validationSettings: outputs.logic.AS2ValidationSettingsResponse;
    }

    /**
     * The AS2 agreement security settings.
     */
    export interface AS2SecuritySettingsResponse {
        /**
         * The value indicating whether to enable NRR for inbound decoded messages.
         */
        enableNRRForInboundDecodedMessages: boolean;
        /**
         * The value indicating whether to enable NRR for inbound encoded messages.
         */
        enableNRRForInboundEncodedMessages: boolean;
        /**
         * The value indicating whether to enable NRR for inbound MDN.
         */
        enableNRRForInboundMDN: boolean;
        /**
         * The value indicating whether to enable NRR for outbound decoded messages.
         */
        enableNRRForOutboundDecodedMessages: boolean;
        /**
         * The value indicating whether to enable NRR for outbound encoded messages.
         */
        enableNRRForOutboundEncodedMessages: boolean;
        /**
         * The value indicating whether to enable NRR for outbound MDN.
         */
        enableNRRForOutboundMDN: boolean;
        /**
         * The name of the encryption certificate.
         */
        encryptionCertificateName?: string;
        /**
         * The value indicating whether to send or request a MDN.
         */
        overrideGroupSigningCertificate: boolean;
        /**
         * The Sha2 algorithm format. Valid values are Sha2, ShaHashSize, ShaHyphenHashSize, Sha2UnderscoreHashSize.
         */
        sha2AlgorithmFormat?: string;
        /**
         * The name of the signing certificate.
         */
        signingCertificateName?: string;
    }

    /**
     * The AS2 agreement validation settings.
     */
    export interface AS2ValidationSettingsResponse {
        /**
         * The value indicating whether to check for certificate revocation list on receive.
         */
        checkCertificateRevocationListOnReceive: boolean;
        /**
         * The value indicating whether to check for certificate revocation list on send.
         */
        checkCertificateRevocationListOnSend: boolean;
        /**
         * The value indicating whether to check for duplicate message.
         */
        checkDuplicateMessage: boolean;
        /**
         * The value indicating whether the message has to be compressed.
         */
        compressMessage: boolean;
        /**
         * The value indicating whether the message has to be encrypted.
         */
        encryptMessage: boolean;
        /**
         * The encryption algorithm.
         */
        encryptionAlgorithm: string;
        /**
         * The number of days to look back for duplicate interchange.
         */
        interchangeDuplicatesValidityDays: number;
        /**
         * The value indicating whether to override incoming message properties with those in agreement.
         */
        overrideMessageProperties: boolean;
        /**
         * The value indicating whether the message has to be signed.
         */
        signMessage: boolean;
        /**
         * The signing algorithm.
         */
        signingAlgorithm?: string;
    }

    /**
     * The integration account agreement content.
     */
    export interface AgreementContentResponse {
        /**
         * The AS2 agreement content.
         */
        aS2?: outputs.logic.AS2AgreementContentResponse;
        /**
         * The EDIFACT agreement content.
         */
        edifact?: outputs.logic.EdifactAgreementContentResponse;
        /**
         * The X12 agreement content.
         */
        x12?: outputs.logic.X12AgreementContentResponse;
    }

    /**
     * The API deployment parameter metadata.
     */
    export interface ApiDeploymentParameterMetadataResponse {
        /**
         * The description.
         */
        description?: string;
        /**
         * The display name.
         */
        displayName?: string;
        /**
         * Indicates whether its required.
         */
        isRequired?: boolean;
        /**
         * The type.
         */
        type?: string;
        /**
         * The visibility.
         */
        visibility?: string;
    }

    /**
     * The API deployment parameters metadata.
     */
    export interface ApiDeploymentParameterMetadataSetResponse {
        /**
         * The package content link parameter.
         */
        packageContentLink?: outputs.logic.ApiDeploymentParameterMetadataResponse;
        /**
         * The package content link parameter.
         */
        redisCacheConnectionString?: outputs.logic.ApiDeploymentParameterMetadataResponse;
    }

    /**
     * The API backend service.
     */
    export interface ApiResourceBackendServiceResponse {
        /**
         * The service URL.
         */
        serviceUrl?: string;
    }

    /**
     * The Api resource definition.
     */
    export interface ApiResourceDefinitionsResponse {
        /**
         * The modified swagger url.
         */
        modifiedSwaggerUrl?: string;
        /**
         * The original swagger url.
         */
        originalSwaggerUrl?: string;
    }

    /**
     * The API general information.
     */
    export interface ApiResourceGeneralInformationResponse {
        /**
         * The description.
         */
        description?: string;
        /**
         * The display name.
         */
        displayName?: string;
        /**
         * The icon url.
         */
        iconUrl?: string;
        /**
         * The release tag.
         */
        releaseTag?: string;
        /**
         * The terms of use url.
         */
        termsOfUseUrl?: string;
        /**
         * The tier.
         */
        tier?: string;
    }

    /**
     * The api resource metadata.
     */
    export interface ApiResourceMetadataResponse {
        /**
         * The api type.
         */
        ApiType?: string;
        /**
         * The brand color.
         */
        brandColor?: string;
        /**
         * The connection type.
         */
        connectionType?: string;
        /**
         * The connector deployment parameters metadata.
         */
        deploymentParameters?: outputs.logic.ApiDeploymentParameterMetadataSetResponse;
        /**
         * The hide key.
         */
        hideKey?: string;
        /**
         * The provisioning state.
         */
        provisioningState?: string;
        /**
         * The source.
         */
        source?: string;
        /**
         * The tags.
         */
        tags?: {[key: string]: string};
        /**
         * The WSDL import method.
         */
        wsdlImportMethod?: string;
        /**
         * The WSDL service.
         */
        wsdlService?: outputs.logic.WsdlServiceResponse;
    }

    /**
     * The API resource policies.
     */
    export interface ApiResourcePoliciesResponse {
        /**
         * The API level only policies XML as embedded content.
         */
        content?: string;
        /**
         * The content link to the policies.
         */
        contentLink?: string;
    }

    /**
     * The API resource properties.
     */
    export interface ApiResourcePropertiesResponse {
        /**
         * The API definition.
         */
        apiDefinitionUrl?: string;
        /**
         * The api definitions.
         */
        apiDefinitions?: outputs.logic.ApiResourceDefinitionsResponse;
        /**
         * The backend service.
         */
        backendService?: outputs.logic.ApiResourceBackendServiceResponse;
        /**
         * The capabilities.
         */
        capabilities?: string[];
        /**
         * The category.
         */
        category?: string;
        /**
         * The connection parameters.
         */
        connectionParameters?: {[key: string]: string};
        /**
         * The api general information.
         */
        generalInformation?: outputs.logic.ApiResourceGeneralInformationResponse;
        /**
         * The integration service environment reference.
         */
        integrationServiceEnvironment?: outputs.logic.ResourceReferenceResponse;
        /**
         * The metadata.
         */
        metadata?: outputs.logic.ApiResourceMetadataResponse;
        /**
         * The name
         */
        name?: string;
        /**
         * The policies for the API.
         */
        policies?: outputs.logic.ApiResourcePoliciesResponse;
        /**
         * The provisioning state.
         */
        provisioningState?: string;
        /**
         * The runtime urls.
         */
        runtimeUrls?: string[];
    }

    /**
     * The assembly properties definition.
     */
    export interface AssemblyPropertiesResponse {
        /**
         * The assembly culture.
         */
        assemblyCulture?: string;
        /**
         * The assembly name.
         */
        assemblyName: string;
        /**
         * The assembly public key token.
         */
        assemblyPublicKeyToken?: string;
        /**
         * The assembly version.
         */
        assemblyVersion?: string;
        /**
         * The artifact changed time.
         */
        changedTime?: string;
        content?: {[key: string]: string};
        /**
         * The content link.
         */
        contentLink?: outputs.logic.ContentLinkResponse;
        /**
         * The content type.
         */
        contentType?: string;
        /**
         * The artifact creation time.
         */
        createdTime?: string;
        metadata?: {[key: string]: string};
    }

    /**
     * The azure resource error info.
     */
    export interface AzureResourceErrorInfoResponse {
        /**
         * The error code.
         */
        code: string;
        /**
         * The error details.
         */
        details?: outputs.logic.AzureResourceErrorInfoResponse[];
        /**
         * The error message.
         */
        message: string;
    }

    /**
     * The B2B partner content.
     */
    export interface B2BPartnerContentResponse {
        /**
         * The list of partner business identities.
         */
        businessIdentities?: outputs.logic.BusinessIdentityResponse[];
    }

    /**
     * The batch configuration properties definition.
     */
    export interface BatchConfigurationPropertiesResponse {
        /**
         * The name of the batch group.
         */
        batchGroupName: string;
        /**
         * The artifact changed time.
         */
        changedTime?: string;
        /**
         * The artifact creation time.
         */
        createdTime?: string;
        metadata?: {[key: string]: string};
        /**
         * The batch release criteria.
         */
        releaseCriteria: outputs.logic.BatchReleaseCriteriaResponse;
    }

    /**
     * The batch release criteria.
     */
    export interface BatchReleaseCriteriaResponse {
        /**
         * The batch size in bytes.
         */
        batchSize?: number;
        /**
         * The message count.
         */
        messageCount?: number;
        /**
         * The recurrence.
         */
        recurrence?: outputs.logic.WorkflowTriggerRecurrenceResponse;
    }

    /**
     * The integration account partner's business identity.
     */
    export interface BusinessIdentityResponse {
        /**
         * The business identity qualifier e.g. as2identity, ZZ, ZZZ, 31, 32
         */
        qualifier: string;
        /**
         * The user defined business identity value.
         */
        value: string;
    }

    /**
     * The content hash.
     */
    export interface ContentHashResponse {
        /**
         * The algorithm of the content hash.
         */
        algorithm?: string;
        /**
         * The value of the content hash.
         */
        value?: string;
    }

    /**
     * The content link.
     */
    export interface ContentLinkResponse {
        /**
         * The content hash.
         */
        contentHash?: outputs.logic.ContentHashResponse;
        /**
         * The content size.
         */
        contentSize?: number;
        /**
         * The content version.
         */
        contentVersion?: string;
        /**
         * The metadata.
         */
        metadata?: outputs.logic.ObjectResponse;
        /**
         * The content link URI.
         */
        uri?: string;
    }

    /**
     * The Edifact agreement acknowledgement settings.
     */
    export interface EdifactAcknowledgementSettingsResponse {
        /**
         * The acknowledgement control number lower bound.
         */
        acknowledgementControlNumberLowerBound: number;
        /**
         * The acknowledgement control number prefix.
         */
        acknowledgementControlNumberPrefix?: string;
        /**
         * The acknowledgement control number suffix.
         */
        acknowledgementControlNumberSuffix?: string;
        /**
         * The acknowledgement control number upper bound.
         */
        acknowledgementControlNumberUpperBound: number;
        /**
         * The value indicating whether to batch functional acknowledgements.
         */
        batchFunctionalAcknowledgements: boolean;
        /**
         * The value indicating whether to batch the technical acknowledgements.
         */
        batchTechnicalAcknowledgements: boolean;
        /**
         * The value indicating whether functional acknowledgement is needed.
         */
        needFunctionalAcknowledgement: boolean;
        /**
         * The value indicating whether a loop is needed for valid messages.
         */
        needLoopForValidMessages: boolean;
        /**
         * The value indicating whether technical acknowledgement is needed.
         */
        needTechnicalAcknowledgement: boolean;
        /**
         * The value indicating whether to rollover acknowledgement control number.
         */
        rolloverAcknowledgementControlNumber: boolean;
        /**
         * The value indicating whether to send synchronous acknowledgement.
         */
        sendSynchronousAcknowledgement: boolean;
    }

    /**
     * The Edifact agreement content.
     */
    export interface EdifactAgreementContentResponse {
        /**
         * The EDIFACT one-way receive agreement.
         */
        receiveAgreement: outputs.logic.EdifactOneWayAgreementResponse;
        /**
         * The EDIFACT one-way send agreement.
         */
        sendAgreement: outputs.logic.EdifactOneWayAgreementResponse;
    }

    /**
     * The Edifact delimiter override settings.
     */
    export interface EdifactDelimiterOverrideResponse {
        /**
         * The component separator.
         */
        componentSeparator: number;
        /**
         * The data element separator.
         */
        dataElementSeparator: number;
        /**
         * The decimal point indicator.
         */
        decimalPointIndicator: string;
        /**
         * The message association assigned code.
         */
        messageAssociationAssignedCode?: string;
        /**
         * The message id.
         */
        messageId?: string;
        /**
         * The message release.
         */
        messageRelease?: string;
        /**
         * The message version.
         */
        messageVersion?: string;
        /**
         * The release indicator.
         */
        releaseIndicator: number;
        /**
         * The repetition separator.
         */
        repetitionSeparator: number;
        /**
         * The segment terminator.
         */
        segmentTerminator: number;
        /**
         * The segment terminator suffix.
         */
        segmentTerminatorSuffix: string;
        /**
         * The target namespace on which this delimiter settings has to be applied.
         */
        targetNamespace?: string;
    }

    /**
     * The Edifact envelope override settings.
     */
    export interface EdifactEnvelopeOverrideResponse {
        /**
         * The application password.
         */
        applicationPassword?: string;
        /**
         * The association assigned code.
         */
        associationAssignedCode?: string;
        /**
         * The controlling agency code.
         */
        controllingAgencyCode?: string;
        /**
         * The functional group id.
         */
        functionalGroupId?: string;
        /**
         * The group header message release.
         */
        groupHeaderMessageRelease?: string;
        /**
         * The group header message version.
         */
        groupHeaderMessageVersion?: string;
        /**
         * The message association assigned code.
         */
        messageAssociationAssignedCode?: string;
        /**
         * The message id on which this envelope settings has to be applied.
         */
        messageId?: string;
        /**
         * The message release version on which this envelope settings has to be applied.
         */
        messageRelease?: string;
        /**
         * The message version on which this envelope settings has to be applied.
         */
        messageVersion?: string;
        /**
         * The receiver application id.
         */
        receiverApplicationId?: string;
        /**
         * The receiver application qualifier.
         */
        receiverApplicationQualifier?: string;
        /**
         * The sender application id.
         */
        senderApplicationId?: string;
        /**
         * The sender application qualifier.
         */
        senderApplicationQualifier?: string;
        /**
         * The target namespace on which this envelope settings has to be applied.
         */
        targetNamespace?: string;
    }

    /**
     * The Edifact agreement envelope settings.
     */
    export interface EdifactEnvelopeSettingsResponse {
        /**
         * The application reference id.
         */
        applicationReferenceId?: string;
        /**
         * The value indicating whether to apply delimiter string advice.
         */
        applyDelimiterStringAdvice: boolean;
        /**
         * The communication agreement id.
         */
        communicationAgreementId?: string;
        /**
         * The value indicating whether to create grouping segments.
         */
        createGroupingSegments: boolean;
        /**
         * The value indicating whether to enable default group headers.
         */
        enableDefaultGroupHeaders: boolean;
        /**
         * The functional group id.
         */
        functionalGroupId?: string;
        /**
         * The group application password.
         */
        groupApplicationPassword?: string;
        /**
         * The group application receiver id.
         */
        groupApplicationReceiverId?: string;
        /**
         * The group application receiver qualifier.
         */
        groupApplicationReceiverQualifier?: string;
        /**
         * The group application sender id.
         */
        groupApplicationSenderId?: string;
        /**
         * The group application sender qualifier.
         */
        groupApplicationSenderQualifier?: string;
        /**
         * The group association assigned code.
         */
        groupAssociationAssignedCode?: string;
        /**
         * The group control number lower bound.
         */
        groupControlNumberLowerBound: number;
        /**
         * The group control number prefix.
         */
        groupControlNumberPrefix?: string;
        /**
         * The group control number suffix.
         */
        groupControlNumberSuffix?: string;
        /**
         * The group control number upper bound.
         */
        groupControlNumberUpperBound: number;
        /**
         * The group controlling agency code.
         */
        groupControllingAgencyCode?: string;
        /**
         * The group message release.
         */
        groupMessageRelease?: string;
        /**
         * The group message version.
         */
        groupMessageVersion?: string;
        /**
         * The interchange control number lower bound.
         */
        interchangeControlNumberLowerBound: number;
        /**
         * The interchange control number prefix.
         */
        interchangeControlNumberPrefix?: string;
        /**
         * The interchange control number suffix.
         */
        interchangeControlNumberSuffix?: string;
        /**
         * The interchange control number upper bound.
         */
        interchangeControlNumberUpperBound: number;
        /**
         * The value indicating whether the message is a test interchange.
         */
        isTestInterchange: boolean;
        /**
         * The value indicating whether to overwrite existing transaction set control number.
         */
        overwriteExistingTransactionSetControlNumber: boolean;
        /**
         * The processing priority code.
         */
        processingPriorityCode?: string;
        /**
         * The receiver internal identification.
         */
        receiverInternalIdentification?: string;
        /**
         * The receiver internal sub identification.
         */
        receiverInternalSubIdentification?: string;
        /**
         * The receiver reverse routing address.
         */
        receiverReverseRoutingAddress?: string;
        /**
         * The recipient reference password qualifier.
         */
        recipientReferencePasswordQualifier?: string;
        /**
         * The recipient reference password value.
         */
        recipientReferencePasswordValue?: string;
        /**
         * The value indicating whether to rollover group control number.
         */
        rolloverGroupControlNumber: boolean;
        /**
         * The value indicating whether to rollover interchange control number.
         */
        rolloverInterchangeControlNumber: boolean;
        /**
         * The value indicating whether to rollover transaction set control number.
         */
        rolloverTransactionSetControlNumber: boolean;
        /**
         * The sender internal identification.
         */
        senderInternalIdentification?: string;
        /**
         * The sender internal sub identification.
         */
        senderInternalSubIdentification?: string;
        /**
         * The sender reverse routing address.
         */
        senderReverseRoutingAddress?: string;
        /**
         * The transaction set control number lower bound.
         */
        transactionSetControlNumberLowerBound: number;
        /**
         * The transaction set control number prefix.
         */
        transactionSetControlNumberPrefix?: string;
        /**
         * The transaction set control number suffix.
         */
        transactionSetControlNumberSuffix?: string;
        /**
         * The transaction set control number upper bound.
         */
        transactionSetControlNumberUpperBound: number;
    }

    /**
     * The Edifact agreement framing settings.
     */
    export interface EdifactFramingSettingsResponse {
        /**
         * The character encoding.
         */
        characterEncoding?: string;
        /**
         * The EDIFACT frame setting characterSet.
         */
        characterSet: string;
        /**
         * The component separator.
         */
        componentSeparator: number;
        /**
         * The data element separator.
         */
        dataElementSeparator: number;
        /**
         * The EDIFACT frame setting decimal indicator.
         */
        decimalPointIndicator: string;
        /**
         * The protocol version.
         */
        protocolVersion: number;
        /**
         * The release indicator.
         */
        releaseIndicator: number;
        /**
         * The repetition separator.
         */
        repetitionSeparator: number;
        /**
         * The segment terminator.
         */
        segmentTerminator: number;
        /**
         * The EDIFACT frame setting segment terminator suffix.
         */
        segmentTerminatorSuffix: string;
        /**
         * The service code list directory version.
         */
        serviceCodeListDirectoryVersion?: string;
    }

    /**
     * The Edifact message filter for odata query.
     */
    export interface EdifactMessageFilterResponse {
        /**
         * The message filter type.
         */
        messageFilterType: string;
    }

    /**
     * The Edifact message identifier.
     */
    export interface EdifactMessageIdentifierResponse {
        /**
         * The message id on which this envelope settings has to be applied.
         */
        messageId: string;
    }

    /**
     * The Edifact one way agreement.
     */
    export interface EdifactOneWayAgreementResponse {
        /**
         * The EDIFACT protocol settings.
         */
        protocolSettings: outputs.logic.EdifactProtocolSettingsResponse;
        /**
         * The receiver business identity
         */
        receiverBusinessIdentity: outputs.logic.BusinessIdentityResponse;
        /**
         * The sender business identity
         */
        senderBusinessIdentity: outputs.logic.BusinessIdentityResponse;
    }

    /**
     * The Edifact agreement protocol settings.
     */
    export interface EdifactProcessingSettingsResponse {
        /**
         * The value indicating whether to create empty xml tags for trailing separators.
         */
        createEmptyXmlTagsForTrailingSeparators: boolean;
        /**
         * The value indicating whether to mask security information.
         */
        maskSecurityInfo: boolean;
        /**
         * The value indicating whether to preserve interchange.
         */
        preserveInterchange: boolean;
        /**
         * The value indicating whether to suspend interchange on error.
         */
        suspendInterchangeOnError: boolean;
        /**
         * The value indicating whether to use dot as decimal separator.
         */
        useDotAsDecimalSeparator: boolean;
    }

    /**
     * The Edifact agreement protocol settings.
     */
    export interface EdifactProtocolSettingsResponse {
        /**
         * The EDIFACT acknowledgement settings.
         */
        acknowledgementSettings: outputs.logic.EdifactAcknowledgementSettingsResponse;
        /**
         * The EDIFACT delimiter override settings.
         */
        edifactDelimiterOverrides?: outputs.logic.EdifactDelimiterOverrideResponse[];
        /**
         * The EDIFACT envelope override settings.
         */
        envelopeOverrides?: outputs.logic.EdifactEnvelopeOverrideResponse[];
        /**
         * The EDIFACT envelope settings.
         */
        envelopeSettings: outputs.logic.EdifactEnvelopeSettingsResponse;
        /**
         * The EDIFACT framing settings.
         */
        framingSettings: outputs.logic.EdifactFramingSettingsResponse;
        /**
         * The EDIFACT message filter.
         */
        messageFilter: outputs.logic.EdifactMessageFilterResponse;
        /**
         * The EDIFACT message filter list.
         */
        messageFilterList?: outputs.logic.EdifactMessageIdentifierResponse[];
        /**
         * The EDIFACT processing Settings.
         */
        processingSettings: outputs.logic.EdifactProcessingSettingsResponse;
        /**
         * The EDIFACT schema references.
         */
        schemaReferences: outputs.logic.EdifactSchemaReferenceResponse[];
        /**
         * The EDIFACT validation override settings.
         */
        validationOverrides?: outputs.logic.EdifactValidationOverrideResponse[];
        /**
         * The EDIFACT validation settings.
         */
        validationSettings: outputs.logic.EdifactValidationSettingsResponse;
    }

    /**
     * The Edifact schema reference.
     */
    export interface EdifactSchemaReferenceResponse {
        /**
         * The association assigned code.
         */
        associationAssignedCode?: string;
        /**
         * The message id.
         */
        messageId: string;
        /**
         * The message release version.
         */
        messageRelease: string;
        /**
         * The message version.
         */
        messageVersion: string;
        /**
         * The schema name.
         */
        schemaName: string;
        /**
         * The sender application id.
         */
        senderApplicationId?: string;
        /**
         * The sender application qualifier.
         */
        senderApplicationQualifier?: string;
    }

    /**
     * The Edifact validation override settings.
     */
    export interface EdifactValidationOverrideResponse {
        /**
         * The value indicating whether to allow leading and trailing spaces and zeroes.
         */
        allowLeadingAndTrailingSpacesAndZeroes: boolean;
        /**
         * The value indicating whether to validate character Set.
         */
        enforceCharacterSet: boolean;
        /**
         * The message id on which the validation settings has to be applied.
         */
        messageId: string;
        /**
         * The trailing separator policy.
         */
        trailingSeparatorPolicy: string;
        /**
         * The value indicating whether to trim leading and trailing spaces and zeroes.
         */
        trimLeadingAndTrailingSpacesAndZeroes: boolean;
        /**
         * The value indicating whether to validate EDI types.
         */
        validateEDITypes: boolean;
        /**
         * The value indicating whether to validate XSD types.
         */
        validateXSDTypes: boolean;
    }

    /**
     * The Edifact agreement validation settings.
     */
    export interface EdifactValidationSettingsResponse {
        /**
         * The value indicating whether to allow leading and trailing spaces and zeroes.
         */
        allowLeadingAndTrailingSpacesAndZeroes: boolean;
        /**
         * The value indicating whether to check for duplicate group control number.
         */
        checkDuplicateGroupControlNumber: boolean;
        /**
         * The value indicating whether to check for duplicate interchange control number.
         */
        checkDuplicateInterchangeControlNumber: boolean;
        /**
         * The value indicating whether to check for duplicate transaction set control number.
         */
        checkDuplicateTransactionSetControlNumber: boolean;
        /**
         * The validity period of interchange control number.
         */
        interchangeControlNumberValidityDays: number;
        /**
         * The trailing separator policy.
         */
        trailingSeparatorPolicy: string;
        /**
         * The value indicating whether to trim leading and trailing spaces and zeroes.
         */
        trimLeadingAndTrailingSpacesAndZeroes: boolean;
        /**
         * The value indicating whether to validate character set in the message.
         */
        validateCharacterSet: boolean;
        /**
         * The value indicating whether to Whether to validate EDI types.
         */
        validateEDITypes: boolean;
        /**
         * The value indicating whether to Whether to validate XSD types.
         */
        validateXSDTypes: boolean;
    }

    /**
     * The expression.
     */
    export interface ExpressionResponse {
        /**
         * The azure resource error info.
         */
        error?: outputs.logic.AzureResourceErrorInfoResponse;
        /**
         * The sub expressions.
         */
        subexpressions?: outputs.logic.ExpressionResponse[];
        /**
         * The text.
         */
        text?: string;
        value?: {[key: string]: string};
    }

    /**
     * The expression root.
     */
    export interface ExpressionRootResponse {
        /**
         * The azure resource error info.
         */
        error?: outputs.logic.AzureResourceErrorInfoResponse;
        /**
         * The path.
         */
        path?: string;
        /**
         * The sub expressions.
         */
        subexpressions?: outputs.logic.ExpressionResponse[];
        /**
         * The text.
         */
        text?: string;
        value?: {[key: string]: string};
    }

    /**
     * The access control configuration policy.
     */
    export interface FlowAccessControlConfigurationPolicyResponse {
        /**
         * The allowed caller IP address ranges.
         */
        allowedCallerIpAddresses?: outputs.logic.IpAddressRangeResponse[];
        /**
         * The authentication policies for workflow.
         */
        openAuthenticationPolicies?: outputs.logic.OpenAuthenticationAccessPoliciesResponse;
    }

    /**
     * The access control configuration.
     */
    export interface FlowAccessControlConfigurationResponse {
        /**
         * The access control configuration for workflow actions.
         */
        actions?: outputs.logic.FlowAccessControlConfigurationPolicyResponse;
        /**
         * The access control configuration for accessing workflow run contents.
         */
        contents?: outputs.logic.FlowAccessControlConfigurationPolicyResponse;
        /**
         * The access control configuration for invoking workflow triggers.
         */
        triggers?: outputs.logic.FlowAccessControlConfigurationPolicyResponse;
        /**
         * The access control configuration for workflow management.
         */
        workflowManagement?: outputs.logic.FlowAccessControlConfigurationPolicyResponse;
    }

    /**
     * The endpoints configuration.
     */
    export interface FlowEndpointsConfigurationResponse {
        /**
         * The connector endpoints.
         */
        connector?: outputs.logic.FlowEndpointsResponse;
        /**
         * The workflow endpoints.
         */
        workflow?: outputs.logic.FlowEndpointsResponse;
    }

    /**
     * The flow endpoints configuration.
     */
    export interface FlowEndpointsResponse {
        /**
         * The access endpoint ip address.
         */
        accessEndpointIpAddresses?: outputs.logic.IpAddressResponse[];
        /**
         * The outgoing ip address.
         */
        outgoingIpAddresses?: outputs.logic.IpAddressResponse[];
    }

    /**
     * The integration account agreement properties.
     */
    export interface IntegrationAccountAgreementPropertiesResponse {
        /**
         * The agreement type.
         */
        agreementType: string;
        /**
         * The changed time.
         */
        changedTime: string;
        /**
         * The agreement content.
         */
        content: outputs.logic.AgreementContentResponse;
        /**
         * The created time.
         */
        createdTime: string;
        /**
         * The business identity of the guest partner.
         */
        guestIdentity: outputs.logic.BusinessIdentityResponse;
        /**
         * The integration account partner that is set as guest partner for this agreement.
         */
        guestPartner: string;
        /**
         * The business identity of the host partner.
         */
        hostIdentity: outputs.logic.BusinessIdentityResponse;
        /**
         * The integration account partner that is set as host partner for this agreement.
         */
        hostPartner: string;
        /**
         * The metadata.
         */
        metadata?: {[key: string]: string};
    }

    /**
     * The integration account certificate properties.
     */
    export interface IntegrationAccountCertificatePropertiesResponse {
        /**
         * The changed time.
         */
        changedTime: string;
        /**
         * The created time.
         */
        createdTime: string;
        /**
         * The key details in the key vault.
         */
        key?: outputs.logic.KeyVaultKeyReferenceResponse;
        /**
         * The metadata.
         */
        metadata?: {[key: string]: string};
        /**
         * The public certificate.
         */
        publicCertificate?: string;
    }

    /**
     * The integration account map.
     */
    export interface IntegrationAccountMapPropertiesResponse {
        /**
         * The changed time.
         */
        changedTime: string;
        /**
         * The content.
         */
        content?: string;
        /**
         * The content link.
         */
        contentLink: outputs.logic.ContentLinkResponse;
        /**
         * The content type.
         */
        contentType?: string;
        /**
         * The created time.
         */
        createdTime: string;
        /**
         * The map type.
         */
        mapType: string;
        /**
         * The metadata.
         */
        metadata?: {[key: string]: string};
        /**
         * The parameters schema of integration account map.
         */
        parametersSchema?: outputs.logic.IntegrationAccountMapPropertiesResponseProperties;
    }

    /**
     * The parameters schema of integration account map.
     */
    export interface IntegrationAccountMapPropertiesResponseProperties {
        /**
         * The reference name.
         */
        ref?: string;
    }

    /**
     * The integration account partner properties.
     */
    export interface IntegrationAccountPartnerPropertiesResponse {
        /**
         * The changed time.
         */
        changedTime: string;
        /**
         * The partner content.
         */
        content: outputs.logic.PartnerContentResponse;
        /**
         * The created time.
         */
        createdTime: string;
        /**
         * The metadata.
         */
        metadata?: {[key: string]: string};
        /**
         * The partner type.
         */
        partnerType: string;
    }

    /**
     * The integration account properties.
     */
    export interface IntegrationAccountPropertiesResponse {
        /**
         * The integration service environment.
         */
        integrationServiceEnvironment?: outputs.logic.IntegrationServiceEnvironmentResponse;
        /**
         * The workflow state.
         */
        state?: string;
    }

    /**
     * The integration account schema properties.
     */
    export interface IntegrationAccountSchemaPropertiesResponse {
        /**
         * The changed time.
         */
        changedTime: string;
        /**
         * The content.
         */
        content?: string;
        /**
         * The content link.
         */
        contentLink: outputs.logic.ContentLinkResponse;
        /**
         * The content type.
         */
        contentType?: string;
        /**
         * The created time.
         */
        createdTime: string;
        /**
         * The document name.
         */
        documentName?: string;
        /**
         * The file name.
         */
        fileName?: string;
        /**
         * The metadata.
         */
        metadata?: {[key: string]: string};
        /**
         * The schema type.
         */
        schemaType: string;
        /**
         * The target namespace of the schema.
         */
        targetNamespace?: string;
    }

    /**
     * The integration account session properties.
     */
    export interface IntegrationAccountSessionPropertiesResponse {
        /**
         * The changed time.
         */
        changedTime: string;
        /**
         * The session content.
         */
        content?: outputs.logic.ObjectResponse;
        /**
         * The created time.
         */
        createdTime: string;
    }

    /**
     * The integration account sku.
     */
    export interface IntegrationAccountSkuResponse {
        /**
         * The sku name.
         */
        name: string;
    }

    /**
     * The integration service environment access endpoint.
     */
    export interface IntegrationServiceEnvironmentAccessEndpointResponse {
        /**
         * The access endpoint type.
         */
        type?: string;
    }

    /**
     * The integration service environment properties.
     */
    export interface IntegrationServiceEnvironmentPropertiesResponse {
        /**
         * The endpoints configuration.
         */
        endpointsConfiguration?: outputs.logic.FlowEndpointsConfigurationResponse;
        /**
         * Gets the tracking id.
         */
        integrationServiceEnvironmentId?: string;
        /**
         * The network configuration.
         */
        networkConfiguration?: outputs.logic.NetworkConfigurationResponse;
        /**
         * The provisioning state.
         */
        provisioningState?: string;
        /**
         * The integration service environment state.
         */
        state?: string;
    }

    /**
     * The integration service environment.
     */
    export interface IntegrationServiceEnvironmentResponse {
        /**
         * The resource id.
         */
        id: string;
        /**
         * The resource location.
         */
        location?: string;
        /**
         * Gets the resource name.
         */
        name: string;
        /**
         * The integration service environment properties.
         */
        properties?: outputs.logic.IntegrationServiceEnvironmentPropertiesResponse;
        /**
         * The sku.
         */
        sku?: outputs.logic.IntegrationServiceEnvironmentSkuResponse;
        /**
         * The resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Gets the resource type.
         */
        type: string;
    }

    /**
     * The integration service environment sku.
     */
    export interface IntegrationServiceEnvironmentSkuResponse {
        /**
         * The sku capacity.
         */
        capacity?: number;
        /**
         * The sku name.
         */
        name?: string;
    }

    /**
     * The ip address range.
     */
    export interface IpAddressRangeResponse {
        /**
         * The IP address range.
         */
        addressRange?: string;
    }

    /**
     * The ip address.
     */
    export interface IpAddressResponse {
        /**
         * The address.
         */
        address?: string;
    }

    /**
     * The reference to the key vault key.
     */
    export interface KeyVaultKeyReferenceResponse {
        /**
         * The private key name in key vault.
         */
        keyName: string;
        /**
         * The key vault reference.
         */
        keyVault: outputs.logic.KeyVaultKeyReferenceResponseProperties;
        /**
         * The private key version in key vault.
         */
        keyVersion?: string;
    }

    /**
     * The key vault reference.
     */
    export interface KeyVaultKeyReferenceResponseProperties {
        /**
         * The resource id.
         */
        id?: string;
        /**
         * The resource name.
         */
        name: string;
        /**
         * The resource type.
         */
        type: string;
    }

    /**
     * The key vault key.
     */
    export interface KeyVaultKeyResponse {
        /**
         * The key attributes.
         */
        attributes?: outputs.logic.KeyVaultKeyResponseProperties;
        /**
         * The key id.
         */
        kid?: string;
    }

    /**
     * The key attributes.
     */
    export interface KeyVaultKeyResponseProperties {
        /**
         * When the key was created.
         */
        created?: number;
        /**
         * Whether the key is enabled or not.
         */
        enabled?: boolean;
        /**
         * When the key was updated.
         */
        updated?: number;
    }

    /**
     * The network configuration.
     */
    export interface NetworkConfigurationResponse {
        /**
         * The access endpoint.
         */
        accessEndpoint?: outputs.logic.IntegrationServiceEnvironmentAccessEndpointResponse;
        /**
         * The subnets.
         */
        subnets?: outputs.logic.ResourceReferenceResponse[];
        /**
         * Gets the virtual network address space.
         */
        virtualNetworkAddressSpace?: string;
    }

    export interface ObjectResponse {
    }

    /**
     * AuthenticationPolicy of type Open.
     */
    export interface OpenAuthenticationAccessPoliciesResponse {
        /**
         * Open authentication policies.
         */
        policies?: {[key: string]: string};
    }

    /**
     * The integration account partner content.
     */
    export interface PartnerContentResponse {
        /**
         * The B2B partner content.
         */
        b2b?: outputs.logic.B2BPartnerContentResponse;
    }

    /**
     * The recurrence schedule occurrence.
     */
    export interface RecurrenceScheduleOccurrenceResponse {
        /**
         * The day of the week.
         */
        day?: string;
        /**
         * The occurrence.
         */
        occurrence?: number;
    }

    /**
     * The recurrence schedule.
     */
    export interface RecurrenceScheduleResponse {
        /**
         * The hours.
         */
        hours?: number[];
        /**
         * The minutes.
         */
        minutes?: number[];
        /**
         * The month days.
         */
        monthDays?: number[];
        /**
         * The monthly occurrences.
         */
        monthlyOccurrences?: outputs.logic.RecurrenceScheduleOccurrenceResponse[];
        /**
         * The days of the week.
         */
        weekDays?: string[];
    }

    /**
     * The resource reference.
     */
    export interface ResourceReferenceResponse {
        /**
         * The resource id.
         */
        id?: string;
        /**
         * Gets the resource name.
         */
        name: string;
        /**
         * Gets the resource type.
         */
        type: string;
    }

    /**
     * The sku type.
     */
    export interface SkuResponse {
        /**
         * The name.
         */
        name: string;
        /**
         * The reference to plan.
         */
        plan?: outputs.logic.ResourceReferenceResponse;
    }

    /**
     * The workflow properties.
     */
    export interface WorkflowPropertiesResponse {
        /**
         * The access control configuration.
         */
        accessControl?: outputs.logic.FlowAccessControlConfigurationResponse;
        /**
         * Gets the access endpoint.
         */
        accessEndpoint: string;
        /**
         * Gets the changed time.
         */
        changedTime: string;
        /**
         * Gets the created time.
         */
        createdTime: string;
        /**
         * The definition.
         */
        definition?: outputs.logic.ObjectResponse;
        /**
         * The endpoints configuration.
         */
        endpointsConfiguration?: outputs.logic.FlowEndpointsConfigurationResponse;
        /**
         * The integration account.
         */
        integrationAccount?: outputs.logic.ResourceReferenceResponse;
        /**
         * The integration service environment.
         */
        integrationServiceEnvironment?: outputs.logic.ResourceReferenceResponse;
        /**
         * The parameters.
         */
        parameters?: {[key: string]: string};
        /**
         * Gets the provisioning state.
         */
        provisioningState: string;
        /**
         * The sku.
         */
        sku: outputs.logic.SkuResponse;
        /**
         * The state.
         */
        state?: string;
        /**
         * Gets the version.
         */
        version: string;
    }

    /**
     * Gets the workflow trigger callback URL query parameters.
     */
    export interface WorkflowTriggerListCallbackUrlQueriesResponse {
        /**
         * The SAS timestamp.
         */
        se?: string;
        /**
         * The SAS signature.
         */
        sig?: string;
        /**
         * The SAS permissions.
         */
        sp?: string;
        /**
         * The SAS version.
         */
        sv?: string;
    }

    /**
     * The workflow trigger recurrence.
     */
    export interface WorkflowTriggerRecurrenceResponse {
        /**
         * The end time.
         */
        endTime?: string;
        /**
         * The frequency.
         */
        frequency?: string;
        /**
         * The interval.
         */
        interval?: number;
        /**
         * The recurrence schedule.
         */
        schedule?: outputs.logic.RecurrenceScheduleResponse;
        /**
         * The start time.
         */
        startTime?: string;
        /**
         * The time zone.
         */
        timeZone?: string;
    }

    /**
     * The WSDL service.
     */
    export interface WsdlServiceResponse {
        /**
         * The list of endpoints' qualified names.
         */
        EndpointQualifiedNames?: string[];
        /**
         * The qualified name.
         */
        qualifiedName?: string;
    }

    /**
     * The X12 agreement acknowledgement settings.
     */
    export interface X12AcknowledgementSettingsResponse {
        /**
         * The acknowledgement control number lower bound.
         */
        acknowledgementControlNumberLowerBound: number;
        /**
         * The acknowledgement control number prefix.
         */
        acknowledgementControlNumberPrefix?: string;
        /**
         * The acknowledgement control number suffix.
         */
        acknowledgementControlNumberSuffix?: string;
        /**
         * The acknowledgement control number upper bound.
         */
        acknowledgementControlNumberUpperBound: number;
        /**
         * The value indicating whether to batch functional acknowledgements.
         */
        batchFunctionalAcknowledgements: boolean;
        /**
         * The value indicating whether to batch implementation acknowledgements.
         */
        batchImplementationAcknowledgements: boolean;
        /**
         * The value indicating whether to batch the technical acknowledgements.
         */
        batchTechnicalAcknowledgements: boolean;
        /**
         * The functional acknowledgement version.
         */
        functionalAcknowledgementVersion?: string;
        /**
         * The implementation acknowledgement version.
         */
        implementationAcknowledgementVersion?: string;
        /**
         * The value indicating whether functional acknowledgement is needed.
         */
        needFunctionalAcknowledgement: boolean;
        /**
         * The value indicating whether implementation acknowledgement is needed.
         */
        needImplementationAcknowledgement: boolean;
        /**
         * The value indicating whether a loop is needed for valid messages.
         */
        needLoopForValidMessages: boolean;
        /**
         * The value indicating whether technical acknowledgement is needed.
         */
        needTechnicalAcknowledgement: boolean;
        /**
         * The value indicating whether to rollover acknowledgement control number.
         */
        rolloverAcknowledgementControlNumber: boolean;
        /**
         * The value indicating whether to send synchronous acknowledgement.
         */
        sendSynchronousAcknowledgement: boolean;
    }

    /**
     * The X12 agreement content.
     */
    export interface X12AgreementContentResponse {
        /**
         * The X12 one-way receive agreement.
         */
        receiveAgreement: outputs.logic.X12OneWayAgreementResponse;
        /**
         * The X12 one-way send agreement.
         */
        sendAgreement: outputs.logic.X12OneWayAgreementResponse;
    }

    /**
     * The X12 delimiter override settings.
     */
    export interface X12DelimiterOverridesResponse {
        /**
         * The component separator.
         */
        componentSeparator: number;
        /**
         * The data element separator.
         */
        dataElementSeparator: number;
        /**
         * The message id.
         */
        messageId?: string;
        /**
         * The protocol version.
         */
        protocolVersion?: string;
        /**
         * The replacement character.
         */
        replaceCharacter: number;
        /**
         * The value indicating whether to replace separators in payload.
         */
        replaceSeparatorsInPayload: boolean;
        /**
         * The segment terminator.
         */
        segmentTerminator: number;
        /**
         * The segment terminator suffix.
         */
        segmentTerminatorSuffix: string;
        /**
         * The target namespace on which this delimiter settings has to be applied.
         */
        targetNamespace?: string;
    }

    /**
     * The X12 envelope override settings.
     */
    export interface X12EnvelopeOverrideResponse {
        /**
         * The date format.
         */
        dateFormat: string;
        /**
         * The functional identifier code.
         */
        functionalIdentifierCode?: string;
        /**
         * The header version.
         */
        headerVersion: string;
        /**
         * The message id on which this envelope settings has to be applied.
         */
        messageId: string;
        /**
         * The protocol version on which this envelope settings has to be applied.
         */
        protocolVersion: string;
        /**
         * The receiver application id.
         */
        receiverApplicationId: string;
        /**
         * The responsible agency code.
         */
        responsibleAgencyCode: string;
        /**
         * The sender application id.
         */
        senderApplicationId: string;
        /**
         * The target namespace on which this envelope settings has to be applied.
         */
        targetNamespace: string;
        /**
         * The time format.
         */
        timeFormat: string;
    }

    /**
     * The X12 agreement envelope settings.
     */
    export interface X12EnvelopeSettingsResponse {
        /**
         * The controls standards id.
         */
        controlStandardsId: number;
        /**
         * The control version number.
         */
        controlVersionNumber: string;
        /**
         * The value indicating whether to enable default group headers.
         */
        enableDefaultGroupHeaders: boolean;
        /**
         * The functional group id.
         */
        functionalGroupId?: string;
        /**
         * The group control number lower bound.
         */
        groupControlNumberLowerBound: number;
        /**
         * The group control number upper bound.
         */
        groupControlNumberUpperBound: number;
        /**
         * The group header agency code.
         */
        groupHeaderAgencyCode: string;
        /**
         * The group header date format.
         */
        groupHeaderDateFormat: string;
        /**
         * The group header time format.
         */
        groupHeaderTimeFormat: string;
        /**
         * The group header version.
         */
        groupHeaderVersion: string;
        /**
         * The interchange  control number lower bound.
         */
        interchangeControlNumberLowerBound: number;
        /**
         * The interchange  control number upper bound.
         */
        interchangeControlNumberUpperBound: number;
        /**
         * The value indicating whether to overwrite existing transaction set control number.
         */
        overwriteExistingTransactionSetControlNumber: boolean;
        /**
         * The receiver application id.
         */
        receiverApplicationId: string;
        /**
         * The value indicating whether to rollover group control number.
         */
        rolloverGroupControlNumber: boolean;
        /**
         * The value indicating whether to rollover interchange control number.
         */
        rolloverInterchangeControlNumber: boolean;
        /**
         * The value indicating whether to rollover transaction set control number.
         */
        rolloverTransactionSetControlNumber: boolean;
        /**
         * The sender application id.
         */
        senderApplicationId: string;
        /**
         * The transaction set control number lower bound.
         */
        transactionSetControlNumberLowerBound: number;
        /**
         * The transaction set control number prefix.
         */
        transactionSetControlNumberPrefix?: string;
        /**
         * The transaction set control number suffix.
         */
        transactionSetControlNumberSuffix?: string;
        /**
         * The transaction set control number upper bound.
         */
        transactionSetControlNumberUpperBound: number;
        /**
         * The usage indicator.
         */
        usageIndicator: string;
        /**
         * The value indicating whether to use control standards id as repetition character.
         */
        useControlStandardsIdAsRepetitionCharacter: boolean;
    }

    /**
     * The X12 agreement framing settings.
     */
    export interface X12FramingSettingsResponse {
        /**
         * The X12 character set.
         */
        characterSet: string;
        /**
         * The component separator.
         */
        componentSeparator: number;
        /**
         * The data element separator.
         */
        dataElementSeparator: number;
        /**
         * The replacement character.
         */
        replaceCharacter: number;
        /**
         * The value indicating whether to replace separators in payload.
         */
        replaceSeparatorsInPayload: boolean;
        /**
         * The segment terminator.
         */
        segmentTerminator: number;
        /**
         * The segment terminator suffix.
         */
        segmentTerminatorSuffix: string;
    }

    /**
     * The X12 message filter for odata query.
     */
    export interface X12MessageFilterResponse {
        /**
         * The message filter type.
         */
        messageFilterType: string;
    }

    /**
     * The X12 message identifier.
     */
    export interface X12MessageIdentifierResponse {
        /**
         * The message id.
         */
        messageId: string;
    }

    /**
     * The X12 one-way agreement.
     */
    export interface X12OneWayAgreementResponse {
        /**
         * The X12 protocol settings.
         */
        protocolSettings: outputs.logic.X12ProtocolSettingsResponse;
        /**
         * The receiver business identity
         */
        receiverBusinessIdentity: outputs.logic.BusinessIdentityResponse;
        /**
         * The sender business identity
         */
        senderBusinessIdentity: outputs.logic.BusinessIdentityResponse;
    }

    /**
     * The X12 processing settings.
     */
    export interface X12ProcessingSettingsResponse {
        /**
         * The value indicating whether to convert numerical type to implied decimal.
         */
        convertImpliedDecimal: boolean;
        /**
         * The value indicating whether to create empty xml tags for trailing separators.
         */
        createEmptyXmlTagsForTrailingSeparators: boolean;
        /**
         * The value indicating whether to mask security information.
         */
        maskSecurityInfo: boolean;
        /**
         * The value indicating whether to preserve interchange.
         */
        preserveInterchange: boolean;
        /**
         * The value indicating whether to suspend interchange on error.
         */
        suspendInterchangeOnError: boolean;
        /**
         * The value indicating whether to use dot as decimal separator.
         */
        useDotAsDecimalSeparator: boolean;
    }

    /**
     * The X12 agreement protocol settings.
     */
    export interface X12ProtocolSettingsResponse {
        /**
         * The X12 acknowledgment settings.
         */
        acknowledgementSettings: outputs.logic.X12AcknowledgementSettingsResponse;
        /**
         * The X12 envelope override settings.
         */
        envelopeOverrides?: outputs.logic.X12EnvelopeOverrideResponse[];
        /**
         * The X12 envelope settings.
         */
        envelopeSettings: outputs.logic.X12EnvelopeSettingsResponse;
        /**
         * The X12 framing settings.
         */
        framingSettings: outputs.logic.X12FramingSettingsResponse;
        /**
         * The X12 message filter.
         */
        messageFilter: outputs.logic.X12MessageFilterResponse;
        /**
         * The X12 message filter list.
         */
        messageFilterList?: outputs.logic.X12MessageIdentifierResponse[];
        /**
         * The X12 processing settings.
         */
        processingSettings: outputs.logic.X12ProcessingSettingsResponse;
        /**
         * The X12 schema references.
         */
        schemaReferences: outputs.logic.X12SchemaReferenceResponse[];
        /**
         * The X12 security settings.
         */
        securitySettings: outputs.logic.X12SecuritySettingsResponse;
        /**
         * The X12 validation override settings.
         */
        validationOverrides?: outputs.logic.X12ValidationOverrideResponse[];
        /**
         * The X12 validation settings.
         */
        validationSettings: outputs.logic.X12ValidationSettingsResponse;
        /**
         * The X12 delimiter override settings.
         */
        x12DelimiterOverrides?: outputs.logic.X12DelimiterOverridesResponse[];
    }

    /**
     * The X12 schema reference.
     */
    export interface X12SchemaReferenceResponse {
        /**
         * The message id.
         */
        messageId: string;
        /**
         * The schema name.
         */
        schemaName: string;
        /**
         * The schema version.
         */
        schemaVersion: string;
        /**
         * The sender application id.
         */
        senderApplicationId?: string;
    }

    /**
     * The X12 agreement security settings.
     */
    export interface X12SecuritySettingsResponse {
        /**
         * The authorization qualifier.
         */
        authorizationQualifier: string;
        /**
         * The authorization value.
         */
        authorizationValue?: string;
        /**
         * The password value.
         */
        passwordValue?: string;
        /**
         * The security qualifier.
         */
        securityQualifier: string;
    }

    /**
     * The X12 validation override settings.
     */
    export interface X12ValidationOverrideResponse {
        /**
         * The value indicating whether to allow leading and trailing spaces and zeroes.
         */
        allowLeadingAndTrailingSpacesAndZeroes: boolean;
        /**
         * The message id on which the validation settings has to be applied.
         */
        messageId: string;
        /**
         * The trailing separator policy.
         */
        trailingSeparatorPolicy: string;
        /**
         * The value indicating whether to trim leading and trailing spaces and zeroes.
         */
        trimLeadingAndTrailingSpacesAndZeroes: boolean;
        /**
         * The value indicating whether to validate character Set.
         */
        validateCharacterSet: boolean;
        /**
         * The value indicating whether to validate EDI types.
         */
        validateEDITypes: boolean;
        /**
         * The value indicating whether to validate XSD types.
         */
        validateXSDTypes: boolean;
    }

    /**
     * The X12 agreement validation settings.
     */
    export interface X12ValidationSettingsResponse {
        /**
         * The value indicating whether to allow leading and trailing spaces and zeroes.
         */
        allowLeadingAndTrailingSpacesAndZeroes: boolean;
        /**
         * The value indicating whether to check for duplicate group control number.
         */
        checkDuplicateGroupControlNumber: boolean;
        /**
         * The value indicating whether to check for duplicate interchange control number.
         */
        checkDuplicateInterchangeControlNumber: boolean;
        /**
         * The value indicating whether to check for duplicate transaction set control number.
         */
        checkDuplicateTransactionSetControlNumber: boolean;
        /**
         * The validity period of interchange control number.
         */
        interchangeControlNumberValidityDays: number;
        /**
         * The trailing separator policy.
         */
        trailingSeparatorPolicy: string;
        /**
         * The value indicating whether to trim leading and trailing spaces and zeroes.
         */
        trimLeadingAndTrailingSpacesAndZeroes: boolean;
        /**
         * The value indicating whether to validate character set in the message.
         */
        validateCharacterSet: boolean;
        /**
         * The value indicating whether to Whether to validate EDI types.
         */
        validateEDITypes: boolean;
        /**
         * The value indicating whether to Whether to validate XSD types.
         */
        validateXSDTypes: boolean;
    }
}

export namespace machinelearning {
    /**
     * Describes the access location for a blob.
     */
    export interface BlobLocationResponse {
        /**
         * Access credentials for the blob, if applicable (e.g. blob specified by storage account connection string + blob URI)
         */
        credentials?: string;
        /**
         * The URI from which the blob is accessible from. For example, aml://abc for system assets or https://xyz for user assets or payload.
         */
        uri: string;
    }

    /**
     * Information about the machine learning commitment plan associated with the web service.
     */
    export interface CommitmentPlanResponse {
        /**
         * Specifies the Azure Resource Manager ID of the commitment plan associated with the web service.
         */
        id: string;
    }

    /**
     * Diagnostics settings for an Azure ML web service.
     */
    export interface DiagnosticsConfigurationResponse {
        /**
         * Specifies the date and time when the logging will cease. If null, diagnostic collection is not time limited.
         */
        expiry?: string;
        /**
         * Specifies the verbosity of the diagnostic output. Valid values are: None - disables tracing; Error - collects only error (stderr) traces; All - collects all traces (stdout and stderr).
         */
        level: string;
    }

    /**
     * Sample input data for the service's input(s).
     */
    export interface ExampleRequestResponse {
        /**
         * Sample input data for the web service's global parameters
         */
        globalParameters?: {[key: string]: string};
        /**
         * Sample input data for the web service's input(s) given as an input name to sample input values matrix map.
         */
        inputs?: {[key: string]: string};
    }

    /**
     * Information about the machine learning workspace containing the experiment that is source for the web service.
     */
    export interface MachineLearningWorkspaceResponse {
        /**
         * Specifies the workspace ID of the machine learning workspace associated with the web service
         */
        id: string;
    }

    /**
     * Holds the available configuration options for an Azure ML web service endpoint.
     */
    export interface RealtimeConfigurationResponse {
        /**
         * Specifies the maximum concurrent calls that can be made to the web service. Minimum value: 4, Maximum value: 200.
         */
        maxConcurrentCalls?: number;
    }

    /**
     * The swagger 2.0 schema describing the service's inputs or outputs. See Swagger specification: http://swagger.io/specification/
     */
    export interface ServiceInputOutputSpecificationResponse {
        /**
         * The description of the Swagger schema.
         */
        description?: string;
        /**
         * Specifies a collection that contains the column schema for each input or output of the web service. For more information, see the Swagger specification.
         */
        properties: {[key: string]: string};
        /**
         * The title of your Swagger schema.
         */
        title?: string;
        /**
         * The type of the entity described in swagger. Always 'object'.
         */
        type: string;
    }

    /**
     * Sku of the resource
     */
    export interface SkuResponse {
        /**
         * Name of the sku
         */
        name?: string;
        /**
         * Tier of the sku like Basic or Enterprise
         */
        tier?: string;
    }

    /**
     * Access information for a storage account.
     */
    export interface StorageAccountResponse {
        /**
         * Specifies the key used to access the storage account.
         */
        key?: string;
        /**
         * Specifies the name of the storage account.
         */
        name?: string;
    }

    /**
     * Access keys for the web service calls.
     */
    export interface WebServiceKeysResponse {
        /**
         * The primary access key.
         */
        primary?: string;
        /**
         * The secondary access key.
         */
        secondary?: string;
    }

    /**
     * The set of properties specific to the Azure ML web service resource.
     */
    export interface WebServicePropertiesResponse {
        /**
         * Contains user defined properties describing web service assets. Properties are expressed as Key/Value pairs.
         */
        assets?: {[key: string]: string};
        /**
         * Contains the commitment plan associated with this web service. Set at creation time. Once set, this value cannot be changed. Note: The commitment plan is not returned from calls to GET operations.
         */
        commitmentPlan?: outputs.machinelearning.CommitmentPlanResponse;
        /**
         * Read Only: The date and time when the web service was created.
         */
        createdOn: string;
        /**
         * The description of the web service.
         */
        description?: string;
        /**
         * Settings controlling the diagnostics traces collection for the web service.
         */
        diagnostics?: outputs.machinelearning.DiagnosticsConfigurationResponse;
        /**
         * Defines sample input data for one or more of the service's inputs.
         */
        exampleRequest?: outputs.machinelearning.ExampleRequestResponse;
        /**
         * When set to true, sample data is included in the web service's swagger definition. The default value is true.
         */
        exposeSampleData?: boolean;
        /**
         * Contains the Swagger 2.0 schema describing one or more of the web service's inputs. For more information, see the Swagger specification.
         */
        input?: outputs.machinelearning.ServiceInputOutputSpecificationResponse;
        /**
         * Contains the web service provisioning keys. If you do not specify provisioning keys, the Azure Machine Learning system generates them for you. Note: The keys are not returned from calls to GET operations.
         */
        keys?: outputs.machinelearning.WebServiceKeysResponse;
        /**
         * Specifies the Machine Learning workspace containing the experiment that is source for the web service.
         */
        machineLearningWorkspace?: outputs.machinelearning.MachineLearningWorkspaceResponse;
        /**
         * Read Only: The date and time when the web service was last modified.
         */
        modifiedOn: string;
        /**
         * Contains the Swagger 2.0 schema describing one or more of the web service's outputs. For more information, see the Swagger specification.
         */
        output?: outputs.machinelearning.ServiceInputOutputSpecificationResponse;
        /**
         * Specifies the package type. Valid values are Graph (Specifies a web service published through the Machine Learning Studio) and Code (Specifies a web service published using code such as Python). Note: Code is not supported at this time.
         */
        packageType: string;
        /**
         * The set of global parameters values defined for the web service, given as a global parameter name to default value map. If no default value is specified, the parameter is considered to be required.
         */
        parameters?: {[key: string]: string};
        /**
         * When set to true, indicates that the payload size is larger than 3 MB. Otherwise false. If the payload size exceed 3 MB, the payload is stored in a blob and the PayloadsLocation parameter contains the URI of the blob. Otherwise, this will be set to false and Assets, Input, Output, Package, Parameters, ExampleRequest are inline. The Payload sizes is determined by adding the size of the Assets, Input, Output, Package, Parameters, and the ExampleRequest.
         */
        payloadsInBlobStorage?: boolean;
        /**
         * The URI of the payload blob. This parameter contains a value only if the payloadsInBlobStorage parameter is set to true. Otherwise is set to null.
         */
        payloadsLocation?: outputs.machinelearning.BlobLocationResponse;
        /**
         * Read Only: The provision state of the web service. Valid values are Unknown, Provisioning, Succeeded, and Failed.
         */
        provisioningState: string;
        /**
         * When set to true, indicates that the web service is read-only and can no longer be updated or patched, only removed. Default, is false. Note: Once set to true, you cannot change its value.
         */
        readOnly?: boolean;
        /**
         * Contains the configuration settings for the web service endpoint.
         */
        realtimeConfiguration?: outputs.machinelearning.RealtimeConfigurationResponse;
        /**
         * Specifies the storage account that Azure Machine Learning uses to store information about the web service. Only the name of the storage account is returned from calls to GET operations. When updating the storage account information, you must ensure that all necessary assets are available in the new storage account or calls to your web service will fail.
         */
        storageAccount?: outputs.machinelearning.StorageAccountResponse;
        /**
         * Read Only: Contains the URI of the swagger spec associated with this web service.
         */
        swaggerLocation: string;
        /**
         * The title of the web service.
         */
        title?: string;
    }

    /**
     * The properties of a machine learning workspace.
     */
    export interface WorkspacePropertiesResponse {
        /**
         * The creation time for this workspace resource.
         */
        creationTime: string;
        /**
         * The key vault identifier used for encrypted workspaces.
         */
        keyVaultIdentifierId?: string;
        /**
         * The email id of the owner for this workspace.
         */
        ownerEmail: string;
        /**
         * The regional endpoint for the machine learning studio service which hosts this workspace.
         */
        studioEndpoint: string;
        /**
         * The fully qualified arm id of the storage account associated with this workspace.
         */
        userStorageAccountId: string;
        /**
         * The immutable id associated with this workspace.
         */
        workspaceId: string;
        /**
         * The current state of workspace resource.
         */
        workspaceState: string;
        /**
         * The type of this workspace.
         */
        workspaceType: string;
    }
}

export namespace machinelearningservices {
    /**
     * Compute node information related to a AmlCompute.
     */
    export interface AmlComputeNodeInformationResponse {
        /**
         * ID of the compute node.
         */
        nodeId: string;
        /**
         * State of the compute node. Values are idle, running, preparing, unusable, leaving and preempted.
         */
        nodeState: string;
        /**
         * SSH port number of the node.
         */
        port: number;
        /**
         * Private IP address of the compute node.
         */
        privateIpAddress: string;
        /**
         * Public IP address of the compute node.
         */
        publicIpAddress: string;
        /**
         * ID of the Experiment running on the node, if any else null.
         */
        runId: string;
    }

    /**
     * Machine Learning compute object.
     */
    export interface ComputeResponse {
        /**
         * Location for the underlying compute
         */
        computeLocation?: string;
        /**
         * The type of compute
         */
        computeType: string;
        /**
         * The date and time when the compute was created.
         */
        createdOn: string;
        /**
         * The description of the Machine Learning compute.
         */
        description?: string;
        /**
         * Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
         */
        isAttachedCompute: boolean;
        /**
         * The date and time when the compute was last modified.
         */
        modifiedOn: string;
        /**
         * Errors during provisioning
         */
        provisioningErrors: outputs.machinelearningservices.MachineLearningServiceErrorResponse[];
        /**
         * The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
         */
        provisioningState: string;
        /**
         * ARM resource id of the underlying compute
         */
        resourceId?: string;
    }

    export interface EncryptionPropertyResponse {
        /**
         * Customer Key vault properties.
         */
        keyVaultProperties: outputs.machinelearningservices.KeyVaultPropertiesResponse;
        /**
         * Indicates whether or not the encryption is enabled for the workspace.
         */
        status: string;
    }

    /**
     * Error detail information.
     */
    export interface ErrorDetailResponse {
        /**
         * Error code.
         */
        code: string;
        /**
         * Error message.
         */
        message: string;
    }

    /**
     * Error response information.
     */
    export interface ErrorResponseResponse {
        /**
         * Error code.
         */
        code: string;
        /**
         * An array of error detail objects.
         */
        details: outputs.machinelearningservices.ErrorDetailResponse[];
        /**
         * Error message.
         */
        message: string;
    }

    /**
     * Identity for the resource.
     */
    export interface IdentityResponse {
        /**
         * The principal ID of resource identity.
         */
        principalId: string;
        /**
         * The tenant ID of resource.
         */
        tenantId: string;
        /**
         * The identity type.
         */
        type: string;
        /**
         * The list of user identities associated with resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
         */
        userAssignedIdentities?: {[key: string]: string};
    }

    export interface KeyVaultPropertiesResponse {
        /**
         * For future use - The client id of the identity which will be used to access key vault.
         */
        identityClientId?: string;
        /**
         * Key vault uri to access the encryption key.
         */
        keyIdentifier: string;
        /**
         * The ArmId of the keyVault where the customer owned encryption key is present.
         */
        keyVaultArmId: string;
    }

    /**
     * Wrapper for error response to follow ARM guidelines.
     */
    export interface MachineLearningServiceErrorResponse {
        /**
         * The error response.
         */
        error: outputs.machinelearningservices.ErrorResponseResponse;
    }

    export interface NotebookListCredentialsResultResponse {
        primaryAccessKey?: string;
        secondaryAccessKey?: string;
    }

    export interface NotebookPreparationErrorResponse {
        errorMessage?: string;
        statusCode?: number;
    }

    export interface NotebookResourceInfoResponse {
        fqdn?: string;
        /**
         * The error that occurs when preparing notebook.
         */
        notebookPreparationError?: outputs.machinelearningservices.NotebookPreparationErrorResponse;
        /**
         * the data plane resourceId that used to initialize notebook component
         */
        resourceId?: string;
    }

    export interface PasswordResponse {
        name: string;
        value: string;
    }

    /**
     * Properties of the PrivateEndpointConnectProperties.
     */
    export interface PrivateEndpointConnectionPropertiesResponse {
        /**
         * The resource of private end point.
         */
        privateEndpoint?: outputs.machinelearningservices.PrivateEndpointResponse;
        /**
         * A collection of information about the state of the connection between service consumer and provider.
         */
        privateLinkServiceConnectionState: outputs.machinelearningservices.PrivateLinkServiceConnectionStateResponse;
        /**
         * The provisioning state of the private endpoint connection resource.
         */
        provisioningState?: string;
    }

    /**
     * The Private Endpoint Connection resource.
     */
    export interface PrivateEndpointConnectionResponse {
        /**
         * Specifies the resource ID.
         */
        id: string;
        /**
         * The identity of the resource.
         */
        identity?: outputs.machinelearningservices.IdentityResponse;
        /**
         * Specifies the location of the resource.
         */
        location?: string;
        /**
         * Specifies the name of the resource.
         */
        name: string;
        /**
         * Resource properties.
         */
        properties?: outputs.machinelearningservices.PrivateEndpointConnectionPropertiesResponse;
        /**
         * The sku of the workspace.
         */
        sku?: outputs.machinelearningservices.SkuResponse;
        /**
         * Contains resource tags defined as key/value pairs.
         */
        tags?: {[key: string]: string};
        /**
         * Specifies the type of the resource.
         */
        type: string;
    }

    /**
     * The Private Endpoint resource.
     */
    export interface PrivateEndpointResponse {
        /**
         * The ARM identifier for Private Endpoint
         */
        id: string;
    }

    /**
     * A collection of information about the state of the connection between service consumer and provider.
     */
    export interface PrivateLinkServiceConnectionStateResponse {
        /**
         * A message indicating if changes on the service provider require any updates on the consumer.
         */
        actionsRequired?: string;
        /**
         * The reason for approval/rejection of the connection.
         */
        description?: string;
        /**
         * Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
         */
        status?: string;
    }

    export interface RegistryListCredentialsResultResponse {
        location: string;
        passwords?: outputs.machinelearningservices.PasswordResponse[];
        username: string;
    }

    /**
     * Properties of a shared private link resource.
     */
    export interface SharedPrivateLinkResourcePropertyResponse {
        /**
         * The private link resource group id.
         */
        groupId?: string;
        /**
         * The resource id that private link links to.
         */
        privateLinkResourceId?: string;
        /**
         * Request message.
         */
        requestMessage?: string;
        /**
         * Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
         */
        status?: string;
    }

    export interface SharedPrivateLinkResourceResponse {
        /**
         * Unique name of the private link.
         */
        name?: string;
        /**
         * Resource properties.
         */
        properties?: outputs.machinelearningservices.SharedPrivateLinkResourcePropertyResponse;
    }

    /**
     * Sku of the resource
     */
    export interface SkuResponse {
        /**
         * Name of the sku
         */
        name?: string;
        /**
         * Tier of the sku like Basic or Enterprise
         */
        tier?: string;
    }

    /**
     * Workspace Connection specific properties.
     */
    export interface WorkspaceConnectionPropsResponse {
        /**
         * Authorization type of the workspace connection.
         */
        authType?: string;
        /**
         * Category of the workspace connection.
         */
        category?: string;
        /**
         * Target of the workspace connection.
         */
        target?: string;
        /**
         * Value details of the workspace connection.
         */
        value?: string;
    }

    /**
     * The properties of a machine learning workspace.
     */
    export interface WorkspacePropertiesResponse {
        /**
         * The flag to indicate whether to allow public access when behind VNet.
         */
        allowPublicAccessWhenBehindVnet?: boolean;
        /**
         * ARM id of the application insights associated with this workspace. This cannot be changed once the workspace has been created
         */
        applicationInsights?: string;
        /**
         * ARM id of the container registry associated with this workspace. This cannot be changed once the workspace has been created
         */
        containerRegistry?: string;
        /**
         * The creation time of the machine learning workspace in ISO8601 format.
         */
        creationTime: string;
        /**
         * The description of this workspace.
         */
        description?: string;
        /**
         * Url for the discovery service to identify regional endpoints for machine learning experimentation services
         */
        discoveryUrl?: string;
        /**
         * The encryption settings of Azure ML workspace.
         */
        encryption?: outputs.machinelearningservices.EncryptionPropertyResponse;
        /**
         * The friendly name for this workspace. This name in mutable
         */
        friendlyName?: string;
        /**
         * The flag to signal HBI data in the workspace and reduce diagnostic data collected by the service
         */
        hbiWorkspace?: boolean;
        /**
         * The compute name for image build
         */
        imageBuildCompute?: string;
        /**
         * ARM id of the key vault associated with this workspace. This cannot be changed once the workspace has been created
         */
        keyVault?: string;
        /**
         * The notebook info of Azure ML workspace.
         */
        notebookInfo: outputs.machinelearningservices.NotebookResourceInfoResponse;
        /**
         * The list of private endpoint connections in the workspace.
         */
        privateEndpointConnections: outputs.machinelearningservices.PrivateEndpointConnectionResponse[];
        /**
         * Count of private connections in the workspace
         */
        privateLinkCount: number;
        /**
         * The current deployment state of workspace resource. The provisioningState is to indicate states for resource provisioning.
         */
        provisioningState: string;
        /**
         * The name of the managed resource group created by workspace RP in customer subscription if the workspace is CMK workspace
         */
        serviceProvisionedResourceGroup: string;
        /**
         * The list of shared private link resources in this workspace.
         */
        sharedPrivateLinkResources?: outputs.machinelearningservices.SharedPrivateLinkResourceResponse[];
        /**
         * ARM id of the storage account associated with this workspace. This cannot be changed once the workspace has been created
         */
        storageAccount?: string;
        /**
         * The immutable id associated with this workspace.
         */
        workspaceId: string;
    }
}

export namespace maintenance {
    /**
     * Properties for maintenance configuration
     */
    export interface MaintenanceConfigurationPropertiesResponse {
        /**
         * Gets or sets extensionProperties of the maintenanceConfiguration. This is for future use only and would be a set of key value pairs for additional information e.g. whether to follow SDP etc.
         */
        extensionProperties?: {[key: string]: string};
        /**
         * Gets or sets maintenanceScope of the configuration. It represent the impact area of the maintenance
         */
        maintenanceScope?: string;
        /**
         * Gets or sets namespace of the resource e.g. Microsoft.Maintenance or Microsoft.Sql
         */
        namespace?: string;
    }
}

export namespace managedidentity {
    /**
     * The properties associated with the user assigned identity.
     */
    export interface UserAssignedIdentityPropertiesResponse {
        /**
         * The id of the app associated with the identity. This is a random generated UUID by MSI.
         */
        clientId: string;
        /**
         * The id of the service principal object associated with the created identity.
         */
        principalId: string;
        /**
         * The id of the tenant which the identity belongs to.
         */
        tenantId: string;
    }
}

export namespace maps {
    /**
     * Additional Map account properties
     */
    export interface MapsAccountPropertiesResponse {
    }

    /**
     * The SKU of the Maps Account.
     */
    export interface SkuResponse {
        /**
         * The name of the SKU, in standard format (such as S0).
         */
        name: string;
        /**
         * Gets the sku tier. This is based on the SKU name.
         */
        tier: string;
    }
}

export namespace media {
    export interface AccountEncryptionResponse {
        /**
         * The properties of the key used to encrypt the account.
         */
        keyVaultProperties?: outputs.media.KeyVaultPropertiesResponse;
        /**
         * The type of key used to encrypt the Account Key.
         */
        type: string;
    }

    /**
     * Akamai access control
     */
    export interface AkamaiAccessControlResponse {
        /**
         * authentication key list
         */
        akamaiSignatureHeaderAuthenticationKeyList?: outputs.media.AkamaiSignatureHeaderAuthenticationKeyResponse[];
    }

    /**
     * Akamai Signature Header authentication key.
     */
    export interface AkamaiSignatureHeaderAuthenticationKeyResponse {
        /**
         * authentication key
         */
        base64Key?: string;
        /**
         * The expiration time of the authentication key.
         */
        expiration?: string;
        /**
         * identifier of the key
         */
        identifier?: string;
    }

    /**
     * The Asset properties.
     */
    export interface AssetPropertiesResponse {
        /**
         * The alternate ID of the Asset.
         */
        alternateId?: string;
        /**
         * The Asset ID.
         */
        assetId: string;
        /**
         * The name of the asset blob container.
         */
        container?: string;
        /**
         * The creation date of the Asset.
         */
        created: string;
        /**
         * The Asset description.
         */
        description?: string;
        /**
         * The last modified date of the Asset.
         */
        lastModified: string;
        /**
         * The name of the storage account.
         */
        storageAccountName?: string;
        /**
         * The Asset encryption format. One of None or MediaStorageEncryption.
         */
        storageEncryptionFormat: string;
    }

    /**
     * Properties of the Streaming Locator.
     */
    export interface AssetStreamingLocatorResponse {
        /**
         * Asset Name.
         */
        assetName: string;
        /**
         * The creation time of the Streaming Locator.
         */
        created: string;
        /**
         * Name of the default ContentKeyPolicy used by this Streaming Locator.
         */
        defaultContentKeyPolicyName: string;
        /**
         * The end time of the Streaming Locator.
         */
        endTime: string;
        /**
         * Streaming Locator name.
         */
        name: string;
        /**
         * The start time of the Streaming Locator.
         */
        startTime: string;
        /**
         * StreamingLocatorId of the Streaming Locator.
         */
        streamingLocatorId: string;
        /**
         * Name of the Streaming Policy used by this Streaming Locator.
         */
        streamingPolicyName: string;
    }

    /**
     * Class to specify DRM configurations of CommonEncryptionCbcs scheme in Streaming Policy
     */
    export interface CbcsDrmConfigurationResponse {
        /**
         * FairPlay configurations
         */
        fairPlay?: outputs.media.StreamingPolicyFairPlayConfigurationResponse;
        /**
         * PlayReady configurations
         */
        playReady?: outputs.media.StreamingPolicyPlayReadyConfigurationResponse;
        /**
         * Widevine configurations
         */
        widevine?: outputs.media.StreamingPolicyWidevineConfigurationResponse;
    }

    /**
     * Class to specify DRM configurations of CommonEncryptionCenc scheme in Streaming Policy
     */
    export interface CencDrmConfigurationResponse {
        /**
         * PlayReady configurations
         */
        playReady?: outputs.media.StreamingPolicyPlayReadyConfigurationResponse;
        /**
         * Widevine configurations
         */
        widevine?: outputs.media.StreamingPolicyWidevineConfigurationResponse;
    }

    /**
     * Class for CommonEncryptionCbcs encryption scheme
     */
    export interface CommonEncryptionCbcsResponse {
        /**
         * Representing which tracks should not be encrypted
         */
        clearTracks?: outputs.media.TrackSelectionResponse[];
        /**
         * Representing default content key for each encryption scheme and separate content keys for specific tracks
         */
        contentKeys?: outputs.media.StreamingPolicyContentKeysResponse;
        /**
         * Configuration of DRMs for current encryption scheme
         */
        drm?: outputs.media.CbcsDrmConfigurationResponse;
        /**
         * Representing supported protocols
         */
        enabledProtocols?: outputs.media.EnabledProtocolsResponse;
    }

    /**
     * Class for envelope encryption scheme
     */
    export interface CommonEncryptionCencResponse {
        /**
         * Representing which tracks should not be encrypted
         */
        clearTracks?: outputs.media.TrackSelectionResponse[];
        /**
         * Representing default content key for each encryption scheme and separate content keys for specific tracks
         */
        contentKeys?: outputs.media.StreamingPolicyContentKeysResponse;
        /**
         * Configuration of DRMs for CommonEncryptionCenc encryption scheme
         */
        drm?: outputs.media.CencDrmConfigurationResponse;
        /**
         * Representing supported protocols
         */
        enabledProtocols?: outputs.media.EnabledProtocolsResponse;
    }

    /**
     * Base class for Content Key Policy configuration. A derived class must be used to create a configuration.
     */
    export interface ContentKeyPolicyConfigurationResponse {
    }

    /**
     * Represents a policy option.
     */
    export interface ContentKeyPolicyOptionResponse {
        /**
         * The key delivery configuration.
         */
        configuration: outputs.media.ContentKeyPolicyConfigurationResponse;
        /**
         * The Policy Option description.
         */
        name?: string;
        /**
         * The legacy Policy Option ID.
         */
        policyOptionId: string;
        /**
         * The requirements that must be met to deliver keys with this configuration
         */
        restriction: outputs.media.ContentKeyPolicyRestrictionResponse;
    }

    /**
     * The properties of the Content Key Policy.
     */
    export interface ContentKeyPolicyPropertiesResponse {
        /**
         * The creation date of the Policy
         */
        created: string;
        /**
         * A description for the Policy.
         */
        description?: string;
        /**
         * The last modified date of the Policy
         */
        lastModified: string;
        /**
         * The Key Policy options.
         */
        options: outputs.media.ContentKeyPolicyOptionResponse[];
        /**
         * The legacy Policy ID.
         */
        policyId: string;
    }

    /**
     * Base class for Content Key Policy restrictions. A derived class must be used to create a restriction.
     */
    export interface ContentKeyPolicyRestrictionResponse {
    }

    /**
     * The client access policy.
     */
    export interface CrossSiteAccessPoliciesResponse {
        /**
         * The content of clientaccesspolicy.xml used by Silverlight.
         */
        clientAccessPolicy?: string;
        /**
         * The content of crossdomain.xml used by Silverlight.
         */
        crossDomainPolicy?: string;
    }

    /**
     * Class to specify properties of default content key for each encryption scheme
     */
    export interface DefaultKeyResponse {
        /**
         * Label can be used to specify Content Key when creating a Streaming Locator
         */
        label?: string;
        /**
         * Policy used by Default Key
         */
        policyName?: string;
    }

    export interface EdgeUsageDataCollectionPolicyResponse {
        /**
         * Usage data collection frequency in ISO 8601 duration format e.g. PT10M , PT5H.
         */
        dataCollectionFrequency?: string;
        /**
         * Usage data reporting frequency in ISO 8601 duration format e.g. PT10M , PT5H.
         */
        dataReportingFrequency?: string;
        /**
         * Details of Event Hub where the usage will be reported.
         */
        eventHubDetails?: outputs.media.EdgeUsageDataEventHubResponse;
        /**
         * Maximum time for which the functionality of the device will not be hampered for not reporting the usage data.
         */
        maxAllowedUnreportedUsageDuration?: string;
    }

    export interface EdgeUsageDataEventHubResponse {
        /**
         * Name of the Event Hub where usage will be reported.
         */
        name?: string;
        /**
         * Namespace of the Event Hub where usage will be reported.
         */
        namespace?: string;
        /**
         * SAS token needed to interact with Event Hub.
         */
        token?: string;
    }

    /**
     * Class to specify which protocols are enabled
     */
    export interface EnabledProtocolsResponse {
        /**
         * Enable DASH protocol or not
         */
        dash: boolean;
        /**
         * Enable Download protocol or not
         */
        download: boolean;
        /**
         * Enable HLS protocol or not
         */
        hls: boolean;
        /**
         * Enable SmoothStreaming protocol or not
         */
        smoothStreaming: boolean;
    }

    /**
     * Class for EnvelopeEncryption encryption scheme
     */
    export interface EnvelopeEncryptionResponse {
        /**
         * Representing which tracks should not be encrypted
         */
        clearTracks?: outputs.media.TrackSelectionResponse[];
        /**
         * Representing default content key for each encryption scheme and separate content keys for specific tracks
         */
        contentKeys?: outputs.media.StreamingPolicyContentKeysResponse;
        /**
         * Template for the URL of the custom service delivering keys to end user players.  Not required when using Azure Media Services for issuing keys.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
         */
        customKeyAcquisitionUrlTemplate?: string;
        /**
         * Representing supported protocols
         */
        enabledProtocols?: outputs.media.EnabledProtocolsResponse;
    }

    /**
     * The class to specify one track property condition.
     */
    export interface FilterTrackPropertyConditionResponse {
        /**
         * The track property condition operation.
         */
        operation: string;
        /**
         * The track property type.
         */
        property: string;
        /**
         * The track property value.
         */
        value: string;
    }

    /**
     * Representing a list of FilterTrackPropertyConditions to select a track.  The filters are combined using a logical AND operation.
     */
    export interface FilterTrackSelectionResponse {
        /**
         * The track selections.
         */
        trackSelections: outputs.media.FilterTrackPropertyConditionResponse[];
    }

    /**
     * Filter First Quality
     */
    export interface FirstQualityResponse {
        /**
         * The first quality bitrate.
         */
        bitrate: number;
    }

    /**
     * The HLS configuration.
     */
    export interface HlsResponse {
        /**
         * The amount of fragments per HTTP Live Streaming (HLS) segment.
         */
        fragmentsPerTsSegment?: number;
    }

    /**
     * The IP access control.
     */
    export interface IPAccessControlResponse {
        /**
         * The IP allow list.
         */
        allow?: outputs.media.IPRangeResponse[];
    }

    /**
     * The IP address range in the CIDR scheme.
     */
    export interface IPRangeResponse {
        /**
         * The IP address.
         */
        address?: string;
        /**
         * The friendly name for the IP address range.
         */
        name?: string;
        /**
         * The subnet mask prefix length (see CIDR notation).
         */
        subnetPrefixLength?: number;
    }

    /**
     * Details of JobOutput errors.
     */
    export interface JobErrorDetailResponse {
        /**
         * Code describing the error detail.
         */
        code: string;
        /**
         * A human-readable representation of the error.
         */
        message: string;
    }

    /**
     * Details of JobOutput errors.
     */
    export interface JobErrorResponse {
        /**
         * Helps with categorization of errors.
         */
        category: string;
        /**
         * Error code describing the error.
         */
        code: string;
        /**
         * An array of details about specific errors that led to this reported error.
         */
        details: outputs.media.JobErrorDetailResponse[];
        /**
         * A human-readable language-dependent representation of the error.
         */
        message: string;
        /**
         * Indicates that it may be possible to retry the Job. If retry is unsuccessful, please contact Azure support via Azure Portal.
         */
        retry: string;
    }

    /**
     * Base class for inputs to a Job.
     */
    export interface JobInputResponse {
    }

    /**
     * Describes all the properties of a JobOutput.
     */
    export interface JobOutputResponse {
        /**
         * The UTC date and time at which this Job Output finished processing.
         */
        endTime: string;
        /**
         * If the JobOutput is in the Error state, it contains the details of the error.
         */
        error: outputs.media.JobErrorResponse;
        /**
         * A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more than one TransformOutput, whereby your Job has more than one JobOutput. In such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the Transform. Subsequently, when you retrieve the Job, either through events or on a GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}' will be used, where the preset name is the name of the preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the Job. Note that this index is the same as the relative index of the corresponding TransformOutput within its Transform.
         */
        label?: string;
        /**
         * If the JobOutput is in a Processing state, this contains the Job completion percentage. The value is an estimate and not intended to be used to predict Job completion times. To determine if the JobOutput is complete, use the State property.
         */
        progress: number;
        /**
         * The UTC date and time at which this Job Output began processing.
         */
        startTime: string;
        /**
         * Describes the state of the JobOutput.
         */
        state: string;
    }

    /**
     * Properties of the Job.
     */
    export interface JobPropertiesResponse {
        /**
         * Customer provided key, value pairs that will be returned in Job and JobOutput state events.
         */
        correlationData?: {[key: string]: string};
        /**
         * The UTC date and time when the Job was created, in 'YYYY-MM-DDThh:mm:ssZ' format.
         */
        created: string;
        /**
         * Optional customer supplied description of the Job.
         */
        description?: string;
        /**
         * The UTC date and time at which this Job finished processing.
         */
        endTime: string;
        /**
         * The inputs for the Job.
         */
        input: outputs.media.JobInputResponse;
        /**
         * The UTC date and time when the Job was last updated, in 'YYYY-MM-DDThh:mm:ssZ' format.
         */
        lastModified: string;
        /**
         * The outputs for the Job.
         */
        outputs: outputs.media.JobOutputResponse[];
        /**
         * Priority with which the job should be processed. Higher priority jobs are processed before lower priority jobs. If not set, the default is normal.
         */
        priority?: string;
        /**
         * The UTC date and time at which this Job began processing.
         */
        startTime: string;
        /**
         * The current state of the job.
         */
        state: string;
    }

    export interface KeyVaultPropertiesResponse {
        /**
         * The current key used to encrypt the Media Services account, including the key version.
         */
        currentKeyIdentifier: string;
        /**
         * The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
         */
        keyIdentifier?: string;
    }

    /**
     * The Live Event encoding.
     */
    export interface LiveEventEncodingResponse {
        /**
         * The encoding type for Live Event. This value is specified at creation time and cannot be updated. When encodingType is set to None, the service simply passes through the incoming video and audio layer(s) to the output. When encodingType is set to Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bit rates or layers. See https://go.microsoft.com/fwlink/?linkid=2095101 for more information. The encodingType of Basic is obsolete – if specified, the service will treat this as a Standard Live Event.
         */
        encodingType?: string;
        /**
         * The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot be updated. If the encodingType is set to Standard, then the default preset name is ‘Default720p’. Else if the encodingType is set to Premium1080p, the default preset is ‘Default1080p’.
         */
        presetName?: string;
    }

    /**
     * The Live Event endpoint.
     */
    export interface LiveEventEndpointResponse {
        /**
         * The endpoint protocol.
         */
        protocol?: string;
        /**
         * The endpoint URL.
         */
        url?: string;
    }

    /**
     * The IP access control for Live Event Input.
     */
    export interface LiveEventInputAccessControlResponse {
        /**
         * The IP access control properties.
         */
        ip?: outputs.media.IPAccessControlResponse;
    }

    /**
     * The Live Event input.
     */
    export interface LiveEventInputResponse {
        /**
         * The access control for LiveEvent Input.
         */
        accessControl?: outputs.media.LiveEventInputAccessControlResponse;
        /**
         * A UUID in string form to uniquely identify the stream. This can be specified at creation time but cannot be updated.  If omitted, the service will generate a unique value.
         */
        accessToken?: string;
        /**
         * The input endpoints for the Live Event.
         */
        endpoints?: outputs.media.LiveEventEndpointResponse[];
        /**
         * ISO 8601 timespan duration of the key frame interval duration.
         */
        keyFrameIntervalDuration?: string;
        /**
         * The streaming protocol for the Live Event.  This is specified at creation time and cannot be updated.
         */
        streamingProtocol: string;
    }

    /**
     * The IP access control for Live Event preview.
     */
    export interface LiveEventPreviewAccessControlResponse {
        /**
         * The IP access control properties.
         */
        ip?: outputs.media.IPAccessControlResponse;
    }

    /**
     * The Live Event preview.
     */
    export interface LiveEventPreviewResponse {
        /**
         * The access control for LiveEvent preview.
         */
        accessControl?: outputs.media.LiveEventPreviewAccessControlResponse;
        /**
         * An Alternative Media Identifier associated with the StreamingLocator created for the preview.  This value is specified at creation time and cannot be updated.  The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.
         */
        alternativeMediaId?: string;
        /**
         * The endpoints for preview.
         */
        endpoints?: outputs.media.LiveEventEndpointResponse[];
        /**
         * The identifier of the preview locator in Guid format.  Specifying this at creation time allows the caller to know the preview locator url before the event is created.  If omitted, the service will generate a random identifier.  This value cannot be updated once the live event is created.
         */
        previewLocator?: string;
        /**
         * The name of streaming policy used for the LiveEvent preview.  This value is specified at creation time and cannot be updated.
         */
        streamingPolicyName?: string;
    }

    /**
     * The Live Event properties.
     */
    export interface LiveEventPropertiesResponse {
        /**
         * The exact time the Live Event was created.
         */
        created: string;
        /**
         * The Live Event access policies.
         */
        crossSiteAccessPolicies?: outputs.media.CrossSiteAccessPoliciesResponse;
        /**
         * The Live Event description.
         */
        description?: string;
        /**
         * The Live Event encoding.
         */
        encoding?: outputs.media.LiveEventEncodingResponse;
        /**
         * The Live Event input.
         */
        input: outputs.media.LiveEventInputResponse;
        /**
         * The exact time the Live Event was last modified.
         */
        lastModified: string;
        /**
         * The Live Event preview.
         */
        preview?: outputs.media.LiveEventPreviewResponse;
        /**
         * The provisioning state of the Live Event.
         */
        provisioningState: string;
        /**
         * The resource state of the Live Event.
         */
        resourceState: string;
        /**
         * The options to use for the LiveEvent.  This value is specified at creation time and cannot be updated. The valid values for the array entry values are 'Default' and 'LowLatency'.
         */
        streamOptions?: string[];
        /**
         * Specifies whether to use a vanity url with the Live Event.  This value is specified at creation time and cannot be updated.
         */
        useStaticHostname?: boolean;
    }

    /**
     * The JSON object that contains the properties required to create a Live Output.
     */
    export interface LiveOutputPropertiesResponse {
        /**
         * ISO 8601 timespan duration of the archive window length. This is duration that customer want to retain the recorded content.
         */
        archiveWindowLength: string;
        /**
         * The asset name.
         */
        assetName: string;
        /**
         * The exact time the Live Output was created.
         */
        created: string;
        /**
         * The description of the Live Output.
         */
        description?: string;
        /**
         * The HLS configuration.
         */
        hls?: outputs.media.HlsResponse;
        /**
         * The exact time the Live Output was last modified.
         */
        lastModified: string;
        /**
         * The manifest file name.  If not provided, the service will generate one automatically.
         */
        manifestName?: string;
        /**
         * The output snapshot time.
         */
        outputSnapTime?: number;
        /**
         * The provisioning state of the Live Output.
         */
        provisioningState: string;
        /**
         * The resource state of the Live Output.
         */
        resourceState: string;
    }

    /**
     * The Media Filter properties.
     */
    export interface MediaFilterPropertiesResponse {
        /**
         * The first quality.
         */
        firstQuality?: outputs.media.FirstQualityResponse;
        /**
         * The presentation time range.
         */
        presentationTimeRange?: outputs.media.PresentationTimeRangeResponse;
        /**
         * The tracks selection conditions.
         */
        tracks?: outputs.media.FilterTrackSelectionResponse[];
    }

    export interface MediaServiceIdentityResponse {
        /**
         * The Principal ID of the identity.
         */
        principalId: string;
        /**
         * The Tenant ID of the identity.
         */
        tenantId: string;
        /**
         * The identity type.
         */
        type: string;
    }

    /**
     * Properties of the Media Services account.
     */
    export interface MediaServicePropertiesResponse {
        /**
         * The account encryption properties.
         */
        encryption?: outputs.media.AccountEncryptionResponse;
        /**
         * The Media Services account ID.
         */
        mediaServiceId: string;
        /**
         * The storage accounts for this resource.
         */
        storageAccounts?: outputs.media.StorageAccountResponse[];
        storageAuthentication?: string;
    }

    /**
     * Class for NoEncryption scheme
     */
    export interface NoEncryptionResponse {
        /**
         * Representing supported protocols
         */
        enabledProtocols?: outputs.media.EnabledProtocolsResponse;
    }

    /**
     * The presentation time range, this is asset related and not recommended for Account Filter.
     */
    export interface PresentationTimeRangeResponse {
        /**
         * The absolute end time boundary.
         */
        endTimestamp?: number;
        /**
         * The indicator of forcing existing of end time stamp.
         */
        forceEndTimestamp?: boolean;
        /**
         * The relative to end right edge.
         */
        liveBackoffDuration?: number;
        /**
         * The relative to end sliding window.
         */
        presentationWindowDuration?: number;
        /**
         * The absolute start time boundary.
         */
        startTimestamp?: number;
        /**
         * The time scale of time stamps.
         */
        timescale?: number;
    }

    /**
     * Base type for all Presets, which define the recipe or instructions on how the input media files should be processed.
     */
    export interface PresetResponse {
    }

    /**
     * Properties of the PrivateEndpointConnectProperties.
     */
    export interface PrivateEndpointConnectionPropertiesResponse {
        /**
         * The resource of private end point.
         */
        privateEndpoint?: outputs.media.PrivateEndpointResponse;
        /**
         * A collection of information about the state of the connection between service consumer and provider.
         */
        privateLinkServiceConnectionState: outputs.media.PrivateLinkServiceConnectionStateResponse;
        /**
         * The provisioning state of the private endpoint connection resource.
         */
        provisioningState?: string;
    }

    /**
     * The Private Endpoint resource.
     */
    export interface PrivateEndpointResponse {
        /**
         * The ARM identifier for Private Endpoint
         */
        id: string;
    }

    /**
     * A collection of information about the state of the connection between service consumer and provider.
     */
    export interface PrivateLinkServiceConnectionStateResponse {
        /**
         * A message indicating if changes on the service provider require any updates on the consumer.
         */
        actionsRequired?: string;
        /**
         * The reason for approval/rejection of the connection.
         */
        description?: string;
        /**
         * Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
         */
        status?: string;
    }

    /**
     * The storage account details.
     */
    export interface StorageAccountResponse {
        /**
         * The ID of the storage account resource. Media Services relies on tables and queues as well as blobs, so the primary storage account must be a Standard Storage account (either Microsoft.ClassicStorage or Microsoft.Storage). Blob only storage accounts can be added as secondary storage accounts.
         */
        id?: string;
        /**
         * The type of the storage account.
         */
        type: string;
    }

    /**
     * StreamingEndpoint access control definition.
     */
    export interface StreamingEndpointAccessControlResponse {
        /**
         * The access control of Akamai
         */
        akamai?: outputs.media.AkamaiAccessControlResponse;
        /**
         * The IP access control of the StreamingEndpoint.
         */
        ip?: outputs.media.IPAccessControlResponse;
    }

    /**
     * The StreamingEndpoint properties.
     */
    export interface StreamingEndpointPropertiesResponse {
        /**
         * The access control definition of the StreamingEndpoint.
         */
        accessControl?: outputs.media.StreamingEndpointAccessControlResponse;
        /**
         * The name of the AvailabilitySet used with this StreamingEndpoint for high availability streaming.  This value can only be set at creation time.
         */
        availabilitySetName?: string;
        /**
         * The CDN enabled flag.
         */
        cdnEnabled?: boolean;
        /**
         * The CDN profile name.
         */
        cdnProfile?: string;
        /**
         * The CDN provider name.
         */
        cdnProvider?: string;
        /**
         * The exact time the StreamingEndpoint was created.
         */
        created: string;
        /**
         * The StreamingEndpoint access policies.
         */
        crossSiteAccessPolicies?: outputs.media.CrossSiteAccessPoliciesResponse;
        /**
         * The custom host names of the StreamingEndpoint
         */
        customHostNames?: string[];
        /**
         * The StreamingEndpoint description.
         */
        description?: string;
        /**
         * The free trial expiration time.
         */
        freeTrialEndTime: string;
        /**
         * The StreamingEndpoint host name.
         */
        hostName: string;
        /**
         * The exact time the StreamingEndpoint was last modified.
         */
        lastModified: string;
        /**
         * Max cache age
         */
        maxCacheAge?: number;
        /**
         * The provisioning state of the StreamingEndpoint.
         */
        provisioningState: string;
        /**
         * The resource state of the StreamingEndpoint.
         */
        resourceState: string;
        /**
         * The number of scale units.  Use the Scale operation to adjust this value.
         */
        scaleUnits: number;
    }

    /**
     * Class for content key in Streaming Locator
     */
    export interface StreamingLocatorContentKeyResponse {
        /**
         * ID of Content Key
         */
        id: string;
        /**
         * Label of Content Key as specified in the Streaming Policy
         */
        labelReferenceInStreamingPolicy?: string;
        /**
         * ContentKeyPolicy used by Content Key
         */
        policyName: string;
        /**
         * Tracks which use this Content Key
         */
        tracks: outputs.media.TrackSelectionResponse[];
        /**
         * Encryption type of Content Key
         */
        type: string;
        /**
         * Value of Content Key
         */
        value?: string;
    }

    /**
     * Properties of the Streaming Locator.
     */
    export interface StreamingLocatorPropertiesResponse {
        /**
         * Alternative Media ID of this Streaming Locator
         */
        alternativeMediaId?: string;
        /**
         * Asset Name
         */
        assetName: string;
        /**
         * The ContentKeys used by this Streaming Locator.
         */
        contentKeys?: outputs.media.StreamingLocatorContentKeyResponse[];
        /**
         * The creation time of the Streaming Locator.
         */
        created: string;
        /**
         * Name of the default ContentKeyPolicy used by this Streaming Locator.
         */
        defaultContentKeyPolicyName?: string;
        /**
         * The end time of the Streaming Locator.
         */
        endTime?: string;
        /**
         * A list of asset or account filters which apply to this streaming locator
         */
        filters?: string[];
        /**
         * The start time of the Streaming Locator.
         */
        startTime?: string;
        /**
         * The StreamingLocatorId of the Streaming Locator.
         */
        streamingLocatorId?: string;
        /**
         * Name of the Streaming Policy used by this Streaming Locator. Either specify the name of Streaming Policy you created or use one of the predefined Streaming Policies. The predefined Streaming Policies available are: 'Predefined_DownloadOnly', 'Predefined_ClearStreamingOnly', 'Predefined_DownloadAndClearStreaming', 'Predefined_ClearKey', 'Predefined_MultiDrmCencStreaming' and 'Predefined_MultiDrmStreaming'
         */
        streamingPolicyName: string;
    }

    /**
     * Class of paths for streaming
     */
    export interface StreamingPathResponse {
        /**
         * Encryption scheme
         */
        encryptionScheme: string;
        /**
         * Streaming paths for each protocol and encryptionScheme pair
         */
        paths?: string[];
        /**
         * Streaming protocol
         */
        streamingProtocol: string;
    }

    /**
     * Class to specify properties of content key
     */
    export interface StreamingPolicyContentKeyResponse {
        /**
         * Label can be used to specify Content Key when creating a Streaming Locator
         */
        label?: string;
        /**
         * Policy used by Content Key
         */
        policyName?: string;
        /**
         * Tracks which use this content key
         */
        tracks?: outputs.media.TrackSelectionResponse[];
    }

    /**
     * Class to specify properties of all content keys in Streaming Policy
     */
    export interface StreamingPolicyContentKeysResponse {
        /**
         * Default content key for an encryption scheme
         */
        defaultKey?: outputs.media.DefaultKeyResponse;
        /**
         * Representing tracks needs separate content key
         */
        keyToTrackMappings?: outputs.media.StreamingPolicyContentKeyResponse[];
    }

    /**
     * Class to specify configurations of FairPlay in Streaming Policy
     */
    export interface StreamingPolicyFairPlayConfigurationResponse {
        /**
         * All license to be persistent or not
         */
        allowPersistentLicense: boolean;
        /**
         * Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
         */
        customLicenseAcquisitionUrlTemplate?: string;
    }

    /**
     * Class to specify configurations of PlayReady in Streaming Policy
     */
    export interface StreamingPolicyPlayReadyConfigurationResponse {
        /**
         * Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
         */
        customLicenseAcquisitionUrlTemplate?: string;
        /**
         * Custom attributes for PlayReady
         */
        playReadyCustomAttributes?: string;
    }

    /**
     * Class to specify properties of Streaming Policy
     */
    export interface StreamingPolicyPropertiesResponse {
        /**
         * Configuration of CommonEncryptionCbcs
         */
        commonEncryptionCbcs?: outputs.media.CommonEncryptionCbcsResponse;
        /**
         * Configuration of CommonEncryptionCenc
         */
        commonEncryptionCenc?: outputs.media.CommonEncryptionCencResponse;
        /**
         * Creation time of Streaming Policy
         */
        created: string;
        /**
         * Default ContentKey used by current Streaming Policy
         */
        defaultContentKeyPolicyName?: string;
        /**
         * Configuration of EnvelopeEncryption
         */
        envelopeEncryption?: outputs.media.EnvelopeEncryptionResponse;
        /**
         * Configurations of NoEncryption
         */
        noEncryption?: outputs.media.NoEncryptionResponse;
    }

    /**
     * Class to specify configurations of Widevine in Streaming Policy
     */
    export interface StreamingPolicyWidevineConfigurationResponse {
        /**
         * Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
         */
        customLicenseAcquisitionUrlTemplate?: string;
    }

    /**
     * Class to specify one track property condition
     */
    export interface TrackPropertyConditionResponse {
        /**
         * Track property condition operation
         */
        operation: string;
        /**
         * Track property type
         */
        property: string;
        /**
         * Track property value
         */
        value?: string;
    }

    /**
     * Class to select a track
     */
    export interface TrackSelectionResponse {
        /**
         * TrackSelections is a track property condition list which can specify track(s)
         */
        trackSelections?: outputs.media.TrackPropertyConditionResponse[];
    }

    /**
     * Describes the properties of a TransformOutput, which are the rules to be applied while generating the desired output.
     */
    export interface TransformOutputResponse {
        /**
         * A Transform can define more than one outputs. This property defines what the service should do when one output fails - either continue to produce other outputs, or, stop the other outputs. The overall Job state will not reflect failures of outputs that are specified with 'ContinueJob'. The default is 'StopProcessingJob'.
         */
        onError?: string;
        /**
         * Preset that describes the operations that will be used to modify, transcode, or extract insights from the source file to generate the output.
         */
        preset: outputs.media.PresetResponse;
        /**
         * Sets the relative priority of the TransformOutputs within a Transform. This sets the priority that the service uses for processing TransformOutputs. The default priority is Normal.
         */
        relativePriority?: string;
    }

    /**
     * A Transform.
     */
    export interface TransformPropertiesResponse {
        /**
         * The UTC date and time when the Transform was created, in 'YYYY-MM-DDThh:mm:ssZ' format.
         */
        created: string;
        /**
         * An optional verbose description of the Transform.
         */
        description?: string;
        /**
         * The UTC date and time when the Transform was last updated, in 'YYYY-MM-DDThh:mm:ssZ' format.
         */
        lastModified: string;
        /**
         * An array of one or more TransformOutputs that the Transform should generate.
         */
        outputs: outputs.media.TransformOutputResponse[];
    }
}

export namespace migrate {
    /**
     * Properties of an assessment.
     */
    export interface AssessmentPropertiesResponse {
        /**
         * Storage type selected for this disk.
         */
        azureDiskType: string;
        /**
         * AHUB discount on windows virtual machines.
         */
        azureHybridUseBenefit: string;
        /**
         * Target Azure location for which the machines should be assessed. These enums are the same as used by Compute API.
         */
        azureLocation: string;
        /**
         * Offer code according to which cost estimation is done.
         */
        azureOfferCode: string;
        /**
         * Pricing tier for Size evaluation.
         */
        azurePricingTier: string;
        /**
         * Storage Redundancy type offered by Azure.
         */
        azureStorageRedundancy: string;
        /**
         * List of azure VM families.
         */
        azureVmFamilies: string[];
        /**
         * Confidence rating percentage for assessment. Can be in the range [0, 100].
         */
        confidenceRatingInPercentage: number;
        /**
         * Time when this project was created. Date-Time represented in ISO-8601 format.
         */
        createdTimestamp: string;
        /**
         * Currency to report prices in.
         */
        currency: string;
        /**
         * Custom discount percentage to be applied on final costs. Can be in the range [0, 100].
         */
        discountPercentage: number;
        /**
         * Enterprise agreement subscription arm id.
         */
        eaSubscriptionId: string;
        /**
         * Monthly network cost estimate for the machines that are part of this assessment as a group, for a 31-day month.
         */
        monthlyBandwidthCost: number;
        /**
         * Monthly compute cost estimate for the machines that are part of this assessment as a group, for a 31-day month.
         */
        monthlyComputeCost: number;
        /**
         * Monthly premium storage cost estimate for the machines that are part of this assessment as a group, for a 31-day month.
         */
        monthlyPremiumStorageCost: number;
        /**
         * Monthly standard SSD storage cost estimate for the machines that are part of this assessment as a group, for a 31-day month.
         */
        monthlyStandardSSDStorageCost: number;
        /**
         * Monthly storage cost estimate for the machines that are part of this assessment as a group, for a 31-day month.
         */
        monthlyStorageCost: number;
        /**
         * Number of assessed machines part of this assessment.
         */
        numberOfMachines: number;
        /**
         * Percentile of performance data used to recommend Azure size.
         */
        percentile: string;
        /**
         * End time to consider performance data for assessment
         */
        perfDataEndTime: string;
        /**
         * Start time to consider performance data for assessment
         */
        perfDataStartTime: string;
        /**
         * Time when the Azure Prices were queried. Date-Time represented in ISO-8601 format.
         */
        pricesTimestamp: string;
        /**
         * Azure reserved instance.
         */
        reservedInstance: string;
        /**
         * Scaling factor used over utilization data to add a performance buffer for new machines to be created in Azure. Min Value = 1.0, Max value = 1.9, Default = 1.3.
         */
        scalingFactor: number;
        /**
         * Assessment sizing criterion.
         */
        sizingCriterion: string;
        /**
         * User configurable setting that describes the status of the assessment.
         */
        stage: string;
        /**
         * Whether the assessment has been created and is valid.
         */
        status: string;
        /**
         * Time range of performance data used to recommend a size.
         */
        timeRange: string;
        /**
         * Time when this project was last updated. Date-Time represented in ISO-8601 format.
         */
        updatedTimestamp: string;
        /**
         * Specify the duration for which the VMs are up in the on-premises environment.
         */
        vmUptime: outputs.migrate.VmUptimeResponse;
    }

    export interface CollectorAgentPropertiesResponse {
        id: string;
        lastHeartbeatUtc: string;
        spnDetails?: outputs.migrate.CollectorBodyAgentSpnPropertiesResponse;
        version: string;
    }

    export interface CollectorBodyAgentSpnPropertiesResponse {
        /**
         * Application/client Id for the service principal with which the on-premise management/data plane components would communicate with our Azure services.
         */
        applicationId?: string;
        /**
         * Intended audience for the service principal.
         */
        audience?: string;
        /**
         * AAD Authority URL which was used to request the token for the service principal.
         */
        authority?: string;
        /**
         * Object Id of the service principal with which the on-premise management/data plane components would communicate with our Azure services.
         */
        objectId?: string;
        /**
         * Tenant Id for the service principal with which the on-premise management/data plane components would communicate with our Azure services.
         */
        tenantId?: string;
    }

    export interface CollectorPropertiesResponse {
        agentProperties?: outputs.migrate.CollectorAgentPropertiesResponse;
        /**
         * Time when this collector was created. Date-Time represented in ISO-8601 format.
         */
        createdTimestamp: string;
        /**
         * The ARM id of the discovery service site.
         */
        discoverySiteId?: string;
        /**
         * Time when this collector was updated. Date-Time represented in ISO-8601 format.
         */
        updatedTimestamp: string;
    }

    /**
     * Properties of group resource.
     */
    export interface GroupPropertiesResponse {
        /**
         * If the assessments are in running state.
         */
        areAssessmentsRunning: boolean;
        /**
         * List of References to Assessments created on this group.
         */
        assessments: string[];
        /**
         * Time when this group was created. Date-Time represented in ISO-8601 format.
         */
        createdTimestamp: string;
        /**
         * Whether the group has been created and is valid.
         */
        groupStatus: string;
        /**
         * Number of machines part of this group.
         */
        machineCount: number;
        /**
         * Time when this group was last updated. Date-Time represented in ISO-8601 format.
         */
        updatedTimestamp: string;
    }

    /**
     * Properties of a project.
     */
    export interface ProjectPropertiesResponse {
        /**
         * Assessment solution ARM id tracked by Microsoft.Migrate/migrateProjects.
         */
        assessmentSolutionId?: string;
        /**
         * Time when this project was created. Date-Time represented in ISO-8601 format.
         */
        createdTimestamp: string;
        /**
         * The ARM id of service map workspace created by customer.
         */
        customerWorkspaceId?: string;
        /**
         * Location of service map workspace created by customer.
         */
        customerWorkspaceLocation?: string;
        /**
         * Time when last assessment was created. Date-Time represented in ISO-8601 format. This value will be null until assessment is created.
         */
        lastAssessmentTimestamp: string;
        /**
         * Number of assessments created in the project.
         */
        numberOfAssessments: number;
        /**
         * Number of groups created in the project.
         */
        numberOfGroups: number;
        /**
         * Number of machines in the project.
         */
        numberOfMachines: number;
        /**
         * Assessment project status.
         */
        projectStatus?: string;
        /**
         * Provisioning state of the project.
         */
        provisioningState: string;
        /**
         * Endpoint at which the collector agent can call agent REST API.
         */
        serviceEndpoint: string;
        /**
         * Time when this project was last updated. Date-Time represented in ISO-8601 format.
         */
        updatedTimestamp: string;
    }

    export interface VmUptimeResponse {
        /**
         * Number of days in a month for VM uptime.
         */
        daysPerMonth?: number;
        /**
         * Number of hours per day for VM uptime.
         */
        hoursPerDay?: number;
    }
}

export namespace mixedreality {
    /**
     * Common Properties shared by Mixed Reality Accounts
     */
    export interface MixedRealityAccountPropertiesResponse {
        /**
         * Correspond domain name of certain Spatial Anchors Account
         */
        accountDomain: string;
        /**
         * unique id of certain account.
         */
        accountId: string;
    }

}

export namespace netapp {
    /**
     * NetApp account properties
     */
    export interface AccountPropertiesResponse {
        /**
         * Active Directories
         */
        activeDirectories?: outputs.netapp.ActiveDirectoryResponse[];
        /**
         * Azure lifecycle management
         */
        provisioningState: string;
    }

    /**
     * Active Directory
     */
    export interface ActiveDirectoryResponse {
        /**
         * Id of the Active Directory
         */
        activeDirectoryId?: string;
        /**
         * Comma separated list of DNS server IP addresses (IPv4 only) for the Active Directory domain
         */
        dns?: string;
        /**
         * Name of the Active Directory domain
         */
        domain?: string;
        /**
         * The Organizational Unit (OU) within the Windows Active Directory
         */
        organizationalUnit?: string;
        /**
         * Plain text password of Active Directory domain administrator
         */
        password?: string;
        /**
         * The Active Directory site the service will limit Domain Controller discovery to
         */
        site?: string;
        /**
         * NetBIOS name of the SMB server. This name will be registered as a computer account in the AD and used to mount volumes
         */
        smbServerName?: string;
        /**
         * Status of the Active Directory
         */
        status?: string;
        /**
         * Username of Active Directory domain administrator
         */
        username?: string;
    }

    /**
     * Mount target properties
     */
    export interface MountTargetPropertiesResponse {
        /**
         * The end of IPv4 address range to use when creating a new mount target
         */
        endIp?: string;
        /**
         * UUID v4 used to identify the MountTarget
         */
        fileSystemId: string;
        /**
         * The gateway of the IPv4 address range to use when creating a new mount target
         */
        gateway?: string;
        /**
         * The mount target's IPv4 address
         */
        ipAddress: string;
        /**
         * UUID v4 used to identify the MountTarget
         */
        mountTargetId: string;
        /**
         * The netmask of the IPv4 address range to use when creating a new mount target
         */
        netmask?: string;
        /**
         * The SMB server's Fully Qualified Domain Name, FQDN
         */
        smbServerFqdn?: string;
        /**
         * The start of IPv4 address range to use when creating a new mount target
         */
        startIp?: string;
        /**
         * The subnet
         */
        subnet?: string;
    }

    /**
     * Pool properties
     */
    export interface PoolPropertiesResponse {
        /**
         * UUID v4 used to identify the Pool
         */
        poolId: string;
        /**
         * Azure lifecycle management
         */
        provisioningState: string;
        /**
         * The service level of the file system
         */
        serviceLevel: string;
        /**
         * Provisioned size of the pool (in bytes). Allowed values are in 4TiB chunks (value must be multiply of 4398046511104).
         */
        size: number;
    }

    /**
     * Replication properties
     */
    export interface ReplicationObjectResponse {
        /**
         * Indicates whether the local volume is the source or destination for the Volume Replication
         */
        endpointType?: string;
        /**
         * The remote region for the other end of the Volume Replication.
         */
        remoteVolumeRegion?: string;
        /**
         * The resource ID of the remote volume.
         */
        remoteVolumeResourceId: string;
        /**
         * Id
         */
        replicationId?: string;
        /**
         * Schedule
         */
        replicationSchedule: string;
    }

    /**
     * Tags are a list of key-value pairs that describe the resource
     */
    export interface ResourceTagsResponse {
    }

    /**
     * Snapshot properties
     */
    export interface SnapshotPropertiesResponse {
        /**
         * The creation date of the snapshot
         */
        created: string;
        /**
         * UUID v4 used to identify the FileSystem
         */
        fileSystemId?: string;
        /**
         * Azure lifecycle management
         */
        provisioningState: string;
        /**
         * UUID v4 used to identify the Snapshot
         */
        snapshotId: string;
    }

    /**
     * Volume properties
     */
    export interface VolumePropertiesResponse {
        /**
         * Unique Baremetal Tenant Identifier.
         */
        baremetalTenantId: string;
        /**
         * A unique file path for the volume. Used when creating mount targets
         */
        creationToken: string;
        /**
         * DataProtection type volumes include an object containing details of the replication
         */
        dataProtection?: outputs.netapp.VolumePropertiesResponseProperties;
        /**
         * Set of export policy rules
         */
        exportPolicy?: outputs.netapp.VolumePropertiesResponseProperties;
        /**
         * Unique FileSystem Identifier.
         */
        fileSystemId: string;
        /**
         * Restoring
         */
        isRestoring?: boolean;
        /**
         * List of mount targets
         */
        mountTargets?: outputs.netapp.MountTargetPropertiesResponse[];
        /**
         * Set of protocol types
         */
        protocolTypes?: string[];
        /**
         * Azure lifecycle management
         */
        provisioningState: string;
        /**
         * The service level of the file system
         */
        serviceLevel?: string;
        /**
         * UUID v4 or resource identifier used to identify the Snapshot.
         */
        snapshotId?: string;
        /**
         * The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes
         */
        subnetId: string;
        /**
         * Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is 100 GiB. Upper limit is 100TiB. Specified in bytes.
         */
        usageThreshold: number;
        /**
         * What type of volume is this
         */
        volumeType?: string;
    }

    /**
     * DataProtection type volumes include an object containing details of the replication
     */
    export interface VolumePropertiesResponseProperties {
        /**
         * Replication properties
         */
        replication?: outputs.netapp.ReplicationObjectResponse;
    }
}

export namespace network {
    /**
     * AAD Vpn authentication type related parameters.
     */
    export interface AadAuthenticationParametersResponse {
        /**
         * AAD Vpn authentication parameter AAD audience.
         */
        aadAudience?: string;
        /**
         * AAD Vpn authentication parameter AAD issuer.
         */
        aadIssuer?: string;
        /**
         * AAD Vpn authentication parameter AAD tenant.
         */
        aadTenant?: string;
    }

    /**
     * AddressSpace contains an array of IP address ranges that can be used by subnets of the virtual network.
     */
    export interface AddressSpaceResponse {
        /**
         * A list of address blocks reserved for this virtual network in CIDR notation.
         */
        addressPrefixes?: string[];
    }

    /**
     * Authentication certificates properties of an application gateway.
     */
    export interface ApplicationGatewayAuthenticationCertificatePropertiesFormatResponse {
        /**
         * Certificate public data.
         */
        data?: string;
        /**
         * The provisioning state of the authentication certificate resource.
         */
        provisioningState: string;
    }

    /**
     * Authentication certificates of an application gateway.
     */
    export interface ApplicationGatewayAuthenticationCertificateResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the authentication certificate that is unique within an Application Gateway.
         */
        name?: string;
        /**
         * Properties of the application gateway authentication certificate.
         */
        properties?: outputs.network.ApplicationGatewayAuthenticationCertificatePropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Application Gateway autoscale configuration.
     */
    export interface ApplicationGatewayAutoscaleConfigurationResponse {
        /**
         * Upper bound on number of Application Gateway capacity.
         */
        maxCapacity?: number;
        /**
         * Lower bound on number of Application Gateway capacity.
         */
        minCapacity: number;
    }

    /**
     * Properties of Backend Address Pool of an application gateway.
     */
    export interface ApplicationGatewayBackendAddressPoolPropertiesFormatResponse {
        /**
         * Backend addresses.
         */
        backendAddresses?: outputs.network.ApplicationGatewayBackendAddressResponse[];
        /**
         * Collection of references to IPs defined in network interfaces.
         */
        backendIPConfigurations: outputs.network.NetworkInterfaceIPConfigurationResponse[];
        /**
         * The provisioning state of the backend address pool resource.
         */
        provisioningState: string;
    }

    /**
     * Backend Address Pool of an application gateway.
     */
    export interface ApplicationGatewayBackendAddressPoolResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the backend address pool that is unique within an Application Gateway.
         */
        name?: string;
        /**
         * Properties of the application gateway backend address pool.
         */
        properties?: outputs.network.ApplicationGatewayBackendAddressPoolPropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Backend address of an application gateway.
     */
    export interface ApplicationGatewayBackendAddressResponse {
        /**
         * Fully qualified domain name (FQDN).
         */
        fqdn?: string;
        /**
         * IP address.
         */
        ipAddress?: string;
    }

    /**
     * Properties of Backend address pool settings of an application gateway.
     */
    export interface ApplicationGatewayBackendHttpSettingsPropertiesFormatResponse {
        /**
         * Cookie name to use for the affinity cookie.
         */
        affinityCookieName?: string;
        /**
         * Array of references to application gateway authentication certificates.
         */
        authenticationCertificates?: outputs.network.SubResourceResponse[];
        /**
         * Connection draining of the backend http settings resource.
         */
        connectionDraining?: outputs.network.ApplicationGatewayConnectionDrainingResponse;
        /**
         * Cookie based affinity.
         */
        cookieBasedAffinity?: string;
        /**
         * Host header to be sent to the backend servers.
         */
        hostName?: string;
        /**
         * Path which should be used as a prefix for all HTTP requests. Null means no path will be prefixed. Default value is null.
         */
        path?: string;
        /**
         * Whether to pick host header should be picked from the host name of the backend server. Default value is false.
         */
        pickHostNameFromBackendAddress?: boolean;
        /**
         * The destination port on the backend.
         */
        port?: number;
        /**
         * Probe resource of an application gateway.
         */
        probe?: outputs.network.SubResourceResponse;
        /**
         * Whether the probe is enabled. Default value is false.
         */
        probeEnabled?: boolean;
        /**
         * The protocol used to communicate with the backend.
         */
        protocol?: string;
        /**
         * The provisioning state of the backend HTTP settings resource.
         */
        provisioningState: string;
        /**
         * Request timeout in seconds. Application Gateway will fail the request if response is not received within RequestTimeout. Acceptable values are from 1 second to 86400 seconds.
         */
        requestTimeout?: number;
        /**
         * Array of references to application gateway trusted root certificates.
         */
        trustedRootCertificates?: outputs.network.SubResourceResponse[];
    }

    /**
     * Backend address pool settings of an application gateway.
     */
    export interface ApplicationGatewayBackendHttpSettingsResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the backend http settings that is unique within an Application Gateway.
         */
        name?: string;
        /**
         * Properties of the application gateway backend HTTP settings.
         */
        properties?: outputs.network.ApplicationGatewayBackendHttpSettingsPropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Connection draining allows open connections to a backend server to be active for a specified time after the backend server got removed from the configuration.
     */
    export interface ApplicationGatewayConnectionDrainingResponse {
        /**
         * The number of seconds connection draining is active. Acceptable values are from 1 second to 3600 seconds.
         */
        drainTimeoutInSec: number;
        /**
         * Whether connection draining is enabled or not.
         */
        enabled: boolean;
    }

    /**
     * Customer error of an application gateway.
     */
    export interface ApplicationGatewayCustomErrorResponse {
        /**
         * Error page URL of the application gateway customer error.
         */
        customErrorPageUrl?: string;
        /**
         * Status code of the application gateway customer error.
         */
        statusCode?: string;
    }

    /**
     * Allows to disable rules within a rule group or an entire rule group.
     */
    export interface ApplicationGatewayFirewallDisabledRuleGroupResponse {
        /**
         * The name of the rule group that will be disabled.
         */
        ruleGroupName: string;
        /**
         * The list of rules that will be disabled. If null, all rules of the rule group will be disabled.
         */
        rules?: number[];
    }

    /**
     * Allow to exclude some variable satisfy the condition for the WAF check.
     */
    export interface ApplicationGatewayFirewallExclusionResponse {
        /**
         * The variable to be excluded.
         */
        matchVariable: string;
        /**
         * When matchVariable is a collection, operator used to specify which elements in the collection this exclusion applies to.
         */
        selector: string;
        /**
         * When matchVariable is a collection, operate on the selector to specify which elements in the collection this exclusion applies to.
         */
        selectorMatchOperator: string;
    }

    /**
     * Properties of Frontend IP configuration of an application gateway.
     */
    export interface ApplicationGatewayFrontendIPConfigurationPropertiesFormatResponse {
        /**
         * PrivateIPAddress of the network interface IP Configuration.
         */
        privateIPAddress?: string;
        /**
         * The private IP address allocation method.
         */
        privateIPAllocationMethod?: string;
        /**
         * Reference to the application gateway private link configuration.
         */
        privateLinkConfiguration?: outputs.network.SubResourceResponse;
        /**
         * The provisioning state of the frontend IP configuration resource.
         */
        provisioningState: string;
        /**
         * Reference to the PublicIP resource.
         */
        publicIPAddress?: outputs.network.SubResourceResponse;
        /**
         * Reference to the subnet resource.
         */
        subnet?: outputs.network.SubResourceResponse;
    }

    /**
     * Frontend IP configuration of an application gateway.
     */
    export interface ApplicationGatewayFrontendIPConfigurationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the frontend IP configuration that is unique within an Application Gateway.
         */
        name?: string;
        /**
         * Properties of the application gateway frontend IP configuration.
         */
        properties?: outputs.network.ApplicationGatewayFrontendIPConfigurationPropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Properties of Frontend port of an application gateway.
     */
    export interface ApplicationGatewayFrontendPortPropertiesFormatResponse {
        /**
         * Frontend port.
         */
        port?: number;
        /**
         * The provisioning state of the frontend port resource.
         */
        provisioningState: string;
    }

    /**
     * Frontend port of an application gateway.
     */
    export interface ApplicationGatewayFrontendPortResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the frontend port that is unique within an Application Gateway.
         */
        name?: string;
        /**
         * Properties of the application gateway frontend port.
         */
        properties?: outputs.network.ApplicationGatewayFrontendPortPropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Header configuration of the Actions set in Application Gateway.
     */
    export interface ApplicationGatewayHeaderConfigurationResponse {
        /**
         * Header name of the header configuration.
         */
        headerName?: string;
        /**
         * Header value of the header configuration.
         */
        headerValue?: string;
    }

    /**
     * Properties of HTTP listener of an application gateway.
     */
    export interface ApplicationGatewayHttpListenerPropertiesFormatResponse {
        /**
         * Custom error configurations of the HTTP listener.
         */
        customErrorConfigurations?: outputs.network.ApplicationGatewayCustomErrorResponse[];
        /**
         * Reference to the FirewallPolicy resource.
         */
        firewallPolicy?: outputs.network.SubResourceResponse;
        /**
         * Frontend IP configuration resource of an application gateway.
         */
        frontendIPConfiguration?: outputs.network.SubResourceResponse;
        /**
         * Frontend port resource of an application gateway.
         */
        frontendPort?: outputs.network.SubResourceResponse;
        /**
         * Host name of HTTP listener.
         */
        hostName?: string;
        /**
         * List of Host names for HTTP Listener that allows special wildcard characters as well.
         */
        hostNames?: string[];
        /**
         * Protocol of the HTTP listener.
         */
        protocol?: string;
        /**
         * The provisioning state of the HTTP listener resource.
         */
        provisioningState: string;
        /**
         * Applicable only if protocol is https. Enables SNI for multi-hosting.
         */
        requireServerNameIndication?: boolean;
        /**
         * SSL certificate resource of an application gateway.
         */
        sslCertificate?: outputs.network.SubResourceResponse;
    }

    /**
     * Http listener of an application gateway.
     */
    export interface ApplicationGatewayHttpListenerResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the HTTP listener that is unique within an Application Gateway.
         */
        name?: string;
        /**
         * Properties of the application gateway HTTP listener.
         */
        properties?: outputs.network.ApplicationGatewayHttpListenerPropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Properties of IP configuration of an application gateway.
     */
    export interface ApplicationGatewayIPConfigurationPropertiesFormatResponse {
        /**
         * The provisioning state of the application gateway IP configuration resource.
         */
        provisioningState: string;
        /**
         * Reference to the subnet resource. A subnet from where application gateway gets its private address.
         */
        subnet?: outputs.network.SubResourceResponse;
    }

    /**
     * IP configuration of an application gateway. Currently 1 public and 1 private IP configuration is allowed.
     */
    export interface ApplicationGatewayIPConfigurationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the IP configuration that is unique within an Application Gateway.
         */
        name?: string;
        /**
         * Properties of the application gateway IP configuration.
         */
        properties?: outputs.network.ApplicationGatewayIPConfigurationPropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Properties of path rule of an application gateway.
     */
    export interface ApplicationGatewayPathRulePropertiesFormatResponse {
        /**
         * Backend address pool resource of URL path map path rule.
         */
        backendAddressPool?: outputs.network.SubResourceResponse;
        /**
         * Backend http settings resource of URL path map path rule.
         */
        backendHttpSettings?: outputs.network.SubResourceResponse;
        /**
         * Reference to the FirewallPolicy resource.
         */
        firewallPolicy?: outputs.network.SubResourceResponse;
        /**
         * Path rules of URL path map.
         */
        paths?: string[];
        /**
         * The provisioning state of the path rule resource.
         */
        provisioningState: string;
        /**
         * Redirect configuration resource of URL path map path rule.
         */
        redirectConfiguration?: outputs.network.SubResourceResponse;
        /**
         * Rewrite rule set resource of URL path map path rule.
         */
        rewriteRuleSet?: outputs.network.SubResourceResponse;
    }

    /**
     * Path rule of URL path map of an application gateway.
     */
    export interface ApplicationGatewayPathRuleResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the path rule that is unique within an Application Gateway.
         */
        name?: string;
        /**
         * Properties of the application gateway path rule.
         */
        properties?: outputs.network.ApplicationGatewayPathRulePropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Properties of Private Link Resource of an application gateway.
     */
    export interface ApplicationGatewayPrivateEndpointConnectionPropertiesResponse {
        /**
         * The consumer link id.
         */
        linkIdentifier: string;
        /**
         * The resource of private end point.
         */
        privateEndpoint: outputs.network.PrivateEndpointResponse;
        /**
         * A collection of information about the state of the connection between service consumer and provider.
         */
        privateLinkServiceConnectionState?: outputs.network.PrivateLinkServiceConnectionStateResponse;
        /**
         * The provisioning state of the application gateway private endpoint connection resource.
         */
        provisioningState: string;
    }

    /**
     * Private Endpoint connection on an application gateway.
     */
    export interface ApplicationGatewayPrivateEndpointConnectionResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the private endpoint connection on an application gateway.
         */
        name?: string;
        /**
         * Properties of the application gateway private endpoint connection.
         */
        properties?: outputs.network.ApplicationGatewayPrivateEndpointConnectionPropertiesResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Properties of private link configuration on an application gateway.
     */
    export interface ApplicationGatewayPrivateLinkConfigurationPropertiesResponse {
        /**
         * An array of application gateway private link ip configurations.
         */
        ipConfigurations?: outputs.network.ApplicationGatewayPrivateLinkIpConfigurationResponse[];
        /**
         * The provisioning state of the application gateway private link configuration.
         */
        provisioningState: string;
    }

    /**
     * Private Link Configuration on an application gateway.
     */
    export interface ApplicationGatewayPrivateLinkConfigurationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the private link configuration that is unique within an Application Gateway.
         */
        name?: string;
        /**
         * Properties of the application gateway private link configuration.
         */
        properties?: outputs.network.ApplicationGatewayPrivateLinkConfigurationPropertiesResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Properties of an application gateway private link IP configuration.
     */
    export interface ApplicationGatewayPrivateLinkIpConfigurationPropertiesResponse {
        /**
         * Whether the ip configuration is primary or not.
         */
        primary?: boolean;
        /**
         * The private IP address of the IP configuration.
         */
        privateIPAddress?: string;
        /**
         * The private IP address allocation method.
         */
        privateIPAllocationMethod?: string;
        /**
         * The provisioning state of the application gateway private link IP configuration.
         */
        provisioningState: string;
        /**
         * Reference to the subnet resource.
         */
        subnet?: outputs.network.SubResourceResponse;
    }

    /**
     * The application gateway private link ip configuration.
     */
    export interface ApplicationGatewayPrivateLinkIpConfigurationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of application gateway private link ip configuration.
         */
        name?: string;
        /**
         * Properties of an application gateway private link ip configuration.
         */
        properties?: outputs.network.ApplicationGatewayPrivateLinkIpConfigurationPropertiesResponse;
        /**
         * The resource type.
         */
        type: string;
    }

    /**
     * Application gateway probe health response match.
     */
    export interface ApplicationGatewayProbeHealthResponseMatchResponse {
        /**
         * Body that must be contained in the health response. Default value is empty.
         */
        body?: string;
        /**
         * Allowed ranges of healthy status codes. Default range of healthy status codes is 200-399.
         */
        statusCodes?: string[];
    }

    /**
     * Properties of probe of an application gateway.
     */
    export interface ApplicationGatewayProbePropertiesFormatResponse {
        /**
         * Host name to send the probe to.
         */
        host?: string;
        /**
         * The probing interval in seconds. This is the time interval between two consecutive probes. Acceptable values are from 1 second to 86400 seconds.
         */
        interval?: number;
        /**
         * Criterion for classifying a healthy probe response.
         */
        match?: outputs.network.ApplicationGatewayProbeHealthResponseMatchResponse;
        /**
         * Minimum number of servers that are always marked healthy. Default value is 0.
         */
        minServers?: number;
        /**
         * Relative path of probe. Valid path starts from '/'. Probe is sent to <Protocol>://<host>:<port><path>.
         */
        path?: string;
        /**
         * Whether the host header should be picked from the backend http settings. Default value is false.
         */
        pickHostNameFromBackendHttpSettings?: boolean;
        /**
         * Custom port which will be used for probing the backend servers. The valid value ranges from 1 to 65535. In case not set, port from http settings will be used. This property is valid for Standard_v2 and WAF_v2 only.
         */
        port?: number;
        /**
         * The protocol used for the probe.
         */
        protocol?: string;
        /**
         * The provisioning state of the probe resource.
         */
        provisioningState: string;
        /**
         * The probe timeout in seconds. Probe marked as failed if valid response is not received with this timeout period. Acceptable values are from 1 second to 86400 seconds.
         */
        timeout?: number;
        /**
         * The probe retry count. Backend server is marked down after consecutive probe failure count reaches UnhealthyThreshold. Acceptable values are from 1 second to 20.
         */
        unhealthyThreshold?: number;
    }

    /**
     * Probe of the application gateway.
     */
    export interface ApplicationGatewayProbeResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the probe that is unique within an Application Gateway.
         */
        name?: string;
        /**
         * Properties of the application gateway probe.
         */
        properties?: outputs.network.ApplicationGatewayProbePropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Properties of the application gateway.
     */
    export interface ApplicationGatewayPropertiesFormatResponse {
        /**
         * Authentication certificates of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
         */
        authenticationCertificates?: outputs.network.ApplicationGatewayAuthenticationCertificateResponse[];
        /**
         * Autoscale Configuration.
         */
        autoscaleConfiguration?: outputs.network.ApplicationGatewayAutoscaleConfigurationResponse;
        /**
         * Backend address pool of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
         */
        backendAddressPools?: outputs.network.ApplicationGatewayBackendAddressPoolResponse[];
        /**
         * Backend http settings of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
         */
        backendHttpSettingsCollection?: outputs.network.ApplicationGatewayBackendHttpSettingsResponse[];
        /**
         * Custom error configurations of the application gateway resource.
         */
        customErrorConfigurations?: outputs.network.ApplicationGatewayCustomErrorResponse[];
        /**
         * Whether FIPS is enabled on the application gateway resource.
         */
        enableFips?: boolean;
        /**
         * Whether HTTP2 is enabled on the application gateway resource.
         */
        enableHttp2?: boolean;
        /**
         * Reference to the FirewallPolicy resource.
         */
        firewallPolicy?: outputs.network.SubResourceResponse;
        /**
         * If true, associates a firewall policy with an application gateway regardless whether the policy differs from the WAF Config.
         */
        forceFirewallPolicyAssociation?: boolean;
        /**
         * Frontend IP addresses of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
         */
        frontendIPConfigurations?: outputs.network.ApplicationGatewayFrontendIPConfigurationResponse[];
        /**
         * Frontend ports of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
         */
        frontendPorts?: outputs.network.ApplicationGatewayFrontendPortResponse[];
        /**
         * Subnets of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
         */
        gatewayIPConfigurations?: outputs.network.ApplicationGatewayIPConfigurationResponse[];
        /**
         * Http listeners of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
         */
        httpListeners?: outputs.network.ApplicationGatewayHttpListenerResponse[];
        /**
         * Operational state of the application gateway resource.
         */
        operationalState: string;
        /**
         * Private Endpoint connections on application gateway.
         */
        privateEndpointConnections: outputs.network.ApplicationGatewayPrivateEndpointConnectionResponse[];
        /**
         * PrivateLink configurations on application gateway.
         */
        privateLinkConfigurations?: outputs.network.ApplicationGatewayPrivateLinkConfigurationResponse[];
        /**
         * Probes of the application gateway resource.
         */
        probes?: outputs.network.ApplicationGatewayProbeResponse[];
        /**
         * The provisioning state of the application gateway resource.
         */
        provisioningState: string;
        /**
         * Redirect configurations of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
         */
        redirectConfigurations?: outputs.network.ApplicationGatewayRedirectConfigurationResponse[];
        /**
         * Request routing rules of the application gateway resource.
         */
        requestRoutingRules?: outputs.network.ApplicationGatewayRequestRoutingRuleResponse[];
        /**
         * The resource GUID property of the application gateway resource.
         */
        resourceGuid: string;
        /**
         * Rewrite rules for the application gateway resource.
         */
        rewriteRuleSets?: outputs.network.ApplicationGatewayRewriteRuleSetResponse[];
        /**
         * SKU of the application gateway resource.
         */
        sku?: outputs.network.ApplicationGatewaySkuResponse;
        /**
         * SSL certificates of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
         */
        sslCertificates?: outputs.network.ApplicationGatewaySslCertificateResponse[];
        /**
         * SSL policy of the application gateway resource.
         */
        sslPolicy?: outputs.network.ApplicationGatewaySslPolicyResponse;
        /**
         * Trusted Root certificates of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
         */
        trustedRootCertificates?: outputs.network.ApplicationGatewayTrustedRootCertificateResponse[];
        /**
         * URL path map of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
         */
        urlPathMaps?: outputs.network.ApplicationGatewayUrlPathMapResponse[];
        /**
         * Web application firewall configuration.
         */
        webApplicationFirewallConfiguration?: outputs.network.ApplicationGatewayWebApplicationFirewallConfigurationResponse;
    }

    /**
     * Properties of redirect configuration of the application gateway.
     */
    export interface ApplicationGatewayRedirectConfigurationPropertiesFormatResponse {
        /**
         * Include path in the redirected url.
         */
        includePath?: boolean;
        /**
         * Include query string in the redirected url.
         */
        includeQueryString?: boolean;
        /**
         * Path rules specifying redirect configuration.
         */
        pathRules?: outputs.network.SubResourceResponse[];
        /**
         * HTTP redirection type.
         */
        redirectType?: string;
        /**
         * Request routing specifying redirect configuration.
         */
        requestRoutingRules?: outputs.network.SubResourceResponse[];
        /**
         * Reference to a listener to redirect the request to.
         */
        targetListener?: outputs.network.SubResourceResponse;
        /**
         * Url to redirect the request to.
         */
        targetUrl?: string;
        /**
         * Url path maps specifying default redirect configuration.
         */
        urlPathMaps?: outputs.network.SubResourceResponse[];
    }

    /**
     * Redirect configuration of an application gateway.
     */
    export interface ApplicationGatewayRedirectConfigurationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the redirect configuration that is unique within an Application Gateway.
         */
        name?: string;
        /**
         * Properties of the application gateway redirect configuration.
         */
        properties?: outputs.network.ApplicationGatewayRedirectConfigurationPropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Properties of request routing rule of the application gateway.
     */
    export interface ApplicationGatewayRequestRoutingRulePropertiesFormatResponse {
        /**
         * Backend address pool resource of the application gateway.
         */
        backendAddressPool?: outputs.network.SubResourceResponse;
        /**
         * Backend http settings resource of the application gateway.
         */
        backendHttpSettings?: outputs.network.SubResourceResponse;
        /**
         * Http listener resource of the application gateway.
         */
        httpListener?: outputs.network.SubResourceResponse;
        /**
         * Priority of the request routing rule.
         */
        priority?: number;
        /**
         * The provisioning state of the request routing rule resource.
         */
        provisioningState: string;
        /**
         * Redirect configuration resource of the application gateway.
         */
        redirectConfiguration?: outputs.network.SubResourceResponse;
        /**
         * Rewrite Rule Set resource in Basic rule of the application gateway.
         */
        rewriteRuleSet?: outputs.network.SubResourceResponse;
        /**
         * Rule type.
         */
        ruleType?: string;
        /**
         * URL path map resource of the application gateway.
         */
        urlPathMap?: outputs.network.SubResourceResponse;
    }

    /**
     * Request routing rule of an application gateway.
     */
    export interface ApplicationGatewayRequestRoutingRuleResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the request routing rule that is unique within an Application Gateway.
         */
        name?: string;
        /**
         * Properties of the application gateway request routing rule.
         */
        properties?: outputs.network.ApplicationGatewayRequestRoutingRulePropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Application gateway resource.
     */
    export interface ApplicationGatewayResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The identity of the application gateway, if configured.
         */
        identity?: outputs.network.ManagedServiceIdentityResponse;
        /**
         * Resource location.
         */
        location?: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Properties of the application gateway.
         */
        properties?: outputs.network.ApplicationGatewayPropertiesFormatResponse;
        /**
         * Resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Resource type.
         */
        type: string;
        /**
         * A list of availability zones denoting where the resource needs to come from.
         */
        zones?: string[];
    }

    /**
     * Set of actions in the Rewrite Rule in Application Gateway.
     */
    export interface ApplicationGatewayRewriteRuleActionSetResponse {
        /**
         * Request Header Actions in the Action Set.
         */
        requestHeaderConfigurations?: outputs.network.ApplicationGatewayHeaderConfigurationResponse[];
        /**
         * Response Header Actions in the Action Set.
         */
        responseHeaderConfigurations?: outputs.network.ApplicationGatewayHeaderConfigurationResponse[];
        /**
         * Url Configuration Action in the Action Set.
         */
        urlConfiguration?: outputs.network.ApplicationGatewayUrlConfigurationResponse;
    }

    /**
     * Set of conditions in the Rewrite Rule in Application Gateway.
     */
    export interface ApplicationGatewayRewriteRuleConditionResponse {
        /**
         * Setting this paramter to truth value with force the pattern to do a case in-sensitive comparison.
         */
        ignoreCase?: boolean;
        /**
         * Setting this value as truth will force to check the negation of the condition given by the user.
         */
        negate?: boolean;
        /**
         * The pattern, either fixed string or regular expression, that evaluates the truthfulness of the condition.
         */
        pattern?: string;
        /**
         * The condition parameter of the RewriteRuleCondition.
         */
        variable?: string;
    }

    /**
     * Rewrite rule of an application gateway.
     */
    export interface ApplicationGatewayRewriteRuleResponse {
        /**
         * Set of actions to be done as part of the rewrite Rule.
         */
        actionSet?: outputs.network.ApplicationGatewayRewriteRuleActionSetResponse;
        /**
         * Conditions based on which the action set execution will be evaluated.
         */
        conditions?: outputs.network.ApplicationGatewayRewriteRuleConditionResponse[];
        /**
         * Name of the rewrite rule that is unique within an Application Gateway.
         */
        name?: string;
        /**
         * Rule Sequence of the rewrite rule that determines the order of execution of a particular rule in a RewriteRuleSet.
         */
        ruleSequence?: number;
    }

    /**
     * Properties of rewrite rule set of the application gateway.
     */
    export interface ApplicationGatewayRewriteRuleSetPropertiesFormatResponse {
        /**
         * The provisioning state of the rewrite rule set resource.
         */
        provisioningState: string;
        /**
         * Rewrite rules in the rewrite rule set.
         */
        rewriteRules?: outputs.network.ApplicationGatewayRewriteRuleResponse[];
    }

    /**
     * Rewrite rule set of an application gateway.
     */
    export interface ApplicationGatewayRewriteRuleSetResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the rewrite rule set that is unique within an Application Gateway.
         */
        name?: string;
        /**
         * Properties of the application gateway rewrite rule set.
         */
        properties?: outputs.network.ApplicationGatewayRewriteRuleSetPropertiesFormatResponse;
    }

    /**
     * SKU of an application gateway.
     */
    export interface ApplicationGatewaySkuResponse {
        /**
         * Capacity (instance count) of an application gateway.
         */
        capacity?: number;
        /**
         * Name of an application gateway SKU.
         */
        name?: string;
        /**
         * Tier of an application gateway.
         */
        tier?: string;
    }

    /**
     * Properties of SSL certificates of an application gateway.
     */
    export interface ApplicationGatewaySslCertificatePropertiesFormatResponse {
        /**
         * Base-64 encoded pfx certificate. Only applicable in PUT Request.
         */
        data?: string;
        /**
         * Secret Id of (base-64 encoded unencrypted pfx) 'Secret' or 'Certificate' object stored in KeyVault.
         */
        keyVaultSecretId?: string;
        /**
         * Password for the pfx file specified in data. Only applicable in PUT request.
         */
        password?: string;
        /**
         * The provisioning state of the SSL certificate resource.
         */
        provisioningState: string;
        /**
         * Base-64 encoded Public cert data corresponding to pfx specified in data. Only applicable in GET request.
         */
        publicCertData: string;
    }

    /**
     * SSL certificates of an application gateway.
     */
    export interface ApplicationGatewaySslCertificateResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the SSL certificate that is unique within an Application Gateway.
         */
        name?: string;
        /**
         * Properties of the application gateway SSL certificate.
         */
        properties?: outputs.network.ApplicationGatewaySslCertificatePropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Application Gateway Ssl policy.
     */
    export interface ApplicationGatewaySslPolicyResponse {
        /**
         * Ssl cipher suites to be enabled in the specified order to application gateway.
         */
        cipherSuites?: string[];
        /**
         * Ssl protocols to be disabled on application gateway.
         */
        disabledSslProtocols?: string[];
        /**
         * Minimum version of Ssl protocol to be supported on application gateway.
         */
        minProtocolVersion?: string;
        /**
         * Name of Ssl predefined policy.
         */
        policyName?: string;
        /**
         * Type of Ssl Policy.
         */
        policyType?: string;
    }

    /**
     * Trusted Root certificates properties of an application gateway.
     */
    export interface ApplicationGatewayTrustedRootCertificatePropertiesFormatResponse {
        /**
         * Certificate public data.
         */
        data?: string;
        /**
         * Secret Id of (base-64 encoded unencrypted pfx) 'Secret' or 'Certificate' object stored in KeyVault.
         */
        keyVaultSecretId?: string;
        /**
         * The provisioning state of the trusted root certificate resource.
         */
        provisioningState: string;
    }

    /**
     * Trusted Root certificates of an application gateway.
     */
    export interface ApplicationGatewayTrustedRootCertificateResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the trusted root certificate that is unique within an Application Gateway.
         */
        name?: string;
        /**
         * Properties of the application gateway trusted root certificate.
         */
        properties?: outputs.network.ApplicationGatewayTrustedRootCertificatePropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Url configuration of the Actions set in Application Gateway.
     */
    export interface ApplicationGatewayUrlConfigurationResponse {
        /**
         * Url path which user has provided for url rewrite. Null means no path will be updated. Default value is null.
         */
        modifiedPath?: string;
        /**
         * Query string which user has provided for url rewrite. Null means no query string will be updated. Default value is null.
         */
        modifiedQueryString?: string;
        /**
         * If set as true, it will re-evaluate the url path map provided in path based request routing rules using modified path. Default value is false.
         */
        reroute?: boolean;
    }

    /**
     * Properties of UrlPathMap of the application gateway.
     */
    export interface ApplicationGatewayUrlPathMapPropertiesFormatResponse {
        /**
         * Default backend address pool resource of URL path map.
         */
        defaultBackendAddressPool?: outputs.network.SubResourceResponse;
        /**
         * Default backend http settings resource of URL path map.
         */
        defaultBackendHttpSettings?: outputs.network.SubResourceResponse;
        /**
         * Default redirect configuration resource of URL path map.
         */
        defaultRedirectConfiguration?: outputs.network.SubResourceResponse;
        /**
         * Default Rewrite rule set resource of URL path map.
         */
        defaultRewriteRuleSet?: outputs.network.SubResourceResponse;
        /**
         * Path rule of URL path map resource.
         */
        pathRules?: outputs.network.ApplicationGatewayPathRuleResponse[];
        /**
         * The provisioning state of the URL path map resource.
         */
        provisioningState: string;
    }

    /**
     * UrlPathMaps give a url path to the backend mapping information for PathBasedRouting.
     */
    export interface ApplicationGatewayUrlPathMapResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the URL path map that is unique within an Application Gateway.
         */
        name?: string;
        /**
         * Properties of the application gateway URL path map.
         */
        properties?: outputs.network.ApplicationGatewayUrlPathMapPropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Application gateway web application firewall configuration.
     */
    export interface ApplicationGatewayWebApplicationFirewallConfigurationResponse {
        /**
         * The disabled rule groups.
         */
        disabledRuleGroups?: outputs.network.ApplicationGatewayFirewallDisabledRuleGroupResponse[];
        /**
         * Whether the web application firewall is enabled or not.
         */
        enabled: boolean;
        /**
         * The exclusion list.
         */
        exclusions?: outputs.network.ApplicationGatewayFirewallExclusionResponse[];
        /**
         * Maximum file upload size in Mb for WAF.
         */
        fileUploadLimitInMb?: number;
        /**
         * Web application firewall mode.
         */
        firewallMode: string;
        /**
         * Maximum request body size for WAF.
         */
        maxRequestBodySize?: number;
        /**
         * Maximum request body size in Kb for WAF.
         */
        maxRequestBodySizeInKb?: number;
        /**
         * Whether allow WAF to check request Body.
         */
        requestBodyCheck?: boolean;
        /**
         * The type of the web application firewall rule set. Possible values are: 'OWASP'.
         */
        ruleSetType: string;
        /**
         * The version of the rule set type.
         */
        ruleSetVersion: string;
    }

    /**
     * Application security group properties.
     */
    export interface ApplicationSecurityGroupPropertiesFormatResponse {
        /**
         * The provisioning state of the application security group resource.
         */
        provisioningState: string;
        /**
         * The resource GUID property of the application security group resource. It uniquely identifies a resource, even if the user changes its name or migrate the resource across subscriptions or resource groups.
         */
        resourceGuid: string;
    }

    /**
     * An application security group in a resource group.
     */
    export interface ApplicationSecurityGroupResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource location.
         */
        location?: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Properties of the application security group.
         */
        properties?: outputs.network.ApplicationSecurityGroupPropertiesFormatResponse;
        /**
         * Resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Properties of ExpressRouteCircuitAuthorization.
     */
    export interface AuthorizationPropertiesFormatResponse {
        /**
         * The authorization key.
         */
        authorizationKey?: string;
        /**
         * The authorization use status.
         */
        authorizationUseStatus?: string;
        /**
         * The provisioning state of the authorization resource.
         */
        provisioningState: string;
    }

    /**
     * The additional properties of azure firewall.
     */
    export interface AzureFirewallAdditionalPropertiesResponse {
    }

    /**
     * Properties of the application rule collection.
     */
    export interface AzureFirewallApplicationRuleCollectionPropertiesFormatResponse {
        /**
         * The action type of a rule collection.
         */
        action?: outputs.network.AzureFirewallRCActionResponse;
        /**
         * Priority of the application rule collection resource.
         */
        priority?: number;
        /**
         * The provisioning state of the application rule collection resource.
         */
        provisioningState: string;
        /**
         * Collection of rules used by a application rule collection.
         */
        rules?: outputs.network.AzureFirewallApplicationRuleResponse[];
    }

    /**
     * Application rule collection resource.
     */
    export interface AzureFirewallApplicationRuleCollectionResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within the Azure firewall. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the azure firewall application rule collection.
         */
        properties?: outputs.network.AzureFirewallApplicationRuleCollectionPropertiesFormatResponse;
    }

    /**
     * Properties of the application rule protocol.
     */
    export interface AzureFirewallApplicationRuleProtocolResponse {
        /**
         * Port number for the protocol, cannot be greater than 64000. This field is optional.
         */
        port?: number;
        /**
         * Protocol type.
         */
        protocolType?: string;
    }

    /**
     * Properties of an application rule.
     */
    export interface AzureFirewallApplicationRuleResponse {
        /**
         * Description of the rule.
         */
        description?: string;
        /**
         * List of FQDN Tags for this rule.
         */
        fqdnTags?: string[];
        /**
         * Name of the application rule.
         */
        name?: string;
        /**
         * Array of ApplicationRuleProtocols.
         */
        protocols?: outputs.network.AzureFirewallApplicationRuleProtocolResponse[];
        /**
         * List of source IP addresses for this rule.
         */
        sourceAddresses?: string[];
        /**
         * List of source IpGroups for this rule.
         */
        sourceIpGroups?: string[];
        /**
         * List of FQDNs for this rule.
         */
        targetFqdns?: string[];
    }

    /**
     * Properties of IP configuration of an Azure Firewall.
     */
    export interface AzureFirewallIPConfigurationPropertiesFormatResponse {
        /**
         * The Firewall Internal Load Balancer IP to be used as the next hop in User Defined Routes.
         */
        privateIPAddress: string;
        /**
         * The provisioning state of the Azure firewall IP configuration resource.
         */
        provisioningState: string;
        /**
         * Reference to the PublicIP resource. This field is a mandatory input if subnet is not null.
         */
        publicIPAddress?: outputs.network.SubResourceResponse;
        /**
         * Reference to the subnet resource. This resource must be named 'AzureFirewallSubnet' or 'AzureFirewallManagementSubnet'.
         */
        subnet?: outputs.network.SubResourceResponse;
    }

    /**
     * IP configuration of an Azure Firewall.
     */
    export interface AzureFirewallIPConfigurationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the azure firewall IP configuration.
         */
        properties?: outputs.network.AzureFirewallIPConfigurationPropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * AzureFirewall NAT Rule Collection Action.
     */
    export interface AzureFirewallNatRCActionResponse {
        /**
         * The type of action.
         */
        type?: string;
    }

    /**
     * Properties of the NAT rule collection.
     */
    export interface AzureFirewallNatRuleCollectionPropertiesResponse {
        /**
         * The action type of a NAT rule collection.
         */
        action?: outputs.network.AzureFirewallNatRCActionResponse;
        /**
         * Priority of the NAT rule collection resource.
         */
        priority?: number;
        /**
         * The provisioning state of the NAT rule collection resource.
         */
        provisioningState: string;
        /**
         * Collection of rules used by a NAT rule collection.
         */
        rules?: outputs.network.AzureFirewallNatRuleResponse[];
    }

    /**
     * NAT rule collection resource.
     */
    export interface AzureFirewallNatRuleCollectionResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within the Azure firewall. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the azure firewall NAT rule collection.
         */
        properties?: outputs.network.AzureFirewallNatRuleCollectionPropertiesResponse;
    }

    /**
     * Properties of a NAT rule.
     */
    export interface AzureFirewallNatRuleResponse {
        /**
         * Description of the rule.
         */
        description?: string;
        /**
         * List of destination IP addresses for this rule. Supports IP ranges, prefixes, and service tags.
         */
        destinationAddresses?: string[];
        /**
         * List of destination ports.
         */
        destinationPorts?: string[];
        /**
         * Name of the NAT rule.
         */
        name?: string;
        /**
         * Array of AzureFirewallNetworkRuleProtocols applicable to this NAT rule.
         */
        protocols?: string[];
        /**
         * List of source IP addresses for this rule.
         */
        sourceAddresses?: string[];
        /**
         * List of source IpGroups for this rule.
         */
        sourceIpGroups?: string[];
        /**
         * The translated address for this NAT rule.
         */
        translatedAddress?: string;
        /**
         * The translated FQDN for this NAT rule.
         */
        translatedFqdn?: string;
        /**
         * The translated port for this NAT rule.
         */
        translatedPort?: string;
    }

    /**
     * Properties of the network rule collection.
     */
    export interface AzureFirewallNetworkRuleCollectionPropertiesFormatResponse {
        /**
         * The action type of a rule collection.
         */
        action?: outputs.network.AzureFirewallRCActionResponse;
        /**
         * Priority of the network rule collection resource.
         */
        priority?: number;
        /**
         * The provisioning state of the network rule collection resource.
         */
        provisioningState: string;
        /**
         * Collection of rules used by a network rule collection.
         */
        rules?: outputs.network.AzureFirewallNetworkRuleResponse[];
    }

    /**
     * Network rule collection resource.
     */
    export interface AzureFirewallNetworkRuleCollectionResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within the Azure firewall. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the azure firewall network rule collection.
         */
        properties?: outputs.network.AzureFirewallNetworkRuleCollectionPropertiesFormatResponse;
    }

    /**
     * Properties of the network rule.
     */
    export interface AzureFirewallNetworkRuleResponse {
        /**
         * Description of the rule.
         */
        description?: string;
        /**
         * List of destination IP addresses.
         */
        destinationAddresses?: string[];
        /**
         * List of destination FQDNs.
         */
        destinationFqdns?: string[];
        /**
         * List of destination IpGroups for this rule.
         */
        destinationIpGroups?: string[];
        /**
         * List of destination ports.
         */
        destinationPorts?: string[];
        /**
         * Name of the network rule.
         */
        name?: string;
        /**
         * Array of AzureFirewallNetworkRuleProtocols.
         */
        protocols?: string[];
        /**
         * List of source IP addresses for this rule.
         */
        sourceAddresses?: string[];
        /**
         * List of source IpGroups for this rule.
         */
        sourceIpGroups?: string[];
    }

    /**
     * Properties of the Azure Firewall.
     */
    export interface AzureFirewallPropertiesFormatResponse {
        /**
         * The additional properties used to further config this azure firewall.
         */
        additionalProperties?: outputs.network.AzureFirewallAdditionalPropertiesResponse;
        /**
         * Collection of application rule collections used by Azure Firewall.
         */
        applicationRuleCollections?: outputs.network.AzureFirewallApplicationRuleCollectionResponse[];
        /**
         * The firewallPolicy associated with this azure firewall.
         */
        firewallPolicy?: outputs.network.SubResourceResponse;
        /**
         * IP addresses associated with AzureFirewall.
         */
        hubIPAddresses?: outputs.network.HubIPAddressesResponse;
        /**
         * IP configuration of the Azure Firewall resource.
         */
        ipConfigurations?: outputs.network.AzureFirewallIPConfigurationResponse[];
        /**
         * IpGroups associated with AzureFirewall.
         */
        ipGroups: outputs.network.IpGroupsResponse;
        /**
         * IP configuration of the Azure Firewall used for management traffic.
         */
        managementIpConfiguration?: outputs.network.AzureFirewallIPConfigurationResponse;
        /**
         * Collection of NAT rule collections used by Azure Firewall.
         */
        natRuleCollections?: outputs.network.AzureFirewallNatRuleCollectionResponse[];
        /**
         * Collection of network rule collections used by Azure Firewall.
         */
        networkRuleCollections?: outputs.network.AzureFirewallNetworkRuleCollectionResponse[];
        /**
         * The provisioning state of the Azure firewall resource.
         */
        provisioningState: string;
        /**
         * The Azure Firewall Resource SKU.
         */
        sku?: outputs.network.AzureFirewallSkuResponse;
        /**
         * The operation mode for Threat Intelligence.
         */
        threatIntelMode?: string;
        /**
         * The virtualHub to which the firewall belongs.
         */
        virtualHub?: outputs.network.SubResourceResponse;
    }

    /**
     * Public IP Address associated with azure firewall.
     */
    export interface AzureFirewallPublicIPAddressResponse {
        /**
         * Public IP Address value.
         */
        address?: string;
    }

    /**
     * Properties of the AzureFirewallRCAction.
     */
    export interface AzureFirewallRCActionResponse {
        /**
         * The type of action.
         */
        type?: string;
    }

    /**
     * SKU of an Azure Firewall.
     */
    export interface AzureFirewallSkuResponse {
        /**
         * Name of an Azure Firewall SKU.
         */
        name?: string;
        /**
         * Tier of an Azure Firewall.
         */
        tier?: string;
    }

    /**
     * Properties of the backend address pool.
     */
    export interface BackendAddressPoolPropertiesFormatResponse {
        /**
         * An array of references to IP addresses defined in network interfaces.
         */
        backendIPConfigurations: outputs.network.NetworkInterfaceIPConfigurationResponse[];
        /**
         * An array of backend addresses.
         */
        loadBalancerBackendAddresses?: outputs.network.LoadBalancerBackendAddressResponse[];
        /**
         * An array of references to load balancing rules that use this backend address pool.
         */
        loadBalancingRules: outputs.network.SubResourceResponse[];
        /**
         * A reference to an outbound rule that uses this backend address pool.
         */
        outboundRule: outputs.network.SubResourceResponse;
        /**
         * An array of references to outbound rules that use this backend address pool.
         */
        outboundRules: outputs.network.SubResourceResponse[];
        /**
         * The provisioning state of the backend address pool resource.
         */
        provisioningState: string;
    }

    /**
     * Pool of backend IP addresses.
     */
    export interface BackendAddressPoolResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within the set of backend address pools used by the load balancer. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of load balancer backend address pool.
         */
        properties?: outputs.network.BackendAddressPoolPropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * The JSON object that contains the properties required to create a Backend Pool.
     */
    export interface BackendPoolPropertiesResponse {
        /**
         * The set of backends for this pool
         */
        backends?: outputs.network.BackendResponse[];
        /**
         * L7 health probe settings for a backend pool
         */
        healthProbeSettings?: outputs.network.SubResourceResponse;
        /**
         * Load balancing settings for a backend pool
         */
        loadBalancingSettings?: outputs.network.SubResourceResponse;
        /**
         * Resource status.
         */
        resourceState?: string;
    }

    /**
     * A backend pool is a collection of backends that can be routed to.
     */
    export interface BackendPoolResponse {
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource name.
         */
        name?: string;
        /**
         * Properties of the Front Door Backend Pool
         */
        properties?: outputs.network.BackendPoolPropertiesResponse;
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Settings that apply to all backend pools.
     */
    export interface BackendPoolsSettingsResponse {
        /**
         * Whether to enforce certificate name check on HTTPS requests to all backend pools. No effect on non-HTTPS requests.
         */
        enforceCertificateNameCheck?: string;
        /**
         * Send and receive timeout on forwarding request to the backend. When timeout is reached, the request fails and returns.
         */
        sendRecvTimeoutSeconds?: number;
    }

    /**
     * Backend address of a frontDoor load balancer.
     */
    export interface BackendResponse {
        /**
         * Location of the backend (IP address or FQDN)
         */
        address?: string;
        /**
         * The value to use as the host header sent to the backend. If blank or unspecified, this defaults to the incoming host.
         */
        backendHostHeader?: string;
        /**
         * Whether to enable use of this backend. Permitted values are 'Enabled' or 'Disabled'
         */
        enabledState?: string;
        /**
         * The HTTP TCP port number. Must be between 1 and 65535.
         */
        httpPort?: number;
        /**
         * The HTTPS TCP port number. Must be between 1 and 65535.
         */
        httpsPort?: number;
        /**
         * Priority to use for load balancing. Higher priorities will not be used for load balancing if any lower priority backend is healthy.
         */
        priority?: number;
        /**
         * The Approval status for the connection to the Private Link
         */
        privateEndpointStatus: string;
        /**
         * The Alias of the Private Link resource. Populating this optional field indicates that this backend is 'Private'
         */
        privateLinkAlias?: string;
        /**
         * A custom message to be included in the approval request to connect to the Private Link
         */
        privateLinkApprovalMessage?: string;
        /**
         * The location of the Private Link resource. Required only if 'privateLinkResourceId' is populated
         */
        privateLinkLocation?: string;
        /**
         * The Resource Id of the Private Link resource. Populating this optional field indicates that this backend is 'Private'
         */
        privateLinkResourceId?: string;
        /**
         * Weight of this endpoint for load balancing purposes.
         */
        weight?: number;
    }

    /**
     * Properties of IP configuration of an Bastion Host.
     */
    export interface BastionHostIPConfigurationPropertiesFormatResponse {
        /**
         * Private IP allocation method.
         */
        privateIPAllocationMethod?: string;
        /**
         * The provisioning state of the bastion host IP configuration resource.
         */
        provisioningState: string;
        /**
         * Reference of the PublicIP resource.
         */
        publicIPAddress: outputs.network.SubResourceResponse;
        /**
         * Reference of the subnet resource.
         */
        subnet: outputs.network.SubResourceResponse;
    }

    /**
     * IP configuration of an Bastion Host.
     */
    export interface BastionHostIPConfigurationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Represents the ip configuration associated with the resource.
         */
        properties?: outputs.network.BastionHostIPConfigurationPropertiesFormatResponse;
        /**
         * Ip configuration type.
         */
        type: string;
    }

    /**
     * Properties of the Bastion Host.
     */
    export interface BastionHostPropertiesFormatResponse {
        /**
         * FQDN for the endpoint on which bastion host is accessible.
         */
        dnsName?: string;
        /**
         * IP configuration of the Bastion Host resource.
         */
        ipConfigurations?: outputs.network.BastionHostIPConfigurationResponse[];
        /**
         * The provisioning state of the bastion host resource.
         */
        provisioningState: string;
    }

    /**
     * Properties of the bgp connection.
     */
    export interface BgpConnectionPropertiesResponse {
        /**
         * The current state of the VirtualHub to Peer.
         */
        connectionState: string;
        /**
         * Peer ASN.
         */
        peerAsn?: number;
        /**
         * Peer IP.
         */
        peerIp?: string;
        /**
         * The provisioning state of the resource.
         */
        provisioningState: string;
    }

    /**
     * BGP settings details.
     */
    export interface BgpSettingsResponse {
        /**
         * The BGP speaker's ASN.
         */
        asn?: number;
        /**
         * The BGP peering address and BGP identifier of this BGP speaker.
         */
        bgpPeeringAddress?: string;
        /**
         * BGP peering address with IP configuration ID for virtual network gateway.
         */
        bgpPeeringAddresses?: outputs.network.IPConfigurationBgpPeeringAddressResponse[];
        /**
         * The weight added to routes learned from this BGP speaker.
         */
        peerWeight?: number;
    }

    /**
     * Network Virtual Appliance Sku Properties.
     */
    export interface BreakOutCategoryPoliciesResponse {
        /**
         * Flag to control breakout of o365 allow category.
         */
        allow?: boolean;
        /**
         * Flag to control breakout of o365 default category.
         */
        default?: boolean;
        /**
         * Flag to control breakout of o365 optimize category.
         */
        optimize?: boolean;
    }

    /**
     * Describes the destination of connection monitor.
     */
    export interface ConnectionMonitorDestinationResponse {
        /**
         * Address of the connection monitor destination (IP or domain name).
         */
        address?: string;
        /**
         * The destination port used by connection monitor.
         */
        port?: number;
        /**
         * The ID of the resource used as the destination by connection monitor.
         */
        resourceId?: string;
    }

    /**
     * Describes the connection monitor endpoint filter item.
     */
    export interface ConnectionMonitorEndpointFilterItemResponse {
        /**
         * The address of the filter item.
         */
        address?: string;
        /**
         * The type of item included in the filter. Currently only 'AgentAddress' is supported.
         */
        type?: string;
    }

    /**
     * Describes the connection monitor endpoint filter.
     */
    export interface ConnectionMonitorEndpointFilterResponse {
        /**
         * List of items in the filter.
         */
        items?: outputs.network.ConnectionMonitorEndpointFilterItemResponse[];
        /**
         * The behavior of the endpoint filter. Currently only 'Include' is supported.
         */
        type?: string;
    }

    /**
     * Describes the connection monitor endpoint.
     */
    export interface ConnectionMonitorEndpointResponse {
        /**
         * Address of the connection monitor endpoint (IP or domain name).
         */
        address?: string;
        /**
         * Filter for sub-items within the endpoint.
         */
        filter?: outputs.network.ConnectionMonitorEndpointFilterResponse;
        /**
         * The name of the connection monitor endpoint.
         */
        name: string;
        /**
         * Resource ID of the connection monitor endpoint.
         */
        resourceId?: string;
    }

    /**
     * Describes the HTTP configuration.
     */
    export interface ConnectionMonitorHttpConfigurationResponse {
        /**
         * The HTTP method to use.
         */
        method?: string;
        /**
         * The path component of the URI. For instance, "/dir1/dir2".
         */
        path?: string;
        /**
         * The port to connect to.
         */
        port?: number;
        /**
         * Value indicating whether HTTPS is preferred over HTTP in cases where the choice is not explicit.
         */
        preferHTTPS?: boolean;
        /**
         * The HTTP headers to transmit with the request.
         */
        requestHeaders?: outputs.network.HTTPHeaderResponse[];
        /**
         * HTTP status codes to consider successful. For instance, "2xx,301-304,418".
         */
        validStatusCodeRanges?: string[];
    }

    /**
     * Describes the ICMP configuration.
     */
    export interface ConnectionMonitorIcmpConfigurationResponse {
        /**
         * Value indicating whether path evaluation with trace route should be disabled.
         */
        disableTraceRoute?: boolean;
    }

    /**
     * Describes a connection monitor output destination.
     */
    export interface ConnectionMonitorOutputResponse {
        /**
         * Connection monitor output destination type. Currently, only "Workspace" is supported.
         */
        type?: string;
        /**
         * Describes the settings for producing output into a log analytics workspace.
         */
        workspaceSettings?: outputs.network.ConnectionMonitorWorkspaceSettingsResponse;
    }

    /**
     * Describes the properties of a connection monitor.
     */
    export interface ConnectionMonitorResultPropertiesResponse {
        /**
         * Determines if the connection monitor will start automatically once created.
         */
        autoStart?: boolean;
        /**
         * Type of connection monitor.
         */
        connectionMonitorType: string;
        /**
         * Describes the destination of connection monitor.
         */
        destination?: outputs.network.ConnectionMonitorDestinationResponse;
        /**
         * List of connection monitor endpoints.
         */
        endpoints?: outputs.network.ConnectionMonitorEndpointResponse[];
        /**
         * Monitoring interval in seconds.
         */
        monitoringIntervalInSeconds?: number;
        /**
         * The monitoring status of the connection monitor.
         */
        monitoringStatus: string;
        /**
         * Optional notes to be associated with the connection monitor.
         */
        notes?: string;
        /**
         * List of connection monitor outputs.
         */
        outputs?: outputs.network.ConnectionMonitorOutputResponse[];
        /**
         * The provisioning state of the connection monitor.
         */
        provisioningState: string;
        /**
         * Describes the source of connection monitor.
         */
        source?: outputs.network.ConnectionMonitorSourceResponse;
        /**
         * The date and time when the connection monitor was started.
         */
        startTime: string;
        /**
         * List of connection monitor test configurations.
         */
        testConfigurations?: outputs.network.ConnectionMonitorTestConfigurationResponse[];
        /**
         * List of connection monitor test groups.
         */
        testGroups?: outputs.network.ConnectionMonitorTestGroupResponse[];
    }

    /**
     * Describes the source of connection monitor.
     */
    export interface ConnectionMonitorSourceResponse {
        /**
         * The source port used by connection monitor.
         */
        port?: number;
        /**
         * The ID of the resource used as the source by connection monitor.
         */
        resourceId: string;
    }

    /**
     * Describes the threshold for declaring a test successful.
     */
    export interface ConnectionMonitorSuccessThresholdResponse {
        /**
         * The maximum percentage of failed checks permitted for a test to evaluate as successful.
         */
        checksFailedPercent?: number;
        /**
         * The maximum round-trip time in milliseconds permitted for a test to evaluate as successful.
         */
        roundTripTimeMs?: number;
    }

    /**
     * Describes the TCP configuration.
     */
    export interface ConnectionMonitorTcpConfigurationResponse {
        /**
         * Value indicating whether path evaluation with trace route should be disabled.
         */
        disableTraceRoute?: boolean;
        /**
         * The port to connect to.
         */
        port?: number;
    }

    /**
     * Describes a connection monitor test configuration.
     */
    export interface ConnectionMonitorTestConfigurationResponse {
        /**
         * The parameters used to perform test evaluation over HTTP.
         */
        httpConfiguration?: outputs.network.ConnectionMonitorHttpConfigurationResponse;
        /**
         * The parameters used to perform test evaluation over ICMP.
         */
        icmpConfiguration?: outputs.network.ConnectionMonitorIcmpConfigurationResponse;
        /**
         * The name of the connection monitor test configuration.
         */
        name: string;
        /**
         * The preferred IP version to use in test evaluation. The connection monitor may choose to use a different version depending on other parameters.
         */
        preferredIPVersion?: string;
        /**
         * The protocol to use in test evaluation.
         */
        protocol: string;
        /**
         * The threshold for declaring a test successful.
         */
        successThreshold?: outputs.network.ConnectionMonitorSuccessThresholdResponse;
        /**
         * The parameters used to perform test evaluation over TCP.
         */
        tcpConfiguration?: outputs.network.ConnectionMonitorTcpConfigurationResponse;
        /**
         * The frequency of test evaluation, in seconds.
         */
        testFrequencySec?: number;
    }

    /**
     * Describes the connection monitor test group.
     */
    export interface ConnectionMonitorTestGroupResponse {
        /**
         * List of destination endpoint names.
         */
        destinations: string[];
        /**
         * Value indicating whether test group is disabled.
         */
        disable?: boolean;
        /**
         * The name of the connection monitor test group.
         */
        name: string;
        /**
         * List of source endpoint names.
         */
        sources: string[];
        /**
         * List of test configuration names.
         */
        testConfigurations: string[];
    }

    /**
     * Describes the settings for producing output into a log analytics workspace.
     */
    export interface ConnectionMonitorWorkspaceSettingsResponse {
        /**
         * Log analytics workspace resource ID.
         */
        workspaceResourceId?: string;
    }

    /**
     * Container network interface configuration properties.
     */
    export interface ContainerNetworkInterfaceConfigurationPropertiesFormatResponse {
        /**
         * A list of container network interfaces created from this container network interface configuration.
         */
        containerNetworkInterfaces?: outputs.network.SubResourceResponse[];
        /**
         * A list of ip configurations of the container network interface configuration.
         */
        ipConfigurations?: outputs.network.IPConfigurationProfileResponse[];
        /**
         * The provisioning state of the container network interface configuration resource.
         */
        provisioningState: string;
    }

    /**
     * Container network interface configuration child resource.
     */
    export interface ContainerNetworkInterfaceConfigurationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Container network interface configuration properties.
         */
        properties?: outputs.network.ContainerNetworkInterfaceConfigurationPropertiesFormatResponse;
        /**
         * Sub Resource type.
         */
        type: string;
    }

    /**
     * Properties of the container network interface IP configuration.
     */
    export interface ContainerNetworkInterfaceIpConfigurationPropertiesFormatResponse {
        /**
         * The provisioning state of the container network interface IP configuration resource.
         */
        provisioningState: string;
    }

    /**
     * The ip configuration for a container network interface.
     */
    export interface ContainerNetworkInterfaceIpConfigurationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * The name of the resource. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the container network interface IP configuration.
         */
        properties?: outputs.network.ContainerNetworkInterfaceIpConfigurationPropertiesFormatResponse;
        /**
         * Sub Resource type.
         */
        type: string;
    }

    /**
     * Properties of container network interface.
     */
    export interface ContainerNetworkInterfacePropertiesFormatResponse {
        /**
         * Reference to the container to which this container network interface is attached.
         */
        container?: outputs.network.ContainerResponse;
        /**
         * Container network interface configuration from which this container network interface is created.
         */
        containerNetworkInterfaceConfiguration: outputs.network.ContainerNetworkInterfaceConfigurationResponse;
        /**
         * Reference to the ip configuration on this container nic.
         */
        ipConfigurations: outputs.network.ContainerNetworkInterfaceIpConfigurationResponse[];
        /**
         * The provisioning state of the container network interface resource.
         */
        provisioningState: string;
    }

    /**
     * Container network interface child resource.
     */
    export interface ContainerNetworkInterfaceResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Container network interface properties.
         */
        properties?: outputs.network.ContainerNetworkInterfacePropertiesFormatResponse;
        /**
         * Sub Resource type.
         */
        type: string;
    }

    /**
     * Reference to container resource in remote resource provider.
     */
    export interface ContainerResponse {
        /**
         * Resource ID.
         */
        id?: string;
    }

    /**
     * Contains custom Dns resolution configuration from customer.
     */
    export interface CustomDnsConfigPropertiesFormatResponse {
        /**
         * Fqdn that resolves to private endpoint ip address.
         */
        fqdn?: string;
        /**
         * A list of private ip addresses of the private endpoint.
         */
        ipAddresses?: string[];
    }

    /**
     * Https settings for a domain
     */
    export interface CustomHttpsConfigurationResponse {
        /**
         * Defines the source of the SSL certificate
         */
        certificateSource: string;
        /**
         * Parameters required for enabling SSL with Front Door-managed certificates (if certificateSource=FrontDoor)
         */
        frontDoorCertificateSourceParameters?: outputs.network.FrontDoorCertificateSourceParametersResponse;
        /**
         * KeyVault certificate source parameters (if certificateSource=AzureKeyVault)
         */
        keyVaultCertificateSourceParameters?: outputs.network.KeyVaultCertificateSourceParametersResponse;
        /**
         * The minimum TLS version required from the clients to establish an SSL handshake with Front Door.
         */
        minimumTlsVersion: string;
        /**
         * Defines the TLS extension protocol that is used for secure delivery
         */
        protocolType: string;
    }

    /**
     * DDoS custom policy properties.
     */
    export interface DdosCustomPolicyPropertiesFormatResponse {
        /**
         * The protocol-specific DDoS policy customization parameters.
         */
        protocolCustomSettings?: outputs.network.ProtocolCustomSettingsFormatResponse[];
        /**
         * The provisioning state of the DDoS custom policy resource.
         */
        provisioningState: string;
        /**
         * The list of public IPs associated with the DDoS custom policy resource. This list is read-only.
         */
        publicIPAddresses: outputs.network.SubResourceResponse[];
        /**
         * The resource GUID property of the DDoS custom policy resource. It uniquely identifies the resource, even if the user changes its name or migrate the resource across subscriptions or resource groups.
         */
        resourceGuid: string;
    }

    /**
     * DDoS protection plan properties.
     */
    export interface DdosProtectionPlanPropertiesFormatResponse {
        /**
         * The provisioning state of the DDoS protection plan resource.
         */
        provisioningState: string;
        /**
         * The resource GUID property of the DDoS protection plan resource. It uniquely identifies the resource, even if the user changes its name or migrate the resource across subscriptions or resource groups.
         */
        resourceGuid: string;
        /**
         * The list of virtual networks associated with the DDoS protection plan resource. This list is read-only.
         */
        virtualNetworks: outputs.network.SubResourceResponse[];
    }

    /**
     * Contains the DDoS protection settings of the public IP.
     */
    export interface DdosSettingsResponse {
        /**
         * The DDoS custom policy associated with the public IP.
         */
        ddosCustomPolicy?: outputs.network.SubResourceResponse;
        /**
         * Enables DDoS protection on the public IP.
         */
        protectedIP?: boolean;
        /**
         * The DDoS protection policy customizability of the public IP. Only standard coverage will have the ability to be customized.
         */
        protectionCoverage?: string;
    }

    /**
     * Details the service to which the subnet is delegated.
     */
    export interface DelegationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a subnet. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the subnet.
         */
        properties?: outputs.network.ServiceDelegationPropertiesFormatResponse;
    }

    /**
     * List of properties of the device.
     */
    export interface DevicePropertiesResponse {
        /**
         * Model of the device.
         */
        deviceModel?: string;
        /**
         * Name of the device Vendor.
         */
        deviceVendor?: string;
        /**
         * Link speed.
         */
        linkSpeedInMbps?: number;
    }

    /**
     * DhcpOptions contains an array of DNS servers available to VMs deployed in the virtual network. Standard DHCP option for a subnet overrides VNET DHCP options.
     */
    export interface DhcpOptionsResponse {
        /**
         * The list of DNS servers IP addresses.
         */
        dnsServers?: string[];
    }

    /**
     * Class containing DNS settings in a Traffic Manager profile.
     */
    export interface DnsConfigResponse {
        /**
         * The fully-qualified domain name (FQDN) of the Traffic Manager profile. This is formed from the concatenation of the RelativeName with the DNS domain used by Azure Traffic Manager.
         */
        fqdn: string;
        /**
         * The relative DNS name provided by this Traffic Manager profile. This value is combined with the DNS domain name used by Azure Traffic Manager to form the fully-qualified domain name (FQDN) of the profile.
         */
        relativeName?: string;
        /**
         * The DNS Time-To-Live (TTL), in seconds. This informs the local DNS resolvers and DNS clients how long to cache DNS responses provided by this Traffic Manager profile.
         */
        ttl?: number;
    }

    /**
     * DNS Proxy Settings in Firewall Policy.
     */
    export interface DnsSettingsResponse {
        /**
         * Enable DNS Proxy on Firewalls attached to the Firewall Policy.
         */
        enableProxy?: boolean;
        /**
         * FQDNs in Network Rules are supported when set to true.
         */
        requireProxyForNetworkRules?: boolean;
        /**
         * List of Custom DNS Servers.
         */
        servers?: string[];
    }

    /**
     * Class representing a Traffic Manager endpoint properties.
     */
    export interface EndpointPropertiesResponse {
        /**
         * List of custom headers.
         */
        customHeaders?: outputs.network.EndpointPropertiesResponseProperties[];
        /**
         * Specifies the location of the external or nested endpoints when using the 'Performance' traffic routing method.
         */
        endpointLocation?: string;
        /**
         * The monitoring status of the endpoint.
         */
        endpointMonitorStatus?: string;
        /**
         * The status of the endpoint. If the endpoint is Enabled, it is probed for endpoint health and is included in the traffic routing method.
         */
        endpointStatus?: string;
        /**
         * The list of countries/regions mapped to this endpoint when using the 'Geographic' traffic routing method. Please consult Traffic Manager Geographic documentation for a full list of accepted values.
         */
        geoMapping?: string[];
        /**
         * The minimum number of endpoints that must be available in the child profile in order for the parent profile to be considered available. Only applicable to endpoint of type 'NestedEndpoints'.
         */
        minChildEndpoints?: number;
        /**
         * The priority of this endpoint when using the 'Priority' traffic routing method. Possible values are from 1 to 1000, lower values represent higher priority. This is an optional parameter.  If specified, it must be specified on all endpoints, and no two endpoints can share the same priority value.
         */
        priority?: number;
        /**
         * The list of subnets, IP addresses, and/or address ranges mapped to this endpoint when using the 'Subnet' traffic routing method. An empty list will match all ranges not covered by other endpoints.
         */
        subnets?: outputs.network.EndpointPropertiesResponseProperties[];
        /**
         * The fully-qualified DNS name or IP address of the endpoint. Traffic Manager returns this value in DNS responses to direct traffic to this endpoint.
         */
        target?: string;
        /**
         * The Azure Resource URI of the of the endpoint. Not applicable to endpoints of type 'ExternalEndpoints'.
         */
        targetResourceId?: string;
        /**
         * The weight of this endpoint when using the 'Weighted' traffic routing method. Possible values are from 1 to 1000.
         */
        weight?: number;
    }

    /**
     * Custom header name and value.
     */
    export interface EndpointPropertiesResponseProperties {
        /**
         * Header name.
         */
        name?: string;
        /**
         * Header value.
         */
        value?: string;
    }

    /**
     * Class representing a Traffic Manager endpoint.
     */
    export interface EndpointResponse {
        /**
         * Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}
         */
        id?: string;
        /**
         * The name of the resource
         */
        name?: string;
        /**
         * The properties of the Traffic Manager endpoint.
         */
        properties?: outputs.network.EndpointPropertiesResponse;
        /**
         * The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
         */
        type?: string;
    }

    /**
     * Identifies the service being brought into the virtual network.
     */
    export interface EndpointServiceResponse {
        /**
         * A unique identifier of the service being referenced by the interface endpoint.
         */
        id?: string;
    }

    /**
     * Defines the properties of an experiment
     */
    export interface ExperimentPropertiesResponse {
        /**
         * The description of the details or intents of the Experiment
         */
        description?: string;
        /**
         * The state of the Experiment
         */
        enabledState?: string;
        /**
         * The endpoint A of an experiment
         */
        endpointA?: outputs.network.EndpointResponse;
        /**
         * The endpoint B of an experiment
         */
        endpointB?: outputs.network.EndpointResponse;
        /**
         * Resource status.
         */
        resourceState?: string;
        /**
         * The uri to the Script used in the Experiment
         */
        scriptFileUri: string;
        /**
         * The description of Experiment status from the server side
         */
        status: string;
    }

    /**
     * Authorization in an ExpressRouteCircuit resource.
     */
    export interface ExpressRouteCircuitAuthorizationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the express route circuit authorization.
         */
        properties?: outputs.network.AuthorizationPropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Properties of the express route circuit connection.
     */
    export interface ExpressRouteCircuitConnectionPropertiesFormatResponse {
        /**
         * /29 IP address space to carve out Customer addresses for tunnels.
         */
        addressPrefix?: string;
        /**
         * The authorization key.
         */
        authorizationKey?: string;
        /**
         * Express Route Circuit connection state.
         */
        circuitConnectionStatus?: string;
        /**
         * Reference to Express Route Circuit Private Peering Resource of the circuit initiating connection.
         */
        expressRouteCircuitPeering?: outputs.network.SubResourceResponse;
        /**
         * IPv6 Address PrefixProperties of the express route circuit connection.
         */
        ipv6CircuitConnectionConfig?: outputs.network.Ipv6CircuitConnectionConfigResponse;
        /**
         * Reference to Express Route Circuit Private Peering Resource of the peered circuit.
         */
        peerExpressRouteCircuitPeering?: outputs.network.SubResourceResponse;
        /**
         * The provisioning state of the express route circuit connection resource.
         */
        provisioningState: string;
    }

    /**
     * Express Route Circuit Connection in an ExpressRouteCircuitPeering resource.
     */
    export interface ExpressRouteCircuitConnectionResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the express route circuit connection.
         */
        properties?: outputs.network.ExpressRouteCircuitConnectionPropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Specifies the peering configuration.
     */
    export interface ExpressRouteCircuitPeeringConfigResponse {
        /**
         * The communities of bgp peering. Specified for microsoft peering.
         */
        advertisedCommunities?: string[];
        /**
         * The reference to AdvertisedPublicPrefixes.
         */
        advertisedPublicPrefixes?: string[];
        /**
         * The advertised public prefix state of the Peering resource.
         */
        advertisedPublicPrefixesState: string;
        /**
         * The CustomerASN of the peering.
         */
        customerASN?: number;
        /**
         * The legacy mode of the peering.
         */
        legacyMode?: number;
        /**
         * The RoutingRegistryName of the configuration.
         */
        routingRegistryName?: string;
    }

    /**
     * ExpressRoute circuit peering identifier.
     */
    export interface ExpressRouteCircuitPeeringIdResponse {
        /**
         * The ID of the ExpressRoute circuit peering.
         */
        id?: string;
    }

    /**
     * Properties of the express route circuit peering.
     */
    export interface ExpressRouteCircuitPeeringPropertiesFormatResponse {
        /**
         * The Azure ASN.
         */
        azureASN?: number;
        /**
         * The list of circuit connections associated with Azure Private Peering for this circuit.
         */
        connections?: outputs.network.ExpressRouteCircuitConnectionResponse[];
        /**
         * The ExpressRoute connection.
         */
        expressRouteConnection?: outputs.network.ExpressRouteConnectionIdResponse;
        /**
         * The GatewayManager Etag.
         */
        gatewayManagerEtag?: string;
        /**
         * The IPv6 peering configuration.
         */
        ipv6PeeringConfig?: outputs.network.Ipv6ExpressRouteCircuitPeeringConfigResponse;
        /**
         * Who was the last to modify the peering.
         */
        lastModifiedBy: string;
        /**
         * The Microsoft peering configuration.
         */
        microsoftPeeringConfig?: outputs.network.ExpressRouteCircuitPeeringConfigResponse;
        /**
         * The peer ASN.
         */
        peerASN?: number;
        /**
         * The list of peered circuit connections associated with Azure Private Peering for this circuit.
         */
        peeredConnections: outputs.network.PeerExpressRouteCircuitConnectionResponse[];
        /**
         * The peering type.
         */
        peeringType?: string;
        /**
         * The primary port.
         */
        primaryAzurePort?: string;
        /**
         * The primary address prefix.
         */
        primaryPeerAddressPrefix?: string;
        /**
         * The provisioning state of the express route circuit peering resource.
         */
        provisioningState: string;
        /**
         * The reference to the RouteFilter resource.
         */
        routeFilter?: outputs.network.SubResourceResponse;
        /**
         * The secondary port.
         */
        secondaryAzurePort?: string;
        /**
         * The secondary address prefix.
         */
        secondaryPeerAddressPrefix?: string;
        /**
         * The shared key.
         */
        sharedKey?: string;
        /**
         * The peering state.
         */
        state?: string;
        /**
         * The peering stats of express route circuit.
         */
        stats?: outputs.network.ExpressRouteCircuitStatsResponse;
        /**
         * The VLAN ID.
         */
        vlanId?: number;
    }

    /**
     * Peering in an ExpressRouteCircuit resource.
     */
    export interface ExpressRouteCircuitPeeringResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the express route circuit peering.
         */
        properties?: outputs.network.ExpressRouteCircuitPeeringPropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Properties of ExpressRouteCircuit.
     */
    export interface ExpressRouteCircuitPropertiesFormatResponse {
        /**
         * Allow classic operations.
         */
        allowClassicOperations?: boolean;
        /**
         * The list of authorizations.
         */
        authorizations?: outputs.network.ExpressRouteCircuitAuthorizationResponse[];
        /**
         * The bandwidth of the circuit when the circuit is provisioned on an ExpressRoutePort resource.
         */
        bandwidthInGbps?: number;
        /**
         * The CircuitProvisioningState state of the resource.
         */
        circuitProvisioningState?: string;
        /**
         * The reference to the ExpressRoutePort resource when the circuit is provisioned on an ExpressRoutePort resource.
         */
        expressRoutePort?: outputs.network.SubResourceResponse;
        /**
         * The GatewayManager Etag.
         */
        gatewayManagerEtag?: string;
        /**
         * Flag denoting global reach status.
         */
        globalReachEnabled?: boolean;
        /**
         * The list of peerings.
         */
        peerings?: outputs.network.ExpressRouteCircuitPeeringResponse[];
        /**
         * The provisioning state of the express route circuit resource.
         */
        provisioningState: string;
        /**
         * The ServiceKey.
         */
        serviceKey?: string;
        /**
         * The ServiceProviderNotes.
         */
        serviceProviderNotes?: string;
        /**
         * The ServiceProviderProperties.
         */
        serviceProviderProperties?: outputs.network.ExpressRouteCircuitServiceProviderPropertiesResponse;
        /**
         * The ServiceProviderProvisioningState state of the resource.
         */
        serviceProviderProvisioningState?: string;
        /**
         * The identifier of the circuit traffic. Outer tag for QinQ encapsulation.
         */
        stag: number;
    }

    /**
     * Contains ServiceProviderProperties in an ExpressRouteCircuit.
     */
    export interface ExpressRouteCircuitServiceProviderPropertiesResponse {
        /**
         * The BandwidthInMbps.
         */
        bandwidthInMbps?: number;
        /**
         * The peering location.
         */
        peeringLocation?: string;
        /**
         * The serviceProviderName.
         */
        serviceProviderName?: string;
    }

    /**
     * Contains SKU in an ExpressRouteCircuit.
     */
    export interface ExpressRouteCircuitSkuResponse {
        /**
         * The family of the SKU.
         */
        family?: string;
        /**
         * The name of the SKU.
         */
        name?: string;
        /**
         * The tier of the SKU.
         */
        tier?: string;
    }

    /**
     * Contains stats associated with the peering.
     */
    export interface ExpressRouteCircuitStatsResponse {
        /**
         * The Primary BytesIn of the peering.
         */
        primarybytesIn?: number;
        /**
         * The primary BytesOut of the peering.
         */
        primarybytesOut?: number;
        /**
         * The secondary BytesIn of the peering.
         */
        secondarybytesIn?: number;
        /**
         * The secondary BytesOut of the peering.
         */
        secondarybytesOut?: number;
    }

    /**
     * The ID of the ExpressRouteConnection.
     */
    export interface ExpressRouteConnectionIdResponse {
        /**
         * The ID of the ExpressRouteConnection.
         */
        id: string;
    }

    /**
     * Properties of the ExpressRouteConnection subresource.
     */
    export interface ExpressRouteConnectionPropertiesResponse {
        /**
         * Authorization key to establish the connection.
         */
        authorizationKey?: string;
        /**
         * Enable internet security.
         */
        enableInternetSecurity?: boolean;
        /**
         * The ExpressRoute circuit peering.
         */
        expressRouteCircuitPeering: outputs.network.ExpressRouteCircuitPeeringIdResponse;
        /**
         * The provisioning state of the express route connection resource.
         */
        provisioningState: string;
        /**
         * The Routing Configuration indicating the associated and propagated route tables on this connection.
         */
        routingConfiguration?: outputs.network.RoutingConfigurationResponse;
        /**
         * The routing weight associated to the connection.
         */
        routingWeight?: number;
    }

    /**
     * ExpressRouteConnection resource.
     */
    export interface ExpressRouteConnectionResponse {
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource.
         */
        name: string;
        /**
         * Properties of the express route connection.
         */
        properties?: outputs.network.ExpressRouteConnectionPropertiesResponse;
    }

    /**
     * Properties of express route cross connection peering.
     */
    export interface ExpressRouteCrossConnectionPeeringPropertiesResponse {
        /**
         * The Azure ASN.
         */
        azureASN: number;
        /**
         * The GatewayManager Etag.
         */
        gatewayManagerEtag?: string;
        /**
         * The IPv6 peering configuration.
         */
        ipv6PeeringConfig?: outputs.network.Ipv6ExpressRouteCircuitPeeringConfigResponse;
        /**
         * Who was the last to modify the peering.
         */
        lastModifiedBy: string;
        /**
         * The Microsoft peering configuration.
         */
        microsoftPeeringConfig?: outputs.network.ExpressRouteCircuitPeeringConfigResponse;
        /**
         * The peer ASN.
         */
        peerASN?: number;
        /**
         * The peering type.
         */
        peeringType?: string;
        /**
         * The primary port.
         */
        primaryAzurePort: string;
        /**
         * The primary address prefix.
         */
        primaryPeerAddressPrefix?: string;
        /**
         * The provisioning state of the express route cross connection peering resource.
         */
        provisioningState: string;
        /**
         * The secondary port.
         */
        secondaryAzurePort: string;
        /**
         * The secondary address prefix.
         */
        secondaryPeerAddressPrefix?: string;
        /**
         * The shared key.
         */
        sharedKey?: string;
        /**
         * The peering state.
         */
        state?: string;
        /**
         * The VLAN ID.
         */
        vlanId?: number;
    }

    /**
     * ExpressRoute gateway resource properties.
     */
    export interface ExpressRouteGatewayPropertiesResponse {
        /**
         * Configuration for auto scaling.
         */
        autoScaleConfiguration?: outputs.network.ExpressRouteGatewayPropertiesResponseProperties;
        /**
         * List of ExpressRoute connections to the ExpressRoute gateway.
         */
        expressRouteConnections: outputs.network.ExpressRouteConnectionResponse[];
        /**
         * The provisioning state of the express route gateway resource.
         */
        provisioningState: string;
        /**
         * The Virtual Hub where the ExpressRoute gateway is or will be deployed.
         */
        virtualHub: outputs.network.VirtualHubIdResponse;
    }

    /**
     * Configuration for auto scaling.
     */
    export interface ExpressRouteGatewayPropertiesResponseProperties {
        /**
         * Minimum and maximum number of scale units to deploy.
         */
        bounds?: outputs.network.ExpressRouteGatewayPropertiesResponseProperties;
    }

    /**
     * ExpressRouteLink Mac Security Configuration.
     */
    export interface ExpressRouteLinkMacSecConfigResponse {
        /**
         * Keyvault Secret Identifier URL containing Mac security CAK key.
         */
        cakSecretIdentifier?: string;
        /**
         * Mac security cipher.
         */
        cipher?: string;
        /**
         * Keyvault Secret Identifier URL containing Mac security CKN key.
         */
        cknSecretIdentifier?: string;
    }

    /**
     * Properties specific to ExpressRouteLink resources.
     */
    export interface ExpressRouteLinkPropertiesFormatResponse {
        /**
         * Administrative state of the physical port.
         */
        adminState?: string;
        /**
         * Physical fiber port type.
         */
        connectorType: string;
        /**
         * Name of Azure router interface.
         */
        interfaceName: string;
        /**
         * MacSec configuration.
         */
        macSecConfig?: outputs.network.ExpressRouteLinkMacSecConfigResponse;
        /**
         * Mapping between physical port to patch panel port.
         */
        patchPanelId: string;
        /**
         * The provisioning state of the express route link resource.
         */
        provisioningState: string;
        /**
         * Mapping of physical patch panel to rack.
         */
        rackId: string;
        /**
         * Name of Azure router associated with physical port.
         */
        routerName: string;
    }

    /**
     * ExpressRouteLink child resource definition.
     */
    export interface ExpressRouteLinkResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of child port resource that is unique among child port resources of the parent.
         */
        name?: string;
        /**
         * ExpressRouteLink properties.
         */
        properties?: outputs.network.ExpressRouteLinkPropertiesFormatResponse;
    }

    /**
     * Properties specific to ExpressRoutePort resources.
     */
    export interface ExpressRoutePortPropertiesFormatResponse {
        /**
         * Date of the physical port allocation to be used in Letter of Authorization.
         */
        allocationDate: string;
        /**
         * Bandwidth of procured ports in Gbps.
         */
        bandwidthInGbps?: number;
        /**
         * Reference the ExpressRoute circuit(s) that are provisioned on this ExpressRoutePort resource.
         */
        circuits: outputs.network.SubResourceResponse[];
        /**
         * Encapsulation method on physical ports.
         */
        encapsulation?: string;
        /**
         * Ether type of the physical port.
         */
        etherType: string;
        /**
         * The set of physical links of the ExpressRoutePort resource.
         */
        links?: outputs.network.ExpressRouteLinkResponse[];
        /**
         * Maximum transmission unit of the physical port pair(s).
         */
        mtu: string;
        /**
         * The name of the peering location that the ExpressRoutePort is mapped to physically.
         */
        peeringLocation?: string;
        /**
         * Aggregate Gbps of associated circuit bandwidths.
         */
        provisionedBandwidthInGbps: number;
        /**
         * The provisioning state of the express route port resource.
         */
        provisioningState: string;
        /**
         * The resource GUID property of the express route port resource.
         */
        resourceGuid: string;
    }

    /**
     * Firewall Policy definition.
     */
    export interface FirewallPolicyPropertiesFormatResponse {
        /**
         * The parent firewall policy from which rules are inherited.
         */
        basePolicy?: outputs.network.SubResourceResponse;
        /**
         * List of references to Child Firewall Policies.
         */
        childPolicies: outputs.network.SubResourceResponse[];
        /**
         * DNS Proxy Settings definition.
         */
        dnsSettings?: outputs.network.DnsSettingsResponse;
        /**
         * List of references to Azure Firewalls that this Firewall Policy is associated with.
         */
        firewalls: outputs.network.SubResourceResponse[];
        /**
         * The provisioning state of the firewall policy resource.
         */
        provisioningState: string;
        /**
         * List of references to FirewallPolicyRuleCollectionGroups.
         */
        ruleCollectionGroups: outputs.network.SubResourceResponse[];
        /**
         * The operation mode for Threat Intelligence.
         */
        threatIntelMode?: string;
        /**
         * ThreatIntel Whitelist for Firewall Policy.
         */
        threatIntelWhitelist?: outputs.network.FirewallPolicyThreatIntelWhitelistResponse;
    }

    /**
     * Properties of the rule collection group.
     */
    export interface FirewallPolicyRuleCollectionGroupPropertiesResponse {
        /**
         * Priority of the Firewall Policy Rule Collection Group resource.
         */
        priority?: number;
        /**
         * The provisioning state of the firewall policy rule collection group resource.
         */
        provisioningState: string;
        /**
         * Group of Firewall Policy rule collections.
         */
        ruleCollections?: outputs.network.FirewallPolicyRuleCollectionResponse[];
    }

    /**
     * Properties of the rule collection.
     */
    export interface FirewallPolicyRuleCollectionResponse {
        /**
         * The name of the rule collection.
         */
        name?: string;
        /**
         * Priority of the Firewall Policy Rule Collection resource.
         */
        priority?: number;
        /**
         * The type of the rule collection.
         */
        ruleCollectionType: string;
    }

    /**
     * ThreatIntel Whitelist for Firewall Policy.
     */
    export interface FirewallPolicyThreatIntelWhitelistResponse {
        /**
         * List of FQDNs for the ThreatIntel Whitelist.
         */
        fqdns?: string[];
        /**
         * List of IP addresses for the ThreatIntel Whitelist.
         */
        ipAddresses?: string[];
    }

    /**
     * Parameters that define the flow log format.
     */
    export interface FlowLogFormatParametersResponse {
        /**
         * The file type of flow log.
         */
        type?: string;
        /**
         * The version (revision) of the flow log.
         */
        version?: number;
    }

    /**
     * Parameters that define the configuration of flow log.
     */
    export interface FlowLogPropertiesFormatResponse {
        /**
         * Flag to enable/disable flow logging.
         */
        enabled?: boolean;
        /**
         * Parameters that define the configuration of traffic analytics.
         */
        flowAnalyticsConfiguration?: outputs.network.TrafficAnalyticsPropertiesResponse;
        /**
         * Parameters that define the flow log format.
         */
        format?: outputs.network.FlowLogFormatParametersResponse;
        /**
         * The provisioning state of the flow log.
         */
        provisioningState: string;
        /**
         * Parameters that define the retention policy for flow log.
         */
        retentionPolicy?: outputs.network.RetentionPolicyParametersResponse;
        /**
         * ID of the storage account which is used to store the flow log.
         */
        storageId: string;
        /**
         * Guid of network security group to which flow log will be applied.
         */
        targetResourceGuid: string;
        /**
         * ID of network security group to which flow log will be applied.
         */
        targetResourceId: string;
    }

    /**
     * A flow log resource.
     */
    export interface FlowLogResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource location.
         */
        location?: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Properties of the flow log.
         */
        properties?: outputs.network.FlowLogPropertiesFormatResponse;
        /**
         * Resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Parameters required for enabling SSL with Front Door-managed certificates
     */
    export interface FrontDoorCertificateSourceParametersResponse {
        /**
         * Defines the type of the certificate used for secure connections to a frontendEndpoint
         */
        certificateType?: string;
    }

    /**
     * The JSON object that contains the properties required to create an endpoint.
     */
    export interface FrontDoorPropertiesResponse {
        /**
         * Backend pools available to routing rules.
         */
        backendPools?: outputs.network.BackendPoolResponse[];
        /**
         * Settings for all backendPools
         */
        backendPoolsSettings?: outputs.network.BackendPoolsSettingsResponse;
        /**
         * The host that each frontendEndpoint must CNAME to.
         */
        cname: string;
        /**
         * Operational status of the Front Door load balancer. Permitted values are 'Enabled' or 'Disabled'
         */
        enabledState?: string;
        /**
         * A friendly name for the frontDoor
         */
        friendlyName?: string;
        /**
         * The Id of the frontdoor.
         */
        frontdoorId: string;
        /**
         * Frontend endpoints available to routing rules.
         */
        frontendEndpoints?: outputs.network.FrontendEndpointResponse[];
        /**
         * Health probe settings associated with this Front Door instance.
         */
        healthProbeSettings?: outputs.network.HealthProbeSettingsModelResponse[];
        /**
         * Load balancing settings associated with this Front Door instance.
         */
        loadBalancingSettings?: outputs.network.LoadBalancingSettingsModelResponse[];
        /**
         * Provisioning state of the Front Door.
         */
        provisioningState: string;
        /**
         * Resource status of the Front Door.
         */
        resourceState?: string;
        /**
         * Routing rules associated with this Front Door.
         */
        routingRules?: outputs.network.RoutingRuleResponse[];
        /**
         * Rules Engine Configurations available to routing rules.
         */
        rulesEngines: outputs.network.RulesEngineResponse[];
    }

    /**
     * The JSON object that contains the properties required to create a frontend endpoint.
     */
    export interface FrontendEndpointPropertiesResponse {
        /**
         * The configuration specifying how to enable HTTPS
         */
        customHttpsConfiguration: outputs.network.CustomHttpsConfigurationResponse;
        /**
         * Provisioning status of Custom Https of the frontendEndpoint.
         */
        customHttpsProvisioningState: string;
        /**
         * Provisioning substate shows the progress of custom HTTPS enabling/disabling process step by step.
         */
        customHttpsProvisioningSubstate: string;
        /**
         * The host name of the frontendEndpoint. Must be a domain name.
         */
        hostName?: string;
        /**
         * Resource status.
         */
        resourceState?: string;
        /**
         * Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'
         */
        sessionAffinityEnabledState?: string;
        /**
         * UNUSED. This field will be ignored. The TTL to use in seconds for session affinity, if applicable.
         */
        sessionAffinityTtlSeconds?: number;
        /**
         * Defines the Web Application Firewall policy for each host (if applicable)
         */
        webApplicationFirewallPolicyLink?: outputs.network.FrontendEndpointUpdateParametersResponseProperties;
    }

    /**
     * A frontend endpoint used for routing.
     */
    export interface FrontendEndpointResponse {
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource name.
         */
        name?: string;
        /**
         * Properties of the Frontend endpoint
         */
        properties?: outputs.network.FrontendEndpointPropertiesResponse;
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Defines the Web Application Firewall policy for each host (if applicable)
     */
    export interface FrontendEndpointUpdateParametersResponseProperties {
        /**
         * Resource ID.
         */
        id?: string;
    }

    /**
     * Properties of Frontend IP Configuration of the load balancer.
     */
    export interface FrontendIPConfigurationPropertiesFormatResponse {
        /**
         * An array of references to inbound pools that use this frontend IP.
         */
        inboundNatPools: outputs.network.SubResourceResponse[];
        /**
         * An array of references to inbound rules that use this frontend IP.
         */
        inboundNatRules: outputs.network.SubResourceResponse[];
        /**
         * An array of references to load balancing rules that use this frontend IP.
         */
        loadBalancingRules: outputs.network.SubResourceResponse[];
        /**
         * An array of references to outbound rules that use this frontend IP.
         */
        outboundRules: outputs.network.SubResourceResponse[];
        /**
         * The private IP address of the IP configuration.
         */
        privateIPAddress?: string;
        /**
         * Whether the specific ipconfiguration is IPv4 or IPv6. Default is taken as IPv4.
         */
        privateIPAddressVersion?: string;
        /**
         * The Private IP allocation method.
         */
        privateIPAllocationMethod?: string;
        /**
         * The provisioning state of the frontend IP configuration resource.
         */
        provisioningState: string;
        /**
         * The reference to the Public IP resource.
         */
        publicIPAddress?: outputs.network.PublicIPAddressResponse;
        /**
         * The reference to the Public IP Prefix resource.
         */
        publicIPPrefix?: outputs.network.SubResourceResponse;
        /**
         * The reference to the subnet resource.
         */
        subnet?: outputs.network.SubnetResponse;
    }

    /**
     * Frontend IP address of the load balancer.
     */
    export interface FrontendIPConfigurationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within the set of frontend IP configurations used by the load balancer. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the load balancer probe.
         */
        properties?: outputs.network.FrontendIPConfigurationPropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
        /**
         * A list of availability zones denoting the IP allocated for the resource needs to come from.
         */
        zones?: string[];
    }

    /**
     * The HTTP header.
     */
    export interface HTTPHeaderResponse {
        /**
         * The name in HTTP header.
         */
        name?: string;
        /**
         * The value in HTTP header.
         */
        value?: string;
    }

    /**
     * An action that can manipulate an http header.
     */
    export interface HeaderActionResponse {
        /**
         * Which type of manipulation to apply to the header.
         */
        headerActionType: string;
        /**
         * The name of the header this action will apply to.
         */
        headerName: string;
        /**
         * The value to update the given header name with. This value is not used if the actionType is Delete.
         */
        value?: string;
    }

    /**
     * Load balancing settings for a backend pool
     */
    export interface HealthProbeSettingsModelResponse {
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource name.
         */
        name?: string;
        /**
         * Properties of the health probe settings
         */
        properties?: outputs.network.HealthProbeSettingsPropertiesResponse;
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * The JSON object that contains the properties required to create a health probe settings.
     */
    export interface HealthProbeSettingsPropertiesResponse {
        /**
         * Whether to enable health probes to be made against backends defined under backendPools. Health probes can only be disabled if there is a single enabled backend in single enabled backend pool.
         */
        enabledState?: string;
        /**
         * Configures which HTTP method to use to probe the backends defined under backendPools.
         */
        healthProbeMethod?: string;
        /**
         * The number of seconds between health probes.
         */
        intervalInSeconds?: number;
        /**
         * The path to use for the health probe. Default is /
         */
        path?: string;
        /**
         * Protocol scheme to use for this probe
         */
        protocol?: string;
        /**
         * Resource status.
         */
        resourceState?: string;
    }

    /**
     * IP addresses associated with azure firewall.
     */
    export interface HubIPAddressesResponse {
        /**
         * Private IP Address associated with azure firewall.
         */
        privateIPAddress?: string;
        /**
         * Public IP addresses associated with azure firewall.
         */
        publicIPs?: outputs.network.HubPublicIPAddressesResponse;
    }

    /**
     * Properties of IP configuration.
     */
    export interface HubIPConfigurationPropertiesFormatResponse {
        /**
         * The private IP address of the IP configuration.
         */
        privateIPAddress?: string;
        /**
         * The private IP address allocation method.
         */
        privateIPAllocationMethod?: string;
        /**
         * The provisioning state of the IP configuration resource.
         */
        provisioningState: string;
        /**
         * The reference to the public IP resource.
         */
        publicIPAddress?: outputs.network.PublicIPAddressResponse;
        /**
         * The reference to the subnet resource.
         */
        subnet?: outputs.network.SubnetResponse;
    }

    /**
     * Public IP addresses associated with azure firewall.
     */
    export interface HubPublicIPAddressesResponse {
        /**
         * The number of Public IP addresses associated with azure firewall.
         */
        addresses?: outputs.network.AzureFirewallPublicIPAddressResponse[];
        /**
         * Private IP Address associated with azure firewall.
         */
        count?: number;
    }

    /**
     * RouteTable route.
     */
    export interface HubRouteResponse {
        /**
         * The type of destinations (eg: CIDR, ResourceId, Service).
         */
        destinationType: string;
        /**
         * List of all destinations.
         */
        destinations: string[];
        /**
         * The name of the Route that is unique within a RouteTable. This name can be used to access this route.
         */
        name: string;
        /**
         * NextHop resource ID.
         */
        nextHop: string;
        /**
         * The type of next hop (eg: ResourceId).
         */
        nextHopType: string;
    }

    /**
     * Parameters for RouteTable.
     */
    export interface HubRouteTablePropertiesResponse {
        /**
         * List of all connections associated with this route table.
         */
        associatedConnections: string[];
        /**
         * List of labels associated with this route table.
         */
        labels?: string[];
        /**
         * List of all connections that advertise to this route table.
         */
        propagatingConnections: string[];
        /**
         * The provisioning state of the RouteTable resource.
         */
        provisioningState: string;
        /**
         * List of all routes.
         */
        routes?: outputs.network.HubRouteResponse[];
    }

    /**
     * Parameters for HubVirtualNetworkConnection.
     */
    export interface HubVirtualNetworkConnectionPropertiesResponse {
        /**
         * Deprecated: VirtualHub to RemoteVnet transit to enabled or not.
         */
        allowHubToRemoteVnetTransit?: boolean;
        /**
         * Deprecated: Allow RemoteVnet to use Virtual Hub's gateways.
         */
        allowRemoteVnetToUseHubVnetGateways?: boolean;
        /**
         * Enable internet security.
         */
        enableInternetSecurity?: boolean;
        /**
         * The provisioning state of the hub virtual network connection resource.
         */
        provisioningState: string;
        /**
         * Reference to the remote virtual network.
         */
        remoteVirtualNetwork?: outputs.network.SubResourceResponse;
        /**
         * The Routing Configuration indicating the associated and propagated route tables on this connection.
         */
        routingConfiguration?: outputs.network.RoutingConfigurationResponse;
    }

    /**
     * Properties of IPConfigurationBgpPeeringAddress.
     */
    export interface IPConfigurationBgpPeeringAddressResponse {
        /**
         * The list of custom BGP peering addresses which belong to IP configuration.
         */
        customBgpIpAddresses?: string[];
        /**
         * The list of default BGP peering addresses which belong to IP configuration.
         */
        defaultBgpIpAddresses: string[];
        /**
         * The ID of IP configuration which belongs to gateway.
         */
        ipconfigurationId?: string;
        /**
         * The list of tunnel public IP addresses which belong to IP configuration.
         */
        tunnelIpAddresses: string[];
    }

    /**
     * IP configuration profile properties.
     */
    export interface IPConfigurationProfilePropertiesFormatResponse {
        /**
         * The provisioning state of the IP configuration profile resource.
         */
        provisioningState: string;
        /**
         * The reference to the subnet resource to create a container network interface ip configuration.
         */
        subnet?: outputs.network.SubnetResponse;
    }

    /**
     * IP configuration profile child resource.
     */
    export interface IPConfigurationProfileResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the IP configuration profile.
         */
        properties?: outputs.network.IPConfigurationProfilePropertiesFormatResponse;
        /**
         * Sub Resource type.
         */
        type: string;
    }

    /**
     * Properties of IP configuration.
     */
    export interface IPConfigurationPropertiesFormatResponse {
        /**
         * The private IP address of the IP configuration.
         */
        privateIPAddress?: string;
        /**
         * The private IP address allocation method.
         */
        privateIPAllocationMethod?: string;
        /**
         * The provisioning state of the IP configuration resource.
         */
        provisioningState: string;
        /**
         * The reference to the public IP resource.
         */
        publicIPAddress?: outputs.network.PublicIPAddressResponse;
        /**
         * The reference to the subnet resource.
         */
        subnet?: outputs.network.SubnetResponse;
    }

    /**
     * IP configuration.
     */
    export interface IPConfigurationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the IP configuration.
         */
        properties?: outputs.network.IPConfigurationPropertiesFormatResponse;
    }

    /**
     * Properties of Inbound NAT pool.
     */
    export interface InboundNatPoolPropertiesFormatResponse {
        /**
         * The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
         */
        backendPort: number;
        /**
         * Configures a virtual machine's endpoint for the floating IP capability required to configure a SQL AlwaysOn Availability Group. This setting is required when using the SQL AlwaysOn Availability Groups in SQL server. This setting can't be changed after you create the endpoint.
         */
        enableFloatingIP?: boolean;
        /**
         * Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This element is only used when the protocol is set to TCP.
         */
        enableTcpReset?: boolean;
        /**
         * A reference to frontend IP addresses.
         */
        frontendIPConfiguration?: outputs.network.SubResourceResponse;
        /**
         * The last port number in the range of external ports that will be used to provide Inbound Nat to NICs associated with a load balancer. Acceptable values range between 1 and 65535.
         */
        frontendPortRangeEnd: number;
        /**
         * The first port number in the range of external ports that will be used to provide Inbound Nat to NICs associated with a load balancer. Acceptable values range between 1 and 65534.
         */
        frontendPortRangeStart: number;
        /**
         * The timeout for the TCP idle connection. The value can be set between 4 and 30 minutes. The default value is 4 minutes. This element is only used when the protocol is set to TCP.
         */
        idleTimeoutInMinutes?: number;
        /**
         * The reference to the transport protocol used by the inbound NAT pool.
         */
        protocol: string;
        /**
         * The provisioning state of the inbound NAT pool resource.
         */
        provisioningState: string;
    }

    /**
     * Inbound NAT pool of the load balancer.
     */
    export interface InboundNatPoolResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within the set of inbound NAT pools used by the load balancer. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of load balancer inbound nat pool.
         */
        properties?: outputs.network.InboundNatPoolPropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Properties of the inbound NAT rule.
     */
    export interface InboundNatRulePropertiesFormatResponse {
        /**
         * A reference to a private IP address defined on a network interface of a VM. Traffic sent to the frontend port of each of the frontend IP configurations is forwarded to the backend IP.
         */
        backendIPConfiguration: outputs.network.NetworkInterfaceIPConfigurationResponse;
        /**
         * The port used for the internal endpoint. Acceptable values range from 1 to 65535.
         */
        backendPort?: number;
        /**
         * Configures a virtual machine's endpoint for the floating IP capability required to configure a SQL AlwaysOn Availability Group. This setting is required when using the SQL AlwaysOn Availability Groups in SQL server. This setting can't be changed after you create the endpoint.
         */
        enableFloatingIP?: boolean;
        /**
         * Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This element is only used when the protocol is set to TCP.
         */
        enableTcpReset?: boolean;
        /**
         * A reference to frontend IP addresses.
         */
        frontendIPConfiguration?: outputs.network.SubResourceResponse;
        /**
         * The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values range from 1 to 65534.
         */
        frontendPort?: number;
        /**
         * The timeout for the TCP idle connection. The value can be set between 4 and 30 minutes. The default value is 4 minutes. This element is only used when the protocol is set to TCP.
         */
        idleTimeoutInMinutes?: number;
        /**
         * The reference to the transport protocol used by the load balancing rule.
         */
        protocol?: string;
        /**
         * The provisioning state of the inbound NAT rule resource.
         */
        provisioningState: string;
    }

    /**
     * Inbound NAT rule of the load balancer.
     */
    export interface InboundNatRuleResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within the set of inbound NAT rules used by the load balancer. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of load balancer inbound nat rule.
         */
        properties?: outputs.network.InboundNatRulePropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Properties of the interface endpoint.
     */
    export interface InterfaceEndpointPropertiesResponse {
        /**
         * A reference to the service being brought into the virtual network.
         */
        endpointService?: outputs.network.EndpointServiceResponse;
        /**
         * A first-party service's FQDN that is mapped to the private IP allocated via this interface endpoint.
         */
        fqdn?: string;
        /**
         * Gets an array of references to the network interfaces created for this interface endpoint.
         */
        networkInterfaces: outputs.network.NetworkInterfaceResponse[];
        /**
         * A read-only property that identifies who created this interface endpoint.
         */
        owner: string;
        /**
         * The provisioning state of the interface endpoint. Possible values are: 'Updating', 'Deleting', and 'Failed'.
         */
        provisioningState: string;
        /**
         * The ID of the subnet from which the private IP will be allocated.
         */
        subnet?: outputs.network.SubnetResponse;
    }

    /**
     * Properties of the IpAllocation.
     */
    export interface IpAllocationPropertiesFormatResponse {
        /**
         * IpAllocation tags.
         */
        allocationTags?: {[key: string]: string};
        /**
         * The IPAM allocation ID.
         */
        ipamAllocationId?: string;
        /**
         * The address prefix for the IpAllocation.
         */
        prefix?: string;
        /**
         * The address prefix length for the IpAllocation.
         */
        prefixLength?: number;
        /**
         * The address prefix Type for the IpAllocation.
         */
        prefixType?: string;
        /**
         * The Subnet that using the prefix of this IpAllocation resource.
         */
        subnet: outputs.network.SubResourceResponse;
        /**
         * The type for the IpAllocation.
         */
        type?: string;
        /**
         * The VirtualNetwork that using the prefix of this IpAllocation resource.
         */
        virtualNetwork: outputs.network.SubResourceResponse;
    }

    /**
     * The IpGroups property information.
     */
    export interface IpGroupPropertiesFormatResponse {
        /**
         * List of references to Azure resources that this IpGroups is associated with.
         */
        firewalls: outputs.network.SubResourceResponse[];
        /**
         * IpAddresses/IpAddressPrefixes in the IpGroups resource.
         */
        ipAddresses?: string[];
        /**
         * The provisioning state of the IpGroups resource.
         */
        provisioningState: string;
    }

    /**
     * List of IpGroups associated with azure firewall.
     */
    export interface IpGroupsResponse {
    }

    /**
     * Contains the IpTag associated with the object.
     */
    export interface IpTagResponse {
        /**
         * The IP tag type. Example: FirstPartyUsage.
         */
        ipTagType?: string;
        /**
         * The value of the IP tag associated with the public IP. Example: SQL.
         */
        tag?: string;
    }

    /**
     * An IPSec Policy configuration for a virtual network gateway connection.
     */
    export interface IpsecPolicyResponse {
        /**
         * The DH Group used in IKE Phase 1 for initial SA.
         */
        dhGroup: string;
        /**
         * The IKE encryption algorithm (IKE phase 2).
         */
        ikeEncryption: string;
        /**
         * The IKE integrity algorithm (IKE phase 2).
         */
        ikeIntegrity: string;
        /**
         * The IPSec encryption algorithm (IKE phase 1).
         */
        ipsecEncryption: string;
        /**
         * The IPSec integrity algorithm (IKE phase 1).
         */
        ipsecIntegrity: string;
        /**
         * The Pfs Group used in IKE Phase 2 for new child SA.
         */
        pfsGroup: string;
        /**
         * The IPSec Security Association (also called Quick Mode or Phase 2 SA) payload size in KB for a site to site VPN tunnel.
         */
        saDataSizeKilobytes: number;
        /**
         * The IPSec Security Association (also called Quick Mode or Phase 2 SA) lifetime in seconds for a site to site VPN tunnel.
         */
        saLifeTimeSeconds: number;
    }

    /**
     * IPv6 Circuit Connection properties for global reach.
     */
    export interface Ipv6CircuitConnectionConfigResponse {
        /**
         * /125 IP address space to carve out customer addresses for global reach.
         */
        addressPrefix?: string;
        /**
         * Express Route Circuit connection state.
         */
        circuitConnectionStatus: string;
    }

    /**
     * Contains IPv6 peering config.
     */
    export interface Ipv6ExpressRouteCircuitPeeringConfigResponse {
        /**
         * The Microsoft peering configuration.
         */
        microsoftPeeringConfig?: outputs.network.ExpressRouteCircuitPeeringConfigResponse;
        /**
         * The primary address prefix.
         */
        primaryPeerAddressPrefix?: string;
        /**
         * The reference to the RouteFilter resource.
         */
        routeFilter?: outputs.network.SubResourceResponse;
        /**
         * The secondary address prefix.
         */
        secondaryPeerAddressPrefix?: string;
        /**
         * The state of peering.
         */
        state?: string;
    }

    /**
     * Parameters required for bring-your-own-certification via Key Vault
     */
    export interface KeyVaultCertificateSourceParametersResponse {
        /**
         * The name of the Key Vault secret representing the full certificate PFX
         */
        secretName?: string;
        /**
         * The version of the Key Vault secret representing the full certificate PFX
         */
        secretVersion?: string;
        /**
         * The Key Vault containing the SSL certificate
         */
        vault?: outputs.network.KeyVaultCertificateSourceParametersResponseProperties;
    }

    /**
     * The Key Vault containing the SSL certificate
     */
    export interface KeyVaultCertificateSourceParametersResponseProperties {
        /**
         * Resource ID.
         */
        id?: string;
    }

    /**
     * Properties of the load balancer backend addresses.
     */
    export interface LoadBalancerBackendAddressPropertiesFormatResponse {
        /**
         * IP Address belonging to the referenced virtual network.
         */
        ipAddress?: string;
        /**
         * Reference to IP address defined in network interfaces.
         */
        networkInterfaceIPConfiguration: outputs.network.SubResourceResponse;
        /**
         * Reference to an existing virtual network.
         */
        virtualNetwork?: outputs.network.SubResourceResponse;
    }

    /**
     * Load balancer backend addresses.
     */
    export interface LoadBalancerBackendAddressResponse {
        /**
         * Name of the backend address.
         */
        name?: string;
        /**
         * Properties of load balancer backend address pool.
         */
        properties?: outputs.network.LoadBalancerBackendAddressPropertiesFormatResponse;
    }

    /**
     * Properties of the load balancer.
     */
    export interface LoadBalancerPropertiesFormatResponse {
        /**
         * Collection of backend address pools used by a load balancer.
         */
        backendAddressPools?: outputs.network.BackendAddressPoolResponse[];
        /**
         * Object representing the frontend IPs to be used for the load balancer.
         */
        frontendIPConfigurations?: outputs.network.FrontendIPConfigurationResponse[];
        /**
         * Defines an external port range for inbound NAT to a single backend port on NICs associated with a load balancer. Inbound NAT rules are created automatically for each NIC associated with the Load Balancer using an external port from this range. Defining an Inbound NAT pool on your Load Balancer is mutually exclusive with defining inbound Nat rules. Inbound NAT pools are referenced from virtual machine scale sets. NICs that are associated with individual virtual machines cannot reference an inbound NAT pool. They have to reference individual inbound NAT rules.
         */
        inboundNatPools?: outputs.network.InboundNatPoolResponse[];
        /**
         * Collection of inbound NAT Rules used by a load balancer. Defining inbound NAT rules on your load balancer is mutually exclusive with defining an inbound NAT pool. Inbound NAT pools are referenced from virtual machine scale sets. NICs that are associated with individual virtual machines cannot reference an Inbound NAT pool. They have to reference individual inbound NAT rules.
         */
        inboundNatRules?: outputs.network.InboundNatRuleResponse[];
        /**
         * Object collection representing the load balancing rules Gets the provisioning.
         */
        loadBalancingRules?: outputs.network.LoadBalancingRuleResponse[];
        /**
         * The outbound rules.
         */
        outboundRules?: outputs.network.OutboundRuleResponse[];
        /**
         * Collection of probe objects used in the load balancer.
         */
        probes?: outputs.network.ProbeResponse[];
        /**
         * The provisioning state of the load balancer resource.
         */
        provisioningState: string;
        /**
         * The resource GUID property of the load balancer resource.
         */
        resourceGuid: string;
    }

    /**
     * SKU of a load balancer.
     */
    export interface LoadBalancerSkuResponse {
        /**
         * Name of a load balancer SKU.
         */
        name?: string;
    }

    /**
     * Properties of the load balancer.
     */
    export interface LoadBalancingRulePropertiesFormatResponse {
        /**
         * A reference to a pool of DIPs. Inbound traffic is randomly load balanced across IPs in the backend IPs.
         */
        backendAddressPool?: outputs.network.SubResourceResponse;
        /**
         * The port used for internal connections on the endpoint. Acceptable values are between 0 and 65535. Note that value 0 enables "Any Port".
         */
        backendPort?: number;
        /**
         * Configures SNAT for the VMs in the backend pool to use the publicIP address specified in the frontend of the load balancing rule.
         */
        disableOutboundSnat?: boolean;
        /**
         * Configures a virtual machine's endpoint for the floating IP capability required to configure a SQL AlwaysOn Availability Group. This setting is required when using the SQL AlwaysOn Availability Groups in SQL server. This setting can't be changed after you create the endpoint.
         */
        enableFloatingIP?: boolean;
        /**
         * Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This element is only used when the protocol is set to TCP.
         */
        enableTcpReset?: boolean;
        /**
         * A reference to frontend IP addresses.
         */
        frontendIPConfiguration?: outputs.network.SubResourceResponse;
        /**
         * The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 0 and 65534. Note that value 0 enables "Any Port".
         */
        frontendPort: number;
        /**
         * The timeout for the TCP idle connection. The value can be set between 4 and 30 minutes. The default value is 4 minutes. This element is only used when the protocol is set to TCP.
         */
        idleTimeoutInMinutes?: number;
        /**
         * The load distribution policy for this rule.
         */
        loadDistribution?: string;
        /**
         * The reference to the load balancer probe used by the load balancing rule.
         */
        probe?: outputs.network.SubResourceResponse;
        /**
         * The reference to the transport protocol used by the load balancing rule.
         */
        protocol: string;
        /**
         * The provisioning state of the load balancing rule resource.
         */
        provisioningState: string;
    }

    /**
     * A load balancing rule for a load balancer.
     */
    export interface LoadBalancingRuleResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within the set of load balancing rules used by the load balancer. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of load balancer load balancing rule.
         */
        properties?: outputs.network.LoadBalancingRulePropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Load balancing settings for a backend pool
     */
    export interface LoadBalancingSettingsModelResponse {
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource name.
         */
        name?: string;
        /**
         * Properties of the load balancing settings
         */
        properties?: outputs.network.LoadBalancingSettingsPropertiesResponse;
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * The JSON object that contains the properties required to create load balancing settings
     */
    export interface LoadBalancingSettingsPropertiesResponse {
        /**
         * The additional latency in milliseconds for probes to fall into the lowest latency bucket
         */
        additionalLatencyMilliseconds?: number;
        /**
         * Resource status.
         */
        resourceState?: string;
        /**
         * The number of samples to consider for load balancing decisions
         */
        sampleSize?: number;
        /**
         * The number of samples within the sample period that must succeed
         */
        successfulSamplesRequired?: number;
    }

    /**
     * LocalNetworkGateway properties.
     */
    export interface LocalNetworkGatewayPropertiesFormatResponse {
        /**
         * Local network gateway's BGP speaker settings.
         */
        bgpSettings?: outputs.network.BgpSettingsResponse;
        /**
         * FQDN of local network gateway.
         */
        fqdn?: string;
        /**
         * IP address of local network gateway.
         */
        gatewayIpAddress?: string;
        /**
         * Local network site address space.
         */
        localNetworkAddressSpace?: outputs.network.AddressSpaceResponse;
        /**
         * The provisioning state of the local network gateway resource.
         */
        provisioningState: string;
        /**
         * The resource GUID property of the local network gateway resource.
         */
        resourceGuid: string;
    }

    /**
     * A common class for general resource information.
     */
    export interface LocalNetworkGatewayResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource location.
         */
        location?: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Properties of the local network gateway.
         */
        properties: outputs.network.LocalNetworkGatewayPropertiesFormatResponse;
        /**
         * Resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Defines a managed rule group override setting.
     */
    export interface ManagedRuleGroupOverrideResponse {
        /**
         * The managed rule group to override.
         */
        ruleGroupName: string;
        /**
         * List of rules that will be disabled. If none specified, all rules in the group will be disabled.
         */
        rules?: outputs.network.ManagedRuleOverrideResponse[];
    }

    /**
     * Defines a managed rule group override setting.
     */
    export interface ManagedRuleOverrideResponse {
        /**
         * Identifier for the managed rule.
         */
        ruleId: string;
        /**
         * The state of the managed rule. Defaults to Disabled if not specified.
         */
        state?: string;
    }

    /**
     * Defines a managed rule set.
     */
    export interface ManagedRuleSetResponse {
        /**
         * Defines the rule group overrides to apply to the rule set.
         */
        ruleGroupOverrides?: outputs.network.ManagedRuleGroupOverrideResponse[];
        /**
         * Defines the rule set type to use.
         */
        ruleSetType: string;
        /**
         * Defines the version of the rule set to use.
         */
        ruleSetVersion: string;
    }

    /**
     * Allow to exclude some variable satisfy the condition for the WAF check.
     */
    export interface ManagedRulesDefinitionResponse {
        /**
         * The Exclusions that are applied on the policy.
         */
        exclusions?: outputs.network.OwaspCrsExclusionEntryResponse[];
        /**
         * The managed rule sets that are associated with the policy.
         */
        managedRuleSets: outputs.network.ManagedRuleSetResponse[];
    }

    /**
     * Identity for the resource.
     */
    export interface ManagedServiceIdentityResponse {
        /**
         * The principal id of the system assigned identity. This property will only be provided for a system assigned identity.
         */
        principalId: string;
        /**
         * The tenant id of the system assigned identity. This property will only be provided for a system assigned identity.
         */
        tenantId: string;
        /**
         * The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual machine.
         */
        type?: string;
        /**
         * The list of user identities associated with resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
         */
        userAssignedIdentities?: {[key: string]: string};
    }

    /**
     * Define match conditions.
     */
    export interface MatchConditionResponse {
        /**
         * Match value.
         */
        matchValues: string[];
        /**
         * List of match variables.
         */
        matchVariables: outputs.network.MatchVariableResponse[];
        /**
         * Whether this is negate condition or not.
         */
        negationConditon?: boolean;
        /**
         * The operator to be matched.
         */
        operator: string;
        /**
         * List of transforms.
         */
        transforms?: string[];
    }

    /**
     * Define match variables.
     */
    export interface MatchVariableResponse {
        /**
         * The selector of match variable.
         */
        selector?: string;
        /**
         * Match Variable.
         */
        variableName: string;
    }

    /**
     * Class containing endpoint monitoring settings in a Traffic Manager profile.
     */
    export interface MonitorConfigResponse {
        /**
         * List of custom headers.
         */
        customHeaders?: outputs.network.MonitorConfigResponseProperties[];
        /**
         * List of expected status code ranges.
         */
        expectedStatusCodeRanges?: outputs.network.MonitorConfigResponseProperties[];
        /**
         * The monitor interval for endpoints in this profile. This is the interval at which Traffic Manager will check the health of each endpoint in this profile.
         */
        intervalInSeconds?: number;
        /**
         * The path relative to the endpoint domain name used to probe for endpoint health.
         */
        path?: string;
        /**
         * The TCP port used to probe for endpoint health.
         */
        port?: number;
        /**
         * The profile-level monitoring status of the Traffic Manager profile.
         */
        profileMonitorStatus?: string;
        /**
         * The protocol (HTTP, HTTPS or TCP) used to probe for endpoint health.
         */
        protocol?: string;
        /**
         * The monitor timeout for endpoints in this profile. This is the time that Traffic Manager allows endpoints in this profile to response to the health check.
         */
        timeoutInSeconds?: number;
        /**
         * The number of consecutive failed health check that Traffic Manager tolerates before declaring an endpoint in this profile Degraded after the next failed health check.
         */
        toleratedNumberOfFailures?: number;
    }

    /**
     * Custom header name and value.
     */
    export interface MonitorConfigResponseProperties {
        /**
         * Header name.
         */
        name?: string;
        /**
         * Header value.
         */
        value?: string;
    }

    /**
     * Nat Gateway properties.
     */
    export interface NatGatewayPropertiesFormatResponse {
        /**
         * The idle timeout of the nat gateway.
         */
        idleTimeoutInMinutes?: number;
        /**
         * The provisioning state of the NAT gateway resource.
         */
        provisioningState: string;
        /**
         * An array of public ip addresses associated with the nat gateway resource.
         */
        publicIpAddresses?: outputs.network.SubResourceResponse[];
        /**
         * An array of public ip prefixes associated with the nat gateway resource.
         */
        publicIpPrefixes?: outputs.network.SubResourceResponse[];
        /**
         * The resource GUID property of the NAT gateway resource.
         */
        resourceGuid: string;
        /**
         * An array of references to the subnets using this nat gateway resource.
         */
        subnets: outputs.network.SubResourceResponse[];
    }

    /**
     * SKU of nat gateway.
     */
    export interface NatGatewaySkuResponse {
        /**
         * Name of Nat Gateway SKU.
         */
        name?: string;
    }

    /**
     * DNS settings of a network interface.
     */
    export interface NetworkInterfaceDnsSettingsResponse {
        /**
         * If the VM that uses this NIC is part of an Availability Set, then this list will have the union of all DNS servers from all NICs that are part of the Availability Set. This property is what is configured on each of those VMs.
         */
        appliedDnsServers: string[];
        /**
         * List of DNS servers IP addresses. Use 'AzureProvidedDNS' to switch to azure provided DNS resolution. 'AzureProvidedDNS' value cannot be combined with other IPs, it must be the only value in dnsServers collection.
         */
        dnsServers?: string[];
        /**
         * Relative DNS name for this NIC used for internal communications between VMs in the same virtual network.
         */
        internalDnsNameLabel?: string;
        /**
         * Even if internalDnsNameLabel is not specified, a DNS entry is created for the primary NIC of the VM. This DNS name can be constructed by concatenating the VM name with the value of internalDomainNameSuffix.
         */
        internalDomainNameSuffix: string;
        /**
         * Fully qualified DNS name supporting internal communications between VMs in the same virtual network.
         */
        internalFqdn: string;
    }

    /**
     * PrivateLinkConnection properties for the network interface.
     */
    export interface NetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesResponse {
        /**
         * List of FQDNs for current private link connection.
         */
        fqdns: string[];
        /**
         * The group ID for current private link connection.
         */
        groupId: string;
        /**
         * The required member name for current private link connection.
         */
        requiredMemberName: string;
    }

    /**
     * Properties of IP configuration.
     */
    export interface NetworkInterfaceIPConfigurationPropertiesFormatResponse {
        /**
         * The reference to ApplicationGatewayBackendAddressPool resource.
         */
        applicationGatewayBackendAddressPools?: outputs.network.ApplicationGatewayBackendAddressPoolResponse[];
        /**
         * Application security groups in which the IP configuration is included.
         */
        applicationSecurityGroups?: outputs.network.ApplicationSecurityGroupResponse[];
        /**
         * The reference to LoadBalancerBackendAddressPool resource.
         */
        loadBalancerBackendAddressPools?: outputs.network.BackendAddressPoolResponse[];
        /**
         * A list of references of LoadBalancerInboundNatRules.
         */
        loadBalancerInboundNatRules?: outputs.network.InboundNatRuleResponse[];
        /**
         * Whether this is a primary customer address on the network interface.
         */
        primary?: boolean;
        /**
         * Private IP address of the IP configuration.
         */
        privateIPAddress?: string;
        /**
         * Whether the specific IP configuration is IPv4 or IPv6. Default is IPv4.
         */
        privateIPAddressVersion?: string;
        /**
         * The private IP address allocation method.
         */
        privateIPAllocationMethod?: string;
        /**
         * PrivateLinkConnection properties for the network interface.
         */
        privateLinkConnectionProperties: outputs.network.NetworkInterfaceIPConfigurationPrivateLinkConnectionPropertiesResponse;
        /**
         * The provisioning state of the network interface IP configuration.
         */
        provisioningState: string;
        /**
         * Public IP address bound to the IP configuration.
         */
        publicIPAddress?: outputs.network.PublicIPAddressResponse;
        /**
         * Subnet bound to the IP configuration.
         */
        subnet?: outputs.network.SubnetResponse;
        /**
         * The reference to Virtual Network Taps.
         */
        virtualNetworkTaps?: outputs.network.VirtualNetworkTapResponse[];
    }

    /**
     * IPConfiguration in a network interface.
     */
    export interface NetworkInterfaceIPConfigurationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Network interface IP configuration properties.
         */
        properties?: outputs.network.NetworkInterfaceIPConfigurationPropertiesFormatResponse;
    }

    /**
     * NetworkInterface properties.
     */
    export interface NetworkInterfacePropertiesFormatResponse {
        /**
         * The DNS settings in network interface.
         */
        dnsSettings?: outputs.network.NetworkInterfaceDnsSettingsResponse;
        /**
         * If the network interface is accelerated networking enabled.
         */
        enableAcceleratedNetworking?: boolean;
        /**
         * Indicates whether IP forwarding is enabled on this network interface.
         */
        enableIPForwarding?: boolean;
        /**
         * A list of references to linked BareMetal resources.
         */
        hostedWorkloads: string[];
        /**
         * A list of IPConfigurations of the network interface.
         */
        ipConfigurations?: outputs.network.NetworkInterfaceIPConfigurationResponse[];
        /**
         * The MAC address of the network interface.
         */
        macAddress: string;
        /**
         * The reference to the NetworkSecurityGroup resource.
         */
        networkSecurityGroup?: outputs.network.NetworkSecurityGroupResponse;
        /**
         * Whether this is a primary network interface on a virtual machine.
         */
        primary: boolean;
        /**
         * A reference to the private endpoint to which the network interface is linked.
         */
        privateEndpoint: outputs.network.PrivateEndpointResponse;
        /**
         * The provisioning state of the network interface resource.
         */
        provisioningState: string;
        /**
         * The resource GUID property of the network interface resource.
         */
        resourceGuid: string;
        /**
         * A list of TapConfigurations of the network interface.
         */
        tapConfigurations: outputs.network.NetworkInterfaceTapConfigurationResponse[];
        /**
         * The reference to a virtual machine.
         */
        virtualMachine: outputs.network.SubResourceResponse;
    }

    /**
     * A network interface in a resource group.
     */
    export interface NetworkInterfaceResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource location.
         */
        location?: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Properties of the network interface.
         */
        properties?: outputs.network.NetworkInterfacePropertiesFormatResponse;
        /**
         * Resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Properties of Virtual Network Tap configuration.
     */
    export interface NetworkInterfaceTapConfigurationPropertiesFormatResponse {
        /**
         * The provisioning state of the network interface tap configuration resource.
         */
        provisioningState: string;
        /**
         * The reference to the Virtual Network Tap resource.
         */
        virtualNetworkTap?: outputs.network.VirtualNetworkTapResponse;
    }

    /**
     * Tap configuration in a Network Interface.
     */
    export interface NetworkInterfaceTapConfigurationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the Virtual Network Tap configuration.
         */
        properties?: outputs.network.NetworkInterfaceTapConfigurationPropertiesFormatResponse;
        /**
         * Sub Resource type.
         */
        type: string;
    }

    /**
     * Network profile properties.
     */
    export interface NetworkProfilePropertiesFormatResponse {
        /**
         * List of chid container network interface configurations.
         */
        containerNetworkInterfaceConfigurations?: outputs.network.ContainerNetworkInterfaceConfigurationResponse[];
        /**
         * List of child container network interfaces.
         */
        containerNetworkInterfaces: outputs.network.ContainerNetworkInterfaceResponse[];
        /**
         * The provisioning state of the network profile resource.
         */
        provisioningState: string;
        /**
         * The resource GUID property of the network profile resource.
         */
        resourceGuid: string;
    }

    /**
     * Network Security Group resource.
     */
    export interface NetworkSecurityGroupPropertiesFormatResponse {
        /**
         * The default security rules of network security group.
         */
        defaultSecurityRules: outputs.network.SecurityRuleResponse[];
        /**
         * A collection of references to flow log resources.
         */
        flowLogs: outputs.network.FlowLogResponse[];
        /**
         * A collection of references to network interfaces.
         */
        networkInterfaces: outputs.network.NetworkInterfaceResponse[];
        /**
         * The provisioning state of the network security group resource.
         */
        provisioningState: string;
        /**
         * The resource GUID property of the network security group resource.
         */
        resourceGuid: string;
        /**
         * A collection of security rules of the network security group.
         */
        securityRules?: outputs.network.SecurityRuleResponse[];
        /**
         * A collection of references to subnets.
         */
        subnets: outputs.network.SubnetResponse[];
    }

    /**
     * NetworkSecurityGroup resource.
     */
    export interface NetworkSecurityGroupResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource location.
         */
        location?: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Properties of the network security group.
         */
        properties?: outputs.network.NetworkSecurityGroupPropertiesFormatResponse;
        /**
         * Resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Network Virtual Appliance definition.
     */
    export interface NetworkVirtualAppliancePropertiesFormatResponse {
        /**
         * BootStrapConfigurationBlobs storage URLs.
         */
        bootStrapConfigurationBlobs?: string[];
        /**
         * CloudInitConfiguration string in plain text.
         */
        cloudInitConfiguration?: string;
        /**
         * CloudInitConfigurationBlob storage URLs.
         */
        cloudInitConfigurationBlobs?: string[];
        /**
         * Network Virtual Appliance SKU.
         */
        nvaSku?: outputs.network.VirtualApplianceSkuPropertiesResponse;
        /**
         * The provisioning state of the resource.
         */
        provisioningState: string;
        /**
         * VirtualAppliance ASN.
         */
        virtualApplianceAsn?: number;
        /**
         * List of Virtual Appliance Network Interfaces.
         */
        virtualApplianceNics: outputs.network.VirtualApplianceNicPropertiesResponse[];
        /**
         * List of references to VirtualApplianceSite.
         */
        virtualApplianceSites: outputs.network.SubResourceResponse[];
        /**
         * The Virtual Hub where Network Virtual Appliance is being deployed.
         */
        virtualHub?: outputs.network.SubResourceResponse;
    }

    /**
     * The network watcher properties.
     */
    export interface NetworkWatcherPropertiesFormatResponse {
        /**
         * The provisioning state of the network watcher resource.
         */
        provisioningState: string;
    }

    /**
     * Network Virtual Appliance Sku Properties.
     */
    export interface Office365PolicyPropertiesResponse {
        /**
         * Office 365 breakout categories.
         */
        breakOutCategories?: outputs.network.BreakOutCategoryPoliciesResponse;
    }

    /**
     * Outbound rule of the load balancer.
     */
    export interface OutboundRulePropertiesFormatResponse {
        /**
         * The number of outbound ports to be used for NAT.
         */
        allocatedOutboundPorts?: number;
        /**
         * A reference to a pool of DIPs. Outbound traffic is randomly load balanced across IPs in the backend IPs.
         */
        backendAddressPool: outputs.network.SubResourceResponse;
        /**
         * Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This element is only used when the protocol is set to TCP.
         */
        enableTcpReset?: boolean;
        /**
         * The Frontend IP addresses of the load balancer.
         */
        frontendIPConfigurations: outputs.network.SubResourceResponse[];
        /**
         * The timeout for the TCP idle connection.
         */
        idleTimeoutInMinutes?: number;
        /**
         * The protocol for the outbound rule in load balancer.
         */
        protocol: string;
        /**
         * The provisioning state of the outbound rule resource.
         */
        provisioningState: string;
    }

    /**
     * Outbound rule of the load balancer.
     */
    export interface OutboundRuleResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within the set of outbound rules used by the load balancer. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of load balancer outbound rule.
         */
        properties?: outputs.network.OutboundRulePropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Allow to exclude some variable satisfy the condition for the WAF check.
     */
    export interface OwaspCrsExclusionEntryResponse {
        /**
         * The variable to be excluded.
         */
        matchVariable: string;
        /**
         * When matchVariable is a collection, operator used to specify which elements in the collection this exclusion applies to.
         */
        selector: string;
        /**
         * When matchVariable is a collection, operate on the selector to specify which elements in the collection this exclusion applies to.
         */
        selectorMatchOperator: string;
    }

    /**
     * Parameters for P2SConnectionConfiguration.
     */
    export interface P2SConnectionConfigurationPropertiesResponse {
        /**
         * The provisioning state of the P2SConnectionConfiguration resource.
         */
        provisioningState: string;
        /**
         * The Routing Configuration indicating the associated and propagated route tables on this connection.
         */
        routingConfiguration?: outputs.network.RoutingConfigurationResponse;
        /**
         * The reference to the address space resource which represents Address space for P2S VpnClient.
         */
        vpnClientAddressPool?: outputs.network.AddressSpaceResponse;
    }

    /**
     * P2SConnectionConfiguration Resource.
     */
    export interface P2SConnectionConfigurationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the P2S connection configuration.
         */
        properties?: outputs.network.P2SConnectionConfigurationPropertiesResponse;
    }

    /**
     * Parameters for P2SVpnGateway.
     */
    export interface P2SVpnGatewayPropertiesResponse {
        /**
         * List of all customer specified DNS servers IP addresses.
         */
        customDnsServers?: string[];
        /**
         * List of all p2s connection configurations of the gateway.
         */
        p2SConnectionConfigurations?: outputs.network.P2SConnectionConfigurationResponse[];
        /**
         * The provisioning state of the P2S VPN gateway resource.
         */
        provisioningState: string;
        /**
         * The VirtualHub to which the gateway belongs.
         */
        virtualHub?: outputs.network.SubResourceResponse;
        /**
         * All P2S VPN clients' connection health status.
         */
        vpnClientConnectionHealth: outputs.network.VpnClientConnectionHealthResponse;
        /**
         * The scale unit for this p2s vpn gateway.
         */
        vpnGatewayScaleUnit?: number;
        /**
         * The VpnServerConfiguration to which the p2sVpnGateway is attached to.
         */
        vpnServerConfiguration?: outputs.network.SubResourceResponse;
    }

    /**
     * P2SVpnGateway Resource.
     */
    export interface P2SVpnGatewayResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource location.
         */
        location: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Properties of the P2SVpnGateway.
         */
        properties?: outputs.network.P2SVpnGatewayPropertiesResponse;
        /**
         * Resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Filter that is applied to packet capture request. Multiple filters can be applied.
     */
    export interface PacketCaptureFilterResponse {
        /**
         * Local IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5"? for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Default = null.
         */
        localIPAddress?: string;
        /**
         * Local port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Default = null.
         */
        localPort?: string;
        /**
         * Protocol to be filtered on.
         */
        protocol?: string;
        /**
         * Local IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Default = null.
         */
        remoteIPAddress?: string;
        /**
         * Remote port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Default = null.
         */
        remotePort?: string;
    }

    /**
     * The properties of a packet capture session.
     */
    export interface PacketCaptureResultPropertiesResponse {
        /**
         * Number of bytes captured per packet, the remaining bytes are truncated.
         */
        bytesToCapturePerPacket?: number;
        /**
         * A list of packet capture filters.
         */
        filters?: outputs.network.PacketCaptureFilterResponse[];
        /**
         * The provisioning state of the packet capture session.
         */
        provisioningState: string;
        /**
         * The storage location for a packet capture session.
         */
        storageLocation: outputs.network.PacketCaptureStorageLocationResponse;
        /**
         * The ID of the targeted resource, only VM is currently supported.
         */
        target: string;
        /**
         * Maximum duration of the capture session in seconds.
         */
        timeLimitInSeconds?: number;
        /**
         * Maximum size of the capture output.
         */
        totalBytesPerSession?: number;
    }

    /**
     * The storage location for a packet capture session.
     */
    export interface PacketCaptureStorageLocationResponse {
        /**
         * A valid local path on the targeting VM. Must include the name of the capture file (*.cap). For linux virtual machine it must start with /var/captures. Required if no storage ID is provided, otherwise optional.
         */
        filePath?: string;
        /**
         * The ID of the storage account to save the packet capture session. Required if no local file path is provided.
         */
        storageId?: string;
        /**
         * The URI of the storage path to save the packet capture. Must be a well-formed URI describing the location to save the packet capture.
         */
        storagePath?: string;
    }

    /**
     * Properties of the peer express route circuit connection.
     */
    export interface PeerExpressRouteCircuitConnectionPropertiesFormatResponse {
        /**
         * /29 IP address space to carve out Customer addresses for tunnels.
         */
        addressPrefix?: string;
        /**
         * The resource guid of the authorization used for the express route circuit connection.
         */
        authResourceGuid?: string;
        /**
         * Express Route Circuit connection state.
         */
        circuitConnectionStatus?: string;
        /**
         * The name of the express route circuit connection resource.
         */
        connectionName?: string;
        /**
         * Reference to Express Route Circuit Private Peering Resource of the circuit.
         */
        expressRouteCircuitPeering?: outputs.network.SubResourceResponse;
        /**
         * Reference to Express Route Circuit Private Peering Resource of the peered circuit.
         */
        peerExpressRouteCircuitPeering?: outputs.network.SubResourceResponse;
        /**
         * The provisioning state of the peer express route circuit connection resource.
         */
        provisioningState: string;
    }

    /**
     * Peer Express Route Circuit Connection in an ExpressRouteCircuitPeering resource.
     */
    export interface PeerExpressRouteCircuitConnectionResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the peer express route circuit connection.
         */
        properties?: outputs.network.PeerExpressRouteCircuitConnectionPropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Defines contents of a web application firewall global configuration.
     */
    export interface PolicySettingsResponse {
        /**
         * Maximum file upload size in Mb for WAF.
         */
        fileUploadLimitInMb?: number;
        /**
         * Maximum request body size in Kb for WAF.
         */
        maxRequestBodySizeInKb?: number;
        /**
         * The mode of the policy.
         */
        mode?: string;
        /**
         * Whether to allow WAF to check request Body.
         */
        requestBodyCheck?: boolean;
        /**
         * The state of the policy.
         */
        state?: string;
    }

    /**
     * PrivateDnsZoneConfig resource.
     */
    export interface PrivateDnsZoneConfigResponse {
        /**
         * Name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the private dns zone configuration.
         */
        properties?: outputs.network.PrivateDnsZonePropertiesFormatResponse;
    }

    /**
     * Properties of the private dns zone group.
     */
    export interface PrivateDnsZoneGroupPropertiesFormatResponse {
        /**
         * A collection of private dns zone configurations of the private dns zone group.
         */
        privateDnsZoneConfigs?: outputs.network.PrivateDnsZoneConfigResponse[];
        /**
         * The provisioning state of the private dns zone group resource.
         */
        provisioningState: string;
    }

    /**
     * Properties of the private dns zone configuration resource.
     */
    export interface PrivateDnsZonePropertiesFormatResponse {
        /**
         * The resource id of the private dns zone.
         */
        privateDnsZoneId?: string;
        /**
         * A collection of information regarding a recordSet, holding information to identify private resources.
         */
        recordSets: outputs.network.RecordSetResponse[];
    }

    /**
     * Properties of the PrivateEndpointConnectProperties.
     */
    export interface PrivateEndpointConnectionPropertiesResponse {
        /**
         * The consumer link id.
         */
        linkIdentifier: string;
        /**
         * The resource of private end point.
         */
        privateEndpoint: outputs.network.PrivateEndpointResponse;
        /**
         * A collection of information about the state of the connection between service consumer and provider.
         */
        privateLinkServiceConnectionState?: outputs.network.PrivateLinkServiceConnectionStateResponse;
        /**
         * The provisioning state of the private endpoint connection resource.
         */
        provisioningState: string;
    }

    /**
     * PrivateEndpointConnection resource.
     */
    export interface PrivateEndpointConnectionResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the private end point connection.
         */
        properties?: outputs.network.PrivateEndpointConnectionPropertiesResponse;
        /**
         * The resource type.
         */
        type: string;
    }

    /**
     * Properties of the private endpoint.
     */
    export interface PrivateEndpointPropertiesResponse {
        /**
         * An array of custom dns configurations.
         */
        customDnsConfigs?: outputs.network.CustomDnsConfigPropertiesFormatResponse[];
        /**
         * A grouping of information about the connection to the remote resource. Used when the network admin does not have access to approve connections to the remote resource.
         */
        manualPrivateLinkServiceConnections?: outputs.network.PrivateLinkServiceConnectionResponse[];
        /**
         * An array of references to the network interfaces created for this private endpoint.
         */
        networkInterfaces: outputs.network.NetworkInterfaceResponse[];
        /**
         * A grouping of information about the connection to the remote resource.
         */
        privateLinkServiceConnections?: outputs.network.PrivateLinkServiceConnectionResponse[];
        /**
         * The provisioning state of the private endpoint resource.
         */
        provisioningState: string;
        /**
         * The ID of the subnet from which the private IP will be allocated.
         */
        subnet?: outputs.network.SubnetResponse;
    }

    /**
     * Private endpoint resource.
     */
    export interface PrivateEndpointResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource location.
         */
        location?: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Properties of the private endpoint.
         */
        properties?: outputs.network.PrivateEndpointPropertiesResponse;
        /**
         * Resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Properties of the PrivateLinkServiceConnection.
     */
    export interface PrivateLinkServiceConnectionPropertiesResponse {
        /**
         * The ID(s) of the group(s) obtained from the remote resource that this private endpoint should connect to.
         */
        groupIds?: string[];
        /**
         * A collection of read-only information about the state of the connection to the remote resource.
         */
        privateLinkServiceConnectionState?: outputs.network.PrivateLinkServiceConnectionStateResponse;
        /**
         * The resource id of private link service.
         */
        privateLinkServiceId?: string;
        /**
         * The provisioning state of the private link service connection resource.
         */
        provisioningState: string;
        /**
         * A message passed to the owner of the remote resource with this connection request. Restricted to 140 chars.
         */
        requestMessage?: string;
    }

    /**
     * PrivateLinkServiceConnection resource.
     */
    export interface PrivateLinkServiceConnectionResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the private link service connection.
         */
        properties?: outputs.network.PrivateLinkServiceConnectionPropertiesResponse;
        /**
         * The resource type.
         */
        type: string;
    }

    /**
     * A collection of information about the state of the connection between service consumer and provider.
     */
    export interface PrivateLinkServiceConnectionStateResponse {
        /**
         * A message indicating if changes on the service provider require any updates on the consumer.
         */
        actionsRequired?: string;
        /**
         * The reason for approval/rejection of the connection.
         */
        description?: string;
        /**
         * Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
         */
        status?: string;
    }

    /**
     * Properties of private link service IP configuration.
     */
    export interface PrivateLinkServiceIpConfigurationPropertiesResponse {
        /**
         * Whether the ip configuration is primary or not.
         */
        primary?: boolean;
        /**
         * The private IP address of the IP configuration.
         */
        privateIPAddress?: string;
        /**
         * Whether the specific IP configuration is IPv4 or IPv6. Default is IPv4.
         */
        privateIPAddressVersion?: string;
        /**
         * The private IP address allocation method.
         */
        privateIPAllocationMethod?: string;
        /**
         * The provisioning state of the private link service IP configuration resource.
         */
        provisioningState: string;
        /**
         * The reference to the subnet resource.
         */
        subnet?: outputs.network.SubnetResponse;
    }

    /**
     * The private link service ip configuration.
     */
    export interface PrivateLinkServiceIpConfigurationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of private link service ip configuration.
         */
        name?: string;
        /**
         * Properties of the private link service ip configuration.
         */
        properties?: outputs.network.PrivateLinkServiceIpConfigurationPropertiesResponse;
        /**
         * The resource type.
         */
        type: string;
    }

    /**
     * Properties of the private link service.
     */
    export interface PrivateLinkServicePropertiesResponse {
        /**
         * The alias of the private link service.
         */
        alias: string;
        /**
         * The auto-approval list of the private link service.
         */
        autoApproval?: {[key: string]: string};
        /**
         * Whether the private link service is enabled for proxy protocol or not.
         */
        enableProxyProtocol?: boolean;
        /**
         * The list of Fqdn.
         */
        fqdns?: string[];
        /**
         * An array of private link service IP configurations.
         */
        ipConfigurations?: outputs.network.PrivateLinkServiceIpConfigurationResponse[];
        /**
         * An array of references to the load balancer IP configurations.
         */
        loadBalancerFrontendIpConfigurations?: outputs.network.FrontendIPConfigurationResponse[];
        /**
         * An array of references to the network interfaces created for this private link service.
         */
        networkInterfaces: outputs.network.NetworkInterfaceResponse[];
        /**
         * An array of list about connections to the private endpoint.
         */
        privateEndpointConnections: outputs.network.PrivateEndpointConnectionResponse[];
        /**
         * The provisioning state of the private link service resource.
         */
        provisioningState: string;
        /**
         * The visibility list of the private link service.
         */
        visibility?: {[key: string]: string};
    }

    /**
     * Represents the properties of the Private DNS zone.
     */
    export interface PrivateZonePropertiesResponse {
        /**
         * The maximum number of record sets that can be created in this Private DNS zone. This is a read-only property and any attempt to set this value will be ignored.
         */
        maxNumberOfRecordSets: number;
        /**
         * The maximum number of virtual networks that can be linked to this Private DNS zone. This is a read-only property and any attempt to set this value will be ignored.
         */
        maxNumberOfVirtualNetworkLinks: number;
        /**
         * The maximum number of virtual networks that can be linked to this Private DNS zone with registration enabled. This is a read-only property and any attempt to set this value will be ignored.
         */
        maxNumberOfVirtualNetworkLinksWithRegistration: number;
        /**
         * The current number of record sets in this Private DNS zone. This is a read-only property and any attempt to set this value will be ignored.
         */
        numberOfRecordSets: number;
        /**
         * The current number of virtual networks that are linked to this Private DNS zone. This is a read-only property and any attempt to set this value will be ignored.
         */
        numberOfVirtualNetworkLinks: number;
        /**
         * The current number of virtual networks that are linked to this Private DNS zone with registration enabled. This is a read-only property and any attempt to set this value will be ignored.
         */
        numberOfVirtualNetworkLinksWithRegistration: number;
        /**
         * The provisioning state of the resource. This is a read-only property and any attempt to set this value will be ignored.
         */
        provisioningState: string;
    }

    /**
     * Load balancer probe resource.
     */
    export interface ProbePropertiesFormatResponse {
        /**
         * The interval, in seconds, for how frequently to probe the endpoint for health status. Typically, the interval is slightly less than half the allocated timeout period (in seconds) which allows two full probes before taking the instance out of rotation. The default value is 15, the minimum value is 5.
         */
        intervalInSeconds?: number;
        /**
         * The load balancer rules that use this probe.
         */
        loadBalancingRules: outputs.network.SubResourceResponse[];
        /**
         * The number of probes where if no response, will result in stopping further traffic from being delivered to the endpoint. This values allows endpoints to be taken out of rotation faster or slower than the typical times used in Azure.
         */
        numberOfProbes?: number;
        /**
         * The port for communicating the probe. Possible values range from 1 to 65535, inclusive.
         */
        port: number;
        /**
         * The protocol of the end point. If 'Tcp' is specified, a received ACK is required for the probe to be successful. If 'Http' or 'Https' is specified, a 200 OK response from the specifies URI is required for the probe to be successful.
         */
        protocol: string;
        /**
         * The provisioning state of the probe resource.
         */
        provisioningState: string;
        /**
         * The URI used for requesting health status from the VM. Path is required if a protocol is set to http. Otherwise, it is not allowed. There is no default value.
         */
        requestPath?: string;
    }

    /**
     * A load balancer probe.
     */
    export interface ProbeResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within the set of probes used by the load balancer. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of load balancer probe.
         */
        properties?: outputs.network.ProbePropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type: string;
    }

    /**
     * Class representing the Traffic Manager profile properties.
     */
    export interface ProfilePropertiesResponse {
        /**
         * The DNS settings of the Traffic Manager profile.
         */
        dnsConfig?: outputs.network.DnsConfigResponse;
        /**
         * The list of endpoints in the Traffic Manager profile.
         */
        endpoints?: outputs.network.EndpointResponse[];
        /**
         * Maximum number of endpoints to be returned for MultiValue routing type.
         */
        maxReturn?: number;
        /**
         * The endpoint monitoring settings of the Traffic Manager profile.
         */
        monitorConfig?: outputs.network.MonitorConfigResponse;
        /**
         * The status of the Traffic Manager profile.
         */
        profileStatus?: string;
        /**
         * The traffic routing method of the Traffic Manager profile.
         */
        trafficRoutingMethod?: string;
        /**
         * Indicates whether Traffic View is 'Enabled' or 'Disabled' for the Traffic Manager profile. Null, indicates 'Disabled'. Enabling this feature will increase the cost of the Traffic Manage profile.
         */
        trafficViewEnrollmentStatus?: string;
    }

    /**
     * The list of RouteTables to advertise the routes to.
     */
    export interface PropagatedRouteTableResponse {
        /**
         * The list of resource ids of all the RouteTables.
         */
        ids?: outputs.network.SubResourceResponse[];
        /**
         * The list of labels.
         */
        labels?: string[];
    }

    /**
     * DDoS custom policy properties.
     */
    export interface ProtocolCustomSettingsFormatResponse {
        /**
         * The protocol for which the DDoS protection policy is being customized.
         */
        protocol?: string;
        /**
         * The customized DDoS protection source rate.
         */
        sourceRateOverride?: string;
        /**
         * The customized DDoS protection trigger rate.
         */
        triggerRateOverride?: string;
        /**
         * The customized DDoS protection trigger rate sensitivity degrees. High: Trigger rate set with most sensitivity w.r.t. normal traffic. Default: Trigger rate set with moderate sensitivity w.r.t. normal traffic. Low: Trigger rate set with less sensitivity w.r.t. normal traffic. Relaxed: Trigger rate set with least sensitivity w.r.t. normal traffic.
         */
        triggerSensitivityOverride?: string;
    }

    /**
     * Contains FQDN of the DNS record associated with the public IP address.
     */
    export interface PublicIPAddressDnsSettingsResponse {
        /**
         * The domain name label. The concatenation of the domain name label and the regionalized DNS zone make up the fully qualified domain name associated with the public IP address. If a domain name label is specified, an A DNS record is created for the public IP in the Microsoft Azure DNS system.
         */
        domainNameLabel?: string;
        /**
         * The Fully Qualified Domain Name of the A DNS record associated with the public IP. This is the concatenation of the domainNameLabel and the regionalized DNS zone.
         */
        fqdn?: string;
        /**
         * The reverse FQDN. A user-visible, fully qualified domain name that resolves to this public IP address. If the reverseFqdn is specified, then a PTR DNS record is created pointing from the IP address in the in-addr.arpa domain to the reverse FQDN.
         */
        reverseFqdn?: string;
    }

    /**
     * Public IP address properties.
     */
    export interface PublicIPAddressPropertiesFormatResponse {
        /**
         * The DDoS protection custom policy associated with the public IP address.
         */
        ddosSettings?: outputs.network.DdosSettingsResponse;
        /**
         * The FQDN of the DNS record associated with the public IP address.
         */
        dnsSettings?: outputs.network.PublicIPAddressDnsSettingsResponse;
        /**
         * The idle timeout of the public IP address.
         */
        idleTimeoutInMinutes?: number;
        /**
         * The IP address associated with the public IP address resource.
         */
        ipAddress?: string;
        /**
         * The IP configuration associated with the public IP address.
         */
        ipConfiguration: outputs.network.IPConfigurationResponse;
        /**
         * The list of tags associated with the public IP address.
         */
        ipTags?: outputs.network.IpTagResponse[];
        /**
         * The provisioning state of the public IP address resource.
         */
        provisioningState: string;
        /**
         * The public IP address version.
         */
        publicIPAddressVersion?: string;
        /**
         * The public IP address allocation method.
         */
        publicIPAllocationMethod?: string;
        /**
         * The Public IP Prefix this Public IP Address should be allocated from.
         */
        publicIPPrefix?: outputs.network.SubResourceResponse;
        /**
         * The resource GUID property of the public IP address resource.
         */
        resourceGuid: string;
    }

    /**
     * Public IP address resource.
     */
    export interface PublicIPAddressResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource location.
         */
        location?: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Public IP address properties.
         */
        properties?: outputs.network.PublicIPAddressPropertiesFormatResponse;
        /**
         * The public IP address SKU.
         */
        sku?: outputs.network.PublicIPAddressSkuResponse;
        /**
         * Resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Resource type.
         */
        type: string;
        /**
         * A list of availability zones denoting the IP allocated for the resource needs to come from.
         */
        zones?: string[];
    }

    /**
     * SKU of a public IP address.
     */
    export interface PublicIPAddressSkuResponse {
        /**
         * Name of a public IP address SKU.
         */
        name?: string;
    }

    /**
     * Public IP prefix properties.
     */
    export interface PublicIPPrefixPropertiesFormatResponse {
        /**
         * The allocated Prefix.
         */
        ipPrefix: string;
        /**
         * The list of tags associated with the public IP prefix.
         */
        ipTags?: outputs.network.IpTagResponse[];
        /**
         * The reference to load balancer frontend IP configuration associated with the public IP prefix.
         */
        loadBalancerFrontendIpConfiguration: outputs.network.SubResourceResponse;
        /**
         * The Length of the Public IP Prefix.
         */
        prefixLength?: number;
        /**
         * The provisioning state of the public IP prefix resource.
         */
        provisioningState: string;
        /**
         * The public IP address version.
         */
        publicIPAddressVersion?: string;
        /**
         * The list of all referenced PublicIPAddresses.
         */
        publicIPAddresses: outputs.network.ReferencedPublicIpAddressResponse[];
        /**
         * The resource GUID property of the public IP prefix resource.
         */
        resourceGuid: string;
    }

    /**
     * SKU of a public IP prefix.
     */
    export interface PublicIPPrefixSkuResponse {
        /**
         * Name of a public IP prefix SKU.
         */
        name?: string;
    }

    /**
     * Radius Server Settings.
     */
    export interface RadiusServerResponse {
        /**
         * The address of this radius server.
         */
        radiusServerAddress: string;
        /**
         * The initial score assigned to this radius server.
         */
        radiusServerScore?: number;
        /**
         * The secret used for this radius server.
         */
        radiusServerSecret?: string;
    }

    /**
     * A collective group of information about the record set information.
     */
    export interface RecordSetResponse {
        /**
         * Fqdn that resolves to private endpoint ip address.
         */
        fqdn?: string;
        /**
         * The private ip address of the private endpoint.
         */
        ipAddresses?: string[];
        /**
         * The provisioning state of the recordset.
         */
        provisioningState: string;
        /**
         * Recordset name.
         */
        recordSetName?: string;
        /**
         * Resource record type.
         */
        recordType?: string;
        /**
         * Recordset time to live.
         */
        ttl?: number;
    }

    /**
     * Reference to a public IP address.
     */
    export interface ReferencedPublicIpAddressResponse {
        /**
         * The PublicIPAddress Reference.
         */
        id?: string;
    }

    /**
     * Properties of ResourceNavigationLink.
     */
    export interface ResourceNavigationLinkFormatResponse {
        /**
         * Link to the external resource.
         */
        link?: string;
        /**
         * Resource type of the linked resource.
         */
        linkedResourceType?: string;
        /**
         * The provisioning state of the resource navigation link resource.
         */
        provisioningState: string;
    }

    /**
     * ResourceNavigationLink resource.
     */
    export interface ResourceNavigationLinkResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id: string;
        /**
         * Name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Resource navigation link properties format.
         */
        properties?: outputs.network.ResourceNavigationLinkFormatResponse;
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Parameters that define the retention policy for flow log.
     */
    export interface RetentionPolicyParametersResponse {
        /**
         * Number of days to retain flow log records.
         */
        days?: number;
        /**
         * Flag to enable/disable retention.
         */
        enabled?: boolean;
    }

    /**
     * Base class for all types of Route.
     */
    export interface RouteConfigurationResponse {
    }

    /**
     * Route Filter Resource.
     */
    export interface RouteFilterPropertiesFormatResponse {
        /**
         * A collection of references to express route circuit ipv6 peerings.
         */
        ipv6Peerings: outputs.network.ExpressRouteCircuitPeeringResponse[];
        /**
         * A collection of references to express route circuit peerings.
         */
        peerings: outputs.network.ExpressRouteCircuitPeeringResponse[];
        /**
         * The provisioning state of the route filter resource.
         */
        provisioningState: string;
        /**
         * Collection of RouteFilterRules contained within a route filter.
         */
        rules?: outputs.network.RouteFilterRuleResponse[];
    }

    /**
     * Route Filter Rule Resource.
     */
    export interface RouteFilterRulePropertiesFormatResponse {
        /**
         * The access type of the rule.
         */
        access: string;
        /**
         * The collection for bgp community values to filter on. e.g. ['12076:5010','12076:5020'].
         */
        communities: string[];
        /**
         * The provisioning state of the route filter rule resource.
         */
        provisioningState: string;
        /**
         * The rule type of the rule.
         */
        routeFilterRuleType: string;
    }

    /**
     * Route Filter Rule Resource.
     */
    export interface RouteFilterRuleResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource location.
         */
        location?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the route filter rule.
         */
        properties?: outputs.network.RouteFilterRulePropertiesFormatResponse;
    }

    /**
     * Route resource.
     */
    export interface RoutePropertiesFormatResponse {
        /**
         * The destination CIDR to which the route applies.
         */
        addressPrefix?: string;
        /**
         * The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
         */
        nextHopIpAddress?: string;
        /**
         * The type of Azure hop the packet should be sent to.
         */
        nextHopType: string;
        /**
         * The provisioning state of the route resource.
         */
        provisioningState: string;
    }

    /**
     * Route resource.
     */
    export interface RouteResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the route.
         */
        properties?: outputs.network.RoutePropertiesFormatResponse;
    }

    /**
     * Route Table resource.
     */
    export interface RouteTablePropertiesFormatResponse {
        /**
         * Whether to disable the routes learned by BGP on that route table. True means disable.
         */
        disableBgpRoutePropagation?: boolean;
        /**
         * The provisioning state of the route table resource.
         */
        provisioningState: string;
        /**
         * Collection of routes contained within a route table.
         */
        routes?: outputs.network.RouteResponse[];
        /**
         * A collection of references to subnets.
         */
        subnets: outputs.network.SubnetResponse[];
    }

    /**
     * Route table resource.
     */
    export interface RouteTableResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource location.
         */
        location?: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Properties of the route table.
         */
        properties?: outputs.network.RouteTablePropertiesFormatResponse;
        /**
         * Resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Routing Configuration indicating the associated and propagated route tables for this connection.
     */
    export interface RoutingConfigurationResponse {
        /**
         * The resource id RouteTable associated with this RoutingConfiguration.
         */
        associatedRouteTable?: outputs.network.SubResourceResponse;
        /**
         * The list of RouteTables to advertise the routes to.
         */
        propagatedRouteTables?: outputs.network.PropagatedRouteTableResponse;
        /**
         * List of routes that control routing from VirtualHub into a virtual network connection.
         */
        vnetRoutes?: outputs.network.VnetRouteResponse;
    }

    /**
     * The JSON object that contains the properties required to create a routing rule.
     */
    export interface RoutingRulePropertiesResponse {
        /**
         * Protocol schemes to match for this rule
         */
        acceptedProtocols?: string[];
        /**
         * Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
         */
        enabledState?: string;
        /**
         * Frontend endpoints associated with this rule
         */
        frontendEndpoints?: outputs.network.SubResourceResponse[];
        /**
         * The route patterns of the rule.
         */
        patternsToMatch?: string[];
        /**
         * Resource status.
         */
        resourceState?: string;
        /**
         * A reference to the routing configuration.
         */
        routeConfiguration?: outputs.network.RouteConfigurationResponse;
        /**
         * A reference to a specific Rules Engine Configuration to apply to this route.
         */
        rulesEngine?: outputs.network.SubResourceResponse;
        /**
         * Defines the Web Application Firewall policy for each routing rule (if applicable)
         */
        webApplicationFirewallPolicyLink?: outputs.network.RoutingRuleUpdateParametersResponseProperties;
    }

    /**
     * A routing rule represents a specification for traffic to treat and where to send it, along with health probe information.
     */
    export interface RoutingRuleResponse {
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource name.
         */
        name?: string;
        /**
         * Properties of the Front Door Routing Rule
         */
        properties?: outputs.network.RoutingRulePropertiesResponse;
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Defines the Web Application Firewall policy for each routing rule (if applicable)
     */
    export interface RoutingRuleUpdateParametersResponseProperties {
        /**
         * Resource ID.
         */
        id?: string;
    }

    /**
     * One or more actions that will execute, modifying the request and/or response.
     */
    export interface RulesEngineActionResponse {
        /**
         * A list of header actions to apply from the request from AFD to the origin.
         */
        requestHeaderActions?: outputs.network.HeaderActionResponse[];
        /**
         * A list of header actions to apply from the response from AFD to the client.
         */
        responseHeaderActions?: outputs.network.HeaderActionResponse[];
        /**
         * Override the route configuration.
         */
        routeConfigurationOverride?: outputs.network.RouteConfigurationResponse;
    }

    /**
     * Define a match condition
     */
    export interface RulesEngineMatchConditionResponse {
        /**
         * Describes if this is negate condition or not
         */
        negateCondition?: boolean;
        /**
         * Match values to match against. The operator will apply to each value in here with OR semantics. If any of them match the variable with the given operator this match condition is considered a match.
         */
        rulesEngineMatchValue: string[];
        /**
         * Match Variable
         */
        rulesEngineMatchVariable: string;
        /**
         * Describes operator to apply to the match condition.
         */
        rulesEngineOperator: string;
        /**
         * Name of selector in RequestHeader or RequestBody to be matched
         */
        selector?: string;
        /**
         * List of transforms
         */
        transforms?: string[];
    }

    /**
     * The JSON object that contains the properties required to create a Rules Engine Configuration.
     */
    export interface RulesEnginePropertiesResponse {
        /**
         * Resource status.
         */
        resourceState?: string;
        /**
         * A list of rules that define a particular Rules Engine Configuration.
         */
        rules?: outputs.network.RulesEngineRuleResponse[];
    }

    /**
     * A rules engine configuration containing a list of rules that will run to modify the runtime behavior of the request and response.
     */
    export interface RulesEngineResponse {
        /**
         * Resource ID.
         */
        id: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Properties of the Rules Engine Configuration.
         */
        properties?: outputs.network.RulesEnginePropertiesResponse;
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Contains a list of match conditions, and an action on how to modify the request/response. If multiple rules match, the actions from one rule that conflict with a previous rule overwrite for a singular action, or append in the case of headers manipulation.
     */
    export interface RulesEngineRuleResponse {
        /**
         * Actions to perform on the request and response if all of the match conditions are met.
         */
        action: outputs.network.RulesEngineActionResponse;
        /**
         * A list of match conditions that must meet in order for the actions of this rule to run. Having no match conditions means the actions will always run.
         */
        matchConditions?: outputs.network.RulesEngineMatchConditionResponse[];
        /**
         * If this rule is a match should the rules engine continue running the remaining rules or stop. If not present, defaults to Continue.
         */
        matchProcessingBehavior?: string;
        /**
         * A name to refer to this specific rule.
         */
        name: string;
        /**
         * A priority assigned to this rule. 
         */
        priority: number;
    }

    /**
     * Properties of the Security Partner Provider.
     */
    export interface SecurityPartnerProviderPropertiesFormatResponse {
        /**
         * The connection status with the Security Partner Provider.
         */
        connectionStatus: string;
        /**
         * The provisioning state of the Security Partner Provider resource.
         */
        provisioningState: string;
        /**
         * The security provider name.
         */
        securityProviderName?: string;
        /**
         * The virtualHub to which the Security Partner Provider belongs.
         */
        virtualHub?: outputs.network.SubResourceResponse;
    }

    /**
     * Security rule resource.
     */
    export interface SecurityRulePropertiesFormatResponse {
        /**
         * The network traffic is allowed or denied.
         */
        access: string;
        /**
         * A description for this rule. Restricted to 140 chars.
         */
        description?: string;
        /**
         * The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
         */
        destinationAddressPrefix?: string;
        /**
         * The destination address prefixes. CIDR or destination IP ranges.
         */
        destinationAddressPrefixes?: string[];
        /**
         * The application security group specified as destination.
         */
        destinationApplicationSecurityGroups?: outputs.network.ApplicationSecurityGroupResponse[];
        /**
         * The destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
         */
        destinationPortRange?: string;
        /**
         * The destination port ranges.
         */
        destinationPortRanges?: string[];
        /**
         * The direction of the rule. The direction specifies if rule will be evaluated on incoming or outgoing traffic.
         */
        direction: string;
        /**
         * The priority of the rule. The value can be between 100 and 4096. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
         */
        priority?: number;
        /**
         * Network protocol this rule applies to.
         */
        protocol: string;
        /**
         * The provisioning state of the security rule resource.
         */
        provisioningState: string;
        /**
         * The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from.
         */
        sourceAddressPrefix?: string;
        /**
         * The CIDR or source IP ranges.
         */
        sourceAddressPrefixes?: string[];
        /**
         * The application security group specified as source.
         */
        sourceApplicationSecurityGroups?: outputs.network.ApplicationSecurityGroupResponse[];
        /**
         * The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
         */
        sourcePortRange?: string;
        /**
         * The source port ranges.
         */
        sourcePortRanges?: string[];
    }

    /**
     * Network security rule.
     */
    export interface SecurityRuleResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the security rule.
         */
        properties?: outputs.network.SecurityRulePropertiesFormatResponse;
    }

    /**
     * Properties of ServiceAssociationLink.
     */
    export interface ServiceAssociationLinkPropertiesFormatResponse {
        /**
         * If true, the resource can be deleted.
         */
        allowDelete?: boolean;
        /**
         * Link to the external resource.
         */
        link?: string;
        /**
         * Resource type of the linked resource.
         */
        linkedResourceType?: string;
        /**
         * A list of locations.
         */
        locations?: string[];
        /**
         * The provisioning state of the service association link resource.
         */
        provisioningState: string;
    }

    /**
     * ServiceAssociationLink resource.
     */
    export interface ServiceAssociationLinkResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Resource navigation link properties format.
         */
        properties?: outputs.network.ServiceAssociationLinkPropertiesFormatResponse;
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Properties of a service delegation.
     */
    export interface ServiceDelegationPropertiesFormatResponse {
        /**
         * The actions permitted to the service upon delegation.
         */
        actions: string[];
        /**
         * The provisioning state of the service delegation resource.
         */
        provisioningState: string;
        /**
         * The name of the service to whom the subnet should be delegated (e.g. Microsoft.Sql/servers).
         */
        serviceName?: string;
    }

    /**
     * Service Endpoint policy definition resource.
     */
    export interface ServiceEndpointPolicyDefinitionPropertiesFormatResponse {
        /**
         * A description for this rule. Restricted to 140 chars.
         */
        description?: string;
        /**
         * The provisioning state of the service endpoint policy definition resource.
         */
        provisioningState: string;
        /**
         * Service endpoint name.
         */
        service?: string;
        /**
         * A list of service resources.
         */
        serviceResources?: string[];
    }

    /**
     * Service Endpoint policy definitions.
     */
    export interface ServiceEndpointPolicyDefinitionResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the service endpoint policy definition.
         */
        properties?: outputs.network.ServiceEndpointPolicyDefinitionPropertiesFormatResponse;
    }

    /**
     * Service Endpoint Policy resource.
     */
    export interface ServiceEndpointPolicyPropertiesFormatResponse {
        /**
         * The provisioning state of the service endpoint policy resource.
         */
        provisioningState: string;
        /**
         * The resource GUID property of the service endpoint policy resource.
         */
        resourceGuid: string;
        /**
         * A collection of service endpoint policy definitions of the service endpoint policy.
         */
        serviceEndpointPolicyDefinitions?: outputs.network.ServiceEndpointPolicyDefinitionResponse[];
        /**
         * A collection of references to subnets.
         */
        subnets: outputs.network.SubnetResponse[];
    }

    /**
     * Service End point policy resource.
     */
    export interface ServiceEndpointPolicyResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource location.
         */
        location?: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Properties of the service end point policy.
         */
        properties?: outputs.network.ServiceEndpointPolicyPropertiesFormatResponse;
        /**
         * Resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * The service endpoint properties.
     */
    export interface ServiceEndpointPropertiesFormatResponse {
        /**
         * A list of locations.
         */
        locations?: string[];
        /**
         * The provisioning state of the service endpoint resource.
         */
        provisioningState: string;
        /**
         * The type of the endpoint service.
         */
        service?: string;
    }

    /**
     * List of all Static Routes.
     */
    export interface StaticRouteResponse {
        /**
         * List of all address prefixes.
         */
        addressPrefixes?: string[];
        /**
         * The name of the StaticRoute that is unique within a VnetRoute.
         */
        name?: string;
        /**
         * The ip address of the next hop.
         */
        nextHopIpAddress?: string;
    }

    /**
     * Reference to another subresource.
     */
    export interface SubResourceResponse {
        /**
         * Resource ID.
         */
        id?: string;
    }

    /**
     * Properties of the subnet.
     */
    export interface SubnetPropertiesFormatResponse {
        /**
         * The address prefix for the subnet.
         */
        addressPrefix?: string;
        /**
         * List of address prefixes for the subnet.
         */
        addressPrefixes?: string[];
        /**
         * An array of references to the delegations on the subnet.
         */
        delegations?: outputs.network.DelegationResponse[];
        /**
         * Array of IpAllocation which reference this subnet.
         */
        ipAllocations?: outputs.network.SubResourceResponse[];
        /**
         * Array of IP configuration profiles which reference this subnet.
         */
        ipConfigurationProfiles: outputs.network.IPConfigurationProfileResponse[];
        /**
         * An array of references to the network interface IP configurations using subnet.
         */
        ipConfigurations: outputs.network.IPConfigurationResponse[];
        /**
         * Nat gateway associated with this subnet.
         */
        natGateway?: outputs.network.SubResourceResponse;
        /**
         * The reference to the NetworkSecurityGroup resource.
         */
        networkSecurityGroup?: outputs.network.NetworkSecurityGroupResponse;
        /**
         * Enable or Disable apply network policies on private end point in the subnet.
         */
        privateEndpointNetworkPolicies?: string;
        /**
         * An array of references to private endpoints.
         */
        privateEndpoints: outputs.network.PrivateEndpointResponse[];
        /**
         * Enable or Disable apply network policies on private link service in the subnet.
         */
        privateLinkServiceNetworkPolicies?: string;
        /**
         * The provisioning state of the subnet resource.
         */
        provisioningState: string;
        /**
         * A read-only string identifying the intention of use for this subnet based on delegations and other user-defined properties.
         */
        purpose: string;
        /**
         * An array of references to the external resources using subnet.
         */
        resourceNavigationLinks: outputs.network.ResourceNavigationLinkResponse[];
        /**
         * The reference to the RouteTable resource.
         */
        routeTable?: outputs.network.RouteTableResponse;
        /**
         * An array of references to services injecting into this subnet.
         */
        serviceAssociationLinks: outputs.network.ServiceAssociationLinkResponse[];
        /**
         * An array of service endpoint policies.
         */
        serviceEndpointPolicies?: outputs.network.ServiceEndpointPolicyResponse[];
        /**
         * An array of service endpoints.
         */
        serviceEndpoints?: outputs.network.ServiceEndpointPropertiesFormatResponse[];
    }

    /**
     * Subnet in a virtual network resource.
     */
    export interface SubnetResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the subnet.
         */
        properties?: outputs.network.SubnetPropertiesFormatResponse;
    }

    /**
     * Parameters that define the configuration of traffic analytics.
     */
    export interface TrafficAnalyticsConfigurationPropertiesResponse {
        /**
         * Flag to enable/disable traffic analytics.
         */
        enabled?: boolean;
        /**
         * The interval in minutes which would decide how frequently TA service should do flow analytics.
         */
        trafficAnalyticsInterval?: number;
        /**
         * The resource guid of the attached workspace.
         */
        workspaceId?: string;
        /**
         * The location of the attached workspace.
         */
        workspaceRegion?: string;
        /**
         * Resource Id of the attached workspace.
         */
        workspaceResourceId?: string;
    }

    /**
     * Parameters that define the configuration of traffic analytics.
     */
    export interface TrafficAnalyticsPropertiesResponse {
        /**
         * Parameters that define the configuration of traffic analytics.
         */
        networkWatcherFlowAnalyticsConfiguration?: outputs.network.TrafficAnalyticsConfigurationPropertiesResponse;
    }

    /**
     * An traffic selector policy for a virtual network gateway connection.
     */
    export interface TrafficSelectorPolicyResponse {
        /**
         * A collection of local address spaces in CIDR format.
         */
        localAddressRanges: string[];
        /**
         * A collection of remote address spaces in CIDR format.
         */
        remoteAddressRanges: string[];
    }

    /**
     * VirtualNetworkGatewayConnection properties.
     */
    export interface TunnelConnectionHealthResponse {
        /**
         * Virtual Network Gateway connection status.
         */
        connectionStatus: string;
        /**
         * The Egress Bytes Transferred in this connection.
         */
        egressBytesTransferred: number;
        /**
         * The Ingress Bytes Transferred in this connection.
         */
        ingressBytesTransferred: number;
        /**
         * The time at which connection was established in Utc format.
         */
        lastConnectionEstablishedUtcTime: string;
        /**
         * Tunnel name.
         */
        tunnel: string;
    }

    /**
     * Network Virtual Appliance NIC properties.
     */
    export interface VirtualApplianceNicPropertiesResponse {
        /**
         * NIC name.
         */
        name: string;
        /**
         * Private IP address.
         */
        privateIpAddress: string;
        /**
         * Public IP address.
         */
        publicIpAddress: string;
    }

    /**
     * Properties of the rule group.
     */
    export interface VirtualApplianceSitePropertiesResponse {
        /**
         * Address Prefix.
         */
        addressPrefix?: string;
        /**
         * Office 365 Policy.
         */
        o365Policy?: outputs.network.Office365PolicyPropertiesResponse;
        /**
         * The provisioning state of the resource.
         */
        provisioningState: string;
    }

    /**
     * Network Virtual Appliance Sku Properties.
     */
    export interface VirtualApplianceSkuPropertiesResponse {
        /**
         * Virtual Appliance Scale Unit.
         */
        bundledScaleUnit?: string;
        /**
         * Virtual Appliance Version.
         */
        marketPlaceVersion?: string;
        /**
         * Virtual Appliance Vendor.
         */
        vendor?: string;
    }

    /**
     * Virtual Hub identifier.
     */
    export interface VirtualHubIdResponse {
        /**
         * The resource URI for the Virtual Hub where the ExpressRoute gateway is or will be deployed. The Virtual Hub resource and the ExpressRoute gateway resource reside in the same subscription.
         */
        id?: string;
    }

    /**
     * Parameters for VirtualHub.
     */
    export interface VirtualHubPropertiesResponse {
        /**
         * Address-prefix for this VirtualHub.
         */
        addressPrefix?: string;
        /**
         * The azureFirewall associated with this VirtualHub.
         */
        azureFirewall?: outputs.network.SubResourceResponse;
        /**
         * List of references to Bgp Connections.
         */
        bgpConnections: outputs.network.SubResourceResponse[];
        /**
         * The expressRouteGateway associated with this VirtualHub.
         */
        expressRouteGateway?: outputs.network.SubResourceResponse;
        /**
         * List of references to IpConfigurations.
         */
        ipConfigurations: outputs.network.SubResourceResponse[];
        /**
         * The P2SVpnGateway associated with this VirtualHub.
         */
        p2SVpnGateway?: outputs.network.SubResourceResponse;
        /**
         * The provisioning state of the virtual hub resource.
         */
        provisioningState: string;
        /**
         * The routeTable associated with this virtual hub.
         */
        routeTable?: outputs.network.VirtualHubRouteTableResponse;
        /**
         * The routing state.
         */
        routingState?: string;
        /**
         * The securityPartnerProvider associated with this VirtualHub.
         */
        securityPartnerProvider?: outputs.network.SubResourceResponse;
        /**
         * The Security Provider name.
         */
        securityProviderName?: string;
        /**
         * The sku of this VirtualHub.
         */
        sku?: string;
        /**
         * List of all virtual hub route table v2s associated with this VirtualHub.
         */
        virtualHubRouteTableV2s?: outputs.network.VirtualHubRouteTableV2Response[];
        /**
         * VirtualRouter ASN.
         */
        virtualRouterAsn?: number;
        /**
         * VirtualRouter IPs.
         */
        virtualRouterIps?: string[];
        /**
         * The VirtualWAN to which the VirtualHub belongs.
         */
        virtualWan?: outputs.network.SubResourceResponse;
        /**
         * The VpnGateway associated with this VirtualHub.
         */
        vpnGateway?: outputs.network.SubResourceResponse;
    }

    /**
     * VirtualHub route.
     */
    export interface VirtualHubRouteResponse {
        /**
         * List of all addressPrefixes.
         */
        addressPrefixes?: string[];
        /**
         * NextHop ip address.
         */
        nextHopIpAddress?: string;
    }

    /**
     * VirtualHub route table.
     */
    export interface VirtualHubRouteTableResponse {
        /**
         * List of all routes.
         */
        routes?: outputs.network.VirtualHubRouteResponse[];
    }

    /**
     * Parameters for VirtualHubRouteTableV2.
     */
    export interface VirtualHubRouteTableV2PropertiesResponse {
        /**
         * List of all connections attached to this route table v2.
         */
        attachedConnections?: string[];
        /**
         * The provisioning state of the virtual hub route table v2 resource.
         */
        provisioningState: string;
        /**
         * List of all routes.
         */
        routes?: outputs.network.VirtualHubRouteV2Response[];
    }

    /**
     * VirtualHubRouteTableV2 Resource.
     */
    export interface VirtualHubRouteTableV2Response {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the virtual hub route table v2.
         */
        properties?: outputs.network.VirtualHubRouteTableV2PropertiesResponse;
    }

    /**
     * VirtualHubRouteTableV2 route.
     */
    export interface VirtualHubRouteV2Response {
        /**
         * The type of destinations.
         */
        destinationType?: string;
        /**
         * List of all destinations.
         */
        destinations?: string[];
        /**
         * The type of next hops.
         */
        nextHopType?: string;
        /**
         * NextHops ip address.
         */
        nextHops?: string[];
    }

    /**
     * Bgp Communities sent over ExpressRoute with each route corresponding to a prefix in this VNET.
     */
    export interface VirtualNetworkBgpCommunitiesResponse {
        /**
         * The BGP community associated with the region of the virtual network.
         */
        regionalCommunity: string;
        /**
         * The BGP community associated with the virtual network.
         */
        virtualNetworkCommunity: string;
    }

    /**
     * VirtualNetworkGatewayConnection properties.
     */
    export interface VirtualNetworkGatewayConnectionPropertiesFormatResponse {
        /**
         * The authorizationKey.
         */
        authorizationKey?: string;
        /**
         * Connection protocol used for this connection.
         */
        connectionProtocol?: string;
        /**
         * Virtual Network Gateway connection status.
         */
        connectionStatus: string;
        /**
         * Gateway connection type.
         */
        connectionType: string;
        /**
         * The dead peer detection timeout of this connection in seconds.
         */
        dpdTimeoutSeconds?: number;
        /**
         * The egress bytes transferred in this connection.
         */
        egressBytesTransferred: number;
        /**
         * EnableBgp flag.
         */
        enableBgp?: boolean;
        /**
         * Bypass ExpressRoute Gateway for data forwarding.
         */
        expressRouteGatewayBypass?: boolean;
        /**
         * The ingress bytes transferred in this connection.
         */
        ingressBytesTransferred: number;
        /**
         * The IPSec Policies to be considered by this connection.
         */
        ipsecPolicies?: outputs.network.IpsecPolicyResponse[];
        /**
         * The reference to local network gateway resource.
         */
        localNetworkGateway2?: outputs.network.LocalNetworkGatewayResponse;
        /**
         * The reference to peerings resource.
         */
        peer?: outputs.network.SubResourceResponse;
        /**
         * The provisioning state of the virtual network gateway connection resource.
         */
        provisioningState: string;
        /**
         * The resource GUID property of the virtual network gateway connection resource.
         */
        resourceGuid: string;
        /**
         * The routing weight.
         */
        routingWeight?: number;
        /**
         * The IPSec shared key.
         */
        sharedKey?: string;
        /**
         * The Traffic Selector Policies to be considered by this connection.
         */
        trafficSelectorPolicies?: outputs.network.TrafficSelectorPolicyResponse[];
        /**
         * Collection of all tunnels' connection health status.
         */
        tunnelConnectionStatus: outputs.network.TunnelConnectionHealthResponse[];
        /**
         * Use private local Azure IP for the connection.
         */
        useLocalAzureIpAddress?: boolean;
        /**
         * Enable policy-based traffic selectors.
         */
        usePolicyBasedTrafficSelectors?: boolean;
        /**
         * The reference to virtual network gateway resource.
         */
        virtualNetworkGateway1: outputs.network.VirtualNetworkGatewayResponse;
        /**
         * The reference to virtual network gateway resource.
         */
        virtualNetworkGateway2?: outputs.network.VirtualNetworkGatewayResponse;
    }

    /**
     * Properties of VirtualNetworkGatewayIPConfiguration.
     */
    export interface VirtualNetworkGatewayIPConfigurationPropertiesFormatResponse {
        /**
         * Private IP Address for this gateway.
         */
        privateIPAddress: string;
        /**
         * The private IP address allocation method.
         */
        privateIPAllocationMethod?: string;
        /**
         * The provisioning state of the virtual network gateway IP configuration resource.
         */
        provisioningState: string;
        /**
         * The reference to the public IP resource.
         */
        publicIPAddress?: outputs.network.SubResourceResponse;
        /**
         * The reference to the subnet resource.
         */
        subnet?: outputs.network.SubResourceResponse;
    }

    /**
     * IP configuration for virtual network gateway.
     */
    export interface VirtualNetworkGatewayIPConfigurationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the virtual network gateway ip configuration.
         */
        properties?: outputs.network.VirtualNetworkGatewayIPConfigurationPropertiesFormatResponse;
    }

    /**
     * VirtualNetworkGateway properties.
     */
    export interface VirtualNetworkGatewayPropertiesFormatResponse {
        /**
         * ActiveActive flag.
         */
        activeActive?: boolean;
        /**
         * Virtual network gateway's BGP speaker settings.
         */
        bgpSettings?: outputs.network.BgpSettingsResponse;
        /**
         * The reference to the address space resource which represents the custom routes address space specified by the customer for virtual network gateway and VpnClient.
         */
        customRoutes?: outputs.network.AddressSpaceResponse;
        /**
         * Whether BGP is enabled for this virtual network gateway or not.
         */
        enableBgp?: boolean;
        /**
         * Whether dns forwarding is enabled or not.
         */
        enableDnsForwarding?: boolean;
        /**
         * Whether private IP needs to be enabled on this gateway for connections or not.
         */
        enablePrivateIpAddress?: boolean;
        /**
         * The reference to the LocalNetworkGateway resource which represents local network site having default routes. Assign Null value in case of removing existing default site setting.
         */
        gatewayDefaultSite?: outputs.network.SubResourceResponse;
        /**
         * The type of this virtual network gateway.
         */
        gatewayType?: string;
        /**
         * The IP address allocated by the gateway to which dns requests can be sent.
         */
        inboundDnsForwardingEndpoint: string;
        /**
         * IP configurations for virtual network gateway.
         */
        ipConfigurations?: outputs.network.VirtualNetworkGatewayIPConfigurationResponse[];
        /**
         * The provisioning state of the virtual network gateway resource.
         */
        provisioningState: string;
        /**
         * The resource GUID property of the virtual network gateway resource.
         */
        resourceGuid: string;
        /**
         * The reference to the VirtualNetworkGatewaySku resource which represents the SKU selected for Virtual network gateway.
         */
        sku?: outputs.network.VirtualNetworkGatewaySkuResponse;
        /**
         * The reference to the VpnClientConfiguration resource which represents the P2S VpnClient configurations.
         */
        vpnClientConfiguration?: outputs.network.VpnClientConfigurationResponse;
        /**
         * The generation for this VirtualNetworkGateway. Must be None if gatewayType is not VPN.
         */
        vpnGatewayGeneration?: string;
        /**
         * The type of this virtual network gateway.
         */
        vpnType?: string;
    }

    /**
     * A common class for general resource information.
     */
    export interface VirtualNetworkGatewayResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource location.
         */
        location?: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Properties of the virtual network gateway.
         */
        properties: outputs.network.VirtualNetworkGatewayPropertiesFormatResponse;
        /**
         * Resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * VirtualNetworkGatewaySku details.
     */
    export interface VirtualNetworkGatewaySkuResponse {
        /**
         * The capacity.
         */
        capacity: number;
        /**
         * Gateway SKU name.
         */
        name?: string;
        /**
         * Gateway SKU tier.
         */
        tier?: string;
    }

    /**
     * Represents the properties of the Private DNS zone.
     */
    export interface VirtualNetworkLinkPropertiesResponse {
        /**
         * The provisioning state of the resource. This is a read-only property and any attempt to set this value will be ignored.
         */
        provisioningState: string;
        /**
         * Is auto-registration of virtual machine records in the virtual network in the Private DNS zone enabled?
         */
        registrationEnabled?: boolean;
        /**
         * The reference of the virtual network.
         */
        virtualNetwork?: outputs.network.SubResourceResponse;
        /**
         * The status of the virtual network link to the Private DNS zone. Possible values are 'InProgress' and 'Done'. This is a read-only property and any attempt to set this value will be ignored.
         */
        virtualNetworkLinkState: string;
    }

    /**
     * Properties of the virtual network peering.
     */
    export interface VirtualNetworkPeeringPropertiesFormatResponse {
        /**
         * Whether the forwarded traffic from the VMs in the local virtual network will be allowed/disallowed in remote virtual network.
         */
        allowForwardedTraffic?: boolean;
        /**
         * If gateway links can be used in remote virtual networking to link to this virtual network.
         */
        allowGatewayTransit?: boolean;
        /**
         * Whether the VMs in the local virtual network space would be able to access the VMs in remote virtual network space.
         */
        allowVirtualNetworkAccess?: boolean;
        /**
         * The status of the virtual network peering.
         */
        peeringState?: string;
        /**
         * The provisioning state of the virtual network peering resource.
         */
        provisioningState: string;
        /**
         * The reference to the remote virtual network address space.
         */
        remoteAddressSpace?: outputs.network.AddressSpaceResponse;
        /**
         * The reference to the remote virtual network. The remote virtual network can be in the same or different region (preview). See here to register for the preview and learn more (https://docs.microsoft.com/en-us/azure/virtual-network/virtual-network-create-peering).
         */
        remoteVirtualNetwork?: outputs.network.SubResourceResponse;
        /**
         * If remote gateways can be used on this virtual network. If the flag is set to true, and allowGatewayTransit on remote peering is also true, virtual network will use gateways of remote virtual network for transit. Only one peering can have this flag set to true. This flag cannot be set if virtual network already has a gateway.
         */
        useRemoteGateways?: boolean;
    }

    /**
     * Peerings in a virtual network resource.
     */
    export interface VirtualNetworkPeeringResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the virtual network peering.
         */
        properties?: outputs.network.VirtualNetworkPeeringPropertiesFormatResponse;
    }

    /**
     * Properties of the virtual network.
     */
    export interface VirtualNetworkPropertiesFormatResponse {
        /**
         * The AddressSpace that contains an array of IP address ranges that can be used by subnets.
         */
        addressSpace?: outputs.network.AddressSpaceResponse;
        /**
         * Bgp Communities sent over ExpressRoute with each route corresponding to a prefix in this VNET.
         */
        bgpCommunities?: outputs.network.VirtualNetworkBgpCommunitiesResponse;
        /**
         * The DDoS protection plan associated with the virtual network.
         */
        ddosProtectionPlan?: outputs.network.SubResourceResponse;
        /**
         * The dhcpOptions that contains an array of DNS servers available to VMs deployed in the virtual network.
         */
        dhcpOptions?: outputs.network.DhcpOptionsResponse;
        /**
         * Indicates if DDoS protection is enabled for all the protected resources in the virtual network. It requires a DDoS protection plan associated with the resource.
         */
        enableDdosProtection?: boolean;
        /**
         * Indicates if VM protection is enabled for all the subnets in the virtual network.
         */
        enableVmProtection?: boolean;
        /**
         * Array of IpAllocation which reference this VNET.
         */
        ipAllocations?: outputs.network.SubResourceResponse[];
        /**
         * The provisioning state of the virtual network resource.
         */
        provisioningState: string;
        /**
         * The resourceGuid property of the Virtual Network resource.
         */
        resourceGuid: string;
        /**
         * A list of subnets in a Virtual Network.
         */
        subnets?: outputs.network.SubnetResponse[];
        /**
         * A list of peerings in a Virtual Network.
         */
        virtualNetworkPeerings?: outputs.network.VirtualNetworkPeeringResponse[];
    }

    /**
     * Virtual Network Tap properties.
     */
    export interface VirtualNetworkTapPropertiesFormatResponse {
        /**
         * The reference to the private IP address on the internal Load Balancer that will receive the tap.
         */
        destinationLoadBalancerFrontEndIPConfiguration?: outputs.network.FrontendIPConfigurationResponse;
        /**
         * The reference to the private IP Address of the collector nic that will receive the tap.
         */
        destinationNetworkInterfaceIPConfiguration?: outputs.network.NetworkInterfaceIPConfigurationResponse;
        /**
         * The VXLAN destination port that will receive the tapped traffic.
         */
        destinationPort?: number;
        /**
         * Specifies the list of resource IDs for the network interface IP configuration that needs to be tapped.
         */
        networkInterfaceTapConfigurations: outputs.network.NetworkInterfaceTapConfigurationResponse[];
        /**
         * The provisioning state of the virtual network tap resource.
         */
        provisioningState: string;
        /**
         * The resource GUID property of the virtual network tap resource.
         */
        resourceGuid: string;
    }

    /**
     * Virtual Network Tap resource.
     */
    export interface VirtualNetworkTapResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource location.
         */
        location?: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Virtual Network Tap Properties.
         */
        properties?: outputs.network.VirtualNetworkTapPropertiesFormatResponse;
        /**
         * Resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Properties of the rule group.
     */
    export interface VirtualRouterPeeringPropertiesResponse {
        /**
         * Peer ASN.
         */
        peerAsn?: number;
        /**
         * Peer IP.
         */
        peerIp?: string;
        /**
         * The provisioning state of the resource.
         */
        provisioningState: string;
    }

    /**
     * Virtual Router definition.
     */
    export interface VirtualRouterPropertiesFormatResponse {
        /**
         * The Gateway on which VirtualRouter is hosted.
         */
        hostedGateway?: outputs.network.SubResourceResponse;
        /**
         * The Subnet on which VirtualRouter is hosted.
         */
        hostedSubnet?: outputs.network.SubResourceResponse;
        /**
         * List of references to VirtualRouterPeerings.
         */
        peerings: outputs.network.SubResourceResponse[];
        /**
         * The provisioning state of the resource.
         */
        provisioningState: string;
        /**
         * VirtualRouter ASN.
         */
        virtualRouterAsn?: number;
        /**
         * VirtualRouter IPs.
         */
        virtualRouterIps?: string[];
    }

    /**
     * Parameters for VirtualWAN.
     */
    export interface VirtualWanPropertiesResponse {
        /**
         * True if branch to branch traffic is allowed.
         */
        allowBranchToBranchTraffic?: boolean;
        /**
         * True if Vnet to Vnet traffic is allowed.
         */
        allowVnetToVnetTraffic?: boolean;
        /**
         * Vpn encryption to be disabled or not.
         */
        disableVpnEncryption?: boolean;
        /**
         * The office local breakout category.
         */
        office365LocalBreakoutCategory?: string;
        /**
         * The provisioning state of the virtual WAN resource.
         */
        provisioningState: string;
        /**
         * The type of the VirtualWAN.
         */
        type?: string;
        /**
         * List of VirtualHubs in the VirtualWAN.
         */
        virtualHubs: outputs.network.SubResourceResponse[];
        /**
         * List of VpnSites in the VirtualWAN.
         */
        vpnSites: outputs.network.SubResourceResponse[];
    }

    /**
     * List of routes that control routing from VirtualHub into a virtual network connection.
     */
    export interface VnetRouteResponse {
        /**
         * List of all Static Routes.
         */
        staticRoutes?: outputs.network.StaticRouteResponse[];
    }

    /**
     * VpnClientConfiguration for P2S client.
     */
    export interface VpnClientConfigurationResponse {
        /**
         * The AADAudience property of the VirtualNetworkGateway resource for vpn client connection used for AAD authentication.
         */
        aadAudience?: string;
        /**
         * The AADIssuer property of the VirtualNetworkGateway resource for vpn client connection used for AAD authentication.
         */
        aadIssuer?: string;
        /**
         * The AADTenant property of the VirtualNetworkGateway resource for vpn client connection used for AAD authentication.
         */
        aadTenant?: string;
        /**
         * The radius server address property of the VirtualNetworkGateway resource for vpn client connection.
         */
        radiusServerAddress?: string;
        /**
         * The radius secret property of the VirtualNetworkGateway resource for vpn client connection.
         */
        radiusServerSecret?: string;
        /**
         * The radiusServers property for multiple radius server configuration.
         */
        radiusServers?: outputs.network.RadiusServerResponse[];
        /**
         * The reference to the address space resource which represents Address space for P2S VpnClient.
         */
        vpnClientAddressPool?: outputs.network.AddressSpaceResponse;
        /**
         * VpnClientIpsecPolicies for virtual network gateway P2S client.
         */
        vpnClientIpsecPolicies?: outputs.network.IpsecPolicyResponse[];
        /**
         * VpnClientProtocols for Virtual network gateway.
         */
        vpnClientProtocols?: string[];
        /**
         * VpnClientRevokedCertificate for Virtual network gateway.
         */
        vpnClientRevokedCertificates?: outputs.network.VpnClientRevokedCertificateResponse[];
        /**
         * VpnClientRootCertificate for virtual network gateway.
         */
        vpnClientRootCertificates?: outputs.network.VpnClientRootCertificateResponse[];
    }

    /**
     * VpnClientConnectionHealth properties.
     */
    export interface VpnClientConnectionHealthResponse {
        /**
         * List of allocated ip addresses to the connected p2s vpn clients.
         */
        allocatedIpAddresses?: string[];
        /**
         * Total of the Egress Bytes Transferred in this connection.
         */
        totalEgressBytesTransferred: number;
        /**
         * Total of the Ingress Bytes Transferred in this P2S Vpn connection.
         */
        totalIngressBytesTransferred: number;
        /**
         * The total of p2s vpn clients connected at this time to this P2SVpnGateway.
         */
        vpnClientConnectionsCount?: number;
    }

    /**
     * Properties of the revoked VPN client certificate of virtual network gateway.
     */
    export interface VpnClientRevokedCertificatePropertiesFormatResponse {
        /**
         * The provisioning state of the VPN client revoked certificate resource.
         */
        provisioningState: string;
        /**
         * The revoked VPN client certificate thumbprint.
         */
        thumbprint?: string;
    }

    /**
     * VPN client revoked certificate of virtual network gateway.
     */
    export interface VpnClientRevokedCertificateResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the vpn client revoked certificate.
         */
        properties?: outputs.network.VpnClientRevokedCertificatePropertiesFormatResponse;
    }

    /**
     * Properties of SSL certificates of application gateway.
     */
    export interface VpnClientRootCertificatePropertiesFormatResponse {
        /**
         * The provisioning state of the VPN client root certificate resource.
         */
        provisioningState: string;
        /**
         * The certificate public data.
         */
        publicCertData: string;
    }

    /**
     * VPN client root certificate of virtual network gateway.
     */
    export interface VpnClientRootCertificateResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the vpn client root certificate.
         */
        properties: outputs.network.VpnClientRootCertificatePropertiesFormatResponse;
    }

    /**
     * Parameters for VpnConnection.
     */
    export interface VpnConnectionPropertiesResponse {
        /**
         * Expected bandwidth in MBPS.
         */
        connectionBandwidth?: number;
        /**
         * The connection status.
         */
        connectionStatus?: string;
        /**
         * The dead peer detection timeout for a vpn connection in seconds.
         */
        dpdTimeoutSeconds?: number;
        /**
         * Egress bytes transferred.
         */
        egressBytesTransferred: number;
        /**
         * EnableBgp flag.
         */
        enableBgp?: boolean;
        /**
         * Enable internet security.
         */
        enableInternetSecurity?: boolean;
        /**
         * EnableBgp flag.
         */
        enableRateLimiting?: boolean;
        /**
         * Ingress bytes transferred.
         */
        ingressBytesTransferred: number;
        /**
         * The IPSec Policies to be considered by this connection.
         */
        ipsecPolicies?: outputs.network.IpsecPolicyResponse[];
        /**
         * The provisioning state of the VPN connection resource.
         */
        provisioningState: string;
        /**
         * Id of the connected vpn site.
         */
        remoteVpnSite?: outputs.network.SubResourceResponse;
        /**
         * The Routing Configuration indicating the associated and propagated route tables on this connection.
         */
        routingConfiguration?: outputs.network.RoutingConfigurationResponse;
        /**
         * Routing weight for vpn connection.
         */
        routingWeight?: number;
        /**
         * SharedKey for the vpn connection.
         */
        sharedKey?: string;
        /**
         * Use local azure ip to initiate connection.
         */
        useLocalAzureIpAddress?: boolean;
        /**
         * Enable policy-based traffic selectors.
         */
        usePolicyBasedTrafficSelectors?: boolean;
        /**
         * Connection protocol used for this connection.
         */
        vpnConnectionProtocolType?: string;
        /**
         * List of all vpn site link connections to the gateway.
         */
        vpnLinkConnections?: outputs.network.VpnSiteLinkConnectionResponse[];
    }

    /**
     * VpnConnection Resource.
     */
    export interface VpnConnectionResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the VPN connection.
         */
        properties?: outputs.network.VpnConnectionPropertiesResponse;
    }

    /**
     * Parameters for VpnGateway.
     */
    export interface VpnGatewayPropertiesResponse {
        /**
         * Local network gateway's BGP speaker settings.
         */
        bgpSettings?: outputs.network.BgpSettingsResponse;
        /**
         * List of all vpn connections to the gateway.
         */
        connections?: outputs.network.VpnConnectionResponse[];
        /**
         * The provisioning state of the VPN gateway resource.
         */
        provisioningState: string;
        /**
         * The VirtualHub to which the gateway belongs.
         */
        virtualHub?: outputs.network.SubResourceResponse;
        /**
         * The scale unit for this vpn gateway.
         */
        vpnGatewayScaleUnit?: number;
    }

    /**
     * BGP settings details for a link.
     */
    export interface VpnLinkBgpSettingsResponse {
        /**
         * The BGP speaker's ASN.
         */
        asn?: number;
        /**
         * The BGP peering address and BGP identifier of this BGP speaker.
         */
        bgpPeeringAddress?: string;
    }

    /**
     * List of properties of a link provider.
     */
    export interface VpnLinkProviderPropertiesResponse {
        /**
         * Name of the link provider.
         */
        linkProviderName?: string;
        /**
         * Link speed.
         */
        linkSpeedInMbps?: number;
    }

    /**
     * Properties of the Radius client root certificate of VpnServerConfiguration.
     */
    export interface VpnServerConfigRadiusClientRootCertificateResponse {
        /**
         * The certificate name.
         */
        name?: string;
        /**
         * The Radius client root certificate thumbprint.
         */
        thumbprint?: string;
    }

    /**
     * Properties of Radius Server root certificate of VpnServerConfiguration.
     */
    export interface VpnServerConfigRadiusServerRootCertificateResponse {
        /**
         * The certificate name.
         */
        name?: string;
        /**
         * The certificate public data.
         */
        publicCertData?: string;
    }

    /**
     * Properties of the revoked VPN client certificate of VpnServerConfiguration.
     */
    export interface VpnServerConfigVpnClientRevokedCertificateResponse {
        /**
         * The certificate name.
         */
        name?: string;
        /**
         * The revoked VPN client certificate thumbprint.
         */
        thumbprint?: string;
    }

    /**
     * Properties of VPN client root certificate of VpnServerConfiguration.
     */
    export interface VpnServerConfigVpnClientRootCertificateResponse {
        /**
         * The certificate name.
         */
        name?: string;
        /**
         * The certificate public data.
         */
        publicCertData?: string;
    }

    /**
     * Parameters for VpnServerConfiguration.
     */
    export interface VpnServerConfigurationPropertiesResponse {
        /**
         * The set of aad vpn authentication parameters.
         */
        aadAuthenticationParameters?: outputs.network.AadAuthenticationParametersResponse;
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * The name of the VpnServerConfiguration that is unique within a resource group.
         */
        name?: string;
        /**
         * List of references to P2SVpnGateways.
         */
        p2SVpnGateways: outputs.network.P2SVpnGatewayResponse[];
        /**
         * The provisioning state of the VpnServerConfiguration resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
         */
        provisioningState: string;
        /**
         * Radius client root certificate of VpnServerConfiguration.
         */
        radiusClientRootCertificates?: outputs.network.VpnServerConfigRadiusClientRootCertificateResponse[];
        /**
         * The radius server address property of the VpnServerConfiguration resource for point to site client connection.
         */
        radiusServerAddress?: string;
        /**
         * Radius Server root certificate of VpnServerConfiguration.
         */
        radiusServerRootCertificates?: outputs.network.VpnServerConfigRadiusServerRootCertificateResponse[];
        /**
         * The radius secret property of the VpnServerConfiguration resource for point to site client connection.
         */
        radiusServerSecret?: string;
        /**
         * Multiple Radius Server configuration for VpnServerConfiguration.
         */
        radiusServers?: outputs.network.RadiusServerResponse[];
        /**
         * VPN authentication types for the VpnServerConfiguration.
         */
        vpnAuthenticationTypes?: string[];
        /**
         * VpnClientIpsecPolicies for VpnServerConfiguration.
         */
        vpnClientIpsecPolicies?: outputs.network.IpsecPolicyResponse[];
        /**
         * VPN client revoked certificate of VpnServerConfiguration.
         */
        vpnClientRevokedCertificates?: outputs.network.VpnServerConfigVpnClientRevokedCertificateResponse[];
        /**
         * VPN client root certificate of VpnServerConfiguration.
         */
        vpnClientRootCertificates?: outputs.network.VpnServerConfigVpnClientRootCertificateResponse[];
        /**
         * VPN protocols for the VpnServerConfiguration.
         */
        vpnProtocols?: string[];
    }

    /**
     * Parameters for VpnConnection.
     */
    export interface VpnSiteLinkConnectionPropertiesResponse {
        /**
         * Expected bandwidth in MBPS.
         */
        connectionBandwidth?: number;
        /**
         * The connection status.
         */
        connectionStatus?: string;
        /**
         * Egress bytes transferred.
         */
        egressBytesTransferred: number;
        /**
         * EnableBgp flag.
         */
        enableBgp?: boolean;
        /**
         * EnableBgp flag.
         */
        enableRateLimiting?: boolean;
        /**
         * Ingress bytes transferred.
         */
        ingressBytesTransferred: number;
        /**
         * The IPSec Policies to be considered by this connection.
         */
        ipsecPolicies?: outputs.network.IpsecPolicyResponse[];
        /**
         * The provisioning state of the VPN site link connection resource.
         */
        provisioningState: string;
        /**
         * Routing weight for vpn connection.
         */
        routingWeight?: number;
        /**
         * SharedKey for the vpn connection.
         */
        sharedKey?: string;
        /**
         * Use local azure ip to initiate connection.
         */
        useLocalAzureIpAddress?: boolean;
        /**
         * Enable policy-based traffic selectors.
         */
        usePolicyBasedTrafficSelectors?: boolean;
        /**
         * Connection protocol used for this connection.
         */
        vpnConnectionProtocolType?: string;
        /**
         * Id of the connected vpn site link.
         */
        vpnSiteLink?: outputs.network.SubResourceResponse;
    }

    /**
     * VpnSiteLinkConnection Resource.
     */
    export interface VpnSiteLinkConnectionResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the VPN site link connection.
         */
        properties?: outputs.network.VpnSiteLinkConnectionPropertiesResponse;
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Parameters for VpnSite.
     */
    export interface VpnSiteLinkPropertiesResponse {
        /**
         * The set of bgp properties.
         */
        bgpProperties?: outputs.network.VpnLinkBgpSettingsResponse;
        /**
         * FQDN of vpn-site-link.
         */
        fqdn?: string;
        /**
         * The ip-address for the vpn-site-link.
         */
        ipAddress?: string;
        /**
         * The link provider properties.
         */
        linkProperties?: outputs.network.VpnLinkProviderPropertiesResponse;
        /**
         * The provisioning state of the VPN site link resource.
         */
        provisioningState: string;
    }

    /**
     * VpnSiteLink Resource.
     */
    export interface VpnSiteLinkResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the VPN site link.
         */
        properties?: outputs.network.VpnSiteLinkPropertiesResponse;
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Parameters for VpnSite.
     */
    export interface VpnSitePropertiesResponse {
        /**
         * The AddressSpace that contains an array of IP address ranges.
         */
        addressSpace?: outputs.network.AddressSpaceResponse;
        /**
         * The set of bgp properties.
         */
        bgpProperties?: outputs.network.BgpSettingsResponse;
        /**
         * The device properties.
         */
        deviceProperties?: outputs.network.DevicePropertiesResponse;
        /**
         * The ip-address for the vpn-site.
         */
        ipAddress?: string;
        /**
         * IsSecuritySite flag.
         */
        isSecuritySite?: boolean;
        /**
         * The provisioning state of the VPN site resource.
         */
        provisioningState: string;
        /**
         * The key for vpn-site that can be used for connections.
         */
        siteKey?: string;
        /**
         * The VirtualWAN to which the vpnSite belongs.
         */
        virtualWan?: outputs.network.SubResourceResponse;
        /**
         * List of all vpn site links.
         */
        vpnSiteLinks?: outputs.network.VpnSiteLinkResponse[];
    }

    /**
     * Defines contents of a web application rule.
     */
    export interface WebApplicationFirewallCustomRuleResponse {
        /**
         * Type of Actions.
         */
        action: string;
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * List of match conditions.
         */
        matchConditions: outputs.network.MatchConditionResponse[];
        /**
         * The name of the resource that is unique within a policy. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Priority of the rule. Rules with a lower value will be evaluated before rules with a higher value.
         */
        priority: number;
        /**
         * The rule type.
         */
        ruleType: string;
    }

    /**
     * Defines web application firewall policy properties.
     */
    export interface WebApplicationFirewallPolicyPropertiesFormatResponse {
        /**
         * A collection of references to application gateways.
         */
        applicationGateways: outputs.network.ApplicationGatewayResponse[];
        /**
         * The custom rules inside the policy.
         */
        customRules?: outputs.network.WebApplicationFirewallCustomRuleResponse[];
        /**
         * A collection of references to application gateway http listeners.
         */
        httpListeners: outputs.network.SubResourceResponse[];
        /**
         * Describes the managedRules structure.
         */
        managedRules: outputs.network.ManagedRulesDefinitionResponse;
        /**
         * A collection of references to application gateway path rules.
         */
        pathBasedRules: outputs.network.SubResourceResponse[];
        /**
         * The PolicySettings for policy.
         */
        policySettings?: outputs.network.PolicySettingsResponse;
        /**
         * The provisioning state of the web application firewall policy resource.
         */
        provisioningState: string;
        /**
         * Resource status of the policy.
         */
        resourceState: string;
    }

    /**
     * Represents the properties of the zone.
     */
    export interface ZonePropertiesResponse {
        /**
         * The maximum number of record sets that can be created in this DNS zone.  This is a read-only property and any attempt to set this value will be ignored.
         */
        maxNumberOfRecordSets: number;
        /**
         * The name servers for this DNS zone. This is a read-only property and any attempt to set this value will be ignored.
         */
        nameServers: string[];
        /**
         * The current number of record sets in this DNS zone.  This is a read-only property and any attempt to set this value will be ignored.
         */
        numberOfRecordSets: number;
        /**
         * A list of references to virtual networks that register hostnames in this DNS zone. This is a only when ZoneType is Private.
         */
        registrationVirtualNetworks?: outputs.network.SubResourceResponse[];
        /**
         * A list of references to virtual networks that resolve records in this DNS zone. This is a only when ZoneType is Private.
         */
        resolutionVirtualNetworks?: outputs.network.SubResourceResponse[];
        /**
         * The type of this DNS zone (Public or Private).
         */
        zoneType?: string;
    }
}

export namespace notificationhubs {
    /**
     * Description of a NotificationHub AdmCredential.
     */
    export interface AdmCredentialPropertiesResponse {
        /**
         * The URL of the authorization token.
         */
        authTokenUrl?: string;
        /**
         * The client identifier.
         */
        clientId?: string;
        /**
         * The credential secret access key.
         */
        clientSecret?: string;
    }

    /**
     * Description of a NotificationHub AdmCredential.
     */
    export interface AdmCredentialResponse {
        /**
         * Properties of NotificationHub AdmCredential.
         */
        properties?: outputs.notificationhubs.AdmCredentialPropertiesResponse;
    }

    /**
     * Description of a NotificationHub ApnsCredential. Note that there is no explicit switch between Certificate and Token Authentication Modes. The mode is determined based on the properties passed in.
     */
    export interface ApnsCredentialPropertiesResponse {
        /**
         * The APNS certificate. Specify if using Certificate Authentication Mode.
         */
        apnsCertificate?: string;
        /**
         * The issuer (iss) registered claim key. The value is a 10-character TeamId, obtained from your developer account. Specify if using Token Authentication Mode.
         */
        appId?: string;
        /**
         * The name of the application or BundleId. Specify if using Token Authentication Mode.
         */
        appName?: string;
        /**
         * The APNS certificate password if it exists.
         */
        certificateKey?: string;
        /**
         * The APNS endpoint of this credential. If using Certificate Authentication Mode and Sandbox specify 'gateway.sandbox.push.apple.com'. If using Certificate Authentication Mode and Production specify 'gateway.push.apple.com'. If using Token Authentication Mode and Sandbox specify 'https://api.development.push.apple.com:443/3/device'. If using Token Authentication Mode and Production specify 'https://api.push.apple.com:443/3/device'.
         */
        endpoint?: string;
        /**
         * A 10-character key identifier (kid) key, obtained from your developer account. Specify if using Token Authentication Mode.
         */
        keyId?: string;
        /**
         * The APNS certificate thumbprint. Specify if using Certificate Authentication Mode.
         */
        thumbprint?: string;
        /**
         * Provider Authentication Token, obtained through your developer account. Specify if using Token Authentication Mode.
         */
        token?: string;
    }

    /**
     * Description of a NotificationHub ApnsCredential.
     */
    export interface ApnsCredentialResponse {
        /**
         * Properties of NotificationHub ApnsCredential.
         */
        properties?: outputs.notificationhubs.ApnsCredentialPropertiesResponse;
    }

    /**
     * Description of a NotificationHub BaiduCredential.
     */
    export interface BaiduCredentialPropertiesResponse {
        /**
         * Baidu Api Key.
         */
        baiduApiKey?: string;
        /**
         * Baidu Endpoint.
         */
        baiduEndPoint?: string;
        /**
         * Baidu Secret Key
         */
        baiduSecretKey?: string;
    }

    /**
     * Description of a NotificationHub BaiduCredential.
     */
    export interface BaiduCredentialResponse {
        /**
         * Properties of NotificationHub BaiduCredential.
         */
        properties?: outputs.notificationhubs.BaiduCredentialPropertiesResponse;
    }

    /**
     * Description of a NotificationHub GcmCredential.
     */
    export interface GcmCredentialPropertiesResponse {
        /**
         * The FCM legacy endpoint. Default value is 'https://fcm.googleapis.com/fcm/send'
         */
        gcmEndpoint?: string;
        /**
         * The Google API key.
         */
        googleApiKey?: string;
    }

    /**
     * Description of a NotificationHub GcmCredential.
     */
    export interface GcmCredentialResponse {
        /**
         * Properties of NotificationHub GcmCredential.
         */
        properties?: outputs.notificationhubs.GcmCredentialPropertiesResponse;
    }

    /**
     * Description of a NotificationHub MpnsCredential.
     */
    export interface MpnsCredentialPropertiesResponse {
        /**
         * The certificate key for this credential.
         */
        certificateKey?: string;
        /**
         * The MPNS certificate.
         */
        mpnsCertificate?: string;
        /**
         * The MPNS certificate Thumbprint
         */
        thumbprint?: string;
    }

    /**
     * Description of a NotificationHub MpnsCredential.
     */
    export interface MpnsCredentialResponse {
        /**
         * Properties of NotificationHub MpnsCredential.
         */
        properties?: outputs.notificationhubs.MpnsCredentialPropertiesResponse;
    }

    /**
     * Namespace properties.
     */
    export interface NamespacePropertiesResponse {
        /**
         * The time the namespace was created.
         */
        createdAt?: string;
        /**
         * Whether or not the namespace is set as Critical.
         */
        critical?: boolean;
        /**
         * Data center for the namespace
         */
        dataCenter?: string;
        /**
         * Whether or not the namespace is currently enabled.
         */
        enabled?: boolean;
        /**
         * Identifier for Azure Insights metrics
         */
        metricId: string;
        /**
         * The name of the namespace.
         */
        name?: string;
        /**
         * The namespace type.
         */
        namespaceType?: string;
        /**
         * Provisioning state of the Namespace.
         */
        provisioningState?: string;
        /**
         * Specifies the targeted region in which the namespace should be created. It can be any of the following values: Australia East, Australia Southeast, Central US, East US, East US 2, West US, North Central US, South Central US, East Asia, Southeast Asia, Brazil South, Japan East, Japan West, North Europe, West Europe
         */
        region?: string;
        /**
         * ScaleUnit where the namespace gets created
         */
        scaleUnit?: string;
        /**
         * Endpoint you can use to perform NotificationHub operations.
         */
        serviceBusEndpoint?: string;
        /**
         * Status of the namespace. It can be any of these values:1 = Created/Active2 = Creating3 = Suspended4 = Deleting
         */
        status?: string;
        /**
         * The Id of the Azure subscription associated with the namespace.
         */
        subscriptionId?: string;
        /**
         * The time the namespace was updated.
         */
        updatedAt?: string;
    }

    /**
     * NotificationHub properties.
     */
    export interface NotificationHubPropertiesResponse {
        /**
         * The AdmCredential of the created NotificationHub
         */
        admCredential?: outputs.notificationhubs.AdmCredentialResponse;
        /**
         * The ApnsCredential of the created NotificationHub
         */
        apnsCredential?: outputs.notificationhubs.ApnsCredentialResponse;
        /**
         * The AuthorizationRules of the created NotificationHub
         */
        authorizationRules?: outputs.notificationhubs.SharedAccessAuthorizationRulePropertiesResponse[];
        /**
         * The BaiduCredential of the created NotificationHub
         */
        baiduCredential?: outputs.notificationhubs.BaiduCredentialResponse;
        /**
         * The GcmCredential of the created NotificationHub
         */
        gcmCredential?: outputs.notificationhubs.GcmCredentialResponse;
        /**
         * The MpnsCredential of the created NotificationHub
         */
        mpnsCredential?: outputs.notificationhubs.MpnsCredentialResponse;
        /**
         * The NotificationHub name.
         */
        name?: string;
        /**
         * The RegistrationTtl of the created NotificationHub
         */
        registrationTtl?: string;
        /**
         * The WnsCredential of the created NotificationHub
         */
        wnsCredential?: outputs.notificationhubs.WnsCredentialResponse;
    }

    /**
     * SharedAccessAuthorizationRule properties.
     */
    export interface SharedAccessAuthorizationRulePropertiesResponse {
        /**
         * A string that describes the claim type
         */
        claimType: string;
        /**
         * A string that describes the claim value
         */
        claimValue: string;
        /**
         * The created time for this rule
         */
        createdTime: string;
        /**
         * A string that describes the authorization rule.
         */
        keyName: string;
        /**
         * The last modified time for this rule
         */
        modifiedTime: string;
        /**
         * A base64-encoded 256-bit primary key for signing and validating the SAS token.
         */
        primaryKey: string;
        /**
         * The revision number for the rule
         */
        revision: number;
        /**
         * The rights associated with the rule.
         */
        rights?: string[];
        /**
         * A base64-encoded 256-bit primary key for signing and validating the SAS token.
         */
        secondaryKey: string;
    }

    /**
     * Description of a Namespace AuthorizationRules.
     */
    export interface SharedAccessAuthorizationRuleResourceResponse {
        /**
         * Resource Id
         */
        id: string;
        /**
         * Resource location
         */
        location?: string;
        /**
         * Resource name
         */
        name: string;
        /**
         * Properties of the Namespace AuthorizationRule.
         */
        properties?: outputs.notificationhubs.SharedAccessAuthorizationRulePropertiesResponse;
        /**
         * The sku of the created namespace
         */
        sku?: outputs.notificationhubs.SkuResponse;
        /**
         * Resource tags
         */
        tags?: {[key: string]: string};
        /**
         * Resource type
         */
        type: string;
    }

    /**
     * The Sku description for a namespace
     */
    export interface SkuResponse {
        /**
         * The capacity of the resource
         */
        capacity?: number;
        /**
         * The Sku Family
         */
        family?: string;
        /**
         * Name of the notification hub sku
         */
        name: string;
        /**
         * The Sku size
         */
        size?: string;
        /**
         * The tier of particular sku
         */
        tier?: string;
    }

    /**
     * Description of a NotificationHub WnsCredential.
     */
    export interface WnsCredentialPropertiesResponse {
        /**
         * The package ID for this credential.
         */
        packageSid?: string;
        /**
         * The secret key.
         */
        secretKey?: string;
        /**
         * The Windows Live endpoint.
         */
        windowsLiveEndpoint?: string;
    }

    /**
     * Description of a NotificationHub WnsCredential.
     */
    export interface WnsCredentialResponse {
        /**
         * Properties of NotificationHub WnsCredential.
         */
        properties?: outputs.notificationhubs.WnsCredentialPropertiesResponse;
    }
}

export namespace offazure {
    /**
     * Class for site agent properties.
     */
    export interface SiteAgentPropertiesResponse {
        /**
         * ID of the agent.
         */
        id: string;
        /**
         * Key vault ARM Id.
         */
        keyVaultId?: string;
        /**
         * Key vault URI.
         */
        keyVaultUri?: string;
        /**
         * Last heartbeat time of the agent in UTC.
         */
        lastHeartBeatUtc: string;
        /**
         * Version of the agent.
         */
        version: string;
    }

    /**
     * Class for site properties.
     */
    export interface SitePropertiesResponse {
        /**
         * On-premises agent details.
         */
        agentDetails?: outputs.offazure.SiteAgentPropertiesResponse;
        /**
         * Appliance Name.
         */
        applianceName?: string;
        /**
         * ARM ID of migration hub solution for SDS.
         */
        discoverySolutionId?: string;
        /**
         * Service endpoint.
         */
        serviceEndpoint: string;
        /**
         * Service principal identity details used by agent for communication to the service.
         */
        servicePrincipalIdentityDetails?: outputs.offazure.SiteSpnPropertiesResponse;
    }

    /**
     * Class for site properties.
     */
    export interface SiteSpnPropertiesResponse {
        /**
         * AAD Authority URL which was used to request the token for the service principal.
         */
        aadAuthority?: string;
        /**
         * Application/client Id for the service principal with which the on-premise management/data plane components would communicate with our Azure services.
         */
        applicationId?: string;
        /**
         * Intended audience for the service principal.
         */
        audience?: string;
        /**
         * Object Id of the service principal with which the on-premise management/data plane components would communicate with our Azure services.
         */
        objectId?: string;
        /**
         * Raw certificate data for building certificate expiry flows.
         */
        rawCertData?: string;
        /**
         * Tenant Id for the service principal with which the on-premise management/data plane components would communicate with our Azure services.
         */
        tenantId?: string;
    }

}

export namespace operationalinsights {
    /**
     * Action property bag.
     */
    export interface ActionResponsePropertiesResponse {
        /**
         * Logic App Resource Id, /subscriptions/{my-subscription}/resourceGroups/{my-resource-group}/providers/Microsoft.Logic/workflows/{my-workflow-id}.
         */
        logicAppResourceId: string;
        /**
         * The name of the logic app's workflow.
         */
        workflowId?: string;
    }

    /**
     * Describes bookmark properties
     */
    export interface BookmarkPropertiesResponse {
        /**
         * The time the bookmark was created
         */
        created?: string;
        /**
         * Describes a user that created the bookmark
         */
        createdBy?: outputs.operationalinsights.UserInfoResponse;
        /**
         * The display name of the bookmark
         */
        displayName: string;
        /**
         * Describes an incident that relates to bookmark
         */
        incidentInfo?: outputs.operationalinsights.IncidentInfoResponse;
        /**
         * List of labels relevant to this bookmark
         */
        labels?: string[];
        /**
         * The notes of the bookmark
         */
        notes?: string;
        /**
         * The query of the bookmark.
         */
        query: string;
        /**
         * The query result of the bookmark.
         */
        queryResult?: string;
        /**
         * The last time the bookmark was updated
         */
        updated?: string;
        /**
         * Describes a user that updated the bookmark
         */
        updatedBy?: outputs.operationalinsights.UserInfoResponse;
    }

    /**
     * Incident additional data property bag.
     */
    export interface IncidentAdditionalDataResponse {
        /**
         * List of product names of alerts in the incident
         */
        alertProductNames: string[];
        /**
         * The number of alerts in the incident
         */
        alertsCount: number;
        /**
         * The number of bookmarks in the incident
         */
        bookmarksCount: number;
        /**
         * The number of comments in the incident
         */
        commentsCount: number;
        /**
         * The tactics associated with incident
         */
        tactics: string[];
    }

    /**
     * Describes related incident information for the bookmark
     */
    export interface IncidentInfoResponse {
        /**
         * Incident Id
         */
        incidentId: string;
        /**
         * Relation Name
         */
        relationName: string;
        /**
         * The severity of the incident
         */
        severity: string;
        /**
         * The title of the incident
         */
        title: string;
    }

    /**
     * Represents an incident label
     */
    export interface IncidentLabelResponse {
        /**
         * The name of the label
         */
        labelName: string;
        /**
         * The type of the label
         */
        labelType: string;
    }

    /**
     * Information on the user an incident is assigned to
     */
    export interface IncidentOwnerInfoResponse {
        /**
         * The name of the user the incident is assigned to.
         */
        assignedTo?: string;
        /**
         * The email of the user the incident is assigned to.
         */
        email?: string;
        /**
         * The object id of the user the incident is assigned to.
         */
        objectId?: string;
        /**
         * The user principal name of the user the incident is assigned to.
         */
        userPrincipalName?: string;
    }

    /**
     * Describes incident properties
     */
    export interface IncidentPropertiesResponse {
        /**
         * Additional data on the incident
         */
        additionalData: outputs.operationalinsights.IncidentAdditionalDataResponse;
        /**
         * The reason the incident was closed
         */
        classification?: string;
        /**
         * Describes the reason the incident was closed
         */
        classificationComment?: string;
        /**
         * The classification reason the incident was closed with
         */
        classificationReason?: string;
        /**
         * The time the incident was created
         */
        createdTimeUtc: string;
        /**
         * The description of the incident
         */
        description?: string;
        /**
         * The time of the first activity in the incident
         */
        firstActivityTimeUtc?: string;
        /**
         * A sequential number
         */
        incidentNumber: number;
        /**
         * The deep-link url to the incident in Azure portal
         */
        incidentUrl: string;
        /**
         * List of labels relevant to this incident
         */
        labels?: outputs.operationalinsights.IncidentLabelResponse[];
        /**
         * The time of the last activity in the incident
         */
        lastActivityTimeUtc?: string;
        /**
         * The last time the incident was updated
         */
        lastModifiedTimeUtc: string;
        /**
         * Describes a user that the incident is assigned to
         */
        owner?: outputs.operationalinsights.IncidentOwnerInfoResponse;
        /**
         * List of resource ids of Analytic rules related to the incident
         */
        relatedAnalyticRuleIds: string[];
        /**
         * The severity of the incident
         */
        severity: string;
        /**
         * The status of the incident
         */
        status: string;
        /**
         * The title of the incident
         */
        title: string;
    }

    /**
     * Value object for saved search results.
     */
    export interface SavedSearchPropertiesResponse {
        /**
         * The category of the saved search. This helps the user to find a saved search faster. 
         */
        category: string;
        /**
         * Saved search display name.
         */
        displayName: string;
        /**
         * The query expression for the saved search. Please see https://docs.microsoft.com/en-us/azure/log-analytics/log-analytics-search-reference for reference.
         */
        query: string;
        /**
         * The tags attached to the saved search.
         */
        tags?: outputs.operationalinsights.TagResponse[];
        /**
         * The version number of the query language. The current version is 2 and is the default.
         */
        version?: number;
    }

    /**
     * Describes a storage account connection.
     */
    export interface StorageAccountResponse {
        /**
         * The Azure Resource Manager ID of the storage account resource.
         */
        id: string;
        /**
         * The storage account key.
         */
        key: string;
    }

    /**
     * Storage insight properties.
     */
    export interface StorageInsightPropertiesResponse {
        /**
         * The names of the blob containers that the workspace should read
         */
        containers?: string[];
        /**
         * The status of the storage insight
         */
        status: outputs.operationalinsights.StorageInsightStatusResponse;
        /**
         * The storage account connection details
         */
        storageAccount: outputs.operationalinsights.StorageAccountResponse;
        /**
         * The names of the Azure tables that the workspace should read
         */
        tables?: string[];
    }

    /**
     * The status of the storage insight.
     */
    export interface StorageInsightStatusResponse {
        /**
         * Description of the state of the storage insight.
         */
        description?: string;
        /**
         * The state of the storage insight connection to the workspace
         */
        state: string;
    }

    /**
     * A tag of a saved search.
     */
    export interface TagResponse {
        /**
         * The tag name.
         */
        name: string;
        /**
         * The tag value.
         */
        value: string;
    }

    /**
     * User information that made some action
     */
    export interface UserInfoResponse {
        /**
         * The email of the user.
         */
        email: string;
        /**
         * The name of the user.
         */
        name: string;
        /**
         * The object id of the user.
         */
        objectId: string;
    }

}

export namespace peering {
    /**
     * The properties that define a BGP session.
     */
    export interface BgpSessionResponse {
        /**
         * The maximum number of prefixes advertised over the IPv4 session.
         */
        maxPrefixesAdvertisedV4?: number;
        /**
         * The maximum number of prefixes advertised over the IPv6 session.
         */
        maxPrefixesAdvertisedV6?: number;
        /**
         * The MD5 authentication key of the session.
         */
        md5AuthenticationKey?: string;
        /**
         * The IPv4 session address on Microsoft's end.
         */
        microsoftSessionIPv4Address?: string;
        /**
         * The IPv6 session address on Microsoft's end.
         */
        microsoftSessionIPv6Address?: string;
        /**
         * The IPv4 session address on peer's end.
         */
        peerSessionIPv4Address?: string;
        /**
         * The IPv6 session address on peer's end.
         */
        peerSessionIPv6Address?: string;
        /**
         * The IPv4 prefix that contains both ends' IPv4 addresses.
         */
        sessionPrefixV4?: string;
        /**
         * The IPv6 prefix that contains both ends' IPv6 addresses.
         */
        sessionPrefixV6?: string;
        /**
         * The state of the IPv4 session.
         */
        sessionStateV4: string;
        /**
         * The state of the IPv6 session.
         */
        sessionStateV6: string;
    }

    /**
     * The properties that define a direct connection.
     */
    export interface DirectConnectionResponse {
        /**
         * The bandwidth of the connection.
         */
        bandwidthInMbps?: number;
        /**
         * The BGP session associated with the connection.
         */
        bgpSession?: outputs.peering.BgpSessionResponse;
        /**
         * The unique identifier (GUID) for the connection.
         */
        connectionIdentifier?: string;
        /**
         * The state of the connection.
         */
        connectionState: string;
        /**
         * The error message related to the connection state, if any.
         */
        errorMessage: string;
        /**
         * The PeeringDB.com ID of the facility at which the connection has to be set up.
         */
        peeringDBFacilityId?: number;
        /**
         * The bandwidth that is actually provisioned.
         */
        provisionedBandwidthInMbps: number;
        /**
         * The field indicating if Microsoft provides session ip addresses.
         */
        sessionAddressProvider?: string;
        /**
         * The flag that indicates whether or not the connection is used for peering service.
         */
        useForPeeringService?: boolean;
    }

    /**
     * The properties that define an exchange connection.
     */
    export interface ExchangeConnectionResponse {
        /**
         * The BGP session associated with the connection.
         */
        bgpSession?: outputs.peering.BgpSessionResponse;
        /**
         * The unique identifier (GUID) for the connection.
         */
        connectionIdentifier?: string;
        /**
         * The state of the connection.
         */
        connectionState: string;
        /**
         * The error message related to the connection state, if any.
         */
        errorMessage: string;
        /**
         * The PeeringDB.com ID of the facility at which the connection has to be set up.
         */
        peeringDBFacilityId?: number;
    }

    /**
     * The properties that define a direct peering.
     */
    export interface PeeringPropertiesDirectResponse {
        /**
         * The set of connections that constitute a direct peering.
         */
        connections?: outputs.peering.DirectConnectionResponse[];
        /**
         * The type of direct peering.
         */
        directPeeringType?: string;
        /**
         * The reference of the peer ASN.
         */
        peerAsn?: outputs.peering.SubResourceResponse;
        /**
         * The flag that indicates whether or not the peering is used for peering service.
         */
        useForPeeringService: boolean;
    }

    /**
     * The properties that define an exchange peering.
     */
    export interface PeeringPropertiesExchangeResponse {
        /**
         * The set of connections that constitute an exchange peering.
         */
        connections?: outputs.peering.ExchangeConnectionResponse[];
        /**
         * The reference of the peer ASN.
         */
        peerAsn?: outputs.peering.SubResourceResponse;
    }

    /**
     * The properties that define connectivity to the Microsoft Cloud Edge.
     */
    export interface PeeringPropertiesResponse {
        /**
         * The properties that define a direct peering.
         */
        direct?: outputs.peering.PeeringPropertiesDirectResponse;
        /**
         * The properties that define an exchange peering.
         */
        exchange?: outputs.peering.PeeringPropertiesExchangeResponse;
        /**
         * The location of the peering.
         */
        peeringLocation?: string;
        /**
         * The provisioning state of the resource.
         */
        provisioningState: string;
    }

    /**
     * The properties that define a registered ASN.
     */
    export interface PeeringRegisteredAsnPropertiesResponse {
        /**
         * The customer's ASN from which traffic originates.
         */
        asn?: number;
        /**
         * The peering service prefix key that is to be shared with the customer.
         */
        peeringServicePrefixKey: string;
        /**
         * The provisioning state of the resource.
         */
        provisioningState: string;
    }

    /**
     * The properties that define a registered prefix.
     */
    export interface PeeringRegisteredPrefixPropertiesResponse {
        /**
         * The error message associated with the validation state, if any.
         */
        errorMessage: string;
        /**
         * The peering service prefix key that is to be shared with the customer.
         */
        peeringServicePrefixKey: string;
        /**
         * The customer's prefix from which traffic originates.
         */
        prefix?: string;
        /**
         * The prefix validation state.
         */
        prefixValidationState: string;
        /**
         * The provisioning state of the resource.
         */
        provisioningState: string;
    }

    /**
     * The details of the event associated with a prefix.
     */
    export interface PeeringServicePrefixEventResponse {
        /**
         * The description of the event associated with a prefix.
         */
        eventDescription: string;
        /**
         * The level of the event associated with a prefix.
         */
        eventLevel: string;
        /**
         * The summary of the event associated with a prefix.
         */
        eventSummary: string;
        /**
         * The timestamp of the event associated with a prefix.
         */
        eventTimestamp: string;
        /**
         * The type of the event associated with a prefix.
         */
        eventType: string;
    }

    /**
     * The peering service prefix properties class.
     */
    export interface PeeringServicePrefixPropertiesResponse {
        /**
         * The error message for validation state
         */
        errorMessage: string;
        /**
         * The list of events for peering service prefix
         */
        events: outputs.peering.PeeringServicePrefixEventResponse[];
        /**
         * The prefix learned type
         */
        learnedType: string;
        /**
         * The peering service prefix key
         */
        peeringServicePrefixKey?: string;
        /**
         * The prefix from which your traffic originates.
         */
        prefix?: string;
        /**
         * The prefix validation state
         */
        prefixValidationState: string;
        /**
         * The provisioning state of the resource.
         */
        provisioningState: string;
    }

    /**
     * The properties that define connectivity to the Peering Service.
     */
    export interface PeeringServicePropertiesResponse {
        /**
         * The PeeringServiceLocation of the Customer.
         */
        peeringServiceLocation?: string;
        /**
         * The MAPS Provider Name.
         */
        peeringServiceProvider?: string;
        /**
         * The provisioning state of the resource.
         */
        provisioningState: string;
    }

    /**
     * The SKU that defines the type of the peering service.
     */
    export interface PeeringServiceSkuResponse {
        /**
         * The name of the peering service SKU.
         */
        name?: string;
    }

    /**
     * The SKU that defines the tier and kind of the peering.
     */
    export interface PeeringSkuResponse {
        /**
         * The family of the peering SKU.
         */
        family?: string;
        /**
         * The name of the peering SKU.
         */
        name?: string;
        /**
         * The size of the peering SKU.
         */
        size?: string;
        /**
         * The tier of the peering SKU.
         */
        tier?: string;
    }

    /**
     * The sub resource.
     */
    export interface SubResourceResponse {
        /**
         * The identifier of the referenced resource.
         */
        id?: string;
    }
}

export namespace policyinsights {
    /**
     * Error definition.
     */
    export interface ErrorDefinitionResponse {
        /**
         * Additional scenario specific error details.
         */
        additionalInfo: outputs.policyinsights.TypedErrorInfoResponse[];
        /**
         * Service specific error code which serves as the substatus for the HTTP error code.
         */
        code: string;
        /**
         * Internal error details.
         */
        details: outputs.policyinsights.ErrorDefinitionResponse[];
        /**
         * Description of the error.
         */
        message: string;
        /**
         * The target of the error.
         */
        target: string;
    }

    /**
     * Details of a single deployment created by the remediation.
     */
    export interface RemediationDeploymentResponse {
        /**
         * The time at which the remediation was created.
         */
        createdOn: string;
        /**
         * Resource ID of the template deployment that will remediate the resource.
         */
        deploymentId: string;
        /**
         * Error encountered while remediated the resource.
         */
        error: outputs.policyinsights.ErrorDefinitionResponse;
        /**
         * The time at which the remediation deployment was last updated.
         */
        lastUpdatedOn: string;
        /**
         * Resource ID of the resource that is being remediated by the deployment.
         */
        remediatedResourceId: string;
        /**
         * Location of the resource that is being remediated.
         */
        resourceLocation: string;
        /**
         * Status of the remediation deployment.
         */
        status: string;
    }

    /**
     * The deployment status summary for all deployments created by the remediation.
     */
    export interface RemediationDeploymentSummaryResponse {
        /**
         * The number of deployments required by the remediation that have failed.
         */
        failedDeployments: number;
        /**
         * The number of deployments required by the remediation that have succeeded.
         */
        successfulDeployments: number;
        /**
         * The number of deployments required by the remediation.
         */
        totalDeployments: number;
    }

    /**
     * The filters that will be applied to determine which resources to remediate.
     */
    export interface RemediationFiltersResponse {
        /**
         * The resource locations that will be remediated.
         */
        locations?: string[];
    }

    /**
     * The remediation properties.
     */
    export interface RemediationPropertiesResponse {
        /**
         * The time at which the remediation was created.
         */
        createdOn: string;
        /**
         * The deployment status summary for all deployments created by the remediation.
         */
        deploymentStatus: outputs.policyinsights.RemediationDeploymentSummaryResponse;
        /**
         * The filters that will be applied to determine which resources to remediate.
         */
        filters?: outputs.policyinsights.RemediationFiltersResponse;
        /**
         * The time at which the remediation was last updated.
         */
        lastUpdatedOn: string;
        /**
         * The resource ID of the policy assignment that should be remediated.
         */
        policyAssignmentId?: string;
        /**
         * The policy definition reference ID of the individual definition that should be remediated. Required when the policy assignment being remediated assigns a policy set definition.
         */
        policyDefinitionReferenceId?: string;
        /**
         * The status of the remediation.
         */
        provisioningState: string;
        /**
         * The way resources to remediate are discovered. Defaults to ExistingNonCompliant if not specified.
         */
        resourceDiscoveryMode?: string;
    }

    /**
     * Scenario specific error details.
     */
    export interface TypedErrorInfoResponse {
        /**
         * The scenario specific error details.
         */
        info: {[key: string]: string};
        /**
         * The type of included error details.
         */
        type: string;
    }
}

export namespace powerbi {
    export interface AzureSkuResponse {
        /**
         * SKU name
         */
        name: string;
        /**
         * SKU tier
         */
        tier: string;
    }

}

export namespace powerbidedicated {
    /**
     * An array of administrator user identities
     */
    export interface DedicatedCapacityAdministratorsResponse {
        /**
         * An array of administrator user identities.
         */
        members?: string[];
    }

    /**
     * Properties of Dedicated Capacity resource.
     */
    export interface DedicatedCapacityPropertiesResponse {
        /**
         * A collection of Dedicated capacity administrators
         */
        administration?: outputs.powerbidedicated.DedicatedCapacityAdministratorsResponse;
        /**
         * The current deployment state of PowerBI Dedicated resource. The provisioningState is to indicate states for resource provisioning.
         */
        provisioningState: string;
        /**
         * The current state of PowerBI Dedicated resource. The state is to indicate more states outside of resource provisioning.
         */
        state: string;
    }

    /**
     * Represents the SKU name and Azure pricing tier for PowerBI Dedicated resource.
     */
    export interface ResourceSkuResponse {
        /**
         * Name of the SKU level.
         */
        name: string;
        /**
         * The name of the Azure pricing tier to which the SKU applies.
         */
        tier?: string;
    }
}

export namespace recoveryservices {
    /**
     * Current job details of the migration item.
     */
    export interface CurrentJobDetailsResponse {
        /**
         * The ARM Id of the job being executed.
         */
        jobId?: string;
        /**
         * The job name.
         */
        jobName?: string;
        /**
         * The start time of the job.
         */
        startTime?: string;
    }

    /**
     * Current scenario details of the protected entity.
     */
    export interface CurrentScenarioDetailsResponse {
        /**
         * ARM Id of the job being executed.
         */
        jobId?: string;
        /**
         * Scenario name.
         */
        scenarioName?: string;
        /**
         * Start time of the workflow.
         */
        startTime?: string;
    }

    /**
     * Encryption details for the fabric.
     */
    export interface EncryptionDetailsResponse {
        /**
         * The key encryption key certificate expiry date.
         */
        kekCertExpiryDate?: string;
        /**
         * The key encryption key certificate thumbprint.
         */
        kekCertThumbprint?: string;
        /**
         * The key encryption key state for the Vmm.
         */
        kekState?: string;
    }

    /**
     * Fabric properties.
     */
    export interface FabricPropertiesResponse {
        /**
         * BCDR state of the fabric.
         */
        bcdrState?: string;
        /**
         * Fabric specific settings.
         */
        customDetails?: outputs.recoveryservices.FabricSpecificDetailsResponse;
        /**
         * Encryption details for the fabric.
         */
        encryptionDetails?: outputs.recoveryservices.EncryptionDetailsResponse;
        /**
         * Friendly name of the fabric.
         */
        friendlyName?: string;
        /**
         * Health of fabric.
         */
        health?: string;
        /**
         * Fabric health error details.
         */
        healthErrorDetails?: outputs.recoveryservices.HealthErrorResponse[];
        /**
         * Dra Registration Id.
         */
        internalIdentifier?: string;
        /**
         * Rollover encryption details for the fabric.
         */
        rolloverEncryptionDetails?: outputs.recoveryservices.EncryptionDetailsResponse;
    }

    /**
     * Fabric specific details.
     */
    export interface FabricSpecificDetailsResponse {
        /**
         * Gets the class type. Overridden in derived classes.
         */
        instanceType: string;
    }

    /**
     * Health Error
     */
    export interface HealthErrorResponse {
        /**
         * Error creation time (UTC)
         */
        creationTimeUtc?: string;
        /**
         * Value indicating whether the health error is customer resolvable.
         */
        customerResolvability?: string;
        /**
         * ID of the entity.
         */
        entityId?: string;
        /**
         * Category of error.
         */
        errorCategory?: string;
        /**
         * Error code.
         */
        errorCode?: string;
        /**
         * The health error unique id.
         */
        errorId?: string;
        /**
         * Level of error.
         */
        errorLevel?: string;
        /**
         * Error message.
         */
        errorMessage?: string;
        /**
         * Source of error.
         */
        errorSource?: string;
        /**
         * Type of error.
         */
        errorType?: string;
        /**
         * The inner health errors. HealthError having a list of HealthError as child errors is problematic. InnerHealthError is used because this will prevent an infinite loop of structures when Hydra tries to auto-generate the contract. We are exposing the related health errors as inner health errors and all API consumers can utilize this in the same fashion as Exception -&gt; InnerException.
         */
        innerHealthErrors?: outputs.recoveryservices.InnerHealthErrorResponse[];
        /**
         * Possible causes of error.
         */
        possibleCauses?: string;
        /**
         * Recommended action to resolve error.
         */
        recommendedAction?: string;
        /**
         * DRA error message.
         */
        recoveryProviderErrorMessage?: string;
        /**
         * Summary message of the entity.
         */
        summaryMessage?: string;
    }

    /**
     * Identity for the resource.
     */
    export interface IdentityDataResponse {
        /**
         * The principal ID of resource identity.
         */
        principalId: string;
        /**
         * The tenant ID of resource.
         */
        tenantId: string;
        /**
         * The identity type.
         */
        type: string;
    }

    /**
     * Identity provider details.
     */
    export interface IdentityProviderDetailsResponse {
        /**
         * The base authority for Azure Active Directory authentication.
         */
        aadAuthority?: string;
        /**
         * The application/client Id for the service principal with which the on-premise management/data plane components would communicate with our Azure services.
         */
        applicationId?: string;
        /**
         * The intended Audience of the service principal with which the on-premise management/data plane components would communicate with our Azure services.
         */
        audience?: string;
        /**
         * The object Id of the service principal with which the on-premise management/data plane components would communicate with our Azure services.
         */
        objectId?: string;
        /**
         * The tenant Id for the service principal with which the on-premise management/data plane components would communicate with our Azure services.
         */
        tenantId?: string;
    }

    /**
     * Implements InnerHealthError class. HealthError object has a list of InnerHealthErrors as child errors. InnerHealthError is used because this will prevent an infinite loop of structures when Hydra tries to auto-generate the contract. We are exposing the related health errors as inner health errors and all API consumers can utilize this in the same fashion as Exception -&gt; InnerException.
     */
    export interface InnerHealthErrorResponse {
        /**
         * Error creation time (UTC)
         */
        creationTimeUtc?: string;
        /**
         * ID of the entity.
         */
        entityId?: string;
        /**
         * Category of error.
         */
        errorCategory?: string;
        /**
         * Error code.
         */
        errorCode?: string;
        /**
         * Level of error.
         */
        errorLevel?: string;
        /**
         * Error message.
         */
        errorMessage?: string;
        /**
         * Source of error.
         */
        errorSource?: string;
        /**
         * Type of error.
         */
        errorType?: string;
        /**
         * Possible causes of error.
         */
        possibleCauses?: string;
        /**
         * Recommended action to resolve error.
         */
        recommendedAction?: string;
        /**
         * DRA error message.
         */
        recoveryProviderErrorMessage?: string;
        /**
         * Summary message of the entity.
         */
        summaryMessage?: string;
    }

    /**
     * Migration item properties.
     */
    export interface MigrationItemPropertiesResponse {
        /**
         * The allowed operations on the migration item, based on the current migration state of the item.
         */
        allowedOperations: string[];
        /**
         * The current job details.
         */
        currentJob: outputs.recoveryservices.CurrentJobDetailsResponse;
        /**
         * The consolidated health.
         */
        health: string;
        /**
         * The list of health errors.
         */
        healthErrors: outputs.recoveryservices.HealthErrorResponse[];
        /**
         * The on-premise virtual machine name.
         */
        machineName: string;
        /**
         * The migration status.
         */
        migrationState: string;
        /**
         * The migration state description.
         */
        migrationStateDescription: string;
        /**
         * The name of policy governing this item.
         */
        policyFriendlyName: string;
        /**
         * The ARM Id of policy governing this item.
         */
        policyId: string;
        /**
         * The migration provider custom settings.
         */
        providerSpecificDetails?: outputs.recoveryservices.MigrationProviderSpecificSettingsResponse;
        /**
         * The recovery services provider ARM Id.
         */
        recoveryServicesProviderId: string;
        /**
         * The test migrate state.
         */
        testMigrateState: string;
        /**
         * The test migrate state description.
         */
        testMigrateStateDescription: string;
    }

    /**
     * Migration provider specific settings.
     */
    export interface MigrationProviderSpecificSettingsResponse {
        /**
         * Gets the instance type.
         */
        instanceType: string;
    }

    /**
     * Network Mapping fabric specific settings.
     */
    export interface NetworkMappingFabricSpecificSettingsResponse {
        /**
         * Gets the Instance type.
         */
        instanceType: string;
    }

    /**
     * Network Mapping Properties.
     */
    export interface NetworkMappingPropertiesResponse {
        /**
         * The fabric specific settings.
         */
        fabricSpecificSettings?: outputs.recoveryservices.NetworkMappingFabricSpecificSettingsResponse;
        /**
         * The primary fabric friendly name.
         */
        primaryFabricFriendlyName?: string;
        /**
         * The primary network friendly name.
         */
        primaryNetworkFriendlyName?: string;
        /**
         * The primary network id for network mapping.
         */
        primaryNetworkId?: string;
        /**
         * The recovery fabric ARM id.
         */
        recoveryFabricArmId?: string;
        /**
         * The recovery fabric friendly name.
         */
        recoveryFabricFriendlyName?: string;
        /**
         * The recovery network friendly name.
         */
        recoveryNetworkFriendlyName?: string;
        /**
         * The recovery network id for network mapping.
         */
        recoveryNetworkId?: string;
        /**
         * The pairing state for network mapping.
         */
        state?: string;
    }

    /**
     * Protection profile custom data details.
     */
    export interface PolicyPropertiesResponse {
        /**
         * The FriendlyName.
         */
        friendlyName?: string;
        /**
         * The ReplicationChannelSetting.
         */
        providerSpecificDetails?: outputs.recoveryservices.PolicyProviderSpecificDetailsResponse;
    }

    /**
     * Base class for Provider specific details for policies.
     */
    export interface PolicyProviderSpecificDetailsResponse {
        /**
         * Gets the class type. Overridden in derived classes.
         */
        instanceType: string;
    }

    /**
     * Private Endpoint Connection Response Properties
     */
    export interface PrivateEndpointConnectionResponse {
        /**
         * Gets or sets private endpoint associated with the private endpoint connection
         */
        privateEndpoint?: outputs.recoveryservices.PrivateEndpointResponse;
        /**
         * Gets or sets private link service connection state
         */
        privateLinkServiceConnectionState?: outputs.recoveryservices.PrivateLinkServiceConnectionStateResponse;
        /**
         * Gets or sets provisioning state of the private endpoint connection
         */
        provisioningState?: string;
    }

    /**
     * Information to be stored in Vault properties as an element of privateEndpointConnections List.
     */
    export interface PrivateEndpointConnectionVaultPropertiesResponse {
        /**
         * Format of id subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.[Service]/{resource}/{resourceName}/privateEndpointConnections/{connectionName}.
         */
        id: string;
        /**
         * Private Endpoint Connection Response Properties.
         */
        properties?: outputs.recoveryservices.PrivateEndpointConnectionResponse;
    }

    /**
     * The Private Endpoint network resource that is linked to the Private Endpoint connection
     */
    export interface PrivateEndpointResponse {
        /**
         * Gets or sets id
         */
        id?: string;
    }

    /**
     * Private Link Service Connection State
     */
    export interface PrivateLinkServiceConnectionStateResponse {
        /**
         * Gets or sets actions required
         */
        actionRequired?: string;
        /**
         * Gets or sets description
         */
        description?: string;
        /**
         * Gets or sets the status
         */
        status?: string;
    }

    /**
     * Protection container mapping properties.
     */
    export interface ProtectionContainerMappingPropertiesResponse {
        /**
         * Health of pairing.
         */
        health?: string;
        /**
         * Health error.
         */
        healthErrorDetails?: outputs.recoveryservices.HealthErrorResponse[];
        /**
         * Friendly name of replication policy.
         */
        policyFriendlyName?: string;
        /**
         * Policy ARM Id.
         */
        policyId?: string;
        /**
         * Provider specific provider details.
         */
        providerSpecificDetails?: outputs.recoveryservices.ProtectionContainerMappingProviderSpecificDetailsResponse;
        /**
         * Friendly name of source fabric.
         */
        sourceFabricFriendlyName?: string;
        /**
         * Friendly name of source protection container.
         */
        sourceProtectionContainerFriendlyName?: string;
        /**
         * Association Status
         */
        state?: string;
        /**
         * Friendly name of target fabric.
         */
        targetFabricFriendlyName?: string;
        /**
         * Friendly name of paired container.
         */
        targetProtectionContainerFriendlyName?: string;
        /**
         * Paired protection container ARM ID.
         */
        targetProtectionContainerId?: string;
    }

    /**
     * Container mapping provider specific details.
     */
    export interface ProtectionContainerMappingProviderSpecificDetailsResponse {
        /**
         * Gets the class type. Overridden in derived classes.
         */
        instanceType: string;
    }

    /**
     * The base class for a backup policy. Workload-specific backup policies are derived from this class.
     */
    export interface ProtectionPolicyResponse {
        /**
         * This property is used as the discriminator for deciding the specific types in the polymorphic chain of types.
         */
        backupManagementType?: string;
        /**
         * The number of items associated with this policy.
         */
        protectedItemsCount?: number;
    }

    /**
     * Recovery plan action custom details.
     */
    export interface RecoveryPlanActionDetailsResponse {
        /**
         * Gets the type of action details (see RecoveryPlanActionDetailsTypes enum for possible values).
         */
        instanceType: string;
    }

    /**
     * Recovery plan action details.
     */
    export interface RecoveryPlanActionResponse {
        /**
         * The action name.
         */
        actionName: string;
        /**
         * The custom details.
         */
        customDetails: outputs.recoveryservices.RecoveryPlanActionDetailsResponse;
        /**
         * The list of failover directions.
         */
        failoverDirections: string[];
        /**
         * The list of failover types.
         */
        failoverTypes: string[];
    }

    /**
     * Recovery plan group details.
     */
    export interface RecoveryPlanGroupResponse {
        /**
         * The end group actions.
         */
        endGroupActions?: outputs.recoveryservices.RecoveryPlanActionResponse[];
        /**
         * The group type.
         */
        groupType: string;
        /**
         * The list of protected items.
         */
        replicationProtectedItems?: outputs.recoveryservices.RecoveryPlanProtectedItemResponse[];
        /**
         * The start group actions.
         */
        startGroupActions?: outputs.recoveryservices.RecoveryPlanActionResponse[];
    }

    /**
     * Recovery plan custom details.
     */
    export interface RecoveryPlanPropertiesResponse {
        /**
         * The list of allowed operations.
         */
        allowedOperations?: string[];
        /**
         * The current scenario details.
         */
        currentScenario?: outputs.recoveryservices.CurrentScenarioDetailsResponse;
        /**
         * The recovery plan status.
         */
        currentScenarioStatus?: string;
        /**
         * The recovery plan status description.
         */
        currentScenarioStatusDescription?: string;
        /**
         * The failover deployment model.
         */
        failoverDeploymentModel?: string;
        /**
         * The friendly name.
         */
        friendlyName?: string;
        /**
         * The recovery plan groups.
         */
        groups?: outputs.recoveryservices.RecoveryPlanGroupResponse[];
        /**
         * The start time of the last planned failover.
         */
        lastPlannedFailoverTime?: string;
        /**
         * The start time of the last test failover.
         */
        lastTestFailoverTime?: string;
        /**
         * The start time of the last unplanned failover.
         */
        lastUnplannedFailoverTime?: string;
        /**
         * The primary fabric friendly name.
         */
        primaryFabricFriendlyName?: string;
        /**
         * The primary fabric Id.
         */
        primaryFabricId?: string;
        /**
         * The provider id and provider specific details.
         */
        providerSpecificDetails: outputs.recoveryservices.RecoveryPlanProviderSpecificDetailsResponse[];
        /**
         * The recovery fabric friendly name.
         */
        recoveryFabricFriendlyName?: string;
        /**
         * The recovery fabric Id.
         */
        recoveryFabricId?: string;
        /**
         * The list of replication providers.
         */
        replicationProviders?: string[];
    }

    /**
     * Recovery plan protected item.
     */
    export interface RecoveryPlanProtectedItemResponse {
        /**
         * The ARM Id of the recovery plan protected item.
         */
        id?: string;
        /**
         * The virtual machine Id.
         */
        virtualMachineId?: string;
    }

    /**
     * Recovery plan provider specific details.
     */
    export interface RecoveryPlanProviderSpecificDetailsResponse {
        /**
         * Gets the Instance type.
         */
        instanceType: string;
    }

    /**
     * Recovery services provider properties.
     */
    export interface RecoveryServicesProviderPropertiesResponse {
        /**
         * The scenarios allowed on this provider.
         */
        allowedScenarios?: string[];
        /**
         * The authentication identity details.
         */
        authenticationIdentityDetails?: outputs.recoveryservices.IdentityProviderDetailsResponse;
        /**
         * A value indicating whether DRA is responsive.
         */
        connectionStatus?: string;
        /**
         * The DRA Id.
         */
        draIdentifier?: string;
        /**
         * The fabric friendly name.
         */
        fabricFriendlyName?: string;
        /**
         * Type of the site.
         */
        fabricType?: string;
        /**
         * Friendly name of the DRA.
         */
        friendlyName?: string;
        /**
         * The recovery services provider health error details.
         */
        healthErrorDetails?: outputs.recoveryservices.HealthErrorResponse[];
        /**
         * Time when last heartbeat was sent by the DRA.
         */
        lastHeartBeat?: string;
        /**
         * Number of protected VMs currently managed by the DRA.
         */
        protectedItemCount?: number;
        /**
         * The provider version.
         */
        providerVersion?: string;
        /**
         * The provider version details.
         */
        providerVersionDetails?: outputs.recoveryservices.VersionDetailsResponse;
        /**
         * Expiry date of the version.
         */
        providerVersionExpiryDate?: string;
        /**
         * DRA version status.
         */
        providerVersionState?: string;
        /**
         * The resource access identity details.
         */
        resourceAccessIdentityDetails?: outputs.recoveryservices.IdentityProviderDetailsResponse;
        /**
         * The fabric provider.
         */
        serverVersion?: string;
    }

    /**
     * Replication protected item custom data details.
     */
    export interface ReplicationProtectedItemPropertiesResponse {
        /**
         * The Current active location of the PE.
         */
        activeLocation?: string;
        /**
         * The allowed operations on the Replication protected item.
         */
        allowedOperations?: string[];
        /**
         * The current scenario.
         */
        currentScenario?: outputs.recoveryservices.CurrentScenarioDetailsResponse;
        /**
         * The consolidated failover health for the VM.
         */
        failoverHealth?: string;
        /**
         * The recovery point ARM Id to which the Vm was failed over.
         */
        failoverRecoveryPointId?: string;
        /**
         * The name.
         */
        friendlyName?: string;
        /**
         * List of health errors.
         */
        healthErrors?: outputs.recoveryservices.HealthErrorResponse[];
        /**
         * The Last successful failover time.
         */
        lastSuccessfulFailoverTime?: string;
        /**
         * The Last successful test failover time.
         */
        lastSuccessfulTestFailoverTime?: string;
        /**
         * The name of Policy governing this PE.
         */
        policyFriendlyName?: string;
        /**
         * The ID of Policy governing this PE.
         */
        policyId?: string;
        /**
         * The friendly name of the primary fabric.
         */
        primaryFabricFriendlyName?: string;
        /**
         * The fabric provider of the primary fabric.
         */
        primaryFabricProvider?: string;
        /**
         * The name of primary protection container friendly name.
         */
        primaryProtectionContainerFriendlyName?: string;
        /**
         * The protected item ARM Id.
         */
        protectableItemId?: string;
        /**
         * The type of protected item type.
         */
        protectedItemType?: string;
        /**
         * The protection status.
         */
        protectionState?: string;
        /**
         * The protection state description.
         */
        protectionStateDescription?: string;
        /**
         * The Replication provider custom settings.
         */
        providerSpecificDetails?: outputs.recoveryservices.ReplicationProviderSpecificSettingsResponse;
        /**
         * The recovery container Id.
         */
        recoveryContainerId?: string;
        /**
         * The friendly name of recovery fabric.
         */
        recoveryFabricFriendlyName?: string;
        /**
         * The Arm Id of recovery fabric.
         */
        recoveryFabricId?: string;
        /**
         * The name of recovery container friendly name.
         */
        recoveryProtectionContainerFriendlyName?: string;
        /**
         * The recovery provider ARM Id.
         */
        recoveryServicesProviderId?: string;
        /**
         * The consolidated protection health for the VM taking any issues with SRS as well as all the replication units associated with the VM's replication group into account. This is a string representation of the ProtectionHealth enumeration.
         */
        replicationHealth?: string;
        /**
         * The Test failover state.
         */
        testFailoverState?: string;
        /**
         * The Test failover state description.
         */
        testFailoverStateDescription?: string;
    }

    /**
     * Replication provider specific settings.
     */
    export interface ReplicationProviderSpecificSettingsResponse {
        /**
         * Gets the Instance type.
         */
        instanceType: string;
    }

    /**
     * Identifies the unique system identifier for each Azure resource.
     */
    export interface SkuResponse {
        /**
         * The Sku name.
         */
        name: string;
    }

    /**
     * Storage mapping properties.
     */
    export interface StorageClassificationMappingPropertiesResponse {
        /**
         * Target storage object Id.
         */
        targetStorageClassificationId?: string;
    }

    /**
     * Details for upgrading vault.
     */
    export interface UpgradeDetailsResponse {
        /**
         * UTC time at which the upgrade operation has ended.
         */
        endTimeUtc: string;
        /**
         * UTC time at which the upgrade operation status was last updated.
         */
        lastUpdatedTimeUtc: string;
        /**
         * Message to the user containing information about the upgrade operation.
         */
        message: string;
        /**
         * ID of the vault upgrade operation.
         */
        operationId: string;
        /**
         * Resource ID of the vault before the upgrade.
         */
        previousResourceId: string;
        /**
         * UTC time at which the upgrade operation has started.
         */
        startTimeUtc: string;
        /**
         * Status of the vault upgrade operation.
         */
        status: string;
        /**
         * The way the vault upgrade was triggered.
         */
        triggerType: string;
        /**
         * Resource ID of the upgraded vault.
         */
        upgradedResourceId: string;
    }

    /**
     * vCenter properties.
     */
    export interface VCenterPropertiesResponse {
        /**
         * The VCenter discovery status.
         */
        discoveryStatus?: string;
        /**
         * The ARM resource name of the fabric containing this VCenter.
         */
        fabricArmResourceName?: string;
        /**
         * Friendly name of the vCenter.
         */
        friendlyName?: string;
        /**
         * The health errors for this VCenter.
         */
        healthErrors?: outputs.recoveryservices.HealthErrorResponse[];
        /**
         * The infrastructure Id of vCenter.
         */
        infrastructureId?: string;
        /**
         * VCenter internal ID.
         */
        internalId?: string;
        /**
         * The IP address of the vCenter.
         */
        ipAddress?: string;
        /**
         * The time when the last heartbeat was received by vCenter.
         */
        lastHeartbeat?: string;
        /**
         * The port number for discovery.
         */
        port?: string;
        /**
         * The process server Id.
         */
        processServerId?: string;
        /**
         * The account Id which has privileges to discover the vCenter.
         */
        runAsAccountId?: string;
    }

    /**
     * Properties of the vault.
     */
    export interface VaultPropertiesResponse {
        /**
         * List of private endpoint connection.
         */
        privateEndpointConnections: outputs.recoveryservices.PrivateEndpointConnectionVaultPropertiesResponse[];
        /**
         * Private endpoint state for backup.
         */
        privateEndpointStateForBackup: string;
        /**
         * Private endpoint state for site recovery.
         */
        privateEndpointStateForSiteRecovery: string;
        /**
         * Provisioning State.
         */
        provisioningState: string;
        /**
         * Details for upgrading vault.
         */
        upgradeDetails?: outputs.recoveryservices.UpgradeDetailsResponse;
    }

    /**
     * Version related details.
     */
    export interface VersionDetailsResponse {
        /**
         * Version expiry date.
         */
        expiryDate?: string;
        /**
         * A value indicating whether security update required.
         */
        status?: string;
        /**
         * The agent version.
         */
        version?: string;
    }
}

export namespace redhatopenshift {
    /**
     * APIServerProfile represents an API server profile.
     */
    export interface APIServerProfileResponse {
        /**
         * The IP of the cluster API server (immutable).
         */
        ip?: string;
        /**
         * The URL to access the cluster API server (immutable).
         */
        url?: string;
        /**
         * API server visibility (immutable).
         */
        visibility?: string;
    }

    /**
     * ClusterProfile represents a cluster profile.
     */
    export interface ClusterProfileResponse {
        /**
         * The domain for the cluster (immutable).
         */
        domain?: string;
        /**
         * The pull secret for the cluster (immutable).
         */
        pullSecret?: string;
        /**
         * The ID of the cluster resource group (immutable).
         */
        resourceGroupId?: string;
        /**
         * The version of the cluster (immutable).
         */
        version?: string;
    }

    /**
     * ConsoleProfile represents a console profile.
     */
    export interface ConsoleProfileResponse {
        /**
         * The URL to access the cluster console (immutable).
         */
        url?: string;
    }

    /**
     * IngressProfile represents an ingress profile.
     */
    export interface IngressProfileResponse {
        /**
         * The IP of the ingress (immutable).
         */
        ip?: string;
        /**
         * The ingress profile name.  Must be "default" (immutable).
         */
        name?: string;
        /**
         * Ingress visibility (immutable).
         */
        visibility?: string;
    }

    /**
     * MasterProfile represents a master profile.
     */
    export interface MasterProfileResponse {
        /**
         * The Azure resource ID of the master subnet (immutable).
         */
        subnetId?: string;
        /**
         * The size of the master VMs (immutable).
         */
        vmSize?: string;
    }

    /**
     * NetworkProfile represents a network profile.
     */
    export interface NetworkProfileResponse {
        /**
         * The CIDR used for OpenShift/Kubernetes Pods (immutable).
         */
        podCidr?: string;
        /**
         * The CIDR used for OpenShift/Kubernetes Services (immutable).
         */
        serviceCidr?: string;
    }

    /**
     * OpenShiftClusterProperties represents an OpenShift cluster's properties.
     */
    export interface OpenShiftClusterPropertiesResponse {
        /**
         * The cluster API server profile.
         */
        apiserverProfile?: outputs.redhatopenshift.APIServerProfileResponse;
        /**
         * The cluster profile.
         */
        clusterProfile?: outputs.redhatopenshift.ClusterProfileResponse;
        /**
         * The console profile.
         */
        consoleProfile?: outputs.redhatopenshift.ConsoleProfileResponse;
        /**
         * The cluster ingress profiles.
         */
        ingressProfiles?: outputs.redhatopenshift.IngressProfileResponse[];
        /**
         * The cluster master profile.
         */
        masterProfile?: outputs.redhatopenshift.MasterProfileResponse;
        /**
         * The cluster network profile.
         */
        networkProfile?: outputs.redhatopenshift.NetworkProfileResponse;
        /**
         * The cluster provisioning state (immutable).
         */
        provisioningState?: string;
        /**
         * The cluster service principal profile.
         */
        servicePrincipalProfile?: outputs.redhatopenshift.ServicePrincipalProfileResponse;
        /**
         * The cluster worker profiles.
         */
        workerProfiles?: outputs.redhatopenshift.WorkerProfileResponse[];
    }

    /**
     * ServicePrincipalProfile represents a service principal profile.
     */
    export interface ServicePrincipalProfileResponse {
        /**
         * The client ID used for the cluster (immutable).
         */
        clientId?: string;
        /**
         * The client secret used for the cluster (immutable).
         */
        clientSecret?: string;
    }

    /**
     * WorkerProfile represents a worker profile.
     */
    export interface WorkerProfileResponse {
        /**
         * The number of worker VMs.  Must be between 3 and 20 (immutable).
         */
        count?: number;
        /**
         * The disk size of the worker VMs.  Must be 128 or greater (immutable).
         */
        diskSizeGB?: number;
        /**
         * The worker profile name.  Must be "worker" (immutable).
         */
        name?: string;
        /**
         * The Azure resource ID of the worker subnet (immutable).
         */
        subnetId?: string;
        /**
         * The size of the worker VMs (immutable).
         */
        vmSize?: string;
    }
}

export namespace relay {
    /**
     * Authorization rule properties.
     */
    export interface AuthorizationRuleResponseProperties {
        /**
         * The rights associated with the rule.
         */
        rights: string[];
    }

    /**
     * Properties of the HybridConnection.
     */
    export interface HybridConnectionResponseProperties {
        /**
         * The time the hybrid connection was created.
         */
        createdAt: string;
        /**
         * The number of listeners for this hybrid connection. Note that min : 1 and max:25 are supported.
         */
        listenerCount: number;
        /**
         * Returns true if client authorization is needed for this hybrid connection; otherwise, false.
         */
        requiresClientAuthorization?: boolean;
        /**
         * The time the namespace was updated.
         */
        updatedAt: string;
        /**
         * The usermetadata is a placeholder to store user-defined string data for the hybrid connection endpoint. For example, it can be used to store descriptive data, such as a list of teams and their contact information. Also, user-defined configuration settings can be stored.
         */
        userMetadata?: string;
    }

    /**
     * Properties of the namespace.
     */
    export interface RelayNamespacePropertiesResponse {
        /**
         * The time the namespace was created.
         */
        createdAt: string;
        /**
         * Identifier for Azure Insights metrics.
         */
        metricId: string;
        provisioningState: string;
        /**
         * Endpoint you can use to perform Service Bus operations.
         */
        serviceBusEndpoint: string;
        /**
         * The time the namespace was updated.
         */
        updatedAt: string;
    }

    /**
     * SKU of the namespace.
     */
    export interface SkuResponse {
        /**
         * Name of this SKU.
         */
        name: string;
        /**
         * The tier of this SKU.
         */
        tier?: string;
    }

    /**
     * Properties of the WCF relay.
     */
    export interface WcfRelayResponseProperties {
        /**
         * The time the WCF relay was created.
         */
        createdAt: string;
        /**
         * Returns true if the relay is dynamic; otherwise, false.
         */
        isDynamic: boolean;
        /**
         * The number of listeners for this relay. Note that min :1 and max:25 are supported.
         */
        listenerCount: number;
        /**
         * WCF relay type.
         */
        relayType?: string;
        /**
         * Returns true if client authorization is needed for this relay; otherwise, false.
         */
        requiresClientAuthorization?: boolean;
        /**
         * Returns true if transport security is needed for this relay; otherwise, false.
         */
        requiresTransportSecurity?: boolean;
        /**
         * The time the namespace was updated.
         */
        updatedAt: string;
        /**
         * The usermetadata is a placeholder to store user-defined string data for the WCF Relay endpoint. For example, it can be used to store descriptive data, such as list of teams and their contact information. Also, user-defined configuration settings can be stored.
         */
        userMetadata?: string;
    }
}

export namespace resources {
    /**
     * The type of the paths for alias.
     */
    export interface AliasPathResponse {
        /**
         * The API versions.
         */
        apiVersions?: string[];
        /**
         * The path of an alias.
         */
        path?: string;
        /**
         * The pattern for an alias path.
         */
        pattern?: outputs.resources.AliasPatternResponse;
    }

    /**
     * The type of the pattern for an alias path.
     */
    export interface AliasPatternResponse {
        /**
         * The alias pattern phrase.
         */
        phrase?: string;
        /**
         * The type of alias pattern
         */
        type?: string;
        /**
         * The alias pattern variable.
         */
        variable?: string;
    }

    /**
     * The alias type. 
     */
    export interface AliasResponse {
        /**
         * The default path for an alias.
         */
        defaultPath?: string;
        /**
         * The default pattern for an alias.
         */
        defaultPattern?: outputs.resources.AliasPatternResponse;
        /**
         * The alias name.
         */
        name?: string;
        /**
         * The paths for an alias.
         */
        paths?: outputs.resources.AliasPathResponse[];
        /**
         * The type of the alias.
         */
        type?: string;
    }

    /**
     * Deployment dependency information.
     */
    export interface BasicDependencyResponse {
        /**
         * The ID of the dependency.
         */
        id?: string;
        /**
         * The dependency resource name.
         */
        resourceName?: string;
        /**
         * The dependency resource type.
         */
        resourceType?: string;
    }

    /**
     * The debug setting.
     */
    export interface DebugSettingResponse {
        /**
         * Specifies the type of information to log for debugging. The permitted values are none, requestContent, responseContent, or both requestContent and responseContent separated by a comma. The default is none. When setting this value, carefully consider the type of information you are passing in during deployment. By logging information about the request or response, you could potentially expose sensitive data that is retrieved through the deployment operations.
         */
        detailLevel?: string;
    }

    /**
     * Deployment dependency information.
     */
    export interface DependencyResponse {
        /**
         * The list of dependencies.
         */
        dependsOn?: outputs.resources.BasicDependencyResponse[];
        /**
         * The ID of the dependency.
         */
        id?: string;
        /**
         * The dependency resource name.
         */
        resourceName?: string;
        /**
         * The dependency resource type.
         */
        resourceType?: string;
    }

    /**
     * Deployment properties with additional details.
     */
    export interface DeploymentPropertiesExtendedResponse {
        /**
         * The correlation ID of the deployment.
         */
        correlationId: string;
        /**
         * The debug setting of the deployment.
         */
        debugSetting: outputs.resources.DebugSettingResponse;
        /**
         * The list of deployment dependencies.
         */
        dependencies: outputs.resources.DependencyResponse[];
        /**
         * The duration of the template deployment.
         */
        duration: string;
        /**
         * The deployment error.
         */
        error: outputs.resources.ErrorResponseResponse;
        /**
         * The deployment mode. Possible values are Incremental and Complete.
         */
        mode: string;
        /**
         * The deployment on error behavior.
         */
        onErrorDeployment: outputs.resources.OnErrorDeploymentExtendedResponse;
        /**
         * Array of provisioned resources.
         */
        outputResources: outputs.resources.ResourceReferenceResponse[];
        /**
         * Key/value pairs that represent deployment output.
         */
        outputs: {[key: string]: string};
        /**
         * Deployment parameters. 
         */
        parameters: {[key: string]: string};
        /**
         * The URI referencing the parameters. 
         */
        parametersLink: outputs.resources.ParametersLinkResponse;
        /**
         * The list of resource providers needed for the deployment.
         */
        providers: outputs.resources.ProviderResponse[];
        /**
         * Denotes the state of provisioning.
         */
        provisioningState: string;
        /**
         * The hash produced for the template.
         */
        templateHash: string;
        /**
         * The URI referencing the template.
         */
        templateLink: outputs.resources.TemplateLinkResponse;
        /**
         * The timestamp of the template deployment.
         */
        timestamp: string;
        /**
         * Array of validated resources.
         */
        validatedResources: outputs.resources.ResourceReferenceResponse[];
    }

    /**
     * The resource management error additional info.
     */
    export interface ErrorAdditionalInfoResponse {
        /**
         * The additional info.
         */
        info: {[key: string]: string};
        /**
         * The additional info type.
         */
        type: string;
    }

    /**
     * The resource management error response.
     */
    export interface ErrorResponseResponse {
        /**
         * The error additional info.
         */
        additionalInfo: outputs.resources.ErrorAdditionalInfoResponse[];
        /**
         * The error code.
         */
        code: string;
        /**
         * The error details.
         */
        details: outputs.resources.ErrorResponseResponse[];
        /**
         * The error message.
         */
        message: string;
        /**
         * The error target.
         */
        target: string;
    }

    /**
     * Deployment on error behavior with additional details.
     */
    export interface OnErrorDeploymentExtendedResponse {
        /**
         * The deployment to be used on error case.
         */
        deploymentName?: string;
        /**
         * The state of the provisioning for the on error deployment.
         */
        provisioningState: string;
        /**
         * The deployment on error behavior type. Possible values are LastSuccessful and SpecificDeployment.
         */
        type?: string;
    }

    /**
     * Entity representing the reference to the deployment parameters.
     */
    export interface ParametersLinkResponse {
        /**
         * If included, must match the ContentVersion in the template.
         */
        contentVersion?: string;
        /**
         * The URI of the parameters file.
         */
        uri: string;
    }

    /**
     * Resource type managed by the resource provider.
     */
    export interface ProviderResourceTypeResponse {
        /**
         * The aliases that are supported by this resource type.
         */
        aliases?: outputs.resources.AliasResponse[];
        /**
         * The API version.
         */
        apiVersions?: string[];
        /**
         * The additional capabilities offered by this resource type.
         */
        capabilities?: string;
        /**
         * The collection of locations where this resource type can be created.
         */
        locations?: string[];
        /**
         * The properties.
         */
        properties?: {[key: string]: string};
        /**
         * The resource type.
         */
        resourceType?: string;
    }

    /**
     * Resource provider information.
     */
    export interface ProviderResponse {
        /**
         * The provider ID.
         */
        id: string;
        /**
         * The namespace of the resource provider.
         */
        namespace?: string;
        /**
         * The registration policy of the resource provider.
         */
        registrationPolicy: string;
        /**
         * The registration state of the resource provider.
         */
        registrationState: string;
        /**
         * The collection of provider resource types.
         */
        resourceTypes: outputs.resources.ProviderResourceTypeResponse[];
    }

    /**
     * The resource Id model.
     */
    export interface ResourceReferenceResponse {
        /**
         * The fully qualified resource Id.
         */
        id: string;
    }

    /**
     * Entity representing the reference to the template.
     */
    export interface TemplateLinkResponse {
        /**
         * If included, must match the ContentVersion in the template.
         */
        contentVersion?: string;
        /**
         * The resource id of a Template Spec. Use either the id or uri property, but not both.
         */
        id?: string;
        /**
         * Applicable only if this template link references a Template Spec. This relativePath property can optionally be used to reference a Template Spec artifact by path.
         */
        relativePath?: string;
        /**
         * The URI of the template to deploy. Use either the uri or id property, but not both.
         */
        uri?: string;
    }
}

export namespace scheduler {
    export interface HttpAuthenticationResponse {
        /**
         * Gets or sets the HTTP authentication type.
         */
        type: string;
    }

    export interface HttpRequestResponse {
        /**
         * Gets or sets the authentication method of the request.
         */
        authentication?: outputs.scheduler.HttpAuthenticationResponse;
        /**
         * Gets or sets the request body.
         */
        body?: string;
        /**
         * Gets or sets the headers.
         */
        headers?: {[key: string]: string};
        /**
         * Gets or sets the method of the request.
         */
        method?: string;
        /**
         * Gets or sets the URI of the request.
         */
        uri?: string;
    }

    export interface JobActionResponse {
        /**
         * Gets or sets the error action.
         */
        errorAction?: outputs.scheduler.JobErrorActionResponse;
        /**
         * Gets or sets the storage queue message.
         */
        queueMessage?: outputs.scheduler.StorageQueueMessageResponse;
        /**
         * Gets or sets the http requests.
         */
        request?: outputs.scheduler.HttpRequestResponse;
        /**
         * Gets or sets the retry policy.
         */
        retryPolicy?: outputs.scheduler.RetryPolicyResponse;
        /**
         * Gets or sets the service bus queue message.
         */
        serviceBusQueueMessage?: outputs.scheduler.ServiceBusQueueMessageResponse;
        /**
         * Gets or sets the service bus topic message.
         */
        serviceBusTopicMessage?: outputs.scheduler.ServiceBusTopicMessageResponse;
        /**
         * Gets or sets the job action type.
         */
        type?: string;
    }

    export interface JobCollectionPropertiesResponse {
        /**
         * Gets or sets the job collection quota.
         */
        quota?: outputs.scheduler.JobCollectionQuotaResponse;
        /**
         * Gets or sets the SKU.
         */
        sku?: outputs.scheduler.SkuResponse;
        /**
         * Gets or sets the state.
         */
        state?: string;
    }

    export interface JobCollectionQuotaResponse {
        /**
         * Gets or set the maximum job count.
         */
        maxJobCount?: number;
        /**
         * Gets or sets the maximum job occurrence.
         */
        maxJobOccurrence?: number;
        /**
         * Gets or set the maximum recurrence.
         */
        maxRecurrence?: outputs.scheduler.JobMaxRecurrenceResponse;
    }

    export interface JobErrorActionResponse {
        /**
         * Gets or sets the storage queue message.
         */
        queueMessage?: outputs.scheduler.StorageQueueMessageResponse;
        /**
         * Gets or sets the http requests.
         */
        request?: outputs.scheduler.HttpRequestResponse;
        /**
         * Gets or sets the retry policy.
         */
        retryPolicy?: outputs.scheduler.RetryPolicyResponse;
        /**
         * Gets or sets the service bus queue message.
         */
        serviceBusQueueMessage?: outputs.scheduler.ServiceBusQueueMessageResponse;
        /**
         * Gets or sets the service bus topic message.
         */
        serviceBusTopicMessage?: outputs.scheduler.ServiceBusTopicMessageResponse;
        /**
         * Gets or sets the job error action type.
         */
        type?: string;
    }

    export interface JobMaxRecurrenceResponse {
        /**
         * Gets or sets the frequency of recurrence (second, minute, hour, day, week, month).
         */
        frequency?: string;
        /**
         * Gets or sets the interval between retries.
         */
        interval?: number;
    }

    export interface JobPropertiesResponse {
        /**
         * Gets or sets the job action.
         */
        action?: outputs.scheduler.JobActionResponse;
        /**
         * Gets or sets the job recurrence.
         */
        recurrence?: outputs.scheduler.JobRecurrenceResponse;
        /**
         * Gets or sets the job start time.
         */
        startTime?: string;
        /**
         * Gets or set the job state.
         */
        state?: string;
        /**
         * Gets the job status.
         */
        status: outputs.scheduler.JobStatusResponse;
    }

    export interface JobRecurrenceResponse {
        /**
         * Gets or sets the maximum number of times that the job should run.
         */
        count?: number;
        /**
         * Gets or sets the time at which the job will complete.
         */
        endTime?: string;
        /**
         * Gets or sets the frequency of recurrence (second, minute, hour, day, week, month).
         */
        frequency?: string;
        /**
         * Gets or sets the interval between retries.
         */
        interval?: number;
        schedule?: outputs.scheduler.JobRecurrenceScheduleResponse;
    }

    export interface JobRecurrenceScheduleMonthlyOccurrenceResponse {
        /**
         * Gets or sets the occurrence. Must be between -5 and 5.
         */
        Occurrence?: number;
        /**
         * Gets or sets the day. Must be one of monday, tuesday, wednesday, thursday, friday, saturday, sunday.
         */
        day?: string;
    }

    export interface JobRecurrenceScheduleResponse {
        /**
         * Gets or sets the hours of the day that the job should execute at.
         */
        hours?: number[];
        /**
         * Gets or sets the minutes of the hour that the job should execute at.
         */
        minutes?: number[];
        /**
         * Gets or sets the days of the month that the job should execute on. Must be between 1 and 31.
         */
        monthDays?: number[];
        /**
         * Gets or sets the occurrences of days within a month.
         */
        monthlyOccurrences?: outputs.scheduler.JobRecurrenceScheduleMonthlyOccurrenceResponse[];
        /**
         * Gets or sets the days of the week that the job should execute on.
         */
        weekDays?: string[];
    }

    export interface JobStatusResponse {
        /**
         * Gets the number of times this job has executed.
         */
        executionCount: number;
        /**
         * Gets the number of times this job has failed.
         */
        failureCount: number;
        /**
         * Gets the number of faulted occurrences (occurrences that were retried and failed as many times as the retry policy states).
         */
        faultedCount: number;
        /**
         * Gets the time the last occurrence executed in ISO-8601 format.  Could be empty if job has not run yet.
         */
        lastExecutionTime: string;
        /**
         * Gets the time of the next occurrence in ISO-8601 format. Could be empty if the job is completed.
         */
        nextExecutionTime: string;
    }

    export interface RetryPolicyResponse {
        /**
         * Gets or sets the number of times a retry should be attempted.
         */
        retryCount?: number;
        /**
         * Gets or sets the retry interval between retries, specify duration in ISO 8601 format.
         */
        retryInterval?: string;
        /**
         * Gets or sets the retry strategy to be used.
         */
        retryType?: string;
    }

    export interface ServiceBusAuthenticationResponse {
        /**
         * Gets or sets the SAS key.
         */
        sasKey?: string;
        /**
         * Gets or sets the SAS key name.
         */
        sasKeyName?: string;
        /**
         * Gets or sets the authentication type.
         */
        type?: string;
    }

    export interface ServiceBusBrokeredMessagePropertiesResponse {
        /**
         * Gets or sets the content type.
         */
        contentType?: string;
        /**
         * Gets or sets the correlation ID.
         */
        correlationId?: string;
        /**
         * Gets or sets the force persistence.
         */
        forcePersistence?: boolean;
        /**
         * Gets or sets the label.
         */
        label?: string;
        /**
         * Gets or sets the message ID.
         */
        messageId?: string;
        /**
         * Gets or sets the partition key.
         */
        partitionKey?: string;
        /**
         * Gets or sets the reply to.
         */
        replyTo?: string;
        /**
         * Gets or sets the reply to session ID.
         */
        replyToSessionId?: string;
        /**
         * Gets or sets the scheduled enqueue time UTC.
         */
        scheduledEnqueueTimeUtc?: string;
        /**
         * Gets or sets the session ID.
         */
        sessionId?: string;
        /**
         * Gets or sets the time to live.
         */
        timeToLive?: string;
        /**
         * Gets or sets the to.
         */
        to?: string;
        /**
         * Gets or sets the via partition key.
         */
        viaPartitionKey?: string;
    }

    export interface ServiceBusQueueMessageResponse {
        /**
         * Gets or sets the Service Bus authentication.
         */
        authentication?: outputs.scheduler.ServiceBusAuthenticationResponse;
        /**
         * Gets or sets the brokered message properties.
         */
        brokeredMessageProperties?: outputs.scheduler.ServiceBusBrokeredMessagePropertiesResponse;
        /**
         * Gets or sets the custom message properties.
         */
        customMessageProperties?: {[key: string]: string};
        /**
         * Gets or sets the message.
         */
        message?: string;
        /**
         * Gets or sets the namespace.
         */
        namespace?: string;
        /**
         * Gets or sets the queue name.
         */
        queueName?: string;
        /**
         * Gets or sets the transport type.
         */
        transportType?: string;
    }

    export interface ServiceBusTopicMessageResponse {
        /**
         * Gets or sets the Service Bus authentication.
         */
        authentication?: outputs.scheduler.ServiceBusAuthenticationResponse;
        /**
         * Gets or sets the brokered message properties.
         */
        brokeredMessageProperties?: outputs.scheduler.ServiceBusBrokeredMessagePropertiesResponse;
        /**
         * Gets or sets the custom message properties.
         */
        customMessageProperties?: {[key: string]: string};
        /**
         * Gets or sets the message.
         */
        message?: string;
        /**
         * Gets or sets the namespace.
         */
        namespace?: string;
        /**
         * Gets or sets the topic path.
         */
        topicPath?: string;
        /**
         * Gets or sets the transport type.
         */
        transportType?: string;
    }

    export interface SkuResponse {
        /**
         * Gets or set the SKU.
         */
        name?: string;
    }

    export interface StorageQueueMessageResponse {
        /**
         * Gets or sets the message.
         */
        message?: string;
        /**
         * Gets or sets the queue name.
         */
        queueName?: string;
        /**
         * Gets or sets the SAS key.
         */
        sasToken?: string;
        /**
         * Gets or sets the storage account name.
         */
        storageAccount?: string;
    }
}

export namespace search {
    /**
     * Identity for the resource.
     */
    export interface IdentityResponse {
        /**
         * The principal ID of resource identity.
         */
        principalId: string;
        /**
         * The tenant ID of resource.
         */
        tenantId: string;
        /**
         * The identity type.
         */
        type: string;
    }

    /**
     * The IP restriction rule of the Azure Cognitive Search service.
     */
    export interface IpRuleResponse {
        /**
         * Value corresponding to a single IPv4 address (eg., 123.1.2.3) or an IP range in CIDR format (eg., 123.1.2.3/24) to be allowed.
         */
        value?: string;
    }

    /**
     * Network specific rules that determine how the Azure Cognitive Search service may be reached.
     */
    export interface NetworkRuleSetResponse {
        /**
         * A list of IP restriction rules that defines the inbound network(s) with allowing access to the search service endpoint. At the meantime, all other public IP networks are blocked by the firewall. These restriction rules are applied only when the 'publicNetworkAccess' of the search service is 'enabled'; otherwise, traffic over public interface is not allowed even with any public IP rules, and private endpoint connections would be the exclusive access method.
         */
        ipRules?: outputs.search.IpRuleResponse[];
    }

    /**
     * Describes the properties of an existing Private Endpoint connection to the Azure Cognitive Search service.
     */
    export interface PrivateEndpointConnectionPropertiesResponse {
        /**
         * The private endpoint resource from Microsoft.Network provider.
         */
        privateEndpoint?: outputs.search.PrivateEndpointConnectionPropertiesResponseProperties;
        /**
         * Describes the current state of an existing Private Link Service connection to the Azure Private Endpoint.
         */
        privateLinkServiceConnectionState?: outputs.search.PrivateEndpointConnectionPropertiesResponseProperties;
    }

    /**
     * The private endpoint resource from Microsoft.Network provider.
     */
    export interface PrivateEndpointConnectionPropertiesResponseProperties {
        /**
         * The resource id of the private endpoint resource from Microsoft.Network provider.
         */
        id?: string;
    }

    /**
     * Describes an existing Private Endpoint connection to the Azure Cognitive Search service.
     */
    export interface PrivateEndpointConnectionResponse {
        /**
         * The ID of the private endpoint connection. This can be used with the Azure Resource Manager to link resources together.
         */
        id: string;
        /**
         * The name of the private endpoint connection.
         */
        name: string;
        /**
         * Describes the properties of an existing Private Endpoint connection to the Azure Cognitive Search service.
         */
        properties?: outputs.search.PrivateEndpointConnectionPropertiesResponse;
        /**
         * The resource type.
         */
        type: string;
    }

    /**
     * Describes an API key for a given Azure Cognitive Search service that has permissions for query operations only.
     */
    export interface QueryKeyResponse {
        /**
         * The value of the query API key.
         */
        key: string;
        /**
         * The name of the query API key; may be empty.
         */
        name: string;
    }

    /**
     * Properties of the Search service.
     */
    export interface SearchServicePropertiesResponse {
        /**
         * Applicable only for the standard3 SKU. You can set this property to enable up to 3 high density partitions that allow up to 1000 indexes, which is much higher than the maximum indexes allowed for any other SKU. For the standard3 SKU, the value is either 'default' or 'highDensity'. For all other SKUs, this value must be 'default'.
         */
        hostingMode?: string;
        /**
         * Network specific rules that determine how the Azure Cognitive Search service may be reached.
         */
        networkRuleSet?: outputs.search.NetworkRuleSetResponse;
        /**
         * The number of partitions in the Search service; if specified, it can be 1, 2, 3, 4, 6, or 12. Values greater than 1 are only valid for standard SKUs. For 'standard3' services with hostingMode set to 'highDensity', the allowed values are between 1 and 3.
         */
        partitionCount?: number;
        /**
         * The list of private endpoint connections to the Azure Cognitive Search service.
         */
        privateEndpointConnections: outputs.search.PrivateEndpointConnectionResponse[];
        /**
         * The state of the last provisioning operation performed on the Search service. Provisioning is an intermediate state that occurs while service capacity is being established. After capacity is set up, provisioningState changes to either 'succeeded' or 'failed'. Client applications can poll provisioning status (the recommended polling interval is from 30 seconds to one minute) by using the Get Search Service operation to see when an operation is completed. If you are using the free service, this value tends to come back as 'succeeded' directly in the call to Create Search service. This is because the free service uses capacity that is already set up.
         */
        provisioningState: string;
        /**
         * This value can be set to 'enabled' to avoid breaking changes on existing customer resources and templates. If set to 'disabled', traffic over public interface is not allowed, and private endpoint connections would be the exclusive access method.
         */
        publicNetworkAccess?: string;
        /**
         * The number of replicas in the Search service. If specified, it must be a value between 1 and 12 inclusive for standard SKUs or between 1 and 3 inclusive for basic SKU.
         */
        replicaCount?: number;
        /**
         * The list of shared private link resources managed by the Azure Cognitive Search service.
         */
        sharedPrivateLinkResources: outputs.search.SharedPrivateLinkResourceResponse[];
        /**
         * The status of the Search service. Possible values include: 'running': The Search service is running and no provisioning operations are underway. 'provisioning': The Search service is being provisioned or scaled up or down. 'deleting': The Search service is being deleted. 'degraded': The Search service is degraded. This can occur when the underlying search units are not healthy. The Search service is most likely operational, but performance might be slow and some requests might be dropped. 'disabled': The Search service is disabled. In this state, the service will reject all API requests. 'error': The Search service is in an error state. If your service is in the degraded, disabled, or error states, it means the Azure Cognitive Search team is actively investigating the underlying issue. Dedicated services in these states are still chargeable based on the number of search units provisioned.
         */
        status: string;
        /**
         * The details of the Search service status.
         */
        statusDetails: string;
    }

    /**
     * Describes the properties of an existing Shared Private Link Resource managed by the Azure Cognitive Search service.
     */
    export interface SharedPrivateLinkResourcePropertiesResponse {
        /**
         * The group id from the provider of resource the shared private link resource is for.
         */
        groupId?: string;
        /**
         * The resource id of the resource the shared private link resource is for.
         */
        privateLinkResourceId?: string;
        /**
         * The request message for requesting approval of the shared private link resource.
         */
        requestMessage?: string;
        /**
         * Status of the shared private link resource. Can be Pending, Approved, Rejected, Disconnected, or Timeout.
         */
        status?: string;
    }

    /**
     * Describes a Shared Private Link Resource managed by the Azure Cognitive Search service.
     */
    export interface SharedPrivateLinkResourceResponse {
        /**
         * The ID of the shared private link resource.
         */
        id: string;
        /**
         * The name of the shared private link resource.
         */
        name: string;
        /**
         * Describes the properties of a Shared Private Link Resource managed by the Azure Cognitive Search service.
         */
        properties?: outputs.search.SharedPrivateLinkResourcePropertiesResponse;
        /**
         * The resource type.
         */
        type: string;
    }

    /**
     * Defines the SKU of an Azure Cognitive Search Service, which determines price tier and capacity limits.
     */
    export interface SkuResponse {
        /**
         * The SKU of the Search service. Valid values include: 'free': Shared service. 'basic': Dedicated service with up to 3 replicas. 'standard': Dedicated service with up to 12 partitions and 12 replicas. 'standard2': Similar to standard, but with more capacity per search unit. 'standard3': The largest Standard offering with up to 12 partitions and 12 replicas (or up to 3 partitions with more indexes if you also set the hostingMode property to 'highDensity'). 'storage_optimized_l1': Supports 1TB per partition, up to 12 partitions. 'storage_optimized_l2': Supports 2TB per partition, up to 12 partitions.'
         */
        name?: string;
    }
}

export namespace security {
    /**
     * Security Solution setting data
     */
    export interface IoTSecuritySolutionPropertiesResponse {
        /**
         * List of resources that were automatically discovered as relevant to the security solution.
         */
        autoDiscoveredResources: string[];
        /**
         * Disabled data sources. Disabling these data sources compromises the system.
         */
        disabledDataSources?: string[];
        /**
         * Resource display name.
         */
        displayName: string;
        /**
         * List of additional options for exporting to workspace data.
         */
        export?: string[];
        /**
         * IoT Hub resource IDs
         */
        iotHubs: string[];
        /**
         * List of the configuration status for each recommendation type.
         */
        recommendationsConfiguration?: outputs.security.RecommendationConfigurationListResponse;
        /**
         * Status of the IoT Security solution.
         */
        status?: string;
        /**
         * Unmasked IP address logging status
         */
        unmaskedIpLoggingStatus?: string;
        /**
         * Properties of the IoT Security solution's user defined resources.
         */
        userDefinedResources?: outputs.security.UserDefinedResourcesPropertiesResponse;
        /**
         * Workspace resource ID
         */
        workspace?: string;
    }

    export interface JitNetworkAccessPolicyPropertiesResponse {
        /**
         * Gets the provisioning state of the Just-in-Time policy.
         */
        provisioningState: string;
        requests?: outputs.security.JitNetworkAccessRequestResponse[];
        /**
         * Configurations for Microsoft.Compute/virtualMachines resource type.
         */
        virtualMachines: outputs.security.JitNetworkAccessPolicyVirtualMachineResponse[];
    }

    export interface JitNetworkAccessPolicyVirtualMachineResponse {
        /**
         * Resource ID of the virtual machine that is linked to this policy
         */
        id: string;
        /**
         * Port configurations for the virtual machine
         */
        ports: outputs.security.JitNetworkAccessPortRuleResponse[];
        /**
         * Public IP address of the Azure Firewall that is linked to this policy, if applicable
         */
        publicIpAddress?: string;
    }

    export interface JitNetworkAccessPortRuleResponse {
        /**
         * Mutually exclusive with the "allowedSourceAddressPrefixes" parameter. Should be an IP address or CIDR, for example "192.168.0.3" or "192.168.0.0/16".
         */
        allowedSourceAddressPrefix?: string;
        /**
         * Mutually exclusive with the "allowedSourceAddressPrefix" parameter.
         */
        allowedSourceAddressPrefixes?: string[];
        /**
         * Maximum duration requests can be made for. In ISO 8601 duration format. Minimum 5 minutes, maximum 1 day
         */
        maxRequestAccessDuration: string;
        number: outputs.security.PortNumberResponse;
        protocol: string;
    }

    export interface JitNetworkAccessRequestPortResponse {
        /**
         * Mutually exclusive with the "allowedSourceAddressPrefixes" parameter. Should be an IP address or CIDR, for example "192.168.0.3" or "192.168.0.0/16".
         */
        allowedSourceAddressPrefix?: string;
        /**
         * Mutually exclusive with the "allowedSourceAddressPrefix" parameter.
         */
        allowedSourceAddressPrefixes?: string[];
        /**
         * The date & time at which the request ends in UTC
         */
        endTimeUtc: string;
        /**
         * The port which is mapped to this port's `number` in the Azure Firewall, if applicable
         */
        mappedPort?: number;
        number: outputs.security.PortNumberResponse;
        /**
         * The status of the port
         */
        status: string;
        /**
         * A description of why the `status` has its value
         */
        statusReason: string;
    }

    export interface JitNetworkAccessRequestResponse {
        /**
         * The justification for making the initiate request
         */
        justification?: string;
        /**
         * The identity of the person who made the request
         */
        requestor: string;
        /**
         * The start time of the request in UTC
         */
        startTimeUtc: string;
        virtualMachines: outputs.security.JitNetworkAccessRequestVirtualMachineResponse[];
    }

    export interface JitNetworkAccessRequestVirtualMachineResponse {
        /**
         * Resource ID of the virtual machine that is linked to this policy
         */
        id: string;
        /**
         * The ports that were opened for the virtual machine
         */
        ports: outputs.security.JitNetworkAccessRequestPortResponse[];
    }

    export interface PortNumberResponse {
    }

    /**
     * List of the configuration status for each recommendation type.
     */
    export interface RecommendationConfigurationListResponse {
    }

    /**
     * Properties of the IoT Security solution's user defined resources.
     */
    export interface UserDefinedResourcesPropertiesResponse {
        /**
         * Azure Resource Graph query which represents the security solution's user defined resources. Required to start with "where type != "Microsoft.Devices/IotHubs""
         */
        query: string;
        /**
         * List of Azure subscription ids on which the user defined resources query should be executed.
         */
        querySubscriptions: string[];
    }
}

export namespace servicebus {
    /**
     * Represents the filter actions which are allowed for the transformation of a message that have been matched by a filter expression.
     */
    export interface ActionResponse {
        /**
         * This property is reserved for future use. An integer value showing the compatibility level, currently hard-coded to 20.
         */
        compatibilityLevel?: number;
        /**
         * Value that indicates whether the rule action requires preprocessing.
         */
        requiresPreprocessing?: boolean;
        /**
         * SQL expression. e.g. MyProperty='ABC'
         */
        sqlExpression?: string;
    }

    /**
     * Properties required to the Create Or Update Alias(Disaster Recovery configurations)
     */
    export interface ArmDisasterRecoveryResponseProperties {
        /**
         * Primary/Secondary eventhub namespace name, which is part of GEO DR pairing
         */
        alternateName?: string;
        /**
         * ARM Id of the Primary/Secondary eventhub namespace name, which is part of GEO DR pairing
         */
        partnerNamespace?: string;
        /**
         * Number of entities pending to be replicated.
         */
        pendingReplicationOperationsCount: number;
        /**
         * Provisioning state of the Alias(Disaster Recovery configuration) - possible values 'Accepted' or 'Succeeded' or 'Failed'
         */
        provisioningState: string;
        /**
         * role of namespace in GEO DR - possible values 'Primary' or 'PrimaryNotReplicating' or 'Secondary'
         */
        role: string;
    }

    /**
     * Represents the correlation filter expression.
     */
    export interface CorrelationFilterResponse {
        /**
         * Content type of the message.
         */
        contentType?: string;
        /**
         * Identifier of the correlation.
         */
        correlationId?: string;
        /**
         * Application specific label.
         */
        label?: string;
        /**
         * Identifier of the message.
         */
        messageId?: string;
        /**
         * dictionary object for custom filters
         */
        properties?: {[key: string]: string};
        /**
         * Address of the queue to reply to.
         */
        replyTo?: string;
        /**
         * Session identifier to reply to.
         */
        replyToSessionId?: string;
        /**
         * Value that indicates whether the rule action requires preprocessing.
         */
        requiresPreprocessing?: boolean;
        /**
         * Session identifier.
         */
        sessionId?: string;
        /**
         * Address to send to.
         */
        to?: string;
    }

    /**
     * Message Count Details.
     */
    export interface MessageCountDetailsResponse {
        /**
         * Number of active messages in the queue, topic, or subscription.
         */
        activeMessageCount: number;
        /**
         * Number of messages that are dead lettered.
         */
        deadLetterMessageCount: number;
        /**
         * Number of scheduled messages.
         */
        scheduledMessageCount: number;
        /**
         * Number of messages transferred into dead letters.
         */
        transferDeadLetterMessageCount: number;
        /**
         * Number of messages transferred to another queue, topic, or subscription.
         */
        transferMessageCount: number;
    }

    /**
     * Properties required to the Create Migration Configuration
     */
    export interface MigrationConfigPropertiesResponseProperties {
        /**
         * State in which Standard to Premium Migration is, possible values : Unknown, Reverting, Completing, Initiating, Syncing, Active
         */
        migrationState: string;
        /**
         * Number of entities pending to be replicated.
         */
        pendingReplicationOperationsCount: number;
        /**
         * Name to access Standard Namespace after migration
         */
        postMigrationName: string;
        /**
         * Provisioning state of Migration Configuration 
         */
        provisioningState: string;
        /**
         * Existing premium Namespace ARM Id name which has no entities, will be used for migration
         */
        targetNamespace: string;
    }

    /**
     * Description of Rule Resource.
     */
    export interface RulepropertiesResponse {
        /**
         * Represents the filter actions which are allowed for the transformation of a message that have been matched by a filter expression.
         */
        action?: outputs.servicebus.ActionResponse;
        /**
         * Properties of correlationFilter
         */
        correlationFilter?: outputs.servicebus.CorrelationFilterResponse;
        /**
         * Filter type that is evaluated against a BrokeredMessage.
         */
        filterType?: string;
        /**
         * Properties of sqlFilter
         */
        sqlFilter?: outputs.servicebus.SqlFilterResponse;
    }

    /**
     * AuthorizationRule properties.
     */
    export interface SBAuthorizationRuleResponseProperties {
        /**
         * The rights associated with the rule.
         */
        rights: string[];
    }

    /**
     * Properties of the namespace.
     */
    export interface SBNamespacePropertiesResponse {
        /**
         * The time the namespace was created.
         */
        createdAt: string;
        /**
         * Identifier for Azure Insights metrics
         */
        metricId: string;
        /**
         * Provisioning state of the namespace.
         */
        provisioningState: string;
        /**
         * Endpoint you can use to perform Service Bus operations.
         */
        serviceBusEndpoint: string;
        /**
         * The time the namespace was updated.
         */
        updatedAt: string;
    }

    /**
     * The Queue Properties definition.
     */
    export interface SBQueuePropertiesResponse {
        /**
         * Last time a message was sent, or the last time there was a receive request to this queue.
         */
        accessedAt: string;
        /**
         * ISO 8061 timeSpan idle interval after which the queue is automatically deleted. The minimum duration is 5 minutes.
         */
        autoDeleteOnIdle?: string;
        /**
         * Message Count Details.
         */
        countDetails: outputs.servicebus.MessageCountDetailsResponse;
        /**
         * The exact time the message was created.
         */
        createdAt: string;
        /**
         * A value that indicates whether this queue has dead letter support when a message expires.
         */
        deadLetteringOnMessageExpiration?: boolean;
        /**
         * ISO 8601 default message timespan to live value. This is the duration after which the message expires, starting from when the message is sent to Service Bus. This is the default value used when TimeToLive is not set on a message itself.
         */
        defaultMessageTimeToLive?: string;
        /**
         * ISO 8601 timeSpan structure that defines the duration of the duplicate detection history. The default value is 10 minutes.
         */
        duplicateDetectionHistoryTimeWindow?: string;
        /**
         * Value that indicates whether server-side batched operations are enabled.
         */
        enableBatchedOperations?: boolean;
        /**
         * A value that indicates whether Express Entities are enabled. An express queue holds a message in memory temporarily before writing it to persistent storage.
         */
        enableExpress?: boolean;
        /**
         * A value that indicates whether the queue is to be partitioned across multiple message brokers.
         */
        enablePartitioning?: boolean;
        /**
         * Queue/Topic name to forward the Dead Letter message
         */
        forwardDeadLetteredMessagesTo?: string;
        /**
         * Queue/Topic name to forward the messages
         */
        forwardTo?: string;
        /**
         * ISO 8601 timespan duration of a peek-lock; that is, the amount of time that the message is locked for other receivers. The maximum value for LockDuration is 5 minutes; the default value is 1 minute.
         */
        lockDuration?: string;
        /**
         * The maximum delivery count. A message is automatically deadlettered after this number of deliveries. default value is 10.
         */
        maxDeliveryCount?: number;
        /**
         * The maximum size of the queue in megabytes, which is the size of memory allocated for the queue. Default is 1024.
         */
        maxSizeInMegabytes?: number;
        /**
         * The number of messages in the queue.
         */
        messageCount: number;
        /**
         * A value indicating if this queue requires duplicate detection.
         */
        requiresDuplicateDetection?: boolean;
        /**
         * A value that indicates whether the queue supports the concept of sessions.
         */
        requiresSession?: boolean;
        /**
         * The size of the queue, in bytes.
         */
        sizeInBytes: number;
        /**
         * Enumerates the possible values for the status of a messaging entity.
         */
        status?: string;
        /**
         * The exact time the message was updated.
         */
        updatedAt: string;
    }

    /**
     * SKU of the namespace.
     */
    export interface SBSkuResponse {
        /**
         * The specified messaging units for the tier. For Premium tier, capacity are 1,2 and 4.
         */
        capacity?: number;
        /**
         * Name of this SKU.
         */
        name: string;
        /**
         * The billing tier of this particular SKU.
         */
        tier?: string;
    }

    /**
     * Description of Subscription Resource.
     */
    export interface SBSubscriptionPropertiesResponse {
        /**
         * Last time there was a receive request to this subscription.
         */
        accessedAt: string;
        /**
         * ISO 8061 timeSpan idle interval after which the topic is automatically deleted. The minimum duration is 5 minutes.
         */
        autoDeleteOnIdle?: string;
        /**
         * Message count details
         */
        countDetails: outputs.servicebus.MessageCountDetailsResponse;
        /**
         * Exact time the message was created.
         */
        createdAt: string;
        /**
         * Value that indicates whether a subscription has dead letter support on filter evaluation exceptions.
         */
        deadLetteringOnFilterEvaluationExceptions?: boolean;
        /**
         * Value that indicates whether a subscription has dead letter support when a message expires.
         */
        deadLetteringOnMessageExpiration?: boolean;
        /**
         * ISO 8061 Default message timespan to live value. This is the duration after which the message expires, starting from when the message is sent to Service Bus. This is the default value used when TimeToLive is not set on a message itself.
         */
        defaultMessageTimeToLive?: string;
        /**
         * ISO 8601 timeSpan structure that defines the duration of the duplicate detection history. The default value is 10 minutes.
         */
        duplicateDetectionHistoryTimeWindow?: string;
        /**
         * Value that indicates whether server-side batched operations are enabled.
         */
        enableBatchedOperations?: boolean;
        /**
         * Queue/Topic name to forward the Dead Letter message
         */
        forwardDeadLetteredMessagesTo?: string;
        /**
         * Queue/Topic name to forward the messages
         */
        forwardTo?: string;
        /**
         * ISO 8061 lock duration timespan for the subscription. The default value is 1 minute.
         */
        lockDuration?: string;
        /**
         * Number of maximum deliveries.
         */
        maxDeliveryCount?: number;
        /**
         * Number of messages.
         */
        messageCount: number;
        /**
         * Value indicating if a subscription supports the concept of sessions.
         */
        requiresSession?: boolean;
        /**
         * Enumerates the possible values for the status of a messaging entity.
         */
        status?: string;
        /**
         * The exact time the message was updated.
         */
        updatedAt: string;
    }

    /**
     * The Topic Properties definition.
     */
    export interface SBTopicPropertiesResponse {
        /**
         * Last time the message was sent, or a request was received, for this topic.
         */
        accessedAt: string;
        /**
         * ISO 8601 timespan idle interval after which the topic is automatically deleted. The minimum duration is 5 minutes.
         */
        autoDeleteOnIdle?: string;
        /**
         * Message count details
         */
        countDetails: outputs.servicebus.MessageCountDetailsResponse;
        /**
         * Exact time the message was created.
         */
        createdAt: string;
        /**
         * ISO 8601 Default message timespan to live value. This is the duration after which the message expires, starting from when the message is sent to Service Bus. This is the default value used when TimeToLive is not set on a message itself.
         */
        defaultMessageTimeToLive?: string;
        /**
         * ISO8601 timespan structure that defines the duration of the duplicate detection history. The default value is 10 minutes.
         */
        duplicateDetectionHistoryTimeWindow?: string;
        /**
         * Value that indicates whether server-side batched operations are enabled.
         */
        enableBatchedOperations?: boolean;
        /**
         * Value that indicates whether Express Entities are enabled. An express topic holds a message in memory temporarily before writing it to persistent storage.
         */
        enableExpress?: boolean;
        /**
         * Value that indicates whether the topic to be partitioned across multiple message brokers is enabled.
         */
        enablePartitioning?: boolean;
        /**
         * Maximum size of the topic in megabytes, which is the size of the memory allocated for the topic. Default is 1024.
         */
        maxSizeInMegabytes?: number;
        /**
         * Value indicating if this topic requires duplicate detection.
         */
        requiresDuplicateDetection?: boolean;
        /**
         * Size of the topic, in bytes.
         */
        sizeInBytes: number;
        /**
         * Enumerates the possible values for the status of a messaging entity.
         */
        status?: string;
        /**
         * Number of subscriptions.
         */
        subscriptionCount: number;
        /**
         * Value that indicates whether the topic supports ordering.
         */
        supportOrdering?: boolean;
        /**
         * The exact time the message was updated.
         */
        updatedAt: string;
    }

    /**
     * Represents a filter which is a composition of an expression and an action that is executed in the pub/sub pipeline.
     */
    export interface SqlFilterResponse {
        /**
         * This property is reserved for future use. An integer value showing the compatibility level, currently hard-coded to 20.
         */
        compatibilityLevel?: number;
        /**
         * Value that indicates whether the rule action requires preprocessing.
         */
        requiresPreprocessing?: boolean;
        /**
         * The SQL expression. e.g. MyProperty='ABC'
         */
        sqlExpression?: string;
    }
}

export namespace servicefabric {
    /**
     * Defines a map that contains specific application delta health policies for different applications.
     * Each entry specifies as key the application name and as value an ApplicationDeltaHealthPolicy used to evaluate the application health when upgrading the cluster.
     * The application name should include the 'fabric:' URI scheme.
     * The map is empty by default.
     */
    export interface ApplicationDeltaHealthPolicyMapResponse {
    }

    /**
     * Defines a map that contains specific application health policies for different applications.
     * Each entry specifies as key the application name and as value an ApplicationHealthPolicy used to evaluate the application health.
     * The application name should include the 'fabric:' URI scheme.
     * The map is empty by default.
     */
    export interface ApplicationHealthPolicyMapResponse {
    }

    /**
     * List of application capacity metric description.
     */
    export interface ApplicationMetricDescriptionListResponse {
    }

    /**
     * List of application parameters with overridden values from their default values specified in the application manifest.
     */
    export interface ApplicationParameterListResponse {
    }

    /**
     * The application resource properties.
     */
    export interface ApplicationResourcePropertiesResponse {
        /**
         * List of user assigned identities for the application, each mapped to a friendly name.
         */
        managedIdentities?: outputs.servicefabric.ApplicationUserAssignedIdentityResponse[];
        /**
         * The maximum number of nodes where Service Fabric will reserve capacity for this application. Note that this does not mean that the services of this application will be placed on all of those nodes. By default, the value of this property is zero and it means that the services can be placed on any node.
         */
        maximumNodes?: number;
        /**
         * List of application capacity metric description.
         */
        metrics?: outputs.servicefabric.ApplicationMetricDescriptionListResponse;
        /**
         * The minimum number of nodes where Service Fabric will reserve capacity for this application. Note that this does not mean that the services of this application will be placed on all of those nodes. If this property is set to zero, no capacity will be reserved. The value of this property cannot be more than the value of the MaximumNodes property.
         */
        minimumNodes?: number;
        /**
         * List of application parameters with overridden values from their default values specified in the application manifest.
         */
        parameters?: outputs.servicefabric.ApplicationParameterListResponse;
        /**
         * The current deployment or provisioning state, which only appears in the response
         */
        provisioningState: string;
        /**
         * Remove the current application capacity settings.
         */
        removeApplicationCapacity?: boolean;
        /**
         * The application type name as defined in the application manifest.
         */
        typeName?: string;
        /**
         * The version of the application type as defined in the application manifest.
         */
        typeVersion?: string;
        /**
         * Describes the policy for a monitored application upgrade.
         */
        upgradePolicy?: outputs.servicefabric.ApplicationUpgradePolicyResponse;
    }

    /**
     * List of application type parameters that can be overridden when creating or updating the application.
     */
    export interface ApplicationTypeParameterListResponse {
    }

    /**
     * The application type name properties
     */
    export interface ApplicationTypeResourcePropertiesResponse {
        /**
         * The current deployment or provisioning state, which only appears in the response.
         */
        provisioningState: string;
    }

    /**
     * The properties of the application type version resource.
     */
    export interface ApplicationTypeVersionResourcePropertiesResponse {
        /**
         * The URL to the application package
         */
        appPackageUrl: string;
        /**
         * List of application type parameters that can be overridden when creating or updating the application.
         */
        defaultParameterList: outputs.servicefabric.ApplicationTypeParameterListResponse;
        /**
         * The current deployment or provisioning state, which only appears in the response
         */
        provisioningState: string;
    }

    export interface ApplicationTypeVersionsCleanupPolicyResponse {
        /**
         * Number of unused versions per application type to keep.
         */
        maxUnusedVersionsToKeep: number;
    }

    /**
     * Describes the policy for a monitored application upgrade.
     */
    export interface ApplicationUpgradePolicyResponse {
        /**
         * Defines a health policy used to evaluate the health of an application or one of its children entities.
         */
        applicationHealthPolicy?: outputs.servicefabric.ArmApplicationHealthPolicyResponse;
        /**
         * If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
         */
        forceRestart?: outputs.servicefabric.ForceRestartResponse;
        /**
         * The policy used for monitoring the application upgrade
         */
        rollingUpgradeMonitoringPolicy?: outputs.servicefabric.ArmRollingUpgradeMonitoringPolicyResponse;
        /**
         * The mode used to monitor health during a rolling upgrade. The values are UnmonitoredAuto, UnmonitoredManual, and Monitored.
         */
        upgradeMode?: string;
        /**
         * The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
         */
        upgradeReplicaSetCheckTimeout?: string;
    }

    export interface ApplicationUserAssignedIdentityResponse {
        /**
         * The friendly name of user assigned identity.
         */
        name: string;
        /**
         * The principal id of user assigned identity.
         */
        principalId: string;
    }

    /**
     * Defines a health policy used to evaluate the health of an application or one of its children entities.
     */
    export interface ArmApplicationHealthPolicyResponse {
        /**
         * Indicates whether warnings are treated with the same severity as errors.
         */
        considerWarningAsError?: boolean;
        /**
         * The health policy used by default to evaluate the health of a service type.
         */
        defaultServiceTypeHealthPolicy?: outputs.servicefabric.ArmServiceTypeHealthPolicyResponse;
        /**
         * The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
         * The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
         * This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
         * The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
         */
        maxPercentUnhealthyDeployedApplications?: number;
        /**
         * The map with service type health policy per service type name. The map is empty by default.
         */
        serviceTypeHealthPolicyMap?: outputs.servicefabric.ArmServiceTypeHealthPolicyMapResponse;
    }

    /**
     * The policy used for monitoring the application upgrade
     */
    export interface ArmRollingUpgradeMonitoringPolicyResponse {
        /**
         * The activation Mode of the service package
         */
        failureAction?: string;
        /**
         * The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.
         */
        healthCheckRetryTimeout?: string;
        /**
         * The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.
         */
        healthCheckStableDuration?: string;
        /**
         * The amount of time to wait after completing an upgrade domain before applying health policies. It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.
         */
        healthCheckWaitDuration?: string;
        /**
         * The amount of time each upgrade domain has to complete before FailureAction is executed. It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.
         */
        upgradeDomainTimeout?: string;
        /**
         * The amount of time the overall upgrade has to complete before FailureAction is executed. It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.
         */
        upgradeTimeout?: string;
    }

    /**
     * Defines a ServiceTypeHealthPolicy per service type name.
     *
     * The entries in the map replace the default service type health policy for each specified service type.
     * For example, in an application that contains both a stateless gateway service type and a stateful engine service type, the health policies for the stateless and stateful services can be configured differently.
     * With policy per service type, there's more granular control of the health of the service.
     *
     * If no policy is specified for a service type name, the DefaultServiceTypeHealthPolicy is used for evaluation.
     */
    export interface ArmServiceTypeHealthPolicyMapResponse {
    }

    /**
     * Represents the health policy used to evaluate the health of services belonging to a service type.
     */
    export interface ArmServiceTypeHealthPolicyResponse {
        /**
         * The maximum percentage of partitions per service allowed to be unhealthy before your application is considered in error.
         */
        maxPercentUnhealthyPartitionsPerService?: number;
        /**
         * The maximum percentage of replicas per partition allowed to be unhealthy before your application is considered in error.
         */
        maxPercentUnhealthyReplicasPerPartition?: number;
        /**
         * The maximum percentage of services allowed to be unhealthy before your application is considered in error.
         */
        maxPercentUnhealthyServices?: number;
    }

    /**
     * The settings to enable AAD authentication on the cluster.
     */
    export interface AzureActiveDirectoryResponse {
        /**
         * Azure active directory client application id.
         */
        clientApplication?: string;
        /**
         * Azure active directory cluster application id.
         */
        clusterApplication?: string;
        /**
         * Azure active directory tenant id.
         */
        tenantId?: string;
    }

    /**
     * Describes the certificate details.
     */
    export interface CertificateDescriptionResponse {
        /**
         * Thumbprint of the primary certificate.
         */
        thumbprint: string;
        /**
         * Thumbprint of the secondary certificate.
         */
        thumbprintSecondary?: string;
        /**
         * The local certificate store location.
         */
        x509StoreName?: string;
    }

    /**
     * Describes the client certificate details using common name.
     */
    export interface ClientCertificateCommonNameResponse {
        /**
         * The common name of the client certificate.
         */
        certificateCommonName: string;
        /**
         * The issuer thumbprint of the client certificate.
         */
        certificateIssuerThumbprint: string;
        /**
         * Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
         */
        isAdmin: boolean;
    }

    /**
     * Describes the client certificate details using thumbprint.
     */
    export interface ClientCertificateThumbprintResponse {
        /**
         * The thumbprint of the client certificate.
         */
        certificateThumbprint: string;
        /**
         * Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
         */
        isAdmin: boolean;
    }

    /**
     * Defines a health policy used to evaluate the health of the cluster or of a cluster node.
     */
    export interface ClusterHealthPolicyResponse {
        /**
         * Defines the application health policy map used to evaluate the health of an application or one of its children entities.
         */
        applicationHealthPolicies?: outputs.servicefabric.ApplicationHealthPolicyMapResponse;
        /**
         * The maximum allowed percentage of unhealthy applications before reporting an error. For example, to allow 10% of applications to be unhealthy, this value would be 10.
         *
         * The percentage represents the maximum tolerated percentage of applications that can be unhealthy before the cluster is considered in error.
         * If the percentage is respected but there is at least one unhealthy application, the health is evaluated as Warning.
         * This is calculated by dividing the number of unhealthy applications over the total number of application instances in the cluster, excluding applications of application types that are included in the ApplicationTypeHealthPolicyMap.
         * The computation rounds up to tolerate one failure on small numbers of applications. Default percentage is zero.
         */
        maxPercentUnhealthyApplications?: number;
        /**
         * The maximum allowed percentage of unhealthy nodes before reporting an error. For example, to allow 10% of nodes to be unhealthy, this value would be 10.
         *
         * The percentage represents the maximum tolerated percentage of nodes that can be unhealthy before the cluster is considered in error.
         * If the percentage is respected but there is at least one unhealthy node, the health is evaluated as Warning.
         * The percentage is calculated by dividing the number of unhealthy nodes over the total number of nodes in the cluster.
         * The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
         *
         * In large clusters, some nodes will always be down or out for repairs, so this percentage should be configured to tolerate that.
         */
        maxPercentUnhealthyNodes?: number;
    }

    /**
     * Describes the cluster resource properties.
     */
    export interface ClusterPropertiesResponse {
        /**
         * The list of add-on features to enable in the cluster.
         */
        addOnFeatures?: string[];
        /**
         * The policy used to clean up unused versions.
         */
        applicationTypeVersionsCleanupPolicy?: outputs.servicefabric.ApplicationTypeVersionsCleanupPolicyResponse;
        /**
         * The Service Fabric runtime versions available for this cluster.
         */
        availableClusterVersions: outputs.servicefabric.ClusterVersionDetailsResponse[];
        /**
         * The AAD authentication settings of the cluster.
         */
        azureActiveDirectory?: outputs.servicefabric.AzureActiveDirectoryResponse;
        /**
         * The certificate to use for securing the cluster. The certificate provided will be used for node to node security within the cluster, SSL certificate for cluster management endpoint and default admin client.
         */
        certificate?: outputs.servicefabric.CertificateDescriptionResponse;
        /**
         * Describes a list of server certificates referenced by common name that are used to secure the cluster.
         */
        certificateCommonNames?: outputs.servicefabric.ServerCertificateCommonNamesResponse;
        /**
         * The list of client certificates referenced by common name that are allowed to manage the cluster.
         */
        clientCertificateCommonNames?: outputs.servicefabric.ClientCertificateCommonNameResponse[];
        /**
         * The list of client certificates referenced by thumbprint that are allowed to manage the cluster.
         */
        clientCertificateThumbprints?: outputs.servicefabric.ClientCertificateThumbprintResponse[];
        /**
         * The Service Fabric runtime version of the cluster. This property can only by set the user when **upgradeMode** is set to 'Manual'. To get list of available Service Fabric versions for new clusters use [ClusterVersion API](./ClusterVersion.md). To get the list of available version for existing clusters use **availableClusterVersions**.
         */
        clusterCodeVersion?: string;
        /**
         * The Azure Resource Provider endpoint. A system service in the cluster connects to this  endpoint.
         */
        clusterEndpoint: string;
        /**
         * A service generated unique identifier for the cluster resource.
         */
        clusterId: string;
        /**
         * The current state of the cluster.
         *
         *   - WaitingForNodes - Indicates that the cluster resource is created and the resource provider is waiting for Service Fabric VM extension to boot up and report to it.
         *   - Deploying - Indicates that the Service Fabric runtime is being installed on the VMs. Cluster resource will be in this state until the cluster boots up and system services are up.
         *   - BaselineUpgrade - Indicates that the cluster is upgrading to establishes the cluster version. This upgrade is automatically initiated when the cluster boots up for the first time.
         *   - UpdatingUserConfiguration - Indicates that the cluster is being upgraded with the user provided configuration.
         *   - UpdatingUserCertificate - Indicates that the cluster is being upgraded with the user provided certificate.
         *   - UpdatingInfrastructure - Indicates that the cluster is being upgraded with the latest Service Fabric runtime version. This happens only when the **upgradeMode** is set to 'Automatic'.
         *   - EnforcingClusterVersion - Indicates that cluster is on a different version than expected and the cluster is being upgraded to the expected version.
         *   - UpgradeServiceUnreachable - Indicates that the system service in the cluster is no longer polling the Resource Provider. Clusters in this state cannot be managed by the Resource Provider.
         *   - AutoScale - Indicates that the ReliabilityLevel of the cluster is being adjusted.
         *   - Ready - Indicates that the cluster is in a stable state.
         */
        clusterState: string;
        /**
         * The storage account information for storing Service Fabric diagnostic logs.
         */
        diagnosticsStorageAccountConfig?: outputs.servicefabric.DiagnosticsStorageAccountConfigResponse;
        /**
         * Indicates if the event store service is enabled.
         */
        eventStoreServiceEnabled?: boolean;
        /**
         * The list of custom fabric settings to configure the cluster.
         */
        fabricSettings?: outputs.servicefabric.SettingsSectionDescriptionResponse[];
        /**
         * The http management endpoint of the cluster.
         */
        managementEndpoint: string;
        /**
         * The list of node types in the cluster.
         */
        nodeTypes: outputs.servicefabric.NodeTypeDescriptionResponse[];
        /**
         * The provisioning state of the cluster resource.
         */
        provisioningState: string;
        /**
         * The reliability level sets the replica set size of system services. Learn about [ReliabilityLevel](https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-capacity).
         *
         *   - None - Run the System services with a target replica set count of 1. This should only be used for test clusters.
         *   - Bronze - Run the System services with a target replica set count of 3. This should only be used for test clusters.
         *   - Silver - Run the System services with a target replica set count of 5.
         *   - Gold - Run the System services with a target replica set count of 7.
         *   - Platinum - Run the System services with a target replica set count of 9.
         */
        reliabilityLevel?: string;
        /**
         * The server certificate used by reverse proxy.
         */
        reverseProxyCertificate?: outputs.servicefabric.CertificateDescriptionResponse;
        /**
         * Describes a list of server certificates referenced by common name that are used to secure the cluster.
         */
        reverseProxyCertificateCommonNames?: outputs.servicefabric.ServerCertificateCommonNamesResponse;
        /**
         * The policy to use when upgrading the cluster.
         */
        upgradeDescription?: outputs.servicefabric.ClusterUpgradePolicyResponse;
        /**
         * The upgrade mode of the cluster when new Service Fabric runtime version is available.
         *
         *   - Automatic - The cluster will be automatically upgraded to the latest Service Fabric runtime version as soon as it is available.
         *   - Manual - The cluster will not be automatically upgraded to the latest Service Fabric runtime version. The cluster is upgraded by setting the **clusterCodeVersion** property in the cluster resource.
         */
        upgradeMode?: string;
        /**
         * The VM image VMSS has been configured with. Generic names such as Windows or Linux can be used.
         */
        vmImage?: string;
    }

    /**
     * Describes the delta health policies for the cluster upgrade.
     */
    export interface ClusterUpgradeDeltaHealthPolicyResponse {
        /**
         * Defines the application delta health policy map used to evaluate the health of an application or one of its child entities when upgrading the cluster.
         */
        applicationDeltaHealthPolicies?: outputs.servicefabric.ApplicationDeltaHealthPolicyMapResponse;
        /**
         * The maximum allowed percentage of applications health degradation allowed during cluster upgrades.
         * The delta is measured between the state of the applications at the beginning of upgrade and the state of the applications at the time of the health evaluation.
         * The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within tolerated limits. System services are not included in this.
         */
        maxPercentDeltaUnhealthyApplications: number;
        /**
         * The maximum allowed percentage of nodes health degradation allowed during cluster upgrades.
         * The delta is measured between the state of the nodes at the beginning of upgrade and the state of the nodes at the time of the health evaluation.
         * The check is performed after every upgrade domain upgrade completion to make sure the global state of the cluster is within tolerated limits.
         */
        maxPercentDeltaUnhealthyNodes: number;
        /**
         * The maximum allowed percentage of upgrade domain nodes health degradation allowed during cluster upgrades.
         * The delta is measured between the state of the upgrade domain nodes at the beginning of upgrade and the state of the upgrade domain nodes at the time of the health evaluation.
         * The check is performed after every upgrade domain upgrade completion for all completed upgrade domains to make sure the state of the upgrade domains is within tolerated limits.
         */
        maxPercentUpgradeDomainDeltaUnhealthyNodes: number;
    }

    /**
     * Describes the policy used when upgrading the cluster.
     */
    export interface ClusterUpgradePolicyResponse {
        /**
         * The cluster delta health policy used when upgrading the cluster.
         */
        deltaHealthPolicy?: outputs.servicefabric.ClusterUpgradeDeltaHealthPolicyResponse;
        /**
         * If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
         */
        forceRestart?: boolean;
        /**
         * The amount of time to retry health evaluation when the application or cluster is unhealthy before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
         */
        healthCheckRetryTimeout: string;
        /**
         * The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
         */
        healthCheckStableDuration: string;
        /**
         * The length of time to wait after completing an upgrade domain before performing health checks. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
         */
        healthCheckWaitDuration: string;
        /**
         * The cluster health policy used when upgrading the cluster.
         */
        healthPolicy: outputs.servicefabric.ClusterHealthPolicyResponse;
        /**
         * The amount of time each upgrade domain has to complete before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
         */
        upgradeDomainTimeout: string;
        /**
         * The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
         */
        upgradeReplicaSetCheckTimeout: string;
        /**
         * The amount of time the overall upgrade has to complete before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
         */
        upgradeTimeout: string;
    }

    /**
     * The detail of the Service Fabric runtime version result
     */
    export interface ClusterVersionDetailsResponse {
        /**
         * The Service Fabric runtime version of the cluster.
         */
        codeVersion?: string;
        /**
         * Indicates if this version is for Windows or Linux operating system.
         */
        environment?: string;
        /**
         * The date of expiry of support of the version.
         */
        supportExpiryUtc?: string;
    }

    /**
     * A list that describes the correlation of the service with other services.
     */
    export interface CorrelationSchemeListResponse {
    }

    /**
     * The storage account information for storing Service Fabric diagnostic logs.
     */
    export interface DiagnosticsStorageAccountConfigResponse {
        /**
         * The blob endpoint of the azure storage account.
         */
        blobEndpoint: string;
        /**
         * The protected diagnostics storage key name.
         */
        protectedAccountKeyName: string;
        /**
         * The secondary protected diagnostics storage key name. If one of the storage account keys is rotated the cluster will fallback to using the other.
         */
        protectedAccountKeyName2?: string;
        /**
         * The queue endpoint of the azure storage account.
         */
        queueEndpoint: string;
        /**
         * The Azure storage account name.
         */
        storageAccountName: string;
        /**
         * The table endpoint of the azure storage account.
         */
        tableEndpoint: string;
    }

    /**
     * Port range details
     */
    export interface EndpointRangeDescriptionResponse {
        /**
         * End port of a range of ports
         */
        endPort: number;
        /**
         * Starting port of a range of ports
         */
        startPort: number;
    }

    /**
     * If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
     */
    export interface ForceRestartResponse {
    }

    /**
     * Describes the managed identities for an Azure resource.
     */
    export interface ManagedIdentityResponse {
        /**
         * The principal id of the managed identity. This property will only be provided for a system assigned identity.
         */
        principalId: string;
        /**
         * The tenant id of the managed identity. This property will only be provided for a system assigned identity.
         */
        tenantId: string;
        /**
         * The type of managed identity for the resource.
         */
        type?: string;
        /**
         * The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
         * '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
         */
        userAssignedIdentities?: outputs.servicefabric.UserAssignedIdentityMapResponse;
    }

    /**
     * Describes a node type in the cluster, each node type represents sub set of nodes in the cluster.
     */
    export interface NodeTypeDescriptionResponse {
        /**
         * The range of ports from which cluster assigned port to Service Fabric applications.
         */
        applicationPorts?: outputs.servicefabric.EndpointRangeDescriptionResponse;
        /**
         * The capacity tags applied to the nodes in the node type, the cluster resource manager uses these tags to understand how much resource a node has.
         */
        capacities?: {[key: string]: string};
        /**
         * The TCP cluster management endpoint port.
         */
        clientConnectionEndpointPort: number;
        /**
         * The durability level of the node type. Learn about [DurabilityLevel](https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-capacity).
         *
         *   - Bronze - No privileges. This is the default.
         *   - Silver - The infrastructure jobs can be paused for a duration of 10 minutes per UD.
         *   - Gold - The infrastructure jobs can be paused for a duration of 2 hours per UD. Gold durability can be enabled only on full node VM skus like D15_V2, G5 etc.
         */
        durabilityLevel?: string;
        /**
         * The range of ephemeral ports that nodes in this node type should be configured with.
         */
        ephemeralPorts?: outputs.servicefabric.EndpointRangeDescriptionResponse;
        /**
         * The HTTP cluster management endpoint port.
         */
        httpGatewayEndpointPort: number;
        /**
         * The node type on which system services will run. Only one node type should be marked as primary. Primary node type cannot be deleted or changed for existing clusters.
         */
        isPrimary: boolean;
        /**
         * The name of the node type.
         */
        name: string;
        /**
         * The placement tags applied to nodes in the node type, which can be used to indicate where certain services (workload) should run.
         */
        placementProperties?: {[key: string]: string};
        /**
         * The endpoint used by reverse proxy.
         */
        reverseProxyEndpointPort?: number;
        /**
         * The number of nodes in the node type. This count should match the capacity property in the corresponding VirtualMachineScaleSet resource.
         */
        vmInstanceCount: number;
    }

    /**
     * Describes how the service is partitioned.
     */
    export interface PartitionSchemeDescriptionResponse {
        /**
         * Specifies how the service is partitioned.
         */
        partitionScheme: string;
    }

    /**
     * Describes the server certificate details using common name.
     */
    export interface ServerCertificateCommonNameResponse {
        /**
         * The common name of the server certificate.
         */
        certificateCommonName: string;
        /**
         * The issuer thumbprint of the server certificate.
         */
        certificateIssuerThumbprint: string;
    }

    /**
     * Describes a list of server certificates referenced by common name that are used to secure the cluster.
     */
    export interface ServerCertificateCommonNamesResponse {
        /**
         * The list of server certificates referenced by common name that are used to secure the cluster.
         */
        commonNames?: outputs.servicefabric.ServerCertificateCommonNameResponse[];
        /**
         * The local certificate store location.
         */
        x509StoreName?: string;
    }

    /**
     * The service load metrics is given as an array of ServiceLoadMetricDescription objects.
     */
    export interface ServiceLoadMetricsListResponse {
    }

    /**
     * A list that describes the correlation of the service with other services.
     */
    export interface ServicePlacementPoliciesListResponse {
    }

    /**
     * The service resource properties.
     */
    export interface ServiceResourcePropertiesResponse {
        /**
         * A list that describes the correlation of the service with other services.
         */
        correlationScheme?: outputs.servicefabric.CorrelationSchemeListResponse;
        /**
         * Specifies the move cost for the service.
         */
        defaultMoveCost?: string;
        /**
         * Describes how the service is partitioned.
         */
        partitionDescription?: outputs.servicefabric.PartitionSchemeDescriptionResponse;
        /**
         * The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
         */
        placementConstraints?: string;
        /**
         * The current deployment or provisioning state, which only appears in the response
         */
        provisioningState: string;
        /**
         * Dns name used for the service. If this is specified, then the service can be accessed via its DNS name instead of service name.
         */
        serviceDnsName?: string;
        /**
         * The kind of service (Stateless or Stateful).
         */
        serviceKind: string;
        /**
         * The service load metrics is given as an array of ServiceLoadMetricDescription objects.
         */
        serviceLoadMetrics?: outputs.servicefabric.ServiceLoadMetricsListResponse;
        /**
         * The activation Mode of the service package
         */
        servicePackageActivationMode?: string;
        /**
         * A list that describes the correlation of the service with other services.
         */
        servicePlacementPolicies?: outputs.servicefabric.ServicePlacementPoliciesListResponse;
        /**
         * The name of the service type
         */
        serviceTypeName?: string;
    }

    /**
     * Describes a parameter in fabric settings of the cluster.
     */
    export interface SettingsParameterDescriptionResponse {
        /**
         * The parameter name of fabric setting.
         */
        name: string;
        /**
         * The parameter value of fabric setting.
         */
        value: string;
    }

    /**
     * Describes a section in the fabric settings of the cluster.
     */
    export interface SettingsSectionDescriptionResponse {
        /**
         * The section name of the fabric settings.
         */
        name: string;
        /**
         * The collection of parameters in the section.
         */
        parameters: outputs.servicefabric.SettingsParameterDescriptionResponse[];
    }

    /**
     * The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
     * '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
     */
    export interface UserAssignedIdentityMapResponse {
    }
}

export namespace signalrservice {
    /**
     * Network ACL
     */
    export interface NetworkACLResponse {
        /**
         * Allowed request types. The value can be one or more of: ClientConnection, ServerConnection, RESTAPI.
         */
        allow?: string[];
        /**
         * Denied request types. The value can be one or more of: ClientConnection, ServerConnection, RESTAPI.
         */
        deny?: string[];
    }

    /**
     * ACL for a private endpoint
     */
    export interface PrivateEndpointACLResponse {
        /**
         * Allowed request types. The value can be one or more of: ClientConnection, ServerConnection, RESTAPI.
         */
        allow?: string[];
        /**
         * Denied request types. The value can be one or more of: ClientConnection, ServerConnection, RESTAPI.
         */
        deny?: string[];
        /**
         * Name of the private endpoint connection
         */
        name: string;
    }

    /**
     * Private endpoint connection properties
     */
    export interface PrivateEndpointConnectionPropertiesResponse {
        /**
         * Private endpoint associated with the private endpoint connection
         */
        privateEndpoint?: outputs.signalrservice.PrivateEndpointResponse;
        /**
         * Connection state
         */
        privateLinkServiceConnectionState?: outputs.signalrservice.PrivateLinkServiceConnectionStateResponse;
        /**
         * Provisioning state of the private endpoint connection
         */
        provisioningState: string;
    }

    /**
     * A private endpoint connection to SignalR resource
     */
    export interface PrivateEndpointConnectionResponse {
        /**
         * Fully qualified resource Id for the resource.
         */
        id: string;
        /**
         * The name of the resource.
         */
        name: string;
        /**
         * Properties of the private endpoint connection
         */
        properties?: outputs.signalrservice.PrivateEndpointConnectionPropertiesResponse;
        /**
         * The type of the resource - e.g. "Microsoft.SignalRService/SignalR"
         */
        type: string;
    }

    /**
     * Private endpoint
     */
    export interface PrivateEndpointResponse {
        /**
         * Full qualified Id of the private endpoint
         */
        id?: string;
    }

    /**
     * Connection state of the private endpoint connection
     */
    export interface PrivateLinkServiceConnectionStateResponse {
        /**
         * A message indicating if changes on the service provider require any updates on the consumer.
         */
        actionsRequired?: string;
        /**
         * The reason for approval/rejection of the connection.
         */
        description?: string;
        /**
         * Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
         */
        status?: string;
    }

    /**
     * The billing information of the SignalR resource.
     */
    export interface ResourceSkuResponse {
        /**
         * Optional, integer. The unit count of SignalR resource. 1 by default.
         * 
         * If present, following values are allowed:
         *     Free: 1
         *     Standard: 1,2,5,10,20,50,100
         */
        capacity?: number;
        /**
         * Optional string. For future use.
         */
        family?: string;
        /**
         * The name of the SKU. Required.
         * 
         * Allowed values: Standard_S1, Free_F1
         */
        name: string;
        /**
         * Optional string. For future use.
         */
        size?: string;
        /**
         * Optional tier of this particular SKU. 'Standard' or 'Free'. 
         * 
         * `Basic` is deprecated, use `Standard` instead.
         */
        tier?: string;
    }

    /**
     * The settings for the Upstream when the Azure SignalR is in server-less mode.
     */
    export interface ServerlessUpstreamSettingsResponse {
        /**
         * Gets or sets the list of Upstream URL templates. Order matters, and the first matching template takes effects.
         */
        templates?: outputs.signalrservice.UpstreamTemplateResponse[];
    }

    /**
     * Cross-Origin Resource Sharing (CORS) settings.
     */
    export interface SignalRCorsSettingsResponse {
        /**
         * Gets or sets the list of origins that should be allowed to make cross-origin calls (for example: http://example.com:12345). Use "*" to allow all. If omitted, allow all by default.
         */
        allowedOrigins?: string[];
    }

    /**
     * Feature of a SignalR resource, which controls the SignalR runtime behavior.
     */
    export interface SignalRFeatureResponse {
        /**
         * FeatureFlags is the supported features of Azure SignalR service.
         * - ServiceMode: Flag for backend server for SignalR service. Values allowed: "Default": have your own backend server; "Serverless": your application doesn't have a backend server; "Classic": for backward compatibility. Support both Default and Serverless mode but not recommended; "PredefinedOnly": for future use.
         * - EnableConnectivityLogs: "true"/"false", to enable/disable the connectivity log category respectively.
         */
        flag: string;
        /**
         * Optional properties related to this feature.
         */
        properties?: {[key: string]: string};
        /**
         * Value of the feature flag. See Azure SignalR service document https://docs.microsoft.com/azure/azure-signalr/ for allowed values.
         */
        value: string;
    }

    /**
     * Network ACLs for SignalR
     */
    export interface SignalRNetworkACLsResponse {
        /**
         * Default action when no other rule matches
         */
        defaultAction?: string;
        /**
         * ACLs for requests from private endpoints
         */
        privateEndpoints?: outputs.signalrservice.PrivateEndpointACLResponse[];
        /**
         * ACL for requests from public network
         */
        publicNetwork?: outputs.signalrservice.NetworkACLResponse;
    }

    /**
     * A class that describes the properties of the SignalR service that should contain more read-only properties than AzSignalR.Models.SignalRCreateOrUpdateProperties
     */
    export interface SignalRPropertiesResponse {
        /**
         * Cross-Origin Resource Sharing (CORS) settings.
         */
        cors?: outputs.signalrservice.SignalRCorsSettingsResponse;
        /**
         * The publicly accessible IP of the SignalR service.
         */
        externalIP: string;
        /**
         * List of SignalR featureFlags. e.g. ServiceMode.
         * 
         * FeatureFlags that are not included in the parameters for the update operation will not be modified.
         * And the response will only include featureFlags that are explicitly set. 
         * When a featureFlag is not explicitly set, SignalR service will use its globally default value. 
         * But keep in mind, the default value doesn't mean "false". It varies in terms of different FeatureFlags.
         */
        features?: outputs.signalrservice.SignalRFeatureResponse[];
        /**
         * FQDN of the SignalR service instance. Format: xxx.service.signalr.net
         */
        hostName: string;
        /**
         * Prefix for the hostName of the SignalR service. Retained for future use.
         * The hostname will be of format: &lt;hostNamePrefix&gt;.service.signalr.net.
         */
        hostNamePrefix?: string;
        /**
         * Network ACLs
         */
        networkACLs?: outputs.signalrservice.SignalRNetworkACLsResponse;
        /**
         * Private endpoint connections to the SignalR resource.
         */
        privateEndpointConnections: outputs.signalrservice.PrivateEndpointConnectionResponse[];
        /**
         * Provisioning state of the resource.
         */
        provisioningState: string;
        /**
         * The publicly accessible port of the SignalR service which is designed for browser/client side usage.
         */
        publicPort: number;
        /**
         * The publicly accessible port of the SignalR service which is designed for customer server side usage.
         */
        serverPort: number;
        /**
         * Upstream settings when the Azure SignalR is in server-less mode.
         */
        upstream?: outputs.signalrservice.ServerlessUpstreamSettingsResponse;
        /**
         * Version of the SignalR resource. Probably you need the same or higher version of client SDKs.
         */
        version: string;
    }

    /**
     * Upstream template item settings. It defines the Upstream URL of the incoming requests.
     * The template defines the pattern of the event, the hub or the category of the incoming request that matches current URL template.
     */
    export interface UpstreamTemplateResponse {
        /**
         * Gets or sets the matching pattern for category names. If not set, it matches any category.
         * There are 3 kind of patterns supported:
         *     1. "*", it to matches any category name
         *     2. Combine multiple categories with ",", for example "connections,messages", it matches category "connections" and "messages"
         *     3. The single category name, for example, "connections", it matches the category "connections"
         */
        categoryPattern?: string;
        /**
         * Gets or sets the matching pattern for event names. If not set, it matches any event.
         * There are 3 kind of patterns supported:
         *     1. "*", it to matches any event name
         *     2. Combine multiple events with ",", for example "connect,disconnect", it matches event "connect" and "disconnect"
         *     3. The single event name, for example, "connect", it matches "connect"
         */
        eventPattern?: string;
        /**
         * Gets or sets the matching pattern for hub names. If not set, it matches any hub.
         * There are 3 kind of patterns supported:
         *     1. "*", it to matches any hub name
         *     2. Combine multiple hubs with ",", for example "hub1,hub2", it matches "hub1" and "hub2"
         *     3. The single hub name, for example, "hub1", it matches "hub1"
         */
        hubPattern?: string;
        /**
         * Gets or sets the Upstream URL template. You can use 3 predefined parameters {hub}, {category} {event} inside the template, the value of the Upstream URL is dynamically calculated when the client request comes in.
         * For example, if the urlTemplate is `http://example.com/{hub}/api/{event}`, with a client request from hub `chat` connects, it will first POST to this URL: `http://example.com/chat/api/connect`.
         */
        urlTemplate: string;
    }
}

export namespace solutions {
    /**
     * Managed application artifact.
     */
    export interface ApplicationArtifactResponse {
        /**
         * The managed application artifact name.
         */
        name: string;
        /**
         * The managed application artifact type.
         */
        type: string;
        /**
         * The managed application artifact blob uri.
         */
        uri: string;
    }

    /**
     * The managed application provider authorization.
     */
    export interface ApplicationAuthorizationResponse {
        /**
         * The provider's principal identifier. This is the identity that the provider will use to call ARM to manage the managed application resources.
         */
        principalId: string;
        /**
         * The provider's role definition identifier. This role will define all the permissions that the provider must have on the managed application's container resource group. This role definition cannot have permission to delete the resource group.
         */
        roleDefinitionId: string;
    }

    /**
     * Managed application billing details definition.
     */
    export interface ApplicationBillingDetailsDefinitionResponse {
        /**
         * The managed application resource usage Id.
         */
        resourceUsageId?: string;
    }

    /**
     * The application client details to track the entity creating/updating the managed app resource.
     */
    export interface ApplicationClientDetailsResponse {
        /**
         * The client application Id.
         */
        applicationId?: string;
        /**
         * The client Oid.
         */
        oid?: string;
        /**
         * The client Puid
         */
        puid?: string;
    }

    /**
     * Application definition artifact.
     */
    export interface ApplicationDefinitionArtifactResponse {
        /**
         * The managed application definition artifact name.
         */
        name: string;
        /**
         * The managed application definition artifact type.
         */
        type: string;
        /**
         * The managed application definition artifact blob uri.
         */
        uri: string;
    }

    /**
     * The managed application definition properties.
     */
    export interface ApplicationDefinitionPropertiesResponse {
        /**
         * The collection of managed application artifacts. The portal will use the files specified as artifacts to construct the user experience of creating a managed application from a managed application definition.
         */
        artifacts?: outputs.solutions.ApplicationDefinitionArtifactResponse[];
        /**
         * The managed application provider authorizations.
         */
        authorizations?: outputs.solutions.ApplicationAuthorizationResponse[];
        /**
         * The createUiDefinition json for the backing template with Microsoft.Solutions/applications resource. It can be a JObject or well-formed JSON string.
         */
        createUiDefinition?: {[key: string]: string};
        /**
         * The managed application deployment policy.
         */
        deploymentPolicy?: outputs.solutions.ApplicationDeploymentPolicyResponse;
        /**
         * The managed application definition description.
         */
        description?: string;
        /**
         * The managed application definition display name.
         */
        displayName?: string;
        /**
         * A value indicating whether the package is enabled or not.
         */
        isEnabled?: boolean;
        /**
         * The managed application lock level.
         */
        lockLevel: string;
        /**
         * The managed application locking policy.
         */
        lockingPolicy?: outputs.solutions.ApplicationPackageLockingPolicyDefinitionResponse;
        /**
         * The inline main template json which has resources to be provisioned. It can be a JObject or well-formed JSON string.
         */
        mainTemplate?: {[key: string]: string};
        /**
         * The managed application management policy that determines publisher's access to the managed resource group.
         */
        managementPolicy?: outputs.solutions.ApplicationManagementPolicyResponse;
        /**
         * The managed application notification policy.
         */
        notificationPolicy?: outputs.solutions.ApplicationNotificationPolicyResponse;
        /**
         * The managed application definition package file Uri. Use this element
         */
        packageFileUri?: string;
        /**
         * The managed application provider policies.
         */
        policies?: outputs.solutions.ApplicationPolicyResponse[];
    }

    /**
     * Managed application deployment policy.
     */
    export interface ApplicationDeploymentPolicyResponse {
        /**
         * The managed application deployment mode.
         */
        deploymentMode: string;
    }

    /**
     * Managed application Jit access policy.
     */
    export interface ApplicationJitAccessPolicyResponse {
        /**
         * Whether the JIT access is enabled.
         */
        jitAccessEnabled: boolean;
        /**
         * JIT approval mode.
         */
        jitApprovalMode?: string;
        /**
         * The JIT approvers
         */
        jitApprovers?: outputs.solutions.JitApproverDefinitionResponse[];
        /**
         * The maximum duration JIT access is granted. This is an ISO8601 time period value.
         */
        maximumJitAccessDuration?: string;
    }

    /**
     * Managed application management policy.
     */
    export interface ApplicationManagementPolicyResponse {
        /**
         * The managed application management mode.
         */
        mode?: string;
    }

    /**
     * Managed application notification endpoint.
     */
    export interface ApplicationNotificationEndpointResponse {
        /**
         * The managed application notification endpoint uri.
         */
        uri: string;
    }

    /**
     * Managed application notification policy.
     */
    export interface ApplicationNotificationPolicyResponse {
        /**
         * The managed application notification endpoint.
         */
        notificationEndpoints: outputs.solutions.ApplicationNotificationEndpointResponse[];
    }

    /**
     * The application package contact information.
     */
    export interface ApplicationPackageContactResponse {
        /**
         * The contact name.
         */
        contactName?: string;
        /**
         * The contact email.
         */
        email: string;
        /**
         * The contact phone number.
         */
        phone: string;
    }

    /**
     * Managed application locking policy.
     */
    export interface ApplicationPackageLockingPolicyDefinitionResponse {
        /**
         * The deny assignment excluded actions.
         */
        allowedActions?: string[];
    }

    /**
     * The appliance package support URLs.
     */
    export interface ApplicationPackageSupportUrlsResponse {
        /**
         * The government cloud support URL.
         */
        governmentCloud?: string;
        /**
         * The public azure support URL.
         */
        publicAzure?: string;
    }

    /**
     * Managed application policy.
     */
    export interface ApplicationPolicyResponse {
        /**
         * The policy name
         */
        name?: string;
        /**
         * The policy parameters.
         */
        parameters?: string;
        /**
         * The policy definition Id.
         */
        policyDefinitionId?: string;
    }

    /**
     * The managed application properties.
     */
    export interface ApplicationPropertiesResponse {
        /**
         * The fully qualified path of managed application definition Id.
         */
        applicationDefinitionId?: string;
        /**
         * The collection of managed application artifacts.
         */
        artifacts: outputs.solutions.ApplicationArtifactResponse[];
        /**
         * The  read-only authorizations property that is retrieved from the application package.
         */
        authorizations: outputs.solutions.ApplicationAuthorizationResponse[];
        /**
         * The managed application billing details.
         */
        billingDetails: outputs.solutions.ApplicationBillingDetailsDefinitionResponse;
        /**
         * The client entity that created the JIT request.
         */
        createdBy: outputs.solutions.ApplicationClientDetailsResponse;
        /**
         * The read-only customer support property that is retrieved from the application package.
         */
        customerSupport: outputs.solutions.ApplicationPackageContactResponse;
        /**
         * The managed application Jit access policy.
         */
        jitAccessPolicy?: outputs.solutions.ApplicationJitAccessPolicyResponse;
        /**
         * The managed resource group Id.
         */
        managedResourceGroupId?: string;
        /**
         * The managed application management mode.
         */
        managementMode: string;
        /**
         * Name and value pairs that define the managed application outputs.
         */
        outputs: {[key: string]: string};
        /**
         * Name and value pairs that define the managed application parameters. It can be a JObject or a well formed JSON string.
         */
        parameters?: {[key: string]: string};
        /**
         * The managed application provisioning state.
         */
        provisioningState: string;
        /**
         * The publisher tenant Id.
         */
        publisherTenantId: string;
        /**
         * The read-only support URLs property that is retrieved from the application package.
         */
        supportUrls: outputs.solutions.ApplicationPackageSupportUrlsResponse;
        /**
         * The client entity that last updated the JIT request.
         */
        updatedBy: outputs.solutions.ApplicationClientDetailsResponse;
    }

    /**
     * Identity for the resource.
     */
    export interface IdentityResponse {
        /**
         * The principal ID of resource identity.
         */
        principalId: string;
        /**
         * The tenant ID of resource.
         */
        tenantId: string;
        /**
         * The identity type.
         */
        type?: string;
        /**
         * The list of user identities associated with the resource. The user identity dictionary key references will be resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
         */
        userAssignedIdentities?: {[key: string]: string};
    }

    /**
     * JIT approver definition.
     */
    export interface JitApproverDefinitionResponse {
        /**
         * The approver display name.
         */
        displayName?: string;
        /**
         * The approver service principal Id.
         */
        id: string;
        /**
         * The approver type.
         */
        type?: string;
    }

    /**
     * The JIT authorization policies.
     */
    export interface JitAuthorizationPoliciesResponse {
        /**
         * The the principal id that will be granted JIT access.
         */
        principalId: string;
        /**
         * The role definition id that will be granted to the Principal.
         */
        roleDefinitionId: string;
    }

    /**
     * Information about JIT request properties
     */
    export interface JitRequestPropertiesResponse {
        /**
         * The parent application id.
         */
        applicationResourceId: string;
        /**
         * The client entity that created the JIT request.
         */
        createdBy: outputs.solutions.ApplicationClientDetailsResponse;
        /**
         * The JIT authorization policies.
         */
        jitAuthorizationPolicies: outputs.solutions.JitAuthorizationPoliciesResponse[];
        /**
         * The JIT request state.
         */
        jitRequestState: string;
        /**
         * The JIT request properties.
         */
        jitSchedulingPolicy: outputs.solutions.JitSchedulingPolicyResponse;
        /**
         * The JIT request provisioning state.
         */
        provisioningState: string;
        /**
         * The publisher tenant id.
         */
        publisherTenantId: string;
        /**
         * The client entity that last updated the JIT request.
         */
        updatedBy: outputs.solutions.ApplicationClientDetailsResponse;
    }

    /**
     * The JIT scheduling policies.
     */
    export interface JitSchedulingPolicyResponse {
        duration: string;
        /**
         * The start time of the request.
         */
        startTime: string;
        /**
         * The type of JIT schedule.
         */
        type: string;
    }

    /**
     * Plan for the managed application.
     */
    export interface PlanResponse {
        /**
         * The plan name.
         */
        name: string;
        /**
         * The product code.
         */
        product: string;
        /**
         * The promotion code.
         */
        promotionCode?: string;
        /**
         * The publisher ID.
         */
        publisher: string;
        /**
         * The plan's version.
         */
        version: string;
    }

    /**
     * SKU for the resource.
     */
    export interface SkuResponse {
        /**
         * The SKU capacity.
         */
        capacity?: number;
        /**
         * The SKU family.
         */
        family?: string;
        /**
         * The SKU model.
         */
        model?: string;
        /**
         * The SKU name.
         */
        name: string;
        /**
         * The SKU size.
         */
        size?: string;
        /**
         * The SKU tier.
         */
        tier?: string;
    }
}

export namespace sql {
    /**
     * Represents the properties of a database.
     */
    export interface DatabasePropertiesResponse {
        /**
         * The collation of the database. If createMode is not Default, this value is ignored.
         */
        collation?: string;
        /**
         * The containment state of the database.
         */
        containmentState: number;
        /**
         * Specifies the mode of database creation.
         *
         * Default: regular database creation.
         *
         * Copy: creates a database as a copy of an existing database. sourceDatabaseId must be specified as the resource ID of the source database.
         *
         * OnlineSecondary/NonReadableSecondary: creates a database as a (readable or nonreadable) secondary replica of an existing database. sourceDatabaseId must be specified as the resource ID of the existing primary database.
         *
         * PointInTimeRestore: Creates a database by restoring a point in time backup of an existing database. sourceDatabaseId must be specified as the resource ID of the existing database, and restorePointInTime must be specified.
         *
         * Recovery: Creates a database by restoring a geo-replicated backup. sourceDatabaseId must be specified as the recoverable database resource ID to restore.
         *
         * Restore: Creates a database by restoring a backup of a deleted database. sourceDatabaseId must be specified. If sourceDatabaseId is the database's original resource ID, then sourceDatabaseDeletionDate must be specified. Otherwise sourceDatabaseId must be the restorable dropped database resource ID and sourceDatabaseDeletionDate is ignored. restorePointInTime may also be specified to restore from an earlier point in time.
         *
         * RestoreLongTermRetentionBackup: Creates a database by restoring from a long term retention vault. recoveryServicesRecoveryPointResourceId must be specified as the recovery point resource ID.
         *
         * Copy, NonReadableSecondary, OnlineSecondary and RestoreLongTermRetentionBackup are not supported for DataWarehouse edition.
         */
        createMode?: string;
        /**
         * The creation date of the database (ISO8601 format).
         */
        creationDate: string;
        /**
         * The current service level objective ID of the database. This is the ID of the service level objective that is currently active.
         */
        currentServiceObjectiveId: string;
        /**
         * The ID of the database.
         */
        databaseId: string;
        /**
         * The default secondary region for this database.
         */
        defaultSecondaryLocation: string;
        /**
         * This records the earliest start date and time that restore is available for this database (ISO8601 format).
         */
        earliestRestoreDate: string;
        /**
         * The edition of the database. The DatabaseEditions enumeration contains all the valid editions. If createMode is NonReadableSecondary or OnlineSecondary, this value is ignored.
         * 
         * The list of SKUs may vary by region and support offer. To determine the SKUs (including the SKU name, tier/edition, family, and capacity) that are available to your subscription in an Azure region, use the `Capabilities_ListByLocation` REST API or one of the following commands:
         * 
         * ```azurecli
         * az sql db list-editions -l <location> -o table
         * ````
         * 
         * ```powershell
         * Get-AzSqlServerServiceObjective -Location <location>
         * ````
         */
        edition?: string;
        /**
         * The name of the elastic pool the database is in. If elasticPoolName and requestedServiceObjectiveName are both updated, the value of requestedServiceObjectiveName is ignored. Not supported for DataWarehouse edition.
         */
        elasticPoolName?: string;
        /**
         * The resource identifier of the failover group containing this database.
         */
        failoverGroupId: string;
        /**
         * The max size of the database expressed in bytes. If createMode is not Default, this value is ignored. To see possible values, query the capabilities API (/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationID}/capabilities) referred to by operationId: "Capabilities_ListByLocation."
         */
        maxSizeBytes?: string;
        /**
         * Conditional. If the database is a geo-secondary, readScale indicates whether read-only connections are allowed to this database or not. Not supported for DataWarehouse edition.
         */
        readScale?: string;
        /**
         * The recommended indices for this database.
         */
        recommendedIndex: outputs.sql.RecommendedIndexResponse[];
        /**
         * Conditional. If createMode is RestoreLongTermRetentionBackup, then this value is required. Specifies the resource ID of the recovery point to restore from.
         */
        recoveryServicesRecoveryPointResourceId?: string;
        /**
         * The configured service level objective ID of the database. This is the service level objective that is in the process of being applied to the database. Once successfully updated, it will match the value of currentServiceObjectiveId property. If requestedServiceObjectiveId and requestedServiceObjectiveName are both updated, the value of requestedServiceObjectiveId overrides the value of requestedServiceObjectiveName.
         * 
         * The list of SKUs may vary by region and support offer. To determine the service objective ids that are available to your subscription in an Azure region, use the `Capabilities_ListByLocation` REST API.
         */
        requestedServiceObjectiveId?: string;
        /**
         * The name of the configured service level objective of the database. This is the service level objective that is in the process of being applied to the database. Once successfully updated, it will match the value of serviceLevelObjective property. 
         * 
         * The list of SKUs may vary by region and support offer. To determine the SKUs (including the SKU name, tier/edition, family, and capacity) that are available to your subscription in an Azure region, use the `Capabilities_ListByLocation` REST API or one of the following commands:
         * 
         * ```azurecli
         * az sql db list-editions -l <location> -o table
         * ````
         * 
         * ```powershell
         * Get-AzSqlServerServiceObjective -Location <location>
         * ````
         */
        requestedServiceObjectiveName?: string;
        /**
         * Conditional. If createMode is PointInTimeRestore, this value is required. If createMode is Restore, this value is optional. Specifies the point in time (ISO8601 format) of the source database that will be restored to create the new database. Must be greater than or equal to the source database's earliestRestoreDate value.
         */
        restorePointInTime?: string;
        /**
         * Indicates the name of the sample schema to apply when creating this database. If createMode is not Default, this value is ignored. Not supported for DataWarehouse edition.
         */
        sampleName?: string;
        /**
         * The current service level objective of the database.
         */
        serviceLevelObjective: string;
        /**
         * The list of service tier advisors for this database. Expanded property
         */
        serviceTierAdvisors: outputs.sql.ServiceTierAdvisorResponse[];
        /**
         * Conditional. If createMode is Restore and sourceDatabaseId is the deleted database's original resource id when it existed (as opposed to its current restorable dropped database id), then this value is required. Specifies the time that the database was deleted.
         */
        sourceDatabaseDeletionDate?: string;
        /**
         * Conditional. If createMode is Copy, NonReadableSecondary, OnlineSecondary, PointInTimeRestore, Recovery, or Restore, then this value is required. Specifies the resource ID of the source database. If createMode is NonReadableSecondary or OnlineSecondary, the name of the source database must be the same as the new database being created.
         */
        sourceDatabaseId?: string;
        /**
         * The status of the database.
         */
        status: string;
        /**
         * The transparent data encryption info for this database.
         */
        transparentDataEncryption: outputs.sql.TransparentDataEncryptionResponse[];
        /**
         * Whether or not this database is zone redundant, which means the replicas of this database will be spread across multiple availability zones.
         */
        zoneRedundant?: boolean;
    }

    /**
     * Represents the properties of a disaster recovery configuration.
     */
    export interface DisasterRecoveryConfigurationPropertiesResponse {
        /**
         * Whether or not failover can be done automatically.
         */
        autoFailover: string;
        /**
         * How aggressive the automatic failover should be.
         */
        failoverPolicy: string;
        /**
         * Logical name of the server.
         */
        logicalServerName: string;
        /**
         * Logical name of the partner server.
         */
        partnerLogicalServerName: string;
        /**
         * Id of the partner server.
         */
        partnerServerId: string;
        /**
         * The role of the current server in the disaster recovery configuration.
         */
        role: string;
        /**
         * The status of the disaster recovery configuration.
         */
        status: string;
    }

    /**
     * Represents the properties of an elastic pool.
     */
    export interface ElasticPoolPropertiesResponse {
        /**
         * The creation date of the elastic pool (ISO8601 format).
         */
        creationDate: string;
        /**
         * The maximum DTU any one database can consume.
         */
        databaseDtuMax?: number;
        /**
         * The minimum DTU all databases are guaranteed.
         */
        databaseDtuMin?: number;
        /**
         * The total shared DTU for the database elastic pool.
         */
        dtu?: number;
        /**
         * The edition of the elastic pool.
         */
        edition?: string;
        /**
         * The state of the elastic pool.
         */
        state: string;
        /**
         * Gets storage limit for the database elastic pool in MB.
         */
        storageMB?: number;
        /**
         * Whether or not this database elastic pool is zone redundant, which means the replicas of this database will be spread across multiple availability zones.
         */
        zoneRedundant?: boolean;
    }

    /**
     * Represents the properties of a server firewall rule.
     */
    export interface FirewallRulePropertiesResponse {
        /**
         * The end IP address of the firewall rule. Must be IPv4 format. Must be greater than or equal to startIpAddress. Use value '0.0.0.0' to represent all Azure-internal IP addresses.
         */
        endIpAddress: string;
        /**
         * The start IP address of the firewall rule. Must be IPv4 format. Use value '0.0.0.0' to represent all Azure-internal IP addresses.
         */
        startIpAddress: string;
    }

    /**
     * The impact of an operation, both in absolute and relative terms.
     */
    export interface OperationImpactResponse {
        /**
         * The absolute impact to dimension.
         */
        changeValueAbsolute: number;
        /**
         * The relative impact to dimension (null if not applicable)
         */
        changeValueRelative: number;
        /**
         * The name of the impact dimension.
         */
        name: string;
        /**
         * The unit in which estimated impact to dimension is measured.
         */
        unit: string;
    }

    /**
     * Represents the properties of a database recommended index.
     */
    export interface RecommendedIndexPropertiesResponse {
        /**
         * The proposed index action. You can create a missing index, drop an unused index, or rebuild an existing index to improve its performance.
         */
        action: string;
        /**
         * Columns over which to build index
         */
        columns: string[];
        /**
         * The UTC datetime showing when this resource was created (ISO8601 format).
         */
        created: string;
        /**
         * The estimated impact of doing recommended index action.
         */
        estimatedImpact: outputs.sql.OperationImpactResponse[];
        /**
         * The list of column names to be included in the index
         */
        includedColumns: string[];
        /**
         * The full build index script
         */
        indexScript: string;
        /**
         * The type of index (CLUSTERED, NONCLUSTERED, COLUMNSTORE, CLUSTERED COLUMNSTORE)
         */
        indexType: string;
        /**
         * The UTC datetime of when was this resource last changed (ISO8601 format).
         */
        lastModified: string;
        /**
         * The values reported after index action is complete.
         */
        reportedImpact: outputs.sql.OperationImpactResponse[];
        /**
         * The schema where table to build index over resides
         */
        schema: string;
        /**
         * The current recommendation state.
         */
        state: string;
        /**
         * The table on which to build index.
         */
        table: string;
    }

    /**
     * Represents a database recommended index.
     */
    export interface RecommendedIndexResponse {
        /**
         * Resource ID.
         */
        id: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * The properties representing the resource.
         */
        properties: outputs.sql.RecommendedIndexPropertiesResponse;
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * The properties of an server Administrator.
     */
    export interface ServerAdministratorPropertiesResponse {
        /**
         * The type of administrator.
         */
        administratorType: string;
        /**
         * The server administrator login value.
         */
        login: string;
        /**
         * The server administrator Sid (Secure ID).
         */
        sid: string;
        /**
         * The server Active Directory Administrator tenant id.
         */
        tenantId: string;
    }

    /**
     * The properties of a server communication link.
     */
    export interface ServerCommunicationLinkPropertiesResponse {
        /**
         * The name of the partner server.
         */
        partnerServer: string;
        /**
         * The state.
         */
        state: string;
    }

    /**
     * Represents the properties of a server.
     */
    export interface ServerPropertiesResponse {
        /**
         * Administrator username for the server. Can only be specified when the server is being created (and is required for creation).
         */
        administratorLogin?: string;
        /**
         * The administrator login password (required for server creation).
         */
        administratorLoginPassword?: string;
        /**
         * The display name of the Azure Active Directory object with admin permissions on this server. Legacy parameter, always null. To check for Active Directory admin, query .../servers/{serverName}/administrators
         */
        externalAdministratorLogin: string;
        /**
         * The ID of the Active Azure Directory object with admin permissions on this server. Legacy parameter, always null. To check for Active Directory admin, query .../servers/{serverName}/administrators.
         */
        externalAdministratorSid: string;
        /**
         * The fully qualified domain name of the server.
         */
        fullyQualifiedDomainName: string;
        /**
         * The state of the server.
         */
        state: string;
        /**
         * The version of the server.
         */
        version?: string;
    }

    /**
     * Represents the properties of a Service Tier Advisor.
     */
    export interface ServiceTierAdvisorPropertiesResponse {
        /**
         * The activeTimeRatio for service tier advisor.
         */
        activeTimeRatio: number;
        /**
         * Gets or sets avgDtu for service tier advisor.
         */
        avgDtu: number;
        /**
         * Gets or sets confidence for service tier advisor.
         */
        confidence: number;
        /**
         * Gets or sets currentServiceLevelObjective for service tier advisor.
         */
        currentServiceLevelObjective: string;
        /**
         * Gets or sets currentServiceLevelObjectiveId for service tier advisor.
         */
        currentServiceLevelObjectiveId: string;
        /**
         * Gets or sets databaseSizeBasedRecommendationServiceLevelObjective for service tier advisor.
         */
        databaseSizeBasedRecommendationServiceLevelObjective: string;
        /**
         * Gets or sets databaseSizeBasedRecommendationServiceLevelObjectiveId for service tier advisor.
         */
        databaseSizeBasedRecommendationServiceLevelObjectiveId: string;
        /**
         * Gets or sets disasterPlanBasedRecommendationServiceLevelObjective for service tier advisor.
         */
        disasterPlanBasedRecommendationServiceLevelObjective: string;
        /**
         * Gets or sets disasterPlanBasedRecommendationServiceLevelObjectiveId for service tier advisor.
         */
        disasterPlanBasedRecommendationServiceLevelObjectiveId: string;
        /**
         * Gets or sets maxDtu for service tier advisor.
         */
        maxDtu: number;
        /**
         * Gets or sets maxSizeInGB for service tier advisor.
         */
        maxSizeInGB: number;
        /**
         * Gets or sets minDtu for service tier advisor.
         */
        minDtu: number;
        /**
         * The observation period start (ISO8601 format).
         */
        observationPeriodEnd: string;
        /**
         * The observation period start (ISO8601 format).
         */
        observationPeriodStart: string;
        /**
         * Gets or sets overallRecommendationServiceLevelObjective for service tier advisor.
         */
        overallRecommendationServiceLevelObjective: string;
        /**
         * Gets or sets overallRecommendationServiceLevelObjectiveId for service tier advisor.
         */
        overallRecommendationServiceLevelObjectiveId: string;
        /**
         * Gets or sets serviceLevelObjectiveUsageMetrics for the service tier advisor.
         */
        serviceLevelObjectiveUsageMetrics: outputs.sql.SloUsageMetricResponse[];
        /**
         * Gets or sets usageBasedRecommendationServiceLevelObjective for service tier advisor.
         */
        usageBasedRecommendationServiceLevelObjective: string;
        /**
         * Gets or sets usageBasedRecommendationServiceLevelObjectiveId for service tier advisor.
         */
        usageBasedRecommendationServiceLevelObjectiveId: string;
    }

    /**
     * Represents a Service Tier Advisor.
     */
    export interface ServiceTierAdvisorResponse {
        /**
         * Resource ID.
         */
        id: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * The properties representing the resource.
         */
        properties: outputs.sql.ServiceTierAdvisorPropertiesResponse;
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * A Slo Usage Metric.
     */
    export interface SloUsageMetricResponse {
        /**
         * Gets or sets inRangeTimeRatio for SLO usage metric.
         */
        inRangeTimeRatio: number;
        /**
         * The serviceLevelObjective for SLO usage metric.
         */
        serviceLevelObjective: string;
        /**
         * The serviceLevelObjectiveId for SLO usage metric.
         */
        serviceLevelObjectiveId: string;
    }

    /**
     * Represents the properties of a database transparent data encryption.
     */
    export interface TransparentDataEncryptionPropertiesResponse {
        /**
         * The status of the database transparent data encryption.
         */
        status?: string;
    }

    /**
     * Represents a database transparent data encryption configuration.
     */
    export interface TransparentDataEncryptionResponse {
        /**
         * Resource ID.
         */
        id: string;
        /**
         * Resource location.
         */
        location: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Represents the properties of the resource.
         */
        properties?: outputs.sql.TransparentDataEncryptionPropertiesResponse;
        /**
         * Resource type.
         */
        type: string;
    }
}

export namespace storage {
    /**
     * Settings properties for Active Directory (AD).
     */
    export interface ActiveDirectoryPropertiesResponse {
        /**
         * Specifies the security identifier (SID) for Azure Storage.
         */
        azureStorageSid: string;
        /**
         * Specifies the domain GUID.
         */
        domainGuid: string;
        /**
         * Specifies the primary domain that the AD DNS server is authoritative for.
         */
        domainName: string;
        /**
         * Specifies the security identifier (SID).
         */
        domainSid: string;
        /**
         * Specifies the Active Directory forest to get.
         */
        forestName: string;
        /**
         * Specifies the NetBIOS domain name.
         */
        netBiosDomainName: string;
    }

    /**
     * Settings for Azure Files identity based authentication.
     */
    export interface AzureFilesIdentityBasedAuthenticationResponse {
        /**
         * Required if choose AD.
         */
        activeDirectoryProperties?: outputs.storage.ActiveDirectoryPropertiesResponse;
        /**
         * Indicates the directory service used.
         */
        directoryServiceOptions: string;
    }

    /**
     * Blob restore parameters
     */
    export interface BlobRestoreParametersResponse {
        /**
         * Blob ranges to restore.
         */
        blobRanges: outputs.storage.BlobRestoreRangeResponse[];
        /**
         * Restore blob to the specified time.
         */
        timeToRestore: string;
    }

    /**
     * Blob range
     */
    export interface BlobRestoreRangeResponse {
        /**
         * Blob end range. This is exclusive. Empty means account end.
         */
        endRange: string;
        /**
         * Blob start range. This is inclusive. Empty means account start.
         */
        startRange: string;
    }

    /**
     * Blob restore status.
     */
    export interface BlobRestoreStatusResponse {
        /**
         * Failure reason when blob restore is failed.
         */
        failureReason: string;
        /**
         * Blob restore request parameters.
         */
        parameters: outputs.storage.BlobRestoreParametersResponse;
        /**
         * Id for tracking blob restore request.
         */
        restoreId: string;
        /**
         * The status of blob restore progress. Possible values are: - InProgress: Indicates that blob restore is ongoing. - Complete: Indicates that blob restore has been completed successfully. - Failed: Indicates that blob restore is failed.
         */
        status: string;
    }

    /**
     * The properties of a container.
     */
    export interface ContainerPropertiesResponse {
        /**
         * Default the container to use specified encryption scope for all writes.
         */
        defaultEncryptionScope?: string;
        /**
         * Indicates whether the blob container was deleted.
         */
        deleted: boolean;
        /**
         * Blob container deletion time.
         */
        deletedTime: string;
        /**
         * Block override of encryption scope from the container default.
         */
        denyEncryptionScopeOverride?: boolean;
        /**
         * The hasImmutabilityPolicy public property is set to true by SRP if ImmutabilityPolicy has been created for this container. The hasImmutabilityPolicy public property is set to false by SRP if ImmutabilityPolicy has not been created for this container.
         */
        hasImmutabilityPolicy: boolean;
        /**
         * The hasLegalHold public property is set to true by SRP if there are at least one existing tag. The hasLegalHold public property is set to false by SRP if all existing legal hold tags are cleared out. There can be a maximum of 1000 blob containers with hasLegalHold=true for a given account.
         */
        hasLegalHold: boolean;
        /**
         * The ImmutabilityPolicy property of the container.
         */
        immutabilityPolicy: outputs.storage.ImmutabilityPolicyPropertiesResponse;
        /**
         * Returns the date and time the container was last modified.
         */
        lastModifiedTime: string;
        /**
         * Specifies whether the lease on a container is of infinite or fixed duration, only when the container is leased.
         */
        leaseDuration: string;
        /**
         * Lease state of the container.
         */
        leaseState: string;
        /**
         * The lease status of the container.
         */
        leaseStatus: string;
        /**
         * The LegalHold property of the container.
         */
        legalHold: outputs.storage.LegalHoldPropertiesResponse;
        /**
         * A name-value pair to associate with the container as metadata.
         */
        metadata?: {[key: string]: string};
        /**
         * Specifies whether data in the container may be accessed publicly and the level of access.
         */
        publicAccess?: string;
        /**
         * Remaining retention days for soft deleted blob container.
         */
        remainingRetentionDays: number;
        /**
         * The version of the deleted blob container.
         */
        version: string;
    }

    /**
     * The custom domain assigned to this storage account. This can be set via Update.
     */
    export interface CustomDomainResponse {
        /**
         * Gets or sets the custom domain name assigned to the storage account. Name is the CNAME source.
         */
        name: string;
        /**
         * Indicates whether indirect CName validation is enabled. Default value is false. This should only be set on updates.
         */
        useSubDomainName?: boolean;
    }

    /**
     * Object to define the number of days after creation.
     */
    export interface DateAfterCreationResponse {
        /**
         * Value indicating the age in days after creation
         */
        daysAfterCreationGreaterThan: number;
    }

    /**
     * Object to define the number of days after last modification.
     */
    export interface DateAfterModificationResponse {
        /**
         * Value indicating the age in days after last modification
         */
        daysAfterModificationGreaterThan: number;
    }

    /**
     * The encryption settings on the storage account.
     */
    export interface EncryptionResponse {
        /**
         * The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault
         */
        keySource: string;
        /**
         * Properties provided by key vault.
         */
        keyvaultproperties?: outputs.storage.KeyVaultPropertiesResponse;
        /**
         * A boolean indicating whether or not the service applies a secondary layer of encryption with platform managed keys for data at rest.
         */
        requireInfrastructureEncryption?: boolean;
        /**
         * List of services which support encryption.
         */
        services?: outputs.storage.EncryptionServicesResponse;
    }

    /**
     * A service that allows server-side encryption to be used.
     */
    export interface EncryptionServiceResponse {
        /**
         * A boolean indicating whether or not the service encrypts the data as it is stored.
         */
        enabled?: boolean;
        /**
         * Encryption key type to be used for the encryption service. 'Account' key type implies that an account-scoped encryption key will be used. 'Service' key type implies that a default service key is used.
         */
        keyType?: string;
        /**
         * Gets a rough estimate of the date/time when the encryption was last enabled by the user. Only returned when encryption is enabled. There might be some unencrypted blobs which were written after this time, as it is just a rough estimate.
         */
        lastEnabledTime: string;
    }

    /**
     * A list of services that support encryption.
     */
    export interface EncryptionServicesResponse {
        /**
         * The encryption function of the blob storage service.
         */
        blob?: outputs.storage.EncryptionServiceResponse;
        /**
         * The encryption function of the file storage service.
         */
        file?: outputs.storage.EncryptionServiceResponse;
        /**
         * The encryption function of the queue storage service.
         */
        queue?: outputs.storage.EncryptionServiceResponse;
        /**
         * The encryption function of the table storage service.
         */
        table?: outputs.storage.EncryptionServiceResponse;
    }

    /**
     * The URIs that are used to perform a retrieval of a public blob, queue, table, web or dfs object.
     */
    export interface EndpointsResponse {
        /**
         * Gets the blob endpoint.
         */
        blob: string;
        /**
         * Gets the dfs endpoint.
         */
        dfs: string;
        /**
         * Gets the file endpoint.
         */
        file: string;
        /**
         * Gets the internet routing storage endpoints
         */
        internetEndpoints?: outputs.storage.StorageAccountInternetEndpointsResponse;
        /**
         * Gets the microsoft routing storage endpoints.
         */
        microsoftEndpoints?: outputs.storage.StorageAccountMicrosoftEndpointsResponse;
        /**
         * Gets the queue endpoint.
         */
        queue: string;
        /**
         * Gets the table endpoint.
         */
        table: string;
        /**
         * Gets the web endpoint.
         */
        web: string;
    }

    /**
     * The properties of the file share.
     */
    export interface FileSharePropertiesResponse {
        /**
         * Access tier for specific share. GpV2 account can choose between TransactionOptimized (default), Hot, and Cool. FileStorage account can choose Premium.
         */
        accessTier?: string;
        /**
         * Indicates the last modification time for share access tier.
         */
        accessTierChangeTime: string;
        /**
         * Indicates if there is a pending transition for access tier.
         */
        accessTierStatus: string;
        /**
         * Indicates whether the share was deleted.
         */
        deleted: boolean;
        /**
         * The deleted time if the share was deleted.
         */
        deletedTime: string;
        /**
         * The authentication protocol that is used for the file share. Can only be specified when creating a share.
         */
        enabledProtocols?: string;
        /**
         * Returns the date and time the share was last modified.
         */
        lastModifiedTime: string;
        /**
         * A name-value pair to associate with the share as metadata.
         */
        metadata?: {[key: string]: string};
        /**
         * Remaining retention days for share that was soft deleted.
         */
        remainingRetentionDays: number;
        /**
         * The property is for NFS share only. The default is NoRootSquash.
         */
        rootSquash?: string;
        /**
         * The maximum size of the share, in gigabytes. Must be greater than 0, and less than or equal to 5TB (5120). For Large File Shares, the maximum size is 102400.
         */
        shareQuota?: number;
        /**
         * The approximate size of the data stored on the share. Note that this value may not include all recently created or recently resized files.
         */
        shareUsageBytes: number;
        /**
         * The version of the share.
         */
        version: string;
    }

    /**
     * Statistics related to replication for storage account's Blob, Table, Queue and File services. It is only available when geo-redundant replication is enabled for the storage account.
     */
    export interface GeoReplicationStatsResponse {
        /**
         * A boolean flag which indicates whether or not account failover is supported for the account.
         */
        canFailover: boolean;
        /**
         * All primary writes preceding this UTC date/time value are guaranteed to be available for read operations. Primary writes following this point in time may or may not be available for reads. Element may be default value if value of LastSyncTime is not available, this can happen if secondary is offline or we are in bootstrap.
         */
        lastSyncTime: string;
        /**
         * The status of the secondary location. Possible values are: - Live: Indicates that the secondary location is active and operational. - Bootstrap: Indicates initial synchronization from the primary location to the secondary location is in progress.This typically occurs when replication is first enabled. - Unavailable: Indicates that the secondary location is temporarily unavailable.
         */
        status: string;
    }

    /**
     * IP rule with specific IP or IP range in CIDR format.
     */
    export interface IPRuleResponse {
        /**
         * The action of IP ACL rule.
         */
        action?: string;
        /**
         * Specifies the IP or IP range in CIDR format. Only IPV4 address is allowed.
         */
        value: string;
    }

    /**
     * Identity for the resource.
     */
    export interface IdentityResponse {
        /**
         * The principal ID of resource identity.
         */
        principalId: string;
        /**
         * The tenant ID of resource.
         */
        tenantId: string;
        /**
         * The identity type.
         */
        type: string;
    }

    /**
     * The properties of an ImmutabilityPolicy of a blob container.
     */
    export interface ImmutabilityPolicyPropertiesResponse {
        /**
         * ImmutabilityPolicy Etag.
         */
        etag: string;
        /**
         * The properties of an ImmutabilityPolicy of a blob container.
         */
        properties?: outputs.storage.ImmutabilityPolicyPropertyResponse;
        /**
         * The ImmutabilityPolicy update history of the blob container.
         */
        updateHistory: outputs.storage.UpdateHistoryPropertyResponse[];
    }

    /**
     * The properties of an ImmutabilityPolicy of a blob container.
     */
    export interface ImmutabilityPolicyPropertyResponse {
        /**
         * This property can only be changed for unlocked time-based retention policies. When enabled, new blocks can be written to an append blob while maintaining immutability protection and compliance. Only new blocks can be added and any existing blocks cannot be modified or deleted. This property cannot be changed with ExtendImmutabilityPolicy API
         */
        allowProtectedAppendWrites?: boolean;
        /**
         * The immutability period for the blobs in the container since the policy creation, in days.
         */
        immutabilityPeriodSinceCreationInDays?: number;
        /**
         * The ImmutabilityPolicy state of a blob container, possible values include: Locked and Unlocked.
         */
        state: string;
    }

    /**
     * Properties of key vault.
     */
    export interface KeyVaultPropertiesResponse {
        /**
         * The object identifier of the current versioned Key Vault Key in use.
         */
        currentVersionedKeyIdentifier: string;
        /**
         * The name of KeyVault key.
         */
        keyname?: string;
        /**
         * The Uri of KeyVault.
         */
        keyvaulturi?: string;
        /**
         * The version of KeyVault key.
         */
        keyversion?: string;
        /**
         * Timestamp of last rotation of the Key Vault Key.
         */
        lastKeyRotationTimestamp: string;
    }

    /**
     * The LegalHold property of a blob container.
     */
    export interface LegalHoldPropertiesResponse {
        /**
         * The hasLegalHold public property is set to true by SRP if there are at least one existing tag. The hasLegalHold public property is set to false by SRP if all existing legal hold tags are cleared out. There can be a maximum of 1000 blob containers with hasLegalHold=true for a given account.
         */
        hasLegalHold: boolean;
        /**
         * The list of LegalHold tags of a blob container.
         */
        tags?: outputs.storage.TagPropertyResponse[];
    }

    /**
     * Actions are applied to the filtered blobs when the execution condition is met.
     */
    export interface ManagementPolicyActionResponse {
        /**
         * The management policy action for base blob
         */
        baseBlob?: outputs.storage.ManagementPolicyBaseBlobResponse;
        /**
         * The management policy action for snapshot
         */
        snapshot?: outputs.storage.ManagementPolicySnapShotResponse;
    }

    /**
     * Management policy action for base blob.
     */
    export interface ManagementPolicyBaseBlobResponse {
        /**
         * The function to delete the blob
         */
        delete?: outputs.storage.DateAfterModificationResponse;
        /**
         * The function to tier blobs to archive storage. Support blobs currently at Hot or Cool tier
         */
        tierToArchive?: outputs.storage.DateAfterModificationResponse;
        /**
         * The function to tier blobs to cool storage. Support blobs currently at Hot tier
         */
        tierToCool?: outputs.storage.DateAfterModificationResponse;
    }

    /**
     * An object that defines the Lifecycle rule. Each definition is made up with a filters set and an actions set.
     */
    export interface ManagementPolicyDefinitionResponse {
        /**
         * An object that defines the action set.
         */
        actions: outputs.storage.ManagementPolicyActionResponse;
        /**
         * An object that defines the filter set.
         */
        filters?: outputs.storage.ManagementPolicyFilterResponse;
    }

    /**
     * Filters limit rule actions to a subset of blobs within the storage account. If multiple filters are defined, a logical AND is performed on all filters. 
     */
    export interface ManagementPolicyFilterResponse {
        /**
         * An array of blob index tag based filters, there can be at most 10 tag filters
         */
        blobIndexMatch?: outputs.storage.TagFilterResponse[];
        /**
         * An array of predefined enum values. Only blockBlob is supported.
         */
        blobTypes: string[];
        /**
         * An array of strings for prefixes to be match.
         */
        prefixMatch?: string[];
    }

    /**
     * The Storage Account ManagementPolicy properties.
     */
    export interface ManagementPolicyPropertiesResponse {
        /**
         * Returns the date and time the ManagementPolicies was last modified.
         */
        lastModifiedTime: string;
        /**
         * The Storage Account ManagementPolicy, in JSON format. See more details in: https://docs.microsoft.com/en-us/azure/storage/common/storage-lifecycle-managment-concepts.
         */
        policy: outputs.storage.ManagementPolicySchemaResponse;
    }

    /**
     * An object that wraps the Lifecycle rule. Each rule is uniquely defined by name.
     */
    export interface ManagementPolicyRuleResponse {
        /**
         * An object that defines the Lifecycle rule.
         */
        definition: outputs.storage.ManagementPolicyDefinitionResponse;
        /**
         * Rule is enabled if set to true.
         */
        enabled?: boolean;
        /**
         * A rule name can contain any combination of alpha numeric characters. Rule name is case-sensitive. It must be unique within a policy.
         */
        name: string;
        /**
         * The valid value is Lifecycle
         */
        type: string;
    }

    /**
     * The Storage Account ManagementPolicies Rules. See more details in: https://docs.microsoft.com/en-us/azure/storage/common/storage-lifecycle-managment-concepts.
     */
    export interface ManagementPolicySchemaResponse {
        /**
         * The Storage Account ManagementPolicies Rules. See more details in: https://docs.microsoft.com/en-us/azure/storage/common/storage-lifecycle-managment-concepts.
         */
        rules: outputs.storage.ManagementPolicyRuleResponse[];
    }

    /**
     * Management policy action for snapshot.
     */
    export interface ManagementPolicySnapShotResponse {
        /**
         * The function to delete the blob snapshot
         */
        delete?: outputs.storage.DateAfterCreationResponse;
    }

    /**
     * Network rule set
     */
    export interface NetworkRuleSetResponse {
        /**
         * Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Possible values are any combination of Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None to bypass none of those traffics.
         */
        bypass?: string;
        /**
         * Specifies the default action of allow or deny when no other rules match.
         */
        defaultAction: string;
        /**
         * Sets the IP ACL rules
         */
        ipRules?: outputs.storage.IPRuleResponse[];
        /**
         * Sets the virtual network rules
         */
        virtualNetworkRules?: outputs.storage.VirtualNetworkRuleResponse[];
    }

    /**
     * Filters limit replication to a subset of blobs within the storage account. A logical OR is performed on values in the filter. If multiple filters are defined, a logical AND is performed on all filters.
     */
    export interface ObjectReplicationPolicyFilterResponse {
        /**
         * Blobs created after the time will be replicated to the destination. It must be in datetime format 'yyyy-MM-ddTHH:mm:ssZ'. Example: 2020-02-19T16:05:00Z
         */
        minCreationTime?: string;
        /**
         * Optional. Filters the results to replicate only blobs whose names begin with the specified prefix.
         */
        prefixMatch?: string[];
    }

    /**
     * The Storage Account ObjectReplicationPolicy properties.
     */
    export interface ObjectReplicationPolicyPropertiesResponse {
        /**
         * Required. Destination account name.
         */
        destinationAccount: string;
        /**
         * Indicates when the policy is enabled on the source account.
         */
        enabledTime: string;
        /**
         * A unique id for object replication policy.
         */
        policyId: string;
        /**
         * The storage account object replication rules.
         */
        rules?: outputs.storage.ObjectReplicationPolicyRuleResponse[];
        /**
         * Required. Source account name.
         */
        sourceAccount: string;
    }

    /**
     * The replication policy rule between two containers.
     */
    export interface ObjectReplicationPolicyRuleResponse {
        /**
         * Required. Destination container name.
         */
        destinationContainer: string;
        /**
         * Optional. An object that defines the filter set.
         */
        filters?: outputs.storage.ObjectReplicationPolicyFilterResponse;
        /**
         * Rule Id is auto-generated for each new rule on destination account. It is required for put policy on source account.
         */
        ruleId?: string;
        /**
         * Required. Source container name.
         */
        sourceContainer: string;
    }

    /**
     * Properties of the PrivateEndpointConnectProperties.
     */
    export interface PrivateEndpointConnectionPropertiesResponse {
        /**
         * The resource of private end point.
         */
        privateEndpoint?: outputs.storage.PrivateEndpointResponse;
        /**
         * A collection of information about the state of the connection between service consumer and provider.
         */
        privateLinkServiceConnectionState: outputs.storage.PrivateLinkServiceConnectionStateResponse;
        /**
         * The provisioning state of the private endpoint connection resource.
         */
        provisioningState?: string;
    }

    /**
     * The Private Endpoint Connection resource.
     */
    export interface PrivateEndpointConnectionResponse {
        /**
         * Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
         */
        id: string;
        /**
         * The name of the resource
         */
        name: string;
        /**
         * Resource properties.
         */
        properties?: outputs.storage.PrivateEndpointConnectionPropertiesResponse;
        /**
         * The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
         */
        type: string;
    }

    /**
     * The Private Endpoint resource.
     */
    export interface PrivateEndpointResponse {
        /**
         * The ARM identifier for Private Endpoint
         */
        id: string;
    }

    /**
     * A collection of information about the state of the connection between service consumer and provider.
     */
    export interface PrivateLinkServiceConnectionStateResponse {
        /**
         * A message indicating if changes on the service provider require any updates on the consumer.
         */
        actionRequired?: string;
        /**
         * The reason for approval/rejection of the connection.
         */
        description?: string;
        /**
         * Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
         */
        status?: string;
    }

    export interface QueuePropertiesResponse {
        /**
         * Integer indicating an approximate number of messages in the queue. This number is not lower than the actual number of messages in the queue, but could be higher.
         */
        approximateMessageCount: number;
        /**
         * A name-value pair that represents queue metadata.
         */
        metadata?: {[key: string]: string};
    }

    /**
     * Routing preference defines the type of network, either microsoft or internet routing to be used to deliver the user data, the default option is microsoft routing
     */
    export interface RoutingPreferenceResponse {
        /**
         * A boolean flag which indicates whether internet routing storage endpoints are to be published
         */
        publishInternetEndpoints?: boolean;
        /**
         * A boolean flag which indicates whether microsoft routing storage endpoints are to be published
         */
        publishMicrosoftEndpoints?: boolean;
        /**
         * Routing Choice defines the kind of network routing opted by the user.
         */
        routingChoice?: string;
    }

    /**
     * The SKU of the storage account.
     */
    export interface SkuResponse {
        /**
         * The SKU name. Required for account creation; optional for update. Note that in older versions, SKU name was called accountType.
         */
        name: string;
        /**
         * The SKU tier. This is based on the SKU name.
         */
        tier?: string;
    }

    /**
     * The URIs that are used to perform a retrieval of a public blob, file, web or dfs object via a internet routing endpoint.
     */
    export interface StorageAccountInternetEndpointsResponse {
        /**
         * Gets the blob endpoint.
         */
        blob: string;
        /**
         * Gets the dfs endpoint.
         */
        dfs: string;
        /**
         * Gets the file endpoint.
         */
        file: string;
        /**
         * Gets the web endpoint.
         */
        web: string;
    }

    /**
     * An access key for the storage account.
     */
    export interface StorageAccountKeyResponse {
        /**
         * Name of the key.
         */
        keyName: string;
        /**
         * Permissions for the key -- read-only or full permissions.
         */
        permissions: string;
        /**
         * Base 64-encoded value of the key.
         */
        value: string;
    }

    /**
     * The URIs that are used to perform a retrieval of a public blob, queue, table, web or dfs object via a microsoft routing endpoint.
     */
    export interface StorageAccountMicrosoftEndpointsResponse {
        /**
         * Gets the blob endpoint.
         */
        blob: string;
        /**
         * Gets the dfs endpoint.
         */
        dfs: string;
        /**
         * Gets the file endpoint.
         */
        file: string;
        /**
         * Gets the queue endpoint.
         */
        queue: string;
        /**
         * Gets the table endpoint.
         */
        table: string;
        /**
         * Gets the web endpoint.
         */
        web: string;
    }

    /**
     * Properties of the storage account.
     */
    export interface StorageAccountPropertiesResponse {
        /**
         * Required for storage accounts where kind = BlobStorage. The access tier used for billing.
         */
        accessTier: string;
        /**
         * Allow or disallow public access to all blobs or containers in the storage account. The default interpretation is true for this property.
         */
        allowBlobPublicAccess?: boolean;
        /**
         * Provides the identity based authentication settings for Azure Files.
         */
        azureFilesIdentityBasedAuthentication?: outputs.storage.AzureFilesIdentityBasedAuthenticationResponse;
        /**
         * Blob restore status
         */
        blobRestoreStatus: outputs.storage.BlobRestoreStatusResponse;
        /**
         * Gets the creation date and time of the storage account in UTC.
         */
        creationTime: string;
        /**
         * Gets the custom domain the user assigned to this storage account.
         */
        customDomain: outputs.storage.CustomDomainResponse;
        /**
         * Gets the encryption settings on the account. If unspecified, the account is unencrypted.
         */
        encryption: outputs.storage.EncryptionResponse;
        /**
         * If the failover is in progress, the value will be true, otherwise, it will be null.
         */
        failoverInProgress: boolean;
        /**
         * Geo Replication Stats
         */
        geoReplicationStats: outputs.storage.GeoReplicationStatsResponse;
        /**
         * Account HierarchicalNamespace enabled if sets to true.
         */
        isHnsEnabled?: boolean;
        /**
         * Allow large file shares if sets to Enabled. It cannot be disabled once it is enabled.
         */
        largeFileSharesState?: string;
        /**
         * Gets the timestamp of the most recent instance of a failover to the secondary location. Only the most recent timestamp is retained. This element is not returned if there has never been a failover instance. Only available if the accountType is Standard_GRS or Standard_RAGRS.
         */
        lastGeoFailoverTime: string;
        /**
         * Set the minimum TLS version to be permitted on requests to storage. The default interpretation is TLS 1.0 for this property.
         */
        minimumTlsVersion?: string;
        /**
         * Network rule set
         */
        networkAcls: outputs.storage.NetworkRuleSetResponse;
        /**
         * Gets the URLs that are used to perform a retrieval of a public blob, queue, or table object. Note that Standard_ZRS and Premium_LRS accounts only return the blob endpoint.
         */
        primaryEndpoints: outputs.storage.EndpointsResponse;
        /**
         * Gets the location of the primary data center for the storage account.
         */
        primaryLocation: string;
        /**
         * List of private endpoint connection associated with the specified storage account
         */
        privateEndpointConnections: outputs.storage.PrivateEndpointConnectionResponse[];
        /**
         * Gets the status of the storage account at the time the operation was called.
         */
        provisioningState: string;
        /**
         * Maintains information about the network routing choice opted by the user for data transfer
         */
        routingPreference?: outputs.storage.RoutingPreferenceResponse;
        /**
         * Gets the URLs that are used to perform a retrieval of a public blob, queue, or table object from the secondary location of the storage account. Only available if the SKU name is Standard_RAGRS.
         */
        secondaryEndpoints: outputs.storage.EndpointsResponse;
        /**
         * Gets the location of the geo-replicated secondary for the storage account. Only available if the accountType is Standard_GRS or Standard_RAGRS.
         */
        secondaryLocation: string;
        /**
         * Gets the status indicating whether the primary location of the storage account is available or unavailable.
         */
        statusOfPrimary: string;
        /**
         * Gets the status indicating whether the secondary location of the storage account is available or unavailable. Only available if the SKU name is Standard_GRS or Standard_RAGRS.
         */
        statusOfSecondary: string;
        /**
         * Allows https traffic only to storage service if sets to true.
         */
        supportsHttpsTrafficOnly?: boolean;
    }

    export interface TablePropertiesResponse {
        /**
         * Table name under the specified account
         */
        tableName: string;
    }

    /**
     * Blob index tag based filtering for blob objects
     */
    export interface TagFilterResponse {
        /**
         * This is the filter tag name, it can have 1 - 128 characters
         */
        name: string;
        /**
         * This is the comparison operator which is used for object comparison and filtering. Only == (equality operator) is currently supported
         */
        op: string;
        /**
         * This is the filter tag value field used for tag based filtering, it can have 0 - 256 characters
         */
        value: string;
    }

    /**
     * A tag of the LegalHold of a blob container.
     */
    export interface TagPropertyResponse {
        /**
         * Returns the Object ID of the user who added the tag.
         */
        objectIdentifier: string;
        /**
         * The tag value.
         */
        tag: string;
        /**
         * Returns the Tenant ID that issued the token for the user who added the tag.
         */
        tenantId: string;
        /**
         * Returns the date and time the tag was added.
         */
        timestamp: string;
        /**
         * Returns the User Principal Name of the user who added the tag.
         */
        upn: string;
    }

    /**
     * An update history of the ImmutabilityPolicy of a blob container.
     */
    export interface UpdateHistoryPropertyResponse {
        /**
         * The immutability period for the blobs in the container since the policy creation, in days.
         */
        immutabilityPeriodSinceCreationInDays: number;
        /**
         * Returns the Object ID of the user who updated the ImmutabilityPolicy.
         */
        objectIdentifier: string;
        /**
         * Returns the Tenant ID that issued the token for the user who updated the ImmutabilityPolicy.
         */
        tenantId: string;
        /**
         * Returns the date and time the ImmutabilityPolicy was updated.
         */
        timestamp: string;
        /**
         * The ImmutabilityPolicy update type of a blob container, possible values include: put, lock and extend.
         */
        update: string;
        /**
         * Returns the User Principal Name of the user who updated the ImmutabilityPolicy.
         */
        upn: string;
    }

    /**
     * Virtual Network rule.
     */
    export interface VirtualNetworkRuleResponse {
        /**
         * The action of virtual network rule.
         */
        action?: string;
        /**
         * Resource ID of a subnet, for example: /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
         */
        id: string;
        /**
         * Gets the state of virtual network rule.
         */
        state?: string;
    }
}

export namespace storagecache {
    /**
     * Cache encryption settings.
     */
    export interface CacheEncryptionSettingsResponse {
        /**
         * Specifies the location of the key encryption key in Key Vault.
         */
        keyEncryptionKey?: outputs.storagecache.KeyVaultKeyReferenceResponse;
    }

    /**
     * An indication of Cache health. Gives more information about health than just that related to provisioning.
     */
    export interface CacheHealthResponse {
        /**
         * List of Cache health states.
         */
        state?: string;
        /**
         * Describes explanation of state.
         */
        statusDescription?: string;
    }

    /**
     * Cache identity properties.
     */
    export interface CacheIdentityResponse {
        /**
         * The principal id of the cache.
         */
        principalId: string;
        /**
         * The tenant id associated with the cache.
         */
        tenantId: string;
        /**
         * The type of identity used for the cache
         */
        type?: string;
    }

    /**
     * Cache network settings.
     */
    export interface CacheNetworkSettingsResponse {
        /**
         * The IPv4 maximum transmission unit configured for the subnet.
         */
        mtu?: number;
        /**
         * Array of additional IP addresses used by this Cache.
         */
        utilityAddresses: string[];
    }

    /**
     * Properties of the Cache.
     */
    export interface CacheResponseProperties {
        /**
         * The size of this Cache, in GB.
         */
        cacheSizeGB?: number;
        /**
         * Specifies encryption settings of the cache.
         */
        encryptionSettings?: outputs.storagecache.CacheEncryptionSettingsResponse;
        /**
         * Health of the Cache.
         */
        health: outputs.storagecache.CacheHealthResponse;
        /**
         * Array of IP addresses that can be used by clients mounting this Cache.
         */
        mountAddresses: string[];
        /**
         * Specifies network settings of the cache.
         */
        networkSettings?: outputs.storagecache.CacheNetworkSettingsResponse;
        /**
         * ARM provisioning state, see https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/Addendum.md#provisioningstate-property
         */
        provisioningState?: string;
        /**
         * Specifies security settings of the cache.
         */
        securitySettings?: outputs.storagecache.CacheSecuritySettingsResponse;
        /**
         * Subnet used for the Cache.
         */
        subnet?: string;
        /**
         * Upgrade status of the Cache.
         */
        upgradeStatus?: outputs.storagecache.CacheUpgradeStatusResponse;
    }

    /**
     * Cache security settings.
     */
    export interface CacheSecuritySettingsResponse {
        /**
         * root squash of cache property.
         */
        rootSquash?: boolean;
    }

    /**
     * Properties describing the software upgrade state of the Cache.
     */
    export interface CacheUpgradeStatusResponse {
        /**
         * Version string of the firmware currently installed on this Cache.
         */
        currentFirmwareVersion: string;
        /**
         * Time at which the pending firmware update will automatically be installed on the Cache.
         */
        firmwareUpdateDeadline: string;
        /**
         * True if there is a firmware update ready to install on this Cache. The firmware will automatically be installed after firmwareUpdateDeadline if not triggered earlier via the upgrade operation.
         */
        firmwareUpdateStatus: string;
        /**
         * Time of the last successful firmware update.
         */
        lastFirmwareUpdate: string;
        /**
         * When firmwareUpdateAvailable is true, this field holds the version string for the update.
         */
        pendingFirmwareVersion: string;
    }

    /**
     * Properties pertained to ClfsTarget
     */
    export interface ClfsTargetResponse {
        /**
         * Resource ID of storage container.
         */
        target?: string;
    }

    /**
     * Describes a reference to Key Vault Key.
     */
    export interface KeyVaultKeyReferenceResponse {
        /**
         * The URL referencing a key encryption key in Key Vault.
         */
        keyUrl: string;
        /**
         * Describes a resource Id to source Key Vault.
         */
        sourceVault: outputs.storagecache.KeyVaultKeyReferenceResponseProperties;
    }

    /**
     * Describes a resource Id to source Key Vault.
     */
    export interface KeyVaultKeyReferenceResponseProperties {
        /**
         * Resource Id.
         */
        id?: string;
    }

    /**
     * A namespace junction.
     */
    export interface NamespaceJunctionResponse {
        /**
         * Namespace path on a Cache for a Storage Target.
         */
        namespacePath?: string;
        /**
         * NFS export where targetPath exists.
         */
        nfsExport?: string;
        /**
         * Path in Storage Target to which namespacePath points.
         */
        targetPath?: string;
    }

    /**
     * Properties pertained to Nfs3Target
     */
    export interface Nfs3TargetResponse {
        /**
         * IP address or host name of an NFSv3 host (e.g., 10.0.44.44).
         */
        target?: string;
        /**
         * Identifies the primary usage model to be used for this Storage Target. Get choices from .../usageModels
         */
        usageModel?: string;
    }

    /**
     * Properties of the Storage Target.
     */
    export interface StorageTargetPropertiesResponse {
        /**
         * Properties when targetType is clfs.
         */
        clfs?: outputs.storagecache.ClfsTargetResponse;
        /**
         * List of Cache namespace junctions to target for namespace associations.
         */
        junctions?: outputs.storagecache.NamespaceJunctionResponse[];
        /**
         * Properties when targetType is nfs3.
         */
        nfs3?: outputs.storagecache.Nfs3TargetResponse;
        /**
         * ARM provisioning state, see https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/Addendum.md#provisioningstate-property
         */
        provisioningState?: string;
        /**
         * Type of the Storage Target.
         */
        targetBaseType: string;
        /**
         * Type of the Storage Target.
         */
        targetType?: string;
        /**
         * Properties when targetType is unknown.
         */
        unknown?: outputs.storagecache.UnknownTargetResponse;
    }

    /**
     * Properties of an unknown type of Storage Target.
     */
    export interface UnknownPropertiesResponse {
    }

    /**
     * Properties pertained to UnknownTarget
     */
    export interface UnknownTargetResponse {
        /**
         * Dictionary of string->string pairs containing information about the Storage Target.
         */
        unknownMap?: outputs.storagecache.UnknownPropertiesResponse;
    }
}

export namespace storagesync {
    /**
     * CloudEndpoint Properties object.
     */
    export interface CloudEndpointPropertiesResponse {
        /**
         * Azure file share name
         */
        azureFileShareName?: string;
        /**
         * Backup Enabled
         */
        backupEnabled: string;
        /**
         * Friendly Name
         */
        friendlyName?: string;
        /**
         * Resource Last Operation Name
         */
        lastOperationName?: string;
        /**
         * CloudEndpoint lastWorkflowId
         */
        lastWorkflowId?: string;
        /**
         * Partnership Id
         */
        partnershipId?: string;
        /**
         * CloudEndpoint Provisioning State
         */
        provisioningState?: string;
        /**
         * Storage Account Resource Id
         */
        storageAccountResourceId?: string;
        /**
         * Storage Account Tenant Id
         */
        storageAccountTenantId?: string;
    }

    /**
     * Server endpoint cloud tiering status object.
     */
    export interface CloudTieringCachePerformanceResponse {
        /**
         * Count of bytes that were served from the local server
         */
        cacheHitBytes: number;
        /**
         * Percentage of total bytes (hit + miss) that were served from the local server
         */
        cacheHitBytesPercent: number;
        /**
         * Count of bytes that were served from the cloud
         */
        cacheMissBytes: number;
        /**
         * Last updated timestamp
         */
        lastUpdatedTimestamp: string;
    }

    /**
     * Status of the date policy
     */
    export interface CloudTieringDatePolicyStatusResponse {
        /**
         * Last updated timestamp
         */
        lastUpdatedTimestamp: string;
        /**
         * Most recent access time of tiered files
         */
        tieredFilesMostRecentAccessTimestamp: string;
    }

    /**
     * Server endpoint cloud tiering status object.
     */
    export interface CloudTieringFilesNotTieringResponse {
        /**
         * Array of tiering errors
         */
        errors: outputs.storagesync.FilesNotTieringErrorResponse[];
        /**
         * Last updated timestamp
         */
        lastUpdatedTimestamp: string;
        /**
         * Last cloud tiering result (HResult)
         */
        totalFileCount: number;
    }

    /**
     * Server endpoint cloud tiering status object.
     */
    export interface CloudTieringSpaceSavingsResponse {
        /**
         * Cached content size on the server
         */
        cachedSizeBytes: number;
        /**
         * Last updated timestamp
         */
        lastUpdatedTimestamp: string;
        /**
         * Count of bytes saved on the server
         */
        spaceSavingsBytes: number;
        /**
         * Percentage of cached size over total size
         */
        spaceSavingsPercent: number;
        /**
         * Total size of content in the azure file share
         */
        totalSizeCloudBytes: number;
        /**
         * Volume size
         */
        volumeSizeBytes: number;
    }

    /**
     * Status of the volume free space policy
     */
    export interface CloudTieringVolumeFreeSpacePolicyStatusResponse {
        /**
         * Current volume free space percentage.
         */
        currentVolumeFreeSpacePercent: number;
        /**
         * In the case where multiple server endpoints are present in a volume, an effective free space policy is applied.
         */
        effectiveVolumeFreeSpacePolicy: number;
        /**
         * Last updated timestamp
         */
        lastUpdatedTimestamp: string;
    }

    /**
     * Files not tiering error object
     */
    export interface FilesNotTieringErrorResponse {
        /**
         * Error code (HResult)
         */
        errorCode: number;
        /**
         * Count of files with this error
         */
        fileCount: number;
    }

    /**
     * Properties of the PrivateEndpointConnectProperties.
     */
    export interface PrivateEndpointConnectionPropertiesResponse {
        /**
         * The resource of private end point.
         */
        privateEndpoint?: outputs.storagesync.PrivateEndpointResponse;
        /**
         * A collection of information about the state of the connection between service consumer and provider.
         */
        privateLinkServiceConnectionState: outputs.storagesync.PrivateLinkServiceConnectionStateResponse;
        /**
         * The provisioning state of the private endpoint connection resource.
         */
        provisioningState?: string;
    }

    /**
     * The Private Endpoint Connection resource.
     */
    export interface PrivateEndpointConnectionResponse {
        /**
         * Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
         */
        id: string;
        /**
         * The name of the resource
         */
        name: string;
        /**
         * Resource properties.
         */
        properties?: outputs.storagesync.PrivateEndpointConnectionPropertiesResponse;
        /**
         * The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
         */
        type: string;
    }

    /**
     * The Private Endpoint resource.
     */
    export interface PrivateEndpointResponse {
        /**
         * The ARM identifier for Private Endpoint
         */
        id: string;
    }

    /**
     * A collection of information about the state of the connection between service consumer and provider.
     */
    export interface PrivateLinkServiceConnectionStateResponse {
        /**
         * A message indicating if changes on the service provider require any updates on the consumer.
         */
        actionsRequired?: string;
        /**
         * The reason for approval/rejection of the connection.
         */
        description?: string;
        /**
         * Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
         */
        status?: string;
    }

    /**
     * RegisteredServer Properties object.
     */
    export interface RegisteredServerPropertiesResponse {
        /**
         * Registered Server Agent Version
         */
        agentVersion?: string;
        /**
         * Registered Server clusterId
         */
        clusterId?: string;
        /**
         * Registered Server clusterName
         */
        clusterName?: string;
        /**
         * Resource discoveryEndpointUri
         */
        discoveryEndpointUri?: string;
        /**
         * Friendly Name
         */
        friendlyName?: string;
        /**
         * Registered Server last heart beat
         */
        lastHeartBeat?: string;
        /**
         * Resource Last Operation Name
         */
        lastOperationName?: string;
        /**
         * Registered Server lastWorkflowId
         */
        lastWorkflowId?: string;
        /**
         * Management Endpoint Uri
         */
        managementEndpointUri?: string;
        /**
         * Monitoring Configuration
         */
        monitoringConfiguration?: string;
        /**
         * Telemetry Endpoint Uri
         */
        monitoringEndpointUri?: string;
        /**
         * Registered Server Provisioning State
         */
        provisioningState?: string;
        /**
         * Resource Location
         */
        resourceLocation?: string;
        /**
         * Registered Server Certificate
         */
        serverCertificate?: string;
        /**
         * Registered Server serverId
         */
        serverId?: string;
        /**
         * Registered Server Management Error Code
         */
        serverManagementErrorCode?: number;
        /**
         * Registered Server OS Version
         */
        serverOSVersion?: string;
        /**
         * Registered Server serverRole
         */
        serverRole?: string;
        /**
         * Service Location
         */
        serviceLocation?: string;
        /**
         * Registered Server storageSyncServiceUid
         */
        storageSyncServiceUid?: string;
    }

    /**
     * Server endpoint cloud tiering status object.
     */
    export interface ServerEndpointCloudTieringStatusResponse {
        /**
         * Information regarding how well the local cache on the server is performing.
         */
        cachePerformance: outputs.storagesync.CloudTieringCachePerformanceResponse;
        /**
         * Status of the date policy
         */
        datePolicyStatus: outputs.storagesync.CloudTieringDatePolicyStatusResponse;
        /**
         * Information regarding files that failed to be tiered
         */
        filesNotTiering: outputs.storagesync.CloudTieringFilesNotTieringResponse;
        /**
         * Cloud tiering health state.
         */
        health: string;
        /**
         * The last updated timestamp of health state
         */
        healthLastUpdatedTimestamp: string;
        /**
         * Last cloud tiering result (HResult)
         */
        lastCloudTieringResult: number;
        /**
         * Last cloud tiering success timestamp
         */
        lastSuccessTimestamp: string;
        /**
         * Last updated timestamp
         */
        lastUpdatedTimestamp: string;
        /**
         * Information regarding how much local space cloud tiering is saving.
         */
        spaceSavings: outputs.storagesync.CloudTieringSpaceSavingsResponse;
        /**
         * Status of the volume free space policy
         */
        volumeFreeSpacePolicyStatus: outputs.storagesync.CloudTieringVolumeFreeSpacePolicyStatusResponse;
    }

    /**
     * Files not syncing error object
     */
    export interface ServerEndpointFilesNotSyncingErrorResponse {
        /**
         * Error code (HResult)
         */
        errorCode: number;
        /**
         * Count of persistent files not syncing with the specified error code
         */
        persistentCount: number;
        /**
         * Count of transient files not syncing with the specified error code
         */
        transientCount: number;
    }

    /**
     * ServerEndpoint Properties object.
     */
    export interface ServerEndpointPropertiesResponse {
        /**
         * Cloud Tiering.
         */
        cloudTiering?: string;
        /**
         * Cloud tiering status. Only populated if cloud tiering is enabled.
         */
        cloudTieringStatus: outputs.storagesync.ServerEndpointCloudTieringStatusResponse;
        /**
         * Friendly Name
         */
        friendlyName?: string;
        /**
         * Policy for how namespace and files are recalled during FastDr.
         */
        initialDownloadPolicy?: string;
        /**
         * Resource Last Operation Name
         */
        lastOperationName: string;
        /**
         * ServerEndpoint lastWorkflowId
         */
        lastWorkflowId: string;
        /**
         * Policy for enabling follow-the-sun business models: link local cache to cloud behavior to pre-populate before local access.
         */
        localCacheMode?: string;
        /**
         * Offline data transfer
         */
        offlineDataTransfer?: string;
        /**
         * Offline data transfer share name
         */
        offlineDataTransferShareName?: string;
        /**
         * Offline data transfer storage account resource ID
         */
        offlineDataTransferStorageAccountResourceId: string;
        /**
         * Offline data transfer storage account tenant ID
         */
        offlineDataTransferStorageAccountTenantId: string;
        /**
         * ServerEndpoint Provisioning State
         */
        provisioningState: string;
        /**
         * Recall status. Only populated if cloud tiering is enabled.
         */
        recallStatus: outputs.storagesync.ServerEndpointRecallStatusResponse;
        /**
         * Server Local path.
         */
        serverLocalPath?: string;
        /**
         * Server Resource Id.
         */
        serverResourceId?: string;
        /**
         * Server Endpoint sync status
         */
        syncStatus: outputs.storagesync.ServerEndpointSyncStatusResponse;
        /**
         * Tier files older than days.
         */
        tierFilesOlderThanDays?: number;
        /**
         * Level of free space to be maintained by Cloud Tiering if it is enabled.
         */
        volumeFreeSpacePercent?: number;
    }

    /**
     * Server endpoint recall error object
     */
    export interface ServerEndpointRecallErrorResponse {
        /**
         * Count of occurences of the error
         */
        count: number;
        /**
         * Error code (HResult)
         */
        errorCode: number;
    }

    /**
     * Server endpoint recall status object.
     */
    export interface ServerEndpointRecallStatusResponse {
        /**
         * Last updated timestamp
         */
        lastUpdatedTimestamp: string;
        /**
         * Array of recall errors
         */
        recallErrors: outputs.storagesync.ServerEndpointRecallErrorResponse[];
        /**
         * Total count of recall errors.
         */
        totalRecallErrorsCount: number;
    }

    /**
     * Sync Session status object.
     */
    export interface ServerEndpointSyncActivityStatusResponse {
        /**
         * Applied bytes
         */
        appliedBytes: number;
        /**
         * Applied item count.
         */
        appliedItemCount: number;
        /**
         * Per item error count
         */
        perItemErrorCount: number;
        /**
         * Timestamp when properties were updated
         */
        timestamp: string;
        /**
         * Total bytes (if available)
         */
        totalBytes: number;
        /**
         * Total item count (if available)
         */
        totalItemCount: number;
    }

    /**
     * Sync Session status object.
     */
    export interface ServerEndpointSyncSessionStatusResponse {
        /**
         * Array of per-item errors coming from the last sync session.
         */
        filesNotSyncingErrors: outputs.storagesync.ServerEndpointFilesNotSyncingErrorResponse[];
        /**
         * Last sync per item error count.
         */
        lastSyncPerItemErrorCount: number;
        /**
         * Last sync result (HResult)
         */
        lastSyncResult: number;
        /**
         * Last sync success timestamp
         */
        lastSyncSuccessTimestamp: string;
        /**
         * Last sync timestamp
         */
        lastSyncTimestamp: string;
        /**
         * Count of persistent files not syncing.
         */
        persistentFilesNotSyncingCount: number;
        /**
         * Count of transient files not syncing.
         */
        transientFilesNotSyncingCount: number;
    }

    /**
     * Server Endpoint sync status
     */
    export interface ServerEndpointSyncStatusResponse {
        /**
         * Combined Health Status.
         */
        combinedHealth: string;
        /**
         * Download sync activity
         */
        downloadActivity: outputs.storagesync.ServerEndpointSyncActivityStatusResponse;
        /**
         * Download Health Status.
         */
        downloadHealth: string;
        /**
         * Download Status
         */
        downloadStatus: outputs.storagesync.ServerEndpointSyncSessionStatusResponse;
        /**
         * Last Updated Timestamp
         */
        lastUpdatedTimestamp: string;
        /**
         * Offline Data Transfer State
         */
        offlineDataTransferStatus: string;
        /**
         * Sync activity
         */
        syncActivity: string;
        /**
         * Total count of persistent files not syncing (combined upload + download).
         */
        totalPersistentFilesNotSyncingCount: number;
        /**
         * Upload sync activity
         */
        uploadActivity: outputs.storagesync.ServerEndpointSyncActivityStatusResponse;
        /**
         * Upload Health Status.
         */
        uploadHealth: string;
        /**
         * Upload Status
         */
        uploadStatus: outputs.storagesync.ServerEndpointSyncSessionStatusResponse;
    }

    /**
     * Storage Sync Service Properties object.
     */
    export interface StorageSyncServicePropertiesResponse {
        /**
         * Incoming Traffic Policy
         */
        incomingTrafficPolicy?: string;
        /**
         * Resource Last Operation Name
         */
        lastOperationName: string;
        /**
         * StorageSyncService lastWorkflowId
         */
        lastWorkflowId: string;
        /**
         * List of private endpoint connection associated with the specified storage sync service
         */
        privateEndpointConnections: outputs.storagesync.PrivateEndpointConnectionResponse[];
        /**
         * StorageSyncService Provisioning State
         */
        provisioningState: string;
        /**
         * Storage Sync service status.
         */
        storageSyncServiceStatus: number;
        /**
         * Storage Sync service Uid
         */
        storageSyncServiceUid: string;
    }

    /**
     * SyncGroup Properties object.
     */
    export interface SyncGroupPropertiesResponse {
        /**
         * Sync group status
         */
        syncGroupStatus: string;
        /**
         * Unique Id
         */
        uniqueId: string;
    }
}

export namespace storsimple {
    /**
     * The properties of access control record.
     */
    export interface AccessControlRecordPropertiesResponse {
        /**
         * The iSCSI initiator name (IQN).
         */
        initiatorName: string;
        /**
         * The number of volumes using the access control record.
         */
        volumeCount: number;
    }

    /**
     * Represent the secrets intended for encryption with asymmetric key pair.
     */
    export interface AsymmetricEncryptedSecretResponse {
        /**
         * The algorithm used to encrypt "Value".
         */
        encryptionAlgorithm: string;
        /**
         * Thumbprint certificate that was used to encrypt "Value". If the value in unencrypted, it will be null.
         */
        encryptionCertThumbprint?: string;
        /**
         * The value of the secret.
         */
        value: string;
    }

    /**
     * The properties of the backup policy.
     */
    export interface BackupPolicyPropertiesResponse {
        /**
         * The backup policy creation type. Indicates whether this was created through SaaS or through StorSimple Snapshot Manager.
         */
        backupPolicyCreationType: string;
        /**
         * The time of the last backup for the backup policy.
         */
        lastBackupTime: string;
        /**
         * The time of the next backup for the backup policy.
         */
        nextBackupTime: string;
        /**
         * Indicates whether at least one of the schedules in the backup policy is active or not.
         */
        scheduledBackupStatus: string;
        /**
         * The count of schedules the backup policy contains.
         */
        schedulesCount: number;
        /**
         * If the backup policy was created by StorSimple Snapshot Manager, then this field indicates the hostname of the StorSimple Snapshot Manager.
         */
        ssmHostName: string;
        /**
         * The path IDs of the volumes which are part of the backup policy.
         */
        volumeIds: string[];
    }

    /**
     * The Backup Schedule Group Properties
     */
    export interface BackupScheduleGroupPropertiesResponse {
        /**
         * The start time. When this field is specified we will generate Default GrandFather Father Son Backup Schedules.
         */
        startTime: outputs.storsimple.TimeResponse;
    }

    /**
     * The properties of the backup schedule.
     */
    export interface BackupSchedulePropertiesResponse {
        /**
         * The type of backup which needs to be taken.
         */
        backupType: string;
        /**
         * The last successful backup run which was triggered for the schedule.
         */
        lastSuccessfulRun: string;
        /**
         * The number of backups to be retained.
         */
        retentionCount: number;
        /**
         * The schedule recurrence.
         */
        scheduleRecurrence: outputs.storsimple.ScheduleRecurrenceResponse;
        /**
         * The schedule status.
         */
        scheduleStatus: string;
        /**
         * The start time of the schedule.
         */
        startTime: string;
    }

    /**
     * The properties of the bandwidth setting.
     */
    export interface BandwidthRateSettingPropertiesResponse {
        /**
         * The schedules.
         */
        schedules: outputs.storsimple.BandwidthScheduleResponse[];
        /**
         * The number of volumes that uses the bandwidth setting.
         */
        volumeCount: number;
    }

    /**
     * The schedule for bandwidth setting.
     */
    export interface BandwidthScheduleResponse {
        /**
         * The days of the week when this schedule is applicable.
         */
        days: string[];
        /**
         * The rate in Mbps.
         */
        rateInMbps: number;
        /**
         * The start time of the schedule.
         */
        start: outputs.storsimple.TimeResponse;
        /**
         * The stop time of the schedule.
         */
        stop: outputs.storsimple.TimeResponse;
    }

    /**
     * Chap properties
     */
    export interface ChapPropertiesResponse {
        /**
         * The chap password.
         */
        password: outputs.storsimple.AsymmetricEncryptedSecretResponse;
    }

    /**
     * The eligibility result of failover set, for failover.
     */
    export interface FailoverSetEligibilityResultResponse {
        /**
         * The error message, if the failover set is not eligible for failover.
         */
        errorMessage?: string;
        /**
         * Represents if this failover set is eligible for failover or not.
         */
        isEligibleForFailover?: boolean;
    }

    /**
     * The failover set on a device.
     */
    export interface FailoverSetResponse {
        /**
         * The eligibility result of the failover set, for failover.
         */
        eligibilityResult?: outputs.storsimple.FailoverSetEligibilityResultResponse;
        /**
         * The list of meta data of volume containers, which are part of the failover set.
         */
        volumeContainers?: outputs.storsimple.VolumeContainerFailoverMetadataResponse[];
    }

    /**
     * Represents the eligibility of a device as a failover target device.
     */
    export interface FailoverTargetResponse {
        /**
         * The amount of free local storage available on the device in bytes.
         */
        availableLocalStorageInBytes?: number;
        /**
         * The amount of free tiered storage available for the device in bytes.
         */
        availableTieredStorageInBytes?: number;
        /**
         * The count of data containers on the device.
         */
        dataContainersCount?: number;
        /**
         * The path ID of the device.
         */
        deviceId?: string;
        /**
         * The geo location (applicable only for cloud appliances) of the device.
         */
        deviceLocation?: string;
        /**
         * The software version of the device.
         */
        deviceSoftwareVersion?: string;
        /**
         * The status of the device.
         */
        deviceStatus?: string;
        /**
         * The eligibility result of the device, as a failover target device.
         */
        eligibilityResult?: outputs.storsimple.TargetEligibilityResultResponse;
        /**
         * The friendly name for the current version of software on the device.
         */
        friendlyDeviceSoftwareVersion?: string;
        /**
         * The model number of the device.
         */
        modelDescription?: string;
        /**
         * The count of volumes on the device.
         */
        volumesCount?: number;
    }

    /**
     * The file server properties.
     */
    export interface FileServerPropertiesResponse {
        /**
         * The backup policy id.
         */
        backupScheduleGroupId: string;
        /**
         * The description of the file server
         */
        description?: string;
        /**
         * Domain of the file server
         */
        domainName: string;
        /**
         * The storage domain id.
         */
        storageDomainId: string;
    }

    /**
     * The File Share.
     */
    export interface FileSharePropertiesResponse {
        /**
         * The user/group who will have full permission in this share. Active directory email address. Example: xyz@contoso.com or Contoso\xyz.
         */
        adminUser: string;
        /**
         * The data policy
         */
        dataPolicy: string;
        /**
         * Description for file share
         */
        description?: string;
        /**
         * The local used capacity in Bytes.
         */
        localUsedCapacityInBytes: number;
        /**
         * The monitoring status
         */
        monitoringStatus: string;
        /**
         * The total provisioned capacity in Bytes
         */
        provisionedCapacityInBytes: number;
        /**
         * The Share Status
         */
        shareStatus: string;
        /**
         * The used capacity in Bytes.
         */
        usedCapacityInBytes: number;
    }

    /**
     * The iSCSI disk properties.
     */
    export interface ISCSIDiskPropertiesResponse {
        /**
         * The access control records.
         */
        accessControlRecords: string[];
        /**
         * The data policy.
         */
        dataPolicy: string;
        /**
         * The description.
         */
        description?: string;
        /**
         * The disk status.
         */
        diskStatus: string;
        /**
         * The local used capacity in bytes.
         */
        localUsedCapacityInBytes: number;
        /**
         * The monitoring.
         */
        monitoringStatus: string;
        /**
         * The provisioned capacity in bytes.
         */
        provisionedCapacityInBytes: number;
        /**
         * The used capacity in bytes.
         */
        usedCapacityInBytes: number;
    }

    /**
     * The iSCSI server properties.
     */
    export interface ISCSIServerPropertiesResponse {
        /**
         * The backup policy id.
         */
        backupScheduleGroupId: string;
        /**
         * The chap id.
         */
        chapId?: string;
        /**
         * The description.
         */
        description?: string;
        /**
         * The reverse chap id.
         */
        reverseChapId?: string;
        /**
         * The storage domain id.
         */
        storageDomainId: string;
    }

    /**
     * The properties of the manager extended info.
     */
    export interface ManagerExtendedInfoPropertiesResponse {
        /**
         * Represents the encryption algorithm used to encrypt the keys. None - if Key is saved in plain text format. Algorithm name - if key is encrypted
         */
        algorithm: string;
        /**
         * Represents the CEK of the resource.
         */
        encryptionKey?: string;
        /**
         * Represents the Cert thumbprint that was used to encrypt the CEK.
         */
        encryptionKeyThumbprint?: string;
        /**
         * Represents the CIK of the resource.
         */
        integrityKey: string;
        /**
         * Represents the portal thumbprint which can be used optionally to encrypt the entire data before storing it.
         */
        portalCertificateThumbprint?: string;
        /**
         * The version of the extended info being persisted.
         */
        version?: string;
    }

    /**
     * Intrinsic settings which refers to the type of the StorSimple Manager.
     */
    export interface ManagerIntrinsicSettingsResponse {
        /**
         * The type of StorSimple Manager.
         */
        type: string;
    }

    /**
     * The properties of the StorSimple Manager.
     */
    export interface ManagerPropertiesResponse {
        /**
         * Represents the type of StorSimple Manager.
         */
        cisIntrinsicSettings?: outputs.storsimple.ManagerIntrinsicSettingsResponse;
        /**
         * Specifies the state of the resource as it is getting provisioned. Value of "Succeeded" means the Manager was successfully created.
         */
        provisioningState?: string;
        /**
         * Specifies the Sku.
         */
        sku?: outputs.storsimple.ManagerSkuResponse;
    }

    /**
     * The Sku.
     */
    export interface ManagerSkuResponse {
        /**
         * Refers to the sku name which should be "Standard"
         */
        name: string;
    }

    /**
     * The schedule recurrence.
     */
    export interface ScheduleRecurrenceResponse {
        /**
         * The recurrence type.
         */
        recurrenceType: string;
        /**
         * The recurrence value.
         */
        recurrenceValue: number;
        /**
         * The week days list. Applicable only for schedules of recurrence type 'weekly'.
         */
        weeklyDaysList?: string[];
    }

    /**
     * The storage account credential properties.
     */
    export interface StorageAccountCredentialPropertiesResponse {
        /**
         * The details of the storage account password.
         */
        accessKey?: outputs.storsimple.AsymmetricEncryptedSecretResponse;
        /**
         * The storage endpoint
         */
        endPoint: string;
        /**
         * Signifies whether SSL needs to be enabled or not.
         */
        sslStatus: string;
        /**
         * The count of volumes using this storage account credential.
         */
        volumesCount: number;
    }

    /**
     * The storage domain properties.
     */
    export interface StorageDomainPropertiesResponse {
        /**
         * The encryption key used to encrypt the data. This is a user secret.
         */
        encryptionKey?: outputs.storsimple.AsymmetricEncryptedSecretResponse;
        /**
         * The encryption status "Enabled | Disabled".
         */
        encryptionStatus: string;
        /**
         * The storage account credentials.
         */
        storageAccountCredentialIds: string[];
    }

    /**
     * The error/warning message due to which the device is ineligible as a failover target device.
     */
    export interface TargetEligibilityErrorMessageResponse {
        /**
         * The localized error message stating the reason why the device is not eligible as a target device.
         */
        message?: string;
        /**
         * The localized resolution message for the error.
         */
        resolution?: string;
        /**
         * The result code for the error, due to which the device does not qualify as a failover target device.
         */
        resultCode?: string;
    }

    /**
     * The eligibility result of device, as a failover target device.
     */
    export interface TargetEligibilityResultResponse {
        /**
         * The eligibility status of device, as a failover target device.
         */
        eligibilityStatus?: string;
        /**
         * The list of error messages, if a device does not qualify as a failover target device.
         */
        messages?: outputs.storsimple.TargetEligibilityErrorMessageResponse[];
    }

    /**
     * The time.
     */
    export interface TimeResponse {
        /**
         * The hour.
         */
        hours: number;
        /**
         * The minute.
         */
        minutes: number;
        /**
         * The second.
         */
        seconds: number;
    }

    /**
     * The metadata of the volume container, that is being considered as part of a failover set.
     */
    export interface VolumeContainerFailoverMetadataResponse {
        /**
         * The path ID of the volume container.
         */
        volumeContainerId?: string;
        /**
         * The list of metadata of volumes inside the volume container, which contains valid cloud snapshots.
         */
        volumes?: outputs.storsimple.VolumeFailoverMetadataResponse[];
    }

    /**
     * The properties of volume container.
     */
    export interface VolumeContainerPropertiesResponse {
        /**
         * The bandwidth-rate set on the volume container.
         */
        bandWidthRateInMbps?: number;
        /**
         * The ID of the bandwidth setting associated with the volume container.
         */
        bandwidthSettingId?: string;
        /**
         * The key used to encrypt data in the volume container. It is required when property 'EncryptionStatus' is "Enabled".
         */
        encryptionKey?: outputs.storsimple.AsymmetricEncryptedSecretResponse;
        /**
         * The flag to denote whether encryption is enabled or not.
         */
        encryptionStatus: string;
        /**
         * The owner ship status of the volume container. Only when the status is "NotOwned", the delete operation on the volume container is permitted.
         */
        ownerShipStatus: string;
        /**
         * The path ID of storage account associated with the volume container.
         */
        storageAccountCredentialId: string;
        /**
         * The total cloud storage for the volume container.
         */
        totalCloudStorageUsageInBytes: number;
        /**
         * The number of volumes in the volume Container.
         */
        volumeCount: number;
    }

    /**
     * The metadata of a volume that has valid cloud snapshot.
     */
    export interface VolumeFailoverMetadataResponse {
        /**
         * The date at which the snapshot was taken.
         */
        backupCreatedDate?: string;
        /**
         * The path ID of the backup-element for this volume, inside the backup set.
         */
        backupElementId?: string;
        /**
         * The path ID of the backup set.
         */
        backupId?: string;
        /**
         * The path ID of the backup policy using which the snapshot was taken.
         */
        backupPolicyId?: string;
        /**
         * The size of the volume in bytes at the time the snapshot was taken.
         */
        sizeInBytes?: number;
        /**
         * The path ID of the volume.
         */
        volumeId?: string;
        /**
         * The type of the volume.
         */
        volumeType?: string;
    }

    /**
     * The properties of volume.
     */
    export interface VolumePropertiesResponse {
        /**
         * The IDs of the access control records, associated with the volume.
         */
        accessControlRecordIds: string[];
        /**
         * The IDs of the backup policies, in which this volume is part of.
         */
        backupPolicyIds: string[];
        /**
         * The backup status of the volume.
         */
        backupStatus: string;
        /**
         * The monitoring status of the volume.
         */
        monitoringStatus: string;
        /**
         * The operation status on the volume.
         */
        operationStatus: string;
        /**
         * The size of the volume in bytes.
         */
        sizeInBytes: number;
        /**
         * The ID of the volume container, in which this volume is created.
         */
        volumeContainerId: string;
        /**
         * The volume status.
         */
        volumeStatus: string;
        /**
         * The type of the volume.
         */
        volumeType: string;
    }
}

export namespace streamanalytics {
    /**
     * Condition applicable to the resource, or to the job overall, that warrant customer attention.
     */
    export interface DiagnosticConditionResponse {
        /**
         * The opaque diagnostic code.
         */
        code: string;
        /**
         * The human-readable message describing the condition in detail. Localized in the Accept-Language of the client request.
         */
        message: string;
        /**
         * The UTC timestamp of when the condition started. Customers should be able to find a corresponding event in the ops log around this time.
         */
        since: string;
    }

    /**
     * Describes conditions applicable to the Input, Output, or the job overall, that warrant customer attention.
     */
    export interface DiagnosticsResponse {
        /**
         * A collection of zero or more conditions applicable to the resource, or to the job overall, that warrant customer attention.
         */
        conditions: outputs.streamanalytics.DiagnosticConditionResponse[];
    }

    /**
     * The properties that are associated with a function.
     */
    export interface FunctionPropertiesResponse {
        /**
         * The current entity tag for the function. This is an opaque string. You can use it to detect whether the resource has changed between requests. You can also use it in the If-Match or If-None-Match headers for write operations for optimistic concurrency.
         */
        etag: string;
        /**
         * Indicates the type of function.
         */
        type?: string;
    }

    /**
     * A function object, containing all information associated with the named function. All functions are contained under a streaming job.
     */
    export interface FunctionResponse {
        /**
         * Resource Id
         */
        id: string;
        /**
         * Resource name
         */
        name?: string;
        /**
         * The properties that are associated with a function.
         */
        properties?: outputs.streamanalytics.FunctionPropertiesResponse;
        /**
         * Resource type
         */
        type: string;
    }

    /**
     * The properties that are associated with an input.
     */
    export interface InputPropertiesResponse {
        /**
         * Describes conditions applicable to the Input, Output, or the job overall, that warrant customer attention.
         */
        diagnostics: outputs.streamanalytics.DiagnosticsResponse;
        /**
         * The current entity tag for the input. This is an opaque string. You can use it to detect whether the resource has changed between requests. You can also use it in the If-Match or If-None-Match headers for write operations for optimistic concurrency.
         */
        etag: string;
        /**
         * Describes how data from an input is serialized or how data is serialized when written to an output. Required on PUT (CreateOrReplace) requests.
         */
        serialization?: outputs.streamanalytics.SerializationResponse;
        /**
         * Indicates whether the input is a source of reference data or stream data. Required on PUT (CreateOrReplace) requests.
         */
        type?: string;
    }

    /**
     * An input object, containing all information associated with the named input. All inputs are contained under a streaming job.
     */
    export interface InputResponse {
        /**
         * Resource Id
         */
        id: string;
        /**
         * Resource name
         */
        name?: string;
        /**
         * The properties that are associated with an input. Required on PUT (CreateOrReplace) requests.
         */
        properties?: outputs.streamanalytics.InputPropertiesResponse;
        /**
         * Resource type
         */
        type: string;
    }

    /**
     * Describes the data source that output will be written to.
     */
    export interface OutputDataSourceResponse {
        /**
         * Indicates the type of data source output will be written to. Required on PUT (CreateOrReplace) requests.
         */
        type?: string;
    }

    /**
     * The properties that are associated with an output.
     */
    export interface OutputPropertiesResponse {
        /**
         * Describes the data source that output will be written to. Required on PUT (CreateOrReplace) requests.
         */
        datasource?: outputs.streamanalytics.OutputDataSourceResponse;
        /**
         * Describes conditions applicable to the Input, Output, or the job overall, that warrant customer attention.
         */
        diagnostics: outputs.streamanalytics.DiagnosticsResponse;
        /**
         * The current entity tag for the output. This is an opaque string. You can use it to detect whether the resource has changed between requests. You can also use it in the If-Match or If-None-Match headers for write operations for optimistic concurrency.
         */
        etag: string;
        /**
         * Describes how data from an input is serialized or how data is serialized when written to an output. Required on PUT (CreateOrReplace) requests.
         */
        serialization?: outputs.streamanalytics.SerializationResponse;
    }

    /**
     * An output object, containing all information associated with the named output. All outputs are contained under a streaming job.
     */
    export interface OutputResponse {
        /**
         * Resource Id
         */
        id: string;
        /**
         * Resource name
         */
        name?: string;
        /**
         * The properties that are associated with an output. Required on PUT (CreateOrReplace) requests.
         */
        properties?: outputs.streamanalytics.OutputPropertiesResponse;
        /**
         * Resource type
         */
        type: string;
    }

    /**
     * Describes how data from an input is serialized or how data is serialized when written to an output.
     */
    export interface SerializationResponse {
        /**
         * Indicates the type of serialization that the input or output uses. Required on PUT (CreateOrReplace) requests.
         */
        type?: string;
    }

    /**
     * The properties that are associated with a SKU.
     */
    export interface SkuResponse {
        /**
         * The name of the SKU. Required on PUT (CreateOrReplace) requests.
         */
        name?: string;
    }

    /**
     * The properties that are associated with a streaming job.
     */
    export interface StreamingJobPropertiesResponse {
        /**
         * Controls certain runtime behaviors of the streaming job.
         */
        compatibilityLevel?: string;
        /**
         * Value is an ISO-8601 formatted UTC timestamp indicating when the streaming job was created.
         */
        createdDate: string;
        /**
         * The data locale of the stream analytics job. Value should be the name of a supported .NET Culture from the set https://msdn.microsoft.com/en-us/library/system.globalization.culturetypes(v=vs.110).aspx. Defaults to 'en-US' if none specified.
         */
        dataLocale?: string;
        /**
         * The current entity tag for the streaming job. This is an opaque string. You can use it to detect whether the resource has changed between requests. You can also use it in the If-Match or If-None-Match headers for write operations for optimistic concurrency.
         */
        etag: string;
        /**
         * The maximum tolerable delay in seconds where events arriving late could be included.  Supported range is -1 to 1814399 (20.23:59:59 days) and -1 is used to specify wait indefinitely. If the property is absent, it is interpreted to have a value of -1.
         */
        eventsLateArrivalMaxDelayInSeconds?: number;
        /**
         * The maximum tolerable delay in seconds where out-of-order events can be adjusted to be back in order.
         */
        eventsOutOfOrderMaxDelayInSeconds?: number;
        /**
         * Indicates the policy to apply to events that arrive out of order in the input event stream.
         */
        eventsOutOfOrderPolicy?: string;
        /**
         * A list of one or more functions for the streaming job. The name property for each function is required when specifying this property in a PUT request. This property cannot be modify via a PATCH operation. You must use the PATCH API available for the individual transformation.
         */
        functions?: outputs.streamanalytics.FunctionResponse[];
        /**
         * A list of one or more inputs to the streaming job. The name property for each input is required when specifying this property in a PUT request. This property cannot be modify via a PATCH operation. You must use the PATCH API available for the individual input.
         */
        inputs?: outputs.streamanalytics.InputResponse[];
        /**
         * A GUID uniquely identifying the streaming job. This GUID is generated upon creation of the streaming job.
         */
        jobId: string;
        /**
         * Describes the state of the streaming job.
         */
        jobState: string;
        /**
         * Value is either an ISO-8601 formatted timestamp indicating the last output event time of the streaming job or null indicating that output has not yet been produced. In case of multiple outputs or multiple streams, this shows the latest value in that set.
         */
        lastOutputEventTime: string;
        /**
         * Indicates the policy to apply to events that arrive at the output and cannot be written to the external storage due to being malformed (missing column values, column values of wrong type or size).
         */
        outputErrorPolicy?: string;
        /**
         * This property should only be utilized when it is desired that the job be started immediately upon creation. Value may be JobStartTime, CustomTime, or LastOutputEventTime to indicate whether the starting point of the output event stream should start whenever the job is started, start at a custom user time stamp specified via the outputStartTime property, or start from the last event output time.
         */
        outputStartMode?: string;
        /**
         * Value is either an ISO-8601 formatted time stamp that indicates the starting point of the output event stream, or null to indicate that the output event stream will start whenever the streaming job is started. This property must have a value if outputStartMode is set to CustomTime.
         */
        outputStartTime?: string;
        /**
         * A list of one or more outputs for the streaming job. The name property for each output is required when specifying this property in a PUT request. This property cannot be modify via a PATCH operation. You must use the PATCH API available for the individual output.
         */
        outputs?: outputs.streamanalytics.OutputResponse[];
        /**
         * Describes the provisioning status of the streaming job.
         */
        provisioningState: string;
        /**
         * Describes the SKU of the streaming job. Required on PUT (CreateOrReplace) requests.
         */
        sku?: outputs.streamanalytics.SkuResponse;
        /**
         * Indicates the query and the number of streaming units to use for the streaming job. The name property of the transformation is required when specifying this property in a PUT request. This property cannot be modify via a PATCH operation. You must use the PATCH API available for the individual transformation.
         */
        transformation?: outputs.streamanalytics.TransformationResponse;
    }

    /**
     * The properties that are associated with a transformation.
     */
    export interface TransformationPropertiesResponse {
        /**
         * The current entity tag for the transformation. This is an opaque string. You can use it to detect whether the resource has changed between requests. You can also use it in the If-Match or If-None-Match headers for write operations for optimistic concurrency.
         */
        etag: string;
        /**
         * Specifies the query that will be run in the streaming job. You can learn more about the Stream Analytics Query Language (SAQL) here: https://msdn.microsoft.com/library/azure/dn834998 . Required on PUT (CreateOrReplace) requests.
         */
        query?: string;
        /**
         * Specifies the number of streaming units that the streaming job uses.
         */
        streamingUnits?: number;
    }

    /**
     * A transformation object, containing all information associated with the named transformation. All transformations are contained under a streaming job.
     */
    export interface TransformationResponse {
        /**
         * Resource Id
         */
        id: string;
        /**
         * Resource name
         */
        name?: string;
        /**
         * The properties that are associated with a transformation. Required on PUT (CreateOrReplace) requests.
         */
        properties?: outputs.streamanalytics.TransformationPropertiesResponse;
        /**
         * Resource type
         */
        type: string;
    }
}

export namespace timeseriesinsights {
    export interface AccessPolicyResourcePropertiesResponse {
        /**
         * An description of the access policy.
         */
        description?: string;
        /**
         * The objectId of the principal in Azure Active Directory.
         */
        principalObjectId?: string;
        /**
         * The list of roles the principal is assigned on the environment.
         */
        roles?: string[];
    }

    /**
     * A key property for the reference data set. A reference data set can have multiple key properties.
     */
    export interface ReferenceDataSetKeyPropertyResponse {
        /**
         * The name of the key property.
         */
        name?: string;
        /**
         * The type of the key property.
         */
        type?: string;
    }

    /**
     * Properties of the reference data set.
     */
    export interface ReferenceDataSetResourcePropertiesResponse {
        /**
         * The time the resource was created.
         */
        creationTime: string;
        /**
         * The reference data set key comparison behavior can be set using this property. By default, the value is 'Ordinal' - which means case sensitive key comparison will be performed while joining reference data with events or while adding new reference data. When 'OrdinalIgnoreCase' is set, case insensitive comparison will be used.
         */
        dataStringComparisonBehavior?: string;
        /**
         * The list of key properties for the reference data set.
         */
        keyProperties: outputs.timeseriesinsights.ReferenceDataSetKeyPropertyResponse[];
        /**
         * Provisioning state of the resource.
         */
        provisioningState?: string;
    }

    /**
     * The sku determines the type of environment, either Gen1 (S1 or S2) or Gen2 (L1). For Gen1 environments the sku determines the capacity of the environment, the ingress rate, and the billing rate.
     */
    export interface SkuResponse {
        /**
         * The capacity of the sku. For Gen1 environments, this value can be changed to support scale out of environments after they have been created.
         */
        capacity: number;
        /**
         * The name of this SKU.
         */
        name: string;
    }
}

export namespace virtualmachineimages {
    /**
     * Describes a unit of image customization
     */
    export interface ImageTemplateCustomizerResponse {
        /**
         * Friendly Name to provide context on what this customization step does
         */
        name?: string;
        /**
         * The type of customization tool you want to use on the Image. For example, "Shell" can be shell customizer
         */
        type: string;
    }

    /**
     * Generic distribution object
     */
    export interface ImageTemplateDistributorResponse {
        /**
         * Tags that will be applied to the artifact once it has been created/updated by the distributor.
         */
        artifactTags?: {[key: string]: string};
        /**
         * The name to be used for the associated RunOutput.
         */
        runOutputName: string;
        /**
         * Type of distribution.
         */
        type: string;
    }

    /**
     * Identity for the image template.
     */
    export interface ImageTemplateIdentityResponse {
        /**
         * The type of identity used for the image template. The type 'None' will remove any identities from the image template.
         */
        type?: string;
        /**
         * The list of user identities associated with the image template. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
         */
        userAssignedIdentities?: {[key: string]: string};
    }

    /**
     * Describes the latest status of running an image template
     */
    export interface ImageTemplateLastRunStatusResponse {
        /**
         * End time of the last run (UTC)
         */
        endTime?: string;
        /**
         * Verbose information about the last run state
         */
        message?: string;
        /**
         * State of the last run
         */
        runState?: string;
        /**
         * Sub-state of the last run
         */
        runSubState?: string;
        /**
         * Start time of the last run (UTC)
         */
        startTime?: string;
    }

    /**
     * Describes the properties of an image template
     */
    export interface ImageTemplatePropertiesResponse {
        /**
         * Maximum duration to wait while building the image template. Omit or specify 0 to use the default (4 hours).
         */
        buildTimeoutInMinutes?: number;
        /**
         * Specifies the properties used to describe the customization steps of the image, like Image source etc
         */
        customize?: outputs.virtualmachineimages.ImageTemplateCustomizerResponse[];
        /**
         * The distribution targets where the image output needs to go to.
         */
        distribute: outputs.virtualmachineimages.ImageTemplateDistributorResponse[];
        /**
         * State of 'run' that is currently executing or was last executed.
         */
        lastRunStatus: outputs.virtualmachineimages.ImageTemplateLastRunStatusResponse;
        /**
         * Provisioning error, if any
         */
        provisioningError: outputs.virtualmachineimages.ProvisioningErrorResponse;
        /**
         * Provisioning state of the resource
         */
        provisioningState: string;
        /**
         * Specifies the properties used to describe the source image.
         */
        source: outputs.virtualmachineimages.ImageTemplateSourceResponse;
        /**
         * Describes how virtual machine is set up to build images
         */
        vmProfile?: outputs.virtualmachineimages.ImageTemplateVmProfileResponse;
    }

    /**
     * Describes a virtual machine image source for building, customizing and distributing
     */
    export interface ImageTemplateSourceResponse {
        /**
         * Specifies the type of source image you want to start with.
         */
        type: string;
    }

    /**
     * Describes the virtual machine used to build, customize and capture images
     */
    export interface ImageTemplateVmProfileResponse {
        /**
         * Size of the OS disk in GB. Omit or specify 0 to use Azure's default OS disk size.
         */
        osDiskSizeGB?: number;
        /**
         * Size of the virtual machine used to build, customize and capture images. Omit or specify empty string to use the default (Standard_D1_v2).
         */
        vmSize?: string;
        /**
         * Optional configuration of the virtual network to use to deploy the build virtual machine in. Omit if no specific virtual network needs to be used.
         */
        vnetConfig?: outputs.virtualmachineimages.VirtualNetworkConfigResponse;
    }

    /**
     * Describes the error happened when create or update an image template
     */
    export interface ProvisioningErrorResponse {
        /**
         * Verbose error message about the provisioning failure
         */
        message?: string;
        /**
         * Error code of the provisioning failure
         */
        provisioningErrorCode?: string;
    }

    /**
     * Virtual Network configuration.
     */
    export interface VirtualNetworkConfigResponse {
        /**
         * Resource id of a pre-existing subnet.
         */
        subnetId?: string;
    }
}

export namespace vmwarecloudsimple {
    /**
     * Properties of dedicated cloud node
     */
    export interface DedicatedCloudNodePropertiesResponse {
        /**
         * Availability Zone id, e.g. "az1"
         */
        availabilityZoneId: string;
        /**
         * Availability Zone name, e.g. "Availability Zone 1"
         */
        availabilityZoneName: string;
        /**
         * VMWare Cloud Rack Name
         */
        cloudRackName: string;
        /**
         * date time the resource was created
         */
        created: {[key: string]: string};
        /**
         * count of nodes to create
         */
        nodesCount: number;
        /**
         * Placement Group id, e.g. "n1"
         */
        placementGroupId: string;
        /**
         * Placement Name, e.g. "Placement Group 1"
         */
        placementGroupName: string;
        /**
         * Private Cloud Id
         */
        privateCloudId: string;
        /**
         * Resource Pool Name
         */
        privateCloudName: string;
        /**
         * The provisioning status of the resource
         */
        provisioningState: string;
        /**
         * purchase id
         */
        purchaseId: string;
        /**
         * Dedicated Cloud Nodes SKU's description
         */
        skuDescription?: outputs.vmwarecloudsimple.SkuDescriptionResponse;
        /**
         * Node status, indicates is private cloud set up on this node or not
         */
        status: string;
        /**
         * VMWare Cluster Name
         */
        vmwareClusterName: string;
    }

    /**
     * Properties of dedicated cloud service
     */
    export interface DedicatedCloudServicePropertiesResponse {
        /**
         * gateway Subnet for the account. It will collect the subnet address and always treat it as /28
         */
        gatewaySubnet: string;
        /**
         * indicates whether account onboarded or not in a given region
         */
        isAccountOnboarded: string;
        /**
         * total nodes purchased
         */
        nodes: number;
        /**
         * link to a service management web portal
         */
        serviceURL: string;
    }

    /**
     * Guest OS Customization properties
     */
    export interface GuestOSCustomizationResponse {
        /**
         * List of dns servers to use
         */
        dnsServers?: string[];
        /**
         * Virtual Machine hostname
         */
        hostName?: string;
        /**
         * Password for login
         */
        password?: string;
        /**
         * id of customization policy
         */
        policyId?: string;
        /**
         * Username for login
         */
        username?: string;
    }

    /**
     * Guest OS nic customization
     */
    export interface GuestOSNICCustomizationResponse {
        /**
         * IP address allocation method
         */
        allocation?: string;
        /**
         * List of dns servers to use
         */
        dnsServers?: string[];
        /**
         * Gateway addresses assigned to nic
         */
        gateway?: string[];
        /**
         * Static ip address for nic
         */
        ipAddress?: string;
        /**
         * Network mask for nic
         */
        mask?: string;
        /**
         * primary WINS server for Windows
         */
        primaryWinsServer?: string;
        /**
         * secondary WINS server for Windows
         */
        secondaryWinsServer?: string;
    }

    /**
     * Properties of resource pool
     */
    export interface ResourcePoolPropertiesResponse {
        /**
         * Hierarchical resource pool name
         */
        fullName: string;
    }

    /**
     * Resource pool model
     */
    export interface ResourcePoolResponse {
        /**
         * resource pool id (privateCloudId:vsphereId)
         */
        id: string;
        /**
         * Azure region
         */
        location: string;
        /**
         * {ResourcePoolName}
         */
        name: string;
        /**
         * The Private Cloud Id
         */
        privateCloudId: string;
        /**
         * Resource pool properties
         */
        properties?: outputs.vmwarecloudsimple.ResourcePoolPropertiesResponse;
        /**
         * {resourceProviderNamespace}/{resourceType}
         */
        type: string;
    }

    /**
     * The purchase SKU for CloudSimple paid resources
     */
    export interface SkuDescriptionResponse {
        /**
         * SKU's id
         */
        id: string;
        /**
         * SKU's name
         */
        name: string;
    }

    /**
     * The purchase SKU for CloudSimple paid resources
     */
    export interface SkuResponse {
        /**
         * The capacity of the SKU
         */
        capacity?: string;
        /**
         * dedicatedCloudNode example: 8 x Ten-Core Intel® Xeon® Processor E5-2640 v4 2.40GHz 25MB Cache (90W); 12 x 64GB PC4-19200 2400MHz DDR4 ECC Registered DIMM, ...
         */
        description?: string;
        /**
         * If the service has different generations of hardware, for the same SKU, then that can be captured here
         */
        family?: string;
        /**
         * The name of the SKU for VMWare CloudSimple Node
         */
        name: string;
        /**
         * The tier of the SKU
         */
        tier?: string;
    }

    /**
     * Tags model
     */
    export interface TagsResponse {
    }

    /**
     * Virtual disk controller model
     */
    export interface VirtualDiskControllerResponse {
        /**
         * Controller's id
         */
        id: string;
        /**
         * The display name of Controller
         */
        name: string;
        /**
         * dik controller subtype (VMWARE_PARAVIRTUAL, BUS_PARALLEL, LSI_PARALLEL, LSI_SAS)
         */
        subType: string;
        /**
         * disk controller type (SCSI)
         */
        type: string;
    }

    /**
     * Virtual disk model
     */
    export interface VirtualDiskResponse {
        /**
         * Disk's Controller id
         */
        controllerId: string;
        /**
         * Disk's independence mode type
         */
        independenceMode: string;
        /**
         * Disk's total size
         */
        totalSize: number;
        /**
         * Disk's id
         */
        virtualDiskId?: string;
        /**
         * Disk's display name
         */
        virtualDiskName: string;
    }

    /**
     * Properties of virtual machine
     */
    export interface VirtualMachinePropertiesResponse {
        /**
         * The amount of memory
         */
        amountOfRam: number;
        /**
         * The list of Virtual Disks' Controllers
         */
        controllers: outputs.vmwarecloudsimple.VirtualDiskControllerResponse[];
        /**
         * Virtual machine properties
         */
        customization?: outputs.vmwarecloudsimple.GuestOSCustomizationResponse;
        /**
         * The list of Virtual Disks
         */
        disks?: outputs.vmwarecloudsimple.VirtualDiskResponse[];
        /**
         * The DNS name of Virtual Machine in VCenter
         */
        dnsname: string;
        /**
         * Expose Guest OS or not
         */
        exposeToGuestVM?: boolean;
        /**
         * The path to virtual machine folder in VCenter
         */
        folder: string;
        /**
         * The name of Guest OS
         */
        guestOS: string;
        /**
         * The Guest OS type
         */
        guestOSType: string;
        /**
         * The list of Virtual NICs
         */
        nics?: outputs.vmwarecloudsimple.VirtualNicResponse[];
        /**
         * The number of CPU cores
         */
        numberOfCores: number;
        /**
         * Password for login. Deprecated - use customization property
         */
        password?: string;
        /**
         * Private Cloud Id
         */
        privateCloudId: string;
        /**
         * The provisioning status of the resource
         */
        provisioningState: string;
        /**
         * The public ip of Virtual Machine
         */
        publicIP: string;
        /**
         * Virtual Machines Resource Pool
         */
        resourcePool?: outputs.vmwarecloudsimple.ResourcePoolResponse;
        /**
         * The status of Virtual machine
         */
        status: string;
        /**
         * Virtual Machine Template Id
         */
        templateId?: string;
        /**
         * Username for login. Deprecated - use customization property
         */
        username?: string;
        /**
         * The list of Virtual VSphere Networks
         */
        vSphereNetworks?: string[];
        /**
         * The internal id of Virtual Machine in VCenter
         */
        vmId: string;
        /**
         * VMware tools version
         */
        vmwaretools: string;
    }

    /**
     * Properties of virtual network
     */
    export interface VirtualNetworkPropertiesResponse {
        /**
         * The Private Cloud id
         */
        privateCloudId: string;
    }

    /**
     * Virtual network model
     */
    export interface VirtualNetworkResponse {
        /**
         * can be used in vm creation/deletion
         */
        assignable: boolean;
        /**
         * virtual network id (privateCloudId:vsphereId)
         */
        id: string;
        /**
         * Azure region
         */
        location: string;
        /**
         * {VirtualNetworkName}
         */
        name: string;
        /**
         * Virtual Network properties
         */
        properties?: outputs.vmwarecloudsimple.VirtualNetworkPropertiesResponse;
        /**
         * {resourceProviderNamespace}/{resourceType}
         */
        type: string;
    }

    /**
     * Virtual NIC model
     */
    export interface VirtualNicResponse {
        /**
         * guest OS customization for nic
         */
        customization?: outputs.vmwarecloudsimple.GuestOSNICCustomizationResponse;
        /**
         * NIC ip address
         */
        ipAddresses?: string[];
        /**
         * NIC MAC address
         */
        macAddress?: string;
        /**
         * Virtual Network
         */
        network: outputs.vmwarecloudsimple.VirtualNetworkResponse;
        /**
         * NIC type
         */
        nicType: string;
        /**
         * Is NIC powered on/off on boot
         */
        powerOnBoot?: boolean;
        /**
         * NIC id
         */
        virtualNicId?: string;
        /**
         * NIC name
         */
        virtualNicName: string;
    }
}

export namespace web {
    /**
     * Information about the formal API definition for the app.
     */
    export interface ApiDefinitionInfoResponse {
        /**
         * The URL of the API definition.
         */
        url?: string;
    }

    /**
     * Azure API management (APIM) configuration linked to the app.
     */
    export interface ApiManagementConfigResponse {
        /**
         * APIM-Api Identifier.
         */
        id?: string;
    }

    /**
     * Description of an App Service Environment.
     */
    export interface AppServiceEnvironmentResponse {
        /**
         * List of comma separated strings describing which VM sizes are allowed for front-ends.
         */
        allowedMultiSizes: string;
        /**
         * List of comma separated strings describing which VM sizes are allowed for workers.
         */
        allowedWorkerSizes: string;
        /**
         * API Management Account associated with the App Service Environment.
         */
        apiManagementAccountId?: string;
        /**
         * Custom settings for changing the behavior of the App Service Environment.
         */
        clusterSettings?: outputs.web.NameValuePairResponse[];
        /**
         * Edition of the metadata database for the App Service Environment, e.g. "Standard".
         */
        databaseEdition: string;
        /**
         * Service objective of the metadata database for the App Service Environment, e.g. "S0".
         */
        databaseServiceObjective: string;
        /**
         * Default Scale Factor for FrontEnds.
         */
        defaultFrontEndScaleFactor: number;
        /**
         * DNS suffix of the App Service Environment.
         */
        dnsSuffix?: string;
        /**
         * True/false indicating whether the App Service Environment is suspended. The environment can be suspended e.g. when the management endpoint is no longer available
         * (most likely because NSG blocked the incoming traffic).
         */
        dynamicCacheEnabled?: boolean;
        /**
         * Current total, used, and available worker capacities.
         */
        environmentCapacities: outputs.web.StampCapacityResponse[];
        /**
         * True/false indicating whether the App Service Environment is healthy.
         */
        environmentIsHealthy: boolean;
        /**
         * Detailed message about with results of the last check of the App Service Environment.
         */
        environmentStatus: string;
        /**
         * Scale factor for front-ends.
         */
        frontEndScaleFactor?: number;
        /**
         * Flag that displays whether an ASE has linux workers or not
         */
        hasLinuxWorkers?: boolean;
        /**
         * Specifies which endpoints to serve internally in the Virtual Network for the App Service Environment.
         */
        internalLoadBalancingMode?: string;
        /**
         * Number of IP SSL addresses reserved for the App Service Environment.
         */
        ipsslAddressCount?: number;
        /**
         * Last deployment action on the App Service Environment.
         */
        lastAction: string;
        /**
         * Result of the last deployment action on the App Service Environment.
         */
        lastActionResult: string;
        /**
         * Location of the App Service Environment, e.g. "West US".
         */
        location: string;
        /**
         * Maximum number of VMs in the App Service Environment.
         */
        maximumNumberOfMachines: number;
        /**
         * Number of front-end instances.
         */
        multiRoleCount?: number;
        /**
         * Front-end VM size, e.g. "Medium", "Large".
         */
        multiSize?: string;
        /**
         * Name of the App Service Environment.
         */
        name: string;
        /**
         * Access control list for controlling traffic to the App Service Environment.
         */
        networkAccessControlList?: outputs.web.NetworkAccessControlEntryResponse[];
        /**
         * Provisioning state of the App Service Environment.
         */
        provisioningState: string;
        /**
         * Resource group of the App Service Environment.
         */
        resourceGroup: string;
        /**
         * Key Vault ID for ILB App Service Environment default SSL certificate
         */
        sslCertKeyVaultId?: string;
        /**
         * Key Vault Secret Name for ILB App Service Environment default SSL certificate
         */
        sslCertKeyVaultSecretName?: string;
        /**
         * Current status of the App Service Environment.
         */
        status: string;
        /**
         * Subscription of the App Service Environment.
         */
        subscriptionId: string;
        /**
         * <code>true</code> if the App Service Environment is suspended; otherwise, <code>false</code>. The environment can be suspended, e.g. when the management endpoint is no longer available
         *  (most likely because NSG blocked the incoming traffic).
         */
        suspended?: boolean;
        /**
         * Number of upgrade domains of the App Service Environment.
         */
        upgradeDomains: number;
        /**
         * User added ip ranges to whitelist on ASE db
         */
        userWhitelistedIpRanges?: string[];
        /**
         * Description of IP SSL mapping for the App Service Environment.
         */
        vipMappings: outputs.web.VirtualIPMappingResponse[];
        /**
         * Description of the Virtual Network.
         */
        virtualNetwork: outputs.web.VirtualNetworkProfileResponse;
        /**
         * Name of the Virtual Network for the App Service Environment.
         */
        vnetName?: string;
        /**
         * Resource group of the Virtual Network.
         */
        vnetResourceGroupName?: string;
        /**
         * Subnet of the Virtual Network.
         */
        vnetSubnetName?: string;
        /**
         * Description of worker pools with worker size IDs, VM sizes, and number of workers in each pool.
         */
        workerPools: outputs.web.WorkerPoolResponse[];
    }

    /**
     * AppServicePlan resource specific properties
     */
    export interface AppServicePlanResponseProperties {
        /**
         * The time when the server farm free offer expires.
         */
        freeOfferExpirationTime?: string;
        /**
         * Geographical location for the App Service plan.
         */
        geoRegion: string;
        /**
         * Specification for the App Service Environment to use for the App Service plan.
         */
        hostingEnvironmentProfile?: outputs.web.HostingEnvironmentProfileResponse;
        /**
         * If Hyper-V container app service plan <code>true</code>, <code>false</code> otherwise.
         */
        hyperV?: boolean;
        /**
         * If <code>true</code>, this App Service Plan owns spot instances.
         */
        isSpot?: boolean;
        /**
         * Obsolete: If Hyper-V container app service plan <code>true</code>, <code>false</code> otherwise.
         */
        isXenon?: boolean;
        /**
         * Maximum number of total workers allowed for this ElasticScaleEnabled App Service Plan
         */
        maximumElasticWorkerCount?: number;
        /**
         * Maximum number of instances that can be assigned to this App Service plan.
         */
        maximumNumberOfWorkers: number;
        /**
         * Number of apps assigned to this App Service plan.
         */
        numberOfSites: number;
        /**
         * If <code>true</code>, apps assigned to this App Service plan can be scaled independently.
         * If <code>false</code>, apps assigned to this App Service plan will scale to all instances of the plan.
         */
        perSiteScaling?: boolean;
        /**
         * Provisioning state of the App Service Environment.
         */
        provisioningState: string;
        /**
         * If Linux app service plan <code>true</code>, <code>false</code> otherwise.
         */
        reserved?: boolean;
        /**
         * Resource group of the App Service plan.
         */
        resourceGroup: string;
        /**
         * The time when the server farm expires. Valid only if it is a spot server farm.
         */
        spotExpirationTime?: string;
        /**
         * App Service plan status.
         */
        status: string;
        /**
         * App Service plan subscription.
         */
        subscription: string;
        /**
         * Scaling worker count.
         */
        targetWorkerCount?: number;
        /**
         * Scaling worker size ID.
         */
        targetWorkerSizeId?: number;
        /**
         * Target worker tier assigned to the App Service plan.
         */
        workerTierName?: string;
    }

    /**
     * A wrapper for an ARM resource id
     */
    export interface ArmIdWrapperResponse {
        id: string;
    }

    /**
     * Actions which to take by the auto-heal module when a rule is triggered.
     */
    export interface AutoHealActionsResponse {
        /**
         * Predefined action to be taken.
         */
        actionType?: string;
        /**
         * Custom action to be taken.
         */
        customAction?: outputs.web.AutoHealCustomActionResponse;
        /**
         * Minimum time the process must execute
         * before taking the action
         */
        minProcessExecutionTime?: string;
    }

    /**
     * Custom action to be executed
     * when an auto heal rule is triggered.
     */
    export interface AutoHealCustomActionResponse {
        /**
         * Executable to be run.
         */
        exe?: string;
        /**
         * Parameters for the executable.
         */
        parameters?: string;
    }

    /**
     * Rules that can be defined for auto-heal.
     */
    export interface AutoHealRulesResponse {
        /**
         * Actions to be executed when a rule is triggered.
         */
        actions?: outputs.web.AutoHealActionsResponse;
        /**
         * Conditions that describe when to execute the auto-heal actions.
         */
        triggers?: outputs.web.AutoHealTriggersResponse;
    }

    /**
     * Triggers for auto-heal.
     */
    export interface AutoHealTriggersResponse {
        /**
         * A rule based on private bytes.
         */
        privateBytesInKB?: number;
        /**
         * A rule based on total requests.
         */
        requests?: outputs.web.RequestsBasedTriggerResponse;
        /**
         * A rule based on request execution time.
         */
        slowRequests?: outputs.web.SlowRequestsBasedTriggerResponse;
        /**
         * A rule based on status codes.
         */
        statusCodes?: outputs.web.StatusCodesBasedTriggerResponse[];
    }

    /**
     * Backup description.
     */
    export interface BackupItemResponse {
        /**
         * Resource Id.
         */
        id: string;
        /**
         * Kind of resource.
         */
        kind?: string;
        /**
         * Resource Name.
         */
        name: string;
        /**
         * BackupItem resource specific properties
         */
        properties?: outputs.web.BackupItemResponseProperties;
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * BackupItem resource specific properties
     */
    export interface BackupItemResponseProperties {
        /**
         * Name of the blob which contains data for this backup.
         */
        blobName: string;
        /**
         * Unique correlation identifier. Please use this along with the timestamp while communicating with Azure support.
         */
        correlationId: string;
        /**
         * Timestamp of the backup creation.
         */
        created: string;
        /**
         * List of databases included in the backup.
         */
        databases: outputs.web.DatabaseBackupSettingResponse[];
        /**
         * Timestamp when this backup finished.
         */
        finishedTimeStamp: string;
        /**
         * Id of the backup.
         */
        id: number;
        /**
         * Timestamp of a last restore operation which used this backup.
         */
        lastRestoreTimeStamp: string;
        /**
         * Details regarding this backup. Might contain an error message.
         */
        log: string;
        /**
         * Name of this backup.
         */
        name: string;
        /**
         * True if this backup has been created due to a schedule being triggered.
         */
        scheduled: boolean;
        /**
         * Size of the backup in bytes.
         */
        sizeInBytes: number;
        /**
         * Backup status.
         */
        status: string;
        /**
         * SAS URL for the storage account container which contains this backup.
         */
        storageAccountUrl: string;
        /**
         * Size of the original web app which has been backed up.
         */
        websiteSizeInBytes: number;
    }

    /**
     * Describes the capabilities/features allowed for a specific SKU.
     */
    export interface CapabilityResponse {
        /**
         * Name of the SKU capability.
         */
        name?: string;
        /**
         * Reason of the SKU capability.
         */
        reason?: string;
        /**
         * Value of the SKU capability.
         */
        value?: string;
    }

    /**
     * Certificate resource specific properties
     */
    export interface CertificateResponseProperties {
        /**
         * CNAME of the certificate to be issued via free certificate
         */
        canonicalName?: string;
        /**
         * Raw bytes of .cer file
         */
        cerBlob: string;
        /**
         * Certificate expiration date.
         */
        expirationDate: string;
        /**
         * Friendly name of the certificate.
         */
        friendlyName: string;
        /**
         * Host names the certificate applies to.
         */
        hostNames?: string[];
        /**
         * Specification for the App Service Environment to use for the certificate.
         */
        hostingEnvironmentProfile: outputs.web.HostingEnvironmentProfileResponse;
        /**
         * Certificate issue Date.
         */
        issueDate: string;
        /**
         * Certificate issuer.
         */
        issuer: string;
        /**
         * Key Vault Csm resource Id.
         */
        keyVaultId?: string;
        /**
         * Key Vault secret name.
         */
        keyVaultSecretName?: string;
        /**
         * Status of the Key Vault secret.
         */
        keyVaultSecretStatus: string;
        /**
         * Certificate password.
         */
        password: string;
        /**
         * Pfx blob.
         */
        pfxBlob?: string;
        /**
         * Public key hash.
         */
        publicKeyHash: string;
        /**
         * Self link.
         */
        selfLink: string;
        /**
         * Resource ID of the associated App Service plan, formatted as: "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
         */
        serverFarmId?: string;
        /**
         * App name.
         */
        siteName: string;
        /**
         * Subject name of the certificate.
         */
        subjectName: string;
        /**
         * Certificate thumbprint.
         */
        thumbprint: string;
        /**
         * Is the certificate valid?.
         */
        valid: boolean;
    }

    /**
     * Information needed for cloning operation.
     */
    export interface CloningInfoResponse {
        /**
         * Application setting overrides for cloned app. If specified, these settings override the settings cloned 
         * from source app. Otherwise, application settings from source app are retained.
         */
        appSettingsOverrides?: {[key: string]: string};
        /**
         * <code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.
         */
        cloneCustomHostNames?: boolean;
        /**
         * <code>true</code> to clone source control from source app; otherwise, <code>false</code>.
         */
        cloneSourceControl?: boolean;
        /**
         * <code>true</code> to configure load balancing for source and destination app.
         */
        configureLoadBalancing?: boolean;
        /**
         * Correlation ID of cloning operation. This ID ties multiple cloning operations
         * together to use the same snapshot.
         */
        correlationId?: string;
        /**
         * App Service Environment.
         */
        hostingEnvironment?: string;
        /**
         * <code>true</code> to overwrite destination app; otherwise, <code>false</code>.
         */
        overwrite?: boolean;
        /**
         * ARM resource ID of the source app. App resource ID is of the form 
         * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots and 
         * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for other slots.
         */
        sourceWebAppId: string;
        /**
         * Location of source app ex: West US or North Europe
         */
        sourceWebAppLocation?: string;
        /**
         * ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager resource ID is of the form 
         * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
         */
        trafficManagerProfileId?: string;
        /**
         * Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile does not already exist.
         */
        trafficManagerProfileName?: string;
    }

    /**
     * Database connection string information.
     */
    export interface ConnStringInfoResponse {
        /**
         * Connection string value.
         */
        connectionString?: string;
        /**
         * Name of connection string.
         */
        name?: string;
        /**
         * Type of database.
         */
        type?: string;
    }

    /**
     * Cross-Origin Resource Sharing (CORS) settings for the app.
     */
    export interface CorsSettingsResponse {
        /**
         * Gets or sets the list of origins that should be allowed to make cross-origin
         * calls (for example: http://example.com:12345). Use "*" to allow all.
         */
        allowedOrigins?: string[];
        /**
         * Gets or sets whether CORS requests with credentials are allowed. See 
         * https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
         * for more details.
         */
        supportCredentials?: boolean;
    }

    /**
     * Database backup settings.
     */
    export interface DatabaseBackupSettingResponse {
        /**
         * Contains a connection string to a database which is being backed up or restored. If the restore should happen to a new database, the database name inside is the new one.
         */
        connectionString?: string;
        /**
         * Contains a connection string name that is linked to the SiteConfig.ConnectionStrings.
         * This is used during restore with overwrite connection strings options.
         */
        connectionStringName?: string;
        /**
         * Database type (e.g. SqlAzure / MySql).
         */
        databaseType: string;
        name?: string;
    }

    /**
     * Deployment resource specific properties
     */
    export interface DeploymentResponseProperties {
        /**
         * True if deployment is currently active, false if completed and null if not started.
         */
        active?: boolean;
        /**
         * Who authored the deployment.
         */
        author?: string;
        /**
         * Author email.
         */
        author_email?: string;
        /**
         * Who performed the deployment.
         */
        deployer?: string;
        /**
         * Details on deployment.
         */
        details?: string;
        /**
         * End time.
         */
        end_time?: string;
        /**
         * Details about deployment status.
         */
        message?: string;
        /**
         * Start time.
         */
        start_time?: string;
        /**
         * Deployment status.
         */
        status?: number;
    }

    /**
     * Routing rules in production experiments.
     */
    export interface ExperimentsResponse {
        /**
         * List of ramp-up rules.
         */
        rampUpRules?: outputs.web.RampUpRuleResponse[];
    }

    /**
     * FunctionEnvelope resource specific properties
     */
    export interface FunctionEnvelopeResponseProperties {
        /**
         * Config information.
         */
        config?: {[key: string]: string};
        /**
         * Config URI.
         */
        config_href?: string;
        /**
         * File list.
         */
        files?: {[key: string]: string};
        /**
         * Function App ID.
         */
        function_app_id?: string;
        /**
         * Function URI.
         */
        href?: string;
        /**
         * The invocation URL
         */
        invoke_url_template?: string;
        /**
         * Gets or sets a value indicating whether the function is disabled
         */
        isDisabled?: boolean;
        /**
         * The function language
         */
        language?: string;
        /**
         * Script URI.
         */
        script_href?: string;
        /**
         * Script root path URI.
         */
        script_root_path_href?: string;
        /**
         * Secrets file URI.
         */
        secrets_file_href?: string;
        /**
         * Test data used when testing via the Azure Portal.
         */
        test_data?: string;
        /**
         * Test data URI.
         */
        test_data_href?: string;
    }

    /**
     * FunctionSecrets resource specific properties
     */
    export interface FunctionSecretsResponseProperties {
        /**
         * Secret key.
         */
        key?: string;
        /**
         * Trigger URL.
         */
        trigger_url?: string;
    }

    /**
     * The IIS handler mappings used to define which handler processes HTTP requests with certain extension. 
     * For example, it is used to configure php-cgi.exe process to handle all HTTP requests with *.php extension.
     */
    export interface HandlerMappingResponse {
        /**
         * Command-line arguments to be passed to the script processor.
         */
        arguments?: string;
        /**
         * Requests with this extension will be handled using the specified FastCGI application.
         */
        extension?: string;
        /**
         * The absolute path to the FastCGI application.
         */
        scriptProcessor?: string;
    }

    /**
     * HostNameBinding resource specific properties
     */
    export interface HostNameBindingResponseProperties {
        /**
         * Azure resource name.
         */
        azureResourceName?: string;
        /**
         * Azure resource type.
         */
        azureResourceType?: string;
        /**
         * Custom DNS record type.
         */
        customHostNameDnsRecordType?: string;
        /**
         * Fully qualified ARM domain resource URI.
         */
        domainId?: string;
        /**
         * Hostname type.
         */
        hostNameType?: string;
        /**
         * App Service app name.
         */
        siteName?: string;
        /**
         * SSL type
         */
        sslState?: string;
        /**
         * SSL certificate thumbprint
         */
        thumbprint?: string;
        /**
         * Virtual IP address assigned to the hostname if IP based SSL is enabled.
         */
        virtualIP: string;
    }

    /**
     * SSL-enabled hostname.
     */
    export interface HostNameSslStateResponse {
        /**
         * Indicates whether the hostname is a standard or repository hostname.
         */
        hostType?: string;
        /**
         * Hostname.
         */
        name?: string;
        /**
         * SSL type.
         */
        sslState?: string;
        /**
         * SSL certificate thumbprint.
         */
        thumbprint?: string;
        /**
         * Set to <code>true</code> to update existing hostname.
         */
        toUpdate?: boolean;
        /**
         * Virtual IP address assigned to the hostname if IP based SSL is enabled.
         */
        virtualIP?: string;
    }

    /**
     * Specification for an App Service Environment to use for this resource.
     */
    export interface HostingEnvironmentProfileResponse {
        /**
         * Resource ID of the App Service Environment.
         */
        id?: string;
        /**
         * Name of the App Service Environment.
         */
        name: string;
        /**
         * Resource type of the App Service Environment.
         */
        type: string;
    }

    /**
     * HybridConnectionKey resource specific properties
     */
    export interface HybridConnectionKeyResponseProperties {
        /**
         * The name of the send key.
         */
        sendKeyName: string;
        /**
         * The value of the send key.
         */
        sendKeyValue: string;
    }

    /**
     * HybridConnection resource specific properties
     */
    export interface HybridConnectionResponseProperties {
        /**
         * The hostname of the endpoint.
         */
        hostname?: string;
        /**
         * The port of the endpoint.
         */
        port?: number;
        /**
         * The ARM URI to the Service Bus relay.
         */
        relayArmUri?: string;
        /**
         * The name of the Service Bus relay.
         */
        relayName?: string;
        /**
         * The name of the Service Bus key which has Send permissions. This is used to authenticate to Service Bus.
         */
        sendKeyName?: string;
        /**
         * The value of the Service Bus key. This is used to authenticate to Service Bus. In ARM this key will not be returned
         * normally, use the POST /listKeys API instead.
         */
        sendKeyValue?: string;
        /**
         * The name of the Service Bus namespace.
         */
        serviceBusNamespace?: string;
        /**
         * The suffix for the service bus endpoint. By default this is .servicebus.windows.net
         */
        serviceBusSuffix?: string;
    }

    /**
     * Identifier resource specific properties
     */
    export interface IdentifierResponseProperties {
        /**
         * String representation of the identity.
         */
        id?: string;
    }

    /**
     * IP security restriction on an app.
     */
    export interface IpSecurityRestrictionResponse {
        /**
         * Allow or Deny access for this IP range.
         */
        action?: string;
        /**
         * IP restriction rule description.
         */
        description?: string;
        /**
         * IP address the security restriction is valid for.
         * It can be in form of pure ipv4 address (required SubnetMask property) or
         * CIDR notation such as ipv4/mask (leading bit match). For CIDR,
         * SubnetMask property must not be specified.
         */
        ipAddress?: string;
        /**
         * IP restriction rule name.
         */
        name?: string;
        /**
         * Priority of IP restriction rule.
         */
        priority?: number;
        /**
         * Subnet mask for the range of IP addresses the restriction is valid for.
         */
        subnetMask?: string;
        /**
         * (internal) Subnet traffic tag
         */
        subnetTrafficTag?: number;
        /**
         * Defines what this IP filter will be used for. This is to support IP filtering on proxies.
         */
        tag?: string;
        /**
         * Virtual network resource id
         */
        vnetSubnetResourceId?: string;
        /**
         * (internal) Vnet traffic tag
         */
        vnetTrafficTag?: number;
    }

    /**
     * Managed service identity.
     */
    export interface ManagedServiceIdentityResponse {
        /**
         * Principal Id of managed service identity.
         */
        principalId: string;
        /**
         * Tenant of managed service identity.
         */
        tenantId: string;
        /**
         * Type of managed service identity.
         */
        type?: string;
        /**
         * The list of user assigned identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
         */
        userAssignedIdentities?: {[key: string]: string};
    }

    /**
     * Name value pair.
     */
    export interface NameValuePairResponse {
        /**
         * Pair name.
         */
        name?: string;
        /**
         * Pair value.
         */
        value?: string;
    }

    /**
     * Network access control entry.
     */
    export interface NetworkAccessControlEntryResponse {
        /**
         * Action object.
         */
        action?: string;
        /**
         * Description of network access control entry.
         */
        description?: string;
        /**
         * Order of precedence.
         */
        order?: number;
        /**
         * Remote subnet.
         */
        remoteSubnet?: string;
    }

    /**
     * PremierAddOn resource specific properties
     */
    export interface PremierAddOnResponseProperties {
        /**
         * Premier add on Marketplace offer.
         */
        marketplaceOffer?: string;
        /**
         * Premier add on Marketplace publisher.
         */
        marketplacePublisher?: string;
        /**
         * Premier add on Product.
         */
        product?: string;
        /**
         * Premier add on SKU.
         */
        sku?: string;
        /**
         * Premier add on Vendor.
         */
        vendor?: string;
    }

    /**
     * The state of a private link connection
     */
    export interface PrivateLinkConnectionStateResponse {
        /**
         * ActionsRequired for a private link connection
         */
        actionsRequired?: string;
        /**
         * Description of a private link connection
         */
        description?: string;
        /**
         * Status of a private link connection
         */
        status?: string;
    }

    /**
     * PublicCertificate resource specific properties
     */
    export interface PublicCertificateResponseProperties {
        /**
         * Public Certificate byte array
         */
        blob?: string;
        /**
         * Public Certificate Location
         */
        publicCertificateLocation?: string;
        /**
         * Certificate Thumbprint
         */
        thumbprint: string;
    }

    /**
     * Push settings for the App.
     */
    export interface PushSettingsResponse {
        /**
         * Resource Id.
         */
        id: string;
        /**
         * Kind of resource.
         */
        kind?: string;
        /**
         * Resource Name.
         */
        name: string;
        /**
         * PushSettings resource specific properties
         */
        properties?: outputs.web.PushSettingsResponseProperties;
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * PushSettings resource specific properties
     */
    export interface PushSettingsResponseProperties {
        /**
         * Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in the push registration endpoint.
         */
        dynamicTagsJson?: string;
        /**
         * Gets or sets a flag indicating whether the Push endpoint is enabled.
         */
        isPushEnabled: boolean;
        /**
         * Gets or sets a JSON string containing a list of tags that are whitelisted for use by the push registration endpoint.
         */
        tagWhitelistJson?: string;
        /**
         * Gets or sets a JSON string containing a list of tags that require user authentication to be used in the push registration endpoint.
         * Tags can consist of alphanumeric characters and the following:
         * '_', '@', '#', '.', ':', '-'. 
         * Validation should be performed at the PushRequestHandler.
         */
        tagsRequiringAuth?: string;
    }

    /**
     * Routing rules for ramp up testing. This rule allows to redirect static traffic % to a slot or to gradually change routing % based on performance.
     */
    export interface RampUpRuleResponse {
        /**
         * Hostname of a slot to which the traffic will be redirected if decided to. E.g. myapp-stage.azurewebsites.net.
         */
        actionHostName?: string;
        /**
         * Custom decision algorithm can be provided in TiPCallback site extension which URL can be specified. See TiPCallback site extension for the scaffold and contracts.
         * https://www.siteextensions.net/packages/TiPCallback/
         */
        changeDecisionCallbackUrl?: string;
        /**
         * Specifies interval in minutes to reevaluate ReroutePercentage.
         */
        changeIntervalInMinutes?: number;
        /**
         * In auto ramp up scenario this is the step to add/remove from <code>ReroutePercentage</code> until it reaches \n<code>MinReroutePercentage</code> or 
         * <code>MaxReroutePercentage</code>. Site metrics are checked every N minutes specified in <code>ChangeIntervalInMinutes</code>.\nCustom decision algorithm 
         * can be provided in TiPCallback site extension which URL can be specified in <code>ChangeDecisionCallbackUrl</code>.
         */
        changeStep?: number;
        /**
         * Specifies upper boundary below which ReroutePercentage will stay.
         */
        maxReroutePercentage?: number;
        /**
         * Specifies lower boundary above which ReroutePercentage will stay.
         */
        minReroutePercentage?: number;
        /**
         * Name of the routing rule. The recommended name would be to point to the slot which will receive the traffic in the experiment.
         */
        name?: string;
        /**
         * Percentage of the traffic which will be redirected to <code>ActionHostName</code>.
         */
        reroutePercentage?: number;
    }

    /**
     * RelayServiceConnectionEntity resource specific properties
     */
    export interface RelayServiceConnectionEntityResponseProperties {
        biztalkUri?: string;
        entityConnectionString?: string;
        entityName?: string;
        hostname?: string;
        port?: number;
        resourceConnectionString?: string;
        resourceType?: string;
    }

    /**
     * A remote private endpoint connection
     */
    export interface RemotePrivateEndpointConnectionResponse {
        /**
         * PrivateEndpoint of a remote private endpoint connection
         */
        privateEndpoint?: outputs.web.ArmIdWrapperResponse;
        /**
         * The state of a private link connection
         */
        privateLinkServiceConnectionState?: outputs.web.PrivateLinkConnectionStateResponse;
        provisioningState: string;
    }

    /**
     * Trigger based on total requests.
     */
    export interface RequestsBasedTriggerResponse {
        /**
         * Request Count.
         */
        count?: number;
        /**
         * Time interval.
         */
        timeInterval?: string;
    }

    /**
     * Configuration of an App Service app.
     */
    export interface SiteConfigResponse {
        /**
         * <code>true</code> if Always On is enabled; otherwise, <code>false</code>.
         */
        alwaysOn?: boolean;
        /**
         * Information about the formal API definition for the app.
         */
        apiDefinition?: outputs.web.ApiDefinitionInfoResponse;
        /**
         * Azure API management settings linked to the app.
         */
        apiManagementConfig?: outputs.web.ApiManagementConfigResponse;
        /**
         * App command line to launch.
         */
        appCommandLine?: string;
        /**
         * Application settings.
         */
        appSettings?: outputs.web.NameValuePairResponse[];
        /**
         * <code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.
         */
        autoHealEnabled?: boolean;
        /**
         * Auto Heal rules.
         */
        autoHealRules?: outputs.web.AutoHealRulesResponse;
        /**
         * Auto-swap slot name.
         */
        autoSwapSlotName?: string;
        /**
         * Connection strings.
         */
        connectionStrings?: outputs.web.ConnStringInfoResponse[];
        /**
         * Cross-Origin Resource Sharing (CORS) settings.
         */
        cors?: outputs.web.CorsSettingsResponse;
        /**
         * Default documents.
         */
        defaultDocuments?: string[];
        /**
         * <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
         */
        detailedErrorLoggingEnabled?: boolean;
        /**
         * Document root.
         */
        documentRoot?: string;
        /**
         * This is work around for polymorphic types.
         */
        experiments?: outputs.web.ExperimentsResponse;
        /**
         * State of FTP / FTPS service
         */
        ftpsState?: string;
        /**
         * Handler mappings.
         */
        handlerMappings?: outputs.web.HandlerMappingResponse[];
        /**
         * Health check path
         */
        healthCheckPath?: string;
        /**
         * Http20Enabled: configures a web site to allow clients to connect over http2.0
         */
        http20Enabled?: boolean;
        /**
         * <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
         */
        httpLoggingEnabled?: boolean;
        /**
         * IP security restrictions for main.
         */
        ipSecurityRestrictions?: outputs.web.IpSecurityRestrictionResponse[];
        /**
         * Java container.
         */
        javaContainer?: string;
        /**
         * Java container version.
         */
        javaContainerVersion?: string;
        /**
         * Java version.
         */
        javaVersion?: string;
        /**
         * Site limits.
         */
        limits?: outputs.web.SiteLimitsResponse;
        /**
         * Linux App Framework and version
         */
        linuxFxVersion?: string;
        /**
         * Site load balancing.
         */
        loadBalancing?: string;
        /**
         * <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
         */
        localMySqlEnabled?: boolean;
        /**
         * HTTP logs directory size limit.
         */
        logsDirectorySizeLimit?: number;
        /**
         * Site MachineKey.
         */
        machineKey: outputs.web.SiteMachineKeyResponse;
        /**
         * Managed pipeline mode.
         */
        managedPipelineMode?: string;
        /**
         * Managed Service Identity Id
         */
        managedServiceIdentityId?: number;
        /**
         * MinTlsVersion: configures the minimum version of TLS required for SSL requests
         */
        minTlsVersion?: string;
        /**
         * .NET Framework version.
         */
        netFrameworkVersion?: string;
        /**
         * Version of Node.js.
         */
        nodeVersion?: string;
        /**
         * Number of workers.
         */
        numberOfWorkers?: number;
        /**
         * Version of PHP.
         */
        phpVersion?: string;
        /**
         * Version of PowerShell.
         */
        powerShellVersion?: string;
        /**
         * Number of preWarmed instances.
         * This setting only applies to the Consumption and Elastic Plans
         */
        preWarmedInstanceCount?: number;
        /**
         * Publishing user name.
         */
        publishingUsername?: string;
        /**
         * Push endpoint settings.
         */
        push?: outputs.web.PushSettingsResponse;
        /**
         * Version of Python.
         */
        pythonVersion?: string;
        /**
         * <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
         */
        remoteDebuggingEnabled?: boolean;
        /**
         * Remote debugging version.
         */
        remoteDebuggingVersion?: string;
        /**
         * <code>true</code> if request tracing is enabled; otherwise, <code>false</code>.
         */
        requestTracingEnabled?: boolean;
        /**
         * Request tracing expiration time.
         */
        requestTracingExpirationTime?: string;
        /**
         * IP security restrictions for scm.
         */
        scmIpSecurityRestrictions?: outputs.web.IpSecurityRestrictionResponse[];
        /**
         * IP security restrictions for scm to use main.
         */
        scmIpSecurityRestrictionsUseMain?: boolean;
        /**
         * SCM type.
         */
        scmType?: string;
        /**
         * Tracing options.
         */
        tracingOptions?: string;
        /**
         * <code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.
         */
        use32BitWorkerProcess?: boolean;
        /**
         * Virtual applications.
         */
        virtualApplications?: outputs.web.VirtualApplicationResponse[];
        /**
         * Virtual Network name.
         */
        vnetName?: string;
        /**
         * <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
         */
        webSocketsEnabled?: boolean;
        /**
         * Xenon App Framework and version
         */
        windowsFxVersion?: string;
        /**
         * Explicit Managed Service Identity Id
         */
        xManagedServiceIdentityId?: number;
    }

    /**
     * SiteExtensionInfo resource specific properties
     */
    export interface SiteExtensionInfoResponseProperties {
        /**
         * List of authors.
         */
        authors?: string[];
        /**
         * Site Extension comment.
         */
        comment?: string;
        /**
         * Detailed description.
         */
        description?: string;
        /**
         * Count of downloads.
         */
        download_count?: number;
        /**
         * Site extension ID.
         */
        extension_id?: string;
        /**
         * Site extension type.
         */
        extension_type?: string;
        /**
         * Extension URL.
         */
        extension_url?: string;
        /**
         * Feed URL.
         */
        feed_url?: string;
        /**
         * Icon URL.
         */
        icon_url?: string;
        /**
         * Installed timestamp.
         */
        installed_date_time?: string;
        /**
         * Installer command line parameters.
         */
        installer_command_line_params?: string;
        /**
         * License URL.
         */
        license_url?: string;
        /**
         * <code>true</code> if the local version is the latest version; <code>false</code> otherwise.
         */
        local_is_latest_version?: boolean;
        /**
         * Local path.
         */
        local_path?: string;
        /**
         * Project URL.
         */
        project_url?: string;
        /**
         * Provisioning state.
         */
        provisioningState?: string;
        /**
         * Published timestamp.
         */
        published_date_time?: string;
        /**
         * Summary description.
         */
        summary?: string;
        title?: string;
        /**
         * Version information.
         */
        version?: string;
    }

    /**
     * Metric limits set on an app.
     */
    export interface SiteLimitsResponse {
        /**
         * Maximum allowed disk size usage in MB.
         */
        maxDiskSizeInMb?: number;
        /**
         * Maximum allowed memory usage in MB.
         */
        maxMemoryInMb?: number;
        /**
         * Maximum allowed CPU usage percentage.
         */
        maxPercentageCpu?: number;
    }

    /**
     * MachineKey of an app.
     */
    export interface SiteMachineKeyResponse {
        /**
         * Algorithm used for decryption.
         */
        decryption?: string;
        /**
         * Decryption key.
         */
        decryptionKey?: string;
        /**
         * MachineKey validation.
         */
        validation?: string;
        /**
         * Validation key.
         */
        validationKey?: string;
    }

    /**
     * Site resource specific properties
     */
    export interface SiteResponseProperties {
        /**
         * Management information availability state for the app.
         */
        availabilityState: string;
        /**
         * <code>true</code> to enable client affinity; <code>false</code> to stop sending session affinity cookies, which route client requests in the same session to the same instance. Default is <code>true</code>.
         */
        clientAffinityEnabled?: boolean;
        /**
         * <code>true</code> to enable client certificate authentication (TLS mutual authentication); otherwise, <code>false</code>. Default is <code>false</code>.
         */
        clientCertEnabled?: boolean;
        /**
         * client certificate authentication comma-separated exclusion paths
         */
        clientCertExclusionPaths?: string;
        /**
         * If specified during app creation, the app is cloned from a source app.
         */
        cloningInfo?: outputs.web.CloningInfoResponse;
        /**
         * Size of the function container.
         */
        containerSize?: number;
        /**
         * Maximum allowed daily memory-time quota (applicable on dynamic apps only).
         */
        dailyMemoryTimeQuota?: number;
        /**
         * Default hostname of the app. Read-only.
         */
        defaultHostName: string;
        /**
         * <code>true</code> if the app is enabled; otherwise, <code>false</code>. Setting this value to false disables the app (takes the app offline).
         */
        enabled?: boolean;
        /**
         * Enabled hostnames for the app.Hostnames need to be assigned (see HostNames) AND enabled. Otherwise,
         * the app is not served on those hostnames.
         */
        enabledHostNames: string[];
        /**
         * Hostname SSL states are used to manage the SSL bindings for app's hostnames.
         */
        hostNameSslStates?: outputs.web.HostNameSslStateResponse[];
        /**
         * Hostnames associated with the app.
         */
        hostNames: string[];
        /**
         * <code>true</code> to disable the public hostnames of the app; otherwise, <code>false</code>.
         *  If <code>true</code>, the app is only accessible via API management process.
         */
        hostNamesDisabled?: boolean;
        /**
         * App Service Environment to use for the app.
         */
        hostingEnvironmentProfile?: outputs.web.HostingEnvironmentProfileResponse;
        /**
         * HttpsOnly: configures a web site to accept only https requests. Issues redirect for
         * http requests
         */
        httpsOnly?: boolean;
        /**
         * Hyper-V sandbox.
         */
        hyperV?: boolean;
        /**
         * Specifies an operation id if this site has a pending operation.
         */
        inProgressOperationId: string;
        /**
         * <code>true</code> if the app is a default container; otherwise, <code>false</code>.
         */
        isDefaultContainer: boolean;
        /**
         * Obsolete: Hyper-V sandbox.
         */
        isXenon?: boolean;
        /**
         * Last time the app was modified, in UTC. Read-only.
         */
        lastModifiedTimeUtc: string;
        /**
         * Maximum number of workers.
         * This only applies to Functions container.
         */
        maxNumberOfWorkers: number;
        /**
         * List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from tenants that site can be hosted with current settings. Read-only.
         */
        outboundIpAddresses: string;
        /**
         * List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from all tenants except dataComponent. Read-only.
         */
        possibleOutboundIpAddresses: string;
        /**
         * Site redundancy mode
         */
        redundancyMode?: string;
        /**
         * Name of the repository site.
         */
        repositorySiteName: string;
        /**
         * <code>true</code> if reserved; otherwise, <code>false</code>.
         */
        reserved?: boolean;
        /**
         * Name of the resource group the app belongs to. Read-only.
         */
        resourceGroup: string;
        /**
         * <code>true</code> to stop SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The default is <code>false</code>.
         */
        scmSiteAlsoStopped?: boolean;
        /**
         * Resource ID of the associated App Service plan, formatted as: "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
         */
        serverFarmId?: string;
        /**
         * Configuration of the app.
         */
        siteConfig?: outputs.web.SiteConfigResponse;
        /**
         * Status of the last deployment slot swap operation.
         */
        slotSwapStatus: outputs.web.SlotSwapStatusResponse;
        /**
         * Current state of the app.
         */
        state: string;
        /**
         * App suspended till in case memory-time quota is exceeded.
         */
        suspendedTill: string;
        /**
         * Specifies which deployment slot this app will swap into. Read-only.
         */
        targetSwapSlot: string;
        /**
         * Azure Traffic Manager hostnames associated with the app. Read-only.
         */
        trafficManagerHostNames: string[];
        /**
         * State indicating whether the app has exceeded its quota usage. Read-only.
         */
        usageState: string;
    }

    /**
     * SiteSourceControl resource specific properties
     */
    export interface SiteSourceControlResponseProperties {
        /**
         * Name of branch to use for deployment.
         */
        branch?: string;
        /**
         * <code>true</code> to enable deployment rollback; otherwise, <code>false</code>.
         */
        deploymentRollbackEnabled?: boolean;
        /**
         * <code>true</code> to limit to manual integration; <code>false</code> to enable continuous integration (which configures webhooks into online repos like GitHub).
         */
        isManualIntegration?: boolean;
        /**
         * <code>true</code> for a Mercurial repository; <code>false</code> for a Git repository.
         */
        isMercurial?: boolean;
        /**
         * Repository or source control URL.
         */
        repoUrl?: string;
    }

    /**
     * Description of the App Service plan scale options.
     */
    export interface SkuCapacityResponse {
        /**
         * Default number of workers for this App Service plan SKU.
         */
        default?: number;
        /**
         * Maximum number of workers for this App Service plan SKU.
         */
        maximum?: number;
        /**
         * Minimum number of workers for this App Service plan SKU.
         */
        minimum?: number;
        /**
         * Available scale configurations for an App Service plan.
         */
        scaleType?: string;
    }

    /**
     * Description of a SKU for a scalable resource.
     */
    export interface SkuDescriptionResponse {
        /**
         * Capabilities of the SKU, e.g., is traffic manager enabled?
         */
        capabilities?: outputs.web.CapabilityResponse[];
        /**
         * Current number of instances assigned to the resource.
         */
        capacity?: number;
        /**
         * Family code of the resource SKU.
         */
        family?: string;
        /**
         * Locations of the SKU.
         */
        locations?: string[];
        /**
         * Name of the resource SKU.
         */
        name?: string;
        /**
         * Size specifier of the resource SKU.
         */
        size?: string;
        /**
         * Min, max, and default scale values of the SKU.
         */
        skuCapacity?: outputs.web.SkuCapacityResponse;
        /**
         * Service tier of the resource SKU.
         */
        tier?: string;
    }

    /**
     * The status of the last successful slot swap operation.
     */
    export interface SlotSwapStatusResponse {
        /**
         * The destination slot of the last swap operation.
         */
        destinationSlotName: string;
        /**
         * The source slot of the last swap operation.
         */
        sourceSlotName: string;
        /**
         * The time the last successful slot swap completed.
         */
        timestampUtc: string;
    }

    /**
     * Trigger based on request execution time.
     */
    export interface SlowRequestsBasedTriggerResponse {
        /**
         * Request Count.
         */
        count?: number;
        /**
         * Time interval.
         */
        timeInterval?: string;
        /**
         * Time taken.
         */
        timeTaken?: string;
    }

    /**
     * Stamp capacity information.
     */
    export interface StampCapacityResponse {
        /**
         * Available capacity (# of machines, bytes of storage etc...).
         */
        availableCapacity?: number;
        /**
         * Shared/dedicated workers.
         */
        computeMode?: string;
        /**
         * If <code>true</code>, it includes basic apps.
         * Basic apps are not used for capacity allocation.
         */
        excludeFromCapacityAllocation?: boolean;
        /**
         * <code>true</code> if capacity is applicable for all apps; otherwise, <code>false</code>.
         */
        isApplicableForAllComputeModes?: boolean;
        /**
         * Is this a linux stamp capacity
         */
        isLinux?: boolean;
        /**
         * Name of the stamp.
         */
        name?: string;
        /**
         * Shared or Dedicated.
         */
        siteMode?: string;
        /**
         * Total capacity (# of machines, bytes of storage etc...).
         */
        totalCapacity?: number;
        /**
         * Name of the unit.
         */
        unit?: string;
        /**
         * Size of the machines.
         */
        workerSize?: string;
        /**
         * Size ID of machines: 
         * 0 - Small
         * 1 - Medium
         * 2 - Large
         */
        workerSizeId?: number;
    }

    /**
     * Build properties for the static site.
     */
    export interface StaticSiteBuildPropertiesResponse {
        /**
         * The path to the api code within the repository.
         */
        apiLocation?: string;
        /**
         * The path of the app artifacts after building.
         */
        appArtifactLocation?: string;
        /**
         * The path to the app code within the repository.
         */
        appLocation?: string;
    }

    /**
     * A static site.
     */
    export interface StaticSiteResponse {
        /**
         * The target branch in the repository.
         */
        branch?: string;
        /**
         * Build properties to configure on the repository.
         */
        buildProperties?: outputs.web.StaticSiteBuildPropertiesResponse;
        /**
         * The custom domains associated with this static site.
         */
        customDomains: string[];
        /**
         * The default autogenerated hostname for the static site.
         */
        defaultHostname: string;
        /**
         * A user's github repository token. This is used to setup the Github Actions workflow file and API secrets.
         */
        repositoryToken?: string;
        /**
         * URL for the repository of the static site.
         */
        repositoryUrl?: string;
    }

    /**
     * Static Site User ARM resource.
     */
    export interface StaticSiteUserARMResourceResponse {
        /**
         * Resource Id.
         */
        id: string;
        /**
         * Kind of resource.
         */
        kind?: string;
        /**
         * Resource Name.
         */
        name: string;
        /**
         * StaticSiteUserARMResource resource specific properties
         */
        properties?: outputs.web.StaticSiteUserARMResourceResponseProperties;
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * StaticSiteUserARMResource resource specific properties
     */
    export interface StaticSiteUserARMResourceResponseProperties {
        /**
         * The display name for the static site user.
         */
        displayName: string;
        /**
         * The identity provider for the static site user.
         */
        provider: string;
        /**
         * The roles for the static site user, in free-form string format
         */
        roles?: string;
        /**
         * The user id for the static site user.
         */
        userId: string;
    }

    /**
     * Trigger based on status code.
     */
    export interface StatusCodesBasedTriggerResponse {
        /**
         * Request Count.
         */
        count?: number;
        /**
         * HTTP status code.
         */
        status?: number;
        /**
         * Request Sub Status.
         */
        subStatus?: number;
        /**
         * Time interval.
         */
        timeInterval?: string;
        /**
         * Win32 error code.
         */
        win32Status?: number;
    }

    /**
     * SwiftVirtualNetwork resource specific properties
     */
    export interface SwiftVirtualNetworkResponseProperties {
        /**
         * The Virtual Network subnet's resource ID. This is the subnet that this Web App will join. This subnet must have a delegation to Microsoft.Web/serverFarms defined first.
         */
        subnetResourceId?: string;
        /**
         * A flag that specifies if the scale unit this Web App is on supports Swift integration.
         */
        swiftSupported?: boolean;
    }

    /**
     * Virtual application in an app.
     */
    export interface VirtualApplicationResponse {
        /**
         * Physical path.
         */
        physicalPath?: string;
        /**
         * <code>true</code> if preloading is enabled; otherwise, <code>false</code>.
         */
        preloadEnabled?: boolean;
        /**
         * Virtual directories for virtual application.
         */
        virtualDirectories?: outputs.web.VirtualDirectoryResponse[];
        /**
         * Virtual path.
         */
        virtualPath?: string;
    }

    /**
     * Directory for virtual application.
     */
    export interface VirtualDirectoryResponse {
        /**
         * Physical path.
         */
        physicalPath?: string;
        /**
         * Path to virtual application.
         */
        virtualPath?: string;
    }

    /**
     * Virtual IP mapping.
     */
    export interface VirtualIPMappingResponse {
        /**
         * Is virtual IP mapping in use.
         */
        inUse?: boolean;
        /**
         * Internal HTTP port.
         */
        internalHttpPort?: number;
        /**
         * Internal HTTPS port.
         */
        internalHttpsPort?: number;
        /**
         * name of the service that virtual IP is assigned to
         */
        serviceName?: string;
        /**
         * Virtual IP address.
         */
        virtualIP?: string;
    }

    /**
     * Specification for using a Virtual Network.
     */
    export interface VirtualNetworkProfileResponse {
        /**
         * Resource id of the Virtual Network.
         */
        id?: string;
        /**
         * Name of the Virtual Network (read-only).
         */
        name: string;
        /**
         * Subnet within the Virtual Network.
         */
        subnet?: string;
        /**
         * Resource type of the Virtual Network (read-only).
         */
        type: string;
    }

    /**
     * VnetInfo resource specific properties
     */
    export interface VnetInfoResponseProperties {
        /**
         * A certificate file (.cer) blob containing the public key of the private key used to authenticate a 
         * Point-To-Site VPN connection.
         */
        certBlob?: string;
        /**
         * The client certificate thumbprint.
         */
        certThumbprint: string;
        /**
         * DNS servers to be used by this Virtual Network. This should be a comma-separated list of IP addresses.
         */
        dnsServers?: string;
        /**
         * Flag that is used to denote if this is VNET injection
         */
        isSwift?: boolean;
        /**
         * <code>true</code> if a resync is required; otherwise, <code>false</code>.
         */
        resyncRequired: boolean;
        /**
         * The routes that this Virtual Network connection uses.
         */
        routes: outputs.web.VnetRouteResponse[];
        /**
         * The Virtual Network's resource ID.
         */
        vnetResourceId?: string;
    }

    /**
     * Virtual Network route contract used to pass routing information for a Virtual Network.
     */
    export interface VnetRouteResponse {
        /**
         * Resource Id.
         */
        id: string;
        /**
         * Kind of resource.
         */
        kind?: string;
        /**
         * Resource Name.
         */
        name: string;
        /**
         * VnetRoute resource specific properties
         */
        properties?: outputs.web.VnetRouteResponseProperties;
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * VnetRoute resource specific properties
     */
    export interface VnetRouteResponseProperties {
        /**
         * The ending address for this route. If the start address is specified in CIDR notation, this must be omitted.
         */
        endAddress?: string;
        /**
         * The type of route this is:
         * DEFAULT - By default, every app has routes to the local address ranges specified by RFC1918
         * INHERITED - Routes inherited from the real Virtual Network routes
         * STATIC - Static route set on the app only
         *
         * These values will be used for syncing an app's routes with those from a Virtual Network.
         */
        routeType?: string;
        /**
         * The starting address for this route. This may also include a CIDR notation, in which case the end address must not be specified.
         */
        startAddress?: string;
    }

    /**
     * Worker pool of an App Service Environment.
     */
    export interface WorkerPoolResponse {
        /**
         * Shared or dedicated app hosting.
         */
        computeMode?: string;
        /**
         * Names of all instances in the worker pool (read only).
         */
        instanceNames: string[];
        /**
         * Number of instances in the worker pool.
         */
        workerCount?: number;
        /**
         * VM size of the worker pool instances.
         */
        workerSize?: string;
        /**
         * Worker size ID for referencing this worker pool.
         */
        workerSizeId?: number;
    }
}

export namespace windowsiot {
    /**
     * The properties of a Windows IoT Device Service.
     */
    export interface DeviceServicePropertiesResponse {
        /**
         * Windows IoT Device Service OEM AAD domain
         */
        adminDomainName?: string;
        /**
         * Windows IoT Device Service ODM AAD domain
         */
        billingDomainName?: string;
        /**
         * Windows IoT Device Service notes.
         */
        notes?: string;
        /**
         * Windows IoT Device Service device allocation,
         */
        quantity?: number;
        /**
         * Windows IoT Device Service start date,
         */
        startDate: string;
    }
}

