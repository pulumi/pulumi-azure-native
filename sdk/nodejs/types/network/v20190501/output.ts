// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../../../types/input";
import * as outputs from "../../../types/output";
import * as enums from "../../../types/enums";
import * as utilities from "../../../utilities";

/**
 * A backend pool is a collection of backends that can be routed to.
 */
export interface BackendPoolResponse {
    /**
     * The set of backends for this pool
     */
    backends?: outputs.network.v20190501.BackendResponse[];
    /**
     * L7 health probe settings for a backend pool
     */
    healthProbeSettings?: outputs.network.v20190501.SubResourceResponse;
    /**
     * Resource ID.
     */
    id?: string;
    /**
     * Load balancing settings for a backend pool
     */
    loadBalancingSettings?: outputs.network.v20190501.SubResourceResponse;
    /**
     * Resource name.
     */
    name?: string;
    /**
     * Resource status.
     */
    resourceState: string;
    /**
     * Resource type.
     */
    type: string;
}

/**
 * Settings that apply to all backend pools.
 */
export interface BackendPoolsSettingsResponse {
    /**
     * Whether to enforce certificate name check on HTTPS requests to all backend pools. No effect on non-HTTPS requests.
     */
    enforceCertificateNameCheck?: string;
    /**
     * Send and receive timeout on forwarding request to the backend. When timeout is reached, the request fails and returns.
     */
    sendRecvTimeoutSeconds?: number;
}
/**
 * backendPoolsSettingsResponseProvideDefaults sets the appropriate defaults for BackendPoolsSettingsResponse
 */
export function backendPoolsSettingsResponseProvideDefaults(val: BackendPoolsSettingsResponse): BackendPoolsSettingsResponse {
    return {
        ...val,
        enforceCertificateNameCheck: (val.enforceCertificateNameCheck) ?? "Enabled",
    };
}

/**
 * Backend address of a frontDoor load balancer.
 */
export interface BackendResponse {
    /**
     * Location of the backend (IP address or FQDN)
     */
    address?: string;
    /**
     * The value to use as the host header sent to the backend. If blank or unspecified, this defaults to the incoming host.
     */
    backendHostHeader?: string;
    /**
     * Whether to enable use of this backend. Permitted values are 'Enabled' or 'Disabled'
     */
    enabledState?: string;
    /**
     * The HTTP TCP port number. Must be between 1 and 65535.
     */
    httpPort?: number;
    /**
     * The HTTPS TCP port number. Must be between 1 and 65535.
     */
    httpsPort?: number;
    /**
     * Priority to use for load balancing. Higher priorities will not be used for load balancing if any lower priority backend is healthy.
     */
    priority?: number;
    /**
     * Weight of this endpoint for load balancing purposes.
     */
    weight?: number;
}

/**
 * Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object.
 */
export interface CacheConfigurationResponse {
    /**
     * Whether to use dynamic compression for cached content
     */
    dynamicCompression?: string;
    /**
     * Treatment of URL query terms when forming the cache key.
     */
    queryParameterStripDirective?: string;
}

/**
 * Https settings for a domain
 */
export interface CustomHttpsConfigurationResponse {
    /**
     * Defines the source of the SSL certificate
     */
    certificateSource: string;
    /**
     * Defines the type of the certificate used for secure connections to a frontendEndpoint
     */
    certificateType?: string;
    /**
     * The minimum TLS version required from the clients to establish an SSL handshake with Front Door.
     */
    minimumTlsVersion: string;
    /**
     * Defines the TLS extension protocol that is used for secure delivery
     */
    protocolType: string;
    /**
     * The name of the Key Vault secret representing the full certificate PFX
     */
    secretName?: string;
    /**
     * The version of the Key Vault secret representing the full certificate PFX
     */
    secretVersion?: string;
    /**
     * The Key Vault containing the SSL certificate
     */
    vault?: outputs.network.v20190501.KeyVaultCertificateSourceParametersResponseVault;
}

/**
 * Describes Forwarding Route.
 */
export interface ForwardingConfigurationResponse {
    /**
     * A reference to the BackendPool which this rule routes to.
     */
    backendPool?: outputs.network.v20190501.SubResourceResponse;
    /**
     * The caching configuration associated with this rule.
     */
    cacheConfiguration?: outputs.network.v20190501.CacheConfigurationResponse;
    /**
     * A custom path used to rewrite resource paths matched by this rule. Leave empty to use incoming path.
     */
    customForwardingPath?: string;
    /**
     * Protocol this rule will use when forwarding traffic to backends.
     */
    forwardingProtocol?: string;
    /**
     *
     * Expected value is '#Microsoft.Azure.FrontDoor.Models.FrontdoorForwardingConfiguration'.
     */
    odataType: "#Microsoft.Azure.FrontDoor.Models.FrontdoorForwardingConfiguration";
}

/**
 * A frontend endpoint used for routing.
 */
export interface FrontendEndpointResponse {
    /**
     * The configuration specifying how to enable HTTPS
     */
    customHttpsConfiguration: outputs.network.v20190501.CustomHttpsConfigurationResponse;
    /**
     * Provisioning status of Custom Https of the frontendEndpoint.
     */
    customHttpsProvisioningState: string;
    /**
     * Provisioning substate shows the progress of custom HTTPS enabling/disabling process step by step.
     */
    customHttpsProvisioningSubstate: string;
    /**
     * The host name of the frontendEndpoint. Must be a domain name.
     */
    hostName?: string;
    /**
     * Resource ID.
     */
    id?: string;
    /**
     * Resource name.
     */
    name?: string;
    /**
     * Resource status.
     */
    resourceState: string;
    /**
     * Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'
     */
    sessionAffinityEnabledState?: string;
    /**
     * UNUSED. This field will be ignored. The TTL to use in seconds for session affinity, if applicable.
     */
    sessionAffinityTtlSeconds?: number;
    /**
     * Resource type.
     */
    type: string;
    /**
     * Defines the Web Application Firewall policy for each host (if applicable)
     */
    webApplicationFirewallPolicyLink?: outputs.network.v20190501.FrontendEndpointUpdateParametersResponseWebApplicationFirewallPolicyLink;
}

/**
 * Defines the Web Application Firewall policy for each host (if applicable)
 */
export interface FrontendEndpointUpdateParametersResponseWebApplicationFirewallPolicyLink {
    /**
     * Resource ID.
     */
    id?: string;
}

/**
 * Load balancing settings for a backend pool
 */
export interface HealthProbeSettingsModelResponse {
    /**
     * Whether to enable health probes to be made against backends defined under backendPools. Health probes can only be disabled if there is a single enabled backend in single enabled backend pool.
     */
    enabledState?: string;
    /**
     * Configures which HTTP method to use to probe the backends defined under backendPools.
     */
    healthProbeMethod?: string;
    /**
     * Resource ID.
     */
    id?: string;
    /**
     * The number of seconds between health probes.
     */
    intervalInSeconds?: number;
    /**
     * Resource name.
     */
    name?: string;
    /**
     * The path to use for the health probe. Default is /
     */
    path?: string;
    /**
     * Protocol scheme to use for this probe
     */
    protocol?: string;
    /**
     * Resource status.
     */
    resourceState: string;
    /**
     * Resource type.
     */
    type: string;
}
/**
 * healthProbeSettingsModelResponseProvideDefaults sets the appropriate defaults for HealthProbeSettingsModelResponse
 */
export function healthProbeSettingsModelResponseProvideDefaults(val: HealthProbeSettingsModelResponse): HealthProbeSettingsModelResponse {
    return {
        ...val,
        healthProbeMethod: (val.healthProbeMethod) ?? "HEAD",
    };
}

/**
 * The Key Vault containing the SSL certificate
 */
export interface KeyVaultCertificateSourceParametersResponseVault {
    /**
     * Resource ID.
     */
    id?: string;
}

/**
 * Load balancing settings for a backend pool
 */
export interface LoadBalancingSettingsModelResponse {
    /**
     * The additional latency in milliseconds for probes to fall into the lowest latency bucket
     */
    additionalLatencyMilliseconds?: number;
    /**
     * Resource ID.
     */
    id?: string;
    /**
     * Resource name.
     */
    name?: string;
    /**
     * Resource status.
     */
    resourceState: string;
    /**
     * The number of samples to consider for load balancing decisions
     */
    sampleSize?: number;
    /**
     * The number of samples within the sample period that must succeed
     */
    successfulSamplesRequired?: number;
    /**
     * Resource type.
     */
    type: string;
}

/**
 * Describes Redirect Route.
 */
export interface RedirectConfigurationResponse {
    /**
     * Fragment to add to the redirect URL. Fragment is the part of the URL that comes after #. Do not include the #.
     */
    customFragment?: string;
    /**
     * Host to redirect. Leave empty to use the incoming host as the destination host.
     */
    customHost?: string;
    /**
     * The full path to redirect. Path cannot be empty and must start with /. Leave empty to use the incoming path as destination path.
     */
    customPath?: string;
    /**
     * The set of query strings to be placed in the redirect URL. Setting this value would replace any existing query string; leave empty to preserve the incoming query string. Query string must be in <key>=<value> format. The first ? and & will be added automatically so do not include them in the front, but do separate multiple query strings with &.
     */
    customQueryString?: string;
    /**
     *
     * Expected value is '#Microsoft.Azure.FrontDoor.Models.FrontdoorRedirectConfiguration'.
     */
    odataType: "#Microsoft.Azure.FrontDoor.Models.FrontdoorRedirectConfiguration";
    /**
     * The protocol of the destination to where the traffic is redirected
     */
    redirectProtocol?: string;
    /**
     * The redirect type the rule will use when redirecting traffic.
     */
    redirectType?: string;
}

/**
 * A routing rule represents a specification for traffic to treat and where to send it, along with health probe information.
 */
export interface RoutingRuleResponse {
    /**
     * Protocol schemes to match for this rule
     */
    acceptedProtocols?: string[];
    /**
     * Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
     */
    enabledState?: string;
    /**
     * Frontend endpoints associated with this rule
     */
    frontendEndpoints?: outputs.network.v20190501.SubResourceResponse[];
    /**
     * Resource ID.
     */
    id?: string;
    /**
     * Resource name.
     */
    name?: string;
    /**
     * The route patterns of the rule.
     */
    patternsToMatch?: string[];
    /**
     * Resource status.
     */
    resourceState: string;
    /**
     * A reference to the routing configuration.
     */
    routeConfiguration?: outputs.network.v20190501.ForwardingConfigurationResponse | outputs.network.v20190501.RedirectConfigurationResponse;
    /**
     * Resource type.
     */
    type: string;
}

/**
 * Reference to another subresource.
 */
export interface SubResourceResponse {
    /**
     * Resource ID.
     */
    id?: string;
}

