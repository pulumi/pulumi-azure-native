// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../../../types/input";
import * as outputs from "../../../types/output";
import * as enums from "../../../types/enums";
import * as utilities from "../../../utilities";

/**
 * The settings to enable AAD authentication on the cluster.
 */
export interface AzureActiveDirectoryArgs {
    /**
     * Azure active directory client application id.
     */
    clientApplication?: pulumi.Input<string>;
    /**
     * Azure active directory cluster application id.
     */
    clusterApplication?: pulumi.Input<string>;
    /**
     * Azure active directory tenant id.
     */
    tenantId?: pulumi.Input<string>;
}

/**
 * Client Certificate definition.
 */
export interface ClientCertificateArgs {
    /**
     * Certificate Common name.
     */
    commonName?: pulumi.Input<string>;
    /**
     * Whether the certificate is admin or not.
     */
    isAdmin: pulumi.Input<boolean>;
    /**
     * Issuer thumbprint for the certificate. Only used together with CommonName.
     */
    issuerThumbprint?: pulumi.Input<string>;
    /**
     * Certificate Thumbprint.
     */
    thumbprint?: pulumi.Input<string>;
}

/**
 * Port range details
 */
export interface EndpointRangeDescriptionArgs {
    /**
     * End port of a range of ports
     */
    endPort: pulumi.Input<number>;
    /**
     * Starting port of a range of ports
     */
    startPort: pulumi.Input<number>;
}

/**
 * Describes a load balancing rule.
 */
export interface LoadBalancingRuleArgs {
    /**
     * The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
     */
    backendPort: pulumi.Input<number>;
    /**
     * The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 1 and 65534.
     */
    frontendPort: pulumi.Input<number>;
    /**
     * the reference to the load balancer probe used by the load balancing rule.
     */
    probeProtocol: pulumi.Input<string | enums.servicefabric.v20200101preview.ProbeProtocol>;
    /**
     * The probe request path. Only supported for HTTP/HTTPS probes.
     */
    probeRequestPath?: pulumi.Input<string>;
    /**
     * The reference to the transport protocol used by the load balancing rule.
     */
    protocol: pulumi.Input<string | enums.servicefabric.v20200101preview.Protocol>;
}

/**
 * Describes a parameter in fabric settings of the cluster.
 */
export interface SettingsParameterDescriptionArgs {
    /**
     * The parameter name of fabric setting.
     */
    name: pulumi.Input<string>;
    /**
     * The parameter value of fabric setting.
     */
    value: pulumi.Input<string>;
}

/**
 * Describes a section in the fabric settings of the cluster.
 */
export interface SettingsSectionDescriptionArgs {
    /**
     * The section name of the fabric settings.
     */
    name: pulumi.Input<string>;
    /**
     * The collection of parameters in the section.
     */
    parameters: pulumi.Input<pulumi.Input<inputs.servicefabric.v20200101preview.SettingsParameterDescriptionArgs>[]>;
}

/**
 * Sku definition
 */
export interface SkuArgs {
    /**
     * Sku Name.
     */
    name: pulumi.Input<string>;
}

/**
 * Azure resource identifier.
 */
export interface SubResourceArgs {
    /**
     * Azure resource identifier.
     */
    id?: pulumi.Input<string>;
}

/**
 * Specifies set of extensions that should be installed onto the virtual machines.
 */
export interface VMSSExtensionArgs {
    /**
     * Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
     */
    autoUpgradeMinorVersion?: pulumi.Input<boolean>;
    /**
     * If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
     */
    forceUpdateTag?: pulumi.Input<string>;
    /**
     * The name of the extension.
     */
    name: pulumi.Input<string>;
    /**
     * The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
     */
    protectedSettings?: any;
    /**
     * Collection of extension names after which this extension needs to be provisioned.
     */
    provisionAfterExtensions?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The name of the extension handler publisher.
     */
    publisher: pulumi.Input<string>;
    /**
     * Json formatted public settings for the extension.
     */
    settings?: any;
    /**
     * Specifies the type of the extension; an example is "CustomScriptExtension".
     */
    type: pulumi.Input<string>;
    /**
     * Specifies the version of the script handler.
     */
    typeHandlerVersion: pulumi.Input<string>;
}

/**
 * Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
 */
export interface VaultCertificateArgs {
    /**
     * For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name <UppercaseThumbprint>.crt for the X509 certificate file and <UppercaseThumbprint>.prv for private key. Both of these files are .pem formatted.
     */
    certificateStore: pulumi.Input<string>;
    /**
     * This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
     */
    certificateUrl: pulumi.Input<string>;
}

/**
 * Specifies set of certificates that should be installed onto the virtual machines.
 */
export interface VaultSecretGroupArgs {
    /**
     * The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
     */
    sourceVault: pulumi.Input<inputs.servicefabric.v20200101preview.SubResourceArgs>;
    /**
     * The list of key vault references in SourceVault which contain certificates.
     */
    vaultCertificates: pulumi.Input<pulumi.Input<inputs.servicefabric.v20200101preview.VaultCertificateArgs>[]>;
}

