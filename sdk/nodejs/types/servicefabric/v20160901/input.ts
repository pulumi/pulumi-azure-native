// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../../../types/input";
import * as outputs from "../../../types/output";
import * as enums from "../../../types/enums";
import * as utilities from "../../../utilities";

/**
 * The settings to enable AAD authentication on the cluster
 */
export interface AzureActiveDirectoryArgs {
    /**
     * Azure active directory client application id
     */
    clientApplication?: pulumi.Input<string>;
    /**
     * Azure active directory cluster application id
     */
    clusterApplication?: pulumi.Input<string>;
    /**
     * Azure active directory tenant id
     */
    tenantId?: pulumi.Input<string>;
}

/**
 * Certificate details
 */
export interface CertificateDescriptionArgs {
    /**
     * Thumbprint of the primary certificate
     */
    thumbprint: pulumi.Input<string>;
    /**
     * Thumbprint of the secondary certificate
     */
    thumbprintSecondary?: pulumi.Input<string>;
    /**
     * The local certificate store location
     */
    x509StoreName?: pulumi.Input<string>;
}

/**
 * Client certificate details using common name
 */
export interface ClientCertificateCommonNameArgs {
    /**
     * Certificate common name to be granted access; be careful using wild card common names
     */
    certificateCommonName: pulumi.Input<string>;
    /**
     * Certificate issuer thumbprint
     */
    certificateIssuerThumbprint: pulumi.Input<string>;
    /**
     * Is this certificate used for admin access from the client, if false , it is used or query only access
     */
    isAdmin: pulumi.Input<boolean>;
}

/**
 * Client certificate details using thumbprint
 */
export interface ClientCertificateThumbprintArgs {
    /**
     * Certificate thumbprint
     */
    certificateThumbprint: pulumi.Input<string>;
    /**
     * Is this certificate used for admin access from the client, if false, it is used or query only access
     */
    isAdmin: pulumi.Input<boolean>;
}

/**
 * Defines a health policy used to evaluate the health of the cluster or of a cluster node.
 */
export interface ClusterHealthPolicyArgs {
    /**
     * The maximum allowed percentage of unhealthy applications before reporting an error. For example, to allow 10% of applications to be unhealthy, this value would be 10. 
     */
    maxPercentUnhealthyApplications?: pulumi.Input<number>;
    /**
     * The maximum allowed percentage of unhealthy nodes before reporting an error. For example, to allow 10% of nodes to be unhealthy, this value would be 10. 
     */
    maxPercentUnhealthyNodes?: pulumi.Input<number>;
}

/**
 * Delta health policy for the cluster
 */
export interface ClusterUpgradeDeltaHealthPolicyArgs {
    /**
     * Additional unhealthy applications percentage
     */
    maxPercentDeltaUnhealthyApplications: pulumi.Input<number>;
    /**
     * Additional unhealthy nodes percentage
     */
    maxPercentDeltaUnhealthyNodes: pulumi.Input<number>;
    /**
     * Additional unhealthy nodes percentage per upgrade domain 
     */
    maxPercentUpgradeDomainDeltaUnhealthyNodes: pulumi.Input<number>;
}

/**
 * Cluster upgrade policy
 */
export interface ClusterUpgradePolicyArgs {
    /**
     * Delta health policy
     */
    deltaHealthPolicy?: pulumi.Input<inputs.servicefabric.v20160901.ClusterUpgradeDeltaHealthPolicyArgs>;
    /**
     * Force node to restart or not
     */
    forceRestart?: pulumi.Input<boolean>;
    /**
     * The length of time that health checks can fail continuously,it represents .Net TimeSpan
     */
    healthCheckRetryTimeout: pulumi.Input<string>;
    /**
     * The length of time that health checks must pass continuously,it represents .Net TimeSpan
     */
    healthCheckStableDuration: pulumi.Input<string>;
    /**
     * The length of time to wait after completing an upgrade domain before performing health checks, it represents .Net TimeSpan
     */
    healthCheckWaitDuration: pulumi.Input<string>;
    /**
     * Cluster health Policy
     */
    healthPolicy: pulumi.Input<inputs.servicefabric.v20160901.ClusterHealthPolicyArgs>;
    /**
     * Use the user defined upgrade policy or not
     */
    overrideUserUpgradePolicy?: pulumi.Input<boolean>;
    /**
     * The timeout for any upgrade domain,it represents .Net TimeSpan
     */
    upgradeDomainTimeout: pulumi.Input<string>;
    /**
     * Timeout for replica set upgrade to complete,it represents .Net TimeSpan
     */
    upgradeReplicaSetCheckTimeout: pulumi.Input<string>;
    /**
     * The upgrade timeout,it represents .Net TimeSpan
     */
    upgradeTimeout: pulumi.Input<string>;
}

/**
 * Diagnostics storage account config
 */
export interface DiagnosticsStorageAccountConfigArgs {
    /**
     * Diagnostics storage account blob endpoint
     */
    blobEndpoint: pulumi.Input<string>;
    /**
     * Protected Diagnostics storage key name
     */
    protectedAccountKeyName: pulumi.Input<string>;
    /**
     * Diagnostics storage account queue endpoint
     */
    queueEndpoint: pulumi.Input<string>;
    /**
     * Diagnostics storage account name
     */
    storageAccountName: pulumi.Input<string>;
    /**
     * Diagnostics storage account table endpoint
     */
    tableEndpoint: pulumi.Input<string>;
}

/**
 * Port range details
 */
export interface EndpointRangeDescriptionArgs {
    /**
     * End port of a range of ports
     */
    endPort: pulumi.Input<number>;
    /**
     * Starting port of a range of ports
     */
    startPort: pulumi.Input<number>;
}

/**
 * Describes a node type in the cluster, each node type represents sub set of nodes in the cluster
 */
export interface NodeTypeDescriptionArgs {
    /**
     * Ports used by applications
     */
    applicationPorts?: pulumi.Input<inputs.servicefabric.v20160901.EndpointRangeDescriptionArgs>;
    /**
     * The capacity tags applied to the nodes in the node type, the cluster resource manager uses these tags to understand how much of a resource a node has
     */
    capacities?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The TCP cluster management endpoint port
     */
    clientConnectionEndpointPort: pulumi.Input<number>;
    /**
     * Node type durability Level
     */
    durabilityLevel?: pulumi.Input<string>;
    /**
     * System assigned application ports
     */
    ephemeralPorts?: pulumi.Input<inputs.servicefabric.v20160901.EndpointRangeDescriptionArgs>;
    /**
     * The HTTP cluster management endpoint port
     */
    httpGatewayEndpointPort: pulumi.Input<number>;
    /**
     * Mark this as the primary node type
     */
    isPrimary: pulumi.Input<boolean>;
    /**
     * Name of the node type
     */
    name: pulumi.Input<string>;
    /**
     * The placement tags applied to nodes in the node type, which can be used to indicate where certain services (workload) should run
     */
    placementProperties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Endpoint used by reverse proxy
     */
    reverseProxyEndpointPort?: pulumi.Input<number>;
    /**
     * The number of node instances in the node type
     */
    vmInstanceCount: pulumi.Input<number>;
}

/**
 * ServiceFabric settings under sections
 */
export interface SettingsParameterDescriptionArgs {
    /**
     * The name of settings property
     */
    name: pulumi.Input<string>;
    /**
     * The value of the property
     */
    value: pulumi.Input<string>;
}

/**
 * ServiceFabric section settings
 */
export interface SettingsSectionDescriptionArgs {
    /**
     * The name of settings section
     */
    name: pulumi.Input<string>;
    /**
     * Collection of settings in the section, each setting is a tuple consisting of setting name and value
     */
    parameters: pulumi.Input<pulumi.Input<inputs.servicefabric.v20160901.SettingsParameterDescriptionArgs>[]>;
}

