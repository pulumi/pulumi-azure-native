// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../../../types/input";
import * as outputs from "../../../types/output";
import * as enums from "../../../types/enums";
import * as utilities from "../../../utilities";

/**
 * The Activity query definitions
 */
export interface ActivityEntityQueriesPropertiesQueryDefinitionsArgs {
    /**
     * The Activity query to run on a given entity
     */
    query?: pulumi.Input<string>;
}

/**
 * Settings for how to dynamically override alert static details
 */
export interface AlertDetailsOverrideArgs {
    /**
     * the format containing columns name(s) to override the alert description
     */
    alertDescriptionFormat?: pulumi.Input<string>;
    /**
     * the format containing columns name(s) to override the alert name
     */
    alertDisplayNameFormat?: pulumi.Input<string>;
    /**
     * the column name to take the alert severity from
     */
    alertSeverityColumnName?: pulumi.Input<string>;
    /**
     * the column name to take the alert tactics from
     */
    alertTacticsColumnName?: pulumi.Input<string>;
}

/**
 * Alerts data type for data connectors.
 */
export interface AlertsDataTypeOfDataConnectorArgs {
    /**
     * Alerts data type connection.
     */
    alerts: pulumi.Input<inputs.securityinsights.v20210901preview.DataConnectorDataTypeCommonArgs>;
}

/**
 * Describes an automation rule action to modify an object's properties
 */
export interface AutomationRuleModifyPropertiesActionArgs {
    /**
     * The configuration of the modify properties automation rule action
     */
    actionConfiguration: pulumi.Input<inputs.securityinsights.v20210901preview.AutomationRuleModifyPropertiesActionActionConfigurationArgs>;
    /**
     * The type of the automation rule action
     * Expected value is 'ModifyProperties'.
     */
    actionType: pulumi.Input<"ModifyProperties">;
    /**
     * The order of execution of the automation rule action
     */
    order: pulumi.Input<number>;
}

/**
 * The configuration of the modify properties automation rule action
 */
export interface AutomationRuleModifyPropertiesActionActionConfigurationArgs {
    /**
     * The reason the incident was closed
     */
    classification?: pulumi.Input<string | enums.securityinsights.v20210901preview.IncidentClassification>;
    /**
     * Describes the reason the incident was closed
     */
    classificationComment?: pulumi.Input<string>;
    /**
     * The classification reason the incident was closed with
     */
    classificationReason?: pulumi.Input<string | enums.securityinsights.v20210901preview.IncidentClassificationReason>;
    /**
     * List of labels to add to the incident
     */
    labels?: pulumi.Input<pulumi.Input<inputs.securityinsights.v20210901preview.IncidentLabelArgs>[]>;
    /**
     * Describes a user that the incident is assigned to
     */
    owner?: pulumi.Input<inputs.securityinsights.v20210901preview.IncidentOwnerInfoArgs>;
    /**
     * The severity of the incident
     */
    severity?: pulumi.Input<string | enums.securityinsights.v20210901preview.IncidentSeverity>;
    /**
     * The status of the incident
     */
    status?: pulumi.Input<string | enums.securityinsights.v20210901preview.IncidentStatus>;
}

/**
 * Describes an automation rule condition that evaluates a property's value
 */
export interface AutomationRulePropertyValuesConditionArgs {
    /**
     * The configuration of the automation rule condition
     */
    conditionProperties: pulumi.Input<inputs.securityinsights.v20210901preview.AutomationRulePropertyValuesConditionConditionPropertiesArgs>;
    /**
     * The type of the automation rule condition
     * Expected value is 'Property'.
     */
    conditionType: pulumi.Input<"Property">;
}

/**
 * The configuration of the automation rule condition
 */
export interface AutomationRulePropertyValuesConditionConditionPropertiesArgs {
    /**
     * The operator to use for evaluation the condition
     */
    operator?: pulumi.Input<string | enums.securityinsights.v20210901preview.AutomationRulePropertyConditionSupportedOperator>;
    /**
     * The property to evaluate
     */
    propertyName?: pulumi.Input<string | enums.securityinsights.v20210901preview.AutomationRulePropertyConditionSupportedProperty>;
    /**
     * The values to use for evaluating the condition
     */
    propertyValues?: pulumi.Input<pulumi.Input<string>[]>;
}

/**
 * Describes an automation rule action to run a playbook
 */
export interface AutomationRuleRunPlaybookActionArgs {
    /**
     * The configuration of the run playbook automation rule action
     */
    actionConfiguration: pulumi.Input<inputs.securityinsights.v20210901preview.AutomationRuleRunPlaybookActionActionConfigurationArgs>;
    /**
     * The type of the automation rule action
     * Expected value is 'RunPlaybook'.
     */
    actionType: pulumi.Input<"RunPlaybook">;
    /**
     * The order of execution of the automation rule action
     */
    order: pulumi.Input<number>;
}

/**
 * The configuration of the run playbook automation rule action
 */
export interface AutomationRuleRunPlaybookActionActionConfigurationArgs {
    /**
     * The resource id of the playbook resource
     */
    logicAppResourceId?: pulumi.Input<string>;
    /**
     * The tenant id of the playbook resource
     */
    tenantId?: pulumi.Input<string>;
}

/**
 * Describes automation rule triggering logic
 */
export interface AutomationRuleTriggeringLogicArgs {
    /**
     * The conditions to evaluate to determine if the automation rule should be triggered on a given object
     */
    conditions?: pulumi.Input<pulumi.Input<inputs.securityinsights.v20210901preview.AutomationRulePropertyValuesConditionArgs>[]>;
    /**
     * Determines when the automation rule should automatically expire and be disabled.
     */
    expirationTimeUtc?: pulumi.Input<string>;
    /**
     * Determines whether the automation rule is enabled or disabled.
     */
    isEnabled: pulumi.Input<boolean>;
    /**
     * The type of object the automation rule triggers on
     */
    triggersOn: pulumi.Input<string | enums.securityinsights.v20210901preview.TriggersOn>;
    /**
     * The type of event the automation rule triggers on
     */
    triggersWhen: pulumi.Input<string | enums.securityinsights.v20210901preview.TriggersWhen>;
}

/**
 * Connector Availability Status
 */
export interface AvailabilityArgs {
    /**
     * Set connector as preview
     */
    isPreview?: pulumi.Input<boolean>;
    /**
     * The connector Availability Status
     */
    status?: pulumi.Input<number>;
}

/**
 * The available data types for Amazon Web Services CloudTrail data connector.
 */
export interface AwsCloudTrailDataConnectorDataTypesArgs {
    /**
     * Logs data type.
     */
    logs: pulumi.Input<inputs.securityinsights.v20210901preview.AwsCloudTrailDataConnectorDataTypesLogsArgs>;
}

/**
 * Logs data type.
 */
export interface AwsCloudTrailDataConnectorDataTypesLogsArgs {
    /**
     * Describe whether this data type connection is enabled or not.
     */
    state: pulumi.Input<string | enums.securityinsights.v20210901preview.DataTypeState>;
}

/**
 * The available data types for Amazon Web Services S3 data connector.
 */
export interface AwsS3DataConnectorDataTypesArgs {
    /**
     * Logs data type.
     */
    logs: pulumi.Input<inputs.securityinsights.v20210901preview.AwsS3DataConnectorDataTypesLogsArgs>;
}

/**
 * Logs data type.
 */
export interface AwsS3DataConnectorDataTypesLogsArgs {
    /**
     * Describe whether this data type connection is enabled or not.
     */
    state: pulumi.Input<string | enums.securityinsights.v20210901preview.DataTypeState>;
}

/**
 * Describe the authentication properties needed to successfully authenticate with the server
 */
export interface CodelessConnectorPollingAuthPropertiesArgs {
    /**
     * A prefix send in the header before the actual token
     */
    apiKeyIdentifier?: pulumi.Input<string>;
    /**
     * The header name which the token is sent with
     */
    apiKeyName?: pulumi.Input<string>;
    /**
     * The authentication type
     */
    authType: pulumi.Input<string>;
    /**
     * The endpoint used to authorize the user, used in Oauth 2.0 flow
     */
    authorizationEndpoint?: pulumi.Input<string>;
    /**
     * The query parameters used in authorization request, used in Oauth 2.0 flow
     */
    authorizationEndpointQueryParameters?: any;
    /**
     * Describes the flow name, for example 'AuthCode' for Oauth 2.0
     */
    flowName?: pulumi.Input<string>;
    /**
     * Marks if the key should sent in header
     */
    isApiKeyInPostPayload?: pulumi.Input<string>;
    /**
     * Marks if we should send the client secret in header or payload, used in Oauth 2.0 flow
     */
    isClientSecretInHeader?: pulumi.Input<boolean>;
    /**
     * The redirect endpoint where we will get the authorization code, used in Oauth 2.0 flow
     */
    redirectionEndpoint?: pulumi.Input<string>;
    /**
     * The OAuth token scope
     */
    scope?: pulumi.Input<string>;
    /**
     * The endpoint used to issue a token, used in Oauth 2.0 flow
     */
    tokenEndpoint?: pulumi.Input<string>;
    /**
     * The query headers used in token request, used in Oauth 2.0 flow
     */
    tokenEndpointHeaders?: any;
    /**
     * The query parameters used in token request, used in Oauth 2.0 flow
     */
    tokenEndpointQueryParameters?: any;
}

/**
 * Config to describe the polling config for API poller connector
 */
export interface CodelessConnectorPollingConfigPropertiesArgs {
    /**
     * Describe the authentication type of the poller
     */
    auth: pulumi.Input<inputs.securityinsights.v20210901preview.CodelessConnectorPollingAuthPropertiesArgs>;
    /**
     * The poller active status
     */
    isActive?: pulumi.Input<boolean>;
    /**
     * Describe the poll request paging config of the poller
     */
    paging?: pulumi.Input<inputs.securityinsights.v20210901preview.CodelessConnectorPollingPagingPropertiesArgs>;
    /**
     * Describe the poll request config parameters of the poller
     */
    request: pulumi.Input<inputs.securityinsights.v20210901preview.CodelessConnectorPollingRequestPropertiesArgs>;
    /**
     * Describe the response config parameters of the poller
     */
    response?: pulumi.Input<inputs.securityinsights.v20210901preview.CodelessConnectorPollingResponsePropertiesArgs>;
}

/**
 * Describe the properties needed to make a pagination call
 */
export interface CodelessConnectorPollingPagingPropertiesArgs {
    /**
     * Defines the name of a next page attribute
     */
    nextPageParaName?: pulumi.Input<string>;
    /**
     * Defines the path to a next page token JSON
     */
    nextPageTokenJsonPath?: pulumi.Input<string>;
    /**
     * Defines the path to a page count attribute
     */
    pageCountAttributePath?: pulumi.Input<string>;
    /**
     * Defines the paging size
     */
    pageSize?: pulumi.Input<number>;
    /**
     * Defines the name of the page size parameter
     */
    pageSizeParaName?: pulumi.Input<string>;
    /**
     * Defines the path to a paging time stamp attribute
     */
    pageTimeStampAttributePath?: pulumi.Input<string>;
    /**
     * Defines the path to a page total count attribute
     */
    pageTotalCountAttributePath?: pulumi.Input<string>;
    /**
     * Describes the type. could be 'None', 'PageToken', 'PageCount', 'TimeStamp'
     */
    pagingType: pulumi.Input<string>;
    /**
     * Determines whether to search for the latest time stamp in the events list
     */
    searchTheLatestTimeStampFromEventsList?: pulumi.Input<string>;
}

/**
 * Describe the request properties needed to successfully pull from the server
 */
export interface CodelessConnectorPollingRequestPropertiesArgs {
    /**
     * Describe the endpoint we should pull the data from
     */
    apiEndpoint: pulumi.Input<string>;
    /**
     * This will be used the query events from the end of the time window
     */
    endTimeAttributeName?: pulumi.Input<string>;
    /**
     * Describe the headers sent in the poll request
     */
    headers?: any;
    /**
     * The http method type we will use in the poll request, GET or POST
     */
    httpMethod: pulumi.Input<string>;
    /**
     * Describe the query parameters sent in the poll request
     */
    queryParameters?: any;
    /**
     * For advanced scenarios for example user name/password embedded in nested JSON payload
     */
    queryParametersTemplate?: pulumi.Input<string>;
    /**
     * The time format will be used the query events in a specific window
     */
    queryTimeFormat: pulumi.Input<string>;
    /**
     * The window interval we will use the pull the data
     */
    queryWindowInMin: pulumi.Input<number>;
    /**
     * Defines the rate limit QPS
     */
    rateLimitQps?: pulumi.Input<number>;
    /**
     * Describe the amount of time we should try and poll the data in case of failure
     */
    retryCount?: pulumi.Input<number>;
    /**
     * This will be used the query events from a start of the time window
     */
    startTimeAttributeName?: pulumi.Input<string>;
    /**
     * The number of seconds we will consider as a request timeout
     */
    timeoutInSeconds?: pulumi.Input<number>;
}

/**
 * Describes the response from the external server
 */
export interface CodelessConnectorPollingResponsePropertiesArgs {
    /**
     * Describes the path we should extract the data in the response
     */
    eventsJsonPaths: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Describes if the data in the response is Gzip
     */
    isGzipCompressed?: pulumi.Input<boolean>;
    /**
     * Describes the path we should extract the status code in the response
     */
    successStatusJsonPath?: pulumi.Input<string>;
    /**
     * Describes the path we should extract the status value in the response
     */
    successStatusValue?: pulumi.Input<string>;
}

/**
 * Config to describe the instructions blade
 */
export interface CodelessUiConnectorConfigPropertiesArgs {
    /**
     * Connector Availability Status
     */
    availability: pulumi.Input<inputs.securityinsights.v20210901preview.AvailabilityArgs>;
    /**
     * Define the way the connector check connectivity
     */
    connectivityCriteria: pulumi.Input<pulumi.Input<inputs.securityinsights.v20210901preview.CodelessUiConnectorConfigPropertiesConnectivityCriteriaArgs>[]>;
    /**
     * An optional custom image to be used when displaying the connector within Azure Sentinel's connector's gallery
     */
    customImage?: pulumi.Input<string>;
    /**
     * Data types to check for last data received
     */
    dataTypes: pulumi.Input<pulumi.Input<inputs.securityinsights.v20210901preview.CodelessUiConnectorConfigPropertiesDataTypesArgs>[]>;
    /**
     * Connector description
     */
    descriptionMarkdown: pulumi.Input<string>;
    /**
     * The graph query to show the current data status
     */
    graphQueries: pulumi.Input<pulumi.Input<inputs.securityinsights.v20210901preview.CodelessUiConnectorConfigPropertiesGraphQueriesArgs>[]>;
    /**
     * Name of the table the connector will insert the data to
     */
    graphQueriesTableName: pulumi.Input<string>;
    /**
     * Instruction steps to enable the connector
     */
    instructionSteps: pulumi.Input<pulumi.Input<inputs.securityinsights.v20210901preview.CodelessUiConnectorConfigPropertiesInstructionStepsArgs>[]>;
    /**
     * Permissions required for the connector
     */
    permissions: pulumi.Input<inputs.securityinsights.v20210901preview.PermissionsArgs>;
    /**
     * Connector publisher name
     */
    publisher: pulumi.Input<string>;
    /**
     * The sample queries for the connector
     */
    sampleQueries: pulumi.Input<pulumi.Input<inputs.securityinsights.v20210901preview.CodelessUiConnectorConfigPropertiesSampleQueriesArgs>[]>;
    /**
     * Connector blade title
     */
    title: pulumi.Input<string>;
}

export interface CodelessUiConnectorConfigPropertiesConnectivityCriteriaArgs {
    /**
     * type of connectivity
     */
    type?: pulumi.Input<string | enums.securityinsights.v20210901preview.ConnectivityType>;
    /**
     * Queries for checking connectivity
     */
    value?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface CodelessUiConnectorConfigPropertiesDataTypesArgs {
    /**
     * Query for indicate last data received
     */
    lastDataReceivedQuery?: pulumi.Input<string>;
    /**
     * Name of the data type to show in the graph. can be use with {{graphQueriesTableName}} placeholder
     */
    name?: pulumi.Input<string>;
}

export interface CodelessUiConnectorConfigPropertiesGraphQueriesArgs {
    /**
     * The base query for the graph
     */
    baseQuery?: pulumi.Input<string>;
    /**
     * The legend for the graph
     */
    legend?: pulumi.Input<string>;
    /**
     * the metric that the query is checking
     */
    metricName?: pulumi.Input<string>;
}

export interface CodelessUiConnectorConfigPropertiesInstructionStepsArgs {
    /**
     * Instruction step description
     */
    description?: pulumi.Input<string>;
    /**
     * Instruction step details
     */
    instructions?: pulumi.Input<pulumi.Input<inputs.securityinsights.v20210901preview.InstructionStepsInstructionsArgs>[]>;
    /**
     * Instruction step title
     */
    title?: pulumi.Input<string>;
}

export interface CodelessUiConnectorConfigPropertiesSampleQueriesArgs {
    /**
     * The sample query description
     */
    description?: pulumi.Input<string>;
    /**
     * the sample query
     */
    query?: pulumi.Input<string>;
}

/**
 * The mapping of content type to a repo path.
 */
export interface ContentPathMapArgs {
    /**
     * Content type.
     */
    contentType?: pulumi.Input<string | enums.securityinsights.v20210901preview.ContentType>;
    /**
     * The path to the content.
     */
    path?: pulumi.Input<string>;
}

/**
 * Common field for data type in data connectors.
 */
export interface DataConnectorDataTypeCommonArgs {
    /**
     * Describe whether this data type connection is enabled or not.
     */
    state: pulumi.Input<string | enums.securityinsights.v20210901preview.DataTypeState>;
}

/**
 * The available data types for Dynamics365 data connector.
 */
export interface Dynamics365DataConnectorDataTypesArgs {
    /**
     * Common Data Service data type connection.
     */
    dynamics365CdsActivities: pulumi.Input<inputs.securityinsights.v20210901preview.Dynamics365DataConnectorDataTypesDynamics365CdsActivitiesArgs>;
}

/**
 * Common Data Service data type connection.
 */
export interface Dynamics365DataConnectorDataTypesDynamics365CdsActivitiesArgs {
    /**
     * Describe whether this data type connection is enabled or not.
     */
    state: pulumi.Input<string | enums.securityinsights.v20210901preview.DataTypeState>;
}

/**
 * Single entity mapping for the alert rule
 */
export interface EntityMappingArgs {
    /**
     * The V3 type of the mapped entity
     */
    entityType?: pulumi.Input<string | enums.securityinsights.v20210901preview.EntityMappingType>;
    /**
     * array of field mappings for the given entity mapping
     */
    fieldMappings?: pulumi.Input<pulumi.Input<inputs.securityinsights.v20210901preview.FieldMappingArgs>[]>;
}

/**
 * Event grouping settings property bag.
 */
export interface EventGroupingSettingsArgs {
    /**
     * The event grouping aggregation kinds
     */
    aggregationKind?: pulumi.Input<string | enums.securityinsights.v20210901preview.EventGroupingAggregationKind>;
}

/**
 * A single field mapping of the mapped entity
 */
export interface FieldMappingArgs {
    /**
     * the column name to be mapped to the identifier
     */
    columnName?: pulumi.Input<string>;
    /**
     * the V3 identifier of the entity
     */
    identifier?: pulumi.Input<string>;
}

/**
 * Grouping configuration property bag.
 */
export interface GroupingConfigurationArgs {
    /**
     * Grouping enabled
     */
    enabled: pulumi.Input<boolean>;
    /**
     * A list of alert details to group by (when matchingMethod is Selected)
     */
    groupByAlertDetails?: pulumi.Input<pulumi.Input<string | enums.securityinsights.v20210901preview.AlertDetail>[]>;
    /**
     * A list of custom details keys to group by (when matchingMethod is Selected). Only keys defined in the current alert rule may be used.
     */
    groupByCustomDetails?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A list of entity types to group by (when matchingMethod is Selected). Only entities defined in the current alert rule may be used.
     */
    groupByEntities?: pulumi.Input<pulumi.Input<string | enums.securityinsights.v20210901preview.EntityMappingType>[]>;
    /**
     * Limit the group to alerts created within the lookback duration (in ISO 8601 duration format)
     */
    lookbackDuration: pulumi.Input<string>;
    /**
     * Grouping matching method. When method is Selected at least one of groupByEntities, groupByAlertDetails, groupByCustomDetails must be provided and not empty.
     */
    matchingMethod: pulumi.Input<string | enums.securityinsights.v20210901preview.MatchingMethod>;
    /**
     * Re-open closed matching incidents
     */
    reopenClosedIncident: pulumi.Input<boolean>;
}

/**
 * Incident Configuration property bag.
 */
export interface IncidentConfigurationArgs {
    /**
     * Create incidents from alerts triggered by this analytics rule
     */
    createIncident: pulumi.Input<boolean>;
    /**
     * Set how the alerts that are triggered by this analytics rule, are grouped into incidents
     */
    groupingConfiguration?: pulumi.Input<inputs.securityinsights.v20210901preview.GroupingConfigurationArgs>;
}

/**
 * Describes related incident information for the bookmark
 */
export interface IncidentInfoArgs {
    /**
     * Incident Id
     */
    incidentId?: pulumi.Input<string>;
    /**
     * Relation Name
     */
    relationName?: pulumi.Input<string>;
    /**
     * The severity of the incident
     */
    severity?: pulumi.Input<string | enums.securityinsights.v20210901preview.IncidentSeverity>;
    /**
     * The title of the incident
     */
    title?: pulumi.Input<string>;
}

/**
 * Represents an incident label
 */
export interface IncidentLabelArgs {
    /**
     * The name of the label
     */
    labelName: pulumi.Input<string>;
}

/**
 * Information on the user an incident is assigned to
 */
export interface IncidentOwnerInfoArgs {
    /**
     * The name of the user the incident is assigned to.
     */
    assignedTo?: pulumi.Input<string>;
    /**
     * The email of the user the incident is assigned to.
     */
    email?: pulumi.Input<string>;
    /**
     * The object id of the user the incident is assigned to.
     */
    objectId?: pulumi.Input<string>;
    /**
     * The user principal name of the user the incident is assigned to.
     */
    userPrincipalName?: pulumi.Input<string>;
}

export interface InstructionStepsInstructionsArgs {
    /**
     * The parameters for the setting
     */
    parameters?: any;
    /**
     * The kind of the setting
     */
    type: pulumi.Input<string | enums.securityinsights.v20210901preview.SettingType>;
}

/**
 * The available data types for MCAS (Microsoft Cloud App Security) data connector.
 */
export interface MCASDataConnectorDataTypesArgs {
    /**
     * Alerts data type connection.
     */
    alerts: pulumi.Input<inputs.securityinsights.v20210901preview.DataConnectorDataTypeCommonArgs>;
    /**
     * Discovery log data type connection.
     */
    discoveryLogs?: pulumi.Input<inputs.securityinsights.v20210901preview.DataConnectorDataTypeCommonArgs>;
}

/**
 * The available data types for Microsoft Threat Intelligence Platforms data connector.
 */
export interface MSTIDataConnectorDataTypesArgs {
    /**
     * Data type for Microsoft Threat Intelligence Platforms data connector.
     */
    bingSafetyPhishingURL: pulumi.Input<inputs.securityinsights.v20210901preview.MSTIDataConnectorDataTypesBingSafetyPhishingURLArgs>;
    /**
     * Data type for Microsoft Threat Intelligence Platforms data connector.
     */
    microsoftEmergingThreatFeed: pulumi.Input<inputs.securityinsights.v20210901preview.MSTIDataConnectorDataTypesMicrosoftEmergingThreatFeedArgs>;
}

/**
 * Data type for Microsoft Threat Intelligence Platforms data connector.
 */
export interface MSTIDataConnectorDataTypesBingSafetyPhishingURLArgs {
    /**
     * lookback period
     */
    lookbackPeriod: pulumi.Input<string>;
    /**
     * Describe whether this data type connection is enabled or not.
     */
    state: pulumi.Input<string | enums.securityinsights.v20210901preview.DataTypeState>;
}

/**
 * Data type for Microsoft Threat Intelligence Platforms data connector.
 */
export interface MSTIDataConnectorDataTypesMicrosoftEmergingThreatFeedArgs {
    /**
     * lookback period
     */
    lookbackPeriod: pulumi.Input<string>;
    /**
     * Describe whether this data type connection is enabled or not.
     */
    state: pulumi.Input<string | enums.securityinsights.v20210901preview.DataTypeState>;
}

/**
 * The available data types for Microsoft Threat Protection Platforms data connector.
 */
export interface MTPDataConnectorDataTypesArgs {
    /**
     * Data type for Microsoft Threat Protection Platforms data connector.
     */
    incidents: pulumi.Input<inputs.securityinsights.v20210901preview.MTPDataConnectorDataTypesIncidentsArgs>;
}

/**
 * Data type for Microsoft Threat Protection Platforms data connector.
 */
export interface MTPDataConnectorDataTypesIncidentsArgs {
    /**
     * Describe whether this data type connection is enabled or not.
     */
    state: pulumi.Input<string | enums.securityinsights.v20210901preview.DataTypeState>;
}

/**
 * Publisher or creator of the content item.
 */
export interface MetadataAuthorArgs {
    /**
     * Email of author contact
     */
    email?: pulumi.Input<string>;
    /**
     * Link for author/vendor page
     */
    link?: pulumi.Input<string>;
    /**
     * Name of the author. Company or person.
     */
    name?: pulumi.Input<string>;
}

/**
 * ies for the solution content item
 */
export interface MetadataCategoriesArgs {
    /**
     * domain for the solution content item
     */
    domains?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Industry verticals for the solution content item
     */
    verticals?: pulumi.Input<pulumi.Input<string>[]>;
}

/**
 * Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex dependencies.
 */
export interface MetadataDependenciesArgs {
    /**
     * Id of the content item we depend on
     */
    contentId?: pulumi.Input<string>;
    /**
     * This is the list of dependencies we must fulfill, according to the AND/OR operator
     */
    criteria?: pulumi.Input<pulumi.Input<inputs.securityinsights.v20210901preview.MetadataDependenciesArgs>[]>;
    /**
     * Type of the content item we depend on
     */
    kind?: pulumi.Input<string | enums.securityinsights.v20210901preview.Kind>;
    /**
     * Name of the content item
     */
    name?: pulumi.Input<string>;
    /**
     * Operator used for list of dependencies in criteria array.
     */
    operator?: pulumi.Input<string | enums.securityinsights.v20210901preview.Operator>;
    /**
     * Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
     */
    version?: pulumi.Input<string>;
}

/**
 * The original source of the content item, where it comes from.
 */
export interface MetadataSourceArgs {
    /**
     * Source type of the content
     */
    kind: pulumi.Input<string | enums.securityinsights.v20210901preview.SourceKind>;
    /**
     * Name of the content source.  The repo name, solution name, LA workspace name etc.
     */
    name?: pulumi.Input<string>;
    /**
     * ID of the content source.  The solution ID, workspace ID, etc
     */
    sourceId?: pulumi.Input<string>;
}

/**
 * Support information for the content item.
 */
export interface MetadataSupportArgs {
    /**
     * Email of support contact
     */
    email?: pulumi.Input<string>;
    /**
     * Link for support help, like to support page to open a ticket etc.
     */
    link?: pulumi.Input<string>;
    /**
     * Name of the support contact. Company or person.
     */
    name?: pulumi.Input<string>;
    /**
     * Type of support for content item
     */
    tier: pulumi.Input<string | enums.securityinsights.v20210901preview.SupportTier>;
}

/**
 * The available data types for office data connector.
 */
export interface OfficeDataConnectorDataTypesArgs {
    /**
     * Exchange data type connection.
     */
    exchange: pulumi.Input<inputs.securityinsights.v20210901preview.OfficeDataConnectorDataTypesExchangeArgs>;
    /**
     * SharePoint data type connection.
     */
    sharePoint: pulumi.Input<inputs.securityinsights.v20210901preview.OfficeDataConnectorDataTypesSharePointArgs>;
    /**
     * Teams data type connection.
     */
    teams: pulumi.Input<inputs.securityinsights.v20210901preview.OfficeDataConnectorDataTypesTeamsArgs>;
}

/**
 * Exchange data type connection.
 */
export interface OfficeDataConnectorDataTypesExchangeArgs {
    /**
     * Describe whether this data type connection is enabled or not.
     */
    state: pulumi.Input<string | enums.securityinsights.v20210901preview.DataTypeState>;
}

/**
 * SharePoint data type connection.
 */
export interface OfficeDataConnectorDataTypesSharePointArgs {
    /**
     * Describe whether this data type connection is enabled or not.
     */
    state: pulumi.Input<string | enums.securityinsights.v20210901preview.DataTypeState>;
}

/**
 * Teams data type connection.
 */
export interface OfficeDataConnectorDataTypesTeamsArgs {
    /**
     * Describe whether this data type connection is enabled or not.
     */
    state: pulumi.Input<string | enums.securityinsights.v20210901preview.DataTypeState>;
}

/**
 * Permissions required for the connector
 */
export interface PermissionsArgs {
    /**
     * Customs permissions required for the connector
     */
    customs?: pulumi.Input<pulumi.Input<inputs.securityinsights.v20210901preview.PermissionsCustomsArgs>[]>;
    /**
     * Resource provider permissions required for the connector
     */
    resourceProvider?: pulumi.Input<pulumi.Input<inputs.securityinsights.v20210901preview.PermissionsResourceProviderArgs>[]>;
}

export interface PermissionsCustomsArgs {
    /**
     * Customs permissions description
     */
    description?: pulumi.Input<string>;
    /**
     * Customs permissions name
     */
    name?: pulumi.Input<string>;
}

export interface PermissionsResourceProviderArgs {
    /**
     * Permission description text
     */
    permissionsDisplayText?: pulumi.Input<string>;
    /**
     * Provider name
     */
    provider?: pulumi.Input<string | enums.securityinsights.v20210901preview.ProviderName>;
    /**
     * Permission provider display name
     */
    providerDisplayName?: pulumi.Input<string>;
    /**
     * Required permissions for the connector
     */
    requiredPermissions?: pulumi.Input<inputs.securityinsights.v20210901preview.RequiredPermissionsArgs>;
    /**
     * Permission provider scope
     */
    scope?: pulumi.Input<string | enums.securityinsights.v20210901preview.PermissionProviderScope>;
}

/**
 * metadata of a repository.
 */
export interface RepositoryArgs {
    /**
     * Branch name of repository.
     */
    branch?: pulumi.Input<string>;
    /**
     * Url to access repository action logs.
     */
    deploymentLogsUrl?: pulumi.Input<string>;
    /**
     * Display url of repository.
     */
    displayUrl?: pulumi.Input<string>;
    /**
     * Dictionary of source control content type and path mapping.
     */
    pathMapping?: pulumi.Input<pulumi.Input<inputs.securityinsights.v20210901preview.ContentPathMapArgs>[]>;
    /**
     * Url of repository.
     */
    url?: pulumi.Input<string>;
}

/**
 * Required permissions for the connector
 */
export interface RequiredPermissionsArgs {
    /**
     * action permission
     */
    action?: pulumi.Input<boolean>;
    /**
     * delete permission
     */
    delete?: pulumi.Input<boolean>;
    /**
     * read permission
     */
    read?: pulumi.Input<boolean>;
    /**
     * write permission
     */
    write?: pulumi.Input<boolean>;
}

/**
 * The available data types for TI (Threat Intelligence) data connector.
 */
export interface TIDataConnectorDataTypesArgs {
    /**
     * Data type for indicators connection.
     */
    indicators: pulumi.Input<inputs.securityinsights.v20210901preview.TIDataConnectorDataTypesIndicatorsArgs>;
}

/**
 * Data type for indicators connection.
 */
export interface TIDataConnectorDataTypesIndicatorsArgs {
    /**
     * Describe whether this data type connection is enabled or not.
     */
    state: pulumi.Input<string | enums.securityinsights.v20210901preview.DataTypeState>;
}

/**
 * Describes external reference
 */
export interface ThreatIntelligenceExternalReferenceArgs {
    /**
     * External reference description
     */
    description?: pulumi.Input<string>;
    /**
     * External reference ID
     */
    externalId?: pulumi.Input<string>;
    /**
     * External reference hashes
     */
    hashes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * External reference source name
     */
    sourceName?: pulumi.Input<string>;
    /**
     * External reference URL
     */
    url?: pulumi.Input<string>;
}

/**
 * Describes threat granular marking model entity
 */
export interface ThreatIntelligenceGranularMarkingModelArgs {
    /**
     * Language granular marking model
     */
    language?: pulumi.Input<string>;
    /**
     * marking reference granular marking model
     */
    markingRef?: pulumi.Input<number>;
    /**
     * granular marking model selectors
     */
    selectors?: pulumi.Input<pulumi.Input<string>[]>;
}

/**
 * Describes threat kill chain phase entity
 */
export interface ThreatIntelligenceKillChainPhaseArgs {
    /**
     * Kill chainName name
     */
    killChainName?: pulumi.Input<string>;
    /**
     * Phase name
     */
    phaseName?: pulumi.Input<string>;
}

/**
 * Describes parsed pattern entity
 */
export interface ThreatIntelligenceParsedPatternArgs {
    /**
     * Pattern type key
     */
    patternTypeKey?: pulumi.Input<string>;
    /**
     * Pattern type keys
     */
    patternTypeValues?: pulumi.Input<pulumi.Input<inputs.securityinsights.v20210901preview.ThreatIntelligenceParsedPatternTypeValueArgs>[]>;
}

/**
 * Describes threat kill chain phase entity
 */
export interface ThreatIntelligenceParsedPatternTypeValueArgs {
    /**
     * Value of parsed pattern
     */
    value?: pulumi.Input<string>;
    /**
     * Type of the value
     */
    valueType?: pulumi.Input<string>;
}

/**
 * The available data types for Threat Intelligence TAXII data connector.
 */
export interface TiTaxiiDataConnectorDataTypesArgs {
    /**
     * Data type for TAXII connector.
     */
    taxiiClient: pulumi.Input<inputs.securityinsights.v20210901preview.TiTaxiiDataConnectorDataTypesTaxiiClientArgs>;
}

/**
 * Data type for TAXII connector.
 */
export interface TiTaxiiDataConnectorDataTypesTaxiiClientArgs {
    /**
     * Describe whether this data type connection is enabled or not.
     */
    state: pulumi.Input<string | enums.securityinsights.v20210901preview.DataTypeState>;
}

/**
 * User information that made some action
 */
export interface UserInfoArgs {
    /**
     * The object id of the user.
     */
    objectId?: pulumi.Input<string>;
}

/**
 * User information that made some action
 */
export interface WatchlistUserInfoArgs {
    /**
     * The object id of the user.
     */
    objectId?: pulumi.Input<string>;
}

