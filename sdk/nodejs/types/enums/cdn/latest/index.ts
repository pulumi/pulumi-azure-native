// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***


export const AFDEndpointProtocols = {
    Http: "Http",
    Https: "Https",
} as const;

/**
 * Supported protocols for the customer's endpoint.
 */
export type AFDEndpointProtocols = (typeof AFDEndpointProtocols)[keyof typeof AFDEndpointProtocols];

export const ActionType = {
    Allow: "Allow",
    Block: "Block",
    Log: "Log",
    Redirect: "Redirect",
} as const;

/**
 * Describes what action to be applied when rule matches
 */
export type ActionType = (typeof ActionType)[keyof typeof ActionType];

export const AfdCertificateType = {
    CustomerCertificate: "CustomerCertificate",
    ManagedCertificate: "ManagedCertificate",
} as const;

/**
 * Defines the source of the SSL certificate.
 */
export type AfdCertificateType = (typeof AfdCertificateType)[keyof typeof AfdCertificateType];

export const AfdMinimumTlsVersion = {
    TLS10: "TLS10",
    TLS12: "TLS12",
} as const;

/**
 * TLS protocol version that will be used for Https
 */
export type AfdMinimumTlsVersion = (typeof AfdMinimumTlsVersion)[keyof typeof AfdMinimumTlsVersion];

export const AfdQueryStringCachingBehavior = {
    IgnoreQueryString: "IgnoreQueryString",
    UseQueryString: "UseQueryString",
    NotSet: "NotSet",
} as const;

/**
 * Defines how CDN caches requests that include query strings. You can ignore any query strings when caching, bypass caching to prevent requests that contain query strings from being cached, or cache every request with a unique URL.
 */
export type AfdQueryStringCachingBehavior = (typeof AfdQueryStringCachingBehavior)[keyof typeof AfdQueryStringCachingBehavior];

export const Algorithm = {
    SHA256: "SHA256",
} as const;

/**
 * Algorithm to use for URL signing
 */
export type Algorithm = (typeof Algorithm)[keyof typeof Algorithm];

export const CacheBehavior = {
    BypassCache: "BypassCache",
    Override: "Override",
    SetIfMissing: "SetIfMissing",
} as const;

/**
 * Caching behavior for the requests
 */
export type CacheBehavior = (typeof CacheBehavior)[keyof typeof CacheBehavior];

export const CacheType = {
    All: "All",
} as const;

/**
 * The level at which the content needs to be cached.
 */
export type CacheType = (typeof CacheType)[keyof typeof CacheType];

export const CookiesOperator = {
    Any: "Any",
    Equal: "Equal",
    Contains: "Contains",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    LessThan: "LessThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThan: "GreaterThan",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type CookiesOperator = (typeof CookiesOperator)[keyof typeof CookiesOperator];

export const CustomRuleEnabledState = {
    Disabled: "Disabled",
    Enabled: "Enabled",
} as const;

/**
 * Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
 */
export type CustomRuleEnabledState = (typeof CustomRuleEnabledState)[keyof typeof CustomRuleEnabledState];

export const DeliveryRuleAction = {
    CacheExpiration: "CacheExpiration",
    CacheKeyQueryString: "CacheKeyQueryString",
    ModifyRequestHeader: "ModifyRequestHeader",
    ModifyResponseHeader: "ModifyResponseHeader",
    UrlRedirect: "UrlRedirect",
    UrlRewrite: "UrlRewrite",
    UrlSigning: "UrlSigning",
    OriginGroupOverride: "OriginGroupOverride",
} as const;

/**
 * The name of the action for the delivery rule.
 */
export type DeliveryRuleAction = (typeof DeliveryRuleAction)[keyof typeof DeliveryRuleAction];

export const DestinationProtocol = {
    MatchRequest: "MatchRequest",
    Http: "Http",
    Https: "Https",
} as const;

/**
 * Protocol to use for the redirect. The default value is MatchRequest
 */
export type DestinationProtocol = (typeof DestinationProtocol)[keyof typeof DestinationProtocol];

export const EnabledState = {
    Enabled: "Enabled",
    Disabled: "Disabled",
} as const;

/**
 * Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
 */
export type EnabledState = (typeof EnabledState)[keyof typeof EnabledState];

export const ForwardingProtocol = {
    HttpOnly: "HttpOnly",
    HttpsOnly: "HttpsOnly",
    MatchRequest: "MatchRequest",
} as const;

/**
 * Protocol this rule will use when forwarding traffic to backends.
 */
export type ForwardingProtocol = (typeof ForwardingProtocol)[keyof typeof ForwardingProtocol];

export const GeoFilterActions = {
    Block: "Block",
    Allow: "Allow",
} as const;

/**
 * Action of the geo filter, i.e. allow or block access.
 */
export type GeoFilterActions = (typeof GeoFilterActions)[keyof typeof GeoFilterActions];

export const HeaderAction = {
    Append: "Append",
    Overwrite: "Overwrite",
    Delete: "Delete",
} as const;

/**
 * Action to perform
 */
export type HeaderAction = (typeof HeaderAction)[keyof typeof HeaderAction];

export const HealthProbeRequestType = {
    NotSet: "NotSet",
    GET: "GET",
    HEAD: "HEAD",
} as const;

/**
 * The type of health probe request that is made.
 */
export type HealthProbeRequestType = (typeof HealthProbeRequestType)[keyof typeof HealthProbeRequestType];

export const HttpVersionOperator = {
    Equal: "Equal",
} as const;

/**
 * Describes operator to be matched
 */
export type HttpVersionOperator = (typeof HttpVersionOperator)[keyof typeof HttpVersionOperator];

export const HttpsRedirect = {
    Enabled: "Enabled",
    Disabled: "Disabled",
} as const;

/**
 * Whether to automatically redirect HTTP traffic to HTTPS traffic. Note that this is a easy way to set up this rule and it will be the first rule that gets executed.
 */
export type HttpsRedirect = (typeof HttpsRedirect)[keyof typeof HttpsRedirect];

export const IsDeviceOperator = {
    Equal: "Equal",
} as const;

/**
 * Describes operator to be matched
 */
export type IsDeviceOperator = (typeof IsDeviceOperator)[keyof typeof IsDeviceOperator];

export const LinkToDefaultDomain = {
    Enabled: "Enabled",
    Disabled: "Disabled",
} as const;

/**
 * whether this route will be linked to the default endpoint domain.
 */
export type LinkToDefaultDomain = (typeof LinkToDefaultDomain)[keyof typeof LinkToDefaultDomain];

export const ManagedRuleEnabledState = {
    Disabled: "Disabled",
    Enabled: "Enabled",
} as const;

/**
 * Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
 */
export type ManagedRuleEnabledState = (typeof ManagedRuleEnabledState)[keyof typeof ManagedRuleEnabledState];

export const MatchProcessingBehavior = {
    Continue: "Continue",
    Stop: "Stop",
} as const;

/**
 * If this rule is a match should the rules engine continue running the remaining rules or stop. If not present, defaults to Continue.
 */
export type MatchProcessingBehavior = (typeof MatchProcessingBehavior)[keyof typeof MatchProcessingBehavior];

export const MatchVariable = {
    RemoteAddress: "RemoteAddress",
    RequestMethod: "RequestMethod",
    QueryString: "QueryString",
    PostArgs: "PostArgs",
    RequestUri: "RequestUri",
    RequestHeader: "RequestHeader",
    RequestBody: "RequestBody",
    RequestScheme: "RequestScheme",
    UrlPath: "UrlPath",
    UrlFileExtension: "UrlFileExtension",
    UrlFileName: "UrlFileName",
    HttpVersion: "HttpVersion",
    Cookies: "Cookies",
    IsDevice: "IsDevice",
} as const;

/**
 * The name of the condition for the delivery rule.
 */
export type MatchVariable = (typeof MatchVariable)[keyof typeof MatchVariable];

export const Operator = {
    Any: "Any",
    IPMatch: "IPMatch",
    GeoMatch: "GeoMatch",
    Equal: "Equal",
    Contains: "Contains",
    LessThan: "LessThan",
    GreaterThan: "GreaterThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type Operator = (typeof Operator)[keyof typeof Operator];

export const OptimizationType = {
    GeneralWebDelivery: "GeneralWebDelivery",
    GeneralMediaStreaming: "GeneralMediaStreaming",
    VideoOnDemandMediaStreaming: "VideoOnDemandMediaStreaming",
    LargeFileDownload: "LargeFileDownload",
    DynamicSiteAcceleration: "DynamicSiteAcceleration",
} as const;

/**
 * Specifies what scenario the customer wants this CDN endpoint to optimize for, e.g. Download, Media services. With this information, CDN can apply scenario driven optimization.
 */
export type OptimizationType = (typeof OptimizationType)[keyof typeof OptimizationType];

export const ParamIndicator = {
    Expires: "Expires",
    KeyId: "KeyId",
    Signature: "Signature",
} as const;

/**
 * Indicates the purpose of the parameter
 */
export type ParamIndicator = (typeof ParamIndicator)[keyof typeof ParamIndicator];

export const PolicyEnabledState = {
    Disabled: "Disabled",
    Enabled: "Enabled",
} as const;

/**
 * describes if the policy is in enabled state or disabled state
 */
export type PolicyEnabledState = (typeof PolicyEnabledState)[keyof typeof PolicyEnabledState];

export const PolicyMode = {
    Prevention: "Prevention",
    Detection: "Detection",
} as const;

/**
 * Describes if it is in detection mode or prevention mode at policy level.
 */
export type PolicyMode = (typeof PolicyMode)[keyof typeof PolicyMode];

export const PostArgsOperator = {
    Any: "Any",
    Equal: "Equal",
    Contains: "Contains",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    LessThan: "LessThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThan: "GreaterThan",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type PostArgsOperator = (typeof PostArgsOperator)[keyof typeof PostArgsOperator];

export const ProbeProtocol = {
    NotSet: "NotSet",
    Http: "Http",
    Https: "Https",
} as const;

/**
 * Protocol to use for health probe.
 */
export type ProbeProtocol = (typeof ProbeProtocol)[keyof typeof ProbeProtocol];

export const QueryStringBehavior = {
    Include: "Include",
    IncludeAll: "IncludeAll",
    Exclude: "Exclude",
    ExcludeAll: "ExcludeAll",
} as const;

/**
 * Caching behavior for the requests
 */
export type QueryStringBehavior = (typeof QueryStringBehavior)[keyof typeof QueryStringBehavior];

export const QueryStringCachingBehavior = {
    IgnoreQueryString: "IgnoreQueryString",
    BypassCaching: "BypassCaching",
    UseQueryString: "UseQueryString",
    NotSet: "NotSet",
} as const;

/**
 * Defines how CDN caches requests that include query strings. You can ignore any query strings when caching, bypass caching to prevent requests that contain query strings from being cached, or cache every request with a unique URL.
 */
export type QueryStringCachingBehavior = (typeof QueryStringCachingBehavior)[keyof typeof QueryStringCachingBehavior];

export const QueryStringOperator = {
    Any: "Any",
    Equal: "Equal",
    Contains: "Contains",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    LessThan: "LessThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThan: "GreaterThan",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type QueryStringOperator = (typeof QueryStringOperator)[keyof typeof QueryStringOperator];

export const RedirectType = {
    Moved: "Moved",
    Found: "Found",
    TemporaryRedirect: "TemporaryRedirect",
    PermanentRedirect: "PermanentRedirect",
} as const;

/**
 * The redirect type the rule will use when redirecting traffic.
 */
export type RedirectType = (typeof RedirectType)[keyof typeof RedirectType];

export const RemoteAddressOperator = {
    Any: "Any",
    IPMatch: "IPMatch",
    GeoMatch: "GeoMatch",
} as const;

/**
 * Describes operator to be matched
 */
export type RemoteAddressOperator = (typeof RemoteAddressOperator)[keyof typeof RemoteAddressOperator];

export const RequestBodyOperator = {
    Any: "Any",
    Equal: "Equal",
    Contains: "Contains",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    LessThan: "LessThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThan: "GreaterThan",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type RequestBodyOperator = (typeof RequestBodyOperator)[keyof typeof RequestBodyOperator];

export const RequestHeaderOperator = {
    Any: "Any",
    Equal: "Equal",
    Contains: "Contains",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    LessThan: "LessThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThan: "GreaterThan",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type RequestHeaderOperator = (typeof RequestHeaderOperator)[keyof typeof RequestHeaderOperator];

export const RequestMethodOperator = {
    Equal: "Equal",
} as const;

/**
 * Describes operator to be matched
 */
export type RequestMethodOperator = (typeof RequestMethodOperator)[keyof typeof RequestMethodOperator];

export const RequestUriOperator = {
    Any: "Any",
    Equal: "Equal",
    Contains: "Contains",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    LessThan: "LessThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThan: "GreaterThan",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type RequestUriOperator = (typeof RequestUriOperator)[keyof typeof RequestUriOperator];

export const ResponseBasedDetectedErrorTypes = {
    None: "None",
    TcpErrorsOnly: "TcpErrorsOnly",
    TcpAndHttpErrors: "TcpAndHttpErrors",
} as const;

/**
 * Type of response errors for real user requests for which origin will be deemed unhealthy
 */
export type ResponseBasedDetectedErrorTypes = (typeof ResponseBasedDetectedErrorTypes)[keyof typeof ResponseBasedDetectedErrorTypes];

export const SecretType = {
    UrlSigningKey: "UrlSigningKey",
    CustomerCertificate: "CustomerCertificate",
    ManagedCertificate: "ManagedCertificate",
} as const;

/**
 * The type of the Secret to create.
 */
export type SecretType = (typeof SecretType)[keyof typeof SecretType];

export const SecurityPolicyType = {
    WebApplicationFirewall: "WebApplicationFirewall",
} as const;

/**
 * The type of the Security policy to create.
 */
export type SecurityPolicyType = (typeof SecurityPolicyType)[keyof typeof SecurityPolicyType];

export const SharedPrivateLinkResourceStatus = {
    Pending: "Pending",
    Approved: "Approved",
    Rejected: "Rejected",
    Disconnected: "Disconnected",
    Timeout: "Timeout",
} as const;

/**
 * Status of the shared private link resource. Can be Pending, Approved, Rejected, Disconnected, or Timeout.
 */
export type SharedPrivateLinkResourceStatus = (typeof SharedPrivateLinkResourceStatus)[keyof typeof SharedPrivateLinkResourceStatus];

export const SkuName = {
    Standard_Verizon: "Standard_Verizon",
    Premium_Verizon: "Premium_Verizon",
    Custom_Verizon: "Custom_Verizon",
    Standard_Akamai: "Standard_Akamai",
    Standard_ChinaCdn: "Standard_ChinaCdn",
    Standard_Microsoft: "Standard_Microsoft",
    Premium_ChinaCdn: "Premium_ChinaCdn",
    Standard_AzureFrontDoor: "Standard_AzureFrontDoor",
    Premium_AzureFrontDoor: "Premium_AzureFrontDoor",
    Standard_955BandWidth_ChinaCdn: "Standard_955BandWidth_ChinaCdn",
    Standard_AvgBandWidth_ChinaCdn: "Standard_AvgBandWidth_ChinaCdn",
    StandardPlus_ChinaCdn: "StandardPlus_ChinaCdn",
    StandardPlus_955BandWidth_ChinaCdn: "StandardPlus_955BandWidth_ChinaCdn",
    StandardPlus_AvgBandWidth_ChinaCdn: "StandardPlus_AvgBandWidth_ChinaCdn",
} as const;

/**
 * Name of the pricing tier.
 */
export type SkuName = (typeof SkuName)[keyof typeof SkuName];

export const Transform = {
    Lowercase: "Lowercase",
    Uppercase: "Uppercase",
} as const;

/**
 * Describes what transforms are applied before matching
 */
export type Transform = (typeof Transform)[keyof typeof Transform];

export const TransformType = {
    Lowercase: "Lowercase",
    Uppercase: "Uppercase",
    Trim: "Trim",
    UrlDecode: "UrlDecode",
    UrlEncode: "UrlEncode",
    RemoveNulls: "RemoveNulls",
} as const;

/**
 * Describes what transforms were applied before matching.
 */
export type TransformType = (typeof TransformType)[keyof typeof TransformType];

export const UrlFileExtensionOperator = {
    Any: "Any",
    Equal: "Equal",
    Contains: "Contains",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    LessThan: "LessThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThan: "GreaterThan",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type UrlFileExtensionOperator = (typeof UrlFileExtensionOperator)[keyof typeof UrlFileExtensionOperator];

export const UrlFileNameOperator = {
    Any: "Any",
    Equal: "Equal",
    Contains: "Contains",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    LessThan: "LessThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThan: "GreaterThan",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type UrlFileNameOperator = (typeof UrlFileNameOperator)[keyof typeof UrlFileNameOperator];

export const UrlPathOperator = {
    Any: "Any",
    Equal: "Equal",
    Contains: "Contains",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    LessThan: "LessThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThan: "GreaterThan",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    Wildcard: "Wildcard",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type UrlPathOperator = (typeof UrlPathOperator)[keyof typeof UrlPathOperator];
