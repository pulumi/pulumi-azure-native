// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

// Export sub-modules:
import * as v20230501 from "./v20230501";
import * as v20240601preview from "./v20240601preview";
import * as v20240901 from "./v20240901";

export {
    v20230501,
    v20240601preview,
    v20240901,
};

export const AFDEndpointProtocols = {
    Http: "Http",
    Https: "Https",
} as const;

/**
 * Supported protocols for the customer's endpoint.
 */
export type AFDEndpointProtocols = (typeof AFDEndpointProtocols)[keyof typeof AFDEndpointProtocols];

export const ActionType = {
    Allow: "Allow",
    Block: "Block",
    Log: "Log",
    Redirect: "Redirect",
} as const;

/**
 * Describes what action to be applied when rule matches
 */
export type ActionType = (typeof ActionType)[keyof typeof ActionType];

export const AfdCertificateType = {
    CustomerCertificate: "CustomerCertificate",
    ManagedCertificate: "ManagedCertificate",
    AzureFirstPartyManagedCertificate: "AzureFirstPartyManagedCertificate",
} as const;

/**
 * Defines the source of the SSL certificate.
 */
export type AfdCertificateType = (typeof AfdCertificateType)[keyof typeof AfdCertificateType];

export const AfdMinimumTlsVersion = {
    TLS10: "TLS10",
    TLS12: "TLS12",
} as const;

/**
 * TLS protocol version that will be used for Https
 */
export type AfdMinimumTlsVersion = (typeof AfdMinimumTlsVersion)[keyof typeof AfdMinimumTlsVersion];

export const AfdQueryStringCachingBehavior = {
    IgnoreQueryString: "IgnoreQueryString",
    UseQueryString: "UseQueryString",
    IgnoreSpecifiedQueryStrings: "IgnoreSpecifiedQueryStrings",
    IncludeSpecifiedQueryStrings: "IncludeSpecifiedQueryStrings",
} as const;

/**
 * Defines how Frontdoor caches requests that include query strings. You can ignore any query strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query strings.
 */
export type AfdQueryStringCachingBehavior = (typeof AfdQueryStringCachingBehavior)[keyof typeof AfdQueryStringCachingBehavior];

export const Algorithm = {
    SHA256: "SHA256",
} as const;

/**
 * Algorithm to use for URL signing
 */
export type Algorithm = (typeof Algorithm)[keyof typeof Algorithm];

export const AutoGeneratedDomainNameLabelScope = {
    TenantReuse: "TenantReuse",
    SubscriptionReuse: "SubscriptionReuse",
    ResourceGroupReuse: "ResourceGroupReuse",
    NoReuse: "NoReuse",
} as const;

/**
 * Indicates the endpoint name reuse scope. The default value is TenantReuse.
 */
export type AutoGeneratedDomainNameLabelScope = (typeof AutoGeneratedDomainNameLabelScope)[keyof typeof AutoGeneratedDomainNameLabelScope];

export const CacheBehavior = {
    BypassCache: "BypassCache",
    Override: "Override",
    SetIfMissing: "SetIfMissing",
} as const;

/**
 * Caching behavior for the requests
 */
export type CacheBehavior = (typeof CacheBehavior)[keyof typeof CacheBehavior];

export const CacheType = {
    All: "All",
} as const;

/**
 * The level at which the content needs to be cached.
 */
export type CacheType = (typeof CacheType)[keyof typeof CacheType];

export const ClientPortOperator = {
    Any: "Any",
    Equal: "Equal",
    Contains: "Contains",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    LessThan: "LessThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThan: "GreaterThan",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type ClientPortOperator = (typeof ClientPortOperator)[keyof typeof ClientPortOperator];

export const CookiesOperator = {
    Any: "Any",
    Equal: "Equal",
    Contains: "Contains",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    LessThan: "LessThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThan: "GreaterThan",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type CookiesOperator = (typeof CookiesOperator)[keyof typeof CookiesOperator];

export const CustomRuleEnabledState = {
    Disabled: "Disabled",
    Enabled: "Enabled",
} as const;

/**
 * Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
 */
export type CustomRuleEnabledState = (typeof CustomRuleEnabledState)[keyof typeof CustomRuleEnabledState];

export const DeliveryRuleActionName = {
    CacheExpiration: "CacheExpiration",
    CacheKeyQueryString: "CacheKeyQueryString",
    ModifyRequestHeader: "ModifyRequestHeader",
    ModifyResponseHeader: "ModifyResponseHeader",
    UrlRedirect: "UrlRedirect",
    UrlRewrite: "UrlRewrite",
    UrlSigning: "UrlSigning",
    OriginGroupOverride: "OriginGroupOverride",
    RouteConfigurationOverride: "RouteConfigurationOverride",
} as const;

/**
 * The name of the action for the delivery rule.
 */
export type DeliveryRuleActionName = (typeof DeliveryRuleActionName)[keyof typeof DeliveryRuleActionName];

export const DeliveryRuleActionParametersType = {
    DeliveryRuleUrlRedirectActionParameters: "DeliveryRuleUrlRedirectActionParameters",
    DeliveryRuleUrlSigningActionParameters: "DeliveryRuleUrlSigningActionParameters",
    DeliveryRuleOriginGroupOverrideActionParameters: "DeliveryRuleOriginGroupOverrideActionParameters",
    DeliveryRuleUrlRewriteActionParameters: "DeliveryRuleUrlRewriteActionParameters",
    DeliveryRuleHeaderActionParameters: "DeliveryRuleHeaderActionParameters",
    DeliveryRuleCacheExpirationActionParameters: "DeliveryRuleCacheExpirationActionParameters",
    DeliveryRuleCacheKeyQueryStringBehaviorActionParameters: "DeliveryRuleCacheKeyQueryStringBehaviorActionParameters",
    DeliveryRuleRouteConfigurationOverrideActionParameters: "DeliveryRuleRouteConfigurationOverrideActionParameters",
} as const;

export type DeliveryRuleActionParametersType = (typeof DeliveryRuleActionParametersType)[keyof typeof DeliveryRuleActionParametersType];

export const DeliveryRuleConditionParametersType = {
    DeliveryRuleRemoteAddressConditionParameters: "DeliveryRuleRemoteAddressConditionParameters",
    DeliveryRuleRequestMethodConditionParameters: "DeliveryRuleRequestMethodConditionParameters",
    DeliveryRuleQueryStringConditionParameters: "DeliveryRuleQueryStringConditionParameters",
    DeliveryRulePostArgsConditionParameters: "DeliveryRulePostArgsConditionParameters",
    DeliveryRuleRequestUriConditionParameters: "DeliveryRuleRequestUriConditionParameters",
    DeliveryRuleRequestHeaderConditionParameters: "DeliveryRuleRequestHeaderConditionParameters",
    DeliveryRuleRequestBodyConditionParameters: "DeliveryRuleRequestBodyConditionParameters",
    DeliveryRuleRequestSchemeConditionParameters: "DeliveryRuleRequestSchemeConditionParameters",
    DeliveryRuleUrlPathMatchConditionParameters: "DeliveryRuleUrlPathMatchConditionParameters",
    DeliveryRuleUrlFileExtensionMatchConditionParameters: "DeliveryRuleUrlFileExtensionMatchConditionParameters",
    DeliveryRuleUrlFilenameConditionParameters: "DeliveryRuleUrlFilenameConditionParameters",
    DeliveryRuleHttpVersionConditionParameters: "DeliveryRuleHttpVersionConditionParameters",
    DeliveryRuleCookiesConditionParameters: "DeliveryRuleCookiesConditionParameters",
    DeliveryRuleIsDeviceConditionParameters: "DeliveryRuleIsDeviceConditionParameters",
    DeliveryRuleSocketAddrConditionParameters: "DeliveryRuleSocketAddrConditionParameters",
    DeliveryRuleClientPortConditionParameters: "DeliveryRuleClientPortConditionParameters",
    DeliveryRuleServerPortConditionParameters: "DeliveryRuleServerPortConditionParameters",
    DeliveryRuleHostNameConditionParameters: "DeliveryRuleHostNameConditionParameters",
    DeliveryRuleSslProtocolConditionParameters: "DeliveryRuleSslProtocolConditionParameters",
} as const;

export type DeliveryRuleConditionParametersType = (typeof DeliveryRuleConditionParametersType)[keyof typeof DeliveryRuleConditionParametersType];

export const DestinationProtocol = {
    MatchRequest: "MatchRequest",
    Http: "Http",
    Https: "Https",
} as const;

/**
 * Protocol to use for the redirect. The default value is MatchRequest
 */
export type DestinationProtocol = (typeof DestinationProtocol)[keyof typeof DestinationProtocol];

export const EnabledState = {
    Enabled: "Enabled",
    Disabled: "Disabled",
} as const;

/**
 * Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
 */
export type EnabledState = (typeof EnabledState)[keyof typeof EnabledState];

export const ForwardingProtocol = {
    HttpOnly: "HttpOnly",
    HttpsOnly: "HttpsOnly",
    MatchRequest: "MatchRequest",
} as const;

/**
 * Protocol this rule will use when forwarding traffic to backends.
 */
export type ForwardingProtocol = (typeof ForwardingProtocol)[keyof typeof ForwardingProtocol];

export const GeoFilterActions = {
    Block: "Block",
    Allow: "Allow",
} as const;

/**
 * Action of the geo filter, i.e. allow or block access.
 */
export type GeoFilterActions = (typeof GeoFilterActions)[keyof typeof GeoFilterActions];

export const HeaderAction = {
    Append: "Append",
    Overwrite: "Overwrite",
    Delete: "Delete",
} as const;

/**
 * Action to perform
 */
export type HeaderAction = (typeof HeaderAction)[keyof typeof HeaderAction];

export const HealthProbeRequestType = {
    NotSet: "NotSet",
    GET: "GET",
    HEAD: "HEAD",
} as const;

/**
 * The type of health probe request that is made.
 */
export type HealthProbeRequestType = (typeof HealthProbeRequestType)[keyof typeof HealthProbeRequestType];

export const HostNameOperator = {
    Any: "Any",
    Equal: "Equal",
    Contains: "Contains",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    LessThan: "LessThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThan: "GreaterThan",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type HostNameOperator = (typeof HostNameOperator)[keyof typeof HostNameOperator];

export const HttpVersionOperator = {
    Equal: "Equal",
} as const;

/**
 * Describes operator to be matched
 */
export type HttpVersionOperator = (typeof HttpVersionOperator)[keyof typeof HttpVersionOperator];

export const HttpsRedirect = {
    Enabled: "Enabled",
    Disabled: "Disabled",
} as const;

/**
 * Whether to automatically redirect HTTP traffic to HTTPS traffic. Note that this is a easy way to set up this rule and it will be the first rule that gets executed.
 */
export type HttpsRedirect = (typeof HttpsRedirect)[keyof typeof HttpsRedirect];

export const IsDeviceMatchValue = {
    Mobile: "Mobile",
    Desktop: "Desktop",
} as const;

export type IsDeviceMatchValue = (typeof IsDeviceMatchValue)[keyof typeof IsDeviceMatchValue];

export const IsDeviceOperator = {
    Equal: "Equal",
} as const;

/**
 * Describes operator to be matched
 */
export type IsDeviceOperator = (typeof IsDeviceOperator)[keyof typeof IsDeviceOperator];

export const KeyVaultSigningKeyParametersType = {
    KeyVaultSigningKeyParameters: "KeyVaultSigningKeyParameters",
} as const;

export type KeyVaultSigningKeyParametersType = (typeof KeyVaultSigningKeyParametersType)[keyof typeof KeyVaultSigningKeyParametersType];

export const LinkToDefaultDomain = {
    Enabled: "Enabled",
    Disabled: "Disabled",
} as const;

/**
 * whether this route will be linked to the default endpoint domain.
 */
export type LinkToDefaultDomain = (typeof LinkToDefaultDomain)[keyof typeof LinkToDefaultDomain];

export const ManagedRuleEnabledState = {
    Disabled: "Disabled",
    Enabled: "Enabled",
} as const;

/**
 * Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
 */
export type ManagedRuleEnabledState = (typeof ManagedRuleEnabledState)[keyof typeof ManagedRuleEnabledState];

export const ManagedServiceIdentityType = {
    None: "None",
    SystemAssigned: "SystemAssigned",
    UserAssigned: "UserAssigned",
    SystemAssigned_UserAssigned: "SystemAssigned, UserAssigned",
} as const;

/**
 * Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
 */
export type ManagedServiceIdentityType = (typeof ManagedServiceIdentityType)[keyof typeof ManagedServiceIdentityType];

export const MatchProcessingBehavior = {
    Continue: "Continue",
    Stop: "Stop",
} as const;

/**
 * If this rule is a match should the rules engine continue running the remaining rules or stop. If not present, defaults to Continue.
 */
export type MatchProcessingBehavior = (typeof MatchProcessingBehavior)[keyof typeof MatchProcessingBehavior];

export const MatchVariable = {
    RemoteAddress: "RemoteAddress",
    RequestMethod: "RequestMethod",
    QueryString: "QueryString",
    PostArgs: "PostArgs",
    RequestUri: "RequestUri",
    RequestHeader: "RequestHeader",
    RequestBody: "RequestBody",
    RequestScheme: "RequestScheme",
    UrlPath: "UrlPath",
    UrlFileExtension: "UrlFileExtension",
    UrlFileName: "UrlFileName",
    HttpVersion: "HttpVersion",
    Cookies: "Cookies",
    IsDevice: "IsDevice",
    SocketAddr: "SocketAddr",
    ClientPort: "ClientPort",
    ServerPort: "ServerPort",
    HostName: "HostName",
    SslProtocol: "SslProtocol",
} as const;

/**
 * The name of the condition for the delivery rule.
 */
export type MatchVariable = (typeof MatchVariable)[keyof typeof MatchVariable];

export const Operator = {
    Any: "Any",
    IPMatch: "IPMatch",
    GeoMatch: "GeoMatch",
    Equal: "Equal",
    Contains: "Contains",
    LessThan: "LessThan",
    GreaterThan: "GreaterThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type Operator = (typeof Operator)[keyof typeof Operator];

export const OptimizationType = {
    GeneralWebDelivery: "GeneralWebDelivery",
    GeneralMediaStreaming: "GeneralMediaStreaming",
    VideoOnDemandMediaStreaming: "VideoOnDemandMediaStreaming",
    LargeFileDownload: "LargeFileDownload",
    DynamicSiteAcceleration: "DynamicSiteAcceleration",
} as const;

/**
 * Specifies what scenario the customer wants this CDN endpoint to optimize for, e.g. Download, Media services. With this information, CDN can apply scenario driven optimization.
 */
export type OptimizationType = (typeof OptimizationType)[keyof typeof OptimizationType];

export const ParamIndicator = {
    Expires: "Expires",
    KeyId: "KeyId",
    Signature: "Signature",
} as const;

/**
 * Indicates the purpose of the parameter
 */
export type ParamIndicator = (typeof ParamIndicator)[keyof typeof ParamIndicator];

export const PolicyEnabledState = {
    Disabled: "Disabled",
    Enabled: "Enabled",
} as const;

/**
 * describes if the policy is in enabled state or disabled state
 */
export type PolicyEnabledState = (typeof PolicyEnabledState)[keyof typeof PolicyEnabledState];

export const PolicyMode = {
    Prevention: "Prevention",
    Detection: "Detection",
} as const;

/**
 * Describes if it is in detection mode or prevention mode at policy level.
 */
export type PolicyMode = (typeof PolicyMode)[keyof typeof PolicyMode];

export const PostArgsOperator = {
    Any: "Any",
    Equal: "Equal",
    Contains: "Contains",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    LessThan: "LessThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThan: "GreaterThan",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type PostArgsOperator = (typeof PostArgsOperator)[keyof typeof PostArgsOperator];

export const ProbeProtocol = {
    NotSet: "NotSet",
    Http: "Http",
    Https: "Https",
} as const;

/**
 * Protocol to use for health probe.
 */
export type ProbeProtocol = (typeof ProbeProtocol)[keyof typeof ProbeProtocol];

export const ProfileScrubbingState = {
    Enabled: "Enabled",
    Disabled: "Disabled",
} as const;

/**
 * State of the log scrubbing config. Default value is Enabled.
 */
export type ProfileScrubbingState = (typeof ProfileScrubbingState)[keyof typeof ProfileScrubbingState];

export const QueryStringBehavior = {
    Include: "Include",
    IncludeAll: "IncludeAll",
    Exclude: "Exclude",
    ExcludeAll: "ExcludeAll",
} as const;

/**
 * Caching behavior for the requests
 */
export type QueryStringBehavior = (typeof QueryStringBehavior)[keyof typeof QueryStringBehavior];

export const QueryStringCachingBehavior = {
    IgnoreQueryString: "IgnoreQueryString",
    BypassCaching: "BypassCaching",
    UseQueryString: "UseQueryString",
    NotSet: "NotSet",
} as const;

/**
 * Defines how CDN caches requests that include query strings. You can ignore any query strings when caching, bypass caching to prevent requests that contain query strings from being cached, or cache every request with a unique URL.
 */
export type QueryStringCachingBehavior = (typeof QueryStringCachingBehavior)[keyof typeof QueryStringCachingBehavior];

export const QueryStringOperator = {
    Any: "Any",
    Equal: "Equal",
    Contains: "Contains",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    LessThan: "LessThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThan: "GreaterThan",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type QueryStringOperator = (typeof QueryStringOperator)[keyof typeof QueryStringOperator];

export const RedirectType = {
    Moved: "Moved",
    Found: "Found",
    TemporaryRedirect: "TemporaryRedirect",
    PermanentRedirect: "PermanentRedirect",
} as const;

/**
 * The redirect type the rule will use when redirecting traffic.
 */
export type RedirectType = (typeof RedirectType)[keyof typeof RedirectType];

export const RemoteAddressOperator = {
    Any: "Any",
    IPMatch: "IPMatch",
    GeoMatch: "GeoMatch",
} as const;

/**
 * Describes operator to be matched
 */
export type RemoteAddressOperator = (typeof RemoteAddressOperator)[keyof typeof RemoteAddressOperator];

export const RequestBodyOperator = {
    Any: "Any",
    Equal: "Equal",
    Contains: "Contains",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    LessThan: "LessThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThan: "GreaterThan",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type RequestBodyOperator = (typeof RequestBodyOperator)[keyof typeof RequestBodyOperator];

export const RequestHeaderOperator = {
    Any: "Any",
    Equal: "Equal",
    Contains: "Contains",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    LessThan: "LessThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThan: "GreaterThan",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type RequestHeaderOperator = (typeof RequestHeaderOperator)[keyof typeof RequestHeaderOperator];

export const RequestMethodMatchValue = {
    GET: "GET",
    HEAD: "HEAD",
    POST: "POST",
    PUT: "PUT",
    DELETE: "DELETE",
    OPTIONS: "OPTIONS",
    TRACE: "TRACE",
} as const;

export type RequestMethodMatchValue = (typeof RequestMethodMatchValue)[keyof typeof RequestMethodMatchValue];

export const RequestMethodOperator = {
    Equal: "Equal",
} as const;

/**
 * Describes operator to be matched
 */
export type RequestMethodOperator = (typeof RequestMethodOperator)[keyof typeof RequestMethodOperator];

export const RequestSchemeMatchValue = {
    HTTP: "HTTP",
    HTTPS: "HTTPS",
} as const;

export type RequestSchemeMatchValue = (typeof RequestSchemeMatchValue)[keyof typeof RequestSchemeMatchValue];

export const RequestUriOperator = {
    Any: "Any",
    Equal: "Equal",
    Contains: "Contains",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    LessThan: "LessThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThan: "GreaterThan",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type RequestUriOperator = (typeof RequestUriOperator)[keyof typeof RequestUriOperator];

export const ResponseBasedDetectedErrorTypes = {
    None: "None",
    TcpErrorsOnly: "TcpErrorsOnly",
    TcpAndHttpErrors: "TcpAndHttpErrors",
} as const;

/**
 * Type of response errors for real user requests for which origin will be deemed unhealthy
 */
export type ResponseBasedDetectedErrorTypes = (typeof ResponseBasedDetectedErrorTypes)[keyof typeof ResponseBasedDetectedErrorTypes];

export const RuleCacheBehavior = {
    HonorOrigin: "HonorOrigin",
    OverrideAlways: "OverrideAlways",
    OverrideIfOriginMissing: "OverrideIfOriginMissing",
} as const;

/**
 * Caching behavior for the requests
 */
export type RuleCacheBehavior = (typeof RuleCacheBehavior)[keyof typeof RuleCacheBehavior];

export const RuleIsCompressionEnabled = {
    Enabled: "Enabled",
    Disabled: "Disabled",
} as const;

/**
 * Indicates whether content compression is enabled. If compression is enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when requested content is smaller than 1 byte or larger than 1 MB.
 */
export type RuleIsCompressionEnabled = (typeof RuleIsCompressionEnabled)[keyof typeof RuleIsCompressionEnabled];

export const RuleQueryStringCachingBehavior = {
    IgnoreQueryString: "IgnoreQueryString",
    UseQueryString: "UseQueryString",
    IgnoreSpecifiedQueryStrings: "IgnoreSpecifiedQueryStrings",
    IncludeSpecifiedQueryStrings: "IncludeSpecifiedQueryStrings",
} as const;

/**
 * Defines how Frontdoor caches requests that include query strings. You can ignore any query strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query strings.
 */
export type RuleQueryStringCachingBehavior = (typeof RuleQueryStringCachingBehavior)[keyof typeof RuleQueryStringCachingBehavior];

export const ScrubbingRuleEntryMatchOperator = {
    EqualsAny: "EqualsAny",
} as const;

/**
 * When matchVariable is a collection, operate on the selector to specify which elements in the collection this rule applies to.
 */
export type ScrubbingRuleEntryMatchOperator = (typeof ScrubbingRuleEntryMatchOperator)[keyof typeof ScrubbingRuleEntryMatchOperator];

export const ScrubbingRuleEntryMatchVariable = {
    RequestIPAddress: "RequestIPAddress",
    RequestUri: "RequestUri",
    QueryStringArgNames: "QueryStringArgNames",
} as const;

/**
 * The variable to be scrubbed from the logs.
 */
export type ScrubbingRuleEntryMatchVariable = (typeof ScrubbingRuleEntryMatchVariable)[keyof typeof ScrubbingRuleEntryMatchVariable];

export const ScrubbingRuleEntryState = {
    Enabled: "Enabled",
    Disabled: "Disabled",
} as const;

/**
 * Defines the state of a log scrubbing rule. Default value is enabled.
 */
export type ScrubbingRuleEntryState = (typeof ScrubbingRuleEntryState)[keyof typeof ScrubbingRuleEntryState];

export const SecretType = {
    UrlSigningKey: "UrlSigningKey",
    CustomerCertificate: "CustomerCertificate",
    ManagedCertificate: "ManagedCertificate",
    AzureFirstPartyManagedCertificate: "AzureFirstPartyManagedCertificate",
} as const;

/**
 * The type of the secret resource.
 */
export type SecretType = (typeof SecretType)[keyof typeof SecretType];

export const SecurityPolicyType = {
    WebApplicationFirewall: "WebApplicationFirewall",
} as const;

/**
 * The type of the Security policy to create.
 */
export type SecurityPolicyType = (typeof SecurityPolicyType)[keyof typeof SecurityPolicyType];

export const ServerPortOperator = {
    Any: "Any",
    Equal: "Equal",
    Contains: "Contains",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    LessThan: "LessThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThan: "GreaterThan",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type ServerPortOperator = (typeof ServerPortOperator)[keyof typeof ServerPortOperator];

export const SharedPrivateLinkResourceStatus = {
    Pending: "Pending",
    Approved: "Approved",
    Rejected: "Rejected",
    Disconnected: "Disconnected",
    Timeout: "Timeout",
} as const;

/**
 * Status of the shared private link resource. Can be Pending, Approved, Rejected, Disconnected, or Timeout.
 */
export type SharedPrivateLinkResourceStatus = (typeof SharedPrivateLinkResourceStatus)[keyof typeof SharedPrivateLinkResourceStatus];

export const SkuName = {
    Standard_Verizon: "Standard_Verizon",
    Premium_Verizon: "Premium_Verizon",
    Custom_Verizon: "Custom_Verizon",
    Standard_Akamai: "Standard_Akamai",
    Standard_ChinaCdn: "Standard_ChinaCdn",
    Standard_Microsoft: "Standard_Microsoft",
    Standard_AzureFrontDoor: "Standard_AzureFrontDoor",
    Premium_AzureFrontDoor: "Premium_AzureFrontDoor",
    Standard_955BandWidth_ChinaCdn: "Standard_955BandWidth_ChinaCdn",
    Standard_AvgBandWidth_ChinaCdn: "Standard_AvgBandWidth_ChinaCdn",
    StandardPlus_ChinaCdn: "StandardPlus_ChinaCdn",
    StandardPlus_955BandWidth_ChinaCdn: "StandardPlus_955BandWidth_ChinaCdn",
    StandardPlus_AvgBandWidth_ChinaCdn: "StandardPlus_AvgBandWidth_ChinaCdn",
} as const;

/**
 * Name of the pricing tier.
 */
export type SkuName = (typeof SkuName)[keyof typeof SkuName];

export const SocketAddrOperator = {
    Any: "Any",
    IPMatch: "IPMatch",
} as const;

/**
 * Describes operator to be matched
 */
export type SocketAddrOperator = (typeof SocketAddrOperator)[keyof typeof SocketAddrOperator];

export const SslProtocol = {
    TLSv1: "TLSv1",
    TLSv1_1: "TLSv1.1",
    TLSv1_2: "TLSv1.2",
} as const;

/**
 * The protocol of an established TLS connection.
 */
export type SslProtocol = (typeof SslProtocol)[keyof typeof SslProtocol];

export const SslProtocolOperator = {
    Equal: "Equal",
} as const;

/**
 * Describes operator to be matched
 */
export type SslProtocolOperator = (typeof SslProtocolOperator)[keyof typeof SslProtocolOperator];

export const Transform = {
    Lowercase: "Lowercase",
    Uppercase: "Uppercase",
    Trim: "Trim",
    UrlDecode: "UrlDecode",
    UrlEncode: "UrlEncode",
    RemoveNulls: "RemoveNulls",
} as const;

/**
 * Describes what transforms are applied before matching
 */
export type Transform = (typeof Transform)[keyof typeof Transform];

export const TransformType = {
    Lowercase: "Lowercase",
    Uppercase: "Uppercase",
    Trim: "Trim",
    UrlDecode: "UrlDecode",
    UrlEncode: "UrlEncode",
    RemoveNulls: "RemoveNulls",
} as const;

/**
 * Describes what transforms were applied before matching.
 */
export type TransformType = (typeof TransformType)[keyof typeof TransformType];

export const TunnelType = {
    HttpConnect: "HttpConnect",
} as const;

/**
 * Protocol this tunnel will use for allowing traffic to backends.
 */
export type TunnelType = (typeof TunnelType)[keyof typeof TunnelType];

export const UrlFileExtensionOperator = {
    Any: "Any",
    Equal: "Equal",
    Contains: "Contains",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    LessThan: "LessThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThan: "GreaterThan",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type UrlFileExtensionOperator = (typeof UrlFileExtensionOperator)[keyof typeof UrlFileExtensionOperator];

export const UrlFileNameOperator = {
    Any: "Any",
    Equal: "Equal",
    Contains: "Contains",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    LessThan: "LessThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThan: "GreaterThan",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type UrlFileNameOperator = (typeof UrlFileNameOperator)[keyof typeof UrlFileNameOperator];

export const UrlPathOperator = {
    Any: "Any",
    Equal: "Equal",
    Contains: "Contains",
    BeginsWith: "BeginsWith",
    EndsWith: "EndsWith",
    LessThan: "LessThan",
    LessThanOrEqual: "LessThanOrEqual",
    GreaterThan: "GreaterThan",
    GreaterThanOrEqual: "GreaterThanOrEqual",
    Wildcard: "Wildcard",
    RegEx: "RegEx",
} as const;

/**
 * Describes operator to be matched
 */
export type UrlPathOperator = (typeof UrlPathOperator)[keyof typeof UrlPathOperator];

export const WafMatchVariable = {
    RemoteAddr: "RemoteAddr",
    SocketAddr: "SocketAddr",
    RequestMethod: "RequestMethod",
    RequestHeader: "RequestHeader",
    RequestUri: "RequestUri",
    QueryString: "QueryString",
    RequestBody: "RequestBody",
    Cookies: "Cookies",
    PostArgs: "PostArgs",
} as const;

/**
 * Match variable to compare against.
 */
export type WafMatchVariable = (typeof WafMatchVariable)[keyof typeof WafMatchVariable];
