// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***


export const AgentDeploymentState = {
    /**
     * The deployment is starting.
     */
    Starting: "Starting",
    /**
     * The deployment started/is operational.
     */
    Running: "Running",
    /**
     * The deployment is being stopped.
     */
    Stopping: "Stopping",
    /**
     * The deployment was stopped.
     */
    Stopped: "Stopped",
    /**
     * The deployment failed.
     */
    Failed: "Failed",
    /**
     * The deployment is being deleted.
     */
    Deleting: "Deleting",
    /**
     * The deployment was deleted.
     */
    Deleted: "Deleted",
    /**
     * The deployment is being updated.
     */
    Updating: "Updating",
} as const;

/**
 * Gets or sets the current operational state of the deployment (and, intrinsically, of the comprising agents).
 */
export type AgentDeploymentState = (typeof AgentDeploymentState)[keyof typeof AgentDeploymentState];

export const AgentDeploymentType = {
    /**
     * The underlying infra is managed by the platform in the deployer's subscription
     */
    Managed: "Managed",
    /**
     * The underlying infra is owned by the platform
     */
    Hosted: "Hosted",
    /**
     * The underlying infra is provisioned by the deployer (BYO)
     */
    Custom: "Custom",
} as const;

/**
 * Gets or sets the type of deployment for the agent.
 */
export type AgentDeploymentType = (typeof AgentDeploymentType)[keyof typeof AgentDeploymentType];

export const AgentProtocol = {
    /**
     * Agent protocol (aka Active)
     */
    Agent: "Agent",
    /**
     * Agent2Agent standard
     */
    A2A: "A2A",
    /**
     * OpenAI-compatible
     */
    Responses: "Responses",
} as const;

/**
 * The protocol used by the agent/exposed by a deployment.
 */
export type AgentProtocol = (typeof AgentProtocol)[keyof typeof AgentProtocol];

export const BuiltInAuthorizationScheme = {
    /**
     * Standard AzureML RBAC
     */
    Default: "Default",
    /**
     * Claim-based, requires membership in the tenant
     */
    OrganizationScope: "OrganizationScope",
    /**
     * Microsoft365-specific (AzureBotService) authorization
     */
    Microsoft365: "Microsoft365",
    /**
     * Custom scheme defined by the application author
     */
    Custom: "Custom",
} as const;

/**
 * Authorization scheme type.
 */
export type BuiltInAuthorizationScheme = (typeof BuiltInAuthorizationScheme)[keyof typeof BuiltInAuthorizationScheme];

export const ByPassSelection = {
    None: "None",
    AzureServices: "AzureServices",
} as const;

/**
 * Setting for trusted services.
 */
export type ByPassSelection = (typeof ByPassSelection)[keyof typeof ByPassSelection];

export const CapabilityHostKind = {
    Agents: "Agents",
} as const;

/**
 * Kind of this capability host.
 */
export type CapabilityHostKind = (typeof CapabilityHostKind)[keyof typeof CapabilityHostKind];

export const ConnectionAuthType = {
    PAT: "PAT",
    ManagedIdentity: "ManagedIdentity",
    UsernamePassword: "UsernamePassword",
    None: "None",
    SAS: "SAS",
    AccountKey: "AccountKey",
    ServicePrincipal: "ServicePrincipal",
    AccessKey: "AccessKey",
    ApiKey: "ApiKey",
    CustomKeys: "CustomKeys",
    OAuth2: "OAuth2",
    AAD: "AAD",
} as const;

/**
 * Authentication type of the connection target
 */
export type ConnectionAuthType = (typeof ConnectionAuthType)[keyof typeof ConnectionAuthType];

export const ConnectionCategory = {
    PythonFeed: "PythonFeed",
    ContainerRegistry: "ContainerRegistry",
    Git: "Git",
    S3: "S3",
    Snowflake: "Snowflake",
    AzureSqlDb: "AzureSqlDb",
    AzureSynapseAnalytics: "AzureSynapseAnalytics",
    AzureMySqlDb: "AzureMySqlDb",
    AzurePostgresDb: "AzurePostgresDb",
    ADLSGen2: "ADLSGen2",
    Redis: "Redis",
    ApiKey: "ApiKey",
    AzureOpenAI: "AzureOpenAI",
    AIServices: "AIServices",
    CognitiveSearch: "CognitiveSearch",
    CognitiveService: "CognitiveService",
    CustomKeys: "CustomKeys",
    AzureBlob: "AzureBlob",
    AzureOneLake: "AzureOneLake",
    CosmosDb: "CosmosDb",
    CosmosDbMongoDbApi: "CosmosDbMongoDbApi",
    AzureDataExplorer: "AzureDataExplorer",
    AzureMariaDb: "AzureMariaDb",
    AzureDatabricksDeltaLake: "AzureDatabricksDeltaLake",
    AzureSqlMi: "AzureSqlMi",
    AzureTableStorage: "AzureTableStorage",
    AmazonRdsForOracle: "AmazonRdsForOracle",
    AmazonRdsForSqlServer: "AmazonRdsForSqlServer",
    AmazonRedshift: "AmazonRedshift",
    Db2: "Db2",
    Drill: "Drill",
    GoogleBigQuery: "GoogleBigQuery",
    Greenplum: "Greenplum",
    Hbase: "Hbase",
    Hive: "Hive",
    Impala: "Impala",
    Informix: "Informix",
    MariaDb: "MariaDb",
    MicrosoftAccess: "MicrosoftAccess",
    MySql: "MySql",
    Netezza: "Netezza",
    Oracle: "Oracle",
    Phoenix: "Phoenix",
    PostgreSql: "PostgreSql",
    Presto: "Presto",
    SapOpenHub: "SapOpenHub",
    SapBw: "SapBw",
    SapHana: "SapHana",
    SapTable: "SapTable",
    Spark: "Spark",
    SqlServer: "SqlServer",
    Sybase: "Sybase",
    Teradata: "Teradata",
    Vertica: "Vertica",
    Pinecone: "Pinecone",
    Cassandra: "Cassandra",
    Couchbase: "Couchbase",
    MongoDbV2: "MongoDbV2",
    MongoDbAtlas: "MongoDbAtlas",
    AmazonS3Compatible: "AmazonS3Compatible",
    FileServer: "FileServer",
    FtpServer: "FtpServer",
    GoogleCloudStorage: "GoogleCloudStorage",
    Hdfs: "Hdfs",
    OracleCloudStorage: "OracleCloudStorage",
    Sftp: "Sftp",
    GenericHttp: "GenericHttp",
    ODataRest: "ODataRest",
    Odbc: "Odbc",
    GenericRest: "GenericRest",
    AmazonMws: "AmazonMws",
    Concur: "Concur",
    Dynamics: "Dynamics",
    DynamicsAx: "DynamicsAx",
    DynamicsCrm: "DynamicsCrm",
    GoogleAdWords: "GoogleAdWords",
    Hubspot: "Hubspot",
    Jira: "Jira",
    Magento: "Magento",
    Marketo: "Marketo",
    Office365: "Office365",
    Eloqua: "Eloqua",
    Responsys: "Responsys",
    OracleServiceCloud: "OracleServiceCloud",
    PayPal: "PayPal",
    QuickBooks: "QuickBooks",
    Salesforce: "Salesforce",
    SalesforceServiceCloud: "SalesforceServiceCloud",
    SalesforceMarketingCloud: "SalesforceMarketingCloud",
    SapCloudForCustomer: "SapCloudForCustomer",
    SapEcc: "SapEcc",
    ServiceNow: "ServiceNow",
    SharePointOnlineList: "SharePointOnlineList",
    Shopify: "Shopify",
    Square: "Square",
    WebTable: "WebTable",
    Xero: "Xero",
    Zoho: "Zoho",
    GenericContainerRegistry: "GenericContainerRegistry",
    Elasticsearch: "Elasticsearch",
    OpenAI: "OpenAI",
    Serp: "Serp",
    BingLLMSearch: "BingLLMSearch",
    Serverless: "Serverless",
    ManagedOnlineEndpoint: "ManagedOnlineEndpoint",
} as const;

/**
 * Category of the connection
 */
export type ConnectionCategory = (typeof ConnectionCategory)[keyof typeof ConnectionCategory];

export const ContentLevel = {
    Low: "Low",
    Medium: "Medium",
    High: "High",
} as const;

/**
 * Level at which content is filtered.
 */
export type ContentLevel = (typeof ContentLevel)[keyof typeof ContentLevel];

export const DeploymentModelVersionUpgradeOption = {
    OnceNewDefaultVersionAvailable: "OnceNewDefaultVersionAvailable",
    OnceCurrentVersionExpired: "OnceCurrentVersionExpired",
    NoAutoUpgrade: "NoAutoUpgrade",
} as const;

/**
 * Deployment model version upgrade option.
 */
export type DeploymentModelVersionUpgradeOption = (typeof DeploymentModelVersionUpgradeOption)[keyof typeof DeploymentModelVersionUpgradeOption];

export const DeploymentScaleType = {
    Standard: "Standard",
    Manual: "Manual",
} as const;

/**
 * Deployment scale type.
 */
export type DeploymentScaleType = (typeof DeploymentScaleType)[keyof typeof DeploymentScaleType];

export const EncryptionScopeState = {
    Disabled: "Disabled",
    Enabled: "Enabled",
} as const;

/**
 * The encryptionScope state.
 */
export type EncryptionScopeState = (typeof EncryptionScopeState)[keyof typeof EncryptionScopeState];

export const HostingModel = {
    Web: "Web",
    ConnectedContainer: "ConnectedContainer",
    DisconnectedContainer: "DisconnectedContainer",
    ProvisionedWeb: "ProvisionedWeb",
} as const;

/**
 * Account hosting model.
 */
export type HostingModel = (typeof HostingModel)[keyof typeof HostingModel];

export const IdentityKind = {
    /**
     * Represents a class identity, used for agentic applications.
     */
    AgentBlueprint: "AgentBlueprint",
    /**
     * Represents an instance identity.
     */
    AgentInstance: "AgentInstance",
    /**
     * Represents an agentic instance identity with user-like traits.
     */
    AgenticUser: "AgenticUser",
    /**
     * Represents a classic managed identity.
     */
    Managed: "Managed",
    /**
     * No identity.
     */
    None: "None",
} as const;

/**
 * Specifies the kind of Entra identity described by this object.
 */
export type IdentityKind = (typeof IdentityKind)[keyof typeof IdentityKind];

export const IdentityManagementType = {
    /**
     * Platform-managed identity.
     */
    System: "System",
    /**
     * User-managed identity.
     */
    User: "User",
    /**
     * No identity.
     */
    None: "None",
} as const;

/**
 * Enumeration of identity types, from the perspective of management.
 */
export type IdentityManagementType = (typeof IdentityManagementType)[keyof typeof IdentityManagementType];

export const KeySource = {
    Microsoft_CognitiveServices: "Microsoft.CognitiveServices",
    Microsoft_KeyVault: "Microsoft.KeyVault",
} as const;

/**
 * Enumerates the possible value of keySource for Encryption
 */
export type KeySource = (typeof KeySource)[keyof typeof KeySource];

export const ManagedPERequirement = {
    Required: "Required",
    NotRequired: "NotRequired",
    NotApplicable: "NotApplicable",
} as const;

export type ManagedPERequirement = (typeof ManagedPERequirement)[keyof typeof ManagedPERequirement];

export const ManagedPEStatus = {
    Inactive: "Inactive",
    Active: "Active",
    NotApplicable: "NotApplicable",
} as const;

export type ManagedPEStatus = (typeof ManagedPEStatus)[keyof typeof ManagedPEStatus];

export const NetworkRuleAction = {
    Allow: "Allow",
    Deny: "Deny",
} as const;

/**
 * The default action when no rule from ipRules and from virtualNetworkRules match. This is only used after the bypass property has been evaluated.
 */
export type NetworkRuleAction = (typeof NetworkRuleAction)[keyof typeof NetworkRuleAction];

export const PrivateEndpointServiceConnectionStatus = {
    Pending: "Pending",
    Approved: "Approved",
    Rejected: "Rejected",
} as const;

/**
 * Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
 */
export type PrivateEndpointServiceConnectionStatus = (typeof PrivateEndpointServiceConnectionStatus)[keyof typeof PrivateEndpointServiceConnectionStatus];

export const PublicNetworkAccess = {
    Enabled: "Enabled",
    Disabled: "Disabled",
} as const;

/**
 * Whether or not public endpoint access is allowed for this account.
 */
export type PublicNetworkAccess = (typeof PublicNetworkAccess)[keyof typeof PublicNetworkAccess];

export const RaiActionType = {
    None: "None",
    BLOCKING: "BLOCKING",
    ANNOTATING: "ANNOTATING",
    HITL: "HITL",
    RETRY: "RETRY",
} as const;

/**
 * The action types to apply to the content filters
 */
export type RaiActionType = (typeof RaiActionType)[keyof typeof RaiActionType];

export const RaiPolicyContentSource = {
    Prompt: "Prompt",
    Completion: "Completion",
    PreToolCall: "PreToolCall",
    PostToolCall: "PostToolCall",
    PreRun: "PreRun",
    PostRun: "PostRun",
} as const;

/**
 * Content source to apply the Content Filters.
 */
export type RaiPolicyContentSource = (typeof RaiPolicyContentSource)[keyof typeof RaiPolicyContentSource];

export const RaiPolicyMode = {
    Default: "Default",
    Deferred: "Deferred",
    Blocking: "Blocking",
    Asynchronous_filter: "Asynchronous_filter",
} as const;

/**
 * Rai policy mode. The enum value mapping is as below: Default = 0, Deferred=1, Blocking=2, Asynchronous_filter =3. Please use 'Asynchronous_filter' after 2025-06-01. It is the same as 'Deferred' in previous version.
 */
export type RaiPolicyMode = (typeof RaiPolicyMode)[keyof typeof RaiPolicyMode];

export const ResourceIdentityType = {
    None: "None",
    SystemAssigned: "SystemAssigned",
    UserAssigned: "UserAssigned",
    SystemAssigned_UserAssigned: "SystemAssigned, UserAssigned",
} as const;

/**
 * The identity type.
 */
export type ResourceIdentityType = (typeof ResourceIdentityType)[keyof typeof ResourceIdentityType];

export const RoutingMethods = {
    Priority: "Priority",
    Weighted: "Weighted",
    Performance: "Performance",
} as const;

/**
 * Multiregion routing methods.
 */
export type RoutingMethods = (typeof RoutingMethods)[keyof typeof RoutingMethods];

export const RuleCategory = {
    Required: "Required",
    Recommended: "Recommended",
    UserDefined: "UserDefined",
    Dependency: "Dependency",
} as const;

/**
 * Category of a managed network Outbound Rule of a cognitive services account.
 */
export type RuleCategory = (typeof RuleCategory)[keyof typeof RuleCategory];

export const RuleStatus = {
    Inactive: "Inactive",
    Active: "Active",
    Provisioning: "Provisioning",
    Deleting: "Deleting",
    Failed: "Failed",
} as const;

/**
 * Type of a managed network Outbound Rule of a cognitive services account.
 */
export type RuleStatus = (typeof RuleStatus)[keyof typeof RuleStatus];

export const RuleType = {
    FQDN: "FQDN",
    PrivateEndpoint: "PrivateEndpoint",
    ServiceTag: "ServiceTag",
} as const;

/**
 * Type of a managed network Outbound Rule of a cognitive services account.
 */
export type RuleType = (typeof RuleType)[keyof typeof RuleType];

export const SkuTier = {
    Free: "Free",
    Basic: "Basic",
    Standard: "Standard",
    Premium: "Premium",
    Enterprise: "Enterprise",
} as const;

/**
 * This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
 */
export type SkuTier = (typeof SkuTier)[keyof typeof SkuTier];

export const TrafficRoutingProtocol = {
    /**
     * Percentage based routing
     */
    FixedRatio: "FixedRatio",
} as const;

/**
 * Methodology used to route traffic to the application's deployments.
 */
export type TrafficRoutingProtocol = (typeof TrafficRoutingProtocol)[keyof typeof TrafficRoutingProtocol];
