// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***


export const ApplicationGroupType = {
    /**
     * Application group is Remote and can launch individual applications without a Desktop.
     */
    RemoteApp: "RemoteApp",
    /**
     * Application Group delivers a full expected Desktop experience
     */
    Desktop: "Desktop",
} as const;

/**
 * Resource Type of ApplicationGroup.
 */
export type ApplicationGroupType = (typeof ApplicationGroupType)[keyof typeof ApplicationGroupType];

export const CommandLineSetting = {
    /**
     * Cannot be launched with command line arguments.
     */
    DoNotAllow: "DoNotAllow",
    /**
     * Can optionally be launched with command line arguments.
     */
    Allow: "Allow",
    /**
     * Required to be launched with command line arguments.
     */
    Require: "Require",
} as const;

/**
 * Specifies whether this published application can be launched with command line arguments provided by the client, command line arguments specified at publish time, or no command line arguments at all.
 */
export type CommandLineSetting = (typeof CommandLineSetting)[keyof typeof CommandLineSetting];

export const DayOfWeek = {
    Monday: "Monday",
    Tuesday: "Tuesday",
    Wednesday: "Wednesday",
    Thursday: "Thursday",
    Friday: "Friday",
    Saturday: "Saturday",
    Sunday: "Sunday",
} as const;

/**
 * Day of the week. Modeled as string
 */
export type DayOfWeek = (typeof DayOfWeek)[keyof typeof DayOfWeek];

export const DirectUDP = {
    /**
     * AVD-wide settings are used to determine connection availability
     */
    Default: "Default",
    /**
     * UDP will attempt this connection type when making connections.
     */
    Enabled: "Enabled",
    /**
     * UDP will not attempt this connection type when making connections
     */
    Disabled: "Disabled",
} as const;

/**
 * Default: AVD-wide settings are used to determine connection availability, Enabled: UDP will attempt this connection type when making connections. This means that this connection is possible, but is not guaranteed, as there are other factors that may prevent this connection type, Disabled: UDP will not attempt this connection type when making connections
 */
export type DirectUDP = (typeof DirectUDP)[keyof typeof DirectUDP];

export const FailHealthCheckOnStagingFailure = {
    /**
     * Health Check will report unhealthy
     */
    Unhealthy: "Unhealthy",
    /**
     * Health Check will report NeedsAssistance
     */
    NeedsAssistance: "NeedsAssistance",
    /**
     * Health Check will not report failure
     */
    DoNotFail: "DoNotFail",
} as const;

/**
 * Parameter indicating how the health check should behave if this package fails staging
 */
export type FailHealthCheckOnStagingFailure = (typeof FailHealthCheckOnStagingFailure)[keyof typeof FailHealthCheckOnStagingFailure];

export const HostPoolType = {
    /**
     * Users will be assigned a SessionHost either by administrators (PersonalDesktopAssignmentType = Direct) or upon connecting to the pool (PersonalDesktopAssignmentType = Automatic). They will always be redirected to their assigned SessionHost.
     */
    Personal: "Personal",
    /**
     * Users get a new (random) SessionHost every time it connects to the HostPool.
     */
    Pooled: "Pooled",
    /**
     * Users assign their own machines, load balancing logic remains the same as Personal. PersonalDesktopAssignmentType must be Direct.
     */
    BYODesktop: "BYODesktop",
} as const;

/**
 * HostPool type for desktop.
 */
export type HostPoolType = (typeof HostPoolType)[keyof typeof HostPoolType];

export const HostpoolPublicNetworkAccess = {
    /**
     * Allows this resource to be accessed from the public network
     */
    Enabled: "Enabled",
    /**
     * Prevents this resource from being accessed from the public network
     */
    Disabled: "Disabled",
    /**
     * Allows SessionHosts to be accessed from the public network
     */
    EnabledForSessionHostsOnly: "EnabledForSessionHostsOnly",
    /**
     * Allows Clients to be accessed from the public network
     */
    EnabledForClientsOnly: "EnabledForClientsOnly",
} as const;

/**
 * Enabled allows this resource to be accessed from both public and private networks, Disabled allows this resource to only be accessed via private endpoints
 */
export type HostpoolPublicNetworkAccess = (typeof HostpoolPublicNetworkAccess)[keyof typeof HostpoolPublicNetworkAccess];

export const LoadBalancerType = {
    /**
     * Uses BreadthFirst algorithm for load balancing.
     */
    BreadthFirst: "BreadthFirst",
    /**
     * Uses DepthFirst algorithm for load balancing.
     */
    DepthFirst: "DepthFirst",
    /**
     * Maintains persistent connections.
     */
    Persistent: "Persistent",
    /**
     * Maintains multiple persistents connections.
     */
    MultiplePersistent: "MultiplePersistent",
} as const;

/**
 * The type of the load balancer.
 */
export type LoadBalancerType = (typeof LoadBalancerType)[keyof typeof LoadBalancerType];

export const ManagedPrivateUDP = {
    /**
     * AVD-wide settings are used to determine connection availability
     */
    Default: "Default",
    /**
     * UDP will attempt this connection type when making connections.
     */
    Enabled: "Enabled",
    /**
     * UDP will not attempt this connection type when making connections
     */
    Disabled: "Disabled",
} as const;

/**
 * Default: AVD-wide settings are used to determine connection availability, Enabled: UDP will attempt this connection type when making connections. This means that this connection is possible, but is not guaranteed, as there are other factors that may prevent this connection type, Disabled: UDP will not attempt this connection type when making connections
 */
export type ManagedPrivateUDP = (typeof ManagedPrivateUDP)[keyof typeof ManagedPrivateUDP];

export const ManagedServiceIdentityType = {
    None: "None",
    SystemAssigned: "SystemAssigned",
    UserAssigned: "UserAssigned",
    SystemAssigned_UserAssigned: "SystemAssigned,UserAssigned",
} as const;

/**
 * Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
 */
export type ManagedServiceIdentityType = (typeof ManagedServiceIdentityType)[keyof typeof ManagedServiceIdentityType];

export const ManagementType = {
    /**
     * Automated management of the hostpool
     */
    Automated: "Automated",
    /**
     * Standard management of the hostpool
     */
    Standard: "Standard",
} as const;

/**
 * The type of management for this hostpool, Automated or Standard. The default value is Automated.
 */
export type ManagementType = (typeof ManagementType)[keyof typeof ManagementType];

export const PackageTimestamped = {
    /**
     * Package is timestamped
     */
    Timestamped: "Timestamped",
    /**
     * Package is not timestamped, use certificate expiry date
     */
    NotTimestamped: "NotTimestamped",
} as const;

/**
 * Is package timestamped so it can ignore the certificate expiry date
 */
export type PackageTimestamped = (typeof PackageTimestamped)[keyof typeof PackageTimestamped];

export const PersonalDesktopAssignmentType = {
    /**
     * Automatically assigns an available personal desktop to the user.
     */
    Automatic: "Automatic",
    /**
     * Manually assigns a specific personal desktop to the user.
     */
    Direct: "Direct",
} as const;

/**
 * PersonalDesktopAssignment type for HostPool.
 */
export type PersonalDesktopAssignmentType = (typeof PersonalDesktopAssignmentType)[keyof typeof PersonalDesktopAssignmentType];

export const PreferredAppGroupType = {
    /**
     * Internal Use Only
     */
    None: "None",
    /**
     * Use Desktop Application Group
     */
    Desktop: "Desktop",
    /**
     * Use RailApplications (RemoteApp)
     */
    RailApplications: "RailApplications",
} as const;

/**
 * The type of preferred application group type, default to Desktop Application Group
 */
export type PreferredAppGroupType = (typeof PreferredAppGroupType)[keyof typeof PreferredAppGroupType];

export const PrivateEndpointServiceConnectionStatus = {
    /**
     * Connection is Pending
     */
    Pending: "Pending",
    /**
     * Connection was Approved
     */
    Approved: "Approved",
    /**
     * Connection was rejected
     */
    Rejected: "Rejected",
} as const;

/**
 * Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
 */
export type PrivateEndpointServiceConnectionStatus = (typeof PrivateEndpointServiceConnectionStatus)[keyof typeof PrivateEndpointServiceConnectionStatus];

export const PublicNetworkAccess = {
    /**
     * This resource is accessible from the public network.
     */
    Enabled: "Enabled",
    /**
     * This resource is not accessible from the public network.
     */
    Disabled: "Disabled",
} as const;

/**
 * Enabled allows this resource to be accessed from both public and private networks, Disabled allows this resource to only be accessed via private endpoints
 */
export type PublicNetworkAccess = (typeof PublicNetworkAccess)[keyof typeof PublicNetworkAccess];

export const PublicUDP = {
    /**
     * AVD-wide settings are used to determine connection availability
     */
    Default: "Default",
    /**
     * UDP will attempt this connection type when making connections.
     */
    Enabled: "Enabled",
    /**
     * UDP will not attempt this connection type when making connections
     */
    Disabled: "Disabled",
} as const;

/**
 * Default: AVD-wide settings are used to determine connection availability, Enabled: UDP will attempt this connection type when making connections. This means that this connection is possible, but is not guaranteed, as there are other factors that may prevent this connection type, Disabled: UDP will not attempt this connection type when making connections
 */
export type PublicUDP = (typeof PublicUDP)[keyof typeof PublicUDP];

export const RegistrationTokenOperation = {
    /**
     * Delete operation
     */
    Delete: "Delete",
    /**
     * No Operation
     */
    None: "None",
    /**
     * Update Operation
     */
    Update: "Update",
} as const;

/**
 * The type of resetting the token.
 */
export type RegistrationTokenOperation = (typeof RegistrationTokenOperation)[keyof typeof RegistrationTokenOperation];

export const RelayUDP = {
    /**
     * AVD-wide settings are used to determine connection availability
     */
    Default: "Default",
    /**
     * UDP will attempt this connection type when making connections.
     */
    Enabled: "Enabled",
    /**
     * UDP will not attempt this connection type when making connections
     */
    Disabled: "Disabled",
} as const;

/**
 * Default: AVD-wide settings are used to determine connection availability, Enabled: UDP will attempt this connection type when making connections. This means that this connection is possible, but is not guaranteed, as there are other factors that may prevent this connection type, Disabled: UDP will not attempt this connection type when making connections
 */
export type RelayUDP = (typeof RelayUDP)[keyof typeof RelayUDP];

export const RemoteApplicationType = {
    /**
     * Built-in applications
     */
    InBuilt: "InBuilt",
    /**
     * Imported MSIX application packages
     */
    MsixApplication: "MsixApplication",
} as const;

/**
 * Resource Type of Application.
 */
export type RemoteApplicationType = (typeof RemoteApplicationType)[keyof typeof RemoteApplicationType];

export const SSOSecretType = {
    /**
     * The SSO Secret is a Shared Key.
     */
    SharedKey: "SharedKey",
    /**
     * The SSO Secret is a Certificate.
     */
    Certificate: "Certificate",
    /**
     * The SSO Secret is a SharedKey that is stored in KeyVault.
     */
    SharedKeyInKeyVault: "SharedKeyInKeyVault",
    /**
     * The SSO Secret is a Certificate that is stored in KeyVault.
     */
    CertificateInKeyVault: "CertificateInKeyVault",
} as const;

/**
 * The type of single sign on Secret Type.
 */
export type SSOSecretType = (typeof SSOSecretType)[keyof typeof SSOSecretType];

export const ScalingHostPoolType = {
    /**
     * Users get a new (random) SessionHost every time it connects to the HostPool.
     */
    Pooled: "Pooled",
    /**
     * Users will be assigned a SessionHost either by administrators (PersonalDesktopAssignmentType = Direct) or upon connecting to the pool (PersonalDesktopAssignmentType = Automatic). They will always be redirected to their assigned SessionHost.
     */
    Personal: "Personal",
} as const;

/**
 * HostPool type for desktop.
 */
export type ScalingHostPoolType = (typeof ScalingHostPoolType)[keyof typeof ScalingHostPoolType];

export const SessionHandlingOperation = {
    /**
     * No action will be taken after disconnect
     */
    None: "None",
    /**
     * Session Host will be deallocated after disconnect
     */
    Deallocate: "Deallocate",
    /**
     * Session Host will hibernate after disconnect
     */
    Hibernate: "Hibernate",
} as const;

/**
 * Action to be taken after a logoff during the ramp up period.
 */
export type SessionHandlingOperation = (typeof SessionHandlingOperation)[keyof typeof SessionHandlingOperation];

export const SessionHostComponentUpdateType = {
    /**
     * Agent and other agent side components are delivery schedule is controlled by WVD Infra.
     */
    Default: "Default",
    /**
     * TenantAdmin have opted in for Scheduled Component Update feature.
     */
    Scheduled: "Scheduled",
} as const;

/**
 * The type of maintenance for session host components.
 */
export type SessionHostComponentUpdateType = (typeof SessionHostComponentUpdateType)[keyof typeof SessionHostComponentUpdateType];

export const SessionHostLoadBalancingAlgorithm = {
    /**
     * Breadth First Algorithm for Load Balancing
     */
    BreadthFirst: "BreadthFirst",
    /**
     * Depth First Algorithm for Load Balancing
     */
    DepthFirst: "DepthFirst",
} as const;

/**
 * Load balancing algorithm for ramp up period.
 */
export type SessionHostLoadBalancingAlgorithm = (typeof SessionHostLoadBalancingAlgorithm)[keyof typeof SessionHostLoadBalancingAlgorithm];

export const SetStartVMOnConnect = {
    /**
     * Start VM on Connect is enabled
     */
    Enable: "Enable",
    /**
     * Start VM on Connect is disabled, must use rampUpAutoStartHosts or turn on manually
     */
    Disable: "Disable",
} as const;

/**
 * The desired configuration of Start VM On Connect for the hostpool during the ramp up phase. If this is disabled, session hosts must be turned on using rampUpAutoStartHosts or by turning them on manually.
 */
export type SetStartVMOnConnect = (typeof SetStartVMOnConnect)[keyof typeof SetStartVMOnConnect];

export const SkuTier = {
    Free: "Free",
    Basic: "Basic",
    Standard: "Standard",
    Premium: "Premium",
} as const;

/**
 * This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
 */
export type SkuTier = (typeof SkuTier)[keyof typeof SkuTier];

export const StartupBehavior = {
    /**
     * Session hosts will not be started by the service. This setting depends on Start VM on Connect to be enabled to start the session hosts.
     */
    None: "None",
    /**
     * Session hosts with an assigned user will be started during Ramp Up
     */
    WithAssignedUser: "WithAssignedUser",
    /**
     * All personal session hosts in the hostpool will be started during ramp up.
     */
    All: "All",
} as const;

/**
 * The desired startup behavior during the ramp up period for personal vms in the hostpool.
 */
export type StartupBehavior = (typeof StartupBehavior)[keyof typeof StartupBehavior];

export const StopHostsWhen = {
    /**
     * Zero Total Sessions
     */
    ZeroSessions: "ZeroSessions",
    /**
     * Zero Active Sessions
     */
    ZeroActiveSessions: "ZeroActiveSessions",
} as const;

/**
 * Specifies when to stop hosts during ramp down period.
 */
export type StopHostsWhen = (typeof StopHostsWhen)[keyof typeof StopHostsWhen];
