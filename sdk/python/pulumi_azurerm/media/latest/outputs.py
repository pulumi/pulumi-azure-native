# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Dict, List, Mapping, Optional, Tuple, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'AccountEncryptionResponse',
    'AkamaiAccessControlResponse',
    'AkamaiSignatureHeaderAuthenticationKeyResponse',
    'AssetStreamingLocatorResponseResult',
    'CbcsDrmConfigurationResponse',
    'CencDrmConfigurationResponse',
    'CommonEncryptionCbcsResponse',
    'CommonEncryptionCencResponse',
    'ContentKeyPolicyConfigurationResponse',
    'ContentKeyPolicyOptionResponse',
    'ContentKeyPolicyRestrictionResponse',
    'CrossSiteAccessPoliciesResponse',
    'DefaultKeyResponse',
    'EdgeUsageDataCollectionPolicyResponseResult',
    'EdgeUsageDataEventHubResponseResult',
    'EnabledProtocolsResponse',
    'EnvelopeEncryptionResponse',
    'FilterTrackPropertyConditionResponse',
    'FilterTrackSelectionResponse',
    'FirstQualityResponse',
    'HlsResponse',
    'IPAccessControlResponse',
    'IPRangeResponse',
    'JobErrorDetailResponse',
    'JobErrorResponse',
    'JobInputResponse',
    'JobOutputResponse',
    'KeyVaultPropertiesResponse',
    'LiveEventEncodingResponse',
    'LiveEventEndpointResponse',
    'LiveEventInputAccessControlResponse',
    'LiveEventInputResponse',
    'LiveEventPreviewAccessControlResponse',
    'LiveEventPreviewResponse',
    'MediaServiceIdentityResponse',
    'NoEncryptionResponse',
    'PresentationTimeRangeResponse',
    'PresetResponse',
    'PrivateEndpointResponse',
    'PrivateLinkServiceConnectionStateResponse',
    'StorageAccountResponse',
    'StreamingEndpointAccessControlResponse',
    'StreamingLocatorContentKeyResponse',
    'StreamingPathResponseResult',
    'StreamingPolicyContentKeyResponse',
    'StreamingPolicyContentKeysResponse',
    'StreamingPolicyFairPlayConfigurationResponse',
    'StreamingPolicyPlayReadyConfigurationResponse',
    'StreamingPolicyWidevineConfigurationResponse',
    'TrackPropertyConditionResponse',
    'TrackSelectionResponse',
    'TransformOutputResponse',
]

@pulumi.output_type
class AccountEncryptionResponse(dict):
    def __init__(__self__, *,
                 type: str,
                 key_vault_properties: Optional['outputs.KeyVaultPropertiesResponse'] = None):
        """
        :param str type: The type of key used to encrypt the Account Key.
        :param 'KeyVaultPropertiesResponseArgs' key_vault_properties: The properties of the key used to encrypt the account.
        """
        pulumi.set(__self__, "type", type)
        if key_vault_properties is not None:
            pulumi.set(__self__, "key_vault_properties", key_vault_properties)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of key used to encrypt the Account Key.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="keyVaultProperties")
    def key_vault_properties(self) -> Optional['outputs.KeyVaultPropertiesResponse']:
        """
        The properties of the key used to encrypt the account.
        """
        return pulumi.get(self, "key_vault_properties")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AkamaiAccessControlResponse(dict):
    """
    Akamai access control
    """
    def __init__(__self__, *,
                 akamai_signature_header_authentication_key_list: Optional[List['outputs.AkamaiSignatureHeaderAuthenticationKeyResponse']] = None):
        """
        Akamai access control
        :param List['AkamaiSignatureHeaderAuthenticationKeyResponseArgs'] akamai_signature_header_authentication_key_list: authentication key list
        """
        if akamai_signature_header_authentication_key_list is not None:
            pulumi.set(__self__, "akamai_signature_header_authentication_key_list", akamai_signature_header_authentication_key_list)

    @property
    @pulumi.getter(name="akamaiSignatureHeaderAuthenticationKeyList")
    def akamai_signature_header_authentication_key_list(self) -> Optional[List['outputs.AkamaiSignatureHeaderAuthenticationKeyResponse']]:
        """
        authentication key list
        """
        return pulumi.get(self, "akamai_signature_header_authentication_key_list")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AkamaiSignatureHeaderAuthenticationKeyResponse(dict):
    """
    Akamai Signature Header authentication key.
    """
    def __init__(__self__, *,
                 base64_key: Optional[str] = None,
                 expiration: Optional[str] = None,
                 identifier: Optional[str] = None):
        """
        Akamai Signature Header authentication key.
        :param str base64_key: authentication key
        :param str expiration: The expiration time of the authentication key.
        :param str identifier: identifier of the key
        """
        if base64_key is not None:
            pulumi.set(__self__, "base64_key", base64_key)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter(name="base64Key")
    def base64_key(self) -> Optional[str]:
        """
        authentication key
        """
        return pulumi.get(self, "base64_key")

    @property
    @pulumi.getter
    def expiration(self) -> Optional[str]:
        """
        The expiration time of the authentication key.
        """
        return pulumi.get(self, "expiration")

    @property
    @pulumi.getter
    def identifier(self) -> Optional[str]:
        """
        identifier of the key
        """
        return pulumi.get(self, "identifier")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AssetStreamingLocatorResponseResult(dict):
    """
    Properties of the Streaming Locator.
    """
    def __init__(__self__, *,
                 asset_name: str,
                 created: str,
                 default_content_key_policy_name: str,
                 end_time: str,
                 name: str,
                 start_time: str,
                 streaming_locator_id: str,
                 streaming_policy_name: str):
        """
        Properties of the Streaming Locator.
        :param str asset_name: Asset Name.
        :param str created: The creation time of the Streaming Locator.
        :param str default_content_key_policy_name: Name of the default ContentKeyPolicy used by this Streaming Locator.
        :param str end_time: The end time of the Streaming Locator.
        :param str name: Streaming Locator name.
        :param str start_time: The start time of the Streaming Locator.
        :param str streaming_locator_id: StreamingLocatorId of the Streaming Locator.
        :param str streaming_policy_name: Name of the Streaming Policy used by this Streaming Locator.
        """
        pulumi.set(__self__, "asset_name", asset_name)
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "default_content_key_policy_name", default_content_key_policy_name)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "streaming_locator_id", streaming_locator_id)
        pulumi.set(__self__, "streaming_policy_name", streaming_policy_name)

    @property
    @pulumi.getter(name="assetName")
    def asset_name(self) -> str:
        """
        Asset Name.
        """
        return pulumi.get(self, "asset_name")

    @property
    @pulumi.getter
    def created(self) -> str:
        """
        The creation time of the Streaming Locator.
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter(name="defaultContentKeyPolicyName")
    def default_content_key_policy_name(self) -> str:
        """
        Name of the default ContentKeyPolicy used by this Streaming Locator.
        """
        return pulumi.get(self, "default_content_key_policy_name")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        """
        The end time of the Streaming Locator.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Streaming Locator name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        The start time of the Streaming Locator.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="streamingLocatorId")
    def streaming_locator_id(self) -> str:
        """
        StreamingLocatorId of the Streaming Locator.
        """
        return pulumi.get(self, "streaming_locator_id")

    @property
    @pulumi.getter(name="streamingPolicyName")
    def streaming_policy_name(self) -> str:
        """
        Name of the Streaming Policy used by this Streaming Locator.
        """
        return pulumi.get(self, "streaming_policy_name")


@pulumi.output_type
class CbcsDrmConfigurationResponse(dict):
    """
    Class to specify DRM configurations of CommonEncryptionCbcs scheme in Streaming Policy
    """
    def __init__(__self__, *,
                 fair_play: Optional['outputs.StreamingPolicyFairPlayConfigurationResponse'] = None,
                 play_ready: Optional['outputs.StreamingPolicyPlayReadyConfigurationResponse'] = None,
                 widevine: Optional['outputs.StreamingPolicyWidevineConfigurationResponse'] = None):
        """
        Class to specify DRM configurations of CommonEncryptionCbcs scheme in Streaming Policy
        :param 'StreamingPolicyFairPlayConfigurationResponseArgs' fair_play: FairPlay configurations
        :param 'StreamingPolicyPlayReadyConfigurationResponseArgs' play_ready: PlayReady configurations
        :param 'StreamingPolicyWidevineConfigurationResponseArgs' widevine: Widevine configurations
        """
        if fair_play is not None:
            pulumi.set(__self__, "fair_play", fair_play)
        if play_ready is not None:
            pulumi.set(__self__, "play_ready", play_ready)
        if widevine is not None:
            pulumi.set(__self__, "widevine", widevine)

    @property
    @pulumi.getter(name="fairPlay")
    def fair_play(self) -> Optional['outputs.StreamingPolicyFairPlayConfigurationResponse']:
        """
        FairPlay configurations
        """
        return pulumi.get(self, "fair_play")

    @property
    @pulumi.getter(name="playReady")
    def play_ready(self) -> Optional['outputs.StreamingPolicyPlayReadyConfigurationResponse']:
        """
        PlayReady configurations
        """
        return pulumi.get(self, "play_ready")

    @property
    @pulumi.getter
    def widevine(self) -> Optional['outputs.StreamingPolicyWidevineConfigurationResponse']:
        """
        Widevine configurations
        """
        return pulumi.get(self, "widevine")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CencDrmConfigurationResponse(dict):
    """
    Class to specify DRM configurations of CommonEncryptionCenc scheme in Streaming Policy
    """
    def __init__(__self__, *,
                 play_ready: Optional['outputs.StreamingPolicyPlayReadyConfigurationResponse'] = None,
                 widevine: Optional['outputs.StreamingPolicyWidevineConfigurationResponse'] = None):
        """
        Class to specify DRM configurations of CommonEncryptionCenc scheme in Streaming Policy
        :param 'StreamingPolicyPlayReadyConfigurationResponseArgs' play_ready: PlayReady configurations
        :param 'StreamingPolicyWidevineConfigurationResponseArgs' widevine: Widevine configurations
        """
        if play_ready is not None:
            pulumi.set(__self__, "play_ready", play_ready)
        if widevine is not None:
            pulumi.set(__self__, "widevine", widevine)

    @property
    @pulumi.getter(name="playReady")
    def play_ready(self) -> Optional['outputs.StreamingPolicyPlayReadyConfigurationResponse']:
        """
        PlayReady configurations
        """
        return pulumi.get(self, "play_ready")

    @property
    @pulumi.getter
    def widevine(self) -> Optional['outputs.StreamingPolicyWidevineConfigurationResponse']:
        """
        Widevine configurations
        """
        return pulumi.get(self, "widevine")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CommonEncryptionCbcsResponse(dict):
    """
    Class for CommonEncryptionCbcs encryption scheme
    """
    def __init__(__self__, *,
                 clear_tracks: Optional[List['outputs.TrackSelectionResponse']] = None,
                 content_keys: Optional['outputs.StreamingPolicyContentKeysResponse'] = None,
                 drm: Optional['outputs.CbcsDrmConfigurationResponse'] = None,
                 enabled_protocols: Optional['outputs.EnabledProtocolsResponse'] = None):
        """
        Class for CommonEncryptionCbcs encryption scheme
        :param List['TrackSelectionResponseArgs'] clear_tracks: Representing which tracks should not be encrypted
        :param 'StreamingPolicyContentKeysResponseArgs' content_keys: Representing default content key for each encryption scheme and separate content keys for specific tracks
        :param 'CbcsDrmConfigurationResponseArgs' drm: Configuration of DRMs for current encryption scheme
        :param 'EnabledProtocolsResponseArgs' enabled_protocols: Representing supported protocols
        """
        if clear_tracks is not None:
            pulumi.set(__self__, "clear_tracks", clear_tracks)
        if content_keys is not None:
            pulumi.set(__self__, "content_keys", content_keys)
        if drm is not None:
            pulumi.set(__self__, "drm", drm)
        if enabled_protocols is not None:
            pulumi.set(__self__, "enabled_protocols", enabled_protocols)

    @property
    @pulumi.getter(name="clearTracks")
    def clear_tracks(self) -> Optional[List['outputs.TrackSelectionResponse']]:
        """
        Representing which tracks should not be encrypted
        """
        return pulumi.get(self, "clear_tracks")

    @property
    @pulumi.getter(name="contentKeys")
    def content_keys(self) -> Optional['outputs.StreamingPolicyContentKeysResponse']:
        """
        Representing default content key for each encryption scheme and separate content keys for specific tracks
        """
        return pulumi.get(self, "content_keys")

    @property
    @pulumi.getter
    def drm(self) -> Optional['outputs.CbcsDrmConfigurationResponse']:
        """
        Configuration of DRMs for current encryption scheme
        """
        return pulumi.get(self, "drm")

    @property
    @pulumi.getter(name="enabledProtocols")
    def enabled_protocols(self) -> Optional['outputs.EnabledProtocolsResponse']:
        """
        Representing supported protocols
        """
        return pulumi.get(self, "enabled_protocols")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CommonEncryptionCencResponse(dict):
    """
    Class for envelope encryption scheme
    """
    def __init__(__self__, *,
                 clear_tracks: Optional[List['outputs.TrackSelectionResponse']] = None,
                 content_keys: Optional['outputs.StreamingPolicyContentKeysResponse'] = None,
                 drm: Optional['outputs.CencDrmConfigurationResponse'] = None,
                 enabled_protocols: Optional['outputs.EnabledProtocolsResponse'] = None):
        """
        Class for envelope encryption scheme
        :param List['TrackSelectionResponseArgs'] clear_tracks: Representing which tracks should not be encrypted
        :param 'StreamingPolicyContentKeysResponseArgs' content_keys: Representing default content key for each encryption scheme and separate content keys for specific tracks
        :param 'CencDrmConfigurationResponseArgs' drm: Configuration of DRMs for CommonEncryptionCenc encryption scheme
        :param 'EnabledProtocolsResponseArgs' enabled_protocols: Representing supported protocols
        """
        if clear_tracks is not None:
            pulumi.set(__self__, "clear_tracks", clear_tracks)
        if content_keys is not None:
            pulumi.set(__self__, "content_keys", content_keys)
        if drm is not None:
            pulumi.set(__self__, "drm", drm)
        if enabled_protocols is not None:
            pulumi.set(__self__, "enabled_protocols", enabled_protocols)

    @property
    @pulumi.getter(name="clearTracks")
    def clear_tracks(self) -> Optional[List['outputs.TrackSelectionResponse']]:
        """
        Representing which tracks should not be encrypted
        """
        return pulumi.get(self, "clear_tracks")

    @property
    @pulumi.getter(name="contentKeys")
    def content_keys(self) -> Optional['outputs.StreamingPolicyContentKeysResponse']:
        """
        Representing default content key for each encryption scheme and separate content keys for specific tracks
        """
        return pulumi.get(self, "content_keys")

    @property
    @pulumi.getter
    def drm(self) -> Optional['outputs.CencDrmConfigurationResponse']:
        """
        Configuration of DRMs for CommonEncryptionCenc encryption scheme
        """
        return pulumi.get(self, "drm")

    @property
    @pulumi.getter(name="enabledProtocols")
    def enabled_protocols(self) -> Optional['outputs.EnabledProtocolsResponse']:
        """
        Representing supported protocols
        """
        return pulumi.get(self, "enabled_protocols")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ContentKeyPolicyConfigurationResponse(dict):
    """
    Base class for Content Key Policy configuration. A derived class must be used to create a configuration.
    """
    def __init__(__self__, *,
                 odata_type: str):
        """
        Base class for Content Key Policy configuration. A derived class must be used to create a configuration.
        :param str odata_type: The discriminator for derived types.
        """
        pulumi.set(__self__, "odata_type", odata_type)

    @property
    @pulumi.getter(name="odataType")
    def odata_type(self) -> str:
        """
        The discriminator for derived types.
        """
        return pulumi.get(self, "odata_type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ContentKeyPolicyOptionResponse(dict):
    """
    Represents a policy option.
    """
    def __init__(__self__, *,
                 configuration: 'outputs.ContentKeyPolicyConfigurationResponse',
                 policy_option_id: str,
                 restriction: 'outputs.ContentKeyPolicyRestrictionResponse',
                 name: Optional[str] = None):
        """
        Represents a policy option.
        :param 'ContentKeyPolicyConfigurationResponseArgs' configuration: The key delivery configuration.
        :param str policy_option_id: The legacy Policy Option ID.
        :param 'ContentKeyPolicyRestrictionResponseArgs' restriction: The requirements that must be met to deliver keys with this configuration
        :param str name: The Policy Option description.
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "policy_option_id", policy_option_id)
        pulumi.set(__self__, "restriction", restriction)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def configuration(self) -> 'outputs.ContentKeyPolicyConfigurationResponse':
        """
        The key delivery configuration.
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter(name="policyOptionId")
    def policy_option_id(self) -> str:
        """
        The legacy Policy Option ID.
        """
        return pulumi.get(self, "policy_option_id")

    @property
    @pulumi.getter
    def restriction(self) -> 'outputs.ContentKeyPolicyRestrictionResponse':
        """
        The requirements that must be met to deliver keys with this configuration
        """
        return pulumi.get(self, "restriction")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The Policy Option description.
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ContentKeyPolicyRestrictionResponse(dict):
    """
    Base class for Content Key Policy restrictions. A derived class must be used to create a restriction.
    """
    def __init__(__self__, *,
                 odata_type: str):
        """
        Base class for Content Key Policy restrictions. A derived class must be used to create a restriction.
        :param str odata_type: The discriminator for derived types.
        """
        pulumi.set(__self__, "odata_type", odata_type)

    @property
    @pulumi.getter(name="odataType")
    def odata_type(self) -> str:
        """
        The discriminator for derived types.
        """
        return pulumi.get(self, "odata_type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CrossSiteAccessPoliciesResponse(dict):
    """
    The client access policy.
    """
    def __init__(__self__, *,
                 client_access_policy: Optional[str] = None,
                 cross_domain_policy: Optional[str] = None):
        """
        The client access policy.
        :param str client_access_policy: The content of clientaccesspolicy.xml used by Silverlight.
        :param str cross_domain_policy: The content of crossdomain.xml used by Silverlight.
        """
        if client_access_policy is not None:
            pulumi.set(__self__, "client_access_policy", client_access_policy)
        if cross_domain_policy is not None:
            pulumi.set(__self__, "cross_domain_policy", cross_domain_policy)

    @property
    @pulumi.getter(name="clientAccessPolicy")
    def client_access_policy(self) -> Optional[str]:
        """
        The content of clientaccesspolicy.xml used by Silverlight.
        """
        return pulumi.get(self, "client_access_policy")

    @property
    @pulumi.getter(name="crossDomainPolicy")
    def cross_domain_policy(self) -> Optional[str]:
        """
        The content of crossdomain.xml used by Silverlight.
        """
        return pulumi.get(self, "cross_domain_policy")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DefaultKeyResponse(dict):
    """
    Class to specify properties of default content key for each encryption scheme
    """
    def __init__(__self__, *,
                 label: Optional[str] = None,
                 policy_name: Optional[str] = None):
        """
        Class to specify properties of default content key for each encryption scheme
        :param str label: Label can be used to specify Content Key when creating a Streaming Locator
        :param str policy_name: Policy used by Default Key
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if policy_name is not None:
            pulumi.set(__self__, "policy_name", policy_name)

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        Label can be used to specify Content Key when creating a Streaming Locator
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> Optional[str]:
        """
        Policy used by Default Key
        """
        return pulumi.get(self, "policy_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class EdgeUsageDataCollectionPolicyResponseResult(dict):
    def __init__(__self__, *,
                 data_collection_frequency: Optional[str] = None,
                 data_reporting_frequency: Optional[str] = None,
                 event_hub_details: Optional['outputs.EdgeUsageDataEventHubResponseResult'] = None,
                 max_allowed_unreported_usage_duration: Optional[str] = None):
        """
        :param str data_collection_frequency: Usage data collection frequency in ISO 8601 duration format e.g. PT10M , PT5H.
        :param str data_reporting_frequency: Usage data reporting frequency in ISO 8601 duration format e.g. PT10M , PT5H.
        :param 'EdgeUsageDataEventHubResponseArgs' event_hub_details: Details of Event Hub where the usage will be reported.
        :param str max_allowed_unreported_usage_duration: Maximum time for which the functionality of the device will not be hampered for not reporting the usage data.
        """
        if data_collection_frequency is not None:
            pulumi.set(__self__, "data_collection_frequency", data_collection_frequency)
        if data_reporting_frequency is not None:
            pulumi.set(__self__, "data_reporting_frequency", data_reporting_frequency)
        if event_hub_details is not None:
            pulumi.set(__self__, "event_hub_details", event_hub_details)
        if max_allowed_unreported_usage_duration is not None:
            pulumi.set(__self__, "max_allowed_unreported_usage_duration", max_allowed_unreported_usage_duration)

    @property
    @pulumi.getter(name="dataCollectionFrequency")
    def data_collection_frequency(self) -> Optional[str]:
        """
        Usage data collection frequency in ISO 8601 duration format e.g. PT10M , PT5H.
        """
        return pulumi.get(self, "data_collection_frequency")

    @property
    @pulumi.getter(name="dataReportingFrequency")
    def data_reporting_frequency(self) -> Optional[str]:
        """
        Usage data reporting frequency in ISO 8601 duration format e.g. PT10M , PT5H.
        """
        return pulumi.get(self, "data_reporting_frequency")

    @property
    @pulumi.getter(name="eventHubDetails")
    def event_hub_details(self) -> Optional['outputs.EdgeUsageDataEventHubResponseResult']:
        """
        Details of Event Hub where the usage will be reported.
        """
        return pulumi.get(self, "event_hub_details")

    @property
    @pulumi.getter(name="maxAllowedUnreportedUsageDuration")
    def max_allowed_unreported_usage_duration(self) -> Optional[str]:
        """
        Maximum time for which the functionality of the device will not be hampered for not reporting the usage data.
        """
        return pulumi.get(self, "max_allowed_unreported_usage_duration")


@pulumi.output_type
class EdgeUsageDataEventHubResponseResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 token: Optional[str] = None):
        """
        :param str name: Name of the Event Hub where usage will be reported.
        :param str namespace: Namespace of the Event Hub where usage will be reported.
        :param str token: SAS token needed to interact with Event Hub.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Event Hub where usage will be reported.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the Event Hub where usage will be reported.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        SAS token needed to interact with Event Hub.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class EnabledProtocolsResponse(dict):
    """
    Class to specify which protocols are enabled
    """
    def __init__(__self__, *,
                 dash: bool,
                 download: bool,
                 hls: bool,
                 smooth_streaming: bool):
        """
        Class to specify which protocols are enabled
        :param bool dash: Enable DASH protocol or not
        :param bool download: Enable Download protocol or not
        :param bool hls: Enable HLS protocol or not
        :param bool smooth_streaming: Enable SmoothStreaming protocol or not
        """
        pulumi.set(__self__, "dash", dash)
        pulumi.set(__self__, "download", download)
        pulumi.set(__self__, "hls", hls)
        pulumi.set(__self__, "smooth_streaming", smooth_streaming)

    @property
    @pulumi.getter
    def dash(self) -> bool:
        """
        Enable DASH protocol or not
        """
        return pulumi.get(self, "dash")

    @property
    @pulumi.getter
    def download(self) -> bool:
        """
        Enable Download protocol or not
        """
        return pulumi.get(self, "download")

    @property
    @pulumi.getter
    def hls(self) -> bool:
        """
        Enable HLS protocol or not
        """
        return pulumi.get(self, "hls")

    @property
    @pulumi.getter(name="smoothStreaming")
    def smooth_streaming(self) -> bool:
        """
        Enable SmoothStreaming protocol or not
        """
        return pulumi.get(self, "smooth_streaming")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class EnvelopeEncryptionResponse(dict):
    """
    Class for EnvelopeEncryption encryption scheme
    """
    def __init__(__self__, *,
                 clear_tracks: Optional[List['outputs.TrackSelectionResponse']] = None,
                 content_keys: Optional['outputs.StreamingPolicyContentKeysResponse'] = None,
                 custom_key_acquisition_url_template: Optional[str] = None,
                 enabled_protocols: Optional['outputs.EnabledProtocolsResponse'] = None):
        """
        Class for EnvelopeEncryption encryption scheme
        :param List['TrackSelectionResponseArgs'] clear_tracks: Representing which tracks should not be encrypted
        :param 'StreamingPolicyContentKeysResponseArgs' content_keys: Representing default content key for each encryption scheme and separate content keys for specific tracks
        :param str custom_key_acquisition_url_template: Template for the URL of the custom service delivering keys to end user players.  Not required when using Azure Media Services for issuing keys.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
        :param 'EnabledProtocolsResponseArgs' enabled_protocols: Representing supported protocols
        """
        if clear_tracks is not None:
            pulumi.set(__self__, "clear_tracks", clear_tracks)
        if content_keys is not None:
            pulumi.set(__self__, "content_keys", content_keys)
        if custom_key_acquisition_url_template is not None:
            pulumi.set(__self__, "custom_key_acquisition_url_template", custom_key_acquisition_url_template)
        if enabled_protocols is not None:
            pulumi.set(__self__, "enabled_protocols", enabled_protocols)

    @property
    @pulumi.getter(name="clearTracks")
    def clear_tracks(self) -> Optional[List['outputs.TrackSelectionResponse']]:
        """
        Representing which tracks should not be encrypted
        """
        return pulumi.get(self, "clear_tracks")

    @property
    @pulumi.getter(name="contentKeys")
    def content_keys(self) -> Optional['outputs.StreamingPolicyContentKeysResponse']:
        """
        Representing default content key for each encryption scheme and separate content keys for specific tracks
        """
        return pulumi.get(self, "content_keys")

    @property
    @pulumi.getter(name="customKeyAcquisitionUrlTemplate")
    def custom_key_acquisition_url_template(self) -> Optional[str]:
        """
        Template for the URL of the custom service delivering keys to end user players.  Not required when using Azure Media Services for issuing keys.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
        """
        return pulumi.get(self, "custom_key_acquisition_url_template")

    @property
    @pulumi.getter(name="enabledProtocols")
    def enabled_protocols(self) -> Optional['outputs.EnabledProtocolsResponse']:
        """
        Representing supported protocols
        """
        return pulumi.get(self, "enabled_protocols")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FilterTrackPropertyConditionResponse(dict):
    """
    The class to specify one track property condition.
    """
    def __init__(__self__, *,
                 operation: str,
                 property: str,
                 value: str):
        """
        The class to specify one track property condition.
        :param str operation: The track property condition operation.
        :param str property: The track property type.
        :param str value: The track property value.
        """
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "property", property)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        The track property condition operation.
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The track property value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def property(self) -> str:
        """
        The track property type.
        """
        return pulumi.get(self, "property")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FilterTrackSelectionResponse(dict):
    """
    Representing a list of FilterTrackPropertyConditions to select a track.  The filters are combined using a logical AND operation.
    """
    def __init__(__self__, *,
                 track_selections: List['outputs.FilterTrackPropertyConditionResponse']):
        """
        Representing a list of FilterTrackPropertyConditions to select a track.  The filters are combined using a logical AND operation.
        :param List['FilterTrackPropertyConditionResponseArgs'] track_selections: The track selections.
        """
        pulumi.set(__self__, "track_selections", track_selections)

    @property
    @pulumi.getter(name="trackSelections")
    def track_selections(self) -> List['outputs.FilterTrackPropertyConditionResponse']:
        """
        The track selections.
        """
        return pulumi.get(self, "track_selections")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FirstQualityResponse(dict):
    """
    Filter First Quality
    """
    def __init__(__self__, *,
                 bitrate: float):
        """
        Filter First Quality
        :param float bitrate: The first quality bitrate.
        """
        pulumi.set(__self__, "bitrate", bitrate)

    @property
    @pulumi.getter
    def bitrate(self) -> float:
        """
        The first quality bitrate.
        """
        return pulumi.get(self, "bitrate")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HlsResponse(dict):
    """
    The HLS configuration.
    """
    def __init__(__self__, *,
                 fragments_per_ts_segment: Optional[float] = None):
        """
        The HLS configuration.
        :param float fragments_per_ts_segment: The amount of fragments per HTTP Live Streaming (HLS) segment.
        """
        if fragments_per_ts_segment is not None:
            pulumi.set(__self__, "fragments_per_ts_segment", fragments_per_ts_segment)

    @property
    @pulumi.getter(name="fragmentsPerTsSegment")
    def fragments_per_ts_segment(self) -> Optional[float]:
        """
        The amount of fragments per HTTP Live Streaming (HLS) segment.
        """
        return pulumi.get(self, "fragments_per_ts_segment")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IPAccessControlResponse(dict):
    """
    The IP access control.
    """
    def __init__(__self__, *,
                 allow: Optional[List['outputs.IPRangeResponse']] = None):
        """
        The IP access control.
        :param List['IPRangeResponseArgs'] allow: The IP allow list.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)

    @property
    @pulumi.getter
    def allow(self) -> Optional[List['outputs.IPRangeResponse']]:
        """
        The IP allow list.
        """
        return pulumi.get(self, "allow")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IPRangeResponse(dict):
    """
    The IP address range in the CIDR scheme.
    """
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 name: Optional[str] = None,
                 subnet_prefix_length: Optional[float] = None):
        """
        The IP address range in the CIDR scheme.
        :param str address: The IP address.
        :param str name: The friendly name for the IP address range.
        :param float subnet_prefix_length: The subnet mask prefix length (see CIDR notation).
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if subnet_prefix_length is not None:
            pulumi.set(__self__, "subnet_prefix_length", subnet_prefix_length)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The IP address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The friendly name for the IP address range.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="subnetPrefixLength")
    def subnet_prefix_length(self) -> Optional[float]:
        """
        The subnet mask prefix length (see CIDR notation).
        """
        return pulumi.get(self, "subnet_prefix_length")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class JobErrorDetailResponse(dict):
    """
    Details of JobOutput errors.
    """
    def __init__(__self__, *,
                 code: str,
                 message: str):
        """
        Details of JobOutput errors.
        :param str code: Code describing the error detail.
        :param str message: A human-readable representation of the error.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> str:
        """
        Code describing the error detail.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        A human-readable representation of the error.
        """
        return pulumi.get(self, "message")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class JobErrorResponse(dict):
    """
    Details of JobOutput errors.
    """
    def __init__(__self__, *,
                 category: str,
                 code: str,
                 details: List['outputs.JobErrorDetailResponse'],
                 message: str,
                 retry: str):
        """
        Details of JobOutput errors.
        :param str category: Helps with categorization of errors.
        :param str code: Error code describing the error.
        :param List['JobErrorDetailResponseArgs'] details: An array of details about specific errors that led to this reported error.
        :param str message: A human-readable language-dependent representation of the error.
        :param str retry: Indicates that it may be possible to retry the Job. If retry is unsuccessful, please contact Azure support via Azure Portal.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "retry", retry)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        Helps with categorization of errors.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def code(self) -> str:
        """
        Error code describing the error.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def details(self) -> List['outputs.JobErrorDetailResponse']:
        """
        An array of details about specific errors that led to this reported error.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        A human-readable language-dependent representation of the error.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def retry(self) -> str:
        """
        Indicates that it may be possible to retry the Job. If retry is unsuccessful, please contact Azure support via Azure Portal.
        """
        return pulumi.get(self, "retry")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class JobInputResponse(dict):
    """
    Base class for inputs to a Job.
    """
    def __init__(__self__, *,
                 odata_type: str):
        """
        Base class for inputs to a Job.
        :param str odata_type: The discriminator for derived types.
        """
        pulumi.set(__self__, "odata_type", odata_type)

    @property
    @pulumi.getter(name="odataType")
    def odata_type(self) -> str:
        """
        The discriminator for derived types.
        """
        return pulumi.get(self, "odata_type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class JobOutputResponse(dict):
    """
    Describes all the properties of a JobOutput.
    """
    def __init__(__self__, *,
                 end_time: str,
                 error: 'outputs.JobErrorResponse',
                 odata_type: str,
                 progress: float,
                 start_time: str,
                 state: str,
                 label: Optional[str] = None):
        """
        Describes all the properties of a JobOutput.
        :param str end_time: The UTC date and time at which this Job Output finished processing.
        :param 'JobErrorResponseArgs' error: If the JobOutput is in the Error state, it contains the details of the error.
        :param str odata_type: The discriminator for derived types.
        :param float progress: If the JobOutput is in a Processing state, this contains the Job completion percentage. The value is an estimate and not intended to be used to predict Job completion times. To determine if the JobOutput is complete, use the State property.
        :param str start_time: The UTC date and time at which this Job Output began processing.
        :param str state: Describes the state of the JobOutput.
        :param str label: A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more than one TransformOutput, whereby your Job has more than one JobOutput. In such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the Transform. Subsequently, when you retrieve the Job, either through events or on a GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}' will be used, where the preset name is the name of the preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the Job. Note that this index is the same as the relative index of the corresponding TransformOutput within its Transform.
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "error", error)
        pulumi.set(__self__, "odata_type", odata_type)
        pulumi.set(__self__, "progress", progress)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "state", state)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        """
        The UTC date and time at which this Job Output finished processing.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter
    def error(self) -> 'outputs.JobErrorResponse':
        """
        If the JobOutput is in the Error state, it contains the details of the error.
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter(name="odataType")
    def odata_type(self) -> str:
        """
        The discriminator for derived types.
        """
        return pulumi.get(self, "odata_type")

    @property
    @pulumi.getter
    def progress(self) -> float:
        """
        If the JobOutput is in a Processing state, this contains the Job completion percentage. The value is an estimate and not intended to be used to predict Job completion times. To determine if the JobOutput is complete, use the State property.
        """
        return pulumi.get(self, "progress")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        The UTC date and time at which this Job Output began processing.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Describes the state of the JobOutput.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more than one TransformOutput, whereby your Job has more than one JobOutput. In such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the Transform. Subsequently, when you retrieve the Job, either through events or on a GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}' will be used, where the preset name is the name of the preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the Job. Note that this index is the same as the relative index of the corresponding TransformOutput within its Transform.
        """
        return pulumi.get(self, "label")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeyVaultPropertiesResponse(dict):
    def __init__(__self__, *,
                 current_key_identifier: str,
                 key_identifier: Optional[str] = None):
        """
        :param str current_key_identifier: The current key used to encrypt the Media Services account, including the key version.
        :param str key_identifier: The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
        """
        pulumi.set(__self__, "current_key_identifier", current_key_identifier)
        if key_identifier is not None:
            pulumi.set(__self__, "key_identifier", key_identifier)

    @property
    @pulumi.getter(name="currentKeyIdentifier")
    def current_key_identifier(self) -> str:
        """
        The current key used to encrypt the Media Services account, including the key version.
        """
        return pulumi.get(self, "current_key_identifier")

    @property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> Optional[str]:
        """
        The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
        """
        return pulumi.get(self, "key_identifier")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LiveEventEncodingResponse(dict):
    """
    The Live Event encoding.
    """
    def __init__(__self__, *,
                 encoding_type: Optional[str] = None,
                 preset_name: Optional[str] = None):
        """
        The Live Event encoding.
        :param str encoding_type: The encoding type for Live Event. This value is specified at creation time and cannot be updated. When encodingType is set to None, the service simply passes through the incoming video and audio layer(s) to the output. When encodingType is set to Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bit rates or layers. See https://go.microsoft.com/fwlink/?linkid=2095101 for more information. The encodingType of Basic is obsolete  if specified, the service will treat this as a Standard Live Event.
        :param str preset_name: The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot be updated. If the encodingType is set to Standard, then the default preset name is Default720p. Else if the encodingType is set to Premium1080p, the default preset is Default1080p.
        """
        if encoding_type is not None:
            pulumi.set(__self__, "encoding_type", encoding_type)
        if preset_name is not None:
            pulumi.set(__self__, "preset_name", preset_name)

    @property
    @pulumi.getter(name="encodingType")
    def encoding_type(self) -> Optional[str]:
        """
        The encoding type for Live Event. This value is specified at creation time and cannot be updated. When encodingType is set to None, the service simply passes through the incoming video and audio layer(s) to the output. When encodingType is set to Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bit rates or layers. See https://go.microsoft.com/fwlink/?linkid=2095101 for more information. The encodingType of Basic is obsolete  if specified, the service will treat this as a Standard Live Event.
        """
        return pulumi.get(self, "encoding_type")

    @property
    @pulumi.getter(name="presetName")
    def preset_name(self) -> Optional[str]:
        """
        The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot be updated. If the encodingType is set to Standard, then the default preset name is Default720p. Else if the encodingType is set to Premium1080p, the default preset is Default1080p.
        """
        return pulumi.get(self, "preset_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LiveEventEndpointResponse(dict):
    """
    The Live Event endpoint.
    """
    def __init__(__self__, *,
                 protocol: Optional[str] = None,
                 url: Optional[str] = None):
        """
        The Live Event endpoint.
        :param str protocol: The endpoint protocol.
        :param str url: The endpoint URL.
        """
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The endpoint protocol.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The endpoint URL.
        """
        return pulumi.get(self, "url")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LiveEventInputAccessControlResponse(dict):
    """
    The IP access control for Live Event Input.
    """
    def __init__(__self__, *,
                 ip: Optional['outputs.IPAccessControlResponse'] = None):
        """
        The IP access control for Live Event Input.
        :param 'IPAccessControlResponseArgs' ip: The IP access control properties.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> Optional['outputs.IPAccessControlResponse']:
        """
        The IP access control properties.
        """
        return pulumi.get(self, "ip")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LiveEventInputResponse(dict):
    """
    The Live Event input.
    """
    def __init__(__self__, *,
                 streaming_protocol: str,
                 access_control: Optional['outputs.LiveEventInputAccessControlResponse'] = None,
                 access_token: Optional[str] = None,
                 endpoints: Optional[List['outputs.LiveEventEndpointResponse']] = None,
                 key_frame_interval_duration: Optional[str] = None):
        """
        The Live Event input.
        :param str streaming_protocol: The streaming protocol for the Live Event.  This is specified at creation time and cannot be updated.
        :param 'LiveEventInputAccessControlResponseArgs' access_control: The access control for LiveEvent Input.
        :param str access_token: A UUID in string form to uniquely identify the stream. This can be specified at creation time but cannot be updated.  If omitted, the service will generate a unique value.
        :param List['LiveEventEndpointResponseArgs'] endpoints: The input endpoints for the Live Event.
        :param str key_frame_interval_duration: ISO 8601 timespan duration of the key frame interval duration.
        """
        pulumi.set(__self__, "streaming_protocol", streaming_protocol)
        if access_control is not None:
            pulumi.set(__self__, "access_control", access_control)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if key_frame_interval_duration is not None:
            pulumi.set(__self__, "key_frame_interval_duration", key_frame_interval_duration)

    @property
    @pulumi.getter(name="streamingProtocol")
    def streaming_protocol(self) -> str:
        """
        The streaming protocol for the Live Event.  This is specified at creation time and cannot be updated.
        """
        return pulumi.get(self, "streaming_protocol")

    @property
    @pulumi.getter(name="accessControl")
    def access_control(self) -> Optional['outputs.LiveEventInputAccessControlResponse']:
        """
        The access control for LiveEvent Input.
        """
        return pulumi.get(self, "access_control")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        A UUID in string form to uniquely identify the stream. This can be specified at creation time but cannot be updated.  If omitted, the service will generate a unique value.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[List['outputs.LiveEventEndpointResponse']]:
        """
        The input endpoints for the Live Event.
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="keyFrameIntervalDuration")
    def key_frame_interval_duration(self) -> Optional[str]:
        """
        ISO 8601 timespan duration of the key frame interval duration.
        """
        return pulumi.get(self, "key_frame_interval_duration")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LiveEventPreviewAccessControlResponse(dict):
    """
    The IP access control for Live Event preview.
    """
    def __init__(__self__, *,
                 ip: Optional['outputs.IPAccessControlResponse'] = None):
        """
        The IP access control for Live Event preview.
        :param 'IPAccessControlResponseArgs' ip: The IP access control properties.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> Optional['outputs.IPAccessControlResponse']:
        """
        The IP access control properties.
        """
        return pulumi.get(self, "ip")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LiveEventPreviewResponse(dict):
    """
    The Live Event preview.
    """
    def __init__(__self__, *,
                 access_control: Optional['outputs.LiveEventPreviewAccessControlResponse'] = None,
                 alternative_media_id: Optional[str] = None,
                 endpoints: Optional[List['outputs.LiveEventEndpointResponse']] = None,
                 preview_locator: Optional[str] = None,
                 streaming_policy_name: Optional[str] = None):
        """
        The Live Event preview.
        :param 'LiveEventPreviewAccessControlResponseArgs' access_control: The access control for LiveEvent preview.
        :param str alternative_media_id: An Alternative Media Identifier associated with the StreamingLocator created for the preview.  This value is specified at creation time and cannot be updated.  The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.
        :param List['LiveEventEndpointResponseArgs'] endpoints: The endpoints for preview.
        :param str preview_locator: The identifier of the preview locator in Guid format.  Specifying this at creation time allows the caller to know the preview locator url before the event is created.  If omitted, the service will generate a random identifier.  This value cannot be updated once the live event is created.
        :param str streaming_policy_name: The name of streaming policy used for the LiveEvent preview.  This value is specified at creation time and cannot be updated.
        """
        if access_control is not None:
            pulumi.set(__self__, "access_control", access_control)
        if alternative_media_id is not None:
            pulumi.set(__self__, "alternative_media_id", alternative_media_id)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if preview_locator is not None:
            pulumi.set(__self__, "preview_locator", preview_locator)
        if streaming_policy_name is not None:
            pulumi.set(__self__, "streaming_policy_name", streaming_policy_name)

    @property
    @pulumi.getter(name="accessControl")
    def access_control(self) -> Optional['outputs.LiveEventPreviewAccessControlResponse']:
        """
        The access control for LiveEvent preview.
        """
        return pulumi.get(self, "access_control")

    @property
    @pulumi.getter(name="alternativeMediaId")
    def alternative_media_id(self) -> Optional[str]:
        """
        An Alternative Media Identifier associated with the StreamingLocator created for the preview.  This value is specified at creation time and cannot be updated.  The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.
        """
        return pulumi.get(self, "alternative_media_id")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[List['outputs.LiveEventEndpointResponse']]:
        """
        The endpoints for preview.
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="previewLocator")
    def preview_locator(self) -> Optional[str]:
        """
        The identifier of the preview locator in Guid format.  Specifying this at creation time allows the caller to know the preview locator url before the event is created.  If omitted, the service will generate a random identifier.  This value cannot be updated once the live event is created.
        """
        return pulumi.get(self, "preview_locator")

    @property
    @pulumi.getter(name="streamingPolicyName")
    def streaming_policy_name(self) -> Optional[str]:
        """
        The name of streaming policy used for the LiveEvent preview.  This value is specified at creation time and cannot be updated.
        """
        return pulumi.get(self, "streaming_policy_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MediaServiceIdentityResponse(dict):
    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: str):
        """
        :param str principal_id: The Principal ID of the identity.
        :param str tenant_id: The Tenant ID of the identity.
        :param str type: The identity type.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The Principal ID of the identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Tenant ID of the identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The identity type.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NoEncryptionResponse(dict):
    """
    Class for NoEncryption scheme
    """
    def __init__(__self__, *,
                 enabled_protocols: Optional['outputs.EnabledProtocolsResponse'] = None):
        """
        Class for NoEncryption scheme
        :param 'EnabledProtocolsResponseArgs' enabled_protocols: Representing supported protocols
        """
        if enabled_protocols is not None:
            pulumi.set(__self__, "enabled_protocols", enabled_protocols)

    @property
    @pulumi.getter(name="enabledProtocols")
    def enabled_protocols(self) -> Optional['outputs.EnabledProtocolsResponse']:
        """
        Representing supported protocols
        """
        return pulumi.get(self, "enabled_protocols")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PresentationTimeRangeResponse(dict):
    """
    The presentation time range, this is asset related and not recommended for Account Filter.
    """
    def __init__(__self__, *,
                 end_timestamp: Optional[float] = None,
                 force_end_timestamp: Optional[bool] = None,
                 live_backoff_duration: Optional[float] = None,
                 presentation_window_duration: Optional[float] = None,
                 start_timestamp: Optional[float] = None,
                 timescale: Optional[float] = None):
        """
        The presentation time range, this is asset related and not recommended for Account Filter.
        :param float end_timestamp: The absolute end time boundary.
        :param bool force_end_timestamp: The indicator of forcing existing of end time stamp.
        :param float live_backoff_duration: The relative to end right edge.
        :param float presentation_window_duration: The relative to end sliding window.
        :param float start_timestamp: The absolute start time boundary.
        :param float timescale: The time scale of time stamps.
        """
        if end_timestamp is not None:
            pulumi.set(__self__, "end_timestamp", end_timestamp)
        if force_end_timestamp is not None:
            pulumi.set(__self__, "force_end_timestamp", force_end_timestamp)
        if live_backoff_duration is not None:
            pulumi.set(__self__, "live_backoff_duration", live_backoff_duration)
        if presentation_window_duration is not None:
            pulumi.set(__self__, "presentation_window_duration", presentation_window_duration)
        if start_timestamp is not None:
            pulumi.set(__self__, "start_timestamp", start_timestamp)
        if timescale is not None:
            pulumi.set(__self__, "timescale", timescale)

    @property
    @pulumi.getter(name="endTimestamp")
    def end_timestamp(self) -> Optional[float]:
        """
        The absolute end time boundary.
        """
        return pulumi.get(self, "end_timestamp")

    @property
    @pulumi.getter(name="forceEndTimestamp")
    def force_end_timestamp(self) -> Optional[bool]:
        """
        The indicator of forcing existing of end time stamp.
        """
        return pulumi.get(self, "force_end_timestamp")

    @property
    @pulumi.getter(name="liveBackoffDuration")
    def live_backoff_duration(self) -> Optional[float]:
        """
        The relative to end right edge.
        """
        return pulumi.get(self, "live_backoff_duration")

    @property
    @pulumi.getter(name="presentationWindowDuration")
    def presentation_window_duration(self) -> Optional[float]:
        """
        The relative to end sliding window.
        """
        return pulumi.get(self, "presentation_window_duration")

    @property
    @pulumi.getter(name="startTimestamp")
    def start_timestamp(self) -> Optional[float]:
        """
        The absolute start time boundary.
        """
        return pulumi.get(self, "start_timestamp")

    @property
    @pulumi.getter
    def timescale(self) -> Optional[float]:
        """
        The time scale of time stamps.
        """
        return pulumi.get(self, "timescale")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PresetResponse(dict):
    """
    Base type for all Presets, which define the recipe or instructions on how the input media files should be processed.
    """
    def __init__(__self__, *,
                 odata_type: str):
        """
        Base type for all Presets, which define the recipe or instructions on how the input media files should be processed.
        :param str odata_type: The discriminator for derived types.
        """
        pulumi.set(__self__, "odata_type", odata_type)

    @property
    @pulumi.getter(name="odataType")
    def odata_type(self) -> str:
        """
        The discriminator for derived types.
        """
        return pulumi.get(self, "odata_type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PrivateEndpointResponse(dict):
    """
    The Private Endpoint resource.
    """
    def __init__(__self__, *,
                 id: str):
        """
        The Private Endpoint resource.
        :param str id: The ARM identifier for Private Endpoint
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ARM identifier for Private Endpoint
        """
        return pulumi.get(self, "id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PrivateLinkServiceConnectionStateResponse(dict):
    """
    A collection of information about the state of the connection between service consumer and provider.
    """
    def __init__(__self__, *,
                 actions_required: Optional[str] = None,
                 description: Optional[str] = None,
                 status: Optional[str] = None):
        """
        A collection of information about the state of the connection between service consumer and provider.
        :param str actions_required: A message indicating if changes on the service provider require any updates on the consumer.
        :param str description: The reason for approval/rejection of the connection.
        :param str status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        if actions_required is not None:
            pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[str]:
        """
        A message indicating if changes on the service provider require any updates on the consumer.
        """
        return pulumi.get(self, "actions_required")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The reason for approval/rejection of the connection.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        return pulumi.get(self, "status")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageAccountResponse(dict):
    """
    The storage account details.
    """
    def __init__(__self__, *,
                 type: str,
                 id: Optional[str] = None):
        """
        The storage account details.
        :param str type: The type of the storage account.
        :param str id: The ID of the storage account resource. Media Services relies on tables and queues as well as blobs, so the primary storage account must be a Standard Storage account (either Microsoft.ClassicStorage or Microsoft.Storage). Blob only storage accounts can be added as secondary storage accounts.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the storage account.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the storage account resource. Media Services relies on tables and queues as well as blobs, so the primary storage account must be a Standard Storage account (either Microsoft.ClassicStorage or Microsoft.Storage). Blob only storage accounts can be added as secondary storage accounts.
        """
        return pulumi.get(self, "id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StreamingEndpointAccessControlResponse(dict):
    """
    StreamingEndpoint access control definition.
    """
    def __init__(__self__, *,
                 akamai: Optional['outputs.AkamaiAccessControlResponse'] = None,
                 ip: Optional['outputs.IPAccessControlResponse'] = None):
        """
        StreamingEndpoint access control definition.
        :param 'AkamaiAccessControlResponseArgs' akamai: The access control of Akamai
        :param 'IPAccessControlResponseArgs' ip: The IP access control of the StreamingEndpoint.
        """
        if akamai is not None:
            pulumi.set(__self__, "akamai", akamai)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def akamai(self) -> Optional['outputs.AkamaiAccessControlResponse']:
        """
        The access control of Akamai
        """
        return pulumi.get(self, "akamai")

    @property
    @pulumi.getter
    def ip(self) -> Optional['outputs.IPAccessControlResponse']:
        """
        The IP access control of the StreamingEndpoint.
        """
        return pulumi.get(self, "ip")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StreamingLocatorContentKeyResponse(dict):
    """
    Class for content key in Streaming Locator
    """
    def __init__(__self__, *,
                 id: str,
                 policy_name: str,
                 tracks: List['outputs.TrackSelectionResponse'],
                 type: str,
                 label_reference_in_streaming_policy: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Class for content key in Streaming Locator
        :param str id: ID of Content Key
        :param str policy_name: ContentKeyPolicy used by Content Key
        :param List['TrackSelectionResponseArgs'] tracks: Tracks which use this Content Key
        :param str type: Encryption type of Content Key
        :param str label_reference_in_streaming_policy: Label of Content Key as specified in the Streaming Policy
        :param str value: Value of Content Key
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "tracks", tracks)
        pulumi.set(__self__, "type", type)
        if label_reference_in_streaming_policy is not None:
            pulumi.set(__self__, "label_reference_in_streaming_policy", label_reference_in_streaming_policy)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of Content Key
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> str:
        """
        ContentKeyPolicy used by Content Key
        """
        return pulumi.get(self, "policy_name")

    @property
    @pulumi.getter
    def tracks(self) -> List['outputs.TrackSelectionResponse']:
        """
        Tracks which use this Content Key
        """
        return pulumi.get(self, "tracks")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Encryption type of Content Key
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="labelReferenceInStreamingPolicy")
    def label_reference_in_streaming_policy(self) -> Optional[str]:
        """
        Label of Content Key as specified in the Streaming Policy
        """
        return pulumi.get(self, "label_reference_in_streaming_policy")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of Content Key
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StreamingPathResponseResult(dict):
    """
    Class of paths for streaming
    """
    def __init__(__self__, *,
                 encryption_scheme: str,
                 streaming_protocol: str,
                 paths: Optional[List[str]] = None):
        """
        Class of paths for streaming
        :param str encryption_scheme: Encryption scheme
        :param str streaming_protocol: Streaming protocol
        :param List[str] paths: Streaming paths for each protocol and encryptionScheme pair
        """
        pulumi.set(__self__, "encryption_scheme", encryption_scheme)
        pulumi.set(__self__, "streaming_protocol", streaming_protocol)
        if paths is not None:
            pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter(name="encryptionScheme")
    def encryption_scheme(self) -> str:
        """
        Encryption scheme
        """
        return pulumi.get(self, "encryption_scheme")

    @property
    @pulumi.getter(name="streamingProtocol")
    def streaming_protocol(self) -> str:
        """
        Streaming protocol
        """
        return pulumi.get(self, "streaming_protocol")

    @property
    @pulumi.getter
    def paths(self) -> Optional[List[str]]:
        """
        Streaming paths for each protocol and encryptionScheme pair
        """
        return pulumi.get(self, "paths")


@pulumi.output_type
class StreamingPolicyContentKeyResponse(dict):
    """
    Class to specify properties of content key
    """
    def __init__(__self__, *,
                 label: Optional[str] = None,
                 policy_name: Optional[str] = None,
                 tracks: Optional[List['outputs.TrackSelectionResponse']] = None):
        """
        Class to specify properties of content key
        :param str label: Label can be used to specify Content Key when creating a Streaming Locator
        :param str policy_name: Policy used by Content Key
        :param List['TrackSelectionResponseArgs'] tracks: Tracks which use this content key
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if policy_name is not None:
            pulumi.set(__self__, "policy_name", policy_name)
        if tracks is not None:
            pulumi.set(__self__, "tracks", tracks)

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        Label can be used to specify Content Key when creating a Streaming Locator
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> Optional[str]:
        """
        Policy used by Content Key
        """
        return pulumi.get(self, "policy_name")

    @property
    @pulumi.getter
    def tracks(self) -> Optional[List['outputs.TrackSelectionResponse']]:
        """
        Tracks which use this content key
        """
        return pulumi.get(self, "tracks")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StreamingPolicyContentKeysResponse(dict):
    """
    Class to specify properties of all content keys in Streaming Policy
    """
    def __init__(__self__, *,
                 default_key: Optional['outputs.DefaultKeyResponse'] = None,
                 key_to_track_mappings: Optional[List['outputs.StreamingPolicyContentKeyResponse']] = None):
        """
        Class to specify properties of all content keys in Streaming Policy
        :param 'DefaultKeyResponseArgs' default_key: Default content key for an encryption scheme
        :param List['StreamingPolicyContentKeyResponseArgs'] key_to_track_mappings: Representing tracks needs separate content key
        """
        if default_key is not None:
            pulumi.set(__self__, "default_key", default_key)
        if key_to_track_mappings is not None:
            pulumi.set(__self__, "key_to_track_mappings", key_to_track_mappings)

    @property
    @pulumi.getter(name="defaultKey")
    def default_key(self) -> Optional['outputs.DefaultKeyResponse']:
        """
        Default content key for an encryption scheme
        """
        return pulumi.get(self, "default_key")

    @property
    @pulumi.getter(name="keyToTrackMappings")
    def key_to_track_mappings(self) -> Optional[List['outputs.StreamingPolicyContentKeyResponse']]:
        """
        Representing tracks needs separate content key
        """
        return pulumi.get(self, "key_to_track_mappings")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StreamingPolicyFairPlayConfigurationResponse(dict):
    """
    Class to specify configurations of FairPlay in Streaming Policy
    """
    def __init__(__self__, *,
                 allow_persistent_license: bool,
                 custom_license_acquisition_url_template: Optional[str] = None):
        """
        Class to specify configurations of FairPlay in Streaming Policy
        :param bool allow_persistent_license: All license to be persistent or not
        :param str custom_license_acquisition_url_template: Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
        """
        pulumi.set(__self__, "allow_persistent_license", allow_persistent_license)
        if custom_license_acquisition_url_template is not None:
            pulumi.set(__self__, "custom_license_acquisition_url_template", custom_license_acquisition_url_template)

    @property
    @pulumi.getter(name="allowPersistentLicense")
    def allow_persistent_license(self) -> bool:
        """
        All license to be persistent or not
        """
        return pulumi.get(self, "allow_persistent_license")

    @property
    @pulumi.getter(name="customLicenseAcquisitionUrlTemplate")
    def custom_license_acquisition_url_template(self) -> Optional[str]:
        """
        Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
        """
        return pulumi.get(self, "custom_license_acquisition_url_template")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StreamingPolicyPlayReadyConfigurationResponse(dict):
    """
    Class to specify configurations of PlayReady in Streaming Policy
    """
    def __init__(__self__, *,
                 custom_license_acquisition_url_template: Optional[str] = None,
                 play_ready_custom_attributes: Optional[str] = None):
        """
        Class to specify configurations of PlayReady in Streaming Policy
        :param str custom_license_acquisition_url_template: Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
        :param str play_ready_custom_attributes: Custom attributes for PlayReady
        """
        if custom_license_acquisition_url_template is not None:
            pulumi.set(__self__, "custom_license_acquisition_url_template", custom_license_acquisition_url_template)
        if play_ready_custom_attributes is not None:
            pulumi.set(__self__, "play_ready_custom_attributes", play_ready_custom_attributes)

    @property
    @pulumi.getter(name="customLicenseAcquisitionUrlTemplate")
    def custom_license_acquisition_url_template(self) -> Optional[str]:
        """
        Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
        """
        return pulumi.get(self, "custom_license_acquisition_url_template")

    @property
    @pulumi.getter(name="playReadyCustomAttributes")
    def play_ready_custom_attributes(self) -> Optional[str]:
        """
        Custom attributes for PlayReady
        """
        return pulumi.get(self, "play_ready_custom_attributes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StreamingPolicyWidevineConfigurationResponse(dict):
    """
    Class to specify configurations of Widevine in Streaming Policy
    """
    def __init__(__self__, *,
                 custom_license_acquisition_url_template: Optional[str] = None):
        """
        Class to specify configurations of Widevine in Streaming Policy
        :param str custom_license_acquisition_url_template: Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
        """
        if custom_license_acquisition_url_template is not None:
            pulumi.set(__self__, "custom_license_acquisition_url_template", custom_license_acquisition_url_template)

    @property
    @pulumi.getter(name="customLicenseAcquisitionUrlTemplate")
    def custom_license_acquisition_url_template(self) -> Optional[str]:
        """
        Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
        """
        return pulumi.get(self, "custom_license_acquisition_url_template")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TrackPropertyConditionResponse(dict):
    """
    Class to specify one track property condition
    """
    def __init__(__self__, *,
                 operation: str,
                 property: str,
                 value: Optional[str] = None):
        """
        Class to specify one track property condition
        :param str operation: Track property condition operation
        :param str property: Track property type
        :param str value: Track property value
        """
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "property", property)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        Track property condition operation
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Track property value
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def property(self) -> str:
        """
        Track property type
        """
        return pulumi.get(self, "property")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TrackSelectionResponse(dict):
    """
    Class to select a track
    """
    def __init__(__self__, *,
                 track_selections: Optional[List['outputs.TrackPropertyConditionResponse']] = None):
        """
        Class to select a track
        :param List['TrackPropertyConditionResponseArgs'] track_selections: TrackSelections is a track property condition list which can specify track(s)
        """
        if track_selections is not None:
            pulumi.set(__self__, "track_selections", track_selections)

    @property
    @pulumi.getter(name="trackSelections")
    def track_selections(self) -> Optional[List['outputs.TrackPropertyConditionResponse']]:
        """
        TrackSelections is a track property condition list which can specify track(s)
        """
        return pulumi.get(self, "track_selections")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TransformOutputResponse(dict):
    """
    Describes the properties of a TransformOutput, which are the rules to be applied while generating the desired output.
    """
    def __init__(__self__, *,
                 preset: 'outputs.PresetResponse',
                 on_error: Optional[str] = None,
                 relative_priority: Optional[str] = None):
        """
        Describes the properties of a TransformOutput, which are the rules to be applied while generating the desired output.
        :param 'PresetResponseArgs' preset: Preset that describes the operations that will be used to modify, transcode, or extract insights from the source file to generate the output.
        :param str on_error: A Transform can define more than one outputs. This property defines what the service should do when one output fails - either continue to produce other outputs, or, stop the other outputs. The overall Job state will not reflect failures of outputs that are specified with 'ContinueJob'. The default is 'StopProcessingJob'.
        :param str relative_priority: Sets the relative priority of the TransformOutputs within a Transform. This sets the priority that the service uses for processing TransformOutputs. The default priority is Normal.
        """
        pulumi.set(__self__, "preset", preset)
        if on_error is not None:
            pulumi.set(__self__, "on_error", on_error)
        if relative_priority is not None:
            pulumi.set(__self__, "relative_priority", relative_priority)

    @property
    @pulumi.getter
    def preset(self) -> 'outputs.PresetResponse':
        """
        Preset that describes the operations that will be used to modify, transcode, or extract insights from the source file to generate the output.
        """
        return pulumi.get(self, "preset")

    @property
    @pulumi.getter(name="onError")
    def on_error(self) -> Optional[str]:
        """
        A Transform can define more than one outputs. This property defines what the service should do when one output fails - either continue to produce other outputs, or, stop the other outputs. The overall Job state will not reflect failures of outputs that are specified with 'ContinueJob'. The default is 'StopProcessingJob'.
        """
        return pulumi.get(self, "on_error")

    @property
    @pulumi.getter(name="relativePriority")
    def relative_priority(self) -> Optional[str]:
        """
        Sets the relative priority of the TransformOutputs within a Transform. This sets the priority that the service uses for processing TransformOutputs. The default priority is Normal.
        """
        return pulumi.get(self, "relative_priority")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


