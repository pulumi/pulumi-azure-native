# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Dict, List, Mapping, Optional, Tuple, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'BackendPoolResponse',
    'BackendPoolsSettingsResponse',
    'BackendResponse',
    'CustomHttpsConfigurationResponse',
    'FrontendEndpointResponse',
    'FrontendEndpointUpdateParametersResponseWebApplicationFirewallPolicyLink',
    'HealthProbeSettingsModelResponse',
    'KeyVaultCertificateSourceParametersResponseVault',
    'LoadBalancingSettingsModelResponse',
    'RouteConfigurationResponse',
    'RoutingRuleResponse',
    'SubResourceResponse',
]

@pulumi.output_type
class BackendPoolResponse(dict):
    """
    A backend pool is a collection of backends that can be routed to.
    """
    def __init__(__self__, *,
                 type: str,
                 backends: Optional[List['outputs.BackendResponse']] = None,
                 health_probe_settings: Optional['outputs.SubResourceResponse'] = None,
                 id: Optional[str] = None,
                 load_balancing_settings: Optional['outputs.SubResourceResponse'] = None,
                 name: Optional[str] = None,
                 resource_state: Optional[str] = None):
        """
        A backend pool is a collection of backends that can be routed to.
        :param str type: Resource type.
        :param List['BackendResponseArgs'] backends: The set of backends for this pool
        :param 'SubResourceResponseArgs' health_probe_settings: L7 health probe settings for a backend pool
        :param str id: Resource ID.
        :param 'SubResourceResponseArgs' load_balancing_settings: Load balancing settings for a backend pool
        :param str name: Resource name.
        :param str resource_state: Resource status.
        """
        pulumi.set(__self__, "type", type)
        if backends is not None:
            pulumi.set(__self__, "backends", backends)
        if health_probe_settings is not None:
            pulumi.set(__self__, "health_probe_settings", health_probe_settings)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if load_balancing_settings is not None:
            pulumi.set(__self__, "load_balancing_settings", load_balancing_settings)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_state is not None:
            pulumi.set(__self__, "resource_state", resource_state)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def backends(self) -> Optional[List['outputs.BackendResponse']]:
        """
        The set of backends for this pool
        """
        return pulumi.get(self, "backends")

    @property
    @pulumi.getter(name="healthProbeSettings")
    def health_probe_settings(self) -> Optional['outputs.SubResourceResponse']:
        """
        L7 health probe settings for a backend pool
        """
        return pulumi.get(self, "health_probe_settings")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="loadBalancingSettings")
    def load_balancing_settings(self) -> Optional['outputs.SubResourceResponse']:
        """
        Load balancing settings for a backend pool
        """
        return pulumi.get(self, "load_balancing_settings")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceState")
    def resource_state(self) -> Optional[str]:
        """
        Resource status.
        """
        return pulumi.get(self, "resource_state")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendPoolsSettingsResponse(dict):
    """
    Settings that apply to all backend pools.
    """
    def __init__(__self__, *,
                 enforce_certificate_name_check: Optional[str] = None,
                 send_recv_timeout_seconds: Optional[float] = None):
        """
        Settings that apply to all backend pools.
        :param str enforce_certificate_name_check: Whether to enforce certificate name check on HTTPS requests to all backend pools. No effect on non-HTTPS requests.
        :param float send_recv_timeout_seconds: Send and receive timeout on forwarding request to the backend. When timeout is reached, the request fails and returns.
        """
        if enforce_certificate_name_check is not None:
            pulumi.set(__self__, "enforce_certificate_name_check", enforce_certificate_name_check)
        if send_recv_timeout_seconds is not None:
            pulumi.set(__self__, "send_recv_timeout_seconds", send_recv_timeout_seconds)

    @property
    @pulumi.getter(name="enforceCertificateNameCheck")
    def enforce_certificate_name_check(self) -> Optional[str]:
        """
        Whether to enforce certificate name check on HTTPS requests to all backend pools. No effect on non-HTTPS requests.
        """
        return pulumi.get(self, "enforce_certificate_name_check")

    @property
    @pulumi.getter(name="sendRecvTimeoutSeconds")
    def send_recv_timeout_seconds(self) -> Optional[float]:
        """
        Send and receive timeout on forwarding request to the backend. When timeout is reached, the request fails and returns.
        """
        return pulumi.get(self, "send_recv_timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackendResponse(dict):
    """
    Backend address of a frontDoor load balancer.
    """
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 backend_host_header: Optional[str] = None,
                 enabled_state: Optional[str] = None,
                 http_port: Optional[float] = None,
                 https_port: Optional[float] = None,
                 priority: Optional[float] = None,
                 weight: Optional[float] = None):
        """
        Backend address of a frontDoor load balancer.
        :param str address: Location of the backend (IP address or FQDN)
        :param str backend_host_header: The value to use as the host header sent to the backend. If blank or unspecified, this defaults to the incoming host.
        :param str enabled_state: Whether to enable use of this backend. Permitted values are 'Enabled' or 'Disabled'
        :param float http_port: The HTTP TCP port number. Must be between 1 and 65535.
        :param float https_port: The HTTPS TCP port number. Must be between 1 and 65535.
        :param float priority: Priority to use for load balancing. Higher priorities will not be used for load balancing if any lower priority backend is healthy.
        :param float weight: Weight of this endpoint for load balancing purposes.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if backend_host_header is not None:
            pulumi.set(__self__, "backend_host_header", backend_host_header)
        if enabled_state is not None:
            pulumi.set(__self__, "enabled_state", enabled_state)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Location of the backend (IP address or FQDN)
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="backendHostHeader")
    def backend_host_header(self) -> Optional[str]:
        """
        The value to use as the host header sent to the backend. If blank or unspecified, this defaults to the incoming host.
        """
        return pulumi.get(self, "backend_host_header")

    @property
    @pulumi.getter(name="enabledState")
    def enabled_state(self) -> Optional[str]:
        """
        Whether to enable use of this backend. Permitted values are 'Enabled' or 'Disabled'
        """
        return pulumi.get(self, "enabled_state")

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[float]:
        """
        The HTTP TCP port number. Must be between 1 and 65535.
        """
        return pulumi.get(self, "http_port")

    @property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[float]:
        """
        The HTTPS TCP port number. Must be between 1 and 65535.
        """
        return pulumi.get(self, "https_port")

    @property
    @pulumi.getter
    def priority(self) -> Optional[float]:
        """
        Priority to use for load balancing. Higher priorities will not be used for load balancing if any lower priority backend is healthy.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def weight(self) -> Optional[float]:
        """
        Weight of this endpoint for load balancing purposes.
        """
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CustomHttpsConfigurationResponse(dict):
    """
    Https settings for a domain
    """
    def __init__(__self__, *,
                 certificate_source: str,
                 minimum_tls_version: str,
                 protocol_type: str,
                 certificate_type: Optional[str] = None,
                 secret_name: Optional[str] = None,
                 secret_version: Optional[str] = None,
                 vault: Optional['outputs.KeyVaultCertificateSourceParametersResponseVault'] = None):
        """
        Https settings for a domain
        :param str certificate_source: Defines the source of the SSL certificate
        :param str minimum_tls_version: The minimum TLS version required from the clients to establish an SSL handshake with Front Door.
        :param str protocol_type: Defines the TLS extension protocol that is used for secure delivery
        :param str certificate_type: Defines the type of the certificate used for secure connections to a frontendEndpoint
        :param str secret_name: The name of the Key Vault secret representing the full certificate PFX
        :param str secret_version: The version of the Key Vault secret representing the full certificate PFX
        :param 'KeyVaultCertificateSourceParametersResponseVaultArgs' vault: The Key Vault containing the SSL certificate
        """
        pulumi.set(__self__, "certificate_source", certificate_source)
        pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        pulumi.set(__self__, "protocol_type", protocol_type)
        if certificate_type is not None:
            pulumi.set(__self__, "certificate_type", certificate_type)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)
        if secret_version is not None:
            pulumi.set(__self__, "secret_version", secret_version)
        if vault is not None:
            pulumi.set(__self__, "vault", vault)

    @property
    @pulumi.getter(name="certificateSource")
    def certificate_source(self) -> str:
        """
        Defines the source of the SSL certificate
        """
        return pulumi.get(self, "certificate_source")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> str:
        """
        The minimum TLS version required from the clients to establish an SSL handshake with Front Door.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> str:
        """
        Defines the TLS extension protocol that is used for secure delivery
        """
        return pulumi.get(self, "protocol_type")

    @property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> Optional[str]:
        """
        Defines the type of the certificate used for secure connections to a frontendEndpoint
        """
        return pulumi.get(self, "certificate_type")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        """
        The name of the Key Vault secret representing the full certificate PFX
        """
        return pulumi.get(self, "secret_name")

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[str]:
        """
        The version of the Key Vault secret representing the full certificate PFX
        """
        return pulumi.get(self, "secret_version")

    @property
    @pulumi.getter
    def vault(self) -> Optional['outputs.KeyVaultCertificateSourceParametersResponseVault']:
        """
        The Key Vault containing the SSL certificate
        """
        return pulumi.get(self, "vault")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FrontendEndpointResponse(dict):
    """
    A frontend endpoint used for routing.
    """
    def __init__(__self__, *,
                 custom_https_configuration: 'outputs.CustomHttpsConfigurationResponse',
                 custom_https_provisioning_state: str,
                 custom_https_provisioning_substate: str,
                 type: str,
                 host_name: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 resource_state: Optional[str] = None,
                 session_affinity_enabled_state: Optional[str] = None,
                 session_affinity_ttl_seconds: Optional[float] = None,
                 web_application_firewall_policy_link: Optional['outputs.FrontendEndpointUpdateParametersResponseWebApplicationFirewallPolicyLink'] = None):
        """
        A frontend endpoint used for routing.
        :param 'CustomHttpsConfigurationResponseArgs' custom_https_configuration: The configuration specifying how to enable HTTPS
        :param str custom_https_provisioning_state: Provisioning status of Custom Https of the frontendEndpoint.
        :param str custom_https_provisioning_substate: Provisioning substate shows the progress of custom HTTPS enabling/disabling process step by step.
        :param str type: Resource type.
        :param str host_name: The host name of the frontendEndpoint. Must be a domain name.
        :param str id: Resource ID.
        :param str name: Resource name.
        :param str resource_state: Resource status.
        :param str session_affinity_enabled_state: Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'
        :param float session_affinity_ttl_seconds: UNUSED. This field will be ignored. The TTL to use in seconds for session affinity, if applicable.
        :param 'FrontendEndpointUpdateParametersResponseWebApplicationFirewallPolicyLinkArgs' web_application_firewall_policy_link: Defines the Web Application Firewall policy for each host (if applicable)
        """
        pulumi.set(__self__, "custom_https_configuration", custom_https_configuration)
        pulumi.set(__self__, "custom_https_provisioning_state", custom_https_provisioning_state)
        pulumi.set(__self__, "custom_https_provisioning_substate", custom_https_provisioning_substate)
        pulumi.set(__self__, "type", type)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_state is not None:
            pulumi.set(__self__, "resource_state", resource_state)
        if session_affinity_enabled_state is not None:
            pulumi.set(__self__, "session_affinity_enabled_state", session_affinity_enabled_state)
        if session_affinity_ttl_seconds is not None:
            pulumi.set(__self__, "session_affinity_ttl_seconds", session_affinity_ttl_seconds)
        if web_application_firewall_policy_link is not None:
            pulumi.set(__self__, "web_application_firewall_policy_link", web_application_firewall_policy_link)

    @property
    @pulumi.getter(name="customHttpsConfiguration")
    def custom_https_configuration(self) -> 'outputs.CustomHttpsConfigurationResponse':
        """
        The configuration specifying how to enable HTTPS
        """
        return pulumi.get(self, "custom_https_configuration")

    @property
    @pulumi.getter(name="customHttpsProvisioningState")
    def custom_https_provisioning_state(self) -> str:
        """
        Provisioning status of Custom Https of the frontendEndpoint.
        """
        return pulumi.get(self, "custom_https_provisioning_state")

    @property
    @pulumi.getter(name="customHttpsProvisioningSubstate")
    def custom_https_provisioning_substate(self) -> str:
        """
        Provisioning substate shows the progress of custom HTTPS enabling/disabling process step by step.
        """
        return pulumi.get(self, "custom_https_provisioning_substate")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[str]:
        """
        The host name of the frontendEndpoint. Must be a domain name.
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceState")
    def resource_state(self) -> Optional[str]:
        """
        Resource status.
        """
        return pulumi.get(self, "resource_state")

    @property
    @pulumi.getter(name="sessionAffinityEnabledState")
    def session_affinity_enabled_state(self) -> Optional[str]:
        """
        Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'
        """
        return pulumi.get(self, "session_affinity_enabled_state")

    @property
    @pulumi.getter(name="sessionAffinityTtlSeconds")
    def session_affinity_ttl_seconds(self) -> Optional[float]:
        """
        UNUSED. This field will be ignored. The TTL to use in seconds for session affinity, if applicable.
        """
        return pulumi.get(self, "session_affinity_ttl_seconds")

    @property
    @pulumi.getter(name="webApplicationFirewallPolicyLink")
    def web_application_firewall_policy_link(self) -> Optional['outputs.FrontendEndpointUpdateParametersResponseWebApplicationFirewallPolicyLink']:
        """
        Defines the Web Application Firewall policy for each host (if applicable)
        """
        return pulumi.get(self, "web_application_firewall_policy_link")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FrontendEndpointUpdateParametersResponseWebApplicationFirewallPolicyLink(dict):
    """
    Defines the Web Application Firewall policy for each host (if applicable)
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        Defines the Web Application Firewall policy for each host (if applicable)
        :param str id: Resource ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HealthProbeSettingsModelResponse(dict):
    """
    Load balancing settings for a backend pool
    """
    def __init__(__self__, *,
                 type: str,
                 enabled_state: Optional[str] = None,
                 health_probe_method: Optional[str] = None,
                 id: Optional[str] = None,
                 interval_in_seconds: Optional[float] = None,
                 name: Optional[str] = None,
                 path: Optional[str] = None,
                 protocol: Optional[str] = None,
                 resource_state: Optional[str] = None):
        """
        Load balancing settings for a backend pool
        :param str type: Resource type.
        :param str enabled_state: Whether to enable health probes to be made against backends defined under backendPools. Health probes can only be disabled if there is a single enabled backend in single enabled backend pool.
        :param str health_probe_method: Configures which HTTP method to use to probe the backends defined under backendPools.
        :param str id: Resource ID.
        :param float interval_in_seconds: The number of seconds between health probes.
        :param str name: Resource name.
        :param str path: The path to use for the health probe. Default is /
        :param str protocol: Protocol scheme to use for this probe
        :param str resource_state: Resource status.
        """
        pulumi.set(__self__, "type", type)
        if enabled_state is not None:
            pulumi.set(__self__, "enabled_state", enabled_state)
        if health_probe_method is not None:
            pulumi.set(__self__, "health_probe_method", health_probe_method)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if interval_in_seconds is not None:
            pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if resource_state is not None:
            pulumi.set(__self__, "resource_state", resource_state)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="enabledState")
    def enabled_state(self) -> Optional[str]:
        """
        Whether to enable health probes to be made against backends defined under backendPools. Health probes can only be disabled if there is a single enabled backend in single enabled backend pool.
        """
        return pulumi.get(self, "enabled_state")

    @property
    @pulumi.getter(name="healthProbeMethod")
    def health_probe_method(self) -> Optional[str]:
        """
        Configures which HTTP method to use to probe the backends defined under backendPools.
        """
        return pulumi.get(self, "health_probe_method")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> Optional[float]:
        """
        The number of seconds between health probes.
        """
        return pulumi.get(self, "interval_in_seconds")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to use for the health probe. Default is /
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol scheme to use for this probe
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="resourceState")
    def resource_state(self) -> Optional[str]:
        """
        Resource status.
        """
        return pulumi.get(self, "resource_state")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeyVaultCertificateSourceParametersResponseVault(dict):
    """
    The Key Vault containing the SSL certificate
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        The Key Vault containing the SSL certificate
        :param str id: Resource ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LoadBalancingSettingsModelResponse(dict):
    """
    Load balancing settings for a backend pool
    """
    def __init__(__self__, *,
                 type: str,
                 additional_latency_milliseconds: Optional[float] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 resource_state: Optional[str] = None,
                 sample_size: Optional[float] = None,
                 successful_samples_required: Optional[float] = None):
        """
        Load balancing settings for a backend pool
        :param str type: Resource type.
        :param float additional_latency_milliseconds: The additional latency in milliseconds for probes to fall into the lowest latency bucket
        :param str id: Resource ID.
        :param str name: Resource name.
        :param str resource_state: Resource status.
        :param float sample_size: The number of samples to consider for load balancing decisions
        :param float successful_samples_required: The number of samples within the sample period that must succeed
        """
        pulumi.set(__self__, "type", type)
        if additional_latency_milliseconds is not None:
            pulumi.set(__self__, "additional_latency_milliseconds", additional_latency_milliseconds)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_state is not None:
            pulumi.set(__self__, "resource_state", resource_state)
        if sample_size is not None:
            pulumi.set(__self__, "sample_size", sample_size)
        if successful_samples_required is not None:
            pulumi.set(__self__, "successful_samples_required", successful_samples_required)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="additionalLatencyMilliseconds")
    def additional_latency_milliseconds(self) -> Optional[float]:
        """
        The additional latency in milliseconds for probes to fall into the lowest latency bucket
        """
        return pulumi.get(self, "additional_latency_milliseconds")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceState")
    def resource_state(self) -> Optional[str]:
        """
        Resource status.
        """
        return pulumi.get(self, "resource_state")

    @property
    @pulumi.getter(name="sampleSize")
    def sample_size(self) -> Optional[float]:
        """
        The number of samples to consider for load balancing decisions
        """
        return pulumi.get(self, "sample_size")

    @property
    @pulumi.getter(name="successfulSamplesRequired")
    def successful_samples_required(self) -> Optional[float]:
        """
        The number of samples within the sample period that must succeed
        """
        return pulumi.get(self, "successful_samples_required")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RouteConfigurationResponse(dict):
    """
    Base class for all types of Route.
    """
    def __init__(__self__, *,
                 odata_type: str):
        """
        Base class for all types of Route.
        """
        pulumi.set(__self__, "odata_type", odata_type)

    @property
    @pulumi.getter(name="odataType")
    def odata_type(self) -> str:
        return pulumi.get(self, "odata_type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RoutingRuleResponse(dict):
    """
    A routing rule represents a specification for traffic to treat and where to send it, along with health probe information.
    """
    def __init__(__self__, *,
                 type: str,
                 accepted_protocols: Optional[List[str]] = None,
                 enabled_state: Optional[str] = None,
                 frontend_endpoints: Optional[List['outputs.SubResourceResponse']] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 patterns_to_match: Optional[List[str]] = None,
                 resource_state: Optional[str] = None,
                 route_configuration: Optional['outputs.RouteConfigurationResponse'] = None):
        """
        A routing rule represents a specification for traffic to treat and where to send it, along with health probe information.
        :param str type: Resource type.
        :param List[str] accepted_protocols: Protocol schemes to match for this rule
        :param str enabled_state: Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
        :param List['SubResourceResponseArgs'] frontend_endpoints: Frontend endpoints associated with this rule
        :param str id: Resource ID.
        :param str name: Resource name.
        :param List[str] patterns_to_match: The route patterns of the rule.
        :param str resource_state: Resource status.
        :param 'RouteConfigurationResponseArgs' route_configuration: A reference to the routing configuration.
        """
        pulumi.set(__self__, "type", type)
        if accepted_protocols is not None:
            pulumi.set(__self__, "accepted_protocols", accepted_protocols)
        if enabled_state is not None:
            pulumi.set(__self__, "enabled_state", enabled_state)
        if frontend_endpoints is not None:
            pulumi.set(__self__, "frontend_endpoints", frontend_endpoints)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if patterns_to_match is not None:
            pulumi.set(__self__, "patterns_to_match", patterns_to_match)
        if resource_state is not None:
            pulumi.set(__self__, "resource_state", resource_state)
        if route_configuration is not None:
            pulumi.set(__self__, "route_configuration", route_configuration)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="acceptedProtocols")
    def accepted_protocols(self) -> Optional[List[str]]:
        """
        Protocol schemes to match for this rule
        """
        return pulumi.get(self, "accepted_protocols")

    @property
    @pulumi.getter(name="enabledState")
    def enabled_state(self) -> Optional[str]:
        """
        Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
        """
        return pulumi.get(self, "enabled_state")

    @property
    @pulumi.getter(name="frontendEndpoints")
    def frontend_endpoints(self) -> Optional[List['outputs.SubResourceResponse']]:
        """
        Frontend endpoints associated with this rule
        """
        return pulumi.get(self, "frontend_endpoints")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="patternsToMatch")
    def patterns_to_match(self) -> Optional[List[str]]:
        """
        The route patterns of the rule.
        """
        return pulumi.get(self, "patterns_to_match")

    @property
    @pulumi.getter(name="resourceState")
    def resource_state(self) -> Optional[str]:
        """
        Resource status.
        """
        return pulumi.get(self, "resource_state")

    @property
    @pulumi.getter(name="routeConfiguration")
    def route_configuration(self) -> Optional['outputs.RouteConfigurationResponse']:
        """
        A reference to the routing configuration.
        """
        return pulumi.get(self, "route_configuration")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubResourceResponse(dict):
    """
    Reference to another subresource.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        Reference to another subresource.
        :param str id: Resource ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


