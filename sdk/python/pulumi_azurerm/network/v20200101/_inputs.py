# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Dict, List, Mapping, Optional, Tuple, Union
from ... import _utilities, _tables

__all__ = [
    'BackendArgs',
    'BackendPoolArgs',
    'BackendPoolsSettingsArgs',
    'FrontendEndpointArgs',
    'FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLinkArgs',
    'HeaderActionArgs',
    'HealthProbeSettingsModelArgs',
    'LoadBalancingSettingsModelArgs',
    'RouteConfigurationArgs',
    'RoutingRuleArgs',
    'RulesEngineActionArgs',
    'RulesEngineMatchConditionArgs',
    'RulesEngineRuleArgs',
    'SubResourceArgs',
]

@pulumi.input_type
class BackendArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 backend_host_header: Optional[pulumi.Input[str]] = None,
                 enabled_state: Optional[pulumi.Input[str]] = None,
                 http_port: Optional[pulumi.Input[float]] = None,
                 https_port: Optional[pulumi.Input[float]] = None,
                 priority: Optional[pulumi.Input[float]] = None,
                 private_link_alias: Optional[pulumi.Input[str]] = None,
                 private_link_approval_message: Optional[pulumi.Input[str]] = None,
                 weight: Optional[pulumi.Input[float]] = None):
        """
        Backend address of a frontDoor load balancer.
        :param pulumi.Input[str] address: Location of the backend (IP address or FQDN)
        :param pulumi.Input[str] backend_host_header: The value to use as the host header sent to the backend. If blank or unspecified, this defaults to the incoming host.
        :param pulumi.Input[str] enabled_state: Whether to enable use of this backend. Permitted values are 'Enabled' or 'Disabled'
        :param pulumi.Input[float] http_port: The HTTP TCP port number. Must be between 1 and 65535.
        :param pulumi.Input[float] https_port: The HTTPS TCP port number. Must be between 1 and 65535.
        :param pulumi.Input[float] priority: Priority to use for load balancing. Higher priorities will not be used for load balancing if any lower priority backend is healthy.
        :param pulumi.Input[str] private_link_alias: The Alias of the Private Link resource. Populating this optional field indicates that this backend is 'Private'
        :param pulumi.Input[str] private_link_approval_message: A custom message to be included in the approval request to connect to the Private Link
        :param pulumi.Input[float] weight: Weight of this endpoint for load balancing purposes.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if backend_host_header is not None:
            pulumi.set(__self__, "backend_host_header", backend_host_header)
        if enabled_state is not None:
            pulumi.set(__self__, "enabled_state", enabled_state)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if private_link_alias is not None:
            pulumi.set(__self__, "private_link_alias", private_link_alias)
        if private_link_approval_message is not None:
            pulumi.set(__self__, "private_link_approval_message", private_link_approval_message)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        Location of the backend (IP address or FQDN)
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="backendHostHeader")
    def backend_host_header(self) -> Optional[pulumi.Input[str]]:
        """
        The value to use as the host header sent to the backend. If blank or unspecified, this defaults to the incoming host.
        """
        return pulumi.get(self, "backend_host_header")

    @backend_host_header.setter
    def backend_host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backend_host_header", value)

    @property
    @pulumi.getter(name="enabledState")
    def enabled_state(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to enable use of this backend. Permitted values are 'Enabled' or 'Disabled'
        """
        return pulumi.get(self, "enabled_state")

    @enabled_state.setter
    def enabled_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enabled_state", value)

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[pulumi.Input[float]]:
        """
        The HTTP TCP port number. Must be between 1 and 65535.
        """
        return pulumi.get(self, "http_port")

    @http_port.setter
    def http_port(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "http_port", value)

    @property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[pulumi.Input[float]]:
        """
        The HTTPS TCP port number. Must be between 1 and 65535.
        """
        return pulumi.get(self, "https_port")

    @https_port.setter
    def https_port(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "https_port", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[float]]:
        """
        Priority to use for load balancing. Higher priorities will not be used for load balancing if any lower priority backend is healthy.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="privateLinkAlias")
    def private_link_alias(self) -> Optional[pulumi.Input[str]]:
        """
        The Alias of the Private Link resource. Populating this optional field indicates that this backend is 'Private'
        """
        return pulumi.get(self, "private_link_alias")

    @private_link_alias.setter
    def private_link_alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_link_alias", value)

    @property
    @pulumi.getter(name="privateLinkApprovalMessage")
    def private_link_approval_message(self) -> Optional[pulumi.Input[str]]:
        """
        A custom message to be included in the approval request to connect to the Private Link
        """
        return pulumi.get(self, "private_link_approval_message")

    @private_link_approval_message.setter
    def private_link_approval_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_link_approval_message", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[float]]:
        """
        Weight of this endpoint for load balancing purposes.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class BackendPoolArgs:
    def __init__(__self__, *,
                 backends: Optional[pulumi.Input[List[pulumi.Input['BackendArgs']]]] = None,
                 health_probe_settings: Optional[pulumi.Input['SubResourceArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 load_balancing_settings: Optional[pulumi.Input['SubResourceArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 resource_state: Optional[pulumi.Input[str]] = None):
        """
        A backend pool is a collection of backends that can be routed to.
        :param pulumi.Input[List[pulumi.Input['BackendArgs']]] backends: The set of backends for this pool
        :param pulumi.Input['SubResourceArgs'] health_probe_settings: L7 health probe settings for a backend pool
        :param pulumi.Input[str] id: Resource ID.
        :param pulumi.Input['SubResourceArgs'] load_balancing_settings: Load balancing settings for a backend pool
        :param pulumi.Input[str] name: Resource name.
        :param pulumi.Input[str] resource_state: Resource status.
        """
        if backends is not None:
            pulumi.set(__self__, "backends", backends)
        if health_probe_settings is not None:
            pulumi.set(__self__, "health_probe_settings", health_probe_settings)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if load_balancing_settings is not None:
            pulumi.set(__self__, "load_balancing_settings", load_balancing_settings)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_state is not None:
            pulumi.set(__self__, "resource_state", resource_state)

    @property
    @pulumi.getter
    def backends(self) -> Optional[pulumi.Input[List[pulumi.Input['BackendArgs']]]]:
        """
        The set of backends for this pool
        """
        return pulumi.get(self, "backends")

    @backends.setter
    def backends(self, value: Optional[pulumi.Input[List[pulumi.Input['BackendArgs']]]]):
        pulumi.set(self, "backends", value)

    @property
    @pulumi.getter(name="healthProbeSettings")
    def health_probe_settings(self) -> Optional[pulumi.Input['SubResourceArgs']]:
        """
        L7 health probe settings for a backend pool
        """
        return pulumi.get(self, "health_probe_settings")

    @health_probe_settings.setter
    def health_probe_settings(self, value: Optional[pulumi.Input['SubResourceArgs']]):
        pulumi.set(self, "health_probe_settings", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="loadBalancingSettings")
    def load_balancing_settings(self) -> Optional[pulumi.Input['SubResourceArgs']]:
        """
        Load balancing settings for a backend pool
        """
        return pulumi.get(self, "load_balancing_settings")

    @load_balancing_settings.setter
    def load_balancing_settings(self, value: Optional[pulumi.Input['SubResourceArgs']]):
        pulumi.set(self, "load_balancing_settings", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="resourceState")
    def resource_state(self) -> Optional[pulumi.Input[str]]:
        """
        Resource status.
        """
        return pulumi.get(self, "resource_state")

    @resource_state.setter
    def resource_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_state", value)


@pulumi.input_type
class BackendPoolsSettingsArgs:
    def __init__(__self__, *,
                 enforce_certificate_name_check: Optional[pulumi.Input[str]] = None,
                 send_recv_timeout_seconds: Optional[pulumi.Input[float]] = None):
        """
        Settings that apply to all backend pools.
        :param pulumi.Input[str] enforce_certificate_name_check: Whether to enforce certificate name check on HTTPS requests to all backend pools. No effect on non-HTTPS requests.
        :param pulumi.Input[float] send_recv_timeout_seconds: Send and receive timeout on forwarding request to the backend. When timeout is reached, the request fails and returns.
        """
        if enforce_certificate_name_check is not None:
            pulumi.set(__self__, "enforce_certificate_name_check", enforce_certificate_name_check)
        if send_recv_timeout_seconds is not None:
            pulumi.set(__self__, "send_recv_timeout_seconds", send_recv_timeout_seconds)

    @property
    @pulumi.getter(name="enforceCertificateNameCheck")
    def enforce_certificate_name_check(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to enforce certificate name check on HTTPS requests to all backend pools. No effect on non-HTTPS requests.
        """
        return pulumi.get(self, "enforce_certificate_name_check")

    @enforce_certificate_name_check.setter
    def enforce_certificate_name_check(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enforce_certificate_name_check", value)

    @property
    @pulumi.getter(name="sendRecvTimeoutSeconds")
    def send_recv_timeout_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        Send and receive timeout on forwarding request to the backend. When timeout is reached, the request fails and returns.
        """
        return pulumi.get(self, "send_recv_timeout_seconds")

    @send_recv_timeout_seconds.setter
    def send_recv_timeout_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "send_recv_timeout_seconds", value)


@pulumi.input_type
class FrontendEndpointArgs:
    def __init__(__self__, *,
                 host_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 resource_state: Optional[pulumi.Input[str]] = None,
                 session_affinity_enabled_state: Optional[pulumi.Input[str]] = None,
                 session_affinity_ttl_seconds: Optional[pulumi.Input[float]] = None,
                 web_application_firewall_policy_link: Optional[pulumi.Input['FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLinkArgs']] = None):
        """
        A frontend endpoint used for routing.
        :param pulumi.Input[str] host_name: The host name of the frontendEndpoint. Must be a domain name.
        :param pulumi.Input[str] id: Resource ID.
        :param pulumi.Input[str] name: Resource name.
        :param pulumi.Input[str] resource_state: Resource status.
        :param pulumi.Input[str] session_affinity_enabled_state: Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'
        :param pulumi.Input[float] session_affinity_ttl_seconds: UNUSED. This field will be ignored. The TTL to use in seconds for session affinity, if applicable.
        :param pulumi.Input['FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLinkArgs'] web_application_firewall_policy_link: Defines the Web Application Firewall policy for each host (if applicable)
        """
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_state is not None:
            pulumi.set(__self__, "resource_state", resource_state)
        if session_affinity_enabled_state is not None:
            pulumi.set(__self__, "session_affinity_enabled_state", session_affinity_enabled_state)
        if session_affinity_ttl_seconds is not None:
            pulumi.set(__self__, "session_affinity_ttl_seconds", session_affinity_ttl_seconds)
        if web_application_firewall_policy_link is not None:
            pulumi.set(__self__, "web_application_firewall_policy_link", web_application_firewall_policy_link)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input[str]]:
        """
        The host name of the frontendEndpoint. Must be a domain name.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="resourceState")
    def resource_state(self) -> Optional[pulumi.Input[str]]:
        """
        Resource status.
        """
        return pulumi.get(self, "resource_state")

    @resource_state.setter
    def resource_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_state", value)

    @property
    @pulumi.getter(name="sessionAffinityEnabledState")
    def session_affinity_enabled_state(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'
        """
        return pulumi.get(self, "session_affinity_enabled_state")

    @session_affinity_enabled_state.setter
    def session_affinity_enabled_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_affinity_enabled_state", value)

    @property
    @pulumi.getter(name="sessionAffinityTtlSeconds")
    def session_affinity_ttl_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        UNUSED. This field will be ignored. The TTL to use in seconds for session affinity, if applicable.
        """
        return pulumi.get(self, "session_affinity_ttl_seconds")

    @session_affinity_ttl_seconds.setter
    def session_affinity_ttl_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "session_affinity_ttl_seconds", value)

    @property
    @pulumi.getter(name="webApplicationFirewallPolicyLink")
    def web_application_firewall_policy_link(self) -> Optional[pulumi.Input['FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLinkArgs']]:
        """
        Defines the Web Application Firewall policy for each host (if applicable)
        """
        return pulumi.get(self, "web_application_firewall_policy_link")

    @web_application_firewall_policy_link.setter
    def web_application_firewall_policy_link(self, value: Optional[pulumi.Input['FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLinkArgs']]):
        pulumi.set(self, "web_application_firewall_policy_link", value)


@pulumi.input_type
class FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLinkArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        Defines the Web Application Firewall policy for each host (if applicable)
        :param pulumi.Input[str] id: Resource ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class HeaderActionArgs:
    def __init__(__self__, *,
                 header_action_type: pulumi.Input[str],
                 header_name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        An action that can manipulate an http header.
        :param pulumi.Input[str] header_action_type: Which type of manipulation to apply to the header.
        :param pulumi.Input[str] header_name: The name of the header this action will apply to.
        :param pulumi.Input[str] value: The value to update the given header name with. This value is not used if the actionType is Delete.
        """
        pulumi.set(__self__, "header_action_type", header_action_type)
        pulumi.set(__self__, "header_name", header_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="headerActionType")
    def header_action_type(self) -> pulumi.Input[str]:
        """
        Which type of manipulation to apply to the header.
        """
        return pulumi.get(self, "header_action_type")

    @header_action_type.setter
    def header_action_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_action_type", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        The name of the header this action will apply to.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value to update the given header name with. This value is not used if the actionType is Delete.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class HealthProbeSettingsModelArgs:
    def __init__(__self__, *,
                 enabled_state: Optional[pulumi.Input[str]] = None,
                 health_probe_method: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 interval_in_seconds: Optional[pulumi.Input[float]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 resource_state: Optional[pulumi.Input[str]] = None):
        """
        Load balancing settings for a backend pool
        :param pulumi.Input[str] enabled_state: Whether to enable health probes to be made against backends defined under backendPools. Health probes can only be disabled if there is a single enabled backend in single enabled backend pool.
        :param pulumi.Input[str] health_probe_method: Configures which HTTP method to use to probe the backends defined under backendPools.
        :param pulumi.Input[str] id: Resource ID.
        :param pulumi.Input[float] interval_in_seconds: The number of seconds between health probes.
        :param pulumi.Input[str] name: Resource name.
        :param pulumi.Input[str] path: The path to use for the health probe. Default is /
        :param pulumi.Input[str] protocol: Protocol scheme to use for this probe
        :param pulumi.Input[str] resource_state: Resource status.
        """
        if enabled_state is not None:
            pulumi.set(__self__, "enabled_state", enabled_state)
        if health_probe_method is not None:
            pulumi.set(__self__, "health_probe_method", health_probe_method)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if interval_in_seconds is not None:
            pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if resource_state is not None:
            pulumi.set(__self__, "resource_state", resource_state)

    @property
    @pulumi.getter(name="enabledState")
    def enabled_state(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to enable health probes to be made against backends defined under backendPools. Health probes can only be disabled if there is a single enabled backend in single enabled backend pool.
        """
        return pulumi.get(self, "enabled_state")

    @enabled_state.setter
    def enabled_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enabled_state", value)

    @property
    @pulumi.getter(name="healthProbeMethod")
    def health_probe_method(self) -> Optional[pulumi.Input[str]]:
        """
        Configures which HTTP method to use to probe the backends defined under backendPools.
        """
        return pulumi.get(self, "health_probe_method")

    @health_probe_method.setter
    def health_probe_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_probe_method", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        The number of seconds between health probes.
        """
        return pulumi.get(self, "interval_in_seconds")

    @interval_in_seconds.setter
    def interval_in_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "interval_in_seconds", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to use for the health probe. Default is /
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Protocol scheme to use for this probe
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="resourceState")
    def resource_state(self) -> Optional[pulumi.Input[str]]:
        """
        Resource status.
        """
        return pulumi.get(self, "resource_state")

    @resource_state.setter
    def resource_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_state", value)


@pulumi.input_type
class LoadBalancingSettingsModelArgs:
    def __init__(__self__, *,
                 additional_latency_milliseconds: Optional[pulumi.Input[float]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 resource_state: Optional[pulumi.Input[str]] = None,
                 sample_size: Optional[pulumi.Input[float]] = None,
                 successful_samples_required: Optional[pulumi.Input[float]] = None):
        """
        Load balancing settings for a backend pool
        :param pulumi.Input[float] additional_latency_milliseconds: The additional latency in milliseconds for probes to fall into the lowest latency bucket
        :param pulumi.Input[str] id: Resource ID.
        :param pulumi.Input[str] name: Resource name.
        :param pulumi.Input[str] resource_state: Resource status.
        :param pulumi.Input[float] sample_size: The number of samples to consider for load balancing decisions
        :param pulumi.Input[float] successful_samples_required: The number of samples within the sample period that must succeed
        """
        if additional_latency_milliseconds is not None:
            pulumi.set(__self__, "additional_latency_milliseconds", additional_latency_milliseconds)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_state is not None:
            pulumi.set(__self__, "resource_state", resource_state)
        if sample_size is not None:
            pulumi.set(__self__, "sample_size", sample_size)
        if successful_samples_required is not None:
            pulumi.set(__self__, "successful_samples_required", successful_samples_required)

    @property
    @pulumi.getter(name="additionalLatencyMilliseconds")
    def additional_latency_milliseconds(self) -> Optional[pulumi.Input[float]]:
        """
        The additional latency in milliseconds for probes to fall into the lowest latency bucket
        """
        return pulumi.get(self, "additional_latency_milliseconds")

    @additional_latency_milliseconds.setter
    def additional_latency_milliseconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "additional_latency_milliseconds", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="resourceState")
    def resource_state(self) -> Optional[pulumi.Input[str]]:
        """
        Resource status.
        """
        return pulumi.get(self, "resource_state")

    @resource_state.setter
    def resource_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_state", value)

    @property
    @pulumi.getter(name="sampleSize")
    def sample_size(self) -> Optional[pulumi.Input[float]]:
        """
        The number of samples to consider for load balancing decisions
        """
        return pulumi.get(self, "sample_size")

    @sample_size.setter
    def sample_size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "sample_size", value)

    @property
    @pulumi.getter(name="successfulSamplesRequired")
    def successful_samples_required(self) -> Optional[pulumi.Input[float]]:
        """
        The number of samples within the sample period that must succeed
        """
        return pulumi.get(self, "successful_samples_required")

    @successful_samples_required.setter
    def successful_samples_required(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "successful_samples_required", value)


@pulumi.input_type
class RouteConfigurationArgs:
    def __init__(__self__, *,
                 odata_type: pulumi.Input[str]):
        """
        Base class for all types of Route.
        """
        pulumi.set(__self__, "odata_type", odata_type)

    @property
    @pulumi.getter(name="odataType")
    def odata_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "odata_type")

    @odata_type.setter
    def odata_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "odata_type", value)


@pulumi.input_type
class RoutingRuleArgs:
    def __init__(__self__, *,
                 accepted_protocols: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 enabled_state: Optional[pulumi.Input[str]] = None,
                 frontend_endpoints: Optional[pulumi.Input[List[pulumi.Input['SubResourceArgs']]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 patterns_to_match: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 resource_state: Optional[pulumi.Input[str]] = None,
                 route_configuration: Optional[pulumi.Input['RouteConfigurationArgs']] = None,
                 rules_engine: Optional[pulumi.Input['SubResourceArgs']] = None):
        """
        A routing rule represents a specification for traffic to treat and where to send it, along with health probe information.
        :param pulumi.Input[List[pulumi.Input[str]]] accepted_protocols: Protocol schemes to match for this rule
        :param pulumi.Input[str] enabled_state: Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
        :param pulumi.Input[List[pulumi.Input['SubResourceArgs']]] frontend_endpoints: Frontend endpoints associated with this rule
        :param pulumi.Input[str] id: Resource ID.
        :param pulumi.Input[str] name: Resource name.
        :param pulumi.Input[List[pulumi.Input[str]]] patterns_to_match: The route patterns of the rule.
        :param pulumi.Input[str] resource_state: Resource status.
        :param pulumi.Input['RouteConfigurationArgs'] route_configuration: A reference to the routing configuration.
        :param pulumi.Input['SubResourceArgs'] rules_engine: A reference to a specific Rules Engine Configuration to apply to this route.
        """
        if accepted_protocols is not None:
            pulumi.set(__self__, "accepted_protocols", accepted_protocols)
        if enabled_state is not None:
            pulumi.set(__self__, "enabled_state", enabled_state)
        if frontend_endpoints is not None:
            pulumi.set(__self__, "frontend_endpoints", frontend_endpoints)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if patterns_to_match is not None:
            pulumi.set(__self__, "patterns_to_match", patterns_to_match)
        if resource_state is not None:
            pulumi.set(__self__, "resource_state", resource_state)
        if route_configuration is not None:
            pulumi.set(__self__, "route_configuration", route_configuration)
        if rules_engine is not None:
            pulumi.set(__self__, "rules_engine", rules_engine)

    @property
    @pulumi.getter(name="acceptedProtocols")
    def accepted_protocols(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        Protocol schemes to match for this rule
        """
        return pulumi.get(self, "accepted_protocols")

    @accepted_protocols.setter
    def accepted_protocols(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "accepted_protocols", value)

    @property
    @pulumi.getter(name="enabledState")
    def enabled_state(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
        """
        return pulumi.get(self, "enabled_state")

    @enabled_state.setter
    def enabled_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enabled_state", value)

    @property
    @pulumi.getter(name="frontendEndpoints")
    def frontend_endpoints(self) -> Optional[pulumi.Input[List[pulumi.Input['SubResourceArgs']]]]:
        """
        Frontend endpoints associated with this rule
        """
        return pulumi.get(self, "frontend_endpoints")

    @frontend_endpoints.setter
    def frontend_endpoints(self, value: Optional[pulumi.Input[List[pulumi.Input['SubResourceArgs']]]]):
        pulumi.set(self, "frontend_endpoints", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="patternsToMatch")
    def patterns_to_match(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        The route patterns of the rule.
        """
        return pulumi.get(self, "patterns_to_match")

    @patterns_to_match.setter
    def patterns_to_match(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "patterns_to_match", value)

    @property
    @pulumi.getter(name="resourceState")
    def resource_state(self) -> Optional[pulumi.Input[str]]:
        """
        Resource status.
        """
        return pulumi.get(self, "resource_state")

    @resource_state.setter
    def resource_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_state", value)

    @property
    @pulumi.getter(name="routeConfiguration")
    def route_configuration(self) -> Optional[pulumi.Input['RouteConfigurationArgs']]:
        """
        A reference to the routing configuration.
        """
        return pulumi.get(self, "route_configuration")

    @route_configuration.setter
    def route_configuration(self, value: Optional[pulumi.Input['RouteConfigurationArgs']]):
        pulumi.set(self, "route_configuration", value)

    @property
    @pulumi.getter(name="rulesEngine")
    def rules_engine(self) -> Optional[pulumi.Input['SubResourceArgs']]:
        """
        A reference to a specific Rules Engine Configuration to apply to this route.
        """
        return pulumi.get(self, "rules_engine")

    @rules_engine.setter
    def rules_engine(self, value: Optional[pulumi.Input['SubResourceArgs']]):
        pulumi.set(self, "rules_engine", value)


@pulumi.input_type
class RulesEngineActionArgs:
    def __init__(__self__, *,
                 request_header_actions: Optional[pulumi.Input[List[pulumi.Input['HeaderActionArgs']]]] = None,
                 response_header_actions: Optional[pulumi.Input[List[pulumi.Input['HeaderActionArgs']]]] = None,
                 route_configuration_override: Optional[pulumi.Input['RouteConfigurationArgs']] = None):
        """
        One or more actions that will execute, modifying the request and/or response.
        :param pulumi.Input[List[pulumi.Input['HeaderActionArgs']]] request_header_actions: A list of header actions to apply from the request from AFD to the origin.
        :param pulumi.Input[List[pulumi.Input['HeaderActionArgs']]] response_header_actions: A list of header actions to apply from the response from AFD to the client.
        :param pulumi.Input['RouteConfigurationArgs'] route_configuration_override: Override the route configuration.
        """
        if request_header_actions is not None:
            pulumi.set(__self__, "request_header_actions", request_header_actions)
        if response_header_actions is not None:
            pulumi.set(__self__, "response_header_actions", response_header_actions)
        if route_configuration_override is not None:
            pulumi.set(__self__, "route_configuration_override", route_configuration_override)

    @property
    @pulumi.getter(name="requestHeaderActions")
    def request_header_actions(self) -> Optional[pulumi.Input[List[pulumi.Input['HeaderActionArgs']]]]:
        """
        A list of header actions to apply from the request from AFD to the origin.
        """
        return pulumi.get(self, "request_header_actions")

    @request_header_actions.setter
    def request_header_actions(self, value: Optional[pulumi.Input[List[pulumi.Input['HeaderActionArgs']]]]):
        pulumi.set(self, "request_header_actions", value)

    @property
    @pulumi.getter(name="responseHeaderActions")
    def response_header_actions(self) -> Optional[pulumi.Input[List[pulumi.Input['HeaderActionArgs']]]]:
        """
        A list of header actions to apply from the response from AFD to the client.
        """
        return pulumi.get(self, "response_header_actions")

    @response_header_actions.setter
    def response_header_actions(self, value: Optional[pulumi.Input[List[pulumi.Input['HeaderActionArgs']]]]):
        pulumi.set(self, "response_header_actions", value)

    @property
    @pulumi.getter(name="routeConfigurationOverride")
    def route_configuration_override(self) -> Optional[pulumi.Input['RouteConfigurationArgs']]:
        """
        Override the route configuration.
        """
        return pulumi.get(self, "route_configuration_override")

    @route_configuration_override.setter
    def route_configuration_override(self, value: Optional[pulumi.Input['RouteConfigurationArgs']]):
        pulumi.set(self, "route_configuration_override", value)


@pulumi.input_type
class RulesEngineMatchConditionArgs:
    def __init__(__self__, *,
                 rules_engine_match_value: pulumi.Input[List[pulumi.Input[str]]],
                 rules_engine_match_variable: pulumi.Input[str],
                 rules_engine_operator: pulumi.Input[str],
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 selector: Optional[pulumi.Input[str]] = None,
                 transforms: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None):
        """
        Define a match condition
        :param pulumi.Input[List[pulumi.Input[str]]] rules_engine_match_value: Match values to match against. The operator will apply to each value in here with OR semantics. If any of them match the variable with the given operator this match condition is considered a match.
        :param pulumi.Input[str] rules_engine_match_variable: Match Variable
        :param pulumi.Input[str] rules_engine_operator: Describes operator to apply to the match condition.
        :param pulumi.Input[bool] negate_condition: Describes if this is negate condition or not
        :param pulumi.Input[str] selector: Name of selector in RequestHeader or RequestBody to be matched
        :param pulumi.Input[List[pulumi.Input[str]]] transforms: List of transforms
        """
        pulumi.set(__self__, "rules_engine_match_value", rules_engine_match_value)
        pulumi.set(__self__, "rules_engine_match_variable", rules_engine_match_variable)
        pulumi.set(__self__, "rules_engine_operator", rules_engine_operator)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter(name="rulesEngineMatchValue")
    def rules_engine_match_value(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        Match values to match against. The operator will apply to each value in here with OR semantics. If any of them match the variable with the given operator this match condition is considered a match.
        """
        return pulumi.get(self, "rules_engine_match_value")

    @rules_engine_match_value.setter
    def rules_engine_match_value(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "rules_engine_match_value", value)

    @property
    @pulumi.getter(name="rulesEngineMatchVariable")
    def rules_engine_match_variable(self) -> pulumi.Input[str]:
        """
        Match Variable
        """
        return pulumi.get(self, "rules_engine_match_variable")

    @rules_engine_match_variable.setter
    def rules_engine_match_variable(self, value: pulumi.Input[str]):
        pulumi.set(self, "rules_engine_match_variable", value)

    @property
    @pulumi.getter(name="rulesEngineOperator")
    def rules_engine_operator(self) -> pulumi.Input[str]:
        """
        Describes operator to apply to the match condition.
        """
        return pulumi.get(self, "rules_engine_operator")

    @rules_engine_operator.setter
    def rules_engine_operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "rules_engine_operator", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[str]]:
        """
        Name of selector in RequestHeader or RequestBody to be matched
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class RulesEngineRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['RulesEngineActionArgs'],
                 name: pulumi.Input[str],
                 priority: pulumi.Input[float],
                 match_conditions: Optional[pulumi.Input[List[pulumi.Input['RulesEngineMatchConditionArgs']]]] = None,
                 match_processing_behavior: Optional[pulumi.Input[str]] = None):
        """
        Contains a list of match conditions, and an action on how to modify the request/response. If multiple rules match, the actions from one rule that conflict with a previous rule overwrite for a singular action, or append in the case of headers manipulation.
        :param pulumi.Input['RulesEngineActionArgs'] action: Actions to perform on the request and response if all of the match conditions are met.
        :param pulumi.Input[str] name: A name to refer to this specific rule.
        :param pulumi.Input[float] priority: A priority assigned to this rule. 
        :param pulumi.Input[List[pulumi.Input['RulesEngineMatchConditionArgs']]] match_conditions: A list of match conditions that must meet in order for the actions of this rule to run. Having no match conditions means the actions will always run.
        :param pulumi.Input[str] match_processing_behavior: If this rule is a match should the rules engine continue running the remaining rules or stop. If not present, defaults to Continue.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        if match_conditions is not None:
            pulumi.set(__self__, "match_conditions", match_conditions)
        if match_processing_behavior is not None:
            pulumi.set(__self__, "match_processing_behavior", match_processing_behavior)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['RulesEngineActionArgs']:
        """
        Actions to perform on the request and response if all of the match conditions are met.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['RulesEngineActionArgs']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A name to refer to this specific rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[float]:
        """
        A priority assigned to this rule. 
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[float]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="matchConditions")
    def match_conditions(self) -> Optional[pulumi.Input[List[pulumi.Input['RulesEngineMatchConditionArgs']]]]:
        """
        A list of match conditions that must meet in order for the actions of this rule to run. Having no match conditions means the actions will always run.
        """
        return pulumi.get(self, "match_conditions")

    @match_conditions.setter
    def match_conditions(self, value: Optional[pulumi.Input[List[pulumi.Input['RulesEngineMatchConditionArgs']]]]):
        pulumi.set(self, "match_conditions", value)

    @property
    @pulumi.getter(name="matchProcessingBehavior")
    def match_processing_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        If this rule is a match should the rules engine continue running the remaining rules or stop. If not present, defaults to Continue.
        """
        return pulumi.get(self, "match_processing_behavior")

    @match_processing_behavior.setter
    def match_processing_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_processing_behavior", value)


@pulumi.input_type
class SubResourceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        Reference to another subresource.
        :param pulumi.Input[str] id: Resource ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


