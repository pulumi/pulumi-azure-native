# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'ACIServiceResponseResponse',
    'ACIServiceResponseResponseDataCollection',
    'ACIServiceResponseResponseEncryptionProperties',
    'ACIServiceResponseResponseEnvironmentImageRequest',
    'ACIServiceResponseResponseVnetConfiguration',
    'AKSResponse',
    'AKSResponseProperties',
    'AKSVariantResponseResponse',
    'AksNetworkingConfigurationResponse',
    'AmlComputeNodeInformationResponseResult',
    'AmlComputeResponse',
    'AmlComputeResponseProperties',
    'AzureDataLakeSectionResponse',
    'AzureMySqlSectionResponse',
    'AzurePostgreSqlSectionResponse',
    'AzureSqlDatabaseSectionResponse',
    'AzureStorageSectionResponse',
    'ClientCredentialsResponse',
    'ContainerResourceRequirementsResponse',
    'DataFactoryResponse',
    'DataLakeAnalyticsResponse',
    'DataLakeAnalyticsResponseProperties',
    'DatabricksResponse',
    'DatabricksResponseProperties',
    'DatasetReferenceResponse',
    'DatasetResponse',
    'DatasetResponseDataPath',
    'DatasetResponseLatest',
    'DatasetResponseSqlDataPath',
    'DatasetStateResponse',
    'DatasetStateResponseDeprecatedBy',
    'DatastoreResponse',
    'EncryptionPropertyResponse',
    'EnvironmentImageResponseResponseEnvironment',
    'EnvironmentImageResponseResponseEnvironmentReference',
    'ErrorDetailResponse',
    'ErrorResponseResponse',
    'GlusterFsSectionResponse',
    'HDInsightResponse',
    'HDInsightResponseProperties',
    'IdentityResponse',
    'ImageAssetResponse',
    'KeyVaultPropertiesResponse',
    'LinkedInfoResponse',
    'LinkedWorkspacePropsResponse',
    'MachineLearningServiceErrorResponse',
    'ModelDockerSectionResponseResponseBaseImageRegistry',
    'ModelEnvironmentDefinitionResponseResponseDocker',
    'ModelEnvironmentDefinitionResponseResponsePython',
    'ModelEnvironmentDefinitionResponseResponseR',
    'ModelEnvironmentDefinitionResponseResponseSpark',
    'ModelResponse',
    'NodeStateCountsResponse',
    'PasswordResponseResult',
    'PrivateEndpointConnectionResponse',
    'PrivateEndpointResponse',
    'PrivateLinkServiceConnectionStateResponse',
    'RCranPackageResponse',
    'RGitHubPackageResponseResponse',
    'RegistryListCredentialsResultResponseResult',
    'ResourceIdResponse',
    'ScaleSettingsResponse',
    'ServiceResponseBaseResponseError',
    'SharedPrivateLinkResourceResponse',
    'SkuResponse',
    'SparkMavenPackageResponse',
    'SslConfigurationResponse',
    'SystemServiceResponse',
    'UserAccountCredentialsResponse',
    'UserAssignedIdentityResponse',
    'UserInfoResponse',
    'VirtualMachineResponse',
    'VirtualMachineResponseProperties',
    'VirtualMachineSshCredentialsResponse',
]

@pulumi.output_type
class ACIServiceResponseResponse(dict):
    """
    The response for an ACI service.
    """
    def __init__(__self__, *,
                 compute_type: str,
                 error: 'outputs.ServiceResponseBaseResponseError',
                 model_config_map: Mapping[str, Any],
                 scoring_uri: str,
                 state: str,
                 swagger_uri: str,
                 app_insights_enabled: Optional[bool] = None,
                 auth_enabled: Optional[bool] = None,
                 cname: Optional[str] = None,
                 container_resource_requirements: Optional['outputs.ContainerResourceRequirementsResponse'] = None,
                 data_collection: Optional['outputs.ACIServiceResponseResponseDataCollection'] = None,
                 deployment_type: Optional[str] = None,
                 description: Optional[str] = None,
                 encryption_properties: Optional['outputs.ACIServiceResponseResponseEncryptionProperties'] = None,
                 environment_image_request: Optional['outputs.ACIServiceResponseResponseEnvironmentImageRequest'] = None,
                 kv_tags: Optional[Mapping[str, str]] = None,
                 location: Optional[str] = None,
                 models: Optional[Sequence['outputs.ModelResponse']] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 public_fqdn: Optional[str] = None,
                 public_ip: Optional[str] = None,
                 ssl_certificate: Optional[str] = None,
                 ssl_enabled: Optional[bool] = None,
                 ssl_key: Optional[str] = None,
                 vnet_configuration: Optional['outputs.ACIServiceResponseResponseVnetConfiguration'] = None):
        """
        The response for an ACI service.
        :param str compute_type: The compute environment type for the service.
        :param 'ServiceResponseBaseResponseErrorArgs' error: The error details.
        :param Mapping[str, Any] model_config_map: Details on the models and configurations.
        :param str scoring_uri: The Uri for sending scoring requests.
        :param str state: The current state of the service.
        :param str swagger_uri: The Uri for sending swagger requests.
        :param bool app_insights_enabled: Whether or not Application Insights is enabled.
        :param bool auth_enabled: Whether or not authentication is enabled on the service.
        :param str cname: The CName for the service.
        :param 'ContainerResourceRequirementsResponseArgs' container_resource_requirements: The container resource requirements.
        :param 'ACIServiceResponseResponseDataCollectionArgs' data_collection: Details of the data collection options specified.
        :param str deployment_type: The deployment type for the service.
        :param str description: The service description.
        :param 'ACIServiceResponseResponseEncryptionPropertiesArgs' encryption_properties: The encryption properties.
        :param 'ACIServiceResponseResponseEnvironmentImageRequestArgs' environment_image_request: The Environment, models and assets used for inferencing.
        :param Mapping[str, str] kv_tags: The service tag dictionary. Tags are mutable.
        :param str location: The name of the Azure location/region.
        :param Sequence['ModelResponseArgs'] models: The list of models.
        :param Mapping[str, str] properties: The service property dictionary. Properties are immutable.
        :param str public_fqdn: The public Fqdn for the service.
        :param str public_ip: The public IP address for the service.
        :param str ssl_certificate: The public SSL certificate in PEM format to use if SSL is enabled.
        :param bool ssl_enabled: Whether or not SSL is enabled.
        :param str ssl_key: The public SSL key in PEM format for the certificate.
        :param 'ACIServiceResponseResponseVnetConfigurationArgs' vnet_configuration: The virtual network configuration.
        """
        pulumi.set(__self__, "compute_type", 'ACI')
        pulumi.set(__self__, "error", error)
        pulumi.set(__self__, "model_config_map", model_config_map)
        pulumi.set(__self__, "scoring_uri", scoring_uri)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "swagger_uri", swagger_uri)
        if app_insights_enabled is not None:
            pulumi.set(__self__, "app_insights_enabled", app_insights_enabled)
        if auth_enabled is not None:
            pulumi.set(__self__, "auth_enabled", auth_enabled)
        if cname is not None:
            pulumi.set(__self__, "cname", cname)
        if container_resource_requirements is not None:
            pulumi.set(__self__, "container_resource_requirements", container_resource_requirements)
        if data_collection is not None:
            pulumi.set(__self__, "data_collection", data_collection)
        if deployment_type is not None:
            pulumi.set(__self__, "deployment_type", deployment_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encryption_properties is not None:
            pulumi.set(__self__, "encryption_properties", encryption_properties)
        if environment_image_request is not None:
            pulumi.set(__self__, "environment_image_request", environment_image_request)
        if kv_tags is not None:
            pulumi.set(__self__, "kv_tags", kv_tags)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if models is not None:
            pulumi.set(__self__, "models", models)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if public_fqdn is not None:
            pulumi.set(__self__, "public_fqdn", public_fqdn)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if ssl_certificate is not None:
            pulumi.set(__self__, "ssl_certificate", ssl_certificate)
        if ssl_enabled is not None:
            pulumi.set(__self__, "ssl_enabled", ssl_enabled)
        if ssl_key is not None:
            pulumi.set(__self__, "ssl_key", ssl_key)
        if vnet_configuration is not None:
            pulumi.set(__self__, "vnet_configuration", vnet_configuration)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> str:
        """
        The compute environment type for the service.
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter
    def error(self) -> 'outputs.ServiceResponseBaseResponseError':
        """
        The error details.
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter(name="modelConfigMap")
    def model_config_map(self) -> Mapping[str, Any]:
        """
        Details on the models and configurations.
        """
        return pulumi.get(self, "model_config_map")

    @property
    @pulumi.getter(name="scoringUri")
    def scoring_uri(self) -> str:
        """
        The Uri for sending scoring requests.
        """
        return pulumi.get(self, "scoring_uri")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the service.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="swaggerUri")
    def swagger_uri(self) -> str:
        """
        The Uri for sending swagger requests.
        """
        return pulumi.get(self, "swagger_uri")

    @property
    @pulumi.getter(name="appInsightsEnabled")
    def app_insights_enabled(self) -> Optional[bool]:
        """
        Whether or not Application Insights is enabled.
        """
        return pulumi.get(self, "app_insights_enabled")

    @property
    @pulumi.getter(name="authEnabled")
    def auth_enabled(self) -> Optional[bool]:
        """
        Whether or not authentication is enabled on the service.
        """
        return pulumi.get(self, "auth_enabled")

    @property
    @pulumi.getter
    def cname(self) -> Optional[str]:
        """
        The CName for the service.
        """
        return pulumi.get(self, "cname")

    @property
    @pulumi.getter(name="containerResourceRequirements")
    def container_resource_requirements(self) -> Optional['outputs.ContainerResourceRequirementsResponse']:
        """
        The container resource requirements.
        """
        return pulumi.get(self, "container_resource_requirements")

    @property
    @pulumi.getter(name="dataCollection")
    def data_collection(self) -> Optional['outputs.ACIServiceResponseResponseDataCollection']:
        """
        Details of the data collection options specified.
        """
        return pulumi.get(self, "data_collection")

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> Optional[str]:
        """
        The deployment type for the service.
        """
        return pulumi.get(self, "deployment_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptionProperties")
    def encryption_properties(self) -> Optional['outputs.ACIServiceResponseResponseEncryptionProperties']:
        """
        The encryption properties.
        """
        return pulumi.get(self, "encryption_properties")

    @property
    @pulumi.getter(name="environmentImageRequest")
    def environment_image_request(self) -> Optional['outputs.ACIServiceResponseResponseEnvironmentImageRequest']:
        """
        The Environment, models and assets used for inferencing.
        """
        return pulumi.get(self, "environment_image_request")

    @property
    @pulumi.getter(name="kvTags")
    def kv_tags(self) -> Optional[Mapping[str, str]]:
        """
        The service tag dictionary. Tags are mutable.
        """
        return pulumi.get(self, "kv_tags")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        The name of the Azure location/region.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def models(self) -> Optional[Sequence['outputs.ModelResponse']]:
        """
        The list of models.
        """
        return pulumi.get(self, "models")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The service property dictionary. Properties are immutable.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="publicFqdn")
    def public_fqdn(self) -> Optional[str]:
        """
        The public Fqdn for the service.
        """
        return pulumi.get(self, "public_fqdn")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[str]:
        """
        The public IP address for the service.
        """
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter(name="sslCertificate")
    def ssl_certificate(self) -> Optional[str]:
        """
        The public SSL certificate in PEM format to use if SSL is enabled.
        """
        return pulumi.get(self, "ssl_certificate")

    @property
    @pulumi.getter(name="sslEnabled")
    def ssl_enabled(self) -> Optional[bool]:
        """
        Whether or not SSL is enabled.
        """
        return pulumi.get(self, "ssl_enabled")

    @property
    @pulumi.getter(name="sslKey")
    def ssl_key(self) -> Optional[str]:
        """
        The public SSL key in PEM format for the certificate.
        """
        return pulumi.get(self, "ssl_key")

    @property
    @pulumi.getter(name="vnetConfiguration")
    def vnet_configuration(self) -> Optional['outputs.ACIServiceResponseResponseVnetConfiguration']:
        """
        The virtual network configuration.
        """
        return pulumi.get(self, "vnet_configuration")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ACIServiceResponseResponseDataCollection(dict):
    """
    Details of the data collection options specified.
    """
    def __init__(__self__, *,
                 event_hub_enabled: Optional[bool] = None,
                 storage_enabled: Optional[bool] = None):
        """
        Details of the data collection options specified.
        :param bool event_hub_enabled: Option for enabling/disabling Event Hub.
        :param bool storage_enabled: Option for enabling/disabling storage.
        """
        if event_hub_enabled is not None:
            pulumi.set(__self__, "event_hub_enabled", event_hub_enabled)
        if storage_enabled is not None:
            pulumi.set(__self__, "storage_enabled", storage_enabled)

    @property
    @pulumi.getter(name="eventHubEnabled")
    def event_hub_enabled(self) -> Optional[bool]:
        """
        Option for enabling/disabling Event Hub.
        """
        return pulumi.get(self, "event_hub_enabled")

    @property
    @pulumi.getter(name="storageEnabled")
    def storage_enabled(self) -> Optional[bool]:
        """
        Option for enabling/disabling storage.
        """
        return pulumi.get(self, "storage_enabled")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ACIServiceResponseResponseEncryptionProperties(dict):
    """
    The encryption properties.
    """
    def __init__(__self__, *,
                 key_name: str,
                 key_version: str,
                 vault_base_url: str):
        """
        The encryption properties.
        :param str key_name: Encryption Key name
        :param str key_version: Encryption Key Version
        :param str vault_base_url: vault base Url
        """
        pulumi.set(__self__, "key_name", key_name)
        pulumi.set(__self__, "key_version", key_version)
        pulumi.set(__self__, "vault_base_url", vault_base_url)

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> str:
        """
        Encryption Key name
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="keyVersion")
    def key_version(self) -> str:
        """
        Encryption Key Version
        """
        return pulumi.get(self, "key_version")

    @property
    @pulumi.getter(name="vaultBaseUrl")
    def vault_base_url(self) -> str:
        """
        vault base Url
        """
        return pulumi.get(self, "vault_base_url")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ACIServiceResponseResponseEnvironmentImageRequest(dict):
    """
    The Environment, models and assets used for inferencing.
    """
    def __init__(__self__, *,
                 assets: Optional[Sequence['outputs.ImageAssetResponse']] = None,
                 driver_program: Optional[str] = None,
                 environment: Optional['outputs.EnvironmentImageResponseResponseEnvironment'] = None,
                 environment_reference: Optional['outputs.EnvironmentImageResponseResponseEnvironmentReference'] = None,
                 model_ids: Optional[Sequence[str]] = None,
                 models: Optional[Sequence['outputs.ModelResponse']] = None):
        """
        The Environment, models and assets used for inferencing.
        :param Sequence['ImageAssetResponseArgs'] assets: The list of assets.
        :param str driver_program: The name of the driver file.
        :param 'EnvironmentImageResponseResponseEnvironmentArgs' environment: The details of the AZURE ML environment.
        :param 'EnvironmentImageResponseResponseEnvironmentReferenceArgs' environment_reference: The unique identifying details of the AZURE ML environment.
        :param Sequence[str] model_ids: The list of model Ids.
        :param Sequence['ModelResponseArgs'] models: The list of models.
        """
        if assets is not None:
            pulumi.set(__self__, "assets", assets)
        if driver_program is not None:
            pulumi.set(__self__, "driver_program", driver_program)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if environment_reference is not None:
            pulumi.set(__self__, "environment_reference", environment_reference)
        if model_ids is not None:
            pulumi.set(__self__, "model_ids", model_ids)
        if models is not None:
            pulumi.set(__self__, "models", models)

    @property
    @pulumi.getter
    def assets(self) -> Optional[Sequence['outputs.ImageAssetResponse']]:
        """
        The list of assets.
        """
        return pulumi.get(self, "assets")

    @property
    @pulumi.getter(name="driverProgram")
    def driver_program(self) -> Optional[str]:
        """
        The name of the driver file.
        """
        return pulumi.get(self, "driver_program")

    @property
    @pulumi.getter
    def environment(self) -> Optional['outputs.EnvironmentImageResponseResponseEnvironment']:
        """
        The details of the AZURE ML environment.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="environmentReference")
    def environment_reference(self) -> Optional['outputs.EnvironmentImageResponseResponseEnvironmentReference']:
        """
        The unique identifying details of the AZURE ML environment.
        """
        return pulumi.get(self, "environment_reference")

    @property
    @pulumi.getter(name="modelIds")
    def model_ids(self) -> Optional[Sequence[str]]:
        """
        The list of model Ids.
        """
        return pulumi.get(self, "model_ids")

    @property
    @pulumi.getter
    def models(self) -> Optional[Sequence['outputs.ModelResponse']]:
        """
        The list of models.
        """
        return pulumi.get(self, "models")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ACIServiceResponseResponseVnetConfiguration(dict):
    """
    The virtual network configuration.
    """
    def __init__(__self__, *,
                 subnet_name: Optional[str] = None,
                 vnet_name: Optional[str] = None):
        """
        The virtual network configuration.
        :param str subnet_name: The name of the virtual network subnet.
        :param str vnet_name: The name of the virtual network.
        """
        if subnet_name is not None:
            pulumi.set(__self__, "subnet_name", subnet_name)
        if vnet_name is not None:
            pulumi.set(__self__, "vnet_name", vnet_name)

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> Optional[str]:
        """
        The name of the virtual network subnet.
        """
        return pulumi.get(self, "subnet_name")

    @property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> Optional[str]:
        """
        The name of the virtual network.
        """
        return pulumi.get(self, "vnet_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AKSResponse(dict):
    """
    A Machine Learning compute based on AKS.
    """
    def __init__(__self__, *,
                 compute_type: str,
                 created_on: str,
                 is_attached_compute: bool,
                 modified_on: str,
                 provisioning_errors: Sequence['outputs.MachineLearningServiceErrorResponse'],
                 provisioning_state: str,
                 compute_location: Optional[str] = None,
                 description: Optional[str] = None,
                 properties: Optional['outputs.AKSResponseProperties'] = None,
                 resource_id: Optional[str] = None):
        """
        A Machine Learning compute based on AKS.
        :param str compute_type: The type of compute
        :param str created_on: The date and time when the compute was created.
        :param bool is_attached_compute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        :param str modified_on: The date and time when the compute was last modified.
        :param Sequence['MachineLearningServiceErrorResponseArgs'] provisioning_errors: Errors during provisioning
        :param str provisioning_state: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        :param str compute_location: Location for the underlying compute
        :param str description: The description of the Machine Learning compute.
        :param 'AKSResponsePropertiesArgs' properties: AKS properties
        :param str resource_id: ARM resource id of the underlying compute
        """
        pulumi.set(__self__, "compute_type", 'AKS')
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "is_attached_compute", is_attached_compute)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "provisioning_errors", provisioning_errors)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if compute_location is not None:
            pulumi.set(__self__, "compute_location", compute_location)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> str:
        """
        The type of compute
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        The date and time when the compute was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="isAttachedCompute")
    def is_attached_compute(self) -> bool:
        """
        Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        """
        return pulumi.get(self, "is_attached_compute")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        The date and time when the compute was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="provisioningErrors")
    def provisioning_errors(self) -> Sequence['outputs.MachineLearningServiceErrorResponse']:
        """
        Errors during provisioning
        """
        return pulumi.get(self, "provisioning_errors")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[str]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.AKSResponseProperties']:
        """
        AKS properties
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AKSResponseProperties(dict):
    """
    AKS properties
    """
    def __init__(__self__, *,
                 system_services: Sequence['outputs.SystemServiceResponse'],
                 agent_count: Optional[int] = None,
                 agent_vm_size: Optional[str] = None,
                 aks_networking_configuration: Optional['outputs.AksNetworkingConfigurationResponse'] = None,
                 cluster_fqdn: Optional[str] = None,
                 ssl_configuration: Optional['outputs.SslConfigurationResponse'] = None):
        """
        AKS properties
        :param Sequence['SystemServiceResponseArgs'] system_services: System services
        :param int agent_count: Number of agents
        :param str agent_vm_size: Agent virtual machine size
        :param 'AksNetworkingConfigurationResponseArgs' aks_networking_configuration: AKS networking configuration for vnet
        :param str cluster_fqdn: Cluster full qualified domain name
        :param 'SslConfigurationResponseArgs' ssl_configuration: SSL configuration
        """
        pulumi.set(__self__, "system_services", system_services)
        if agent_count is not None:
            pulumi.set(__self__, "agent_count", agent_count)
        if agent_vm_size is not None:
            pulumi.set(__self__, "agent_vm_size", agent_vm_size)
        if aks_networking_configuration is not None:
            pulumi.set(__self__, "aks_networking_configuration", aks_networking_configuration)
        if cluster_fqdn is not None:
            pulumi.set(__self__, "cluster_fqdn", cluster_fqdn)
        if ssl_configuration is not None:
            pulumi.set(__self__, "ssl_configuration", ssl_configuration)

    @property
    @pulumi.getter(name="systemServices")
    def system_services(self) -> Sequence['outputs.SystemServiceResponse']:
        """
        System services
        """
        return pulumi.get(self, "system_services")

    @property
    @pulumi.getter(name="agentCount")
    def agent_count(self) -> Optional[int]:
        """
        Number of agents
        """
        return pulumi.get(self, "agent_count")

    @property
    @pulumi.getter(name="agentVMSize")
    def agent_vm_size(self) -> Optional[str]:
        """
        Agent virtual machine size
        """
        return pulumi.get(self, "agent_vm_size")

    @property
    @pulumi.getter(name="aksNetworkingConfiguration")
    def aks_networking_configuration(self) -> Optional['outputs.AksNetworkingConfigurationResponse']:
        """
        AKS networking configuration for vnet
        """
        return pulumi.get(self, "aks_networking_configuration")

    @property
    @pulumi.getter(name="clusterFqdn")
    def cluster_fqdn(self) -> Optional[str]:
        """
        Cluster full qualified domain name
        """
        return pulumi.get(self, "cluster_fqdn")

    @property
    @pulumi.getter(name="sslConfiguration")
    def ssl_configuration(self) -> Optional['outputs.SslConfigurationResponse']:
        """
        SSL configuration
        """
        return pulumi.get(self, "ssl_configuration")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AKSVariantResponseResponse(dict):
    """
    The response for an AKS variant.
    """
    def __init__(__self__, *,
                 compute_type: str,
                 error: 'outputs.ServiceResponseBaseResponseError',
                 state: str,
                 deployment_type: Optional[str] = None,
                 description: Optional[str] = None,
                 is_default: Optional[bool] = None,
                 kv_tags: Optional[Mapping[str, str]] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 traffic_percentile: Optional[float] = None,
                 type: Optional[str] = None):
        """
        The response for an AKS variant.
        :param str compute_type: The compute environment type for the service.
        :param 'ServiceResponseBaseResponseErrorArgs' error: The error details.
        :param str state: The current state of the service.
        :param str deployment_type: The deployment type for the service.
        :param str description: The service description.
        :param bool is_default: Is this the default variant.
        :param Mapping[str, str] kv_tags: The service tag dictionary. Tags are mutable.
        :param Mapping[str, str] properties: The service property dictionary. Properties are immutable.
        :param float traffic_percentile: The amount of traffic variant receives.
        :param str type: The type of the variant.
        """
        pulumi.set(__self__, "compute_type", 'Custom')
        pulumi.set(__self__, "error", error)
        pulumi.set(__self__, "state", state)
        if deployment_type is not None:
            pulumi.set(__self__, "deployment_type", deployment_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if kv_tags is not None:
            pulumi.set(__self__, "kv_tags", kv_tags)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if traffic_percentile is not None:
            pulumi.set(__self__, "traffic_percentile", traffic_percentile)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> str:
        """
        The compute environment type for the service.
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter
    def error(self) -> 'outputs.ServiceResponseBaseResponseError':
        """
        The error details.
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the service.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> Optional[str]:
        """
        The deployment type for the service.
        """
        return pulumi.get(self, "deployment_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[bool]:
        """
        Is this the default variant.
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter(name="kvTags")
    def kv_tags(self) -> Optional[Mapping[str, str]]:
        """
        The service tag dictionary. Tags are mutable.
        """
        return pulumi.get(self, "kv_tags")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The service property dictionary. Properties are immutable.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="trafficPercentile")
    def traffic_percentile(self) -> Optional[float]:
        """
        The amount of traffic variant receives.
        """
        return pulumi.get(self, "traffic_percentile")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the variant.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AksNetworkingConfigurationResponse(dict):
    """
    Advance configuration for AKS networking
    """
    def __init__(__self__, *,
                 dns_service_ip: Optional[str] = None,
                 docker_bridge_cidr: Optional[str] = None,
                 service_cidr: Optional[str] = None,
                 subnet_id: Optional[str] = None):
        """
        Advance configuration for AKS networking
        :param str dns_service_ip: An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range specified in serviceCidr.
        :param str docker_bridge_cidr: A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes service address range.
        :param str service_cidr: A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP ranges.
        :param str subnet_id: Virtual network subnet resource ID the compute nodes belong to
        """
        if dns_service_ip is not None:
            pulumi.set(__self__, "dns_service_ip", dns_service_ip)
        if docker_bridge_cidr is not None:
            pulumi.set(__self__, "docker_bridge_cidr", docker_bridge_cidr)
        if service_cidr is not None:
            pulumi.set(__self__, "service_cidr", service_cidr)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="dnsServiceIP")
    def dns_service_ip(self) -> Optional[str]:
        """
        An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range specified in serviceCidr.
        """
        return pulumi.get(self, "dns_service_ip")

    @property
    @pulumi.getter(name="dockerBridgeCidr")
    def docker_bridge_cidr(self) -> Optional[str]:
        """
        A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes service address range.
        """
        return pulumi.get(self, "docker_bridge_cidr")

    @property
    @pulumi.getter(name="serviceCidr")
    def service_cidr(self) -> Optional[str]:
        """
        A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP ranges.
        """
        return pulumi.get(self, "service_cidr")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        Virtual network subnet resource ID the compute nodes belong to
        """
        return pulumi.get(self, "subnet_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AmlComputeNodeInformationResponseResult(dict):
    """
    Compute node information related to a AmlCompute.
    """
    def __init__(__self__, *,
                 node_id: str,
                 node_state: str,
                 port: float,
                 private_ip_address: str,
                 public_ip_address: str,
                 run_id: str):
        """
        Compute node information related to a AmlCompute.
        :param str node_id: ID of the compute node.
        :param str node_state: State of the compute node. Values are idle, running, preparing, unusable, leaving and preempted.
        :param float port: SSH port number of the node.
        :param str private_ip_address: Private IP address of the compute node.
        :param str public_ip_address: Public IP address of the compute node.
        :param str run_id: ID of the Experiment running on the node, if any else null.
        """
        pulumi.set(__self__, "node_id", node_id)
        pulumi.set(__self__, "node_state", node_state)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        pulumi.set(__self__, "public_ip_address", public_ip_address)
        pulumi.set(__self__, "run_id", run_id)

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> str:
        """
        ID of the compute node.
        """
        return pulumi.get(self, "node_id")

    @property
    @pulumi.getter(name="nodeState")
    def node_state(self) -> str:
        """
        State of the compute node. Values are idle, running, preparing, unusable, leaving and preempted.
        """
        return pulumi.get(self, "node_state")

    @property
    @pulumi.getter
    def port(self) -> float:
        """
        SSH port number of the node.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> str:
        """
        Private IP address of the compute node.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> str:
        """
        Public IP address of the compute node.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter(name="runId")
    def run_id(self) -> str:
        """
        ID of the Experiment running on the node, if any else null.
        """
        return pulumi.get(self, "run_id")


@pulumi.output_type
class AmlComputeResponse(dict):
    """
    An Azure Machine Learning compute.
    """
    def __init__(__self__, *,
                 compute_type: str,
                 created_on: str,
                 is_attached_compute: bool,
                 modified_on: str,
                 provisioning_errors: Sequence['outputs.MachineLearningServiceErrorResponse'],
                 provisioning_state: str,
                 compute_location: Optional[str] = None,
                 description: Optional[str] = None,
                 properties: Optional['outputs.AmlComputeResponseProperties'] = None,
                 resource_id: Optional[str] = None):
        """
        An Azure Machine Learning compute.
        :param str compute_type: The type of compute
        :param str created_on: The date and time when the compute was created.
        :param bool is_attached_compute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        :param str modified_on: The date and time when the compute was last modified.
        :param Sequence['MachineLearningServiceErrorResponseArgs'] provisioning_errors: Errors during provisioning
        :param str provisioning_state: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        :param str compute_location: Location for the underlying compute
        :param str description: The description of the Machine Learning compute.
        :param 'AmlComputeResponsePropertiesArgs' properties: AML Compute properties
        :param str resource_id: ARM resource id of the underlying compute
        """
        pulumi.set(__self__, "compute_type", 'AmlCompute')
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "is_attached_compute", is_attached_compute)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "provisioning_errors", provisioning_errors)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if compute_location is not None:
            pulumi.set(__self__, "compute_location", compute_location)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> str:
        """
        The type of compute
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        The date and time when the compute was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="isAttachedCompute")
    def is_attached_compute(self) -> bool:
        """
        Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        """
        return pulumi.get(self, "is_attached_compute")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        The date and time when the compute was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="provisioningErrors")
    def provisioning_errors(self) -> Sequence['outputs.MachineLearningServiceErrorResponse']:
        """
        Errors during provisioning
        """
        return pulumi.get(self, "provisioning_errors")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[str]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.AmlComputeResponseProperties']:
        """
        AML Compute properties
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AmlComputeResponseProperties(dict):
    """
    AML Compute properties
    """
    def __init__(__self__, *,
                 allocation_state: str,
                 allocation_state_transition_time: str,
                 current_node_count: int,
                 errors: Sequence['outputs.MachineLearningServiceErrorResponse'],
                 node_state_counts: 'outputs.NodeStateCountsResponse',
                 target_node_count: int,
                 remote_login_port_public_access: Optional[str] = None,
                 scale_settings: Optional['outputs.ScaleSettingsResponse'] = None,
                 subnet: Optional['outputs.ResourceIdResponse'] = None,
                 user_account_credentials: Optional['outputs.UserAccountCredentialsResponse'] = None,
                 vm_priority: Optional[str] = None,
                 vm_size: Optional[str] = None):
        """
        AML Compute properties
        :param str allocation_state: Allocation state of the compute. Possible values are: steady - Indicates that the compute is not resizing. There are no changes to the number of compute nodes in the compute in progress. A compute enters this state when it is created and when no operations are being performed on the compute to change the number of compute nodes. resizing - Indicates that the compute is resizing; that is, compute nodes are being added to or removed from the compute.
        :param str allocation_state_transition_time: The time at which the compute entered its current allocation state.
        :param int current_node_count: The number of compute nodes currently assigned to the compute.
        :param Sequence['MachineLearningServiceErrorResponseArgs'] errors: Collection of errors encountered by various compute nodes during node setup.
        :param 'NodeStateCountsResponseArgs' node_state_counts: Counts of various node states on the compute.
        :param int target_node_count: The target number of compute nodes for the compute. If the allocationState is resizing, this property denotes the target node count for the ongoing resize operation. If the allocationState is steady, this property denotes the target node count for the previous resize operation.
        :param str remote_login_port_public_access: State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on all nodes of the cluster. Enabled - Indicates that the public ssh port is open on all nodes of the cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined, else is open all public nodes. It can be default only during cluster creation time, after creation it will be either enabled or disabled.
        :param 'ScaleSettingsResponseArgs' scale_settings: Scale settings for AML Compute
        :param 'ResourceIdResponseArgs' subnet: Virtual network subnet resource ID the compute nodes belong to.
        :param 'UserAccountCredentialsResponseArgs' user_account_credentials: Credentials for an administrator user account that will be created on each compute node.
        :param str vm_priority: Virtual Machine priority
        :param str vm_size: Virtual Machine Size
        """
        pulumi.set(__self__, "allocation_state", allocation_state)
        pulumi.set(__self__, "allocation_state_transition_time", allocation_state_transition_time)
        pulumi.set(__self__, "current_node_count", current_node_count)
        pulumi.set(__self__, "errors", errors)
        pulumi.set(__self__, "node_state_counts", node_state_counts)
        pulumi.set(__self__, "target_node_count", target_node_count)
        if remote_login_port_public_access is not None:
            pulumi.set(__self__, "remote_login_port_public_access", remote_login_port_public_access)
        if scale_settings is not None:
            pulumi.set(__self__, "scale_settings", scale_settings)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if user_account_credentials is not None:
            pulumi.set(__self__, "user_account_credentials", user_account_credentials)
        if vm_priority is not None:
            pulumi.set(__self__, "vm_priority", vm_priority)
        if vm_size is not None:
            pulumi.set(__self__, "vm_size", vm_size)

    @property
    @pulumi.getter(name="allocationState")
    def allocation_state(self) -> str:
        """
        Allocation state of the compute. Possible values are: steady - Indicates that the compute is not resizing. There are no changes to the number of compute nodes in the compute in progress. A compute enters this state when it is created and when no operations are being performed on the compute to change the number of compute nodes. resizing - Indicates that the compute is resizing; that is, compute nodes are being added to or removed from the compute.
        """
        return pulumi.get(self, "allocation_state")

    @property
    @pulumi.getter(name="allocationStateTransitionTime")
    def allocation_state_transition_time(self) -> str:
        """
        The time at which the compute entered its current allocation state.
        """
        return pulumi.get(self, "allocation_state_transition_time")

    @property
    @pulumi.getter(name="currentNodeCount")
    def current_node_count(self) -> int:
        """
        The number of compute nodes currently assigned to the compute.
        """
        return pulumi.get(self, "current_node_count")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.MachineLearningServiceErrorResponse']:
        """
        Collection of errors encountered by various compute nodes during node setup.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter(name="nodeStateCounts")
    def node_state_counts(self) -> 'outputs.NodeStateCountsResponse':
        """
        Counts of various node states on the compute.
        """
        return pulumi.get(self, "node_state_counts")

    @property
    @pulumi.getter(name="targetNodeCount")
    def target_node_count(self) -> int:
        """
        The target number of compute nodes for the compute. If the allocationState is resizing, this property denotes the target node count for the ongoing resize operation. If the allocationState is steady, this property denotes the target node count for the previous resize operation.
        """
        return pulumi.get(self, "target_node_count")

    @property
    @pulumi.getter(name="remoteLoginPortPublicAccess")
    def remote_login_port_public_access(self) -> Optional[str]:
        """
        State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on all nodes of the cluster. Enabled - Indicates that the public ssh port is open on all nodes of the cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined, else is open all public nodes. It can be default only during cluster creation time, after creation it will be either enabled or disabled.
        """
        return pulumi.get(self, "remote_login_port_public_access")

    @property
    @pulumi.getter(name="scaleSettings")
    def scale_settings(self) -> Optional['outputs.ScaleSettingsResponse']:
        """
        Scale settings for AML Compute
        """
        return pulumi.get(self, "scale_settings")

    @property
    @pulumi.getter
    def subnet(self) -> Optional['outputs.ResourceIdResponse']:
        """
        Virtual network subnet resource ID the compute nodes belong to.
        """
        return pulumi.get(self, "subnet")

    @property
    @pulumi.getter(name="userAccountCredentials")
    def user_account_credentials(self) -> Optional['outputs.UserAccountCredentialsResponse']:
        """
        Credentials for an administrator user account that will be created on each compute node.
        """
        return pulumi.get(self, "user_account_credentials")

    @property
    @pulumi.getter(name="vmPriority")
    def vm_priority(self) -> Optional[str]:
        """
        Virtual Machine priority
        """
        return pulumi.get(self, "vm_priority")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> Optional[str]:
        """
        Virtual Machine Size
        """
        return pulumi.get(self, "vm_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureDataLakeSectionResponse(dict):
    def __init__(__self__, *,
                 authority_url: Optional[str] = None,
                 certificate: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 credential_type: Optional[str] = None,
                 is_cert_auth: Optional[bool] = None,
                 resource_group: Optional[str] = None,
                 resource_uri: Optional[str] = None,
                 service_data_access_auth_identity: Optional[str] = None,
                 store_name: Optional[str] = None,
                 subscription_id: Optional[str] = None,
                 tenant_id: Optional[str] = None,
                 thumbprint: Optional[str] = None):
        """
        :param str authority_url: The authority URL used for authentication.
        :param str certificate: The content of the certificate used for authentication.
        :param str client_id: The Client ID/Application ID
        :param str client_secret: The client secret.
        :param str credential_type: The Azure Data Lake credential type.
        :param bool is_cert_auth:  Is it using certificate to authenticate. If false then use client secret.
        :param str resource_group: Resource Group.
        :param str resource_uri: The resource the service principal/app has access to.
        :param str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param str store_name: The Azure Data Lake store name.
        :param str subscription_id: Subscription ID.
        :param str tenant_id: The ID of the tenant the service principal/app belongs to.
        :param str thumbprint: The thumbprint of the certificate above.
        """
        if authority_url is not None:
            pulumi.set(__self__, "authority_url", authority_url)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if is_cert_auth is not None:
            pulumi.set(__self__, "is_cert_auth", is_cert_auth)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if resource_uri is not None:
            pulumi.set(__self__, "resource_uri", resource_uri)
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if store_name is not None:
            pulumi.set(__self__, "store_name", store_name)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)

    @property
    @pulumi.getter(name="authorityUrl")
    def authority_url(self) -> Optional[str]:
        """
        The authority URL used for authentication.
        """
        return pulumi.get(self, "authority_url")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        The content of the certificate used for authentication.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID/Application ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[str]:
        """
        The Azure Data Lake credential type.
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter(name="isCertAuth")
    def is_cert_auth(self) -> Optional[bool]:
        """
         Is it using certificate to authenticate. If false then use client secret.
        """
        return pulumi.get(self, "is_cert_auth")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[str]:
        """
        Resource Group.
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[str]:
        """
        The resource the service principal/app has access to.
        """
        return pulumi.get(self, "resource_uri")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> Optional[str]:
        """
        The Azure Data Lake store name.
        """
        return pulumi.get(self, "store_name")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        Subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The ID of the tenant the service principal/app belongs to.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[str]:
        """
        The thumbprint of the certificate above.
        """
        return pulumi.get(self, "thumbprint")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureMySqlSectionResponse(dict):
    def __init__(__self__, *,
                 authority_url: Optional[str] = None,
                 certificate: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 credential_type: Optional[str] = None,
                 database_name: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 is_cert_auth: Optional[bool] = None,
                 port_number: Optional[str] = None,
                 resource_group: Optional[str] = None,
                 resource_uri: Optional[str] = None,
                 server_name: Optional[str] = None,
                 service_data_access_auth_identity: Optional[str] = None,
                 subscription_id: Optional[str] = None,
                 tenant_id: Optional[str] = None,
                 thumbprint: Optional[str] = None,
                 user_id: Optional[str] = None,
                 user_password: Optional[str] = None):
        """
        :param str authority_url: The authority URL used for authentication.
        :param str certificate: The content of the certificate used for authentication.
        :param str client_id: The Client ID/Application ID
        :param str client_secret: The client secret.
        :param str credential_type: Sql Authentication type.
        :param str database_name: The Azure SQL database name.
        :param str endpoint: The server host endpoint.
        :param bool is_cert_auth:  Is it using certificate to authenticate. If false then use client secret.
        :param str port_number: / The Azure SQL port number.
        :param str resource_group: Resource Group.
        :param str resource_uri: The resource the service principal/app has access to.
        :param str server_name: The Azure SQL server name.
        :param str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param str subscription_id: Subscription ID.
        :param str tenant_id: The ID of the tenant the service principal/app belongs to.
        :param str thumbprint: The thumbprint of the certificate above.
        :param str user_id: The Azure SQL user id.
        :param str user_password: The Azure SQL user password.
        """
        if authority_url is not None:
            pulumi.set(__self__, "authority_url", authority_url)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if is_cert_auth is not None:
            pulumi.set(__self__, "is_cert_auth", is_cert_auth)
        if port_number is not None:
            pulumi.set(__self__, "port_number", port_number)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if resource_uri is not None:
            pulumi.set(__self__, "resource_uri", resource_uri)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if user_password is not None:
            pulumi.set(__self__, "user_password", user_password)

    @property
    @pulumi.getter(name="authorityUrl")
    def authority_url(self) -> Optional[str]:
        """
        The authority URL used for authentication.
        """
        return pulumi.get(self, "authority_url")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        The content of the certificate used for authentication.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID/Application ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[str]:
        """
        Sql Authentication type.
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The Azure SQL database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The server host endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="isCertAuth")
    def is_cert_auth(self) -> Optional[bool]:
        """
         Is it using certificate to authenticate. If false then use client secret.
        """
        return pulumi.get(self, "is_cert_auth")

    @property
    @pulumi.getter(name="portNumber")
    def port_number(self) -> Optional[str]:
        """
        / The Azure SQL port number.
        """
        return pulumi.get(self, "port_number")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[str]:
        """
        Resource Group.
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[str]:
        """
        The resource the service principal/app has access to.
        """
        return pulumi.get(self, "resource_uri")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        The Azure SQL server name.
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        Subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The ID of the tenant the service principal/app belongs to.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[str]:
        """
        The thumbprint of the certificate above.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        """
        The Azure SQL user id.
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter(name="userPassword")
    def user_password(self) -> Optional[str]:
        """
        The Azure SQL user password.
        """
        return pulumi.get(self, "user_password")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzurePostgreSqlSectionResponse(dict):
    def __init__(__self__, *,
                 authority_url: Optional[str] = None,
                 certificate: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 credential_type: Optional[str] = None,
                 database_name: Optional[str] = None,
                 enable_ssl: Optional[bool] = None,
                 endpoint: Optional[str] = None,
                 is_cert_auth: Optional[bool] = None,
                 port_number: Optional[str] = None,
                 resource_group: Optional[str] = None,
                 resource_uri: Optional[str] = None,
                 server_name: Optional[str] = None,
                 service_data_access_auth_identity: Optional[str] = None,
                 subscription_id: Optional[str] = None,
                 tenant_id: Optional[str] = None,
                 thumbprint: Optional[str] = None,
                 user_id: Optional[str] = None,
                 user_password: Optional[str] = None):
        """
        :param str authority_url: The authority URL used for authentication.
        :param str certificate: The content of the certificate used for authentication.
        :param str client_id: The Client ID/Application ID
        :param str client_secret: The client secret.
        :param str credential_type: Sql Authentication type.
        :param str database_name: The Azure SQL database name.
        :param bool enable_ssl: Indicates SSL requirement of Azure Postgresql server.
        :param str endpoint: The server host endpoint.
        :param bool is_cert_auth:  Is it using certificate to authenticate. If false then use client secret.
        :param str port_number: / The Azure SQL port number.
        :param str resource_group: Resource Group.
        :param str resource_uri: The resource the service principal/app has access to.
        :param str server_name: The Azure SQL server name.
        :param str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param str subscription_id: Subscription ID.
        :param str tenant_id: The ID of the tenant the service principal/app belongs to.
        :param str thumbprint: The thumbprint of the certificate above.
        :param str user_id: The Azure SQL user id.
        :param str user_password: The Azure SQL user password.
        """
        if authority_url is not None:
            pulumi.set(__self__, "authority_url", authority_url)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if enable_ssl is not None:
            pulumi.set(__self__, "enable_ssl", enable_ssl)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if is_cert_auth is not None:
            pulumi.set(__self__, "is_cert_auth", is_cert_auth)
        if port_number is not None:
            pulumi.set(__self__, "port_number", port_number)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if resource_uri is not None:
            pulumi.set(__self__, "resource_uri", resource_uri)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if user_password is not None:
            pulumi.set(__self__, "user_password", user_password)

    @property
    @pulumi.getter(name="authorityUrl")
    def authority_url(self) -> Optional[str]:
        """
        The authority URL used for authentication.
        """
        return pulumi.get(self, "authority_url")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        The content of the certificate used for authentication.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID/Application ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[str]:
        """
        Sql Authentication type.
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The Azure SQL database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="enableSsl")
    def enable_ssl(self) -> Optional[bool]:
        """
        Indicates SSL requirement of Azure Postgresql server.
        """
        return pulumi.get(self, "enable_ssl")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The server host endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="isCertAuth")
    def is_cert_auth(self) -> Optional[bool]:
        """
         Is it using certificate to authenticate. If false then use client secret.
        """
        return pulumi.get(self, "is_cert_auth")

    @property
    @pulumi.getter(name="portNumber")
    def port_number(self) -> Optional[str]:
        """
        / The Azure SQL port number.
        """
        return pulumi.get(self, "port_number")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[str]:
        """
        Resource Group.
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[str]:
        """
        The resource the service principal/app has access to.
        """
        return pulumi.get(self, "resource_uri")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        The Azure SQL server name.
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        Subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The ID of the tenant the service principal/app belongs to.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[str]:
        """
        The thumbprint of the certificate above.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        """
        The Azure SQL user id.
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter(name="userPassword")
    def user_password(self) -> Optional[str]:
        """
        The Azure SQL user password.
        """
        return pulumi.get(self, "user_password")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureSqlDatabaseSectionResponse(dict):
    def __init__(__self__, *,
                 authority_url: Optional[str] = None,
                 certificate: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 credential_type: Optional[str] = None,
                 database_name: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 is_cert_auth: Optional[bool] = None,
                 port_number: Optional[str] = None,
                 resource_group: Optional[str] = None,
                 resource_uri: Optional[str] = None,
                 server_name: Optional[str] = None,
                 service_data_access_auth_identity: Optional[str] = None,
                 subscription_id: Optional[str] = None,
                 tenant_id: Optional[str] = None,
                 thumbprint: Optional[str] = None,
                 user_id: Optional[str] = None,
                 user_password: Optional[str] = None):
        """
        :param str authority_url: The authority URL used for authentication.
        :param str certificate: The content of the certificate used for authentication.
        :param str client_id: The Client ID/Application ID
        :param str client_secret: The client secret.
        :param str credential_type: Sql Authentication type.
        :param str database_name: The Azure SQL database name.
        :param str endpoint: The server host endpoint.
        :param bool is_cert_auth:  Is it using certificate to authenticate. If false then use client secret.
        :param str port_number: / The Azure SQL port number.
        :param str resource_group: Resource Group.
        :param str resource_uri: The resource the service principal/app has access to.
        :param str server_name: The Azure SQL server name.
        :param str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param str subscription_id: Subscription ID.
        :param str tenant_id: The ID of the tenant the service principal/app belongs to.
        :param str thumbprint: The thumbprint of the certificate above.
        :param str user_id: The Azure SQL user id.
        :param str user_password: The Azure SQL user password.
        """
        if authority_url is not None:
            pulumi.set(__self__, "authority_url", authority_url)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if is_cert_auth is not None:
            pulumi.set(__self__, "is_cert_auth", is_cert_auth)
        if port_number is not None:
            pulumi.set(__self__, "port_number", port_number)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if resource_uri is not None:
            pulumi.set(__self__, "resource_uri", resource_uri)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if user_password is not None:
            pulumi.set(__self__, "user_password", user_password)

    @property
    @pulumi.getter(name="authorityUrl")
    def authority_url(self) -> Optional[str]:
        """
        The authority URL used for authentication.
        """
        return pulumi.get(self, "authority_url")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        The content of the certificate used for authentication.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID/Application ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[str]:
        """
        Sql Authentication type.
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The Azure SQL database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The server host endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="isCertAuth")
    def is_cert_auth(self) -> Optional[bool]:
        """
         Is it using certificate to authenticate. If false then use client secret.
        """
        return pulumi.get(self, "is_cert_auth")

    @property
    @pulumi.getter(name="portNumber")
    def port_number(self) -> Optional[str]:
        """
        / The Azure SQL port number.
        """
        return pulumi.get(self, "port_number")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[str]:
        """
        Resource Group.
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[str]:
        """
        The resource the service principal/app has access to.
        """
        return pulumi.get(self, "resource_uri")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        The Azure SQL server name.
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        Subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The ID of the tenant the service principal/app belongs to.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[str]:
        """
        The thumbprint of the certificate above.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        """
        The Azure SQL user id.
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter(name="userPassword")
    def user_password(self) -> Optional[str]:
        """
        The Azure SQL user password.
        """
        return pulumi.get(self, "user_password")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureStorageSectionResponse(dict):
    def __init__(__self__, *,
                 account_key: Optional[str] = None,
                 account_name: Optional[str] = None,
                 are_workspace_managed_identities_allowed: Optional[bool] = None,
                 blob_cache_timeout: Optional[int] = None,
                 client_credentials: Optional['outputs.ClientCredentialsResponse'] = None,
                 container_name: Optional[str] = None,
                 credential: Optional[str] = None,
                 credential_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 is_sas: Optional[bool] = None,
                 protocol: Optional[str] = None,
                 resource_group: Optional[str] = None,
                 sas_token: Optional[str] = None,
                 service_data_access_auth_identity: Optional[str] = None,
                 subscription_id: Optional[str] = None):
        """
        :param str account_key:  Storage Account Key (Deprecated).
        :param str account_name: Storage Account Name.
        :param bool are_workspace_managed_identities_allowed: Indicate if we are using Workspace ManagedIdentities/MSI token (Deprecated).
        :param int blob_cache_timeout:  If this is an "DataStoreType.AzureBlob", the length of time (in seconds) to cache files locally after they are accessed (downloaded).
        :param str container_name: The storage container name.
        :param str credential: The credential.
        :param str credential_type:  The credential type.
        :param str endpoint: The host of the container.
        :param bool is_sas: Indicate if we are using SAS token or Account Key (Deprecated).
        :param str protocol: The protocol to use. Defaults to https.
        :param str resource_group: Resource Group.
        :param str sas_token:  SAS Token for the container (Deprecated).
        :param str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param str subscription_id: Subscription ID.
        """
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if are_workspace_managed_identities_allowed is not None:
            pulumi.set(__self__, "are_workspace_managed_identities_allowed", are_workspace_managed_identities_allowed)
        if blob_cache_timeout is not None:
            pulumi.set(__self__, "blob_cache_timeout", blob_cache_timeout)
        if client_credentials is not None:
            pulumi.set(__self__, "client_credentials", client_credentials)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if is_sas is not None:
            pulumi.set(__self__, "is_sas", is_sas)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[str]:
        """
         Storage Account Key (Deprecated).
        """
        return pulumi.get(self, "account_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[str]:
        """
        Storage Account Name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="areWorkspaceManagedIdentitiesAllowed")
    def are_workspace_managed_identities_allowed(self) -> Optional[bool]:
        """
        Indicate if we are using Workspace ManagedIdentities/MSI token (Deprecated).
        """
        return pulumi.get(self, "are_workspace_managed_identities_allowed")

    @property
    @pulumi.getter(name="blobCacheTimeout")
    def blob_cache_timeout(self) -> Optional[int]:
        """
         If this is an "DataStoreType.AzureBlob", the length of time (in seconds) to cache files locally after they are accessed (downloaded).
        """
        return pulumi.get(self, "blob_cache_timeout")

    @property
    @pulumi.getter(name="clientCredentials")
    def client_credentials(self) -> Optional['outputs.ClientCredentialsResponse']:
        return pulumi.get(self, "client_credentials")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        """
        The storage container name.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def credential(self) -> Optional[str]:
        """
        The credential.
        """
        return pulumi.get(self, "credential")

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[str]:
        """
         The credential type.
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The host of the container.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="isSas")
    def is_sas(self) -> Optional[bool]:
        """
        Indicate if we are using SAS token or Account Key (Deprecated).
        """
        return pulumi.get(self, "is_sas")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol to use. Defaults to https.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[str]:
        """
        Resource Group.
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional[str]:
        """
         SAS Token for the container (Deprecated).
        """
        return pulumi.get(self, "sas_token")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        Subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ClientCredentialsResponse(dict):
    def __init__(__self__, *,
                 authority_url: Optional[str] = None,
                 certificate: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 is_cert_auth: Optional[bool] = None,
                 resource_group: Optional[str] = None,
                 resource_uri: Optional[str] = None,
                 service_data_access_auth_identity: Optional[str] = None,
                 subscription_id: Optional[str] = None,
                 tenant_id: Optional[str] = None,
                 thumbprint: Optional[str] = None):
        """
        :param str authority_url: The authority URL used for authentication.
        :param str certificate: The content of the certificate used for authentication.
        :param str client_id: The Client ID/Application ID
        :param str client_secret: The client secret.
        :param bool is_cert_auth:  Is it using certificate to authenticate. If false then use client secret.
        :param str resource_group: Resource Group.
        :param str resource_uri: The resource the service principal/app has access to.
        :param str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param str subscription_id: Subscription ID.
        :param str tenant_id: The ID of the tenant the service principal/app belongs to.
        :param str thumbprint: The thumbprint of the certificate above.
        """
        if authority_url is not None:
            pulumi.set(__self__, "authority_url", authority_url)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if is_cert_auth is not None:
            pulumi.set(__self__, "is_cert_auth", is_cert_auth)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if resource_uri is not None:
            pulumi.set(__self__, "resource_uri", resource_uri)
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)

    @property
    @pulumi.getter(name="authorityUrl")
    def authority_url(self) -> Optional[str]:
        """
        The authority URL used for authentication.
        """
        return pulumi.get(self, "authority_url")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        The content of the certificate used for authentication.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID/Application ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="isCertAuth")
    def is_cert_auth(self) -> Optional[bool]:
        """
         Is it using certificate to authenticate. If false then use client secret.
        """
        return pulumi.get(self, "is_cert_auth")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[str]:
        """
        Resource Group.
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[str]:
        """
        The resource the service principal/app has access to.
        """
        return pulumi.get(self, "resource_uri")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        Subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The ID of the tenant the service principal/app belongs to.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[str]:
        """
        The thumbprint of the certificate above.
        """
        return pulumi.get(self, "thumbprint")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ContainerResourceRequirementsResponse(dict):
    """
    The resource requirements for the container (cpu and memory).
    """
    def __init__(__self__, *,
                 cpu: Optional[float] = None,
                 fpga: Optional[int] = None,
                 gpu: Optional[int] = None,
                 memory_in_gb: Optional[float] = None):
        """
        The resource requirements for the container (cpu and memory).
        :param float cpu: The number of CPU cores on the container.
        :param int fpga: The number of FPGA PCIE devices exposed to the container. Must be multiple of 2.
        :param int gpu: The number of GPU cores in the container.
        :param float memory_in_gb: The amount of memory on the container in GB.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if fpga is not None:
            pulumi.set(__self__, "fpga", fpga)
        if gpu is not None:
            pulumi.set(__self__, "gpu", gpu)
        if memory_in_gb is not None:
            pulumi.set(__self__, "memory_in_gb", memory_in_gb)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[float]:
        """
        The number of CPU cores on the container.
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def fpga(self) -> Optional[int]:
        """
        The number of FPGA PCIE devices exposed to the container. Must be multiple of 2.
        """
        return pulumi.get(self, "fpga")

    @property
    @pulumi.getter
    def gpu(self) -> Optional[int]:
        """
        The number of GPU cores in the container.
        """
        return pulumi.get(self, "gpu")

    @property
    @pulumi.getter(name="memoryInGB")
    def memory_in_gb(self) -> Optional[float]:
        """
        The amount of memory on the container in GB.
        """
        return pulumi.get(self, "memory_in_gb")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DataFactoryResponse(dict):
    """
    A DataFactory compute.
    """
    def __init__(__self__, *,
                 compute_type: str,
                 created_on: str,
                 is_attached_compute: bool,
                 modified_on: str,
                 provisioning_errors: Sequence['outputs.MachineLearningServiceErrorResponse'],
                 provisioning_state: str,
                 compute_location: Optional[str] = None,
                 description: Optional[str] = None,
                 resource_id: Optional[str] = None):
        """
        A DataFactory compute.
        :param str compute_type: The type of compute
        :param str created_on: The date and time when the compute was created.
        :param bool is_attached_compute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        :param str modified_on: The date and time when the compute was last modified.
        :param Sequence['MachineLearningServiceErrorResponseArgs'] provisioning_errors: Errors during provisioning
        :param str provisioning_state: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        :param str compute_location: Location for the underlying compute
        :param str description: The description of the Machine Learning compute.
        :param str resource_id: ARM resource id of the underlying compute
        """
        pulumi.set(__self__, "compute_type", 'DataFactory')
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "is_attached_compute", is_attached_compute)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "provisioning_errors", provisioning_errors)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if compute_location is not None:
            pulumi.set(__self__, "compute_location", compute_location)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> str:
        """
        The type of compute
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        The date and time when the compute was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="isAttachedCompute")
    def is_attached_compute(self) -> bool:
        """
        Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        """
        return pulumi.get(self, "is_attached_compute")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        The date and time when the compute was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="provisioningErrors")
    def provisioning_errors(self) -> Sequence['outputs.MachineLearningServiceErrorResponse']:
        """
        Errors during provisioning
        """
        return pulumi.get(self, "provisioning_errors")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[str]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DataLakeAnalyticsResponse(dict):
    """
    A DataLakeAnalytics compute.
    """
    def __init__(__self__, *,
                 compute_type: str,
                 created_on: str,
                 is_attached_compute: bool,
                 modified_on: str,
                 provisioning_errors: Sequence['outputs.MachineLearningServiceErrorResponse'],
                 provisioning_state: str,
                 compute_location: Optional[str] = None,
                 description: Optional[str] = None,
                 properties: Optional['outputs.DataLakeAnalyticsResponseProperties'] = None,
                 resource_id: Optional[str] = None):
        """
        A DataLakeAnalytics compute.
        :param str compute_type: The type of compute
        :param str created_on: The date and time when the compute was created.
        :param bool is_attached_compute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        :param str modified_on: The date and time when the compute was last modified.
        :param Sequence['MachineLearningServiceErrorResponseArgs'] provisioning_errors: Errors during provisioning
        :param str provisioning_state: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        :param str compute_location: Location for the underlying compute
        :param str description: The description of the Machine Learning compute.
        :param str resource_id: ARM resource id of the underlying compute
        """
        pulumi.set(__self__, "compute_type", 'DataLakeAnalytics')
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "is_attached_compute", is_attached_compute)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "provisioning_errors", provisioning_errors)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if compute_location is not None:
            pulumi.set(__self__, "compute_location", compute_location)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> str:
        """
        The type of compute
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        The date and time when the compute was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="isAttachedCompute")
    def is_attached_compute(self) -> bool:
        """
        Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        """
        return pulumi.get(self, "is_attached_compute")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        The date and time when the compute was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="provisioningErrors")
    def provisioning_errors(self) -> Sequence['outputs.MachineLearningServiceErrorResponse']:
        """
        Errors during provisioning
        """
        return pulumi.get(self, "provisioning_errors")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[str]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.DataLakeAnalyticsResponseProperties']:
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DataLakeAnalyticsResponseProperties(dict):
    def __init__(__self__, *,
                 data_lake_store_account_name: Optional[str] = None):
        """
        :param str data_lake_store_account_name: DataLake Store Account Name
        """
        if data_lake_store_account_name is not None:
            pulumi.set(__self__, "data_lake_store_account_name", data_lake_store_account_name)

    @property
    @pulumi.getter(name="dataLakeStoreAccountName")
    def data_lake_store_account_name(self) -> Optional[str]:
        """
        DataLake Store Account Name
        """
        return pulumi.get(self, "data_lake_store_account_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DatabricksResponse(dict):
    """
    A DataFactory compute.
    """
    def __init__(__self__, *,
                 compute_type: str,
                 created_on: str,
                 is_attached_compute: bool,
                 modified_on: str,
                 provisioning_errors: Sequence['outputs.MachineLearningServiceErrorResponse'],
                 provisioning_state: str,
                 compute_location: Optional[str] = None,
                 description: Optional[str] = None,
                 properties: Optional['outputs.DatabricksResponseProperties'] = None,
                 resource_id: Optional[str] = None):
        """
        A DataFactory compute.
        :param str compute_type: The type of compute
        :param str created_on: The date and time when the compute was created.
        :param bool is_attached_compute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        :param str modified_on: The date and time when the compute was last modified.
        :param Sequence['MachineLearningServiceErrorResponseArgs'] provisioning_errors: Errors during provisioning
        :param str provisioning_state: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        :param str compute_location: Location for the underlying compute
        :param str description: The description of the Machine Learning compute.
        :param str resource_id: ARM resource id of the underlying compute
        """
        pulumi.set(__self__, "compute_type", 'Databricks')
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "is_attached_compute", is_attached_compute)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "provisioning_errors", provisioning_errors)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if compute_location is not None:
            pulumi.set(__self__, "compute_location", compute_location)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> str:
        """
        The type of compute
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        The date and time when the compute was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="isAttachedCompute")
    def is_attached_compute(self) -> bool:
        """
        Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        """
        return pulumi.get(self, "is_attached_compute")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        The date and time when the compute was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="provisioningErrors")
    def provisioning_errors(self) -> Sequence['outputs.MachineLearningServiceErrorResponse']:
        """
        Errors during provisioning
        """
        return pulumi.get(self, "provisioning_errors")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[str]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.DatabricksResponseProperties']:
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DatabricksResponseProperties(dict):
    def __init__(__self__, *,
                 databricks_access_token: Optional[str] = None):
        """
        :param str databricks_access_token: Databricks access token
        """
        if databricks_access_token is not None:
            pulumi.set(__self__, "databricks_access_token", databricks_access_token)

    @property
    @pulumi.getter(name="databricksAccessToken")
    def databricks_access_token(self) -> Optional[str]:
        """
        Databricks access token
        """
        return pulumi.get(self, "databricks_access_token")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DatasetReferenceResponse(dict):
    """
    The dataset reference object.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        The dataset reference object.
        :param str id: The id of the dataset reference.
        :param str name: The name of the dataset reference.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the dataset reference.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the dataset reference.
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DatasetResponse(dict):
    """
    Machine Learning dataset object.
    """
    def __init__(__self__, *,
                 created_time: str,
                 dataset_id: str,
                 dataset_type: str,
                 default_compute: str,
                 description: str,
                 etag: str,
                 is_visible: bool,
                 modified_time: str,
                 name: str,
                 tags: Mapping[str, str],
                 dataset_state: Optional['outputs.DatasetStateResponse'] = None,
                 latest: Optional['outputs.DatasetResponseLatest'] = None):
        """
        Machine Learning dataset object.
        :param str created_time: The dataset creation time (UTC).
        :param str dataset_id: Unique Dataset identifier.
        :param str dataset_type: Dataset Type.
        :param str default_compute: Name of the default compute to be used for any Dataset actions (such as Profile, Write).
        :param str description: Description about this dataset version.
        :param str etag: eTag description
        :param bool is_visible: Flag to hide Dataset in UI
        :param str modified_time: The dataset last modified time (UTC).
        :param str name: Unique dataset name
        :param Mapping[str, str] tags: Tags for this dataset version.
        :param 'DatasetStateResponseArgs' dataset_state: Dataset state
        :param 'DatasetResponseLatestArgs' latest: Last created Dataset definition.
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "dataset_type", dataset_type)
        pulumi.set(__self__, "default_compute", default_compute)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "etag", etag)
        pulumi.set(__self__, "is_visible", is_visible)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tags", tags)
        if dataset_state is not None:
            pulumi.set(__self__, "dataset_state", dataset_state)
        if latest is not None:
            pulumi.set(__self__, "latest", latest)

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> str:
        """
        The dataset creation time (UTC).
        """
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> str:
        """
        Unique Dataset identifier.
        """
        return pulumi.get(self, "dataset_id")

    @property
    @pulumi.getter(name="datasetType")
    def dataset_type(self) -> str:
        """
        Dataset Type.
        """
        return pulumi.get(self, "dataset_type")

    @property
    @pulumi.getter(name="defaultCompute")
    def default_compute(self) -> str:
        """
        Name of the default compute to be used for any Dataset actions (such as Profile, Write).
        """
        return pulumi.get(self, "default_compute")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description about this dataset version.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        eTag description
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="isVisible")
    def is_visible(self) -> bool:
        """
        Flag to hide Dataset in UI
        """
        return pulumi.get(self, "is_visible")

    @property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> str:
        """
        The dataset last modified time (UTC).
        """
        return pulumi.get(self, "modified_time")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique dataset name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        """
        Tags for this dataset version.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="datasetState")
    def dataset_state(self) -> Optional['outputs.DatasetStateResponse']:
        """
        Dataset state
        """
        return pulumi.get(self, "dataset_state")

    @property
    @pulumi.getter
    def latest(self) -> Optional['outputs.DatasetResponseLatest']:
        """
        Last created Dataset definition.
        """
        return pulumi.get(self, "latest")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DatasetResponseDataPath(dict):
    """
     Datastore and reference to location of data such as relativePath, Sql Query and etc.
    """
    def __init__(__self__, *,
                 azure_file_path: str,
                 datastore_name: str,
                 http_url: str,
                 partition_format: str,
                 partition_format_ignore_error: bool,
                 paths: Sequence[str],
                 relative_path: str,
                 additional_properties: Optional[Mapping[str, Any]] = None,
                 sql_data_path: Optional['outputs.DatasetResponseSqlDataPath'] = None):
        """
         Datastore and reference to location of data such as relativePath, Sql Query and etc.
        :param str azure_file_path: Azure path for Azure Blob or File
        :param str datastore_name: Data store Name
        :param str http_url: HTTP URL.
        :param str partition_format: Specify the partition format of path. Defaults to None.
        :param bool partition_format_ignore_error: Whether or not to ignore unmatched path.
        :param Sequence[str] paths: List of files expanded from a file GLOB specified
        :param str relative_path: Relative path in the data store
        :param Mapping[str, Any] additional_properties: Additional Properties.
        :param 'DatasetResponseSqlDataPathArgs' sql_data_path: Sql Query/Table/Stored Procedure details.
        """
        pulumi.set(__self__, "azure_file_path", azure_file_path)
        pulumi.set(__self__, "datastore_name", datastore_name)
        pulumi.set(__self__, "http_url", http_url)
        pulumi.set(__self__, "partition_format", partition_format)
        pulumi.set(__self__, "partition_format_ignore_error", partition_format_ignore_error)
        pulumi.set(__self__, "paths", paths)
        pulumi.set(__self__, "relative_path", relative_path)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if sql_data_path is not None:
            pulumi.set(__self__, "sql_data_path", sql_data_path)

    @property
    @pulumi.getter(name="azureFilePath")
    def azure_file_path(self) -> str:
        """
        Azure path for Azure Blob or File
        """
        return pulumi.get(self, "azure_file_path")

    @property
    @pulumi.getter(name="datastoreName")
    def datastore_name(self) -> str:
        """
        Data store Name
        """
        return pulumi.get(self, "datastore_name")

    @property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> str:
        """
        HTTP URL.
        """
        return pulumi.get(self, "http_url")

    @property
    @pulumi.getter(name="partitionFormat")
    def partition_format(self) -> str:
        """
        Specify the partition format of path. Defaults to None.
        """
        return pulumi.get(self, "partition_format")

    @property
    @pulumi.getter(name="partitionFormatIgnoreError")
    def partition_format_ignore_error(self) -> bool:
        """
        Whether or not to ignore unmatched path.
        """
        return pulumi.get(self, "partition_format_ignore_error")

    @property
    @pulumi.getter
    def paths(self) -> Sequence[str]:
        """
        List of files expanded from a file GLOB specified
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> str:
        """
        Relative path in the data store
        """
        return pulumi.get(self, "relative_path")

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[Mapping[str, Any]]:
        """
        Additional Properties.
        """
        return pulumi.get(self, "additional_properties")

    @property
    @pulumi.getter(name="sqlDataPath")
    def sql_data_path(self) -> Optional['outputs.DatasetResponseSqlDataPath']:
        """
        Sql Query/Table/Stored Procedure details.
        """
        return pulumi.get(self, "sql_data_path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DatasetResponseLatest(dict):
    """
    Last created Dataset definition.
    """
    def __init__(__self__, *,
                 created_time: str,
                 dataflow: str,
                 dataset_id: str,
                 description: str,
                 etag: str,
                 file_type: str,
                 modified_time: str,
                 notes: str,
                 partition_format_in_path: bool,
                 saved_dataset_id: str,
                 tags: Mapping[str, str],
                 telemetry_info: Mapping[str, str],
                 use_description_tags_from_definition: bool,
                 version_id: str,
                 created_by: Optional['outputs.UserInfoResponse'] = None,
                 data_path: Optional['outputs.DatasetResponseDataPath'] = None,
                 dataset_definition_state: Optional['outputs.DatasetStateResponse'] = None,
                 properties: Optional[Mapping[str, Any]] = None):
        """
        Last created Dataset definition.
        :param str created_time: The dataset creation time (UTC).
        :param str dataflow: Dataflow Json
        :param str dataset_id: Unique Dataset identifier.
        :param str description: Description about the dataset.
        :param str etag: eTag description
        :param str file_type: Dataset FileType, specified by user.
        :param str modified_time: The dataset last modified time (UTC).
        :param str notes: Summary of Definition changes.
        :param bool partition_format_in_path: Indicates how the source data is partitioned. This is defined to filter on a range of partitioned data before performing actions or materialization.
        :param str saved_dataset_id: Indicates the saved dataset this definition is mapping to, populated on Get.
        :param Mapping[str, str] tags: Tags associated with the dataset.
        :param Mapping[str, str] telemetry_info:  Telemetry information about the dataset including information like which service the dataset was created from.
        :param bool use_description_tags_from_definition:  Whether to use description and tags from the definition level as opposed to dataset level (old behavior).
        :param str version_id: An identifier uniquely identifies a definition change.
        :param 'UserInfoResponseArgs' created_by: User who created.
        :param 'DatasetResponseDataPathArgs' data_path:  Datastore and reference to location of data such as relativePath, Sql Query and etc.
        :param 'DatasetStateResponseArgs' dataset_definition_state: Dataset state
        :param Mapping[str, Any] properties: Properties stores information like name of time series column for time series dataset.
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "dataflow", dataflow)
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "etag", etag)
        pulumi.set(__self__, "file_type", file_type)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "notes", notes)
        pulumi.set(__self__, "partition_format_in_path", partition_format_in_path)
        pulumi.set(__self__, "saved_dataset_id", saved_dataset_id)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "telemetry_info", telemetry_info)
        pulumi.set(__self__, "use_description_tags_from_definition", use_description_tags_from_definition)
        pulumi.set(__self__, "version_id", version_id)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if data_path is not None:
            pulumi.set(__self__, "data_path", data_path)
        if dataset_definition_state is not None:
            pulumi.set(__self__, "dataset_definition_state", dataset_definition_state)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> str:
        """
        The dataset creation time (UTC).
        """
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter
    def dataflow(self) -> str:
        """
        Dataflow Json
        """
        return pulumi.get(self, "dataflow")

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> str:
        """
        Unique Dataset identifier.
        """
        return pulumi.get(self, "dataset_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description about the dataset.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        eTag description
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="fileType")
    def file_type(self) -> str:
        """
        Dataset FileType, specified by user.
        """
        return pulumi.get(self, "file_type")

    @property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> str:
        """
        The dataset last modified time (UTC).
        """
        return pulumi.get(self, "modified_time")

    @property
    @pulumi.getter
    def notes(self) -> str:
        """
        Summary of Definition changes.
        """
        return pulumi.get(self, "notes")

    @property
    @pulumi.getter(name="partitionFormatInPath")
    def partition_format_in_path(self) -> bool:
        """
        Indicates how the source data is partitioned. This is defined to filter on a range of partitioned data before performing actions or materialization.
        """
        return pulumi.get(self, "partition_format_in_path")

    @property
    @pulumi.getter(name="savedDatasetId")
    def saved_dataset_id(self) -> str:
        """
        Indicates the saved dataset this definition is mapping to, populated on Get.
        """
        return pulumi.get(self, "saved_dataset_id")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        """
        Tags associated with the dataset.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="telemetryInfo")
    def telemetry_info(self) -> Mapping[str, str]:
        """
         Telemetry information about the dataset including information like which service the dataset was created from.
        """
        return pulumi.get(self, "telemetry_info")

    @property
    @pulumi.getter(name="useDescriptionTagsFromDefinition")
    def use_description_tags_from_definition(self) -> bool:
        """
         Whether to use description and tags from the definition level as opposed to dataset level (old behavior).
        """
        return pulumi.get(self, "use_description_tags_from_definition")

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> str:
        """
        An identifier uniquely identifies a definition change.
        """
        return pulumi.get(self, "version_id")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional['outputs.UserInfoResponse']:
        """
        User who created.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="dataPath")
    def data_path(self) -> Optional['outputs.DatasetResponseDataPath']:
        """
         Datastore and reference to location of data such as relativePath, Sql Query and etc.
        """
        return pulumi.get(self, "data_path")

    @property
    @pulumi.getter(name="datasetDefinitionState")
    def dataset_definition_state(self) -> Optional['outputs.DatasetStateResponse']:
        """
        Dataset state
        """
        return pulumi.get(self, "dataset_definition_state")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, Any]]:
        """
        Properties stores information like name of time series column for time series dataset.
        """
        return pulumi.get(self, "properties")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DatasetResponseSqlDataPath(dict):
    """
    Sql Query/Table/Stored Procedure details.
    """
    def __init__(__self__, *,
                 query_timeout: int,
                 sql_query: str,
                 sql_stored_procedure_name: str,
                 sql_table_name: str):
        """
        Sql Query/Table/Stored Procedure details.
        :param int query_timeout: SQL query timeout. Unit in seconds.
        :param str sql_query: SQL query
        :param str sql_stored_procedure_name: SQL storedProcedure name
        :param str sql_table_name: SQL table name
        """
        pulumi.set(__self__, "query_timeout", query_timeout)
        pulumi.set(__self__, "sql_query", sql_query)
        pulumi.set(__self__, "sql_stored_procedure_name", sql_stored_procedure_name)
        pulumi.set(__self__, "sql_table_name", sql_table_name)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> int:
        """
        SQL query timeout. Unit in seconds.
        """
        return pulumi.get(self, "query_timeout")

    @property
    @pulumi.getter(name="sqlQuery")
    def sql_query(self) -> str:
        """
        SQL query
        """
        return pulumi.get(self, "sql_query")

    @property
    @pulumi.getter(name="sqlStoredProcedureName")
    def sql_stored_procedure_name(self) -> str:
        """
        SQL storedProcedure name
        """
        return pulumi.get(self, "sql_stored_procedure_name")

    @property
    @pulumi.getter(name="sqlTableName")
    def sql_table_name(self) -> str:
        """
        SQL table name
        """
        return pulumi.get(self, "sql_table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DatasetStateResponse(dict):
    """
    Dataset state
    """
    def __init__(__self__, *,
                 etag: str,
                 deprecated_by: Optional['outputs.DatasetStateResponseDeprecatedBy'] = None,
                 state: Optional[str] = None):
        """
        Dataset state
        :param str etag: eTag description
        :param 'DatasetStateResponseDeprecatedByArgs' deprecated_by: Reference to better Dataset or a Definition
        :param str state: Dataset state
        """
        pulumi.set(__self__, "etag", etag)
        if deprecated_by is not None:
            pulumi.set(__self__, "deprecated_by", deprecated_by)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        eTag description
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="deprecatedBy")
    def deprecated_by(self) -> Optional['outputs.DatasetStateResponseDeprecatedBy']:
        """
        Reference to better Dataset or a Definition
        """
        return pulumi.get(self, "deprecated_by")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        Dataset state
        """
        return pulumi.get(self, "state")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DatasetStateResponseDeprecatedBy(dict):
    """
    Reference to better Dataset or a Definition
    """
    def __init__(__self__, *,
                 dataset_id: str,
                 definition_version: Optional[str] = None):
        """
        Reference to better Dataset or a Definition
        :param str dataset_id: Unique Dataset identifier.
        :param str definition_version: Definition Version
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        if definition_version is not None:
            pulumi.set(__self__, "definition_version", definition_version)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> str:
        """
        Unique Dataset identifier.
        """
        return pulumi.get(self, "dataset_id")

    @property
    @pulumi.getter(name="definitionVersion")
    def definition_version(self) -> Optional[str]:
        """
        Definition Version
        """
        return pulumi.get(self, "definition_version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DatastoreResponse(dict):
    """
    Machine Learning datastore object.
    """
    def __init__(__self__, *,
                 created_by: 'outputs.UserInfoResponse',
                 created_time: str,
                 modified_by: 'outputs.UserInfoResponse',
                 modified_time: str,
                 tags: Mapping[str, str],
                 azure_data_lake_section: Optional['outputs.AzureDataLakeSectionResponse'] = None,
                 azure_my_sql_section: Optional['outputs.AzureMySqlSectionResponse'] = None,
                 azure_postgre_sql_section: Optional['outputs.AzurePostgreSqlSectionResponse'] = None,
                 azure_sql_database_section: Optional['outputs.AzureSqlDatabaseSectionResponse'] = None,
                 azure_storage_section: Optional['outputs.AzureStorageSectionResponse'] = None,
                 data_store_type: Optional[str] = None,
                 description: Optional[str] = None,
                 gluster_fs_section: Optional['outputs.GlusterFsSectionResponse'] = None,
                 has_been_validated: Optional[bool] = None,
                 linked_info: Optional['outputs.LinkedInfoResponse'] = None,
                 name: Optional[str] = None):
        """
        Machine Learning datastore object.
        :param 'UserInfoResponseArgs' created_by: The User who created the datastore.
        :param str created_time: The date and time when the datastore was created.
        :param 'UserInfoResponseArgs' modified_by: The User who modified the datastore.
        :param str modified_time: The date and time when the datastore was last modified.
        :param Mapping[str, str] tags: Tags for this datastore.
        :param str data_store_type: The datastore type.
        :param str description: Description of the datastore.
        :param 'GlusterFsSectionResponseArgs' gluster_fs_section: Data specific to GlusterFS.
        :param bool has_been_validated: A read only property that denotes whether the service datastore has been validated with credentials.
        :param 'LinkedInfoResponseArgs' linked_info: Info about origin if it is linked.
        :param str name: Name of the datastore.
        """
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "modified_by", modified_by)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "tags", tags)
        if azure_data_lake_section is not None:
            pulumi.set(__self__, "azure_data_lake_section", azure_data_lake_section)
        if azure_my_sql_section is not None:
            pulumi.set(__self__, "azure_my_sql_section", azure_my_sql_section)
        if azure_postgre_sql_section is not None:
            pulumi.set(__self__, "azure_postgre_sql_section", azure_postgre_sql_section)
        if azure_sql_database_section is not None:
            pulumi.set(__self__, "azure_sql_database_section", azure_sql_database_section)
        if azure_storage_section is not None:
            pulumi.set(__self__, "azure_storage_section", azure_storage_section)
        if data_store_type is not None:
            pulumi.set(__self__, "data_store_type", data_store_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if gluster_fs_section is not None:
            pulumi.set(__self__, "gluster_fs_section", gluster_fs_section)
        if has_been_validated is not None:
            pulumi.set(__self__, "has_been_validated", has_been_validated)
        if linked_info is not None:
            pulumi.set(__self__, "linked_info", linked_info)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> 'outputs.UserInfoResponse':
        """
        The User who created the datastore.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> str:
        """
        The date and time when the datastore was created.
        """
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter(name="modifiedBy")
    def modified_by(self) -> 'outputs.UserInfoResponse':
        """
        The User who modified the datastore.
        """
        return pulumi.get(self, "modified_by")

    @property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> str:
        """
        The date and time when the datastore was last modified.
        """
        return pulumi.get(self, "modified_time")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        """
        Tags for this datastore.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="azureDataLakeSection")
    def azure_data_lake_section(self) -> Optional['outputs.AzureDataLakeSectionResponse']:
        return pulumi.get(self, "azure_data_lake_section")

    @property
    @pulumi.getter(name="azureMySqlSection")
    def azure_my_sql_section(self) -> Optional['outputs.AzureMySqlSectionResponse']:
        return pulumi.get(self, "azure_my_sql_section")

    @property
    @pulumi.getter(name="azurePostgreSqlSection")
    def azure_postgre_sql_section(self) -> Optional['outputs.AzurePostgreSqlSectionResponse']:
        return pulumi.get(self, "azure_postgre_sql_section")

    @property
    @pulumi.getter(name="azureSqlDatabaseSection")
    def azure_sql_database_section(self) -> Optional['outputs.AzureSqlDatabaseSectionResponse']:
        return pulumi.get(self, "azure_sql_database_section")

    @property
    @pulumi.getter(name="azureStorageSection")
    def azure_storage_section(self) -> Optional['outputs.AzureStorageSectionResponse']:
        return pulumi.get(self, "azure_storage_section")

    @property
    @pulumi.getter(name="dataStoreType")
    def data_store_type(self) -> Optional[str]:
        """
        The datastore type.
        """
        return pulumi.get(self, "data_store_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the datastore.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="glusterFsSection")
    def gluster_fs_section(self) -> Optional['outputs.GlusterFsSectionResponse']:
        """
        Data specific to GlusterFS.
        """
        return pulumi.get(self, "gluster_fs_section")

    @property
    @pulumi.getter(name="hasBeenValidated")
    def has_been_validated(self) -> Optional[bool]:
        """
        A read only property that denotes whether the service datastore has been validated with credentials.
        """
        return pulumi.get(self, "has_been_validated")

    @property
    @pulumi.getter(name="linkedInfo")
    def linked_info(self) -> Optional['outputs.LinkedInfoResponse']:
        """
        Info about origin if it is linked.
        """
        return pulumi.get(self, "linked_info")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the datastore.
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class EncryptionPropertyResponse(dict):
    def __init__(__self__, *,
                 key_vault_properties: 'outputs.KeyVaultPropertiesResponse',
                 status: str):
        """
        :param 'KeyVaultPropertiesResponseArgs' key_vault_properties: Customer Key vault properties.
        :param str status: Indicates whether or not the encryption is enabled for the workspace.
        """
        pulumi.set(__self__, "key_vault_properties", key_vault_properties)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="keyVaultProperties")
    def key_vault_properties(self) -> 'outputs.KeyVaultPropertiesResponse':
        """
        Customer Key vault properties.
        """
        return pulumi.get(self, "key_vault_properties")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Indicates whether or not the encryption is enabled for the workspace.
        """
        return pulumi.get(self, "status")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class EnvironmentImageResponseResponseEnvironment(dict):
    """
    The details of the AZURE ML environment.
    """
    def __init__(__self__, *,
                 docker: Optional['outputs.ModelEnvironmentDefinitionResponseResponseDocker'] = None,
                 environment_variables: Optional[Mapping[str, str]] = None,
                 inferencing_stack_version: Optional[str] = None,
                 name: Optional[str] = None,
                 python: Optional['outputs.ModelEnvironmentDefinitionResponseResponsePython'] = None,
                 r: Optional['outputs.ModelEnvironmentDefinitionResponseResponseR'] = None,
                 spark: Optional['outputs.ModelEnvironmentDefinitionResponseResponseSpark'] = None,
                 version: Optional[str] = None):
        """
        The details of the AZURE ML environment.
        :param 'ModelEnvironmentDefinitionResponseResponseDockerArgs' docker: The definition of a Docker container.
        :param Mapping[str, str] environment_variables: Definition of environment variables to be defined in the environment.
        :param str inferencing_stack_version: The inferencing stack version added to the image. To avoid adding an inferencing stack, do not set this value. Valid values: "latest".
        :param str name: The name of the environment.
        :param 'ModelEnvironmentDefinitionResponseResponsePythonArgs' python: Settings for a Python environment.
        :param 'ModelEnvironmentDefinitionResponseResponseRArgs' r: Settings for a R environment.
        :param 'ModelEnvironmentDefinitionResponseResponseSparkArgs' spark: The configuration for a Spark environment.
        :param str version: The environment version.
        """
        if docker is not None:
            pulumi.set(__self__, "docker", docker)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if inferencing_stack_version is not None:
            pulumi.set(__self__, "inferencing_stack_version", inferencing_stack_version)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if python is not None:
            pulumi.set(__self__, "python", python)
        if r is not None:
            pulumi.set(__self__, "r", r)
        if spark is not None:
            pulumi.set(__self__, "spark", spark)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def docker(self) -> Optional['outputs.ModelEnvironmentDefinitionResponseResponseDocker']:
        """
        The definition of a Docker container.
        """
        return pulumi.get(self, "docker")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, str]]:
        """
        Definition of environment variables to be defined in the environment.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="inferencingStackVersion")
    def inferencing_stack_version(self) -> Optional[str]:
        """
        The inferencing stack version added to the image. To avoid adding an inferencing stack, do not set this value. Valid values: "latest".
        """
        return pulumi.get(self, "inferencing_stack_version")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the environment.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def python(self) -> Optional['outputs.ModelEnvironmentDefinitionResponseResponsePython']:
        """
        Settings for a Python environment.
        """
        return pulumi.get(self, "python")

    @property
    @pulumi.getter
    def r(self) -> Optional['outputs.ModelEnvironmentDefinitionResponseResponseR']:
        """
        Settings for a R environment.
        """
        return pulumi.get(self, "r")

    @property
    @pulumi.getter
    def spark(self) -> Optional['outputs.ModelEnvironmentDefinitionResponseResponseSpark']:
        """
        The configuration for a Spark environment.
        """
        return pulumi.get(self, "spark")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The environment version.
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class EnvironmentImageResponseResponseEnvironmentReference(dict):
    """
    The unique identifying details of the AZURE ML environment.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 version: Optional[str] = None):
        """
        The unique identifying details of the AZURE ML environment.
        :param str name: Name of the environment.
        :param str version: Version of the environment.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the environment.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of the environment.
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ErrorDetailResponse(dict):
    """
    Error detail information.
    """
    def __init__(__self__, *,
                 code: str,
                 message: str):
        """
        Error detail information.
        :param str code: Error code.
        :param str message: Error message.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> str:
        """
        Error code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Error message.
        """
        return pulumi.get(self, "message")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ErrorResponseResponse(dict):
    """
    Error response information.
    """
    def __init__(__self__, *,
                 code: str,
                 details: Sequence['outputs.ErrorDetailResponse'],
                 message: str):
        """
        Error response information.
        :param str code: Error code.
        :param Sequence['ErrorDetailResponseArgs'] details: An array of error detail objects.
        :param str message: Error message.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> str:
        """
        Error code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.ErrorDetailResponse']:
        """
        An array of error detail objects.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Error message.
        """
        return pulumi.get(self, "message")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlusterFsSectionResponse(dict):
    """
    Data specific to GlusterFS.
    """
    def __init__(__self__, *,
                 server_address: str,
                 volume_name: str):
        """
        Data specific to GlusterFS.
        :param str server_address: The server address of one of the servers that hosts the GlusterFS. Can be either the IP address or server name.
        :param str volume_name: The name of the created GlusterFS volume.
        """
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "volume_name", volume_name)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        """
        The server address of one of the servers that hosts the GlusterFS. Can be either the IP address or server name.
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> str:
        """
        The name of the created GlusterFS volume.
        """
        return pulumi.get(self, "volume_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HDInsightResponse(dict):
    """
    A HDInsight compute.
    """
    def __init__(__self__, *,
                 compute_type: str,
                 created_on: str,
                 is_attached_compute: bool,
                 modified_on: str,
                 provisioning_errors: Sequence['outputs.MachineLearningServiceErrorResponse'],
                 provisioning_state: str,
                 compute_location: Optional[str] = None,
                 description: Optional[str] = None,
                 properties: Optional['outputs.HDInsightResponseProperties'] = None,
                 resource_id: Optional[str] = None):
        """
        A HDInsight compute.
        :param str compute_type: The type of compute
        :param str created_on: The date and time when the compute was created.
        :param bool is_attached_compute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        :param str modified_on: The date and time when the compute was last modified.
        :param Sequence['MachineLearningServiceErrorResponseArgs'] provisioning_errors: Errors during provisioning
        :param str provisioning_state: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        :param str compute_location: Location for the underlying compute
        :param str description: The description of the Machine Learning compute.
        :param str resource_id: ARM resource id of the underlying compute
        """
        pulumi.set(__self__, "compute_type", 'HDInsight')
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "is_attached_compute", is_attached_compute)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "provisioning_errors", provisioning_errors)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if compute_location is not None:
            pulumi.set(__self__, "compute_location", compute_location)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> str:
        """
        The type of compute
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        The date and time when the compute was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="isAttachedCompute")
    def is_attached_compute(self) -> bool:
        """
        Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        """
        return pulumi.get(self, "is_attached_compute")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        The date and time when the compute was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="provisioningErrors")
    def provisioning_errors(self) -> Sequence['outputs.MachineLearningServiceErrorResponse']:
        """
        Errors during provisioning
        """
        return pulumi.get(self, "provisioning_errors")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[str]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.HDInsightResponseProperties']:
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HDInsightResponseProperties(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 administrator_account: Optional['outputs.VirtualMachineSshCredentialsResponse'] = None,
                 ssh_port: Optional[int] = None):
        """
        :param str address: Public IP address of the master node of the cluster.
        :param 'VirtualMachineSshCredentialsResponseArgs' administrator_account: Admin credentials for master node of the cluster
        :param int ssh_port: Port open for ssh connections on the master node of the cluster.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if administrator_account is not None:
            pulumi.set(__self__, "administrator_account", administrator_account)
        if ssh_port is not None:
            pulumi.set(__self__, "ssh_port", ssh_port)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Public IP address of the master node of the cluster.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="administratorAccount")
    def administrator_account(self) -> Optional['outputs.VirtualMachineSshCredentialsResponse']:
        """
        Admin credentials for master node of the cluster
        """
        return pulumi.get(self, "administrator_account")

    @property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[int]:
        """
        Port open for ssh connections on the master node of the cluster.
        """
        return pulumi.get(self, "ssh_port")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IdentityResponse(dict):
    """
    Identity for the resource.
    """
    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: Optional[str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Identity for the resource.
        :param str principal_id: The principal ID of resource identity.
        :param str tenant_id: The tenant ID of resource.
        :param str type: The identity type.
        :param Mapping[str, 'UserAssignedIdentityResponseArgs'] user_assigned_identities: The user assigned identities associated with the resource.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of resource identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of resource.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The identity type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The user assigned identities associated with the resource.
        """
        return pulumi.get(self, "user_assigned_identities")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ImageAssetResponse(dict):
    """
    An Image asset.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 mime_type: Optional[str] = None,
                 unpack: Optional[bool] = None,
                 url: Optional[str] = None):
        """
        An Image asset.
        :param str id: The Asset Id.
        :param str mime_type: The mime type.
        :param bool unpack: Whether the Asset is unpacked.
        :param str url: The Url of the Asset.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mime_type is not None:
            pulumi.set(__self__, "mime_type", mime_type)
        if unpack is not None:
            pulumi.set(__self__, "unpack", unpack)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The Asset Id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="mimeType")
    def mime_type(self) -> Optional[str]:
        """
        The mime type.
        """
        return pulumi.get(self, "mime_type")

    @property
    @pulumi.getter
    def unpack(self) -> Optional[bool]:
        """
        Whether the Asset is unpacked.
        """
        return pulumi.get(self, "unpack")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The Url of the Asset.
        """
        return pulumi.get(self, "url")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeyVaultPropertiesResponse(dict):
    def __init__(__self__, *,
                 key_identifier: str,
                 key_vault_arm_id: str,
                 identity_client_id: Optional[str] = None):
        """
        :param str key_identifier: Key vault uri to access the encryption key.
        :param str key_vault_arm_id: The ArmId of the keyVault where the customer owned encryption key is present.
        :param str identity_client_id: For future use - The client id of the identity which will be used to access key vault.
        """
        pulumi.set(__self__, "key_identifier", key_identifier)
        pulumi.set(__self__, "key_vault_arm_id", key_vault_arm_id)
        if identity_client_id is not None:
            pulumi.set(__self__, "identity_client_id", identity_client_id)

    @property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> str:
        """
        Key vault uri to access the encryption key.
        """
        return pulumi.get(self, "key_identifier")

    @property
    @pulumi.getter(name="keyVaultArmId")
    def key_vault_arm_id(self) -> str:
        """
        The ArmId of the keyVault where the customer owned encryption key is present.
        """
        return pulumi.get(self, "key_vault_arm_id")

    @property
    @pulumi.getter(name="identityClientId")
    def identity_client_id(self) -> Optional[str]:
        """
        For future use - The client id of the identity which will be used to access key vault.
        """
        return pulumi.get(self, "identity_client_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LinkedInfoResponse(dict):
    """
    Info about origin if it is linked.
    """
    def __init__(__self__, *,
                 linked_id: Optional[str] = None,
                 linked_resource_name: Optional[str] = None,
                 origin: Optional[str] = None):
        """
        Info about origin if it is linked.
        :param str linked_id: LinkedId id.
        :param str linked_resource_name: Linked resource name.
        :param str origin: Datastore origin
        """
        if linked_id is not None:
            pulumi.set(__self__, "linked_id", linked_id)
        if linked_resource_name is not None:
            pulumi.set(__self__, "linked_resource_name", linked_resource_name)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)

    @property
    @pulumi.getter(name="linkedId")
    def linked_id(self) -> Optional[str]:
        """
        LinkedId id.
        """
        return pulumi.get(self, "linked_id")

    @property
    @pulumi.getter(name="linkedResourceName")
    def linked_resource_name(self) -> Optional[str]:
        """
        Linked resource name.
        """
        return pulumi.get(self, "linked_resource_name")

    @property
    @pulumi.getter
    def origin(self) -> Optional[str]:
        """
        Datastore origin
        """
        return pulumi.get(self, "origin")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LinkedWorkspacePropsResponse(dict):
    """
    LinkedWorkspace specific properties.
    """
    def __init__(__self__, *,
                 linked_workspace_resource_id: Optional[str] = None,
                 user_assigned_identity_resource_id: Optional[str] = None):
        """
        LinkedWorkspace specific properties.
        :param str linked_workspace_resource_id: ResourceId of the link target of the linked workspace.
        :param str user_assigned_identity_resource_id: ResourceId of the user assigned identity for the linked workspace.
        """
        if linked_workspace_resource_id is not None:
            pulumi.set(__self__, "linked_workspace_resource_id", linked_workspace_resource_id)
        if user_assigned_identity_resource_id is not None:
            pulumi.set(__self__, "user_assigned_identity_resource_id", user_assigned_identity_resource_id)

    @property
    @pulumi.getter(name="linkedWorkspaceResourceId")
    def linked_workspace_resource_id(self) -> Optional[str]:
        """
        ResourceId of the link target of the linked workspace.
        """
        return pulumi.get(self, "linked_workspace_resource_id")

    @property
    @pulumi.getter(name="userAssignedIdentityResourceId")
    def user_assigned_identity_resource_id(self) -> Optional[str]:
        """
        ResourceId of the user assigned identity for the linked workspace.
        """
        return pulumi.get(self, "user_assigned_identity_resource_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MachineLearningServiceErrorResponse(dict):
    """
    Wrapper for error response to follow ARM guidelines.
    """
    def __init__(__self__, *,
                 error: 'outputs.ErrorResponseResponse'):
        """
        Wrapper for error response to follow ARM guidelines.
        :param 'ErrorResponseResponseArgs' error: The error response.
        """
        pulumi.set(__self__, "error", error)

    @property
    @pulumi.getter
    def error(self) -> 'outputs.ErrorResponseResponse':
        """
        The error response.
        """
        return pulumi.get(self, "error")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ModelDockerSectionResponseResponseBaseImageRegistry(dict):
    """
    Image registry that contains the base image.
    """
    def __init__(__self__, *,
                 address: Optional[str] = None):
        """
        Image registry that contains the base image.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        return pulumi.get(self, "address")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ModelEnvironmentDefinitionResponseResponseDocker(dict):
    """
    The definition of a Docker container.
    """
    def __init__(__self__, *,
                 base_dockerfile: Optional[str] = None,
                 base_image: Optional[str] = None,
                 base_image_registry: Optional['outputs.ModelDockerSectionResponseResponseBaseImageRegistry'] = None):
        """
        The definition of a Docker container.
        :param str base_dockerfile: Base Dockerfile used for Docker-based runs. Mutually exclusive with BaseImage.
        :param str base_image: Base image used for Docker-based runs. Mutually exclusive with BaseDockerfile.
        :param 'ModelDockerSectionResponseResponseBaseImageRegistryArgs' base_image_registry: Image registry that contains the base image.
        """
        if base_dockerfile is not None:
            pulumi.set(__self__, "base_dockerfile", base_dockerfile)
        if base_image is not None:
            pulumi.set(__self__, "base_image", base_image)
        if base_image_registry is not None:
            pulumi.set(__self__, "base_image_registry", base_image_registry)

    @property
    @pulumi.getter(name="baseDockerfile")
    def base_dockerfile(self) -> Optional[str]:
        """
        Base Dockerfile used for Docker-based runs. Mutually exclusive with BaseImage.
        """
        return pulumi.get(self, "base_dockerfile")

    @property
    @pulumi.getter(name="baseImage")
    def base_image(self) -> Optional[str]:
        """
        Base image used for Docker-based runs. Mutually exclusive with BaseDockerfile.
        """
        return pulumi.get(self, "base_image")

    @property
    @pulumi.getter(name="baseImageRegistry")
    def base_image_registry(self) -> Optional['outputs.ModelDockerSectionResponseResponseBaseImageRegistry']:
        """
        Image registry that contains the base image.
        """
        return pulumi.get(self, "base_image_registry")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ModelEnvironmentDefinitionResponseResponsePython(dict):
    """
    Settings for a Python environment.
    """
    def __init__(__self__, *,
                 base_conda_environment: Optional[str] = None,
                 conda_dependencies: Optional[Any] = None,
                 interpreter_path: Optional[str] = None,
                 user_managed_dependencies: Optional[bool] = None):
        """
        Settings for a Python environment.
        :param Any conda_dependencies: A JObject containing Conda dependencies.
        :param str interpreter_path: The python interpreter path to use if an environment build is not required. The path specified gets used to call the user script.
        :param bool user_managed_dependencies: True means that AzureML reuses an existing python environment; False means that AzureML will create a python environment based on the Conda dependencies specification.
        """
        if base_conda_environment is not None:
            pulumi.set(__self__, "base_conda_environment", base_conda_environment)
        if conda_dependencies is not None:
            pulumi.set(__self__, "conda_dependencies", conda_dependencies)
        if interpreter_path is not None:
            pulumi.set(__self__, "interpreter_path", interpreter_path)
        if user_managed_dependencies is not None:
            pulumi.set(__self__, "user_managed_dependencies", user_managed_dependencies)

    @property
    @pulumi.getter(name="baseCondaEnvironment")
    def base_conda_environment(self) -> Optional[str]:
        return pulumi.get(self, "base_conda_environment")

    @property
    @pulumi.getter(name="condaDependencies")
    def conda_dependencies(self) -> Optional[Any]:
        """
        A JObject containing Conda dependencies.
        """
        return pulumi.get(self, "conda_dependencies")

    @property
    @pulumi.getter(name="interpreterPath")
    def interpreter_path(self) -> Optional[str]:
        """
        The python interpreter path to use if an environment build is not required. The path specified gets used to call the user script.
        """
        return pulumi.get(self, "interpreter_path")

    @property
    @pulumi.getter(name="userManagedDependencies")
    def user_managed_dependencies(self) -> Optional[bool]:
        """
        True means that AzureML reuses an existing python environment; False means that AzureML will create a python environment based on the Conda dependencies specification.
        """
        return pulumi.get(self, "user_managed_dependencies")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ModelEnvironmentDefinitionResponseResponseR(dict):
    """
    Settings for a R environment.
    """
    def __init__(__self__, *,
                 bio_conductor_packages: Optional[Sequence[str]] = None,
                 cran_packages: Optional[Sequence['outputs.RCranPackageResponse']] = None,
                 custom_url_packages: Optional[Sequence[str]] = None,
                 git_hub_packages: Optional[Sequence['outputs.RGitHubPackageResponseResponse']] = None,
                 r_version: Optional[str] = None,
                 rscript_path: Optional[str] = None,
                 snapshot_date: Optional[str] = None,
                 user_managed: Optional[bool] = None):
        """
        Settings for a R environment.
        :param Sequence[str] bio_conductor_packages: The packages from Bioconductor.
        :param Sequence['RCranPackageResponseArgs'] cran_packages: The CRAN packages to use.
        :param Sequence[str] custom_url_packages: The packages from custom urls.
        :param Sequence['RGitHubPackageResponseResponseArgs'] git_hub_packages: The packages directly from GitHub.
        :param str r_version: The version of R to be installed
        :param str rscript_path: The Rscript path to use if an environment build is not required.
               The path specified gets used to call the user script.
        :param str snapshot_date: Date of MRAN snapshot to use in YYYY-MM-DD format, e.g. "2019-04-17"
        :param bool user_managed: Indicates whether the environment is managed by user or by AzureML.
        """
        if bio_conductor_packages is not None:
            pulumi.set(__self__, "bio_conductor_packages", bio_conductor_packages)
        if cran_packages is not None:
            pulumi.set(__self__, "cran_packages", cran_packages)
        if custom_url_packages is not None:
            pulumi.set(__self__, "custom_url_packages", custom_url_packages)
        if git_hub_packages is not None:
            pulumi.set(__self__, "git_hub_packages", git_hub_packages)
        if r_version is not None:
            pulumi.set(__self__, "r_version", r_version)
        if rscript_path is not None:
            pulumi.set(__self__, "rscript_path", rscript_path)
        if snapshot_date is not None:
            pulumi.set(__self__, "snapshot_date", snapshot_date)
        if user_managed is not None:
            pulumi.set(__self__, "user_managed", user_managed)

    @property
    @pulumi.getter(name="bioConductorPackages")
    def bio_conductor_packages(self) -> Optional[Sequence[str]]:
        """
        The packages from Bioconductor.
        """
        return pulumi.get(self, "bio_conductor_packages")

    @property
    @pulumi.getter(name="cranPackages")
    def cran_packages(self) -> Optional[Sequence['outputs.RCranPackageResponse']]:
        """
        The CRAN packages to use.
        """
        return pulumi.get(self, "cran_packages")

    @property
    @pulumi.getter(name="customUrlPackages")
    def custom_url_packages(self) -> Optional[Sequence[str]]:
        """
        The packages from custom urls.
        """
        return pulumi.get(self, "custom_url_packages")

    @property
    @pulumi.getter(name="gitHubPackages")
    def git_hub_packages(self) -> Optional[Sequence['outputs.RGitHubPackageResponseResponse']]:
        """
        The packages directly from GitHub.
        """
        return pulumi.get(self, "git_hub_packages")

    @property
    @pulumi.getter(name="rVersion")
    def r_version(self) -> Optional[str]:
        """
        The version of R to be installed
        """
        return pulumi.get(self, "r_version")

    @property
    @pulumi.getter(name="rscriptPath")
    def rscript_path(self) -> Optional[str]:
        """
        The Rscript path to use if an environment build is not required.
        The path specified gets used to call the user script.
        """
        return pulumi.get(self, "rscript_path")

    @property
    @pulumi.getter(name="snapshotDate")
    def snapshot_date(self) -> Optional[str]:
        """
        Date of MRAN snapshot to use in YYYY-MM-DD format, e.g. "2019-04-17"
        """
        return pulumi.get(self, "snapshot_date")

    @property
    @pulumi.getter(name="userManaged")
    def user_managed(self) -> Optional[bool]:
        """
        Indicates whether the environment is managed by user or by AzureML.
        """
        return pulumi.get(self, "user_managed")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ModelEnvironmentDefinitionResponseResponseSpark(dict):
    """
    The configuration for a Spark environment.
    """
    def __init__(__self__, *,
                 packages: Optional[Sequence['outputs.SparkMavenPackageResponse']] = None,
                 precache_packages: Optional[bool] = None,
                 repositories: Optional[Sequence[str]] = None):
        """
        The configuration for a Spark environment.
        :param Sequence['SparkMavenPackageResponseArgs'] packages: The Spark packages to use.
        :param bool precache_packages: Whether to precache the packages.
        :param Sequence[str] repositories: The list of spark repositories.
        """
        if packages is not None:
            pulumi.set(__self__, "packages", packages)
        if precache_packages is not None:
            pulumi.set(__self__, "precache_packages", precache_packages)
        if repositories is not None:
            pulumi.set(__self__, "repositories", repositories)

    @property
    @pulumi.getter
    def packages(self) -> Optional[Sequence['outputs.SparkMavenPackageResponse']]:
        """
        The Spark packages to use.
        """
        return pulumi.get(self, "packages")

    @property
    @pulumi.getter(name="precachePackages")
    def precache_packages(self) -> Optional[bool]:
        """
        Whether to precache the packages.
        """
        return pulumi.get(self, "precache_packages")

    @property
    @pulumi.getter
    def repositories(self) -> Optional[Sequence[str]]:
        """
        The list of spark repositories.
        """
        return pulumi.get(self, "repositories")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ModelResponse(dict):
    """
    An Azure Machine Learning Model.
    """
    def __init__(__self__, *,
                 mime_type: str,
                 name: str,
                 url: str,
                 created_time: Optional[str] = None,
                 datasets: Optional[Sequence['outputs.DatasetReferenceResponse']] = None,
                 derived_model_ids: Optional[Sequence[str]] = None,
                 description: Optional[str] = None,
                 experiment_name: Optional[str] = None,
                 framework: Optional[str] = None,
                 framework_version: Optional[str] = None,
                 id: Optional[str] = None,
                 kv_tags: Optional[Mapping[str, str]] = None,
                 modified_time: Optional[str] = None,
                 parent_model_id: Optional[str] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 resource_requirements: Optional['outputs.ContainerResourceRequirementsResponse'] = None,
                 run_id: Optional[str] = None,
                 sample_input_data: Optional[str] = None,
                 sample_output_data: Optional[str] = None,
                 unpack: Optional[bool] = None,
                 version: Optional[int] = None):
        """
        An Azure Machine Learning Model.
        :param str mime_type: The MIME type of Model content. For more details about MIME type, please open https://www.iana.org/assignments/media-types/media-types.xhtml
        :param str name: The Model name.
        :param str url: The URL of the Model. Usually a SAS URL.
        :param str created_time: The Model creation time (UTC).
        :param Sequence['DatasetReferenceResponseArgs'] datasets: The list of datasets associated with the model.
        :param Sequence[str] derived_model_ids: Models derived from this model
        :param str description: The Model description text.
        :param str experiment_name: The name of the experiment where this model was created.
        :param str framework: The Model framework.
        :param str framework_version: The Model framework version.
        :param str id: The Model Id.
        :param Mapping[str, str] kv_tags: The Model tag dictionary. Items are mutable.
        :param str modified_time: The Model last modified time (UTC).
        :param str parent_model_id: The Parent Model Id.
        :param Mapping[str, str] properties: The Model property dictionary. Properties are immutable.
        :param 'ContainerResourceRequirementsResponseArgs' resource_requirements: Resource requirements for the model
        :param str run_id: The RunId that created this model.
        :param str sample_input_data: Sample Input Data for the Model. A reference to a dataset in the workspace in the format aml://dataset/{datasetId}
        :param str sample_output_data: Sample Output Data for the Model. A reference to a dataset in the workspace in the format aml://dataset/{datasetId}
        :param bool unpack: Indicates whether we need to unpack the Model during docker Image creation.
        :param int version: The Model version assigned by Model Management Service.
        """
        pulumi.set(__self__, "mime_type", mime_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if created_time is not None:
            pulumi.set(__self__, "created_time", created_time)
        if datasets is not None:
            pulumi.set(__self__, "datasets", datasets)
        if derived_model_ids is not None:
            pulumi.set(__self__, "derived_model_ids", derived_model_ids)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if experiment_name is not None:
            pulumi.set(__self__, "experiment_name", experiment_name)
        if framework is not None:
            pulumi.set(__self__, "framework", framework)
        if framework_version is not None:
            pulumi.set(__self__, "framework_version", framework_version)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kv_tags is not None:
            pulumi.set(__self__, "kv_tags", kv_tags)
        if modified_time is not None:
            pulumi.set(__self__, "modified_time", modified_time)
        if parent_model_id is not None:
            pulumi.set(__self__, "parent_model_id", parent_model_id)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_requirements is not None:
            pulumi.set(__self__, "resource_requirements", resource_requirements)
        if run_id is not None:
            pulumi.set(__self__, "run_id", run_id)
        if sample_input_data is not None:
            pulumi.set(__self__, "sample_input_data", sample_input_data)
        if sample_output_data is not None:
            pulumi.set(__self__, "sample_output_data", sample_output_data)
        if unpack is not None:
            pulumi.set(__self__, "unpack", unpack)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="mimeType")
    def mime_type(self) -> str:
        """
        The MIME type of Model content. For more details about MIME type, please open https://www.iana.org/assignments/media-types/media-types.xhtml
        """
        return pulumi.get(self, "mime_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Model name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the Model. Usually a SAS URL.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> Optional[str]:
        """
        The Model creation time (UTC).
        """
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter
    def datasets(self) -> Optional[Sequence['outputs.DatasetReferenceResponse']]:
        """
        The list of datasets associated with the model.
        """
        return pulumi.get(self, "datasets")

    @property
    @pulumi.getter(name="derivedModelIds")
    def derived_model_ids(self) -> Optional[Sequence[str]]:
        """
        Models derived from this model
        """
        return pulumi.get(self, "derived_model_ids")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The Model description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="experimentName")
    def experiment_name(self) -> Optional[str]:
        """
        The name of the experiment where this model was created.
        """
        return pulumi.get(self, "experiment_name")

    @property
    @pulumi.getter
    def framework(self) -> Optional[str]:
        """
        The Model framework.
        """
        return pulumi.get(self, "framework")

    @property
    @pulumi.getter(name="frameworkVersion")
    def framework_version(self) -> Optional[str]:
        """
        The Model framework version.
        """
        return pulumi.get(self, "framework_version")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The Model Id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="kvTags")
    def kv_tags(self) -> Optional[Mapping[str, str]]:
        """
        The Model tag dictionary. Items are mutable.
        """
        return pulumi.get(self, "kv_tags")

    @property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> Optional[str]:
        """
        The Model last modified time (UTC).
        """
        return pulumi.get(self, "modified_time")

    @property
    @pulumi.getter(name="parentModelId")
    def parent_model_id(self) -> Optional[str]:
        """
        The Parent Model Id.
        """
        return pulumi.get(self, "parent_model_id")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The Model property dictionary. Properties are immutable.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="resourceRequirements")
    def resource_requirements(self) -> Optional['outputs.ContainerResourceRequirementsResponse']:
        """
        Resource requirements for the model
        """
        return pulumi.get(self, "resource_requirements")

    @property
    @pulumi.getter(name="runId")
    def run_id(self) -> Optional[str]:
        """
        The RunId that created this model.
        """
        return pulumi.get(self, "run_id")

    @property
    @pulumi.getter(name="sampleInputData")
    def sample_input_data(self) -> Optional[str]:
        """
        Sample Input Data for the Model. A reference to a dataset in the workspace in the format aml://dataset/{datasetId}
        """
        return pulumi.get(self, "sample_input_data")

    @property
    @pulumi.getter(name="sampleOutputData")
    def sample_output_data(self) -> Optional[str]:
        """
        Sample Output Data for the Model. A reference to a dataset in the workspace in the format aml://dataset/{datasetId}
        """
        return pulumi.get(self, "sample_output_data")

    @property
    @pulumi.getter
    def unpack(self) -> Optional[bool]:
        """
        Indicates whether we need to unpack the Model during docker Image creation.
        """
        return pulumi.get(self, "unpack")

    @property
    @pulumi.getter
    def version(self) -> Optional[int]:
        """
        The Model version assigned by Model Management Service.
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NodeStateCountsResponse(dict):
    """
    Counts of various compute node states on the amlCompute.
    """
    def __init__(__self__, *,
                 idle_node_count: int,
                 leaving_node_count: int,
                 preempted_node_count: int,
                 preparing_node_count: int,
                 running_node_count: int,
                 unusable_node_count: int):
        """
        Counts of various compute node states on the amlCompute.
        :param int idle_node_count: Number of compute nodes in idle state.
        :param int leaving_node_count: Number of compute nodes which are leaving the amlCompute.
        :param int preempted_node_count: Number of compute nodes which are in preempted state.
        :param int preparing_node_count: Number of compute nodes which are being prepared.
        :param int running_node_count: Number of compute nodes which are running jobs.
        :param int unusable_node_count: Number of compute nodes which are in unusable state.
        """
        pulumi.set(__self__, "idle_node_count", idle_node_count)
        pulumi.set(__self__, "leaving_node_count", leaving_node_count)
        pulumi.set(__self__, "preempted_node_count", preempted_node_count)
        pulumi.set(__self__, "preparing_node_count", preparing_node_count)
        pulumi.set(__self__, "running_node_count", running_node_count)
        pulumi.set(__self__, "unusable_node_count", unusable_node_count)

    @property
    @pulumi.getter(name="idleNodeCount")
    def idle_node_count(self) -> int:
        """
        Number of compute nodes in idle state.
        """
        return pulumi.get(self, "idle_node_count")

    @property
    @pulumi.getter(name="leavingNodeCount")
    def leaving_node_count(self) -> int:
        """
        Number of compute nodes which are leaving the amlCompute.
        """
        return pulumi.get(self, "leaving_node_count")

    @property
    @pulumi.getter(name="preemptedNodeCount")
    def preempted_node_count(self) -> int:
        """
        Number of compute nodes which are in preempted state.
        """
        return pulumi.get(self, "preempted_node_count")

    @property
    @pulumi.getter(name="preparingNodeCount")
    def preparing_node_count(self) -> int:
        """
        Number of compute nodes which are being prepared.
        """
        return pulumi.get(self, "preparing_node_count")

    @property
    @pulumi.getter(name="runningNodeCount")
    def running_node_count(self) -> int:
        """
        Number of compute nodes which are running jobs.
        """
        return pulumi.get(self, "running_node_count")

    @property
    @pulumi.getter(name="unusableNodeCount")
    def unusable_node_count(self) -> int:
        """
        Number of compute nodes which are in unusable state.
        """
        return pulumi.get(self, "unusable_node_count")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PasswordResponseResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class PrivateEndpointConnectionResponse(dict):
    """
    The Private Endpoint Connection resource.
    """
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 private_link_service_connection_state: 'outputs.PrivateLinkServiceConnectionStateResponse',
                 provisioning_state: str,
                 type: str,
                 identity: Optional['outputs.IdentityResponse'] = None,
                 location: Optional[str] = None,
                 private_endpoint: Optional['outputs.PrivateEndpointResponse'] = None,
                 sku: Optional['outputs.SkuResponse'] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        The Private Endpoint Connection resource.
        :param str id: Specifies the resource ID.
        :param str name: Specifies the name of the resource.
        :param 'PrivateLinkServiceConnectionStateResponseArgs' private_link_service_connection_state: A collection of information about the state of the connection between service consumer and provider.
        :param str provisioning_state: The provisioning state of the private endpoint connection resource.
        :param str type: Specifies the type of the resource.
        :param 'IdentityResponseArgs' identity: The identity of the resource.
        :param str location: Specifies the location of the resource.
        :param 'PrivateEndpointResponseArgs' private_endpoint: The resource of private end point.
        :param 'SkuResponseArgs' sku: The sku of the workspace.
        :param Mapping[str, str] tags: Contains resource tags defined as key/value pairs.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_link_service_connection_state", private_link_service_connection_state)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "type", type)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Specifies the resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> 'outputs.PrivateLinkServiceConnectionStateResponse':
        """
        A collection of information about the state of the connection between service consumer and provider.
        """
        return pulumi.get(self, "private_link_service_connection_state")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the private endpoint connection resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of the resource.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def identity(self) -> Optional['outputs.IdentityResponse']:
        """
        The identity of the resource.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Specifies the location of the resource.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.PrivateEndpointResponse']:
        """
        The resource of private end point.
        """
        return pulumi.get(self, "private_endpoint")

    @property
    @pulumi.getter
    def sku(self) -> Optional['outputs.SkuResponse']:
        """
        The sku of the workspace.
        """
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Contains resource tags defined as key/value pairs.
        """
        return pulumi.get(self, "tags")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PrivateEndpointResponse(dict):
    """
    The Private Endpoint resource.
    """
    def __init__(__self__, *,
                 id: str):
        """
        The Private Endpoint resource.
        :param str id: The ARM identifier for Private Endpoint
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ARM identifier for Private Endpoint
        """
        return pulumi.get(self, "id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PrivateLinkServiceConnectionStateResponse(dict):
    """
    A collection of information about the state of the connection between service consumer and provider.
    """
    def __init__(__self__, *,
                 actions_required: Optional[str] = None,
                 description: Optional[str] = None,
                 status: Optional[str] = None):
        """
        A collection of information about the state of the connection between service consumer and provider.
        :param str actions_required: A message indicating if changes on the service provider require any updates on the consumer.
        :param str description: The reason for approval/rejection of the connection.
        :param str status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        if actions_required is not None:
            pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[str]:
        """
        A message indicating if changes on the service provider require any updates on the consumer.
        """
        return pulumi.get(self, "actions_required")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The reason for approval/rejection of the connection.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        return pulumi.get(self, "status")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RCranPackageResponse(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 repository: Optional[str] = None):
        """
        :param str name: The package name.
        :param str repository: The repository name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if repository is not None:
            pulumi.set(__self__, "repository", repository)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The package name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def repository(self) -> Optional[str]:
        """
        The repository name.
        """
        return pulumi.get(self, "repository")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RGitHubPackageResponseResponse(dict):
    def __init__(__self__, *,
                 repository: Optional[str] = None):
        """
        :param str repository: Repository address in the format username/repo[/subdir][@ref|#pull].
        """
        if repository is not None:
            pulumi.set(__self__, "repository", repository)

    @property
    @pulumi.getter
    def repository(self) -> Optional[str]:
        """
        Repository address in the format username/repo[/subdir][@ref|#pull].
        """
        return pulumi.get(self, "repository")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RegistryListCredentialsResultResponseResult(dict):
    def __init__(__self__, *,
                 location: str,
                 username: str,
                 passwords: Optional[Sequence['outputs.PasswordResponseResult']] = None):
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "username", username)
        if passwords is not None:
            pulumi.set(__self__, "passwords", passwords)

    @property
    @pulumi.getter
    def location(self) -> str:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def passwords(self) -> Optional[Sequence['outputs.PasswordResponseResult']]:
        return pulumi.get(self, "passwords")


@pulumi.output_type
class ResourceIdResponse(dict):
    """
    Represents a resource ID. For example, for a subnet, it is the resource URL for the subnet.
    """
    def __init__(__self__, *,
                 id: str):
        """
        Represents a resource ID. For example, for a subnet, it is the resource URL for the subnet.
        :param str id: The ID of the resource
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the resource
        """
        return pulumi.get(self, "id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScaleSettingsResponse(dict):
    """
    scale settings for AML Compute
    """
    def __init__(__self__, *,
                 max_node_count: int,
                 min_node_count: Optional[int] = None,
                 node_idle_time_before_scale_down: Optional[str] = None):
        """
        scale settings for AML Compute
        :param int max_node_count: Max number of nodes to use
        :param int min_node_count: Min number of nodes to use
        :param str node_idle_time_before_scale_down: Node Idle Time before scaling down amlCompute
        """
        pulumi.set(__self__, "max_node_count", max_node_count)
        if min_node_count is not None:
            pulumi.set(__self__, "min_node_count", min_node_count)
        if node_idle_time_before_scale_down is not None:
            pulumi.set(__self__, "node_idle_time_before_scale_down", node_idle_time_before_scale_down)

    @property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> int:
        """
        Max number of nodes to use
        """
        return pulumi.get(self, "max_node_count")

    @property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> Optional[int]:
        """
        Min number of nodes to use
        """
        return pulumi.get(self, "min_node_count")

    @property
    @pulumi.getter(name="nodeIdleTimeBeforeScaleDown")
    def node_idle_time_before_scale_down(self) -> Optional[str]:
        """
        Node Idle Time before scaling down amlCompute
        """
        return pulumi.get(self, "node_idle_time_before_scale_down")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceResponseBaseResponseError(dict):
    """
    The error details.
    """
    def __init__(__self__, *,
                 code: str,
                 details: Sequence['outputs.ErrorDetailResponse'],
                 message: str):
        """
        The error details.
        :param str code: Error code.
        :param Sequence['ErrorDetailResponseArgs'] details: An array of error detail objects.
        :param str message: Error message.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> str:
        """
        Error code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.ErrorDetailResponse']:
        """
        An array of error detail objects.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Error message.
        """
        return pulumi.get(self, "message")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SharedPrivateLinkResourceResponse(dict):
    def __init__(__self__, *,
                 group_id: Optional[str] = None,
                 name: Optional[str] = None,
                 private_link_resource_id: Optional[str] = None,
                 request_message: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str group_id: The private link resource group id.
        :param str name: Unique name of the private link.
        :param str private_link_resource_id: The resource id that private link links to.
        :param str request_message: Request message.
        :param str status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_link_resource_id is not None:
            pulumi.set(__self__, "private_link_resource_id", private_link_resource_id)
        if request_message is not None:
            pulumi.set(__self__, "request_message", request_message)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        The private link resource group id.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique name of the private link.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateLinkResourceId")
    def private_link_resource_id(self) -> Optional[str]:
        """
        The resource id that private link links to.
        """
        return pulumi.get(self, "private_link_resource_id")

    @property
    @pulumi.getter(name="requestMessage")
    def request_message(self) -> Optional[str]:
        """
        Request message.
        """
        return pulumi.get(self, "request_message")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        return pulumi.get(self, "status")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SkuResponse(dict):
    """
    Sku of the resource
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 tier: Optional[str] = None):
        """
        Sku of the resource
        :param str name: Name of the sku
        :param str tier: Tier of the sku like Basic or Enterprise
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the sku
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        """
        Tier of the sku like Basic or Enterprise
        """
        return pulumi.get(self, "tier")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SparkMavenPackageResponse(dict):
    def __init__(__self__, *,
                 artifact: Optional[str] = None,
                 group: Optional[str] = None,
                 version: Optional[str] = None):
        if artifact is not None:
            pulumi.set(__self__, "artifact", artifact)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def artifact(self) -> Optional[str]:
        return pulumi.get(self, "artifact")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SslConfigurationResponse(dict):
    """
    The ssl configuration for scoring
    """
    def __init__(__self__, *,
                 cert: Optional[str] = None,
                 cname: Optional[str] = None,
                 key: Optional[str] = None,
                 status: Optional[str] = None):
        """
        The ssl configuration for scoring
        :param str cert: Cert data
        :param str cname: CNAME of the cert
        :param str key: Key data
        :param str status: Enable or disable ssl for scoring
        """
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if cname is not None:
            pulumi.set(__self__, "cname", cname)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def cert(self) -> Optional[str]:
        """
        Cert data
        """
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def cname(self) -> Optional[str]:
        """
        CNAME of the cert
        """
        return pulumi.get(self, "cname")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key data
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable or disable ssl for scoring
        """
        return pulumi.get(self, "status")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SystemServiceResponse(dict):
    """
    A system service running on a compute.
    """
    def __init__(__self__, *,
                 public_ip_address: str,
                 system_service_type: str,
                 version: str):
        """
        A system service running on a compute.
        :param str public_ip_address: Public IP address
        :param str system_service_type: The type of this system service.
        :param str version: The version for this type.
        """
        pulumi.set(__self__, "public_ip_address", public_ip_address)
        pulumi.set(__self__, "system_service_type", system_service_type)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> str:
        """
        Public IP address
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter(name="systemServiceType")
    def system_service_type(self) -> str:
        """
        The type of this system service.
        """
        return pulumi.get(self, "system_service_type")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The version for this type.
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UserAccountCredentialsResponse(dict):
    """
    Settings for user account that gets created on each on the nodes of a compute.
    """
    def __init__(__self__, *,
                 admin_user_name: str,
                 admin_user_password: Optional[str] = None,
                 admin_user_ssh_public_key: Optional[str] = None):
        """
        Settings for user account that gets created on each on the nodes of a compute.
        :param str admin_user_name: Name of the administrator user account which can be used to SSH to nodes.
        :param str admin_user_password: Password of the administrator user account.
        :param str admin_user_ssh_public_key: SSH public key of the administrator user account.
        """
        pulumi.set(__self__, "admin_user_name", admin_user_name)
        if admin_user_password is not None:
            pulumi.set(__self__, "admin_user_password", admin_user_password)
        if admin_user_ssh_public_key is not None:
            pulumi.set(__self__, "admin_user_ssh_public_key", admin_user_ssh_public_key)

    @property
    @pulumi.getter(name="adminUserName")
    def admin_user_name(self) -> str:
        """
        Name of the administrator user account which can be used to SSH to nodes.
        """
        return pulumi.get(self, "admin_user_name")

    @property
    @pulumi.getter(name="adminUserPassword")
    def admin_user_password(self) -> Optional[str]:
        """
        Password of the administrator user account.
        """
        return pulumi.get(self, "admin_user_password")

    @property
    @pulumi.getter(name="adminUserSshPublicKey")
    def admin_user_ssh_public_key(self) -> Optional[str]:
        """
        SSH public key of the administrator user account.
        """
        return pulumi.get(self, "admin_user_ssh_public_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User Assigned Identity
    """
    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str,
                 tenant_id: str):
        """
        User Assigned Identity
        :param str client_id: The clientId(aka appId) of the user assigned identity.
        :param str principal_id: The principal ID of the user assigned identity.
        :param str tenant_id: The tenant ID of the user assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The clientId(aka appId) of the user assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of the user assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of the user assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UserInfoResponse(dict):
    """
    User who created.
    """
    def __init__(__self__, *,
                 user_alt_sec_id: Optional[str] = None,
                 user_idp: Optional[str] = None,
                 user_iss: Optional[str] = None,
                 user_name: Optional[str] = None,
                 user_object_id: Optional[str] = None,
                 user_pu_id: Optional[str] = None,
                 user_tenant_id: Optional[str] = None):
        """
        User who created.
        :param str user_alt_sec_id: A user alternate sec id. This represents the user in a different identity provider system Eg.1:live.com:puid
        :param str user_idp: A user identity provider. Eg live.com
        :param str user_iss: The issuer which issued the token for this user.
        :param str user_name:  A user's full name or a service principal's app ID.
        :param str user_object_id: A user or service principal's object ID..
        :param str user_pu_id: A user or service principal's PuID.
        :param str user_tenant_id: A user or service principal's tenant ID.
        """
        if user_alt_sec_id is not None:
            pulumi.set(__self__, "user_alt_sec_id", user_alt_sec_id)
        if user_idp is not None:
            pulumi.set(__self__, "user_idp", user_idp)
        if user_iss is not None:
            pulumi.set(__self__, "user_iss", user_iss)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)
        if user_object_id is not None:
            pulumi.set(__self__, "user_object_id", user_object_id)
        if user_pu_id is not None:
            pulumi.set(__self__, "user_pu_id", user_pu_id)
        if user_tenant_id is not None:
            pulumi.set(__self__, "user_tenant_id", user_tenant_id)

    @property
    @pulumi.getter(name="userAltSecId")
    def user_alt_sec_id(self) -> Optional[str]:
        """
        A user alternate sec id. This represents the user in a different identity provider system Eg.1:live.com:puid
        """
        return pulumi.get(self, "user_alt_sec_id")

    @property
    @pulumi.getter(name="userIdp")
    def user_idp(self) -> Optional[str]:
        """
        A user identity provider. Eg live.com
        """
        return pulumi.get(self, "user_idp")

    @property
    @pulumi.getter(name="userIss")
    def user_iss(self) -> Optional[str]:
        """
        The issuer which issued the token for this user.
        """
        return pulumi.get(self, "user_iss")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        """
         A user's full name or a service principal's app ID.
        """
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter(name="userObjectId")
    def user_object_id(self) -> Optional[str]:
        """
        A user or service principal's object ID..
        """
        return pulumi.get(self, "user_object_id")

    @property
    @pulumi.getter(name="userPuId")
    def user_pu_id(self) -> Optional[str]:
        """
        A user or service principal's PuID.
        """
        return pulumi.get(self, "user_pu_id")

    @property
    @pulumi.getter(name="userTenantId")
    def user_tenant_id(self) -> Optional[str]:
        """
        A user or service principal's tenant ID.
        """
        return pulumi.get(self, "user_tenant_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class VirtualMachineResponse(dict):
    """
    A Machine Learning compute based on Azure Virtual Machines.
    """
    def __init__(__self__, *,
                 compute_type: str,
                 created_on: str,
                 is_attached_compute: bool,
                 modified_on: str,
                 provisioning_errors: Sequence['outputs.MachineLearningServiceErrorResponse'],
                 provisioning_state: str,
                 compute_location: Optional[str] = None,
                 description: Optional[str] = None,
                 properties: Optional['outputs.VirtualMachineResponseProperties'] = None,
                 resource_id: Optional[str] = None):
        """
        A Machine Learning compute based on Azure Virtual Machines.
        :param str compute_type: The type of compute
        :param str created_on: The date and time when the compute was created.
        :param bool is_attached_compute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        :param str modified_on: The date and time when the compute was last modified.
        :param Sequence['MachineLearningServiceErrorResponseArgs'] provisioning_errors: Errors during provisioning
        :param str provisioning_state: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        :param str compute_location: Location for the underlying compute
        :param str description: The description of the Machine Learning compute.
        :param str resource_id: ARM resource id of the underlying compute
        """
        pulumi.set(__self__, "compute_type", 'VirtualMachine')
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "is_attached_compute", is_attached_compute)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "provisioning_errors", provisioning_errors)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if compute_location is not None:
            pulumi.set(__self__, "compute_location", compute_location)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> str:
        """
        The type of compute
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        The date and time when the compute was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="isAttachedCompute")
    def is_attached_compute(self) -> bool:
        """
        Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        """
        return pulumi.get(self, "is_attached_compute")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> str:
        """
        The date and time when the compute was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="provisioningErrors")
    def provisioning_errors(self) -> Sequence['outputs.MachineLearningServiceErrorResponse']:
        """
        Errors during provisioning
        """
        return pulumi.get(self, "provisioning_errors")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[str]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.VirtualMachineResponseProperties']:
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class VirtualMachineResponseProperties(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 administrator_account: Optional['outputs.VirtualMachineSshCredentialsResponse'] = None,
                 ssh_port: Optional[int] = None,
                 virtual_machine_size: Optional[str] = None):
        """
        :param str address: Public IP address of the virtual machine.
        :param 'VirtualMachineSshCredentialsResponseArgs' administrator_account: Admin credentials for virtual machine
        :param int ssh_port: Port open for ssh connections.
        :param str virtual_machine_size: Virtual Machine size
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if administrator_account is not None:
            pulumi.set(__self__, "administrator_account", administrator_account)
        if ssh_port is not None:
            pulumi.set(__self__, "ssh_port", ssh_port)
        if virtual_machine_size is not None:
            pulumi.set(__self__, "virtual_machine_size", virtual_machine_size)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Public IP address of the virtual machine.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="administratorAccount")
    def administrator_account(self) -> Optional['outputs.VirtualMachineSshCredentialsResponse']:
        """
        Admin credentials for virtual machine
        """
        return pulumi.get(self, "administrator_account")

    @property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[int]:
        """
        Port open for ssh connections.
        """
        return pulumi.get(self, "ssh_port")

    @property
    @pulumi.getter(name="virtualMachineSize")
    def virtual_machine_size(self) -> Optional[str]:
        """
        Virtual Machine size
        """
        return pulumi.get(self, "virtual_machine_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class VirtualMachineSshCredentialsResponse(dict):
    """
    Admin credentials for virtual machine
    """
    def __init__(__self__, *,
                 password: Optional[str] = None,
                 private_key_data: Optional[str] = None,
                 public_key_data: Optional[str] = None,
                 username: Optional[str] = None):
        """
        Admin credentials for virtual machine
        :param str password: Password of admin account
        :param str private_key_data: Private key data
        :param str public_key_data: Public key data
        :param str username: Username of admin account
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if private_key_data is not None:
            pulumi.set(__self__, "private_key_data", private_key_data)
        if public_key_data is not None:
            pulumi.set(__self__, "public_key_data", public_key_data)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password of admin account
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="privateKeyData")
    def private_key_data(self) -> Optional[str]:
        """
        Private key data
        """
        return pulumi.get(self, "private_key_data")

    @property
    @pulumi.getter(name="publicKeyData")
    def public_key_data(self) -> Optional[str]:
        """
        Public key data
        """
        return pulumi.get(self, "public_key_data")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username of admin account
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


