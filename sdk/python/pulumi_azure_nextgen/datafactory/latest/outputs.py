# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'ActivityDependencyResponse',
    'ActivityPolicyResponse',
    'AmazonMWSLinkedServiceResponse',
    'AmazonMWSObjectDatasetResponse',
    'AmazonRedshiftLinkedServiceResponse',
    'AmazonRedshiftTableDatasetResponse',
    'AmazonS3DatasetResponse',
    'AmazonS3LinkedServiceResponse',
    'AmazonS3LocationResponse',
    'AvroDatasetResponse',
    'AvroFormatResponse',
    'AzPowerShellSetupResponse',
    'AzureBatchLinkedServiceResponse',
    'AzureBlobDatasetResponse',
    'AzureBlobFSDatasetResponse',
    'AzureBlobFSLinkedServiceResponse',
    'AzureBlobFSLocationResponse',
    'AzureBlobStorageLinkedServiceResponse',
    'AzureBlobStorageLocationResponse',
    'AzureDataExplorerLinkedServiceResponse',
    'AzureDataExplorerTableDatasetResponse',
    'AzureDataLakeAnalyticsLinkedServiceResponse',
    'AzureDataLakeStoreDatasetResponse',
    'AzureDataLakeStoreLinkedServiceResponse',
    'AzureDataLakeStoreLocationResponse',
    'AzureDatabricksDeltaLakeDatasetResponse',
    'AzureDatabricksDeltaLakeLinkedServiceResponse',
    'AzureDatabricksLinkedServiceResponse',
    'AzureFileStorageLinkedServiceResponse',
    'AzureFileStorageLocationResponse',
    'AzureFunctionLinkedServiceResponse',
    'AzureKeyVaultLinkedServiceResponse',
    'AzureKeyVaultSecretReferenceResponse',
    'AzureMLLinkedServiceResponse',
    'AzureMLServiceLinkedServiceResponse',
    'AzureMariaDBLinkedServiceResponse',
    'AzureMariaDBTableDatasetResponse',
    'AzureMySqlLinkedServiceResponse',
    'AzureMySqlTableDatasetResponse',
    'AzurePostgreSqlLinkedServiceResponse',
    'AzurePostgreSqlTableDatasetResponse',
    'AzureSearchIndexDatasetResponse',
    'AzureSearchLinkedServiceResponse',
    'AzureSqlDWLinkedServiceResponse',
    'AzureSqlDWTableDatasetResponse',
    'AzureSqlDatabaseLinkedServiceResponse',
    'AzureSqlMILinkedServiceResponse',
    'AzureSqlMITableDatasetResponse',
    'AzureSqlTableDatasetResponse',
    'AzureStorageLinkedServiceResponse',
    'AzureTableDatasetResponse',
    'AzureTableStorageLinkedServiceResponse',
    'BinaryDatasetResponse',
    'CassandraLinkedServiceResponse',
    'CassandraTableDatasetResponse',
    'ChainingTriggerResponse',
    'CmdkeySetupResponse',
    'CommonDataServiceForAppsEntityDatasetResponse',
    'CommonDataServiceForAppsLinkedServiceResponse',
    'ComponentSetupResponse',
    'ConcurLinkedServiceResponse',
    'ConcurObjectDatasetResponse',
    'ConnectionStatePropertiesResponse',
    'ControlActivityResponse',
    'CosmosDbLinkedServiceResponse',
    'CosmosDbMongoDbApiCollectionDatasetResponse',
    'CosmosDbMongoDbApiLinkedServiceResponse',
    'CosmosDbSqlApiCollectionDatasetResponse',
    'CouchbaseLinkedServiceResponse',
    'CouchbaseTableDatasetResponse',
    'CustomDataSourceLinkedServiceResponse',
    'CustomDatasetResponse',
    'DataFlowResponseFolder',
    'DataFlowSinkResponse',
    'DataFlowSourceResponse',
    'DatasetBZip2CompressionResponse',
    'DatasetDeflateCompressionResponse',
    'DatasetGZipCompressionResponse',
    'DatasetReferenceResponse',
    'DatasetResponseFolder',
    'DatasetTarCompressionResponse',
    'DatasetTarGZipCompressionResponse',
    'DatasetZipDeflateCompressionResponse',
    'Db2LinkedServiceResponse',
    'Db2TableDatasetResponse',
    'DelimitedTextDatasetResponse',
    'DocumentDbCollectionDatasetResponse',
    'DrillLinkedServiceResponse',
    'DrillTableDatasetResponse',
    'DynamicsAXLinkedServiceResponse',
    'DynamicsAXResourceDatasetResponse',
    'DynamicsCrmEntityDatasetResponse',
    'DynamicsCrmLinkedServiceResponse',
    'DynamicsEntityDatasetResponse',
    'DynamicsLinkedServiceResponse',
    'EloquaLinkedServiceResponse',
    'EloquaObjectDatasetResponse',
    'EntityReferenceResponse',
    'EnvironmentVariableSetupResponse',
    'ExcelDatasetResponse',
    'ExecutionActivityResponse',
    'FactoryGitHubConfigurationResponse',
    'FactoryIdentityResponse',
    'FactoryVSTSConfigurationResponse',
    'FileServerLinkedServiceResponse',
    'FileServerLocationResponse',
    'FileShareDatasetResponse',
    'FtpServerLinkedServiceResponse',
    'FtpServerLocationResponse',
    'GlobalParameterSpecificationResponse',
    'GoogleAdWordsLinkedServiceResponse',
    'GoogleAdWordsObjectDatasetResponse',
    'GoogleBigQueryLinkedServiceResponse',
    'GoogleBigQueryObjectDatasetResponse',
    'GoogleCloudStorageLinkedServiceResponse',
    'GoogleCloudStorageLocationResponse',
    'GreenplumLinkedServiceResponse',
    'GreenplumTableDatasetResponse',
    'HBaseLinkedServiceResponse',
    'HBaseObjectDatasetResponse',
    'HDInsightLinkedServiceResponse',
    'HDInsightOnDemandLinkedServiceResponse',
    'HdfsLinkedServiceResponse',
    'HdfsLocationResponse',
    'HiveLinkedServiceResponse',
    'HiveObjectDatasetResponse',
    'HttpDatasetResponse',
    'HttpLinkedServiceResponse',
    'HttpServerLocationResponse',
    'HubspotLinkedServiceResponse',
    'HubspotObjectDatasetResponse',
    'ImpalaLinkedServiceResponse',
    'ImpalaObjectDatasetResponse',
    'InformixLinkedServiceResponse',
    'InformixTableDatasetResponse',
    'IntegrationRuntimeComputePropertiesResponse',
    'IntegrationRuntimeCustomSetupScriptPropertiesResponse',
    'IntegrationRuntimeDataFlowPropertiesResponse',
    'IntegrationRuntimeDataProxyPropertiesResponse',
    'IntegrationRuntimeReferenceResponse',
    'IntegrationRuntimeSsisCatalogInfoResponse',
    'IntegrationRuntimeSsisPropertiesResponse',
    'IntegrationRuntimeVNetPropertiesResponse',
    'JiraLinkedServiceResponse',
    'JiraObjectDatasetResponse',
    'JsonDatasetResponse',
    'JsonFormatResponse',
    'LinkedIntegrationRuntimeKeyAuthorizationResponse',
    'LinkedIntegrationRuntimeRbacAuthorizationResponse',
    'LinkedIntegrationRuntimeResponseResult',
    'LinkedServiceReferenceResponse',
    'MagentoLinkedServiceResponse',
    'MagentoObjectDatasetResponse',
    'ManagedIntegrationRuntimeErrorResponseResult',
    'ManagedIntegrationRuntimeNodeResponseResult',
    'ManagedIntegrationRuntimeOperationResultResponseResult',
    'ManagedIntegrationRuntimeResponse',
    'ManagedIntegrationRuntimeStatusResponseResult',
    'ManagedPrivateEndpointResponse',
    'MappingDataFlowResponse',
    'MariaDBLinkedServiceResponse',
    'MariaDBTableDatasetResponse',
    'MarketoLinkedServiceResponse',
    'MarketoObjectDatasetResponse',
    'MicrosoftAccessLinkedServiceResponse',
    'MicrosoftAccessTableDatasetResponse',
    'MongoDbAtlasCollectionDatasetResponse',
    'MongoDbAtlasLinkedServiceResponse',
    'MongoDbCollectionDatasetResponse',
    'MongoDbLinkedServiceResponse',
    'MongoDbV2CollectionDatasetResponse',
    'MongoDbV2LinkedServiceResponse',
    'MultiplePipelineTriggerResponse',
    'MySqlLinkedServiceResponse',
    'MySqlTableDatasetResponse',
    'NetezzaLinkedServiceResponse',
    'NetezzaTableDatasetResponse',
    'ODataLinkedServiceResponse',
    'ODataResourceDatasetResponse',
    'OdbcLinkedServiceResponse',
    'OdbcTableDatasetResponse',
    'Office365DatasetResponse',
    'Office365LinkedServiceResponse',
    'OracleLinkedServiceResponse',
    'OracleServiceCloudLinkedServiceResponse',
    'OracleServiceCloudObjectDatasetResponse',
    'OracleTableDatasetResponse',
    'OrcDatasetResponse',
    'OrcFormatResponse',
    'PackageStoreResponse',
    'ParameterSpecificationResponse',
    'ParquetDatasetResponse',
    'ParquetFormatResponse',
    'PaypalLinkedServiceResponse',
    'PaypalObjectDatasetResponse',
    'PhoenixLinkedServiceResponse',
    'PhoenixObjectDatasetResponse',
    'PipelineReferenceResponse',
    'PipelineResponseFolder',
    'PostgreSqlLinkedServiceResponse',
    'PostgreSqlTableDatasetResponse',
    'PrestoLinkedServiceResponse',
    'PrestoObjectDatasetResponse',
    'QuickBooksLinkedServiceResponse',
    'QuickBooksObjectDatasetResponse',
    'RelationalTableDatasetResponse',
    'RerunTumblingWindowTriggerResponse',
    'ResponsysLinkedServiceResponse',
    'ResponsysObjectDatasetResponse',
    'RestResourceDatasetResponse',
    'RestServiceLinkedServiceResponse',
    'RetryPolicyResponse',
    'SalesforceLinkedServiceResponse',
    'SalesforceMarketingCloudLinkedServiceResponse',
    'SalesforceMarketingCloudObjectDatasetResponse',
    'SalesforceObjectDatasetResponse',
    'SalesforceServiceCloudLinkedServiceResponse',
    'SalesforceServiceCloudObjectDatasetResponse',
    'SapBWLinkedServiceResponse',
    'SapBwCubeDatasetResponse',
    'SapCloudForCustomerLinkedServiceResponse',
    'SapCloudForCustomerResourceDatasetResponse',
    'SapEccLinkedServiceResponse',
    'SapEccResourceDatasetResponse',
    'SapHanaLinkedServiceResponse',
    'SapHanaTableDatasetResponse',
    'SapOpenHubLinkedServiceResponse',
    'SapOpenHubTableDatasetResponse',
    'SapTableLinkedServiceResponse',
    'SapTableResourceDatasetResponse',
    'ScriptActionResponse',
    'SecureStringResponse',
    'SelfDependencyTumblingWindowTriggerReferenceResponse',
    'SelfHostedIntegrationRuntimeNodeResponseResult',
    'SelfHostedIntegrationRuntimeResponse',
    'SelfHostedIntegrationRuntimeStatusResponseResult',
    'ServiceNowLinkedServiceResponse',
    'ServiceNowObjectDatasetResponse',
    'SftpLocationResponse',
    'SftpServerLinkedServiceResponse',
    'SharePointOnlineListLinkedServiceResponse',
    'SharePointOnlineListResourceDatasetResponse',
    'ShopifyLinkedServiceResponse',
    'ShopifyObjectDatasetResponse',
    'SnowflakeDatasetResponse',
    'SnowflakeLinkedServiceResponse',
    'SparkLinkedServiceResponse',
    'SparkObjectDatasetResponse',
    'SqlServerLinkedServiceResponse',
    'SqlServerTableDatasetResponse',
    'SquareLinkedServiceResponse',
    'SquareObjectDatasetResponse',
    'SsisEnvironmentReferenceResponseResult',
    'SsisEnvironmentResponseResult',
    'SsisFolderResponseResult',
    'SsisPackageResponseResult',
    'SsisParameterResponseResult',
    'SsisProjectResponseResult',
    'SsisVariableResponseResult',
    'SybaseLinkedServiceResponse',
    'SybaseTableDatasetResponse',
    'TeradataLinkedServiceResponse',
    'TeradataTableDatasetResponse',
    'TextFormatResponse',
    'TransformationResponse',
    'TriggerDependencyReferenceResponse',
    'TriggerPipelineReferenceResponse',
    'TriggerReferenceResponse',
    'TumblingWindowTriggerResponse',
    'UserAccessPolicyResponseResult',
    'UserPropertyResponse',
    'VariableSpecificationResponse',
    'VerticaLinkedServiceResponse',
    'VerticaTableDatasetResponse',
    'WebAnonymousAuthenticationResponse',
    'WebBasicAuthenticationResponse',
    'WebClientCertificateAuthenticationResponse',
    'WebLinkedServiceResponse',
    'WebTableDatasetResponse',
    'XeroLinkedServiceResponse',
    'XeroObjectDatasetResponse',
    'XmlDatasetResponse',
    'ZohoLinkedServiceResponse',
    'ZohoObjectDatasetResponse',
]

@pulumi.output_type
class ActivityDependencyResponse(dict):
    """
    Activity dependency information.
    """
    def __init__(__self__, *,
                 activity: str,
                 dependency_conditions: Sequence[str]):
        """
        Activity dependency information.
        :param str activity: Activity name.
        :param Sequence[str] dependency_conditions: Match-Condition for the dependency.
        """
        pulumi.set(__self__, "activity", activity)
        pulumi.set(__self__, "dependency_conditions", dependency_conditions)

    @property
    @pulumi.getter
    def activity(self) -> str:
        """
        Activity name.
        """
        return pulumi.get(self, "activity")

    @property
    @pulumi.getter(name="dependencyConditions")
    def dependency_conditions(self) -> Sequence[str]:
        """
        Match-Condition for the dependency.
        """
        return pulumi.get(self, "dependency_conditions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ActivityPolicyResponse(dict):
    """
    Execution policy for an activity.
    """
    def __init__(__self__, *,
                 retry: Optional[Any] = None,
                 retry_interval_in_seconds: Optional[int] = None,
                 secure_input: Optional[bool] = None,
                 secure_output: Optional[bool] = None,
                 timeout: Optional[Any] = None):
        """
        Execution policy for an activity.
        :param Any retry: Maximum ordinary retry attempts. Default is 0. Type: integer (or Expression with resultType integer), minimum: 0.
        :param int retry_interval_in_seconds: Interval between each retry attempt (in seconds). The default is 30 sec.
        :param bool secure_input: When set to true, Input from activity is considered as secure and will not be logged to monitoring.
        :param bool secure_output: When set to true, Output from activity is considered as secure and will not be logged to monitoring.
        :param Any timeout: Specifies the timeout for the activity to run. The default timeout is 7 days. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        if retry is not None:
            pulumi.set(__self__, "retry", retry)
        if retry_interval_in_seconds is not None:
            pulumi.set(__self__, "retry_interval_in_seconds", retry_interval_in_seconds)
        if secure_input is not None:
            pulumi.set(__self__, "secure_input", secure_input)
        if secure_output is not None:
            pulumi.set(__self__, "secure_output", secure_output)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def retry(self) -> Optional[Any]:
        """
        Maximum ordinary retry attempts. Default is 0. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "retry")

    @property
    @pulumi.getter(name="retryIntervalInSeconds")
    def retry_interval_in_seconds(self) -> Optional[int]:
        """
        Interval between each retry attempt (in seconds). The default is 30 sec.
        """
        return pulumi.get(self, "retry_interval_in_seconds")

    @property
    @pulumi.getter(name="secureInput")
    def secure_input(self) -> Optional[bool]:
        """
        When set to true, Input from activity is considered as secure and will not be logged to monitoring.
        """
        return pulumi.get(self, "secure_input")

    @property
    @pulumi.getter(name="secureOutput")
    def secure_output(self) -> Optional[bool]:
        """
        When set to true, Output from activity is considered as secure and will not be logged to monitoring.
        """
        return pulumi.get(self, "secure_output")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[Any]:
        """
        Specifies the timeout for the activity to run. The default timeout is 7 days. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "timeout")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AmazonMWSLinkedServiceResponse(dict):
    """
    Amazon Marketplace Web Service linked service.
    """
    def __init__(__self__, *,
                 access_key_id: Any,
                 endpoint: Any,
                 marketplace_id: Any,
                 seller_id: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 mws_auth_token: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 secret_key: Optional[Any] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Amazon Marketplace Web Service linked service.
        :param Any access_key_id: The access key id used to access data.
        :param Any endpoint: The endpoint of the Amazon MWS server, (i.e. mws.amazonservices.com)
        :param Any marketplace_id: The Amazon Marketplace ID you want to retrieve data from. To retrieve data from multiple Marketplace IDs, separate them with a comma (,). (i.e. A2EUQ1WTGCTBG2)
        :param Any seller_id: The Amazon seller ID.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] mws_auth_token: The Amazon MWS authentication token.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] secret_key: The secret key used to access data.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "marketplace_id", marketplace_id)
        pulumi.set(__self__, "seller_id", seller_id)
        pulumi.set(__self__, "type", 'AmazonMWS')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if mws_auth_token is not None:
            pulumi.set(__self__, "mws_auth_token", mws_auth_token)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Any:
        """
        The access key id used to access data.
        """
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter
    def endpoint(self) -> Any:
        """
        The endpoint of the Amazon MWS server, (i.e. mws.amazonservices.com)
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="marketplaceID")
    def marketplace_id(self) -> Any:
        """
        The Amazon Marketplace ID you want to retrieve data from. To retrieve data from multiple Marketplace IDs, separate them with a comma (,). (i.e. A2EUQ1WTGCTBG2)
        """
        return pulumi.get(self, "marketplace_id")

    @property
    @pulumi.getter(name="sellerID")
    def seller_id(self) -> Any:
        """
        The Amazon seller ID.
        """
        return pulumi.get(self, "seller_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter(name="mwsAuthToken")
    def mws_auth_token(self) -> Optional[Any]:
        """
        The Amazon MWS authentication token.
        """
        return pulumi.get(self, "mws_auth_token")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[Any]:
        """
        The secret key used to access data.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AmazonMWSObjectDatasetResponse(dict):
    """
    Amazon Marketplace Web Service dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Amazon Marketplace Web Service dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AmazonMWSObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AmazonRedshiftLinkedServiceResponse(dict):
    """
    Linked service for Amazon Redshift.
    """
    def __init__(__self__, *,
                 database: Any,
                 server: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 port: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Linked service for Amazon Redshift.
        :param Any database: The database name of the Amazon Redshift source. Type: string (or Expression with resultType string).
        :param Any server: The name of the Amazon Redshift server. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: The password of the Amazon Redshift source.
        :param Any port: The TCP port number that the Amazon Redshift server uses to listen for client connections. The default value is 5439. Type: integer (or Expression with resultType integer).
        :param Any username: The username of the Amazon Redshift source. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "server", server)
        pulumi.set(__self__, "type", 'AmazonRedshift')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> Any:
        """
        The database name of the Amazon Redshift source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def server(self) -> Any:
        """
        The name of the Amazon Redshift server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        The password of the Amazon Redshift source.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The TCP port number that the Amazon Redshift server uses to listen for client connections. The default value is 5439. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The username of the Amazon Redshift source. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AmazonRedshiftTableDatasetResponse(dict):
    """
    The Amazon Redshift table dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The Amazon Redshift table dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The Amazon Redshift table name. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AmazonRedshiftTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The Amazon Redshift table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AmazonS3DatasetResponse(dict):
    """
    A single Amazon Simple Storage Service (S3) object or a set of S3 objects.
    """
    def __init__(__self__, *,
                 bucket_name: Any,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 compression: Optional[Any] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 format: Optional[Any] = None,
                 key: Optional[Any] = None,
                 modified_datetime_end: Optional[Any] = None,
                 modified_datetime_start: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 prefix: Optional[Any] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 version: Optional[Any] = None):
        """
        A single Amazon Simple Storage Service (S3) object or a set of S3 objects.
        :param Any bucket_name: The name of the Amazon S3 bucket. Type: string (or Expression with resultType string).
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param Union['DatasetBZip2CompressionResponseArgs', 'DatasetDeflateCompressionResponseArgs', 'DatasetGZipCompressionResponseArgs', 'DatasetTarCompressionResponseArgs', 'DatasetTarGZipCompressionResponseArgs', 'DatasetZipDeflateCompressionResponseArgs'] compression: The data compression method used for the Amazon S3 object.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Union['AvroFormatResponseArgs', 'JsonFormatResponseArgs', 'OrcFormatResponseArgs', 'ParquetFormatResponseArgs', 'TextFormatResponseArgs'] format: The format of files.
        :param Any key: The key of the Amazon S3 object. Type: string (or Expression with resultType string).
        :param Any modified_datetime_end: The end of S3 object's modified datetime. Type: string (or Expression with resultType string).
        :param Any modified_datetime_start: The start of S3 object's modified datetime. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any prefix: The prefix filter for the S3 object name. Type: string (or Expression with resultType string).
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any version: The version for the S3 object. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AmazonS3Object')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if modified_datetime_end is not None:
            pulumi.set(__self__, "modified_datetime_end", modified_datetime_end)
        if modified_datetime_start is not None:
            pulumi.set(__self__, "modified_datetime_start", modified_datetime_start)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Any:
        """
        The name of the Amazon S3 bucket. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def compression(self) -> Optional[Any]:
        """
        The data compression method used for the Amazon S3 object.
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def format(self) -> Optional[Any]:
        """
        The format of files.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def key(self) -> Optional[Any]:
        """
        The key of the Amazon S3 object. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="modifiedDatetimeEnd")
    def modified_datetime_end(self) -> Optional[Any]:
        """
        The end of S3 object's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_end")

    @property
    @pulumi.getter(name="modifiedDatetimeStart")
    def modified_datetime_start(self) -> Optional[Any]:
        """
        The start of S3 object's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_start")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[Any]:
        """
        The prefix filter for the S3 object name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def version(self) -> Optional[Any]:
        """
        The version for the S3 object. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AmazonS3LinkedServiceResponse(dict):
    """
    Linked service for Amazon S3.
    """
    def __init__(__self__, *,
                 type: str,
                 access_key_id: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 authentication_type: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 secret_access_key: Optional[Any] = None,
                 service_url: Optional[Any] = None,
                 session_token: Optional[Any] = None):
        """
        Linked service for Amazon S3.
        :param str type: Type of linked service.
        :param Any access_key_id: The access key identifier of the Amazon S3 Identity and Access Management (IAM) user. Type: string (or Expression with resultType string).
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any authentication_type: The authentication type of S3. Allowed value: AccessKey (default) or TemporarySecurityCredentials. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] secret_access_key: The secret access key of the Amazon S3 Identity and Access Management (IAM) user.
        :param Any service_url: This value specifies the endpoint to access with the S3 Connector. This is an optional property; change it only if you want to try a different service endpoint or want to switch between https and http. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] session_token: The session token for the S3 temporary security credential.
        """
        pulumi.set(__self__, "type", 'AmazonS3')
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if service_url is not None:
            pulumi.set(__self__, "service_url", service_url)
        if session_token is not None:
            pulumi.set(__self__, "session_token", session_token)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[Any]:
        """
        The access key identifier of the Amazon S3 Identity and Access Management (IAM) user. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[Any]:
        """
        The authentication type of S3. Allowed value: AccessKey (default) or TemporarySecurityCredentials. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[Any]:
        """
        The secret access key of the Amazon S3 Identity and Access Management (IAM) user.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="serviceUrl")
    def service_url(self) -> Optional[Any]:
        """
        This value specifies the endpoint to access with the S3 Connector. This is an optional property; change it only if you want to try a different service endpoint or want to switch between https and http. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_url")

    @property
    @pulumi.getter(name="sessionToken")
    def session_token(self) -> Optional[Any]:
        """
        The session token for the S3 temporary security credential.
        """
        return pulumi.get(self, "session_token")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AmazonS3LocationResponse(dict):
    """
    The location of amazon S3 dataset.
    """
    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[Any] = None,
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None,
                 version: Optional[Any] = None):
        """
        The location of amazon S3 dataset.
        :param str type: Type of dataset storage location.
        :param Any bucket_name: Specify the bucketName of amazon S3. Type: string (or Expression with resultType string)
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        :param Any version: Specify the version of amazon S3. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'AmazonS3Location')
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset storage location.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[Any]:
        """
        Specify the bucketName of amazon S3. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    @property
    @pulumi.getter
    def version(self) -> Optional[Any]:
        """
        Specify the version of amazon S3. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AvroDatasetResponse(dict):
    """
    Avro dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 location: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 avro_compression_codec: Optional[str] = None,
                 avro_compression_level: Optional[int] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Avro dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param Union['AmazonS3LocationResponseArgs', 'AzureBlobFSLocationResponseArgs', 'AzureBlobStorageLocationResponseArgs', 'AzureDataLakeStoreLocationResponseArgs', 'AzureFileStorageLocationResponseArgs', 'FileServerLocationResponseArgs', 'FtpServerLocationResponseArgs', 'GoogleCloudStorageLocationResponseArgs', 'HdfsLocationResponseArgs', 'HttpServerLocationResponseArgs', 'SftpLocationResponseArgs'] location: The location of the avro storage.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "type", 'Avro')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if avro_compression_codec is not None:
            pulumi.set(__self__, "avro_compression_codec", avro_compression_codec)
        if avro_compression_level is not None:
            pulumi.set(__self__, "avro_compression_level", avro_compression_level)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def location(self) -> Any:
        """
        The location of the avro storage.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="avroCompressionCodec")
    def avro_compression_codec(self) -> Optional[str]:
        return pulumi.get(self, "avro_compression_codec")

    @property
    @pulumi.getter(name="avroCompressionLevel")
    def avro_compression_level(self) -> Optional[int]:
        return pulumi.get(self, "avro_compression_level")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AvroFormatResponse(dict):
    """
    The data stored in Avro format.
    """
    def __init__(__self__, *,
                 type: str,
                 deserializer: Optional[Any] = None,
                 serializer: Optional[Any] = None):
        """
        The data stored in Avro format.
        :param str type: Type of dataset storage format.
        :param Any deserializer: Deserializer. Type: string (or Expression with resultType string).
        :param Any serializer: Serializer. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'AvroFormat')
        if deserializer is not None:
            pulumi.set(__self__, "deserializer", deserializer)
        if serializer is not None:
            pulumi.set(__self__, "serializer", serializer)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset storage format.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def deserializer(self) -> Optional[Any]:
        """
        Deserializer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "deserializer")

    @property
    @pulumi.getter
    def serializer(self) -> Optional[Any]:
        """
        Serializer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "serializer")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzPowerShellSetupResponse(dict):
    """
    The express custom setup of installing Azure PowerShell.
    """
    def __init__(__self__, *,
                 type: str,
                 version: str):
        """
        The express custom setup of installing Azure PowerShell.
        :param str type: The type of custom setup.
        :param str version: The required version of Azure PowerShell to install.
        """
        pulumi.set(__self__, "type", 'AzPowerShellSetup')
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of custom setup.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The required version of Azure PowerShell to install.
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureBatchLinkedServiceResponse(dict):
    """
    Azure Batch linked service.
    """
    def __init__(__self__, *,
                 account_name: Any,
                 batch_uri: Any,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 pool_name: Any,
                 type: str,
                 access_key: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None):
        """
        Azure Batch linked service.
        :param Any account_name: The Azure Batch account name. Type: string (or Expression with resultType string).
        :param Any batch_uri: The Azure Batch URI. Type: string (or Expression with resultType string).
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: The Azure Storage linked service reference.
        :param Any pool_name: The Azure Batch pool name. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] access_key: The Azure Batch account access key.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "batch_uri", batch_uri)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "pool_name", pool_name)
        pulumi.set(__self__, "type", 'AzureBatch')
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Any:
        """
        The Azure Batch account name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="batchUri")
    def batch_uri(self) -> Any:
        """
        The Azure Batch URI. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "batch_uri")

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        The Azure Storage linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="poolName")
    def pool_name(self) -> Any:
        """
        The Azure Batch pool name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "pool_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[Any]:
        """
        The Azure Batch account access key.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureBlobDatasetResponse(dict):
    """
    The Azure Blob storage.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 compression: Optional[Any] = None,
                 description: Optional[str] = None,
                 file_name: Optional[Any] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 folder_path: Optional[Any] = None,
                 format: Optional[Any] = None,
                 modified_datetime_end: Optional[Any] = None,
                 modified_datetime_start: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_root_location: Optional[Any] = None):
        """
        The Azure Blob storage.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param Union['DatasetBZip2CompressionResponseArgs', 'DatasetDeflateCompressionResponseArgs', 'DatasetGZipCompressionResponseArgs', 'DatasetTarCompressionResponseArgs', 'DatasetTarGZipCompressionResponseArgs', 'DatasetZipDeflateCompressionResponseArgs'] compression: The data compression method used for the blob storage.
        :param str description: Dataset description.
        :param Any file_name: The name of the Azure Blob. Type: string (or Expression with resultType string).
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any folder_path: The path of the Azure Blob storage. Type: string (or Expression with resultType string).
        :param Union['AvroFormatResponseArgs', 'JsonFormatResponseArgs', 'OrcFormatResponseArgs', 'ParquetFormatResponseArgs', 'TextFormatResponseArgs'] format: The format of the Azure Blob storage.
        :param Any modified_datetime_end: The end of Azure Blob's modified datetime. Type: string (or Expression with resultType string).
        :param Any modified_datetime_start: The start of Azure Blob's modified datetime. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_root_location: The root of blob path. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureBlob')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if modified_datetime_end is not None:
            pulumi.set(__self__, "modified_datetime_end", modified_datetime_end)
        if modified_datetime_start is not None:
            pulumi.set(__self__, "modified_datetime_start", modified_datetime_start)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_root_location is not None:
            pulumi.set(__self__, "table_root_location", table_root_location)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def compression(self) -> Optional[Any]:
        """
        The data compression method used for the blob storage.
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        The name of the Azure Blob. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        The path of the Azure Blob storage. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "folder_path")

    @property
    @pulumi.getter
    def format(self) -> Optional[Any]:
        """
        The format of the Azure Blob storage.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="modifiedDatetimeEnd")
    def modified_datetime_end(self) -> Optional[Any]:
        """
        The end of Azure Blob's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_end")

    @property
    @pulumi.getter(name="modifiedDatetimeStart")
    def modified_datetime_start(self) -> Optional[Any]:
        """
        The start of Azure Blob's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_start")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableRootLocation")
    def table_root_location(self) -> Optional[Any]:
        """
        The root of blob path. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_root_location")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureBlobFSDatasetResponse(dict):
    """
    The Azure Data Lake Storage Gen2 storage.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 compression: Optional[Any] = None,
                 description: Optional[str] = None,
                 file_name: Optional[Any] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 folder_path: Optional[Any] = None,
                 format: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The Azure Data Lake Storage Gen2 storage.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param Union['DatasetBZip2CompressionResponseArgs', 'DatasetDeflateCompressionResponseArgs', 'DatasetGZipCompressionResponseArgs', 'DatasetTarCompressionResponseArgs', 'DatasetTarGZipCompressionResponseArgs', 'DatasetZipDeflateCompressionResponseArgs'] compression: The data compression method used for the blob storage.
        :param str description: Dataset description.
        :param Any file_name: The name of the Azure Data Lake Storage Gen2. Type: string (or Expression with resultType string).
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any folder_path: The path of the Azure Data Lake Storage Gen2 storage. Type: string (or Expression with resultType string).
        :param Union['AvroFormatResponseArgs', 'JsonFormatResponseArgs', 'OrcFormatResponseArgs', 'ParquetFormatResponseArgs', 'TextFormatResponseArgs'] format: The format of the Azure Data Lake Storage Gen2 storage.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureBlobFSFile')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def compression(self) -> Optional[Any]:
        """
        The data compression method used for the blob storage.
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        The name of the Azure Data Lake Storage Gen2. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        The path of the Azure Data Lake Storage Gen2 storage. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "folder_path")

    @property
    @pulumi.getter
    def format(self) -> Optional[Any]:
        """
        The format of the Azure Data Lake Storage Gen2 storage.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureBlobFSLinkedServiceResponse(dict):
    """
    Azure Data Lake Storage Gen2 linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 url: Any,
                 account_key: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 azure_cloud_type: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[Any] = None,
                 tenant: Optional[Any] = None):
        """
        Azure Data Lake Storage Gen2 linked service.
        :param str type: Type of linked service.
        :param Any url: Endpoint for the Azure Data Lake Storage Gen2 service. Type: string (or Expression with resultType string).
        :param Any account_key: Account key for the Azure Data Lake Storage Gen2 service. Type: string (or Expression with resultType string).
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any azure_cloud_type: Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions’ cloud type. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Any service_principal_id: The ID of the application used to authenticate against the Azure Data Lake Storage Gen2 account. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] service_principal_key: The Key of the application used to authenticate against the Azure Data Lake Storage Gen2 account.
        :param Any tenant: The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'AzureBlobFS')
        pulumi.set(__self__, "url", url)
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if azure_cloud_type is not None:
            pulumi.set(__self__, "azure_cloud_type", azure_cloud_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        Endpoint for the Azure Data Lake Storage Gen2 service. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[Any]:
        """
        Account key for the Azure Data Lake Storage Gen2 service. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "account_key")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="azureCloudType")
    def azure_cloud_type(self) -> Optional[Any]:
        """
        Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions’ cloud type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_cloud_type")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The ID of the application used to authenticate against the Azure Data Lake Storage Gen2 account. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[Any]:
        """
        The Key of the application used to authenticate against the Azure Data Lake Storage Gen2 account.
        """
        return pulumi.get(self, "service_principal_key")

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureBlobFSLocationResponse(dict):
    """
    The location of azure blobFS dataset.
    """
    def __init__(__self__, *,
                 type: str,
                 file_name: Optional[Any] = None,
                 file_system: Optional[Any] = None,
                 folder_path: Optional[Any] = None):
        """
        The location of azure blobFS dataset.
        :param str type: Type of dataset storage location.
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any file_system: Specify the fileSystem of azure blobFS. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        pulumi.set(__self__, "type", 'AzureBlobFSLocation')
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset storage location.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[Any]:
        """
        Specify the fileSystem of azure blobFS. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_system")

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureBlobStorageLinkedServiceResponse(dict):
    """
    The azure blob storage linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 account_key: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 azure_cloud_type: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[str] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 sas_token: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None,
                 sas_uri: Optional[Any] = None,
                 service_endpoint: Optional[str] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[Any] = None,
                 tenant: Optional[Any] = None):
        """
        The azure blob storage linked service.
        :param str type: Type of linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' account_key: The Azure key vault secret reference of accountKey in connection string.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any azure_cloud_type: Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions’ cloud type. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_string: The connection string. It is mutually exclusive with sasUri, serviceEndpoint property. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str description: Linked service description.
        :param str encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' sas_token: The Azure key vault secret reference of sasToken in sas uri.
        :param Any sas_uri: SAS URI of the Azure Blob Storage resource. It is mutually exclusive with connectionString, serviceEndpoint property. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str service_endpoint: Blob service endpoint of the Azure Blob Storage resource. It is mutually exclusive with connectionString, sasUri property.
        :param Any service_principal_id: The ID of the service principal used to authenticate against Azure SQL Data Warehouse. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] service_principal_key: The key of the service principal used to authenticate against Azure SQL Data Warehouse.
        :param Any tenant: The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'AzureBlobStorage')
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if azure_cloud_type is not None:
            pulumi.set(__self__, "azure_cloud_type", azure_cloud_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)
        if sas_uri is not None:
            pulumi.set(__self__, "sas_uri", sas_uri)
        if service_endpoint is not None:
            pulumi.set(__self__, "service_endpoint", service_endpoint)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of accountKey in connection string.
        """
        return pulumi.get(self, "account_key")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="azureCloudType")
    def azure_cloud_type(self) -> Optional[Any]:
        """
        Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions’ cloud type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_cloud_type")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        The connection string. It is mutually exclusive with sasUri, serviceEndpoint property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[str]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of sasToken in sas uri.
        """
        return pulumi.get(self, "sas_token")

    @property
    @pulumi.getter(name="sasUri")
    def sas_uri(self) -> Optional[Any]:
        """
        SAS URI of the Azure Blob Storage resource. It is mutually exclusive with connectionString, serviceEndpoint property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "sas_uri")

    @property
    @pulumi.getter(name="serviceEndpoint")
    def service_endpoint(self) -> Optional[str]:
        """
        Blob service endpoint of the Azure Blob Storage resource. It is mutually exclusive with connectionString, sasUri property.
        """
        return pulumi.get(self, "service_endpoint")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The ID of the service principal used to authenticate against Azure SQL Data Warehouse. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[Any]:
        """
        The key of the service principal used to authenticate against Azure SQL Data Warehouse.
        """
        return pulumi.get(self, "service_principal_key")

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureBlobStorageLocationResponse(dict):
    """
    The location of azure blob dataset.
    """
    def __init__(__self__, *,
                 type: str,
                 container: Optional[Any] = None,
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None):
        """
        The location of azure blob dataset.
        :param str type: Type of dataset storage location.
        :param Any container: Specify the container of azure blob. Type: string (or Expression with resultType string).
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        pulumi.set(__self__, "type", 'AzureBlobStorageLocation')
        if container is not None:
            pulumi.set(__self__, "container", container)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset storage location.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def container(self) -> Optional[Any]:
        """
        Specify the container of azure blob. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureDataExplorerLinkedServiceResponse(dict):
    """
    Azure Data Explorer (Kusto) linked service.
    """
    def __init__(__self__, *,
                 database: Any,
                 endpoint: Any,
                 service_principal_id: Any,
                 service_principal_key: Any,
                 tenant: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None):
        """
        Azure Data Explorer (Kusto) linked service.
        :param Any database: Database name for connection. Type: string (or Expression with resultType string).
        :param Any endpoint: The endpoint of Azure Data Explorer (the engine's endpoint). URL will be in the format https://<clusterName>.<regionName>.kusto.windows.net. Type: string (or Expression with resultType string)
        :param Any service_principal_id: The ID of the service principal used to authenticate against Azure Data Explorer. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] service_principal_key: The key of the service principal used to authenticate against Kusto.
        :param Any tenant: The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "service_principal_key", service_principal_key)
        pulumi.set(__self__, "tenant", tenant)
        pulumi.set(__self__, "type", 'AzureDataExplorer')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def database(self) -> Any:
        """
        Database name for connection. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def endpoint(self) -> Any:
        """
        The endpoint of Azure Data Explorer (the engine's endpoint). URL will be in the format https://<clusterName>.<regionName>.kusto.windows.net. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Any:
        """
        The ID of the service principal used to authenticate against Azure Data Explorer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Any:
        """
        The key of the service principal used to authenticate against Kusto.
        """
        return pulumi.get(self, "service_principal_key")

    @property
    @pulumi.getter
    def tenant(self) -> Any:
        """
        The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureDataExplorerTableDatasetResponse(dict):
    """
    The Azure Data Explorer (Kusto) dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None):
        """
        The Azure Data Explorer (Kusto) dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Azure Data Explorer database. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureDataExplorerTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Azure Data Explorer database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureDataLakeAnalyticsLinkedServiceResponse(dict):
    """
    Azure Data Lake Analytics linked service.
    """
    def __init__(__self__, *,
                 account_name: Any,
                 tenant: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 data_lake_analytics_uri: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 resource_group_name: Optional[Any] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[Any] = None,
                 subscription_id: Optional[Any] = None):
        """
        Azure Data Lake Analytics linked service.
        :param Any account_name: The Azure Data Lake Analytics account name. Type: string (or Expression with resultType string).
        :param Any tenant: The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any data_lake_analytics_uri: Azure Data Lake Analytics URI Type: string (or Expression with resultType string).
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Any resource_group_name: Data Lake Analytics account resource group name (if different from Data Factory account). Type: string (or Expression with resultType string).
        :param Any service_principal_id: The ID of the application used to authenticate against the Azure Data Lake Analytics account. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] service_principal_key: The Key of the application used to authenticate against the Azure Data Lake Analytics account.
        :param Any subscription_id: Data Lake Analytics account subscription ID (if different from Data Factory account). Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "tenant", tenant)
        pulumi.set(__self__, "type", 'AzureDataLakeAnalytics')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if data_lake_analytics_uri is not None:
            pulumi.set(__self__, "data_lake_analytics_uri", data_lake_analytics_uri)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Any:
        """
        The Azure Data Lake Analytics account name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def tenant(self) -> Any:
        """
        The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="dataLakeAnalyticsUri")
    def data_lake_analytics_uri(self) -> Optional[Any]:
        """
        Azure Data Lake Analytics URI Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "data_lake_analytics_uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[Any]:
        """
        Data Lake Analytics account resource group name (if different from Data Factory account). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The ID of the application used to authenticate against the Azure Data Lake Analytics account. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[Any]:
        """
        The Key of the application used to authenticate against the Azure Data Lake Analytics account.
        """
        return pulumi.get(self, "service_principal_key")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[Any]:
        """
        Data Lake Analytics account subscription ID (if different from Data Factory account). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "subscription_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureDataLakeStoreDatasetResponse(dict):
    """
    Azure Data Lake Store dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 compression: Optional[Any] = None,
                 description: Optional[str] = None,
                 file_name: Optional[Any] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 folder_path: Optional[Any] = None,
                 format: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Azure Data Lake Store dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param Union['DatasetBZip2CompressionResponseArgs', 'DatasetDeflateCompressionResponseArgs', 'DatasetGZipCompressionResponseArgs', 'DatasetTarCompressionResponseArgs', 'DatasetTarGZipCompressionResponseArgs', 'DatasetZipDeflateCompressionResponseArgs'] compression: The data compression method used for the item(s) in the Azure Data Lake Store.
        :param str description: Dataset description.
        :param Any file_name: The name of the file in the Azure Data Lake Store. Type: string (or Expression with resultType string).
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any folder_path: Path to the folder in the Azure Data Lake Store. Type: string (or Expression with resultType string).
        :param Union['AvroFormatResponseArgs', 'JsonFormatResponseArgs', 'OrcFormatResponseArgs', 'ParquetFormatResponseArgs', 'TextFormatResponseArgs'] format: The format of the Data Lake Store.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureDataLakeStoreFile')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def compression(self) -> Optional[Any]:
        """
        The data compression method used for the item(s) in the Azure Data Lake Store.
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        The name of the file in the Azure Data Lake Store. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Path to the folder in the Azure Data Lake Store. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "folder_path")

    @property
    @pulumi.getter
    def format(self) -> Optional[Any]:
        """
        The format of the Data Lake Store.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureDataLakeStoreLinkedServiceResponse(dict):
    """
    Azure Data Lake Store linked service.
    """
    def __init__(__self__, *,
                 data_lake_store_uri: Any,
                 type: str,
                 account_name: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 azure_cloud_type: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 resource_group_name: Optional[Any] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[Any] = None,
                 subscription_id: Optional[Any] = None,
                 tenant: Optional[Any] = None):
        """
        Azure Data Lake Store linked service.
        :param Any data_lake_store_uri: Data Lake Store service URI. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Any account_name: Data Lake Store account name. Type: string (or Expression with resultType string).
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any azure_cloud_type: Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions’ cloud type. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Any resource_group_name: Data Lake Store account resource group name (if different from Data Factory account). Type: string (or Expression with resultType string).
        :param Any service_principal_id: The ID of the application used to authenticate against the Azure Data Lake Store account. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] service_principal_key: The Key of the application used to authenticate against the Azure Data Lake Store account.
        :param Any subscription_id: Data Lake Store account subscription ID (if different from Data Factory account). Type: string (or Expression with resultType string).
        :param Any tenant: The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "data_lake_store_uri", data_lake_store_uri)
        pulumi.set(__self__, "type", 'AzureDataLakeStore')
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if azure_cloud_type is not None:
            pulumi.set(__self__, "azure_cloud_type", azure_cloud_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)

    @property
    @pulumi.getter(name="dataLakeStoreUri")
    def data_lake_store_uri(self) -> Any:
        """
        Data Lake Store service URI. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "data_lake_store_uri")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[Any]:
        """
        Data Lake Store account name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="azureCloudType")
    def azure_cloud_type(self) -> Optional[Any]:
        """
        Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions’ cloud type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_cloud_type")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[Any]:
        """
        Data Lake Store account resource group name (if different from Data Factory account). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The ID of the application used to authenticate against the Azure Data Lake Store account. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[Any]:
        """
        The Key of the application used to authenticate against the Azure Data Lake Store account.
        """
        return pulumi.get(self, "service_principal_key")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[Any]:
        """
        Data Lake Store account subscription ID (if different from Data Factory account). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureDataLakeStoreLocationResponse(dict):
    """
    The location of azure data lake store dataset.
    """
    def __init__(__self__, *,
                 type: str,
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None):
        """
        The location of azure data lake store dataset.
        :param str type: Type of dataset storage location.
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        pulumi.set(__self__, "type", 'AzureDataLakeStoreLocation')
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset storage location.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureDatabricksDeltaLakeDatasetResponse(dict):
    """
    Azure Databricks Delta Lake dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 database: Optional[Any] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None):
        """
        Azure Databricks Delta Lake dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param Any database: The database name of delta table. Type: string (or Expression with resultType string).
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The name of delta table. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureDatabricksDeltaLakeDataset')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def database(self) -> Optional[Any]:
        """
        The database name of delta table. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The name of delta table. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureDatabricksDeltaLakeLinkedServiceResponse(dict):
    """
    Azure Databricks Delta Lake linked service.
    """
    def __init__(__self__, *,
                 domain: Any,
                 type: str,
                 access_token: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 cluster_id: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None):
        """
        Azure Databricks Delta Lake linked service.
        :param Any domain: <REGION>.azuredatabricks.net, domain name of your Databricks deployment. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] access_token: Access token for databricks REST API. Refer to https://docs.azuredatabricks.net/api/latest/authentication.html. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any cluster_id: The id of an existing interactive cluster that will be used for all runs of this job. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "type", 'AzureDatabricksDeltaLake')
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def domain(self) -> Any:
        """
        <REGION>.azuredatabricks.net, domain name of your Databricks deployment. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[Any]:
        """
        Access token for databricks REST API. Refer to https://docs.azuredatabricks.net/api/latest/authentication.html. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[Any]:
        """
        The id of an existing interactive cluster that will be used for all runs of this job. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureDatabricksLinkedServiceResponse(dict):
    """
    Azure Databricks linked service.
    """
    def __init__(__self__, *,
                 access_token: Any,
                 domain: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 existing_cluster_id: Optional[Any] = None,
                 instance_pool_id: Optional[Any] = None,
                 new_cluster_custom_tags: Optional[Mapping[str, Any]] = None,
                 new_cluster_driver_node_type: Optional[Any] = None,
                 new_cluster_enable_elastic_disk: Optional[Any] = None,
                 new_cluster_init_scripts: Optional[Any] = None,
                 new_cluster_log_destination: Optional[Any] = None,
                 new_cluster_node_type: Optional[Any] = None,
                 new_cluster_num_of_worker: Optional[Any] = None,
                 new_cluster_spark_conf: Optional[Mapping[str, Any]] = None,
                 new_cluster_spark_env_vars: Optional[Mapping[str, Any]] = None,
                 new_cluster_version: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None):
        """
        Azure Databricks linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] access_token: Access token for databricks REST API. Refer to https://docs.azuredatabricks.net/api/latest/authentication.html. Type: string (or Expression with resultType string).
        :param Any domain: <REGION>.azuredatabricks.net, domain name of your Databricks deployment. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any existing_cluster_id: The id of an existing interactive cluster that will be used for all runs of this activity. Type: string (or Expression with resultType string).
        :param Any instance_pool_id: The id of an existing instance pool that will be used for all runs of this activity. Type: string (or Expression with resultType string).
        :param Mapping[str, Any] new_cluster_custom_tags: Additional tags for cluster resources. This property is ignored in instance pool configurations.
        :param Any new_cluster_driver_node_type: The driver node type for the new job cluster. This property is ignored in instance pool configurations. Type: string (or Expression with resultType string).
        :param Any new_cluster_enable_elastic_disk: Enable the elastic disk on the new cluster. This property is now ignored, and takes the default elastic disk behavior in Databricks (elastic disks are always enabled). Type: boolean (or Expression with resultType boolean).
        :param Any new_cluster_init_scripts: User-defined initialization scripts for the new cluster. Type: array of strings (or Expression with resultType array of strings).
        :param Any new_cluster_log_destination: Specify a location to deliver Spark driver, worker, and event logs. Type: string (or Expression with resultType string).
        :param Any new_cluster_node_type: The node type of the new job cluster. This property is required if newClusterVersion is specified and instancePoolId is not specified. If instancePoolId is specified, this property is ignored. Type: string (or Expression with resultType string).
        :param Any new_cluster_num_of_worker: If not using an existing interactive cluster, this specifies the number of worker nodes to use for the new job cluster or instance pool. For new job clusters, this a string-formatted Int32, like '1' means numOfWorker is 1 or '1:10' means auto-scale from 1 (min) to 10 (max). For instance pools, this is a string-formatted Int32, and can only specify a fixed number of worker nodes, such as '2'. Required if newClusterVersion is specified. Type: string (or Expression with resultType string).
        :param Mapping[str, Any] new_cluster_spark_conf: A set of optional, user-specified Spark configuration key-value pairs.
        :param Mapping[str, Any] new_cluster_spark_env_vars: A set of optional, user-specified Spark environment variables key-value pairs.
        :param Any new_cluster_version: If not using an existing interactive cluster, this specifies the Spark version of a new job cluster or instance pool nodes created for each run of this activity. Required if instancePoolId is specified. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "type", 'AzureDatabricks')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if existing_cluster_id is not None:
            pulumi.set(__self__, "existing_cluster_id", existing_cluster_id)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if new_cluster_custom_tags is not None:
            pulumi.set(__self__, "new_cluster_custom_tags", new_cluster_custom_tags)
        if new_cluster_driver_node_type is not None:
            pulumi.set(__self__, "new_cluster_driver_node_type", new_cluster_driver_node_type)
        if new_cluster_enable_elastic_disk is not None:
            pulumi.set(__self__, "new_cluster_enable_elastic_disk", new_cluster_enable_elastic_disk)
        if new_cluster_init_scripts is not None:
            pulumi.set(__self__, "new_cluster_init_scripts", new_cluster_init_scripts)
        if new_cluster_log_destination is not None:
            pulumi.set(__self__, "new_cluster_log_destination", new_cluster_log_destination)
        if new_cluster_node_type is not None:
            pulumi.set(__self__, "new_cluster_node_type", new_cluster_node_type)
        if new_cluster_num_of_worker is not None:
            pulumi.set(__self__, "new_cluster_num_of_worker", new_cluster_num_of_worker)
        if new_cluster_spark_conf is not None:
            pulumi.set(__self__, "new_cluster_spark_conf", new_cluster_spark_conf)
        if new_cluster_spark_env_vars is not None:
            pulumi.set(__self__, "new_cluster_spark_env_vars", new_cluster_spark_env_vars)
        if new_cluster_version is not None:
            pulumi.set(__self__, "new_cluster_version", new_cluster_version)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Any:
        """
        Access token for databricks REST API. Refer to https://docs.azuredatabricks.net/api/latest/authentication.html. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter
    def domain(self) -> Any:
        """
        <REGION>.azuredatabricks.net, domain name of your Databricks deployment. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter(name="existingClusterId")
    def existing_cluster_id(self) -> Optional[Any]:
        """
        The id of an existing interactive cluster that will be used for all runs of this activity. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "existing_cluster_id")

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[Any]:
        """
        The id of an existing instance pool that will be used for all runs of this activity. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "instance_pool_id")

    @property
    @pulumi.getter(name="newClusterCustomTags")
    def new_cluster_custom_tags(self) -> Optional[Mapping[str, Any]]:
        """
        Additional tags for cluster resources. This property is ignored in instance pool configurations.
        """
        return pulumi.get(self, "new_cluster_custom_tags")

    @property
    @pulumi.getter(name="newClusterDriverNodeType")
    def new_cluster_driver_node_type(self) -> Optional[Any]:
        """
        The driver node type for the new job cluster. This property is ignored in instance pool configurations. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "new_cluster_driver_node_type")

    @property
    @pulumi.getter(name="newClusterEnableElasticDisk")
    def new_cluster_enable_elastic_disk(self) -> Optional[Any]:
        """
        Enable the elastic disk on the new cluster. This property is now ignored, and takes the default elastic disk behavior in Databricks (elastic disks are always enabled). Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "new_cluster_enable_elastic_disk")

    @property
    @pulumi.getter(name="newClusterInitScripts")
    def new_cluster_init_scripts(self) -> Optional[Any]:
        """
        User-defined initialization scripts for the new cluster. Type: array of strings (or Expression with resultType array of strings).
        """
        return pulumi.get(self, "new_cluster_init_scripts")

    @property
    @pulumi.getter(name="newClusterLogDestination")
    def new_cluster_log_destination(self) -> Optional[Any]:
        """
        Specify a location to deliver Spark driver, worker, and event logs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "new_cluster_log_destination")

    @property
    @pulumi.getter(name="newClusterNodeType")
    def new_cluster_node_type(self) -> Optional[Any]:
        """
        The node type of the new job cluster. This property is required if newClusterVersion is specified and instancePoolId is not specified. If instancePoolId is specified, this property is ignored. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "new_cluster_node_type")

    @property
    @pulumi.getter(name="newClusterNumOfWorker")
    def new_cluster_num_of_worker(self) -> Optional[Any]:
        """
        If not using an existing interactive cluster, this specifies the number of worker nodes to use for the new job cluster or instance pool. For new job clusters, this a string-formatted Int32, like '1' means numOfWorker is 1 or '1:10' means auto-scale from 1 (min) to 10 (max). For instance pools, this is a string-formatted Int32, and can only specify a fixed number of worker nodes, such as '2'. Required if newClusterVersion is specified. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "new_cluster_num_of_worker")

    @property
    @pulumi.getter(name="newClusterSparkConf")
    def new_cluster_spark_conf(self) -> Optional[Mapping[str, Any]]:
        """
        A set of optional, user-specified Spark configuration key-value pairs.
        """
        return pulumi.get(self, "new_cluster_spark_conf")

    @property
    @pulumi.getter(name="newClusterSparkEnvVars")
    def new_cluster_spark_env_vars(self) -> Optional[Mapping[str, Any]]:
        """
        A set of optional, user-specified Spark environment variables key-value pairs.
        """
        return pulumi.get(self, "new_cluster_spark_env_vars")

    @property
    @pulumi.getter(name="newClusterVersion")
    def new_cluster_version(self) -> Optional[Any]:
        """
        If not using an existing interactive cluster, this specifies the Spark version of a new job cluster or instance pool nodes created for each run of this activity. Required if instancePoolId is specified. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "new_cluster_version")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureFileStorageLinkedServiceResponse(dict):
    """
    Azure File Storage linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 account_key: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 file_share: Optional[Any] = None,
                 host: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 sas_token: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None,
                 sas_uri: Optional[Any] = None,
                 snapshot: Optional[Any] = None,
                 user_id: Optional[Any] = None):
        """
        Azure File Storage linked service.
        :param str type: Type of linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' account_key: The Azure key vault secret reference of accountKey in connection string.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_string: The connection string. It is mutually exclusive with sasUri property. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any file_share: The azure file share name. It is required when auth with accountKey/sasToken. Type: string (or Expression with resultType string).
        :param Any host: Host name of the server. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password to logon the server.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' sas_token: The Azure key vault secret reference of sasToken in sas uri.
        :param Any sas_uri: SAS URI of the Azure File resource. It is mutually exclusive with connectionString property. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param Any snapshot: The azure file share snapshot version. Type: string (or Expression with resultType string).
        :param Any user_id: User ID to logon the server. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'AzureFileStorage')
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if file_share is not None:
            pulumi.set(__self__, "file_share", file_share)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)
        if sas_uri is not None:
            pulumi.set(__self__, "sas_uri", sas_uri)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of accountKey in connection string.
        """
        return pulumi.get(self, "account_key")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        The connection string. It is mutually exclusive with sasUri property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter(name="fileShare")
    def file_share(self) -> Optional[Any]:
        """
        The azure file share name. It is required when auth with accountKey/sasToken. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_share")

    @property
    @pulumi.getter
    def host(self) -> Optional[Any]:
        """
        Host name of the server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password to logon the server.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of sasToken in sas uri.
        """
        return pulumi.get(self, "sas_token")

    @property
    @pulumi.getter(name="sasUri")
    def sas_uri(self) -> Optional[Any]:
        """
        SAS URI of the Azure File resource. It is mutually exclusive with connectionString property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "sas_uri")

    @property
    @pulumi.getter
    def snapshot(self) -> Optional[Any]:
        """
        The azure file share snapshot version. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "snapshot")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[Any]:
        """
        User ID to logon the server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureFileStorageLocationResponse(dict):
    """
    The location of file server dataset.
    """
    def __init__(__self__, *,
                 type: str,
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None):
        """
        The location of file server dataset.
        :param str type: Type of dataset storage location.
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        pulumi.set(__self__, "type", 'AzureFileStorageLocation')
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset storage location.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureFunctionLinkedServiceResponse(dict):
    """
    Azure Function linked service.
    """
    def __init__(__self__, *,
                 function_app_url: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 function_key: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None):
        """
        Azure Function linked service.
        :param Any function_app_url: The endpoint of the Azure Function App. URL will be in the format https://<accountName>.azurewebsites.net.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] function_key: Function or Host key for Azure Function App.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "function_app_url", function_app_url)
        pulumi.set(__self__, "type", 'AzureFunction')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if function_key is not None:
            pulumi.set(__self__, "function_key", function_key)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="functionAppUrl")
    def function_app_url(self) -> Any:
        """
        The endpoint of the Azure Function App. URL will be in the format https://<accountName>.azurewebsites.net.
        """
        return pulumi.get(self, "function_app_url")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter(name="functionKey")
    def function_key(self) -> Optional[Any]:
        """
        Function or Host key for Azure Function App.
        """
        return pulumi.get(self, "function_key")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureKeyVaultLinkedServiceResponse(dict):
    """
    Azure Key Vault linked service.
    """
    def __init__(__self__, *,
                 base_url: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None):
        """
        Azure Key Vault linked service.
        :param Any base_url: The base URL of the Azure Key Vault. e.g. https://myakv.vault.azure.net Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "type", 'AzureKeyVault')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Any:
        """
        The base URL of the Azure Key Vault. e.g. https://myakv.vault.azure.net Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "base_url")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureKeyVaultSecretReferenceResponse(dict):
    """
    Azure Key Vault secret reference.
    """
    def __init__(__self__, *,
                 secret_name: Any,
                 store: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 secret_version: Optional[Any] = None):
        """
        Azure Key Vault secret reference.
        :param Any secret_name: The name of the secret in Azure Key Vault. Type: string (or Expression with resultType string).
        :param 'LinkedServiceReferenceResponseArgs' store: The Azure Key Vault linked service reference.
        :param str type: Type of the secret.
        :param Any secret_version: The version of the secret in Azure Key Vault. The default value is the latest version of the secret. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "secret_name", secret_name)
        pulumi.set(__self__, "store", store)
        pulumi.set(__self__, "type", 'AzureKeyVaultSecret')
        if secret_version is not None:
            pulumi.set(__self__, "secret_version", secret_version)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Any:
        """
        The name of the secret in Azure Key Vault. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "secret_name")

    @property
    @pulumi.getter
    def store(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        The Azure Key Vault linked service reference.
        """
        return pulumi.get(self, "store")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the secret.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[Any]:
        """
        The version of the secret in Azure Key Vault. The default value is the latest version of the secret. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "secret_version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureMLLinkedServiceResponse(dict):
    """
    Azure ML Studio Web Service linked service.
    """
    def __init__(__self__, *,
                 api_key: Any,
                 ml_endpoint: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[Any] = None,
                 tenant: Optional[Any] = None,
                 update_resource_endpoint: Optional[Any] = None):
        """
        Azure ML Studio Web Service linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] api_key: The API key for accessing the Azure ML model endpoint.
        :param Any ml_endpoint: The Batch Execution REST URL for an Azure ML Studio Web Service endpoint. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Any service_principal_id: The ID of the service principal used to authenticate against the ARM-based updateResourceEndpoint of an Azure ML Studio web service. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] service_principal_key: The key of the service principal used to authenticate against the ARM-based updateResourceEndpoint of an Azure ML Studio web service.
        :param Any tenant: The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        :param Any update_resource_endpoint: The Update Resource REST URL for an Azure ML Studio Web Service endpoint. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "ml_endpoint", ml_endpoint)
        pulumi.set(__self__, "type", 'AzureML')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)
        if update_resource_endpoint is not None:
            pulumi.set(__self__, "update_resource_endpoint", update_resource_endpoint)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Any:
        """
        The API key for accessing the Azure ML model endpoint.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="mlEndpoint")
    def ml_endpoint(self) -> Any:
        """
        The Batch Execution REST URL for an Azure ML Studio Web Service endpoint. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "ml_endpoint")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The ID of the service principal used to authenticate against the ARM-based updateResourceEndpoint of an Azure ML Studio web service. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[Any]:
        """
        The key of the service principal used to authenticate against the ARM-based updateResourceEndpoint of an Azure ML Studio web service.
        """
        return pulumi.get(self, "service_principal_key")

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    @property
    @pulumi.getter(name="updateResourceEndpoint")
    def update_resource_endpoint(self) -> Optional[Any]:
        """
        The Update Resource REST URL for an Azure ML Studio Web Service endpoint. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "update_resource_endpoint")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureMLServiceLinkedServiceResponse(dict):
    """
    Azure ML Service linked service.
    """
    def __init__(__self__, *,
                 ml_workspace_name: Any,
                 resource_group_name: Any,
                 subscription_id: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[Any] = None,
                 tenant: Optional[Any] = None):
        """
        Azure ML Service linked service.
        :param Any ml_workspace_name: Azure ML Service workspace name. Type: string (or Expression with resultType string).
        :param Any resource_group_name: Azure ML Service workspace resource group name. Type: string (or Expression with resultType string).
        :param Any subscription_id: Azure ML Service workspace subscription ID. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Any service_principal_id: The ID of the service principal used to authenticate against the endpoint of a published Azure ML Service pipeline. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] service_principal_key: The key of the service principal used to authenticate against the endpoint of a published Azure ML Service pipeline.
        :param Any tenant: The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "ml_workspace_name", ml_workspace_name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "type", 'AzureMLService')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)

    @property
    @pulumi.getter(name="mlWorkspaceName")
    def ml_workspace_name(self) -> Any:
        """
        Azure ML Service workspace name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "ml_workspace_name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Any:
        """
        Azure ML Service workspace resource group name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Any:
        """
        Azure ML Service workspace subscription ID. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The ID of the service principal used to authenticate against the endpoint of a published Azure ML Service pipeline. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[Any]:
        """
        The key of the service principal used to authenticate against the endpoint of a published Azure ML Service pipeline.
        """
        return pulumi.get(self, "service_principal_key")

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureMariaDBLinkedServiceResponse(dict):
    """
    Azure Database for MariaDB linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 pwd: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None):
        """
        Azure Database for MariaDB linked service.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_string: An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' pwd: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "type", 'AzureMariaDB')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if pwd is not None:
            pulumi.set(__self__, "pwd", pwd)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def pwd(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "pwd")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureMariaDBTableDatasetResponse(dict):
    """
    Azure Database for MariaDB dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Azure Database for MariaDB dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureMariaDBTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureMySqlLinkedServiceResponse(dict):
    """
    Azure MySQL database linked service.
    """
    def __init__(__self__, *,
                 connection_string: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None):
        """
        Azure MySQL database linked service.
        :param Any connection_string: The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' password: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'AzureMySql')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "password")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureMySqlTableDatasetResponse(dict):
    """
    The Azure MySQL database dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The Azure MySQL database dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The name of Azure MySQL database table. Type: string (or Expression with resultType string).
        :param Any table_name: The Azure MySQL database table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureMySqlTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The name of Azure MySQL database table. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The Azure MySQL database table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzurePostgreSqlLinkedServiceResponse(dict):
    """
    Azure PostgreSQL linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None):
        """
        Azure PostgreSQL linked service.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_string: An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' password: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "type", 'AzurePostgreSql')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "password")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzurePostgreSqlTableDatasetResponse(dict):
    """
    Azure PostgreSQL dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Azure PostgreSQL dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Azure PostgreSQL database. Type: string (or Expression with resultType string).
        :param Any table_name: The table name of the Azure PostgreSQL database which includes both schema and table. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzurePostgreSqlTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Azure PostgreSQL database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name of the Azure PostgreSQL database which includes both schema and table. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureSearchIndexDatasetResponse(dict):
    """
    The Azure Search Index.
    """
    def __init__(__self__, *,
                 index_name: Any,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The Azure Search Index.
        :param Any index_name: The name of the Azure Search Index. Type: string (or Expression with resultType string).
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "index_name", index_name)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureSearchIndex')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Any:
        """
        The name of the Azure Search Index. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "index_name")

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureSearchLinkedServiceResponse(dict):
    """
    Linked service for Windows Azure Search Service.
    """
    def __init__(__self__, *,
                 type: str,
                 url: Any,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 key: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None):
        """
        Linked service for Windows Azure Search Service.
        :param str type: Type of linked service.
        :param Any url: URL for Azure Search service. Type: string (or Expression with resultType string).
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] key: Admin Key for Azure Search service
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "type", 'AzureSearch')
        pulumi.set(__self__, "url", url)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        URL for Azure Search service. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def key(self) -> Optional[Any]:
        """
        Admin Key for Azure Search service
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureSqlDWLinkedServiceResponse(dict):
    """
    Azure SQL Data Warehouse linked service.
    """
    def __init__(__self__, *,
                 connection_string: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 azure_cloud_type: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[Any] = None,
                 tenant: Optional[Any] = None):
        """
        Azure SQL Data Warehouse linked service.
        :param Any connection_string: The connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any azure_cloud_type: Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions’ cloud type. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' password: The Azure key vault secret reference of password in connection string.
        :param Any service_principal_id: The ID of the service principal used to authenticate against Azure SQL Data Warehouse. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] service_principal_key: The key of the service principal used to authenticate against Azure SQL Data Warehouse.
        :param Any tenant: The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'AzureSqlDW')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if azure_cloud_type is not None:
            pulumi.set(__self__, "azure_cloud_type", azure_cloud_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="azureCloudType")
    def azure_cloud_type(self) -> Optional[Any]:
        """
        Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions’ cloud type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_cloud_type")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The ID of the service principal used to authenticate against Azure SQL Data Warehouse. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[Any]:
        """
        The key of the service principal used to authenticate against Azure SQL Data Warehouse.
        """
        return pulumi.get(self, "service_principal_key")

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureSqlDWTableDatasetResponse(dict):
    """
    The Azure SQL Data Warehouse dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The Azure SQL Data Warehouse dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Azure SQL Data Warehouse. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureSqlDWTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Azure SQL Data Warehouse. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureSqlDatabaseLinkedServiceResponse(dict):
    """
    Microsoft Azure SQL Database linked service.
    """
    def __init__(__self__, *,
                 connection_string: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 azure_cloud_type: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[Any] = None,
                 tenant: Optional[Any] = None):
        """
        Microsoft Azure SQL Database linked service.
        :param Any connection_string: The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any azure_cloud_type: Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions’ cloud type. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' password: The Azure key vault secret reference of password in connection string.
        :param Any service_principal_id: The ID of the service principal used to authenticate against Azure SQL Database. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] service_principal_key: The key of the service principal used to authenticate against Azure SQL Database.
        :param Any tenant: The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'AzureSqlDatabase')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if azure_cloud_type is not None:
            pulumi.set(__self__, "azure_cloud_type", azure_cloud_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="azureCloudType")
    def azure_cloud_type(self) -> Optional[Any]:
        """
        Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions’ cloud type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_cloud_type")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The ID of the service principal used to authenticate against Azure SQL Database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[Any]:
        """
        The key of the service principal used to authenticate against Azure SQL Database.
        """
        return pulumi.get(self, "service_principal_key")

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureSqlMILinkedServiceResponse(dict):
    """
    Azure SQL Managed Instance linked service.
    """
    def __init__(__self__, *,
                 connection_string: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 azure_cloud_type: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[Any] = None,
                 tenant: Optional[Any] = None):
        """
        Azure SQL Managed Instance linked service.
        :param Any connection_string: The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any azure_cloud_type: Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions’ cloud type. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' password: The Azure key vault secret reference of password in connection string.
        :param Any service_principal_id: The ID of the service principal used to authenticate against Azure SQL Managed Instance. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] service_principal_key: The key of the service principal used to authenticate against Azure SQL Managed Instance.
        :param Any tenant: The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'AzureSqlMI')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if azure_cloud_type is not None:
            pulumi.set(__self__, "azure_cloud_type", azure_cloud_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="azureCloudType")
    def azure_cloud_type(self) -> Optional[Any]:
        """
        Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions’ cloud type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_cloud_type")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The ID of the service principal used to authenticate against Azure SQL Managed Instance. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[Any]:
        """
        The key of the service principal used to authenticate against Azure SQL Managed Instance.
        """
        return pulumi.get(self, "service_principal_key")

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureSqlMITableDatasetResponse(dict):
    """
    The Azure SQL Managed Instance dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The Azure SQL Managed Instance dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Azure SQL Managed Instance dataset. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureSqlMITable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Azure SQL Managed Instance dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureSqlTableDatasetResponse(dict):
    """
    The Azure SQL Server database dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The Azure SQL Server database dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Azure SQL database. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'AzureSqlTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Azure SQL database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureStorageLinkedServiceResponse(dict):
    """
    The storage account linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 account_key: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[str] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 sas_token: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None,
                 sas_uri: Optional[Any] = None):
        """
        The storage account linked service.
        :param str type: Type of linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' account_key: The Azure key vault secret reference of accountKey in connection string.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_string: The connection string. It is mutually exclusive with sasUri property. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str description: Linked service description.
        :param str encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' sas_token: The Azure key vault secret reference of sasToken in sas uri.
        :param Any sas_uri: SAS URI of the Azure Storage resource. It is mutually exclusive with connectionString property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        pulumi.set(__self__, "type", 'AzureStorage')
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)
        if sas_uri is not None:
            pulumi.set(__self__, "sas_uri", sas_uri)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of accountKey in connection string.
        """
        return pulumi.get(self, "account_key")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        The connection string. It is mutually exclusive with sasUri property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[str]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of sasToken in sas uri.
        """
        return pulumi.get(self, "sas_token")

    @property
    @pulumi.getter(name="sasUri")
    def sas_uri(self) -> Optional[Any]:
        """
        SAS URI of the Azure Storage resource. It is mutually exclusive with connectionString property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "sas_uri")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureTableDatasetResponse(dict):
    """
    The Azure Table storage dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 table_name: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The Azure Table storage dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param Any table_name: The table name of the Azure Table storage. Type: string (or Expression with resultType string).
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "table_name", table_name)
        pulumi.set(__self__, "type", 'AzureTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Any:
        """
        The table name of the Azure Table storage. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AzureTableStorageLinkedServiceResponse(dict):
    """
    The azure table storage linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 account_key: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[str] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 sas_token: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None,
                 sas_uri: Optional[Any] = None):
        """
        The azure table storage linked service.
        :param str type: Type of linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' account_key: The Azure key vault secret reference of accountKey in connection string.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_string: The connection string. It is mutually exclusive with sasUri property. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str description: Linked service description.
        :param str encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' sas_token: The Azure key vault secret reference of sasToken in sas uri.
        :param Any sas_uri: SAS URI of the Azure Storage resource. It is mutually exclusive with connectionString property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        pulumi.set(__self__, "type", 'AzureTableStorage')
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)
        if sas_uri is not None:
            pulumi.set(__self__, "sas_uri", sas_uri)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of accountKey in connection string.
        """
        return pulumi.get(self, "account_key")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        The connection string. It is mutually exclusive with sasUri property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[str]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of sasToken in sas uri.
        """
        return pulumi.get(self, "sas_token")

    @property
    @pulumi.getter(name="sasUri")
    def sas_uri(self) -> Optional[Any]:
        """
        SAS URI of the Azure Storage resource. It is mutually exclusive with connectionString property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "sas_uri")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BinaryDatasetResponse(dict):
    """
    Binary dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 location: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 compression: Optional[Any] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Binary dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param Union['AmazonS3LocationResponseArgs', 'AzureBlobFSLocationResponseArgs', 'AzureBlobStorageLocationResponseArgs', 'AzureDataLakeStoreLocationResponseArgs', 'AzureFileStorageLocationResponseArgs', 'FileServerLocationResponseArgs', 'FtpServerLocationResponseArgs', 'GoogleCloudStorageLocationResponseArgs', 'HdfsLocationResponseArgs', 'HttpServerLocationResponseArgs', 'SftpLocationResponseArgs'] location: The location of the Binary storage.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param Union['DatasetBZip2CompressionResponseArgs', 'DatasetDeflateCompressionResponseArgs', 'DatasetGZipCompressionResponseArgs', 'DatasetTarCompressionResponseArgs', 'DatasetTarGZipCompressionResponseArgs', 'DatasetZipDeflateCompressionResponseArgs'] compression: The data compression method used for the binary dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "type", 'Binary')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def location(self) -> Any:
        """
        The location of the Binary storage.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def compression(self) -> Optional[Any]:
        """
        The data compression method used for the binary dataset.
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CassandraLinkedServiceResponse(dict):
    """
    Linked service for Cassandra data source.
    """
    def __init__(__self__, *,
                 host: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 authentication_type: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 port: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Linked service for Cassandra data source.
        :param Any host: Host name for connection. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any authentication_type: AuthenticationType to be used for connection. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password for authentication.
        :param Any port: The port for the connection. Type: integer (or Expression with resultType integer).
        :param Any username: Username for authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'Cassandra')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        Host name for connection. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[Any]:
        """
        AuthenticationType to be used for connection. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password for authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The port for the connection. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        Username for authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CassandraTableDatasetResponse(dict):
    """
    The Cassandra database dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 keyspace: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The Cassandra database dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any keyspace: The keyspace of the Cassandra database. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name of the Cassandra database. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'CassandraTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if keyspace is not None:
            pulumi.set(__self__, "keyspace", keyspace)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def keyspace(self) -> Optional[Any]:
        """
        The keyspace of the Cassandra database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "keyspace")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name of the Cassandra database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ChainingTriggerResponse(dict):
    """
    Trigger that allows the referenced pipeline to depend on other pipeline runs based on runDimension Name/Value pairs. Upstream pipelines should declare the same runDimension Name and their runs should have the values for those runDimensions. The referenced pipeline run would be triggered if the values for the runDimension match for all upstream pipeline runs.
    """
    def __init__(__self__, *,
                 depends_on: Sequence['outputs.PipelineReferenceResponse'],
                 pipeline: 'outputs.TriggerPipelineReferenceResponse',
                 run_dimension: str,
                 runtime_state: str,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None):
        """
        Trigger that allows the referenced pipeline to depend on other pipeline runs based on runDimension Name/Value pairs. Upstream pipelines should declare the same runDimension Name and their runs should have the values for those runDimensions. The referenced pipeline run would be triggered if the values for the runDimension match for all upstream pipeline runs.
        :param Sequence['PipelineReferenceResponseArgs'] depends_on: Upstream Pipelines.
        :param 'TriggerPipelineReferenceResponseArgs' pipeline: Pipeline for which runs are created when all upstream pipelines complete successfully.
        :param str run_dimension: Run Dimension property that needs to be emitted by upstream pipelines.
        :param str runtime_state: Indicates if trigger is running or not. Updated when Start/Stop APIs are called on the Trigger.
        :param str type: Trigger type.
        :param Sequence[Any] annotations: List of tags that can be used for describing the trigger.
        :param str description: Trigger description.
        """
        pulumi.set(__self__, "depends_on", depends_on)
        pulumi.set(__self__, "pipeline", pipeline)
        pulumi.set(__self__, "run_dimension", run_dimension)
        pulumi.set(__self__, "runtime_state", runtime_state)
        pulumi.set(__self__, "type", 'ChainingTrigger')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Sequence['outputs.PipelineReferenceResponse']:
        """
        Upstream Pipelines.
        """
        return pulumi.get(self, "depends_on")

    @property
    @pulumi.getter
    def pipeline(self) -> 'outputs.TriggerPipelineReferenceResponse':
        """
        Pipeline for which runs are created when all upstream pipelines complete successfully.
        """
        return pulumi.get(self, "pipeline")

    @property
    @pulumi.getter(name="runDimension")
    def run_dimension(self) -> str:
        """
        Run Dimension property that needs to be emitted by upstream pipelines.
        """
        return pulumi.get(self, "run_dimension")

    @property
    @pulumi.getter(name="runtimeState")
    def runtime_state(self) -> str:
        """
        Indicates if trigger is running or not. Updated when Start/Stop APIs are called on the Trigger.
        """
        return pulumi.get(self, "runtime_state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Trigger type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the trigger.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Trigger description.
        """
        return pulumi.get(self, "description")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CmdkeySetupResponse(dict):
    """
    The custom setup of running cmdkey commands.
    """
    def __init__(__self__, *,
                 password: Any,
                 target_name: Any,
                 type: str,
                 user_name: Any):
        """
        The custom setup of running cmdkey commands.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: The password of data source access.
        :param Any target_name: The server name of data source access.
        :param str type: The type of custom setup.
        :param Any user_name: The user name of data source access.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "target_name", target_name)
        pulumi.set(__self__, "type", 'CmdkeySetup')
        pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def password(self) -> Any:
        """
        The password of data source access.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="targetName")
    def target_name(self) -> Any:
        """
        The server name of data source access.
        """
        return pulumi.get(self, "target_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of custom setup.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Any:
        """
        The user name of data source access.
        """
        return pulumi.get(self, "user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CommonDataServiceForAppsEntityDatasetResponse(dict):
    """
    The Common Data Service for Apps entity dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 entity_name: Optional[Any] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The Common Data Service for Apps entity dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param Any entity_name: The logical name of the entity. Type: string (or Expression with resultType string).
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'CommonDataServiceForAppsEntity')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entity_name is not None:
            pulumi.set(__self__, "entity_name", entity_name)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="entityName")
    def entity_name(self) -> Optional[Any]:
        """
        The logical name of the entity. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "entity_name")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CommonDataServiceForAppsLinkedServiceResponse(dict):
    """
    Common Data Service for Apps linked service.
    """
    def __init__(__self__, *,
                 authentication_type: str,
                 deployment_type: str,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 host_name: Optional[Any] = None,
                 organization_name: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 port: Optional[Any] = None,
                 service_principal_credential: Optional[Any] = None,
                 service_principal_credential_type: Optional[str] = None,
                 service_principal_id: Optional[Any] = None,
                 service_uri: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Common Data Service for Apps linked service.
        :param str authentication_type: The authentication type to connect to Common Data Service for Apps server. 'Office365' for online scenario, 'Ifd' for on-premises with Ifd scenario. 'AADServicePrincipal' for Server-To-Server authentication in online scenario. Type: string (or Expression with resultType string).
        :param str deployment_type: The deployment type of the Common Data Service for Apps instance. 'Online' for Common Data Service for Apps Online and 'OnPremisesWithIfd' for Common Data Service for Apps on-premises with Ifd. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any host_name: The host name of the on-premises Common Data Service for Apps server. The property is required for on-prem and not allowed for online. Type: string (or Expression with resultType string).
        :param Any organization_name: The organization name of the Common Data Service for Apps instance. The property is required for on-prem and required for online when there are more than one Common Data Service for Apps instances associated with the user. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password to access the Common Data Service for Apps instance.
        :param Any port: The port of on-premises Common Data Service for Apps server. The property is required for on-prem and not allowed for online. Default is 443. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] service_principal_credential: The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey', servicePrincipalCredential can be SecureString or AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can only be AzureKeyVaultSecretReference.
        :param str service_principal_credential_type: The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret, 'ServicePrincipalCert' for certificate. Type: string (or Expression with resultType string).
        :param Any service_principal_id: The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression with resultType string).
        :param Any service_uri: The URL to the Microsoft Common Data Service for Apps server. The property is required for on-line and not allowed for on-prem. Type: string (or Expression with resultType string).
        :param Any username: User name to access the Common Data Service for Apps instance. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "deployment_type", deployment_type)
        pulumi.set(__self__, "type", 'CommonDataServiceForApps')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if organization_name is not None:
            pulumi.set(__self__, "organization_name", organization_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if service_principal_credential is not None:
            pulumi.set(__self__, "service_principal_credential", service_principal_credential)
        if service_principal_credential_type is not None:
            pulumi.set(__self__, "service_principal_credential_type", service_principal_credential_type)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_uri is not None:
            pulumi.set(__self__, "service_uri", service_uri)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        The authentication type to connect to Common Data Service for Apps server. 'Office365' for online scenario, 'Ifd' for on-premises with Ifd scenario. 'AADServicePrincipal' for Server-To-Server authentication in online scenario. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> str:
        """
        The deployment type of the Common Data Service for Apps instance. 'Online' for Common Data Service for Apps Online and 'OnPremisesWithIfd' for Common Data Service for Apps on-premises with Ifd. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "deployment_type")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[Any]:
        """
        The host name of the on-premises Common Data Service for Apps server. The property is required for on-prem and not allowed for online. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter(name="organizationName")
    def organization_name(self) -> Optional[Any]:
        """
        The organization name of the Common Data Service for Apps instance. The property is required for on-prem and required for online when there are more than one Common Data Service for Apps instances associated with the user. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "organization_name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password to access the Common Data Service for Apps instance.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The port of on-premises Common Data Service for Apps server. The property is required for on-prem and not allowed for online. Default is 443. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="servicePrincipalCredential")
    def service_principal_credential(self) -> Optional[Any]:
        """
        The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey', servicePrincipalCredential can be SecureString or AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can only be AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "service_principal_credential")

    @property
    @pulumi.getter(name="servicePrincipalCredentialType")
    def service_principal_credential_type(self) -> Optional[str]:
        """
        The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret, 'ServicePrincipalCert' for certificate. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_credential_type")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="serviceUri")
    def service_uri(self) -> Optional[Any]:
        """
        The URL to the Microsoft Common Data Service for Apps server. The property is required for on-line and not allowed for on-prem. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_uri")

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        User name to access the Common Data Service for Apps instance. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ComponentSetupResponse(dict):
    """
    The custom setup of installing 3rd party components.
    """
    def __init__(__self__, *,
                 component_name: str,
                 type: str,
                 license_key: Optional[Any] = None):
        """
        The custom setup of installing 3rd party components.
        :param str component_name: The name of the 3rd party component.
        :param str type: The type of custom setup.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] license_key: The license key to activate the component.
        """
        pulumi.set(__self__, "component_name", component_name)
        pulumi.set(__self__, "type", 'ComponentSetup')
        if license_key is not None:
            pulumi.set(__self__, "license_key", license_key)

    @property
    @pulumi.getter(name="componentName")
    def component_name(self) -> str:
        """
        The name of the 3rd party component.
        """
        return pulumi.get(self, "component_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of custom setup.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="licenseKey")
    def license_key(self) -> Optional[Any]:
        """
        The license key to activate the component.
        """
        return pulumi.get(self, "license_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ConcurLinkedServiceResponse(dict):
    """
    Concur Service linked service.
    """
    def __init__(__self__, *,
                 client_id: Any,
                 type: str,
                 username: Any,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_properties: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Concur Service linked service.
        :param Any client_id: Application client_id supplied by Concur App Management.
        :param str type: Type of linked service.
        :param Any username: The user name that you use to access Concur Service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_properties: Properties used to connect to Concur. It is mutually exclusive with any other properties in the linked service. Type: object.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: The password corresponding to the user name that you provided in the username field.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "type", 'Concur')
        pulumi.set(__self__, "username", username)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_properties is not None:
            pulumi.set(__self__, "connection_properties", connection_properties)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Any:
        """
        Application client_id supplied by Concur App Management.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def username(self) -> Any:
        """
        The user name that you use to access Concur Service.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionProperties")
    def connection_properties(self) -> Optional[Any]:
        """
        Properties used to connect to Concur. It is mutually exclusive with any other properties in the linked service. Type: object.
        """
        return pulumi.get(self, "connection_properties")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        The password corresponding to the user name that you provided in the username field.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ConcurObjectDatasetResponse(dict):
    """
    Concur Service dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Concur Service dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'ConcurObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ConnectionStatePropertiesResponse(dict):
    """
    The connection state of a managed private endpoint
    """
    def __init__(__self__, *,
                 actions_required: str,
                 description: str,
                 status: str):
        """
        The connection state of a managed private endpoint
        :param str actions_required: The actions required on the managed private endpoint
        :param str description: The managed private endpoint description
        :param str status: The approval status
        """
        pulumi.set(__self__, "actions_required", actions_required)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> str:
        """
        The actions required on the managed private endpoint
        """
        return pulumi.get(self, "actions_required")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The managed private endpoint description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The approval status
        """
        return pulumi.get(self, "status")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ControlActivityResponse(dict):
    """
    Base class for all control activities like IfCondition, ForEach , Until.
    """
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 depends_on: Optional[Sequence['outputs.ActivityDependencyResponse']] = None,
                 description: Optional[str] = None,
                 user_properties: Optional[Sequence['outputs.UserPropertyResponse']] = None):
        """
        Base class for all control activities like IfCondition, ForEach , Until.
        :param str name: Activity name.
        :param str type: Type of activity.
        :param Sequence['ActivityDependencyResponseArgs'] depends_on: Activity depends on condition.
        :param str description: Activity description.
        :param Sequence['UserPropertyResponseArgs'] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'Container')
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of activity.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[Sequence['outputs.ActivityDependencyResponse']]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[Sequence['outputs.UserPropertyResponse']]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CosmosDbLinkedServiceResponse(dict):
    """
    Microsoft Azure Cosmos Database (CosmosDB) linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 account_endpoint: Optional[Any] = None,
                 account_key: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_string: Optional[Any] = None,
                 database: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None):
        """
        Microsoft Azure Cosmos Database (CosmosDB) linked service.
        :param str type: Type of linked service.
        :param Any account_endpoint: The endpoint of the Azure CosmosDB account. Type: string (or Expression with resultType string)
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] account_key: The account key of the Azure CosmosDB account. Type: SecureString or AzureKeyVaultSecretReference.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_string: The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param Any database: The name of the database. Type: string (or Expression with resultType string)
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "type", 'CosmosDb')
        if account_endpoint is not None:
            pulumi.set(__self__, "account_endpoint", account_endpoint)
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accountEndpoint")
    def account_endpoint(self) -> Optional[Any]:
        """
        The endpoint of the Azure CosmosDB account. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "account_endpoint")

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[Any]:
        """
        The account key of the Azure CosmosDB account. Type: SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "account_key")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def database(self) -> Optional[Any]:
        """
        The name of the database. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CosmosDbMongoDbApiCollectionDatasetResponse(dict):
    """
    The CosmosDB (MongoDB API) database dataset.
    """
    def __init__(__self__, *,
                 collection: Any,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The CosmosDB (MongoDB API) database dataset.
        :param Any collection: The collection name of the CosmosDB (MongoDB API) database. Type: string (or Expression with resultType string).
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'CosmosDbMongoDbApiCollection')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter
    def collection(self) -> Any:
        """
        The collection name of the CosmosDB (MongoDB API) database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "collection")

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CosmosDbMongoDbApiLinkedServiceResponse(dict):
    """
    Linked service for CosmosDB (MongoDB API) data source.
    """
    def __init__(__self__, *,
                 connection_string: Any,
                 database: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None):
        """
        Linked service for CosmosDB (MongoDB API) data source.
        :param Any connection_string: The CosmosDB (MongoDB API) connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param Any database: The name of the CosmosDB (MongoDB API) database that you want to access. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "type", 'CosmosDbMongoDbApi')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The CosmosDB (MongoDB API) connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def database(self) -> Any:
        """
        The name of the CosmosDB (MongoDB API) database that you want to access. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CosmosDbSqlApiCollectionDatasetResponse(dict):
    """
    Microsoft Azure CosmosDB (SQL API) Collection dataset.
    """
    def __init__(__self__, *,
                 collection_name: Any,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Microsoft Azure CosmosDB (SQL API) Collection dataset.
        :param Any collection_name: CosmosDB (SQL API) collection name. Type: string (or Expression with resultType string).
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'CosmosDbSqlApiCollection')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Any:
        """
        CosmosDB (SQL API) collection name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CouchbaseLinkedServiceResponse(dict):
    """
    Couchbase server linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_string: Optional[Any] = None,
                 cred_string: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None):
        """
        Couchbase server linked service.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_string: An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' cred_string: The Azure key vault secret reference of credString in connection string.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "type", 'Couchbase')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if cred_string is not None:
            pulumi.set(__self__, "cred_string", cred_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter(name="credString")
    def cred_string(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of credString in connection string.
        """
        return pulumi.get(self, "cred_string")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CouchbaseTableDatasetResponse(dict):
    """
    Couchbase server dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Couchbase server dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'CouchbaseTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CustomDataSourceLinkedServiceResponse(dict):
    """
    Custom linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None):
        """
        Custom linked service.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "type", 'CustomDataSource')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CustomDatasetResponse(dict):
    """
    The custom dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The custom dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'CustomDataset')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DataFlowResponseFolder(dict):
    """
    The folder that this data flow is in. If not specified, Data flow will appear at the root level.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        The folder that this data flow is in. If not specified, Data flow will appear at the root level.
        :param str name: The name of the folder that this data flow is in.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the folder that this data flow is in.
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DataFlowSinkResponse(dict):
    """
    Transformation for data flow sink.
    """
    def __init__(__self__, *,
                 name: str,
                 dataset: Optional['outputs.DatasetReferenceResponse'] = None,
                 description: Optional[str] = None,
                 linked_service: Optional['outputs.LinkedServiceReferenceResponse'] = None,
                 schema_linked_service: Optional['outputs.LinkedServiceReferenceResponse'] = None):
        """
        Transformation for data flow sink.
        :param str name: Transformation name.
        :param 'DatasetReferenceResponseArgs' dataset: Dataset reference.
        :param str description: Transformation description.
        :param 'LinkedServiceReferenceResponseArgs' linked_service: Linked service reference.
        :param 'LinkedServiceReferenceResponseArgs' schema_linked_service: Schema linked service reference.
        """
        pulumi.set(__self__, "name", name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if linked_service is not None:
            pulumi.set(__self__, "linked_service", linked_service)
        if schema_linked_service is not None:
            pulumi.set(__self__, "schema_linked_service", schema_linked_service)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Transformation name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def dataset(self) -> Optional['outputs.DatasetReferenceResponse']:
        """
        Dataset reference.
        """
        return pulumi.get(self, "dataset")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Transformation description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> Optional['outputs.LinkedServiceReferenceResponse']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service")

    @property
    @pulumi.getter(name="schemaLinkedService")
    def schema_linked_service(self) -> Optional['outputs.LinkedServiceReferenceResponse']:
        """
        Schema linked service reference.
        """
        return pulumi.get(self, "schema_linked_service")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DataFlowSourceResponse(dict):
    """
    Transformation for data flow source.
    """
    def __init__(__self__, *,
                 name: str,
                 dataset: Optional['outputs.DatasetReferenceResponse'] = None,
                 description: Optional[str] = None,
                 linked_service: Optional['outputs.LinkedServiceReferenceResponse'] = None,
                 schema_linked_service: Optional['outputs.LinkedServiceReferenceResponse'] = None):
        """
        Transformation for data flow source.
        :param str name: Transformation name.
        :param 'DatasetReferenceResponseArgs' dataset: Dataset reference.
        :param str description: Transformation description.
        :param 'LinkedServiceReferenceResponseArgs' linked_service: Linked service reference.
        :param 'LinkedServiceReferenceResponseArgs' schema_linked_service: Schema linked service reference.
        """
        pulumi.set(__self__, "name", name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if linked_service is not None:
            pulumi.set(__self__, "linked_service", linked_service)
        if schema_linked_service is not None:
            pulumi.set(__self__, "schema_linked_service", schema_linked_service)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Transformation name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def dataset(self) -> Optional['outputs.DatasetReferenceResponse']:
        """
        Dataset reference.
        """
        return pulumi.get(self, "dataset")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Transformation description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="linkedService")
    def linked_service(self) -> Optional['outputs.LinkedServiceReferenceResponse']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service")

    @property
    @pulumi.getter(name="schemaLinkedService")
    def schema_linked_service(self) -> Optional['outputs.LinkedServiceReferenceResponse']:
        """
        Schema linked service reference.
        """
        return pulumi.get(self, "schema_linked_service")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DatasetBZip2CompressionResponse(dict):
    """
    The BZip2 compression method used on a dataset.
    """
    def __init__(__self__, *,
                 type: str):
        """
        The BZip2 compression method used on a dataset.
        :param str type: Type of dataset compression.
        """
        pulumi.set(__self__, "type", 'BZip2')

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset compression.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DatasetDeflateCompressionResponse(dict):
    """
    The Deflate compression method used on a dataset.
    """
    def __init__(__self__, *,
                 type: str,
                 level: Optional[str] = None):
        """
        The Deflate compression method used on a dataset.
        :param str type: Type of dataset compression.
        :param str level: The Deflate compression level.
        """
        pulumi.set(__self__, "type", 'Deflate')
        if level is not None:
            pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset compression.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        The Deflate compression level.
        """
        return pulumi.get(self, "level")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DatasetGZipCompressionResponse(dict):
    """
    The GZip compression method used on a dataset.
    """
    def __init__(__self__, *,
                 type: str,
                 level: Optional[str] = None):
        """
        The GZip compression method used on a dataset.
        :param str type: Type of dataset compression.
        :param str level: The GZip compression level.
        """
        pulumi.set(__self__, "type", 'GZip')
        if level is not None:
            pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset compression.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        The GZip compression level.
        """
        return pulumi.get(self, "level")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DatasetReferenceResponse(dict):
    """
    Dataset reference type.
    """
    def __init__(__self__, *,
                 reference_name: str,
                 type: str,
                 parameters: Optional[Mapping[str, Any]] = None):
        """
        Dataset reference type.
        :param str reference_name: Reference dataset name.
        :param str type: Dataset reference type.
        :param Mapping[str, Any] parameters: Arguments for dataset.
        """
        pulumi.set(__self__, "reference_name", reference_name)
        pulumi.set(__self__, "type", type)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> str:
        """
        Reference dataset name.
        """
        return pulumi.get(self, "reference_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Dataset reference type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, Any]]:
        """
        Arguments for dataset.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DatasetResponseFolder(dict):
    """
    The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param str name: The name of the folder that this Dataset is in.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the folder that this Dataset is in.
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DatasetTarCompressionResponse(dict):
    """
    The Tar archive method used on a dataset.
    """
    def __init__(__self__, *,
                 type: str):
        """
        The Tar archive method used on a dataset.
        :param str type: Type of dataset compression.
        """
        pulumi.set(__self__, "type", 'Tar')

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset compression.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DatasetTarGZipCompressionResponse(dict):
    """
    The TarGZip compression method used on a dataset.
    """
    def __init__(__self__, *,
                 type: str,
                 level: Optional[str] = None):
        """
        The TarGZip compression method used on a dataset.
        :param str type: Type of dataset compression.
        :param str level: The TarGZip compression level.
        """
        pulumi.set(__self__, "type", 'TarGZip')
        if level is not None:
            pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset compression.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        The TarGZip compression level.
        """
        return pulumi.get(self, "level")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DatasetZipDeflateCompressionResponse(dict):
    """
    The ZipDeflate compression method used on a dataset.
    """
    def __init__(__self__, *,
                 type: str,
                 level: Optional[str] = None):
        """
        The ZipDeflate compression method used on a dataset.
        :param str type: Type of dataset compression.
        :param str level: The ZipDeflate compression level.
        """
        pulumi.set(__self__, "type", 'ZipDeflate')
        if level is not None:
            pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset compression.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        The ZipDeflate compression level.
        """
        return pulumi.get(self, "level")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class Db2LinkedServiceResponse(dict):
    """
    Linked service for DB2 data source.
    """
    def __init__(__self__, *,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 authentication_type: Optional[str] = None,
                 certificate_common_name: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_string: Optional[Any] = None,
                 database: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 package_collection: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 server: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Linked service for DB2 data source.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param str authentication_type: AuthenticationType to be used for connection. It is mutually exclusive with connectionString property.
        :param Any certificate_common_name: Certificate Common Name when TLS is enabled. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_string: The connection string. It is mutually exclusive with server, database, authenticationType, userName, packageCollection and certificateCommonName property. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param Any database: Database name for connection. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        :param Any package_collection: Under where packages are created when querying database. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password for authentication.
        :param Any server: Server name for connection. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        :param Any username: Username for authentication. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'Db2')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if certificate_common_name is not None:
            pulumi.set(__self__, "certificate_common_name", certificate_common_name)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if package_collection is not None:
            pulumi.set(__self__, "package_collection", package_collection)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[str]:
        """
        AuthenticationType to be used for connection. It is mutually exclusive with connectionString property.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="certificateCommonName")
    def certificate_common_name(self) -> Optional[Any]:
        """
        Certificate Common Name when TLS is enabled. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "certificate_common_name")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        The connection string. It is mutually exclusive with server, database, authenticationType, userName, packageCollection and certificateCommonName property. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def database(self) -> Optional[Any]:
        """
        Database name for connection. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter(name="packageCollection")
    def package_collection(self) -> Optional[Any]:
        """
        Under where packages are created when querying database. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "package_collection")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password for authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def server(self) -> Optional[Any]:
        """
        Server name for connection. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        Username for authentication. It is mutually exclusive with connectionString property. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class Db2TableDatasetResponse(dict):
    """
    The Db2 table dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The Db2 table dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The Db2 table name. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'Db2Table')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The Db2 table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DelimitedTextDatasetResponse(dict):
    """
    Delimited text dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 location: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 column_delimiter: Optional[Any] = None,
                 compression_codec: Optional[str] = None,
                 compression_level: Optional[str] = None,
                 description: Optional[str] = None,
                 encoding_name: Optional[Any] = None,
                 escape_char: Optional[Any] = None,
                 first_row_as_header: Optional[Any] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 null_value: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 quote_char: Optional[Any] = None,
                 row_delimiter: Optional[Any] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Delimited text dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param Union['AmazonS3LocationResponseArgs', 'AzureBlobFSLocationResponseArgs', 'AzureBlobStorageLocationResponseArgs', 'AzureDataLakeStoreLocationResponseArgs', 'AzureFileStorageLocationResponseArgs', 'FileServerLocationResponseArgs', 'FtpServerLocationResponseArgs', 'GoogleCloudStorageLocationResponseArgs', 'HdfsLocationResponseArgs', 'HttpServerLocationResponseArgs', 'SftpLocationResponseArgs'] location: The location of the delimited text storage.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param Any column_delimiter: The column delimiter. Type: string (or Expression with resultType string).
        :param str compression_level: The data compression method used for DelimitedText.
        :param str description: Dataset description.
        :param Any encoding_name: The code page name of the preferred encoding. If miss, the default value is UTF-8, unless BOM denotes another Unicode encoding. Refer to the name column of the table in the following link to set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType string).
        :param Any escape_char: The escape character. Type: string (or Expression with resultType string).
        :param Any first_row_as_header: When used as input, treat the first row of data as headers. When used as output,write the headers into the output as the first row of data. The default value is false. Type: boolean (or Expression with resultType boolean).
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any null_value: The null value string. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any quote_char: The quote character. Type: string (or Expression with resultType string).
        :param Any row_delimiter: The row delimiter. Type: string (or Expression with resultType string).
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "type", 'DelimitedText')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if column_delimiter is not None:
            pulumi.set(__self__, "column_delimiter", column_delimiter)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if compression_level is not None:
            pulumi.set(__self__, "compression_level", compression_level)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encoding_name is not None:
            pulumi.set(__self__, "encoding_name", encoding_name)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if first_row_as_header is not None:
            pulumi.set(__self__, "first_row_as_header", first_row_as_header)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if null_value is not None:
            pulumi.set(__self__, "null_value", null_value)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if row_delimiter is not None:
            pulumi.set(__self__, "row_delimiter", row_delimiter)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def location(self) -> Any:
        """
        The location of the delimited text storage.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="columnDelimiter")
    def column_delimiter(self) -> Optional[Any]:
        """
        The column delimiter. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "column_delimiter")

    @property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[str]:
        return pulumi.get(self, "compression_codec")

    @property
    @pulumi.getter(name="compressionLevel")
    def compression_level(self) -> Optional[str]:
        """
        The data compression method used for DelimitedText.
        """
        return pulumi.get(self, "compression_level")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encodingName")
    def encoding_name(self) -> Optional[Any]:
        """
        The code page name of the preferred encoding. If miss, the default value is UTF-8, unless BOM denotes another Unicode encoding. Refer to the name column of the table in the following link to set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encoding_name")

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[Any]:
        """
        The escape character. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "escape_char")

    @property
    @pulumi.getter(name="firstRowAsHeader")
    def first_row_as_header(self) -> Optional[Any]:
        """
        When used as input, treat the first row of data as headers. When used as output,write the headers into the output as the first row of data. The default value is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "first_row_as_header")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter(name="nullValue")
    def null_value(self) -> Optional[Any]:
        """
        The null value string. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "null_value")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[Any]:
        """
        The quote character. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "quote_char")

    @property
    @pulumi.getter(name="rowDelimiter")
    def row_delimiter(self) -> Optional[Any]:
        """
        The row delimiter. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "row_delimiter")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DocumentDbCollectionDatasetResponse(dict):
    """
    Microsoft Azure Document Database Collection dataset.
    """
    def __init__(__self__, *,
                 collection_name: Any,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Microsoft Azure Document Database Collection dataset.
        :param Any collection_name: Document Database collection name. Type: string (or Expression with resultType string).
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'DocumentDbCollection')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Any:
        """
        Document Database collection name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DrillLinkedServiceResponse(dict):
    """
    Drill server linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 pwd: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None):
        """
        Drill server linked service.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_string: An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' pwd: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "type", 'Drill')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if pwd is not None:
            pulumi.set(__self__, "pwd", pwd)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def pwd(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "pwd")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DrillTableDatasetResponse(dict):
    """
    Drill server dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Drill server dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Drill. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'DrillTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Drill. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DynamicsAXLinkedServiceResponse(dict):
    """
    Dynamics AX linked service.
    """
    def __init__(__self__, *,
                 aad_resource_id: Any,
                 service_principal_id: Any,
                 service_principal_key: Any,
                 tenant: Any,
                 type: str,
                 url: Any,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None):
        """
        Dynamics AX linked service.
        :param Any aad_resource_id: Specify the resource you are requesting authorization. Type: string (or Expression with resultType string).
        :param Any service_principal_id: Specify the application's client ID. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] service_principal_key: Specify the application's key. Mark this field as a SecureString to store it securely in Data Factory, or reference a secret stored in Azure Key Vault. Type: string (or Expression with resultType string).
        :param Any tenant: Specify the tenant information (domain name or tenant ID) under which your application resides. Retrieve it by hovering the mouse in the top-right corner of the Azure portal. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Any url: The Dynamics AX (or Dynamics 365 Finance and Operations) instance OData endpoint.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "aad_resource_id", aad_resource_id)
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "service_principal_key", service_principal_key)
        pulumi.set(__self__, "tenant", tenant)
        pulumi.set(__self__, "type", 'DynamicsAX')
        pulumi.set(__self__, "url", url)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="aadResourceId")
    def aad_resource_id(self) -> Any:
        """
        Specify the resource you are requesting authorization. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "aad_resource_id")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Any:
        """
        Specify the application's client ID. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Any:
        """
        Specify the application's key. Mark this field as a SecureString to store it securely in Data Factory, or reference a secret stored in Azure Key Vault. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_key")

    @property
    @pulumi.getter
    def tenant(self) -> Any:
        """
        Specify the tenant information (domain name or tenant ID) under which your application resides. Retrieve it by hovering the mouse in the top-right corner of the Azure portal. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        The Dynamics AX (or Dynamics 365 Finance and Operations) instance OData endpoint.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DynamicsAXResourceDatasetResponse(dict):
    """
    The path of the Dynamics AX OData entity.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 path: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The path of the Dynamics AX OData entity.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param Any path: The path of the Dynamics AX OData entity. Type: string (or Expression with resultType string).
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", 'DynamicsAXResource')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def path(self) -> Any:
        """
        The path of the Dynamics AX OData entity. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DynamicsCrmEntityDatasetResponse(dict):
    """
    The Dynamics CRM entity dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 entity_name: Optional[Any] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The Dynamics CRM entity dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param Any entity_name: The logical name of the entity. Type: string (or Expression with resultType string).
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'DynamicsCrmEntity')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entity_name is not None:
            pulumi.set(__self__, "entity_name", entity_name)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="entityName")
    def entity_name(self) -> Optional[Any]:
        """
        The logical name of the entity. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "entity_name")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DynamicsCrmLinkedServiceResponse(dict):
    """
    Dynamics CRM linked service.
    """
    def __init__(__self__, *,
                 authentication_type: str,
                 deployment_type: str,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 host_name: Optional[Any] = None,
                 organization_name: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 port: Optional[Any] = None,
                 service_principal_credential: Optional[Any] = None,
                 service_principal_credential_type: Optional[str] = None,
                 service_principal_id: Optional[Any] = None,
                 service_uri: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Dynamics CRM linked service.
        :param str authentication_type: The authentication type to connect to Dynamics CRM server. 'Office365' for online scenario, 'Ifd' for on-premises with Ifd scenario, 'AADServicePrincipal' for Server-To-Server authentication in online scenario. Type: string (or Expression with resultType string).
        :param str deployment_type: The deployment type of the Dynamics CRM instance. 'Online' for Dynamics CRM Online and 'OnPremisesWithIfd' for Dynamics CRM on-premises with Ifd. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any host_name: The host name of the on-premises Dynamics CRM server. The property is required for on-prem and not allowed for online. Type: string (or Expression with resultType string).
        :param Any organization_name: The organization name of the Dynamics CRM instance. The property is required for on-prem and required for online when there are more than one Dynamics CRM instances associated with the user. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password to access the Dynamics CRM instance.
        :param Any port: The port of on-premises Dynamics CRM server. The property is required for on-prem and not allowed for online. Default is 443. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] service_principal_credential: The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey', servicePrincipalCredential can be SecureString or AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can only be AzureKeyVaultSecretReference.
        :param str service_principal_credential_type: The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret, 'ServicePrincipalCert' for certificate. Type: string (or Expression with resultType string).
        :param Any service_principal_id: The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression with resultType string).
        :param Any service_uri: The URL to the Microsoft Dynamics CRM server. The property is required for on-line and not allowed for on-prem. Type: string (or Expression with resultType string).
        :param Any username: User name to access the Dynamics CRM instance. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "deployment_type", deployment_type)
        pulumi.set(__self__, "type", 'DynamicsCrm')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if organization_name is not None:
            pulumi.set(__self__, "organization_name", organization_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if service_principal_credential is not None:
            pulumi.set(__self__, "service_principal_credential", service_principal_credential)
        if service_principal_credential_type is not None:
            pulumi.set(__self__, "service_principal_credential_type", service_principal_credential_type)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_uri is not None:
            pulumi.set(__self__, "service_uri", service_uri)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        The authentication type to connect to Dynamics CRM server. 'Office365' for online scenario, 'Ifd' for on-premises with Ifd scenario, 'AADServicePrincipal' for Server-To-Server authentication in online scenario. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> str:
        """
        The deployment type of the Dynamics CRM instance. 'Online' for Dynamics CRM Online and 'OnPremisesWithIfd' for Dynamics CRM on-premises with Ifd. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "deployment_type")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[Any]:
        """
        The host name of the on-premises Dynamics CRM server. The property is required for on-prem and not allowed for online. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter(name="organizationName")
    def organization_name(self) -> Optional[Any]:
        """
        The organization name of the Dynamics CRM instance. The property is required for on-prem and required for online when there are more than one Dynamics CRM instances associated with the user. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "organization_name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password to access the Dynamics CRM instance.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The port of on-premises Dynamics CRM server. The property is required for on-prem and not allowed for online. Default is 443. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="servicePrincipalCredential")
    def service_principal_credential(self) -> Optional[Any]:
        """
        The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey', servicePrincipalCredential can be SecureString or AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can only be AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "service_principal_credential")

    @property
    @pulumi.getter(name="servicePrincipalCredentialType")
    def service_principal_credential_type(self) -> Optional[str]:
        """
        The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret, 'ServicePrincipalCert' for certificate. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_credential_type")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="serviceUri")
    def service_uri(self) -> Optional[Any]:
        """
        The URL to the Microsoft Dynamics CRM server. The property is required for on-line and not allowed for on-prem. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_uri")

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        User name to access the Dynamics CRM instance. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DynamicsEntityDatasetResponse(dict):
    """
    The Dynamics entity dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 entity_name: Optional[Any] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The Dynamics entity dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param Any entity_name: The logical name of the entity. Type: string (or Expression with resultType string).
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'DynamicsEntity')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entity_name is not None:
            pulumi.set(__self__, "entity_name", entity_name)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="entityName")
    def entity_name(self) -> Optional[Any]:
        """
        The logical name of the entity. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "entity_name")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DynamicsLinkedServiceResponse(dict):
    """
    Dynamics linked service.
    """
    def __init__(__self__, *,
                 authentication_type: str,
                 deployment_type: str,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 host_name: Optional[Any] = None,
                 organization_name: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 port: Optional[Any] = None,
                 service_principal_credential: Optional[Any] = None,
                 service_principal_credential_type: Optional[str] = None,
                 service_principal_id: Optional[Any] = None,
                 service_uri: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Dynamics linked service.
        :param str authentication_type: The authentication type to connect to Dynamics server. 'Office365' for online scenario, 'Ifd' for on-premises with Ifd scenario, 'AADServicePrincipal' for Server-To-Server authentication in online scenario. Type: string (or Expression with resultType string).
        :param str deployment_type: The deployment type of the Dynamics instance. 'Online' for Dynamics Online and 'OnPremisesWithIfd' for Dynamics on-premises with Ifd. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any host_name: The host name of the on-premises Dynamics server. The property is required for on-prem and not allowed for online. Type: string (or Expression with resultType string).
        :param Any organization_name: The organization name of the Dynamics instance. The property is required for on-prem and required for online when there are more than one Dynamics instances associated with the user. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password to access the Dynamics instance.
        :param Any port: The port of on-premises Dynamics server. The property is required for on-prem and not allowed for online. Default is 443. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] service_principal_credential: The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey', servicePrincipalCredential can be SecureString or AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can only be AzureKeyVaultSecretReference.
        :param str service_principal_credential_type: The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret, 'ServicePrincipalCert' for certificate. Type: string (or Expression with resultType string).
        :param Any service_principal_id: The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression with resultType string).
        :param Any service_uri: The URL to the Microsoft Dynamics server. The property is required for on-line and not allowed for on-prem. Type: string (or Expression with resultType string).
        :param Any username: User name to access the Dynamics instance. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "deployment_type", deployment_type)
        pulumi.set(__self__, "type", 'Dynamics')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if organization_name is not None:
            pulumi.set(__self__, "organization_name", organization_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if service_principal_credential is not None:
            pulumi.set(__self__, "service_principal_credential", service_principal_credential)
        if service_principal_credential_type is not None:
            pulumi.set(__self__, "service_principal_credential_type", service_principal_credential_type)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_uri is not None:
            pulumi.set(__self__, "service_uri", service_uri)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        The authentication type to connect to Dynamics server. 'Office365' for online scenario, 'Ifd' for on-premises with Ifd scenario, 'AADServicePrincipal' for Server-To-Server authentication in online scenario. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> str:
        """
        The deployment type of the Dynamics instance. 'Online' for Dynamics Online and 'OnPremisesWithIfd' for Dynamics on-premises with Ifd. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "deployment_type")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[Any]:
        """
        The host name of the on-premises Dynamics server. The property is required for on-prem and not allowed for online. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter(name="organizationName")
    def organization_name(self) -> Optional[Any]:
        """
        The organization name of the Dynamics instance. The property is required for on-prem and required for online when there are more than one Dynamics instances associated with the user. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "organization_name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password to access the Dynamics instance.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The port of on-premises Dynamics server. The property is required for on-prem and not allowed for online. Default is 443. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="servicePrincipalCredential")
    def service_principal_credential(self) -> Optional[Any]:
        """
        The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey', servicePrincipalCredential can be SecureString or AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can only be AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "service_principal_credential")

    @property
    @pulumi.getter(name="servicePrincipalCredentialType")
    def service_principal_credential_type(self) -> Optional[str]:
        """
        The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret, 'ServicePrincipalCert' for certificate. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_credential_type")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="serviceUri")
    def service_uri(self) -> Optional[Any]:
        """
        The URL to the Microsoft Dynamics server. The property is required for on-line and not allowed for on-prem. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_uri")

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        User name to access the Dynamics instance. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class EloquaLinkedServiceResponse(dict):
    """
    Eloqua server linked service.
    """
    def __init__(__self__, *,
                 endpoint: Any,
                 type: str,
                 username: Any,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Eloqua server linked service.
        :param Any endpoint: The endpoint of the Eloqua server. (i.e. eloqua.example.com)
        :param str type: Type of linked service.
        :param Any username: The site name and user name of your Eloqua account in the form: sitename/username. (i.e. Eloqua/Alice)
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: The password corresponding to the user name.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "type", 'Eloqua')
        pulumi.set(__self__, "username", username)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter
    def endpoint(self) -> Any:
        """
        The endpoint of the Eloqua server. (i.e. eloqua.example.com)
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def username(self) -> Any:
        """
        The site name and user name of your Eloqua account in the form: sitename/username. (i.e. Eloqua/Alice)
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        The password corresponding to the user name.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class EloquaObjectDatasetResponse(dict):
    """
    Eloqua server dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Eloqua server dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'EloquaObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class EntityReferenceResponse(dict):
    """
    The entity reference.
    """
    def __init__(__self__, *,
                 reference_name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        The entity reference.
        :param str reference_name: The name of this referenced entity.
        :param str type: The type of this referenced entity.
        """
        if reference_name is not None:
            pulumi.set(__self__, "reference_name", reference_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> Optional[str]:
        """
        The name of this referenced entity.
        """
        return pulumi.get(self, "reference_name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of this referenced entity.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class EnvironmentVariableSetupResponse(dict):
    """
    The custom setup of setting environment variable.
    """
    def __init__(__self__, *,
                 type: str,
                 variable_name: str,
                 variable_value: str):
        """
        The custom setup of setting environment variable.
        :param str type: The type of custom setup.
        :param str variable_name: The name of the environment variable.
        :param str variable_value: The value of the environment variable.
        """
        pulumi.set(__self__, "type", 'EnvironmentVariableSetup')
        pulumi.set(__self__, "variable_name", variable_name)
        pulumi.set(__self__, "variable_value", variable_value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of custom setup.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="variableName")
    def variable_name(self) -> str:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "variable_name")

    @property
    @pulumi.getter(name="variableValue")
    def variable_value(self) -> str:
        """
        The value of the environment variable.
        """
        return pulumi.get(self, "variable_value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ExcelDatasetResponse(dict):
    """
    Excel dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 location: Any,
                 sheet_name: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 compression: Optional[Any] = None,
                 description: Optional[str] = None,
                 first_row_as_header: Optional[Any] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 null_value: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 range: Optional[Any] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Excel dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param Union['AmazonS3LocationResponseArgs', 'AzureBlobFSLocationResponseArgs', 'AzureBlobStorageLocationResponseArgs', 'AzureDataLakeStoreLocationResponseArgs', 'AzureFileStorageLocationResponseArgs', 'FileServerLocationResponseArgs', 'FtpServerLocationResponseArgs', 'GoogleCloudStorageLocationResponseArgs', 'HdfsLocationResponseArgs', 'HttpServerLocationResponseArgs', 'SftpLocationResponseArgs'] location: The location of the excel storage.
        :param Any sheet_name: The sheet of excel file. Type: string (or Expression with resultType string).
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param Union['DatasetBZip2CompressionResponseArgs', 'DatasetDeflateCompressionResponseArgs', 'DatasetGZipCompressionResponseArgs', 'DatasetTarCompressionResponseArgs', 'DatasetTarGZipCompressionResponseArgs', 'DatasetZipDeflateCompressionResponseArgs'] compression: The data compression method used for the json dataset.
        :param str description: Dataset description.
        :param Any first_row_as_header: When used as input, treat the first row of data as headers. When used as output,write the headers into the output as the first row of data. The default value is false. Type: boolean (or Expression with resultType boolean).
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any null_value: The null value string. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any range: The partial data of one sheet. Type: string (or Expression with resultType string).
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "sheet_name", sheet_name)
        pulumi.set(__self__, "type", 'Excel')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if first_row_as_header is not None:
            pulumi.set(__self__, "first_row_as_header", first_row_as_header)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if null_value is not None:
            pulumi.set(__self__, "null_value", null_value)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if range is not None:
            pulumi.set(__self__, "range", range)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def location(self) -> Any:
        """
        The location of the excel storage.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="sheetName")
    def sheet_name(self) -> Any:
        """
        The sheet of excel file. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "sheet_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def compression(self) -> Optional[Any]:
        """
        The data compression method used for the json dataset.
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="firstRowAsHeader")
    def first_row_as_header(self) -> Optional[Any]:
        """
        When used as input, treat the first row of data as headers. When used as output,write the headers into the output as the first row of data. The default value is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "first_row_as_header")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter(name="nullValue")
    def null_value(self) -> Optional[Any]:
        """
        The null value string. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "null_value")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def range(self) -> Optional[Any]:
        """
        The partial data of one sheet. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "range")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ExecutionActivityResponse(dict):
    """
    Base class for all execution activities.
    """
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 depends_on: Optional[Sequence['outputs.ActivityDependencyResponse']] = None,
                 description: Optional[str] = None,
                 linked_service_name: Optional['outputs.LinkedServiceReferenceResponse'] = None,
                 policy: Optional['outputs.ActivityPolicyResponse'] = None,
                 user_properties: Optional[Sequence['outputs.UserPropertyResponse']] = None):
        """
        Base class for all execution activities.
        :param str name: Activity name.
        :param str type: Type of activity.
        :param Sequence['ActivityDependencyResponseArgs'] depends_on: Activity depends on condition.
        :param str description: Activity description.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param 'ActivityPolicyResponseArgs' policy: Activity policy.
        :param Sequence['UserPropertyResponseArgs'] user_properties: Activity user properties.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'Execution')
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Activity name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of activity.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[Sequence['outputs.ActivityDependencyResponse']]:
        """
        Activity depends on condition.
        """
        return pulumi.get(self, "depends_on")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Activity description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional['outputs.LinkedServiceReferenceResponse']:
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def policy(self) -> Optional['outputs.ActivityPolicyResponse']:
        """
        Activity policy.
        """
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[Sequence['outputs.UserPropertyResponse']]:
        """
        Activity user properties.
        """
        return pulumi.get(self, "user_properties")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FactoryGitHubConfigurationResponse(dict):
    """
    Factory's GitHub repo information.
    """
    def __init__(__self__, *,
                 account_name: str,
                 collaboration_branch: str,
                 repository_name: str,
                 root_folder: str,
                 type: str,
                 host_name: Optional[str] = None,
                 last_commit_id: Optional[str] = None):
        """
        Factory's GitHub repo information.
        :param str account_name: Account name.
        :param str collaboration_branch: Collaboration branch.
        :param str repository_name: Repository name.
        :param str root_folder: Root folder.
        :param str type: Type of repo configuration.
        :param str host_name: GitHub Enterprise host name. For example: https://github.mydomain.com
        :param str last_commit_id: Last commit id.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "collaboration_branch", collaboration_branch)
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "root_folder", root_folder)
        pulumi.set(__self__, "type", 'FactoryGitHubConfiguration')
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        Account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="collaborationBranch")
    def collaboration_branch(self) -> str:
        """
        Collaboration branch.
        """
        return pulumi.get(self, "collaboration_branch")

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> str:
        """
        Repository name.
        """
        return pulumi.get(self, "repository_name")

    @property
    @pulumi.getter(name="rootFolder")
    def root_folder(self) -> str:
        """
        Root folder.
        """
        return pulumi.get(self, "root_folder")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of repo configuration.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[str]:
        """
        GitHub Enterprise host name. For example: https://github.mydomain.com
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[str]:
        """
        Last commit id.
        """
        return pulumi.get(self, "last_commit_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FactoryIdentityResponse(dict):
    """
    Identity properties of the factory resource.
    """
    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: str):
        """
        Identity properties of the factory resource.
        :param str principal_id: The principal id of the identity.
        :param str tenant_id: The client tenant id of the identity.
        :param str type: The identity type. Currently the only supported type is 'SystemAssigned'.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal id of the identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The client tenant id of the identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The identity type. Currently the only supported type is 'SystemAssigned'.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FactoryVSTSConfigurationResponse(dict):
    """
    Factory's VSTS repo information.
    """
    def __init__(__self__, *,
                 account_name: str,
                 collaboration_branch: str,
                 project_name: str,
                 repository_name: str,
                 root_folder: str,
                 type: str,
                 last_commit_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        Factory's VSTS repo information.
        :param str account_name: Account name.
        :param str collaboration_branch: Collaboration branch.
        :param str project_name: VSTS project name.
        :param str repository_name: Repository name.
        :param str root_folder: Root folder.
        :param str type: Type of repo configuration.
        :param str last_commit_id: Last commit id.
        :param str tenant_id: VSTS tenant id.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "collaboration_branch", collaboration_branch)
        pulumi.set(__self__, "project_name", project_name)
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "root_folder", root_folder)
        pulumi.set(__self__, "type", 'FactoryVSTSConfiguration')
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        Account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="collaborationBranch")
    def collaboration_branch(self) -> str:
        """
        Collaboration branch.
        """
        return pulumi.get(self, "collaboration_branch")

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> str:
        """
        VSTS project name.
        """
        return pulumi.get(self, "project_name")

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> str:
        """
        Repository name.
        """
        return pulumi.get(self, "repository_name")

    @property
    @pulumi.getter(name="rootFolder")
    def root_folder(self) -> str:
        """
        Root folder.
        """
        return pulumi.get(self, "root_folder")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of repo configuration.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[str]:
        """
        Last commit id.
        """
        return pulumi.get(self, "last_commit_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        VSTS tenant id.
        """
        return pulumi.get(self, "tenant_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FileServerLinkedServiceResponse(dict):
    """
    File system linked service.
    """
    def __init__(__self__, *,
                 host: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 user_id: Optional[Any] = None):
        """
        File system linked service.
        :param Any host: Host name of the server. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password to logon the server.
        :param Any user_id: User ID to logon the server. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'FileServer')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        Host name of the server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password to logon the server.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[Any]:
        """
        User ID to logon the server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FileServerLocationResponse(dict):
    """
    The location of file server dataset.
    """
    def __init__(__self__, *,
                 type: str,
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None):
        """
        The location of file server dataset.
        :param str type: Type of dataset storage location.
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        pulumi.set(__self__, "type", 'FileServerLocation')
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset storage location.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FileShareDatasetResponse(dict):
    """
    An on-premises file system dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 compression: Optional[Any] = None,
                 description: Optional[str] = None,
                 file_filter: Optional[Any] = None,
                 file_name: Optional[Any] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 folder_path: Optional[Any] = None,
                 format: Optional[Any] = None,
                 modified_datetime_end: Optional[Any] = None,
                 modified_datetime_start: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        An on-premises file system dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param Union['DatasetBZip2CompressionResponseArgs', 'DatasetDeflateCompressionResponseArgs', 'DatasetGZipCompressionResponseArgs', 'DatasetTarCompressionResponseArgs', 'DatasetTarGZipCompressionResponseArgs', 'DatasetZipDeflateCompressionResponseArgs'] compression: The data compression method used for the file system.
        :param str description: Dataset description.
        :param Any file_filter: Specify a filter to be used to select a subset of files in the folderPath rather than all files. Type: string (or Expression with resultType string).
        :param Any file_name: The name of the on-premises file system. Type: string (or Expression with resultType string).
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any folder_path: The path of the on-premises file system. Type: string (or Expression with resultType string).
        :param Union['AvroFormatResponseArgs', 'JsonFormatResponseArgs', 'OrcFormatResponseArgs', 'ParquetFormatResponseArgs', 'TextFormatResponseArgs'] format: The format of the files.
        :param Any modified_datetime_end: The end of file's modified datetime. Type: string (or Expression with resultType string).
        :param Any modified_datetime_start: The start of file's modified datetime. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'FileShare')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if file_filter is not None:
            pulumi.set(__self__, "file_filter", file_filter)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if modified_datetime_end is not None:
            pulumi.set(__self__, "modified_datetime_end", modified_datetime_end)
        if modified_datetime_start is not None:
            pulumi.set(__self__, "modified_datetime_start", modified_datetime_start)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def compression(self) -> Optional[Any]:
        """
        The data compression method used for the file system.
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="fileFilter")
    def file_filter(self) -> Optional[Any]:
        """
        Specify a filter to be used to select a subset of files in the folderPath rather than all files. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_filter")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        The name of the on-premises file system. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        The path of the on-premises file system. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "folder_path")

    @property
    @pulumi.getter
    def format(self) -> Optional[Any]:
        """
        The format of the files.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="modifiedDatetimeEnd")
    def modified_datetime_end(self) -> Optional[Any]:
        """
        The end of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_end")

    @property
    @pulumi.getter(name="modifiedDatetimeStart")
    def modified_datetime_start(self) -> Optional[Any]:
        """
        The start of file's modified datetime. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "modified_datetime_start")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FtpServerLinkedServiceResponse(dict):
    """
    A FTP server Linked Service.
    """
    def __init__(__self__, *,
                 host: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 authentication_type: Optional[str] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 enable_server_certificate_validation: Optional[Any] = None,
                 enable_ssl: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 port: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        A FTP server Linked Service.
        :param Any host: Host name of the FTP server. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param str authentication_type: The authentication type to be used to connect to the FTP server.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any enable_server_certificate_validation: If true, validate the FTP server SSL certificate when connect over SSL/TLS channel. Default value is true. Type: boolean (or Expression with resultType boolean).
        :param Any enable_ssl: If true, connect to the FTP server over SSL/TLS channel. Default value is true. Type: boolean (or Expression with resultType boolean).
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password to logon the FTP server.
        :param Any port: The TCP port number that the FTP server uses to listen for client connections. Default value is 21. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any user_name: Username to logon the FTP server. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'FtpServer')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_server_certificate_validation is not None:
            pulumi.set(__self__, "enable_server_certificate_validation", enable_server_certificate_validation)
        if enable_ssl is not None:
            pulumi.set(__self__, "enable_ssl", enable_ssl)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        Host name of the FTP server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[str]:
        """
        The authentication type to be used to connect to the FTP server.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="enableServerCertificateValidation")
    def enable_server_certificate_validation(self) -> Optional[Any]:
        """
        If true, validate the FTP server SSL certificate when connect over SSL/TLS channel. Default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "enable_server_certificate_validation")

    @property
    @pulumi.getter(name="enableSsl")
    def enable_ssl(self) -> Optional[Any]:
        """
        If true, connect to the FTP server over SSL/TLS channel. Default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "enable_ssl")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password to logon the FTP server.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The TCP port number that the FTP server uses to listen for client connections. Default value is 21. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        Username to logon the FTP server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FtpServerLocationResponse(dict):
    """
    The location of ftp server dataset.
    """
    def __init__(__self__, *,
                 type: str,
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None):
        """
        The location of ftp server dataset.
        :param str type: Type of dataset storage location.
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        pulumi.set(__self__, "type", 'FtpServerLocation')
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset storage location.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalParameterSpecificationResponse(dict):
    """
    Definition of a single parameter for an entity.
    """
    def __init__(__self__, *,
                 type: str,
                 value: Any):
        """
        Definition of a single parameter for an entity.
        :param str type: Global Parameter type.
        :param Any value: Value of parameter.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Global Parameter type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Any:
        """
        Value of parameter.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GoogleAdWordsLinkedServiceResponse(dict):
    """
    Google AdWords service linked service.
    """
    def __init__(__self__, *,
                 authentication_type: str,
                 client_customer_id: Any,
                 developer_token: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 client_id: Optional[Any] = None,
                 client_secret: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 email: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 key_file_path: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 refresh_token: Optional[Any] = None,
                 trusted_cert_path: Optional[Any] = None,
                 use_system_trust_store: Optional[Any] = None):
        """
        Google AdWords service linked service.
        :param str authentication_type: The OAuth 2.0 authentication mechanism used for authentication. ServiceAuthentication can only be used on self-hosted IR.
        :param Any client_customer_id: The Client customer ID of the AdWords account that you want to fetch report data for.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] developer_token: The developer token associated with the manager account that you use to grant access to the AdWords API.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any client_id: The client id of the google application used to acquire the refresh token. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] client_secret: The client secret of the google application used to acquire the refresh token.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any email: The service account email ID that is used for ServiceAuthentication and can only be used on self-hosted IR.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any key_file_path: The full path to the .p12 key file that is used to authenticate the service account email address and can only be used on self-hosted IR.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] refresh_token: The refresh token obtained from Google for authorizing access to AdWords for UserAuthentication.
        :param Any trusted_cert_path: The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        :param Any use_system_trust_store: Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "client_customer_id", client_customer_id)
        pulumi.set(__self__, "developer_token", developer_token)
        pulumi.set(__self__, "type", 'GoogleAdWords')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if key_file_path is not None:
            pulumi.set(__self__, "key_file_path", key_file_path)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if trusted_cert_path is not None:
            pulumi.set(__self__, "trusted_cert_path", trusted_cert_path)
        if use_system_trust_store is not None:
            pulumi.set(__self__, "use_system_trust_store", use_system_trust_store)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        The OAuth 2.0 authentication mechanism used for authentication. ServiceAuthentication can only be used on self-hosted IR.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="clientCustomerID")
    def client_customer_id(self) -> Any:
        """
        The Client customer ID of the AdWords account that you want to fetch report data for.
        """
        return pulumi.get(self, "client_customer_id")

    @property
    @pulumi.getter(name="developerToken")
    def developer_token(self) -> Any:
        """
        The developer token associated with the manager account that you use to grant access to the AdWords API.
        """
        return pulumi.get(self, "developer_token")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[Any]:
        """
        The client id of the google application used to acquire the refresh token. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[Any]:
        """
        The client secret of the google application used to acquire the refresh token.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def email(self) -> Optional[Any]:
        """
        The service account email ID that is used for ServiceAuthentication and can only be used on self-hosted IR.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter(name="keyFilePath")
    def key_file_path(self) -> Optional[Any]:
        """
        The full path to the .p12 key file that is used to authenticate the service account email address and can only be used on self-hosted IR.
        """
        return pulumi.get(self, "key_file_path")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[Any]:
        """
        The refresh token obtained from Google for authorizing access to AdWords for UserAuthentication.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="trustedCertPath")
    def trusted_cert_path(self) -> Optional[Any]:
        """
        The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        """
        return pulumi.get(self, "trusted_cert_path")

    @property
    @pulumi.getter(name="useSystemTrustStore")
    def use_system_trust_store(self) -> Optional[Any]:
        """
        Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        """
        return pulumi.get(self, "use_system_trust_store")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GoogleAdWordsObjectDatasetResponse(dict):
    """
    Google AdWords service dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Google AdWords service dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'GoogleAdWordsObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GoogleBigQueryLinkedServiceResponse(dict):
    """
    Google BigQuery service linked service.
    """
    def __init__(__self__, *,
                 authentication_type: str,
                 project: Any,
                 type: str,
                 additional_projects: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 client_id: Optional[Any] = None,
                 client_secret: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 email: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 key_file_path: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 refresh_token: Optional[Any] = None,
                 request_google_drive_scope: Optional[Any] = None,
                 trusted_cert_path: Optional[Any] = None,
                 use_system_trust_store: Optional[Any] = None):
        """
        Google BigQuery service linked service.
        :param str authentication_type: The OAuth 2.0 authentication mechanism used for authentication. ServiceAuthentication can only be used on self-hosted IR.
        :param Any project: The default BigQuery project to query against.
        :param str type: Type of linked service.
        :param Any additional_projects: A comma-separated list of public BigQuery projects to access.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any client_id: The client id of the google application used to acquire the refresh token. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] client_secret: The client secret of the google application used to acquire the refresh token.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any email: The service account email ID that is used for ServiceAuthentication and can only be used on self-hosted IR.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any key_file_path: The full path to the .p12 key file that is used to authenticate the service account email address and can only be used on self-hosted IR.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] refresh_token: The refresh token obtained from Google for authorizing access to BigQuery for UserAuthentication.
        :param Any request_google_drive_scope: Whether to request access to Google Drive. Allowing Google Drive access enables support for federated tables that combine BigQuery data with data from Google Drive. The default value is false.
        :param Any trusted_cert_path: The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        :param Any use_system_trust_store: Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "type", 'GoogleBigQuery')
        if additional_projects is not None:
            pulumi.set(__self__, "additional_projects", additional_projects)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if key_file_path is not None:
            pulumi.set(__self__, "key_file_path", key_file_path)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if request_google_drive_scope is not None:
            pulumi.set(__self__, "request_google_drive_scope", request_google_drive_scope)
        if trusted_cert_path is not None:
            pulumi.set(__self__, "trusted_cert_path", trusted_cert_path)
        if use_system_trust_store is not None:
            pulumi.set(__self__, "use_system_trust_store", use_system_trust_store)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        The OAuth 2.0 authentication mechanism used for authentication. ServiceAuthentication can only be used on self-hosted IR.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter
    def project(self) -> Any:
        """
        The default BigQuery project to query against.
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="additionalProjects")
    def additional_projects(self) -> Optional[Any]:
        """
        A comma-separated list of public BigQuery projects to access.
        """
        return pulumi.get(self, "additional_projects")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[Any]:
        """
        The client id of the google application used to acquire the refresh token. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[Any]:
        """
        The client secret of the google application used to acquire the refresh token.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def email(self) -> Optional[Any]:
        """
        The service account email ID that is used for ServiceAuthentication and can only be used on self-hosted IR.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter(name="keyFilePath")
    def key_file_path(self) -> Optional[Any]:
        """
        The full path to the .p12 key file that is used to authenticate the service account email address and can only be used on self-hosted IR.
        """
        return pulumi.get(self, "key_file_path")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[Any]:
        """
        The refresh token obtained from Google for authorizing access to BigQuery for UserAuthentication.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="requestGoogleDriveScope")
    def request_google_drive_scope(self) -> Optional[Any]:
        """
        Whether to request access to Google Drive. Allowing Google Drive access enables support for federated tables that combine BigQuery data with data from Google Drive. The default value is false.
        """
        return pulumi.get(self, "request_google_drive_scope")

    @property
    @pulumi.getter(name="trustedCertPath")
    def trusted_cert_path(self) -> Optional[Any]:
        """
        The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        """
        return pulumi.get(self, "trusted_cert_path")

    @property
    @pulumi.getter(name="useSystemTrustStore")
    def use_system_trust_store(self) -> Optional[Any]:
        """
        Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        """
        return pulumi.get(self, "use_system_trust_store")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GoogleBigQueryObjectDatasetResponse(dict):
    """
    Google BigQuery service dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 dataset: Optional[Any] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Google BigQuery service dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param Any dataset: The database name of the Google BigQuery. Type: string (or Expression with resultType string).
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Google BigQuery. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using database + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'GoogleBigQueryObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def dataset(self) -> Optional[Any]:
        """
        The database name of the Google BigQuery. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "dataset")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Google BigQuery. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using database + table properties instead.
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GoogleCloudStorageLinkedServiceResponse(dict):
    """
    Linked service for Google Cloud Storage.
    """
    def __init__(__self__, *,
                 type: str,
                 access_key_id: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 secret_access_key: Optional[Any] = None,
                 service_url: Optional[Any] = None):
        """
        Linked service for Google Cloud Storage.
        :param str type: Type of linked service.
        :param Any access_key_id: The access key identifier of the Google Cloud Storage Identity and Access Management (IAM) user. Type: string (or Expression with resultType string).
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] secret_access_key: The secret access key of the Google Cloud Storage Identity and Access Management (IAM) user.
        :param Any service_url: This value specifies the endpoint to access with the Google Cloud Storage Connector. This is an optional property; change it only if you want to try a different service endpoint or want to switch between https and http. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'GoogleCloudStorage')
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if service_url is not None:
            pulumi.set(__self__, "service_url", service_url)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[Any]:
        """
        The access key identifier of the Google Cloud Storage Identity and Access Management (IAM) user. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[Any]:
        """
        The secret access key of the Google Cloud Storage Identity and Access Management (IAM) user.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="serviceUrl")
    def service_url(self) -> Optional[Any]:
        """
        This value specifies the endpoint to access with the Google Cloud Storage Connector. This is an optional property; change it only if you want to try a different service endpoint or want to switch between https and http. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_url")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GoogleCloudStorageLocationResponse(dict):
    """
    The location of Google Cloud Storage dataset.
    """
    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[Any] = None,
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None,
                 version: Optional[Any] = None):
        """
        The location of Google Cloud Storage dataset.
        :param str type: Type of dataset storage location.
        :param Any bucket_name: Specify the bucketName of Google Cloud Storage. Type: string (or Expression with resultType string)
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        :param Any version: Specify the version of Google Cloud Storage. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'GoogleCloudStorageLocation')
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset storage location.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[Any]:
        """
        Specify the bucketName of Google Cloud Storage. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    @property
    @pulumi.getter
    def version(self) -> Optional[Any]:
        """
        Specify the version of Google Cloud Storage. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GreenplumLinkedServiceResponse(dict):
    """
    Greenplum Database linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 pwd: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None):
        """
        Greenplum Database linked service.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_string: An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' pwd: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "type", 'Greenplum')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if pwd is not None:
            pulumi.set(__self__, "pwd", pwd)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def pwd(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "pwd")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GreenplumTableDatasetResponse(dict):
    """
    Greenplum Database dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Greenplum Database dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of Greenplum. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'GreenplumTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of Greenplum. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HBaseLinkedServiceResponse(dict):
    """
    HBase server linked service.
    """
    def __init__(__self__, *,
                 authentication_type: str,
                 host: Any,
                 type: str,
                 allow_host_name_cn_mismatch: Optional[Any] = None,
                 allow_self_signed_server_cert: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 enable_ssl: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 http_path: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 port: Optional[Any] = None,
                 trusted_cert_path: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        HBase server linked service.
        :param str authentication_type: The authentication mechanism to use to connect to the HBase server.
        :param Any host: The IP address or host name of the HBase server. (i.e. 192.168.222.160)
        :param str type: Type of linked service.
        :param Any allow_host_name_cn_mismatch: Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        :param Any allow_self_signed_server_cert: Specifies whether to allow self-signed certificates from the server. The default value is false.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any enable_ssl: Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any http_path: The partial URL corresponding to the HBase server. (i.e. /gateway/sandbox/hbase/version)
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: The password corresponding to the user name.
        :param Any port: The TCP port that the HBase instance uses to listen for client connections. The default value is 9090.
        :param Any trusted_cert_path: The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        :param Any username: The user name used to connect to the HBase instance.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'HBase')
        if allow_host_name_cn_mismatch is not None:
            pulumi.set(__self__, "allow_host_name_cn_mismatch", allow_host_name_cn_mismatch)
        if allow_self_signed_server_cert is not None:
            pulumi.set(__self__, "allow_self_signed_server_cert", allow_self_signed_server_cert)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_ssl is not None:
            pulumi.set(__self__, "enable_ssl", enable_ssl)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if http_path is not None:
            pulumi.set(__self__, "http_path", http_path)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if trusted_cert_path is not None:
            pulumi.set(__self__, "trusted_cert_path", trusted_cert_path)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        The authentication mechanism to use to connect to the HBase server.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        The IP address or host name of the HBase server. (i.e. 192.168.222.160)
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="allowHostNameCNMismatch")
    def allow_host_name_cn_mismatch(self) -> Optional[Any]:
        """
        Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        """
        return pulumi.get(self, "allow_host_name_cn_mismatch")

    @property
    @pulumi.getter(name="allowSelfSignedServerCert")
    def allow_self_signed_server_cert(self) -> Optional[Any]:
        """
        Specifies whether to allow self-signed certificates from the server. The default value is false.
        """
        return pulumi.get(self, "allow_self_signed_server_cert")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="enableSsl")
    def enable_ssl(self) -> Optional[Any]:
        """
        Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        """
        return pulumi.get(self, "enable_ssl")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter(name="httpPath")
    def http_path(self) -> Optional[Any]:
        """
        The partial URL corresponding to the HBase server. (i.e. /gateway/sandbox/hbase/version)
        """
        return pulumi.get(self, "http_path")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        The password corresponding to the user name.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The TCP port that the HBase instance uses to listen for client connections. The default value is 9090.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="trustedCertPath")
    def trusted_cert_path(self) -> Optional[Any]:
        """
        The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        """
        return pulumi.get(self, "trusted_cert_path")

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The user name used to connect to the HBase instance.
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HBaseObjectDatasetResponse(dict):
    """
    HBase server dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        HBase server dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'HBaseObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HDInsightLinkedServiceResponse(dict):
    """
    HDInsight linked service.
    """
    def __init__(__self__, *,
                 cluster_uri: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 file_system: Optional[Any] = None,
                 hcatalog_linked_service_name: Optional['outputs.LinkedServiceReferenceResponse'] = None,
                 is_esp_enabled: Optional[Any] = None,
                 linked_service_name: Optional['outputs.LinkedServiceReferenceResponse'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        HDInsight linked service.
        :param Any cluster_uri: HDInsight cluster URI. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any file_system: Specify the FileSystem if the main storage for the HDInsight is ADLS Gen2. Type: string (or Expression with resultType string).
        :param 'LinkedServiceReferenceResponseArgs' hcatalog_linked_service_name: A reference to the Azure SQL linked service that points to the HCatalog database.
        :param Any is_esp_enabled: Specify if the HDInsight is created with ESP (Enterprise Security Package). Type: Boolean.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: The Azure Storage linked service reference.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: HDInsight cluster password.
        :param Any user_name: HDInsight cluster user name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "cluster_uri", cluster_uri)
        pulumi.set(__self__, "type", 'HDInsight')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if hcatalog_linked_service_name is not None:
            pulumi.set(__self__, "hcatalog_linked_service_name", hcatalog_linked_service_name)
        if is_esp_enabled is not None:
            pulumi.set(__self__, "is_esp_enabled", is_esp_enabled)
        if linked_service_name is not None:
            pulumi.set(__self__, "linked_service_name", linked_service_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="clusterUri")
    def cluster_uri(self) -> Any:
        """
        HDInsight cluster URI. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "cluster_uri")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[Any]:
        """
        Specify the FileSystem if the main storage for the HDInsight is ADLS Gen2. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_system")

    @property
    @pulumi.getter(name="hcatalogLinkedServiceName")
    def hcatalog_linked_service_name(self) -> Optional['outputs.LinkedServiceReferenceResponse']:
        """
        A reference to the Azure SQL linked service that points to the HCatalog database.
        """
        return pulumi.get(self, "hcatalog_linked_service_name")

    @property
    @pulumi.getter(name="isEspEnabled")
    def is_esp_enabled(self) -> Optional[Any]:
        """
        Specify if the HDInsight is created with ESP (Enterprise Security Package). Type: Boolean.
        """
        return pulumi.get(self, "is_esp_enabled")

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> Optional['outputs.LinkedServiceReferenceResponse']:
        """
        The Azure Storage linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        HDInsight cluster password.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        HDInsight cluster user name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HDInsightOnDemandLinkedServiceResponse(dict):
    """
    HDInsight ondemand linked service.
    """
    def __init__(__self__, *,
                 cluster_resource_group: Any,
                 cluster_size: Any,
                 host_subscription_id: Any,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 tenant: Any,
                 time_to_live: Any,
                 type: str,
                 version: Any,
                 additional_linked_service_names: Optional[Sequence['outputs.LinkedServiceReferenceResponse']] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 cluster_name_prefix: Optional[Any] = None,
                 cluster_password: Optional[Any] = None,
                 cluster_ssh_password: Optional[Any] = None,
                 cluster_ssh_user_name: Optional[Any] = None,
                 cluster_type: Optional[Any] = None,
                 cluster_user_name: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 core_configuration: Optional[Any] = None,
                 data_node_size: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 h_base_configuration: Optional[Any] = None,
                 hcatalog_linked_service_name: Optional['outputs.LinkedServiceReferenceResponse'] = None,
                 hdfs_configuration: Optional[Any] = None,
                 head_node_size: Optional[Any] = None,
                 hive_configuration: Optional[Any] = None,
                 map_reduce_configuration: Optional[Any] = None,
                 oozie_configuration: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 script_actions: Optional[Sequence['outputs.ScriptActionResponse']] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[Any] = None,
                 spark_version: Optional[Any] = None,
                 storm_configuration: Optional[Any] = None,
                 subnet_name: Optional[Any] = None,
                 virtual_network_id: Optional[Any] = None,
                 yarn_configuration: Optional[Any] = None,
                 zookeeper_node_size: Optional[Any] = None):
        """
        HDInsight ondemand linked service.
        :param Any cluster_resource_group: The resource group where the cluster belongs. Type: string (or Expression with resultType string).
        :param Any cluster_size: Number of worker/data nodes in the cluster. Suggestion value: 4. Type: string (or Expression with resultType string).
        :param Any host_subscription_id: The customer’s subscription to host the cluster. Type: string (or Expression with resultType string).
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Azure Storage linked service to be used by the on-demand cluster for storing and processing data.
        :param Any tenant: The Tenant id/name to which the service principal belongs. Type: string (or Expression with resultType string).
        :param Any time_to_live: The allowed idle time for the on-demand HDInsight cluster. Specifies how long the on-demand HDInsight cluster stays alive after completion of an activity run if there are no other active jobs in the cluster. The minimum value is 5 mins. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Any version: Version of the HDInsight cluster.  Type: string (or Expression with resultType string).
        :param Sequence['LinkedServiceReferenceResponseArgs'] additional_linked_service_names: Specifies additional storage accounts for the HDInsight linked service so that the Data Factory service can register them on your behalf.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any cluster_name_prefix: The prefix of cluster name, postfix will be distinct with timestamp. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] cluster_password: The password to access the cluster.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] cluster_ssh_password: The password to SSH remotely connect cluster’s node (for Linux).
        :param Any cluster_ssh_user_name: The username to SSH remotely connect to cluster’s node (for Linux). Type: string (or Expression with resultType string).
        :param Any cluster_type: The cluster type. Type: string (or Expression with resultType string).
        :param Any cluster_user_name: The username to access the cluster. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any core_configuration: Specifies the core configuration parameters (as in core-site.xml) for the HDInsight cluster to be created.
        :param Any data_node_size: Specifies the size of the data node for the HDInsight cluster.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any h_base_configuration: Specifies the HBase configuration parameters (hbase-site.xml) for the HDInsight cluster.
        :param 'LinkedServiceReferenceResponseArgs' hcatalog_linked_service_name: The name of Azure SQL linked service that point to the HCatalog database. The on-demand HDInsight cluster is created by using the Azure SQL database as the metastore.
        :param Any hdfs_configuration: Specifies the HDFS configuration parameters (hdfs-site.xml) for the HDInsight cluster.
        :param Any head_node_size: Specifies the size of the head node for the HDInsight cluster.
        :param Any hive_configuration: Specifies the hive configuration parameters (hive-site.xml) for the HDInsight cluster.
        :param Any map_reduce_configuration: Specifies the MapReduce configuration parameters (mapred-site.xml) for the HDInsight cluster.
        :param Any oozie_configuration: Specifies the Oozie configuration parameters (oozie-site.xml) for the HDInsight cluster.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Sequence['ScriptActionResponseArgs'] script_actions: Custom script actions to run on HDI ondemand cluster once it's up. Please refer to https://docs.microsoft.com/en-us/azure/hdinsight/hdinsight-hadoop-customize-cluster-linux?toc=%2Fen-us%2Fazure%2Fhdinsight%2Fr-server%2FTOC.json&bc=%2Fen-us%2Fazure%2Fbread%2Ftoc.json#understanding-script-actions.
        :param Any service_principal_id: The service principal id for the hostSubscriptionId. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] service_principal_key: The key for the service principal id.
        :param Any spark_version: The version of spark if the cluster type is 'spark'. Type: string (or Expression with resultType string).
        :param Any storm_configuration: Specifies the Storm configuration parameters (storm-site.xml) for the HDInsight cluster.
        :param Any subnet_name: The ARM resource ID for the subnet in the vNet. If virtualNetworkId was specified, then this property is required. Type: string (or Expression with resultType string).
        :param Any virtual_network_id: The ARM resource ID for the vNet to which the cluster should be joined after creation. Type: string (or Expression with resultType string).
        :param Any yarn_configuration: Specifies the Yarn configuration parameters (yarn-site.xml) for the HDInsight cluster.
        :param Any zookeeper_node_size: Specifies the size of the Zoo Keeper node for the HDInsight cluster.
        """
        pulumi.set(__self__, "cluster_resource_group", cluster_resource_group)
        pulumi.set(__self__, "cluster_size", cluster_size)
        pulumi.set(__self__, "host_subscription_id", host_subscription_id)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "tenant", tenant)
        pulumi.set(__self__, "time_to_live", time_to_live)
        pulumi.set(__self__, "type", 'HDInsightOnDemand')
        pulumi.set(__self__, "version", version)
        if additional_linked_service_names is not None:
            pulumi.set(__self__, "additional_linked_service_names", additional_linked_service_names)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cluster_name_prefix is not None:
            pulumi.set(__self__, "cluster_name_prefix", cluster_name_prefix)
        if cluster_password is not None:
            pulumi.set(__self__, "cluster_password", cluster_password)
        if cluster_ssh_password is not None:
            pulumi.set(__self__, "cluster_ssh_password", cluster_ssh_password)
        if cluster_ssh_user_name is not None:
            pulumi.set(__self__, "cluster_ssh_user_name", cluster_ssh_user_name)
        if cluster_type is not None:
            pulumi.set(__self__, "cluster_type", cluster_type)
        if cluster_user_name is not None:
            pulumi.set(__self__, "cluster_user_name", cluster_user_name)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if core_configuration is not None:
            pulumi.set(__self__, "core_configuration", core_configuration)
        if data_node_size is not None:
            pulumi.set(__self__, "data_node_size", data_node_size)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if h_base_configuration is not None:
            pulumi.set(__self__, "h_base_configuration", h_base_configuration)
        if hcatalog_linked_service_name is not None:
            pulumi.set(__self__, "hcatalog_linked_service_name", hcatalog_linked_service_name)
        if hdfs_configuration is not None:
            pulumi.set(__self__, "hdfs_configuration", hdfs_configuration)
        if head_node_size is not None:
            pulumi.set(__self__, "head_node_size", head_node_size)
        if hive_configuration is not None:
            pulumi.set(__self__, "hive_configuration", hive_configuration)
        if map_reduce_configuration is not None:
            pulumi.set(__self__, "map_reduce_configuration", map_reduce_configuration)
        if oozie_configuration is not None:
            pulumi.set(__self__, "oozie_configuration", oozie_configuration)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if script_actions is not None:
            pulumi.set(__self__, "script_actions", script_actions)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if spark_version is not None:
            pulumi.set(__self__, "spark_version", spark_version)
        if storm_configuration is not None:
            pulumi.set(__self__, "storm_configuration", storm_configuration)
        if subnet_name is not None:
            pulumi.set(__self__, "subnet_name", subnet_name)
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)
        if yarn_configuration is not None:
            pulumi.set(__self__, "yarn_configuration", yarn_configuration)
        if zookeeper_node_size is not None:
            pulumi.set(__self__, "zookeeper_node_size", zookeeper_node_size)

    @property
    @pulumi.getter(name="clusterResourceGroup")
    def cluster_resource_group(self) -> Any:
        """
        The resource group where the cluster belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "cluster_resource_group")

    @property
    @pulumi.getter(name="clusterSize")
    def cluster_size(self) -> Any:
        """
        Number of worker/data nodes in the cluster. Suggestion value: 4. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "cluster_size")

    @property
    @pulumi.getter(name="hostSubscriptionId")
    def host_subscription_id(self) -> Any:
        """
        The customer’s subscription to host the cluster. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "host_subscription_id")

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Azure Storage linked service to be used by the on-demand cluster for storing and processing data.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def tenant(self) -> Any:
        """
        The Tenant id/name to which the service principal belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    @property
    @pulumi.getter(name="timeToLive")
    def time_to_live(self) -> Any:
        """
        The allowed idle time for the on-demand HDInsight cluster. Specifies how long the on-demand HDInsight cluster stays alive after completion of an activity run if there are no other active jobs in the cluster. The minimum value is 5 mins. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "time_to_live")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def version(self) -> Any:
        """
        Version of the HDInsight cluster.  Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="additionalLinkedServiceNames")
    def additional_linked_service_names(self) -> Optional[Sequence['outputs.LinkedServiceReferenceResponse']]:
        """
        Specifies additional storage accounts for the HDInsight linked service so that the Data Factory service can register them on your behalf.
        """
        return pulumi.get(self, "additional_linked_service_names")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="clusterNamePrefix")
    def cluster_name_prefix(self) -> Optional[Any]:
        """
        The prefix of cluster name, postfix will be distinct with timestamp. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "cluster_name_prefix")

    @property
    @pulumi.getter(name="clusterPassword")
    def cluster_password(self) -> Optional[Any]:
        """
        The password to access the cluster.
        """
        return pulumi.get(self, "cluster_password")

    @property
    @pulumi.getter(name="clusterSshPassword")
    def cluster_ssh_password(self) -> Optional[Any]:
        """
        The password to SSH remotely connect cluster’s node (for Linux).
        """
        return pulumi.get(self, "cluster_ssh_password")

    @property
    @pulumi.getter(name="clusterSshUserName")
    def cluster_ssh_user_name(self) -> Optional[Any]:
        """
        The username to SSH remotely connect to cluster’s node (for Linux). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "cluster_ssh_user_name")

    @property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> Optional[Any]:
        """
        The cluster type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "cluster_type")

    @property
    @pulumi.getter(name="clusterUserName")
    def cluster_user_name(self) -> Optional[Any]:
        """
        The username to access the cluster. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "cluster_user_name")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="coreConfiguration")
    def core_configuration(self) -> Optional[Any]:
        """
        Specifies the core configuration parameters (as in core-site.xml) for the HDInsight cluster to be created.
        """
        return pulumi.get(self, "core_configuration")

    @property
    @pulumi.getter(name="dataNodeSize")
    def data_node_size(self) -> Optional[Any]:
        """
        Specifies the size of the data node for the HDInsight cluster.
        """
        return pulumi.get(self, "data_node_size")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter(name="hBaseConfiguration")
    def h_base_configuration(self) -> Optional[Any]:
        """
        Specifies the HBase configuration parameters (hbase-site.xml) for the HDInsight cluster.
        """
        return pulumi.get(self, "h_base_configuration")

    @property
    @pulumi.getter(name="hcatalogLinkedServiceName")
    def hcatalog_linked_service_name(self) -> Optional['outputs.LinkedServiceReferenceResponse']:
        """
        The name of Azure SQL linked service that point to the HCatalog database. The on-demand HDInsight cluster is created by using the Azure SQL database as the metastore.
        """
        return pulumi.get(self, "hcatalog_linked_service_name")

    @property
    @pulumi.getter(name="hdfsConfiguration")
    def hdfs_configuration(self) -> Optional[Any]:
        """
        Specifies the HDFS configuration parameters (hdfs-site.xml) for the HDInsight cluster.
        """
        return pulumi.get(self, "hdfs_configuration")

    @property
    @pulumi.getter(name="headNodeSize")
    def head_node_size(self) -> Optional[Any]:
        """
        Specifies the size of the head node for the HDInsight cluster.
        """
        return pulumi.get(self, "head_node_size")

    @property
    @pulumi.getter(name="hiveConfiguration")
    def hive_configuration(self) -> Optional[Any]:
        """
        Specifies the hive configuration parameters (hive-site.xml) for the HDInsight cluster.
        """
        return pulumi.get(self, "hive_configuration")

    @property
    @pulumi.getter(name="mapReduceConfiguration")
    def map_reduce_configuration(self) -> Optional[Any]:
        """
        Specifies the MapReduce configuration parameters (mapred-site.xml) for the HDInsight cluster.
        """
        return pulumi.get(self, "map_reduce_configuration")

    @property
    @pulumi.getter(name="oozieConfiguration")
    def oozie_configuration(self) -> Optional[Any]:
        """
        Specifies the Oozie configuration parameters (oozie-site.xml) for the HDInsight cluster.
        """
        return pulumi.get(self, "oozie_configuration")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="scriptActions")
    def script_actions(self) -> Optional[Sequence['outputs.ScriptActionResponse']]:
        """
        Custom script actions to run on HDI ondemand cluster once it's up. Please refer to https://docs.microsoft.com/en-us/azure/hdinsight/hdinsight-hadoop-customize-cluster-linux?toc=%2Fen-us%2Fazure%2Fhdinsight%2Fr-server%2FTOC.json&bc=%2Fen-us%2Fazure%2Fbread%2Ftoc.json#understanding-script-actions.
        """
        return pulumi.get(self, "script_actions")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The service principal id for the hostSubscriptionId. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[Any]:
        """
        The key for the service principal id.
        """
        return pulumi.get(self, "service_principal_key")

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> Optional[Any]:
        """
        The version of spark if the cluster type is 'spark'. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "spark_version")

    @property
    @pulumi.getter(name="stormConfiguration")
    def storm_configuration(self) -> Optional[Any]:
        """
        Specifies the Storm configuration parameters (storm-site.xml) for the HDInsight cluster.
        """
        return pulumi.get(self, "storm_configuration")

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> Optional[Any]:
        """
        The ARM resource ID for the subnet in the vNet. If virtualNetworkId was specified, then this property is required. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "subnet_name")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[Any]:
        """
        The ARM resource ID for the vNet to which the cluster should be joined after creation. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "virtual_network_id")

    @property
    @pulumi.getter(name="yarnConfiguration")
    def yarn_configuration(self) -> Optional[Any]:
        """
        Specifies the Yarn configuration parameters (yarn-site.xml) for the HDInsight cluster.
        """
        return pulumi.get(self, "yarn_configuration")

    @property
    @pulumi.getter(name="zookeeperNodeSize")
    def zookeeper_node_size(self) -> Optional[Any]:
        """
        Specifies the size of the Zoo Keeper node for the HDInsight cluster.
        """
        return pulumi.get(self, "zookeeper_node_size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HdfsLinkedServiceResponse(dict):
    """
    Hadoop Distributed File System (HDFS) linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 url: Any,
                 annotations: Optional[Sequence[Any]] = None,
                 authentication_type: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        Hadoop Distributed File System (HDFS) linked service.
        :param str type: Type of linked service.
        :param Any url: The URL of the HDFS service endpoint, e.g. http://myhostname:50070/webhdfs/v1 . Type: string (or Expression with resultType string).
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any authentication_type: Type of authentication used to connect to the HDFS. Possible values are: Anonymous and Windows. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password for Windows authentication.
        :param Any user_name: User name for Windows authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'Hdfs')
        pulumi.set(__self__, "url", url)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        The URL of the HDFS service endpoint, e.g. http://myhostname:50070/webhdfs/v1 . Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[Any]:
        """
        Type of authentication used to connect to the HDFS. Possible values are: Anonymous and Windows. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password for Windows authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        User name for Windows authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HdfsLocationResponse(dict):
    """
    The location of HDFS.
    """
    def __init__(__self__, *,
                 type: str,
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None):
        """
        The location of HDFS.
        :param str type: Type of dataset storage location.
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        pulumi.set(__self__, "type", 'HdfsLocation')
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset storage location.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HiveLinkedServiceResponse(dict):
    """
    Hive Server linked service.
    """
    def __init__(__self__, *,
                 authentication_type: str,
                 host: Any,
                 type: str,
                 allow_host_name_cn_mismatch: Optional[Any] = None,
                 allow_self_signed_server_cert: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 enable_ssl: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 http_path: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 port: Optional[Any] = None,
                 server_type: Optional[str] = None,
                 service_discovery_mode: Optional[Any] = None,
                 thrift_transport_protocol: Optional[str] = None,
                 trusted_cert_path: Optional[Any] = None,
                 use_native_query: Optional[Any] = None,
                 use_system_trust_store: Optional[Any] = None,
                 username: Optional[Any] = None,
                 zoo_keeper_name_space: Optional[Any] = None):
        """
        Hive Server linked service.
        :param str authentication_type: The authentication method used to access the Hive server.
        :param Any host: IP address or host name of the Hive server, separated by ';' for multiple hosts (only when serviceDiscoveryMode is enable).
        :param str type: Type of linked service.
        :param Any allow_host_name_cn_mismatch: Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        :param Any allow_self_signed_server_cert: Specifies whether to allow self-signed certificates from the server. The default value is false.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any enable_ssl: Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any http_path: The partial URL corresponding to the Hive server.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: The password corresponding to the user name that you provided in the Username field
        :param Any port: The TCP port that the Hive server uses to listen for client connections.
        :param str server_type: The type of Hive server.
        :param Any service_discovery_mode: true to indicate using the ZooKeeper service, false not.
        :param str thrift_transport_protocol: The transport protocol to use in the Thrift layer.
        :param Any trusted_cert_path: The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        :param Any use_native_query: Specifies whether the driver uses native HiveQL queries,or converts them into an equivalent form in HiveQL.
        :param Any use_system_trust_store: Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        :param Any username: The user name that you use to access Hive Server.
        :param Any zoo_keeper_name_space: The namespace on ZooKeeper under which Hive Server 2 nodes are added.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'Hive')
        if allow_host_name_cn_mismatch is not None:
            pulumi.set(__self__, "allow_host_name_cn_mismatch", allow_host_name_cn_mismatch)
        if allow_self_signed_server_cert is not None:
            pulumi.set(__self__, "allow_self_signed_server_cert", allow_self_signed_server_cert)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_ssl is not None:
            pulumi.set(__self__, "enable_ssl", enable_ssl)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if http_path is not None:
            pulumi.set(__self__, "http_path", http_path)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if server_type is not None:
            pulumi.set(__self__, "server_type", server_type)
        if service_discovery_mode is not None:
            pulumi.set(__self__, "service_discovery_mode", service_discovery_mode)
        if thrift_transport_protocol is not None:
            pulumi.set(__self__, "thrift_transport_protocol", thrift_transport_protocol)
        if trusted_cert_path is not None:
            pulumi.set(__self__, "trusted_cert_path", trusted_cert_path)
        if use_native_query is not None:
            pulumi.set(__self__, "use_native_query", use_native_query)
        if use_system_trust_store is not None:
            pulumi.set(__self__, "use_system_trust_store", use_system_trust_store)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if zoo_keeper_name_space is not None:
            pulumi.set(__self__, "zoo_keeper_name_space", zoo_keeper_name_space)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        The authentication method used to access the Hive server.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        IP address or host name of the Hive server, separated by ';' for multiple hosts (only when serviceDiscoveryMode is enable).
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="allowHostNameCNMismatch")
    def allow_host_name_cn_mismatch(self) -> Optional[Any]:
        """
        Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        """
        return pulumi.get(self, "allow_host_name_cn_mismatch")

    @property
    @pulumi.getter(name="allowSelfSignedServerCert")
    def allow_self_signed_server_cert(self) -> Optional[Any]:
        """
        Specifies whether to allow self-signed certificates from the server. The default value is false.
        """
        return pulumi.get(self, "allow_self_signed_server_cert")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="enableSsl")
    def enable_ssl(self) -> Optional[Any]:
        """
        Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        """
        return pulumi.get(self, "enable_ssl")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter(name="httpPath")
    def http_path(self) -> Optional[Any]:
        """
        The partial URL corresponding to the Hive server.
        """
        return pulumi.get(self, "http_path")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        The password corresponding to the user name that you provided in the Username field
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The TCP port that the Hive server uses to listen for client connections.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> Optional[str]:
        """
        The type of Hive server.
        """
        return pulumi.get(self, "server_type")

    @property
    @pulumi.getter(name="serviceDiscoveryMode")
    def service_discovery_mode(self) -> Optional[Any]:
        """
        true to indicate using the ZooKeeper service, false not.
        """
        return pulumi.get(self, "service_discovery_mode")

    @property
    @pulumi.getter(name="thriftTransportProtocol")
    def thrift_transport_protocol(self) -> Optional[str]:
        """
        The transport protocol to use in the Thrift layer.
        """
        return pulumi.get(self, "thrift_transport_protocol")

    @property
    @pulumi.getter(name="trustedCertPath")
    def trusted_cert_path(self) -> Optional[Any]:
        """
        The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        """
        return pulumi.get(self, "trusted_cert_path")

    @property
    @pulumi.getter(name="useNativeQuery")
    def use_native_query(self) -> Optional[Any]:
        """
        Specifies whether the driver uses native HiveQL queries,or converts them into an equivalent form in HiveQL.
        """
        return pulumi.get(self, "use_native_query")

    @property
    @pulumi.getter(name="useSystemTrustStore")
    def use_system_trust_store(self) -> Optional[Any]:
        """
        Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        """
        return pulumi.get(self, "use_system_trust_store")

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The user name that you use to access Hive Server.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="zooKeeperNameSpace")
    def zoo_keeper_name_space(self) -> Optional[Any]:
        """
        The namespace on ZooKeeper under which Hive Server 2 nodes are added.
        """
        return pulumi.get(self, "zoo_keeper_name_space")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HiveObjectDatasetResponse(dict):
    """
    Hive Server dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Hive Server dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Hive. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'HiveObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Hive. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HttpDatasetResponse(dict):
    """
    A file in an HTTP web server.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 additional_headers: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 compression: Optional[Any] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 format: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 relative_url: Optional[Any] = None,
                 request_body: Optional[Any] = None,
                 request_method: Optional[Any] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        A file in an HTTP web server.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Any additional_headers: The headers for the HTTP Request. e.g. request-header-name-1:request-header-value-1
               ...
               request-header-name-n:request-header-value-n Type: string (or Expression with resultType string).
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param Union['DatasetBZip2CompressionResponseArgs', 'DatasetDeflateCompressionResponseArgs', 'DatasetGZipCompressionResponseArgs', 'DatasetTarCompressionResponseArgs', 'DatasetTarGZipCompressionResponseArgs', 'DatasetZipDeflateCompressionResponseArgs'] compression: The data compression method used on files.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Union['AvroFormatResponseArgs', 'JsonFormatResponseArgs', 'OrcFormatResponseArgs', 'ParquetFormatResponseArgs', 'TextFormatResponseArgs'] format: The format of files.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any relative_url: The relative URL based on the URL in the HttpLinkedService refers to an HTTP file Type: string (or Expression with resultType string).
        :param Any request_body: The body for the HTTP request. Type: string (or Expression with resultType string).
        :param Any request_method: The HTTP method for the HTTP request. Type: string (or Expression with resultType string).
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'HttpFile')
        if additional_headers is not None:
            pulumi.set(__self__, "additional_headers", additional_headers)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if relative_url is not None:
            pulumi.set(__self__, "relative_url", relative_url)
        if request_body is not None:
            pulumi.set(__self__, "request_body", request_body)
        if request_method is not None:
            pulumi.set(__self__, "request_method", request_method)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="additionalHeaders")
    def additional_headers(self) -> Optional[Any]:
        """
        The headers for the HTTP Request. e.g. request-header-name-1:request-header-value-1
        ...
        request-header-name-n:request-header-value-n Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "additional_headers")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def compression(self) -> Optional[Any]:
        """
        The data compression method used on files.
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def format(self) -> Optional[Any]:
        """
        The format of files.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="relativeUrl")
    def relative_url(self) -> Optional[Any]:
        """
        The relative URL based on the URL in the HttpLinkedService refers to an HTTP file Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "relative_url")

    @property
    @pulumi.getter(name="requestBody")
    def request_body(self) -> Optional[Any]:
        """
        The body for the HTTP request. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "request_body")

    @property
    @pulumi.getter(name="requestMethod")
    def request_method(self) -> Optional[Any]:
        """
        The HTTP method for the HTTP request. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "request_method")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HttpLinkedServiceResponse(dict):
    """
    Linked service for an HTTP source.
    """
    def __init__(__self__, *,
                 type: str,
                 url: Any,
                 annotations: Optional[Sequence[Any]] = None,
                 authentication_type: Optional[str] = None,
                 cert_thumbprint: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 embedded_cert_data: Optional[Any] = None,
                 enable_server_certificate_validation: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        Linked service for an HTTP source.
        :param str type: Type of linked service.
        :param Any url: The base URL of the HTTP endpoint, e.g. http://www.microsoft.com. Type: string (or Expression with resultType string).
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param str authentication_type: The authentication type to be used to connect to the HTTP server.
        :param Any cert_thumbprint: Thumbprint of certificate for ClientCertificate authentication. Only valid for on-premises copy. For on-premises copy with ClientCertificate authentication, either CertThumbprint or EmbeddedCertData/Password should be specified. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any embedded_cert_data: Base64 encoded certificate data for ClientCertificate authentication. For on-premises copy with ClientCertificate authentication, either CertThumbprint or EmbeddedCertData/Password should be specified. Type: string (or Expression with resultType string).
        :param Any enable_server_certificate_validation: If true, validate the HTTPS server SSL certificate. Default value is true. Type: boolean (or Expression with resultType boolean).
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password for Basic, Digest, Windows, or ClientCertificate with EmbeddedCertData authentication.
        :param Any user_name: User name for Basic, Digest, or Windows authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'HttpServer')
        pulumi.set(__self__, "url", url)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if cert_thumbprint is not None:
            pulumi.set(__self__, "cert_thumbprint", cert_thumbprint)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if embedded_cert_data is not None:
            pulumi.set(__self__, "embedded_cert_data", embedded_cert_data)
        if enable_server_certificate_validation is not None:
            pulumi.set(__self__, "enable_server_certificate_validation", enable_server_certificate_validation)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        The base URL of the HTTP endpoint, e.g. http://www.microsoft.com. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[str]:
        """
        The authentication type to be used to connect to the HTTP server.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="certThumbprint")
    def cert_thumbprint(self) -> Optional[Any]:
        """
        Thumbprint of certificate for ClientCertificate authentication. Only valid for on-premises copy. For on-premises copy with ClientCertificate authentication, either CertThumbprint or EmbeddedCertData/Password should be specified. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "cert_thumbprint")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="embeddedCertData")
    def embedded_cert_data(self) -> Optional[Any]:
        """
        Base64 encoded certificate data for ClientCertificate authentication. For on-premises copy with ClientCertificate authentication, either CertThumbprint or EmbeddedCertData/Password should be specified. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "embedded_cert_data")

    @property
    @pulumi.getter(name="enableServerCertificateValidation")
    def enable_server_certificate_validation(self) -> Optional[Any]:
        """
        If true, validate the HTTPS server SSL certificate. Default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "enable_server_certificate_validation")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password for Basic, Digest, Windows, or ClientCertificate with EmbeddedCertData authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        User name for Basic, Digest, or Windows authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HttpServerLocationResponse(dict):
    """
    The location of http server.
    """
    def __init__(__self__, *,
                 type: str,
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None,
                 relative_url: Optional[Any] = None):
        """
        The location of http server.
        :param str type: Type of dataset storage location.
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        :param Any relative_url: Specify the relativeUrl of http server. Type: string (or Expression with resultType string)
        """
        pulumi.set(__self__, "type", 'HttpServerLocation')
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if relative_url is not None:
            pulumi.set(__self__, "relative_url", relative_url)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset storage location.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    @property
    @pulumi.getter(name="relativeUrl")
    def relative_url(self) -> Optional[Any]:
        """
        Specify the relativeUrl of http server. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "relative_url")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HubspotLinkedServiceResponse(dict):
    """
    Hubspot Service linked service.
    """
    def __init__(__self__, *,
                 client_id: Any,
                 type: str,
                 access_token: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 client_secret: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 refresh_token: Optional[Any] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Hubspot Service linked service.
        :param Any client_id: The client ID associated with your Hubspot application.
        :param str type: Type of linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] access_token: The access token obtained when initially authenticating your OAuth integration.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] client_secret: The client secret associated with your Hubspot application.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] refresh_token: The refresh token obtained when initially authenticating your OAuth integration.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "type", 'Hubspot')
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Any:
        """
        The client ID associated with your Hubspot application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[Any]:
        """
        The access token obtained when initially authenticating your OAuth integration.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[Any]:
        """
        The client secret associated with your Hubspot application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[Any]:
        """
        The refresh token obtained when initially authenticating your OAuth integration.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HubspotObjectDatasetResponse(dict):
    """
    Hubspot Service dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Hubspot Service dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'HubspotObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ImpalaLinkedServiceResponse(dict):
    """
    Impala server linked service.
    """
    def __init__(__self__, *,
                 authentication_type: str,
                 host: Any,
                 type: str,
                 allow_host_name_cn_mismatch: Optional[Any] = None,
                 allow_self_signed_server_cert: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 enable_ssl: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 port: Optional[Any] = None,
                 trusted_cert_path: Optional[Any] = None,
                 use_system_trust_store: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Impala server linked service.
        :param str authentication_type: The authentication type to use.
        :param Any host: The IP address or host name of the Impala server. (i.e. 192.168.222.160)
        :param str type: Type of linked service.
        :param Any allow_host_name_cn_mismatch: Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        :param Any allow_self_signed_server_cert: Specifies whether to allow self-signed certificates from the server. The default value is false.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any enable_ssl: Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: The password corresponding to the user name when using UsernameAndPassword.
        :param Any port: The TCP port that the Impala server uses to listen for client connections. The default value is 21050.
        :param Any trusted_cert_path: The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        :param Any use_system_trust_store: Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        :param Any username: The user name used to access the Impala server. The default value is anonymous when using SASLUsername.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'Impala')
        if allow_host_name_cn_mismatch is not None:
            pulumi.set(__self__, "allow_host_name_cn_mismatch", allow_host_name_cn_mismatch)
        if allow_self_signed_server_cert is not None:
            pulumi.set(__self__, "allow_self_signed_server_cert", allow_self_signed_server_cert)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_ssl is not None:
            pulumi.set(__self__, "enable_ssl", enable_ssl)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if trusted_cert_path is not None:
            pulumi.set(__self__, "trusted_cert_path", trusted_cert_path)
        if use_system_trust_store is not None:
            pulumi.set(__self__, "use_system_trust_store", use_system_trust_store)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        The authentication type to use.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        The IP address or host name of the Impala server. (i.e. 192.168.222.160)
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="allowHostNameCNMismatch")
    def allow_host_name_cn_mismatch(self) -> Optional[Any]:
        """
        Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        """
        return pulumi.get(self, "allow_host_name_cn_mismatch")

    @property
    @pulumi.getter(name="allowSelfSignedServerCert")
    def allow_self_signed_server_cert(self) -> Optional[Any]:
        """
        Specifies whether to allow self-signed certificates from the server. The default value is false.
        """
        return pulumi.get(self, "allow_self_signed_server_cert")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="enableSsl")
    def enable_ssl(self) -> Optional[Any]:
        """
        Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        """
        return pulumi.get(self, "enable_ssl")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        The password corresponding to the user name when using UsernameAndPassword.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The TCP port that the Impala server uses to listen for client connections. The default value is 21050.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="trustedCertPath")
    def trusted_cert_path(self) -> Optional[Any]:
        """
        The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        """
        return pulumi.get(self, "trusted_cert_path")

    @property
    @pulumi.getter(name="useSystemTrustStore")
    def use_system_trust_store(self) -> Optional[Any]:
        """
        Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        """
        return pulumi.get(self, "use_system_trust_store")

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The user name used to access the Impala server. The default value is anonymous when using SASLUsername.
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ImpalaObjectDatasetResponse(dict):
    """
    Impala server dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Impala server dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Impala. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'ImpalaObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Impala. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InformixLinkedServiceResponse(dict):
    """
    Informix linked service.
    """
    def __init__(__self__, *,
                 connection_string: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 authentication_type: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 credential: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        Informix linked service.
        :param Any connection_string: The non-access credential portion of the connection string as well as an optional encrypted credential. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any authentication_type: Type of authentication used to connect to the Informix as ODBC data store. Possible values are: Anonymous and Basic. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] credential: The access credential portion of the connection string specified in driver-specific property-value format.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password for Basic authentication.
        :param Any user_name: User name for Basic authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'Informix')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The non-access credential portion of the connection string as well as an optional encrypted credential. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[Any]:
        """
        Type of authentication used to connect to the Informix as ODBC data store. Possible values are: Anonymous and Basic. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def credential(self) -> Optional[Any]:
        """
        The access credential portion of the connection string specified in driver-specific property-value format.
        """
        return pulumi.get(self, "credential")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password for Basic authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        User name for Basic authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class InformixTableDatasetResponse(dict):
    """
    The Informix table dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The Informix table dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The Informix table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'InformixTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The Informix table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationRuntimeComputePropertiesResponse(dict):
    """
    The compute resource properties for managed integration runtime.
    """
    def __init__(__self__, *,
                 data_flow_properties: Optional['outputs.IntegrationRuntimeDataFlowPropertiesResponse'] = None,
                 location: Optional[str] = None,
                 max_parallel_executions_per_node: Optional[int] = None,
                 node_size: Optional[str] = None,
                 number_of_nodes: Optional[int] = None,
                 v_net_properties: Optional['outputs.IntegrationRuntimeVNetPropertiesResponse'] = None):
        """
        The compute resource properties for managed integration runtime.
        :param 'IntegrationRuntimeDataFlowPropertiesResponseArgs' data_flow_properties: Data flow properties for managed integration runtime.
        :param str location: The location for managed integration runtime. The supported regions could be found on https://docs.microsoft.com/en-us/azure/data-factory/data-factory-data-movement-activities
        :param int max_parallel_executions_per_node: Maximum parallel executions count per node for managed integration runtime.
        :param str node_size: The node size requirement to managed integration runtime.
        :param int number_of_nodes: The required number of nodes for managed integration runtime.
        :param 'IntegrationRuntimeVNetPropertiesResponseArgs' v_net_properties: VNet properties for managed integration runtime.
        """
        if data_flow_properties is not None:
            pulumi.set(__self__, "data_flow_properties", data_flow_properties)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if max_parallel_executions_per_node is not None:
            pulumi.set(__self__, "max_parallel_executions_per_node", max_parallel_executions_per_node)
        if node_size is not None:
            pulumi.set(__self__, "node_size", node_size)
        if number_of_nodes is not None:
            pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        if v_net_properties is not None:
            pulumi.set(__self__, "v_net_properties", v_net_properties)

    @property
    @pulumi.getter(name="dataFlowProperties")
    def data_flow_properties(self) -> Optional['outputs.IntegrationRuntimeDataFlowPropertiesResponse']:
        """
        Data flow properties for managed integration runtime.
        """
        return pulumi.get(self, "data_flow_properties")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        The location for managed integration runtime. The supported regions could be found on https://docs.microsoft.com/en-us/azure/data-factory/data-factory-data-movement-activities
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="maxParallelExecutionsPerNode")
    def max_parallel_executions_per_node(self) -> Optional[int]:
        """
        Maximum parallel executions count per node for managed integration runtime.
        """
        return pulumi.get(self, "max_parallel_executions_per_node")

    @property
    @pulumi.getter(name="nodeSize")
    def node_size(self) -> Optional[str]:
        """
        The node size requirement to managed integration runtime.
        """
        return pulumi.get(self, "node_size")

    @property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> Optional[int]:
        """
        The required number of nodes for managed integration runtime.
        """
        return pulumi.get(self, "number_of_nodes")

    @property
    @pulumi.getter(name="vNetProperties")
    def v_net_properties(self) -> Optional['outputs.IntegrationRuntimeVNetPropertiesResponse']:
        """
        VNet properties for managed integration runtime.
        """
        return pulumi.get(self, "v_net_properties")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationRuntimeCustomSetupScriptPropertiesResponse(dict):
    """
    Custom setup script properties for a managed dedicated integration runtime.
    """
    def __init__(__self__, *,
                 blob_container_uri: Optional[str] = None,
                 sas_token: Optional['outputs.SecureStringResponse'] = None):
        """
        Custom setup script properties for a managed dedicated integration runtime.
        :param str blob_container_uri: The URI of the Azure blob container that contains the custom setup script.
        :param 'SecureStringResponseArgs' sas_token: The SAS token of the Azure blob container.
        """
        if blob_container_uri is not None:
            pulumi.set(__self__, "blob_container_uri", blob_container_uri)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)

    @property
    @pulumi.getter(name="blobContainerUri")
    def blob_container_uri(self) -> Optional[str]:
        """
        The URI of the Azure blob container that contains the custom setup script.
        """
        return pulumi.get(self, "blob_container_uri")

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional['outputs.SecureStringResponse']:
        """
        The SAS token of the Azure blob container.
        """
        return pulumi.get(self, "sas_token")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationRuntimeDataFlowPropertiesResponse(dict):
    """
    Data flow properties for managed integration runtime.
    """
    def __init__(__self__, *,
                 compute_type: Optional[str] = None,
                 core_count: Optional[int] = None,
                 time_to_live: Optional[int] = None):
        """
        Data flow properties for managed integration runtime.
        :param str compute_type: Compute type of the cluster which will execute data flow job.
        :param int core_count: Core count of the cluster which will execute data flow job. Supported values are: 8, 16, 32, 48, 80, 144 and 272.
        :param int time_to_live: Time to live (in minutes) setting of the cluster which will execute data flow job.
        """
        if compute_type is not None:
            pulumi.set(__self__, "compute_type", compute_type)
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if time_to_live is not None:
            pulumi.set(__self__, "time_to_live", time_to_live)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> Optional[str]:
        """
        Compute type of the cluster which will execute data flow job.
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[int]:
        """
        Core count of the cluster which will execute data flow job. Supported values are: 8, 16, 32, 48, 80, 144 and 272.
        """
        return pulumi.get(self, "core_count")

    @property
    @pulumi.getter(name="timeToLive")
    def time_to_live(self) -> Optional[int]:
        """
        Time to live (in minutes) setting of the cluster which will execute data flow job.
        """
        return pulumi.get(self, "time_to_live")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationRuntimeDataProxyPropertiesResponse(dict):
    """
    Data proxy properties for a managed dedicated integration runtime.
    """
    def __init__(__self__, *,
                 connect_via: Optional['outputs.EntityReferenceResponse'] = None,
                 path: Optional[str] = None,
                 staging_linked_service: Optional['outputs.EntityReferenceResponse'] = None):
        """
        Data proxy properties for a managed dedicated integration runtime.
        :param 'EntityReferenceResponseArgs' connect_via: The self-hosted integration runtime reference.
        :param str path: The path to contain the staged data in the Blob storage.
        :param 'EntityReferenceResponseArgs' staging_linked_service: The staging linked service reference.
        """
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if staging_linked_service is not None:
            pulumi.set(__self__, "staging_linked_service", staging_linked_service)

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.EntityReferenceResponse']:
        """
        The self-hosted integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to contain the staged data in the Blob storage.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="stagingLinkedService")
    def staging_linked_service(self) -> Optional['outputs.EntityReferenceResponse']:
        """
        The staging linked service reference.
        """
        return pulumi.get(self, "staging_linked_service")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationRuntimeReferenceResponse(dict):
    """
    Integration runtime reference type.
    """
    def __init__(__self__, *,
                 reference_name: str,
                 type: str,
                 parameters: Optional[Mapping[str, Any]] = None):
        """
        Integration runtime reference type.
        :param str reference_name: Reference integration runtime name.
        :param str type: Type of integration runtime.
        :param Mapping[str, Any] parameters: Arguments for integration runtime.
        """
        pulumi.set(__self__, "reference_name", reference_name)
        pulumi.set(__self__, "type", type)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> str:
        """
        Reference integration runtime name.
        """
        return pulumi.get(self, "reference_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of integration runtime.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, Any]]:
        """
        Arguments for integration runtime.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationRuntimeSsisCatalogInfoResponse(dict):
    """
    Catalog information for managed dedicated integration runtime.
    """
    def __init__(__self__, *,
                 catalog_admin_password: Optional['outputs.SecureStringResponse'] = None,
                 catalog_admin_user_name: Optional[str] = None,
                 catalog_pricing_tier: Optional[str] = None,
                 catalog_server_endpoint: Optional[str] = None):
        """
        Catalog information for managed dedicated integration runtime.
        :param 'SecureStringResponseArgs' catalog_admin_password: The password of the administrator user account of the catalog database.
        :param str catalog_admin_user_name: The administrator user name of catalog database.
        :param str catalog_pricing_tier: The pricing tier for the catalog database. The valid values could be found in https://azure.microsoft.com/en-us/pricing/details/sql-database/
        :param str catalog_server_endpoint: The catalog database server URL.
        """
        if catalog_admin_password is not None:
            pulumi.set(__self__, "catalog_admin_password", catalog_admin_password)
        if catalog_admin_user_name is not None:
            pulumi.set(__self__, "catalog_admin_user_name", catalog_admin_user_name)
        if catalog_pricing_tier is not None:
            pulumi.set(__self__, "catalog_pricing_tier", catalog_pricing_tier)
        if catalog_server_endpoint is not None:
            pulumi.set(__self__, "catalog_server_endpoint", catalog_server_endpoint)

    @property
    @pulumi.getter(name="catalogAdminPassword")
    def catalog_admin_password(self) -> Optional['outputs.SecureStringResponse']:
        """
        The password of the administrator user account of the catalog database.
        """
        return pulumi.get(self, "catalog_admin_password")

    @property
    @pulumi.getter(name="catalogAdminUserName")
    def catalog_admin_user_name(self) -> Optional[str]:
        """
        The administrator user name of catalog database.
        """
        return pulumi.get(self, "catalog_admin_user_name")

    @property
    @pulumi.getter(name="catalogPricingTier")
    def catalog_pricing_tier(self) -> Optional[str]:
        """
        The pricing tier for the catalog database. The valid values could be found in https://azure.microsoft.com/en-us/pricing/details/sql-database/
        """
        return pulumi.get(self, "catalog_pricing_tier")

    @property
    @pulumi.getter(name="catalogServerEndpoint")
    def catalog_server_endpoint(self) -> Optional[str]:
        """
        The catalog database server URL.
        """
        return pulumi.get(self, "catalog_server_endpoint")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationRuntimeSsisPropertiesResponse(dict):
    """
    SSIS properties for managed integration runtime.
    """
    def __init__(__self__, *,
                 catalog_info: Optional['outputs.IntegrationRuntimeSsisCatalogInfoResponse'] = None,
                 custom_setup_script_properties: Optional['outputs.IntegrationRuntimeCustomSetupScriptPropertiesResponse'] = None,
                 data_proxy_properties: Optional['outputs.IntegrationRuntimeDataProxyPropertiesResponse'] = None,
                 edition: Optional[str] = None,
                 express_custom_setup_properties: Optional[Sequence[Any]] = None,
                 license_type: Optional[str] = None,
                 package_stores: Optional[Sequence['outputs.PackageStoreResponse']] = None):
        """
        SSIS properties for managed integration runtime.
        :param 'IntegrationRuntimeSsisCatalogInfoResponseArgs' catalog_info: Catalog information for managed dedicated integration runtime.
        :param 'IntegrationRuntimeCustomSetupScriptPropertiesResponseArgs' custom_setup_script_properties: Custom setup script properties for a managed dedicated integration runtime.
        :param 'IntegrationRuntimeDataProxyPropertiesResponseArgs' data_proxy_properties: Data proxy properties for a managed dedicated integration runtime.
        :param str edition: The edition for the SSIS Integration Runtime
        :param Sequence[Union['AzPowerShellSetupResponseArgs', 'CmdkeySetupResponseArgs', 'ComponentSetupResponseArgs', 'EnvironmentVariableSetupResponseArgs']] express_custom_setup_properties: Custom setup without script properties for a SSIS integration runtime.
        :param str license_type: License type for bringing your own license scenario.
        :param Sequence['PackageStoreResponseArgs'] package_stores: Package stores for the SSIS Integration Runtime.
        """
        if catalog_info is not None:
            pulumi.set(__self__, "catalog_info", catalog_info)
        if custom_setup_script_properties is not None:
            pulumi.set(__self__, "custom_setup_script_properties", custom_setup_script_properties)
        if data_proxy_properties is not None:
            pulumi.set(__self__, "data_proxy_properties", data_proxy_properties)
        if edition is not None:
            pulumi.set(__self__, "edition", edition)
        if express_custom_setup_properties is not None:
            pulumi.set(__self__, "express_custom_setup_properties", express_custom_setup_properties)
        if license_type is not None:
            pulumi.set(__self__, "license_type", license_type)
        if package_stores is not None:
            pulumi.set(__self__, "package_stores", package_stores)

    @property
    @pulumi.getter(name="catalogInfo")
    def catalog_info(self) -> Optional['outputs.IntegrationRuntimeSsisCatalogInfoResponse']:
        """
        Catalog information for managed dedicated integration runtime.
        """
        return pulumi.get(self, "catalog_info")

    @property
    @pulumi.getter(name="customSetupScriptProperties")
    def custom_setup_script_properties(self) -> Optional['outputs.IntegrationRuntimeCustomSetupScriptPropertiesResponse']:
        """
        Custom setup script properties for a managed dedicated integration runtime.
        """
        return pulumi.get(self, "custom_setup_script_properties")

    @property
    @pulumi.getter(name="dataProxyProperties")
    def data_proxy_properties(self) -> Optional['outputs.IntegrationRuntimeDataProxyPropertiesResponse']:
        """
        Data proxy properties for a managed dedicated integration runtime.
        """
        return pulumi.get(self, "data_proxy_properties")

    @property
    @pulumi.getter
    def edition(self) -> Optional[str]:
        """
        The edition for the SSIS Integration Runtime
        """
        return pulumi.get(self, "edition")

    @property
    @pulumi.getter(name="expressCustomSetupProperties")
    def express_custom_setup_properties(self) -> Optional[Sequence[Any]]:
        """
        Custom setup without script properties for a SSIS integration runtime.
        """
        return pulumi.get(self, "express_custom_setup_properties")

    @property
    @pulumi.getter(name="licenseType")
    def license_type(self) -> Optional[str]:
        """
        License type for bringing your own license scenario.
        """
        return pulumi.get(self, "license_type")

    @property
    @pulumi.getter(name="packageStores")
    def package_stores(self) -> Optional[Sequence['outputs.PackageStoreResponse']]:
        """
        Package stores for the SSIS Integration Runtime.
        """
        return pulumi.get(self, "package_stores")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IntegrationRuntimeVNetPropertiesResponse(dict):
    """
    VNet properties for managed integration runtime.
    """
    def __init__(__self__, *,
                 public_ips: Optional[Sequence[str]] = None,
                 subnet: Optional[str] = None,
                 v_net_id: Optional[str] = None):
        """
        VNet properties for managed integration runtime.
        :param Sequence[str] public_ips: Resource IDs of the public IP addresses that this integration runtime will use.
        :param str subnet: The name of the subnet this integration runtime will join.
        :param str v_net_id: The ID of the VNet that this integration runtime will join.
        """
        if public_ips is not None:
            pulumi.set(__self__, "public_ips", public_ips)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if v_net_id is not None:
            pulumi.set(__self__, "v_net_id", v_net_id)

    @property
    @pulumi.getter(name="publicIPs")
    def public_ips(self) -> Optional[Sequence[str]]:
        """
        Resource IDs of the public IP addresses that this integration runtime will use.
        """
        return pulumi.get(self, "public_ips")

    @property
    @pulumi.getter
    def subnet(self) -> Optional[str]:
        """
        The name of the subnet this integration runtime will join.
        """
        return pulumi.get(self, "subnet")

    @property
    @pulumi.getter(name="vNetId")
    def v_net_id(self) -> Optional[str]:
        """
        The ID of the VNet that this integration runtime will join.
        """
        return pulumi.get(self, "v_net_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class JiraLinkedServiceResponse(dict):
    """
    Jira Service linked service.
    """
    def __init__(__self__, *,
                 host: Any,
                 type: str,
                 username: Any,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 port: Optional[Any] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Jira Service linked service.
        :param Any host: The IP address or host name of the Jira service. (e.g. jira.example.com)
        :param str type: Type of linked service.
        :param Any username: The user name that you use to access Jira Service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: The password corresponding to the user name that you provided in the username field.
        :param Any port: The TCP port that the Jira server uses to listen for client connections. The default value is 443 if connecting through HTTPS, or 8080 if connecting through HTTP.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'Jira')
        pulumi.set(__self__, "username", username)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        The IP address or host name of the Jira service. (e.g. jira.example.com)
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def username(self) -> Any:
        """
        The user name that you use to access Jira Service.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        The password corresponding to the user name that you provided in the username field.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The TCP port that the Jira server uses to listen for client connections. The default value is 443 if connecting through HTTPS, or 8080 if connecting through HTTP.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class JiraObjectDatasetResponse(dict):
    """
    Jira Service dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Jira Service dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'JiraObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class JsonDatasetResponse(dict):
    """
    Json dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 location: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 compression: Optional[Any] = None,
                 description: Optional[str] = None,
                 encoding_name: Optional[Any] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Json dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param Union['AmazonS3LocationResponseArgs', 'AzureBlobFSLocationResponseArgs', 'AzureBlobStorageLocationResponseArgs', 'AzureDataLakeStoreLocationResponseArgs', 'AzureFileStorageLocationResponseArgs', 'FileServerLocationResponseArgs', 'FtpServerLocationResponseArgs', 'GoogleCloudStorageLocationResponseArgs', 'HdfsLocationResponseArgs', 'HttpServerLocationResponseArgs', 'SftpLocationResponseArgs'] location: The location of the json data storage.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param Union['DatasetBZip2CompressionResponseArgs', 'DatasetDeflateCompressionResponseArgs', 'DatasetGZipCompressionResponseArgs', 'DatasetTarCompressionResponseArgs', 'DatasetTarGZipCompressionResponseArgs', 'DatasetZipDeflateCompressionResponseArgs'] compression: The data compression method used for the json dataset.
        :param str description: Dataset description.
        :param Any encoding_name: The code page name of the preferred encoding. If not specified, the default value is UTF-8, unless BOM denotes another Unicode encoding. Refer to the name column of the table in the following link to set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType string).
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "type", 'Json')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encoding_name is not None:
            pulumi.set(__self__, "encoding_name", encoding_name)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def location(self) -> Any:
        """
        The location of the json data storage.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def compression(self) -> Optional[Any]:
        """
        The data compression method used for the json dataset.
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encodingName")
    def encoding_name(self) -> Optional[Any]:
        """
        The code page name of the preferred encoding. If not specified, the default value is UTF-8, unless BOM denotes another Unicode encoding. Refer to the name column of the table in the following link to set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encoding_name")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class JsonFormatResponse(dict):
    """
    The data stored in JSON format.
    """
    def __init__(__self__, *,
                 type: str,
                 deserializer: Optional[Any] = None,
                 encoding_name: Optional[Any] = None,
                 file_pattern: Optional[str] = None,
                 json_node_reference: Optional[Any] = None,
                 json_path_definition: Optional[Any] = None,
                 nesting_separator: Optional[Any] = None,
                 serializer: Optional[Any] = None):
        """
        The data stored in JSON format.
        :param str type: Type of dataset storage format.
        :param Any deserializer: Deserializer. Type: string (or Expression with resultType string).
        :param Any encoding_name: The code page name of the preferred encoding. If not provided, the default value is 'utf-8', unless the byte order mark (BOM) denotes another Unicode encoding. The full list of supported values can be found in the 'Name' column of the table of encodings in the following reference: https://go.microsoft.com/fwlink/?linkid=861078. Type: string (or Expression with resultType string).
        :param str file_pattern: File pattern of JSON. To be more specific, the way of separating a collection of JSON objects. The default value is 'setOfObjects'. It is case-sensitive.
        :param Any json_node_reference: The JSONPath of the JSON array element to be flattened. Example: "$.ArrayPath". Type: string (or Expression with resultType string).
        :param Any json_path_definition: The JSONPath definition for each column mapping with a customized column name to extract data from JSON file. For fields under root object, start with "$"; for fields inside the array chosen by jsonNodeReference property, start from the array element. Example: {"Column1": "$.Column1Path", "Column2": "Column2PathInArray"}. Type: object (or Expression with resultType object).
        :param Any nesting_separator: The character used to separate nesting levels. Default value is '.' (dot). Type: string (or Expression with resultType string).
        :param Any serializer: Serializer. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'JsonFormat')
        if deserializer is not None:
            pulumi.set(__self__, "deserializer", deserializer)
        if encoding_name is not None:
            pulumi.set(__self__, "encoding_name", encoding_name)
        if file_pattern is not None:
            pulumi.set(__self__, "file_pattern", file_pattern)
        if json_node_reference is not None:
            pulumi.set(__self__, "json_node_reference", json_node_reference)
        if json_path_definition is not None:
            pulumi.set(__self__, "json_path_definition", json_path_definition)
        if nesting_separator is not None:
            pulumi.set(__self__, "nesting_separator", nesting_separator)
        if serializer is not None:
            pulumi.set(__self__, "serializer", serializer)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset storage format.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def deserializer(self) -> Optional[Any]:
        """
        Deserializer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "deserializer")

    @property
    @pulumi.getter(name="encodingName")
    def encoding_name(self) -> Optional[Any]:
        """
        The code page name of the preferred encoding. If not provided, the default value is 'utf-8', unless the byte order mark (BOM) denotes another Unicode encoding. The full list of supported values can be found in the 'Name' column of the table of encodings in the following reference: https://go.microsoft.com/fwlink/?linkid=861078. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encoding_name")

    @property
    @pulumi.getter(name="filePattern")
    def file_pattern(self) -> Optional[str]:
        """
        File pattern of JSON. To be more specific, the way of separating a collection of JSON objects. The default value is 'setOfObjects'. It is case-sensitive.
        """
        return pulumi.get(self, "file_pattern")

    @property
    @pulumi.getter(name="jsonNodeReference")
    def json_node_reference(self) -> Optional[Any]:
        """
        The JSONPath of the JSON array element to be flattened. Example: "$.ArrayPath". Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "json_node_reference")

    @property
    @pulumi.getter(name="jsonPathDefinition")
    def json_path_definition(self) -> Optional[Any]:
        """
        The JSONPath definition for each column mapping with a customized column name to extract data from JSON file. For fields under root object, start with "$"; for fields inside the array chosen by jsonNodeReference property, start from the array element. Example: {"Column1": "$.Column1Path", "Column2": "Column2PathInArray"}. Type: object (or Expression with resultType object).
        """
        return pulumi.get(self, "json_path_definition")

    @property
    @pulumi.getter(name="nestingSeparator")
    def nesting_separator(self) -> Optional[Any]:
        """
        The character used to separate nesting levels. Default value is '.' (dot). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "nesting_separator")

    @property
    @pulumi.getter
    def serializer(self) -> Optional[Any]:
        """
        Serializer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "serializer")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LinkedIntegrationRuntimeKeyAuthorizationResponse(dict):
    """
    The key authorization type integration runtime.
    """
    def __init__(__self__, *,
                 authorization_type: str,
                 key: 'outputs.SecureStringResponse'):
        """
        The key authorization type integration runtime.
        :param str authorization_type: The authorization type for integration runtime sharing.
        :param 'SecureStringResponseArgs' key: The key used for authorization.
        """
        pulumi.set(__self__, "authorization_type", 'Key')
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter(name="authorizationType")
    def authorization_type(self) -> str:
        """
        The authorization type for integration runtime sharing.
        """
        return pulumi.get(self, "authorization_type")

    @property
    @pulumi.getter
    def key(self) -> 'outputs.SecureStringResponse':
        """
        The key used for authorization.
        """
        return pulumi.get(self, "key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LinkedIntegrationRuntimeRbacAuthorizationResponse(dict):
    """
    The role based access control (RBAC) authorization type integration runtime.
    """
    def __init__(__self__, *,
                 authorization_type: str,
                 resource_id: str):
        """
        The role based access control (RBAC) authorization type integration runtime.
        :param str authorization_type: The authorization type for integration runtime sharing.
        :param str resource_id: The resource identifier of the integration runtime to be shared.
        """
        pulumi.set(__self__, "authorization_type", 'RBAC')
        pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="authorizationType")
    def authorization_type(self) -> str:
        """
        The authorization type for integration runtime sharing.
        """
        return pulumi.get(self, "authorization_type")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        """
        The resource identifier of the integration runtime to be shared.
        """
        return pulumi.get(self, "resource_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class LinkedIntegrationRuntimeResponseResult(dict):
    """
    The linked integration runtime information.
    """
    def __init__(__self__, *,
                 create_time: str,
                 data_factory_location: str,
                 data_factory_name: str,
                 name: str,
                 subscription_id: str):
        """
        The linked integration runtime information.
        :param str create_time: The creating time of the linked integration runtime.
        :param str data_factory_location: The location of the data factory for which the linked integration runtime belong to.
        :param str data_factory_name: The name of the data factory for which the linked integration runtime belong to.
        :param str name: The name of the linked integration runtime.
        :param str subscription_id: The subscription ID for which the linked integration runtime belong to.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "data_factory_location", data_factory_location)
        pulumi.set(__self__, "data_factory_name", data_factory_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subscription_id", subscription_id)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The creating time of the linked integration runtime.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="dataFactoryLocation")
    def data_factory_location(self) -> str:
        """
        The location of the data factory for which the linked integration runtime belong to.
        """
        return pulumi.get(self, "data_factory_location")

    @property
    @pulumi.getter(name="dataFactoryName")
    def data_factory_name(self) -> str:
        """
        The name of the data factory for which the linked integration runtime belong to.
        """
        return pulumi.get(self, "data_factory_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the linked integration runtime.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> str:
        """
        The subscription ID for which the linked integration runtime belong to.
        """
        return pulumi.get(self, "subscription_id")


@pulumi.output_type
class LinkedServiceReferenceResponse(dict):
    """
    Linked service reference type.
    """
    def __init__(__self__, *,
                 reference_name: str,
                 type: str,
                 parameters: Optional[Mapping[str, Any]] = None):
        """
        Linked service reference type.
        :param str reference_name: Reference LinkedService name.
        :param str type: Linked service reference type.
        :param Mapping[str, Any] parameters: Arguments for LinkedService.
        """
        pulumi.set(__self__, "reference_name", reference_name)
        pulumi.set(__self__, "type", type)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> str:
        """
        Reference LinkedService name.
        """
        return pulumi.get(self, "reference_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Linked service reference type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, Any]]:
        """
        Arguments for LinkedService.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MagentoLinkedServiceResponse(dict):
    """
    Magento server linked service.
    """
    def __init__(__self__, *,
                 host: Any,
                 type: str,
                 access_token: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Magento server linked service.
        :param Any host: The URL of the Magento instance. (i.e. 192.168.222.110/magento3)
        :param str type: Type of linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] access_token: The access token from Magento.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'Magento')
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        The URL of the Magento instance. (i.e. 192.168.222.110/magento3)
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[Any]:
        """
        The access token from Magento.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MagentoObjectDatasetResponse(dict):
    """
    Magento server dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Magento server dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'MagentoObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ManagedIntegrationRuntimeErrorResponseResult(dict):
    """
    Error definition for managed integration runtime.
    """
    def __init__(__self__, *,
                 code: str,
                 message: str,
                 parameters: Sequence[str],
                 time: str):
        """
        Error definition for managed integration runtime.
        :param str code: Error code.
        :param str message: Error message.
        :param Sequence[str] parameters: Managed integration runtime error parameters.
        :param str time: The time when the error occurred.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def code(self) -> str:
        """
        Error code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Error message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def parameters(self) -> Sequence[str]:
        """
        Managed integration runtime error parameters.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def time(self) -> str:
        """
        The time when the error occurred.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class ManagedIntegrationRuntimeNodeResponseResult(dict):
    """
    Properties of integration runtime node.
    """
    def __init__(__self__, *,
                 node_id: str,
                 status: str,
                 errors: Optional[Sequence['outputs.ManagedIntegrationRuntimeErrorResponseResult']] = None):
        """
        Properties of integration runtime node.
        :param str node_id: The managed integration runtime node id.
        :param str status: The managed integration runtime node status.
        :param Sequence['ManagedIntegrationRuntimeErrorResponseArgs'] errors: The errors that occurred on this integration runtime node.
        """
        pulumi.set(__self__, "node_id", node_id)
        pulumi.set(__self__, "status", status)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> str:
        """
        The managed integration runtime node id.
        """
        return pulumi.get(self, "node_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The managed integration runtime node status.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.ManagedIntegrationRuntimeErrorResponseResult']]:
        """
        The errors that occurred on this integration runtime node.
        """
        return pulumi.get(self, "errors")


@pulumi.output_type
class ManagedIntegrationRuntimeOperationResultResponseResult(dict):
    """
    Properties of managed integration runtime operation result.
    """
    def __init__(__self__, *,
                 activity_id: str,
                 error_code: str,
                 parameters: Sequence[str],
                 result: str,
                 start_time: str,
                 type: str):
        """
        Properties of managed integration runtime operation result.
        :param str activity_id: The activity id for the operation request.
        :param str error_code: The error code.
        :param Sequence[str] parameters: Managed integration runtime error parameters.
        :param str result: The operation result.
        :param str start_time: The start time of the operation.
        :param str type: The operation type. Could be start or stop.
        """
        pulumi.set(__self__, "activity_id", activity_id)
        pulumi.set(__self__, "error_code", error_code)
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "result", result)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="activityId")
    def activity_id(self) -> str:
        """
        The activity id for the operation request.
        """
        return pulumi.get(self, "activity_id")

    @property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> str:
        """
        The error code.
        """
        return pulumi.get(self, "error_code")

    @property
    @pulumi.getter
    def parameters(self) -> Sequence[str]:
        """
        Managed integration runtime error parameters.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def result(self) -> str:
        """
        The operation result.
        """
        return pulumi.get(self, "result")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        The start time of the operation.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The operation type. Could be start or stop.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ManagedIntegrationRuntimeResponse(dict):
    """
    Managed integration runtime, including managed elastic and managed dedicated integration runtimes.
    """
    def __init__(__self__, *,
                 state: str,
                 type: str,
                 compute_properties: Optional['outputs.IntegrationRuntimeComputePropertiesResponse'] = None,
                 description: Optional[str] = None,
                 ssis_properties: Optional['outputs.IntegrationRuntimeSsisPropertiesResponse'] = None):
        """
        Managed integration runtime, including managed elastic and managed dedicated integration runtimes.
        :param str state: Integration runtime state, only valid for managed dedicated integration runtime.
        :param str type: Type of integration runtime.
        :param 'IntegrationRuntimeComputePropertiesResponseArgs' compute_properties: The compute resource for managed integration runtime.
        :param str description: Integration runtime description.
        :param 'IntegrationRuntimeSsisPropertiesResponseArgs' ssis_properties: SSIS properties for managed integration runtime.
        """
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "type", 'Managed')
        if compute_properties is not None:
            pulumi.set(__self__, "compute_properties", compute_properties)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ssis_properties is not None:
            pulumi.set(__self__, "ssis_properties", ssis_properties)

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Integration runtime state, only valid for managed dedicated integration runtime.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of integration runtime.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="computeProperties")
    def compute_properties(self) -> Optional['outputs.IntegrationRuntimeComputePropertiesResponse']:
        """
        The compute resource for managed integration runtime.
        """
        return pulumi.get(self, "compute_properties")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Integration runtime description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ssisProperties")
    def ssis_properties(self) -> Optional['outputs.IntegrationRuntimeSsisPropertiesResponse']:
        """
        SSIS properties for managed integration runtime.
        """
        return pulumi.get(self, "ssis_properties")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ManagedIntegrationRuntimeStatusResponseResult(dict):
    """
    Managed integration runtime status.
    """
    def __init__(__self__, *,
                 create_time: str,
                 data_factory_name: str,
                 last_operation: 'outputs.ManagedIntegrationRuntimeOperationResultResponseResult',
                 nodes: Sequence['outputs.ManagedIntegrationRuntimeNodeResponseResult'],
                 other_errors: Sequence['outputs.ManagedIntegrationRuntimeErrorResponseResult'],
                 state: str,
                 type: str):
        """
        Managed integration runtime status.
        :param str create_time: The time at which the integration runtime was created, in ISO8601 format.
        :param str data_factory_name: The data factory name which the integration runtime belong to.
        :param 'ManagedIntegrationRuntimeOperationResultResponseArgs' last_operation: The last operation result that occurred on this integration runtime.
        :param Sequence['ManagedIntegrationRuntimeNodeResponseArgs'] nodes: The list of nodes for managed integration runtime.
        :param Sequence['ManagedIntegrationRuntimeErrorResponseArgs'] other_errors: The errors that occurred on this integration runtime.
        :param str state: The state of integration runtime.
        :param str type: Type of integration runtime.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "data_factory_name", data_factory_name)
        pulumi.set(__self__, "last_operation", last_operation)
        pulumi.set(__self__, "nodes", nodes)
        pulumi.set(__self__, "other_errors", other_errors)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "type", 'Managed')

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The time at which the integration runtime was created, in ISO8601 format.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="dataFactoryName")
    def data_factory_name(self) -> str:
        """
        The data factory name which the integration runtime belong to.
        """
        return pulumi.get(self, "data_factory_name")

    @property
    @pulumi.getter(name="lastOperation")
    def last_operation(self) -> 'outputs.ManagedIntegrationRuntimeOperationResultResponseResult':
        """
        The last operation result that occurred on this integration runtime.
        """
        return pulumi.get(self, "last_operation")

    @property
    @pulumi.getter
    def nodes(self) -> Sequence['outputs.ManagedIntegrationRuntimeNodeResponseResult']:
        """
        The list of nodes for managed integration runtime.
        """
        return pulumi.get(self, "nodes")

    @property
    @pulumi.getter(name="otherErrors")
    def other_errors(self) -> Sequence['outputs.ManagedIntegrationRuntimeErrorResponseResult']:
        """
        The errors that occurred on this integration runtime.
        """
        return pulumi.get(self, "other_errors")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of integration runtime.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of integration runtime.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ManagedPrivateEndpointResponse(dict):
    """
    Properties of a managed private endpoint
    """
    def __init__(__self__, *,
                 is_reserved: bool,
                 provisioning_state: str,
                 connection_state: Optional['outputs.ConnectionStatePropertiesResponse'] = None,
                 fqdns: Optional[Sequence[str]] = None,
                 group_id: Optional[str] = None,
                 private_link_resource_id: Optional[str] = None):
        """
        Properties of a managed private endpoint
        :param bool is_reserved: Denotes whether the managed private endpoint is reserved
        :param str provisioning_state: The managed private endpoint provisioning state
        :param 'ConnectionStatePropertiesResponseArgs' connection_state: The managed private endpoint connection state
        :param Sequence[str] fqdns: Fully qualified domain names
        :param str group_id: The groupId to which the managed private endpoint is created
        :param str private_link_resource_id: The ARM resource ID of the resource to which the managed private endpoint is created
        """
        pulumi.set(__self__, "is_reserved", is_reserved)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if connection_state is not None:
            pulumi.set(__self__, "connection_state", connection_state)
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if private_link_resource_id is not None:
            pulumi.set(__self__, "private_link_resource_id", private_link_resource_id)

    @property
    @pulumi.getter(name="isReserved")
    def is_reserved(self) -> bool:
        """
        Denotes whether the managed private endpoint is reserved
        """
        return pulumi.get(self, "is_reserved")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The managed private endpoint provisioning state
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="connectionState")
    def connection_state(self) -> Optional['outputs.ConnectionStatePropertiesResponse']:
        """
        The managed private endpoint connection state
        """
        return pulumi.get(self, "connection_state")

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[Sequence[str]]:
        """
        Fully qualified domain names
        """
        return pulumi.get(self, "fqdns")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        The groupId to which the managed private endpoint is created
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="privateLinkResourceId")
    def private_link_resource_id(self) -> Optional[str]:
        """
        The ARM resource ID of the resource to which the managed private endpoint is created
        """
        return pulumi.get(self, "private_link_resource_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MappingDataFlowResponse(dict):
    """
    Mapping data flow.
    """
    def __init__(__self__, *,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DataFlowResponseFolder'] = None,
                 script: Optional[str] = None,
                 sinks: Optional[Sequence['outputs.DataFlowSinkResponse']] = None,
                 sources: Optional[Sequence['outputs.DataFlowSourceResponse']] = None,
                 transformations: Optional[Sequence['outputs.TransformationResponse']] = None,
                 type: Optional[str] = None):
        """
        Mapping data flow.
        :param Sequence[Any] annotations: List of tags that can be used for describing the data flow.
        :param str description: The description of the data flow.
        :param 'DataFlowResponseFolderArgs' folder: The folder that this data flow is in. If not specified, Data flow will appear at the root level.
        :param str script: DataFlow script.
        :param Sequence['DataFlowSinkResponseArgs'] sinks: List of sinks in data flow.
        :param Sequence['DataFlowSourceResponseArgs'] sources: List of sources in data flow.
        :param Sequence['TransformationResponseArgs'] transformations: List of transformations in data flow.
        :param str type: Type of data flow.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if script is not None:
            pulumi.set(__self__, "script", script)
        if sinks is not None:
            pulumi.set(__self__, "sinks", sinks)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if transformations is not None:
            pulumi.set(__self__, "transformations", transformations)
        if type is not None:
            pulumi.set(__self__, "type", 'MappingDataFlow')

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the data flow.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the data flow.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DataFlowResponseFolder']:
        """
        The folder that this data flow is in. If not specified, Data flow will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def script(self) -> Optional[str]:
        """
        DataFlow script.
        """
        return pulumi.get(self, "script")

    @property
    @pulumi.getter
    def sinks(self) -> Optional[Sequence['outputs.DataFlowSinkResponse']]:
        """
        List of sinks in data flow.
        """
        return pulumi.get(self, "sinks")

    @property
    @pulumi.getter
    def sources(self) -> Optional[Sequence['outputs.DataFlowSourceResponse']]:
        """
        List of sources in data flow.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def transformations(self) -> Optional[Sequence['outputs.TransformationResponse']]:
        """
        List of transformations in data flow.
        """
        return pulumi.get(self, "transformations")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of data flow.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MariaDBLinkedServiceResponse(dict):
    """
    MariaDB server linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 pwd: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None):
        """
        MariaDB server linked service.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_string: An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' pwd: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "type", 'MariaDB')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if pwd is not None:
            pulumi.set(__self__, "pwd", pwd)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def pwd(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "pwd")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MariaDBTableDatasetResponse(dict):
    """
    MariaDB server dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        MariaDB server dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'MariaDBTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MarketoLinkedServiceResponse(dict):
    """
    Marketo server linked service.
    """
    def __init__(__self__, *,
                 client_id: Any,
                 endpoint: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 client_secret: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Marketo server linked service.
        :param Any client_id: The client Id of your Marketo service.
        :param Any endpoint: The endpoint of the Marketo server. (i.e. 123-ABC-321.mktorest.com)
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] client_secret: The client secret of your Marketo service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "type", 'Marketo')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Any:
        """
        The client Id of your Marketo service.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def endpoint(self) -> Any:
        """
        The endpoint of the Marketo server. (i.e. 123-ABC-321.mktorest.com)
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[Any]:
        """
        The client secret of your Marketo service.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MarketoObjectDatasetResponse(dict):
    """
    Marketo server dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Marketo server dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'MarketoObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MicrosoftAccessLinkedServiceResponse(dict):
    """
    Microsoft Access linked service.
    """
    def __init__(__self__, *,
                 connection_string: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 authentication_type: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 credential: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        Microsoft Access linked service.
        :param Any connection_string: The non-access credential portion of the connection string as well as an optional encrypted credential. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any authentication_type: Type of authentication used to connect to the Microsoft Access as ODBC data store. Possible values are: Anonymous and Basic. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] credential: The access credential portion of the connection string specified in driver-specific property-value format.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password for Basic authentication.
        :param Any user_name: User name for Basic authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'MicrosoftAccess')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The non-access credential portion of the connection string as well as an optional encrypted credential. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[Any]:
        """
        Type of authentication used to connect to the Microsoft Access as ODBC data store. Possible values are: Anonymous and Basic. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def credential(self) -> Optional[Any]:
        """
        The access credential portion of the connection string specified in driver-specific property-value format.
        """
        return pulumi.get(self, "credential")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password for Basic authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        User name for Basic authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MicrosoftAccessTableDatasetResponse(dict):
    """
    The Microsoft Access table dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The Microsoft Access table dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The Microsoft Access table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'MicrosoftAccessTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The Microsoft Access table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MongoDbAtlasCollectionDatasetResponse(dict):
    """
    The MongoDB Atlas database dataset.
    """
    def __init__(__self__, *,
                 collection: Any,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The MongoDB Atlas database dataset.
        :param Any collection: The collection name of the MongoDB Atlas database. Type: string (or Expression with resultType string).
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'MongoDbAtlasCollection')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter
    def collection(self) -> Any:
        """
        The collection name of the MongoDB Atlas database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "collection")

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MongoDbAtlasLinkedServiceResponse(dict):
    """
    Linked service for MongoDB Atlas data source.
    """
    def __init__(__self__, *,
                 connection_string: Any,
                 database: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None):
        """
        Linked service for MongoDB Atlas data source.
        :param Any connection_string: The MongoDB Atlas connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param Any database: The name of the MongoDB Atlas database that you want to access. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "type", 'MongoDbAtlas')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The MongoDB Atlas connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def database(self) -> Any:
        """
        The name of the MongoDB Atlas database that you want to access. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MongoDbCollectionDatasetResponse(dict):
    """
    The MongoDB database dataset.
    """
    def __init__(__self__, *,
                 collection_name: Any,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The MongoDB database dataset.
        :param Any collection_name: The table name of the MongoDB database. Type: string (or Expression with resultType string).
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'MongoDbCollection')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Any:
        """
        The table name of the MongoDB database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MongoDbLinkedServiceResponse(dict):
    """
    Linked service for MongoDb data source.
    """
    def __init__(__self__, *,
                 database_name: Any,
                 server: Any,
                 type: str,
                 allow_self_signed_server_cert: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 auth_source: Optional[Any] = None,
                 authentication_type: Optional[str] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 enable_ssl: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 port: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Linked service for MongoDb data source.
        :param Any database_name: The name of the MongoDB database that you want to access. Type: string (or Expression with resultType string).
        :param Any server: The IP address or server name of the MongoDB server. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Any allow_self_signed_server_cert: Specifies whether to allow self-signed certificates from the server. The default value is false. Type: boolean (or Expression with resultType boolean).
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any auth_source: Database to verify the username and password. Type: string (or Expression with resultType string).
        :param str authentication_type: The authentication type to be used to connect to the MongoDB database.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any enable_ssl: Specifies whether the connections to the server are encrypted using SSL. The default value is false. Type: boolean (or Expression with resultType boolean).
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password for authentication.
        :param Any port: The TCP port number that the MongoDB server uses to listen for client connections. The default value is 27017. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Any username: Username for authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "server", server)
        pulumi.set(__self__, "type", 'MongoDb')
        if allow_self_signed_server_cert is not None:
            pulumi.set(__self__, "allow_self_signed_server_cert", allow_self_signed_server_cert)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if auth_source is not None:
            pulumi.set(__self__, "auth_source", auth_source)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_ssl is not None:
            pulumi.set(__self__, "enable_ssl", enable_ssl)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Any:
        """
        The name of the MongoDB database that you want to access. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def server(self) -> Any:
        """
        The IP address or server name of the MongoDB server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="allowSelfSignedServerCert")
    def allow_self_signed_server_cert(self) -> Optional[Any]:
        """
        Specifies whether to allow self-signed certificates from the server. The default value is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "allow_self_signed_server_cert")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="authSource")
    def auth_source(self) -> Optional[Any]:
        """
        Database to verify the username and password. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "auth_source")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[str]:
        """
        The authentication type to be used to connect to the MongoDB database.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="enableSsl")
    def enable_ssl(self) -> Optional[Any]:
        """
        Specifies whether the connections to the server are encrypted using SSL. The default value is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "enable_ssl")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password for authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The TCP port number that the MongoDB server uses to listen for client connections. The default value is 27017. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        Username for authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MongoDbV2CollectionDatasetResponse(dict):
    """
    The MongoDB database dataset.
    """
    def __init__(__self__, *,
                 collection: Any,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The MongoDB database dataset.
        :param Any collection: The collection name of the MongoDB database. Type: string (or Expression with resultType string).
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'MongoDbV2Collection')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter
    def collection(self) -> Any:
        """
        The collection name of the MongoDB database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "collection")

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MongoDbV2LinkedServiceResponse(dict):
    """
    Linked service for MongoDB data source.
    """
    def __init__(__self__, *,
                 connection_string: Any,
                 database: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None):
        """
        Linked service for MongoDB data source.
        :param Any connection_string: The MongoDB connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param Any database: The name of the MongoDB database that you want to access. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "type", 'MongoDbV2')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The MongoDB connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def database(self) -> Any:
        """
        The name of the MongoDB database that you want to access. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MultiplePipelineTriggerResponse(dict):
    """
    Base class for all triggers that support one to many model for trigger to pipeline.
    """
    def __init__(__self__, *,
                 runtime_state: str,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 pipelines: Optional[Sequence['outputs.TriggerPipelineReferenceResponse']] = None):
        """
        Base class for all triggers that support one to many model for trigger to pipeline.
        :param str runtime_state: Indicates if trigger is running or not. Updated when Start/Stop APIs are called on the Trigger.
        :param str type: Trigger type.
        :param Sequence[Any] annotations: List of tags that can be used for describing the trigger.
        :param str description: Trigger description.
        :param Sequence['TriggerPipelineReferenceResponseArgs'] pipelines: Pipelines that need to be started.
        """
        pulumi.set(__self__, "runtime_state", runtime_state)
        pulumi.set(__self__, "type", 'MultiplePipelineTrigger')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if pipelines is not None:
            pulumi.set(__self__, "pipelines", pipelines)

    @property
    @pulumi.getter(name="runtimeState")
    def runtime_state(self) -> str:
        """
        Indicates if trigger is running or not. Updated when Start/Stop APIs are called on the Trigger.
        """
        return pulumi.get(self, "runtime_state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Trigger type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the trigger.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Trigger description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def pipelines(self) -> Optional[Sequence['outputs.TriggerPipelineReferenceResponse']]:
        """
        Pipelines that need to be started.
        """
        return pulumi.get(self, "pipelines")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MySqlLinkedServiceResponse(dict):
    """
    Linked service for MySQL data source.
    """
    def __init__(__self__, *,
                 connection_string: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None):
        """
        Linked service for MySQL data source.
        :param Any connection_string: The connection string.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' password: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'MySql')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The connection string.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "password")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MySqlTableDatasetResponse(dict):
    """
    The MySQL table dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The MySQL table dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The MySQL table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'MySqlTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The MySQL table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NetezzaLinkedServiceResponse(dict):
    """
    Netezza linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 pwd: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None):
        """
        Netezza linked service.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_string: An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' pwd: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "type", 'Netezza')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if pwd is not None:
            pulumi.set(__self__, "pwd", pwd)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def pwd(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "pwd")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NetezzaTableDatasetResponse(dict):
    """
    Netezza dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Netezza dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Netezza. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'NetezzaTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Netezza. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ODataLinkedServiceResponse(dict):
    """
    Open Data Protocol (OData) linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 url: Any,
                 aad_resource_id: Optional[Any] = None,
                 aad_service_principal_credential_type: Optional[str] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 authentication_type: Optional[str] = None,
                 azure_cloud_type: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 service_principal_embedded_cert: Optional[Any] = None,
                 service_principal_embedded_cert_password: Optional[Any] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[Any] = None,
                 tenant: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        Open Data Protocol (OData) linked service.
        :param str type: Type of linked service.
        :param Any url: The URL of the OData service endpoint. Type: string (or Expression with resultType string).
        :param Any aad_resource_id: Specify the resource you are requesting authorization to use Directory. Type: string (or Expression with resultType string).
        :param str aad_service_principal_credential_type: Specify the credential type (key or cert) is used for service principal.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param str authentication_type: Type of authentication used to connect to the OData service.
        :param Any azure_cloud_type: Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions’ cloud type. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password of the OData service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] service_principal_embedded_cert: Specify the base64 encoded certificate of your application registered in Azure Active Directory. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] service_principal_embedded_cert_password: Specify the password of your certificate if your certificate has a password and you are using AadServicePrincipal authentication. Type: string (or Expression with resultType string).
        :param Any service_principal_id: Specify the application id of your application registered in Azure Active Directory. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] service_principal_key: Specify the secret of your application registered in Azure Active Directory. Type: string (or Expression with resultType string).
        :param Any tenant: Specify the tenant information (domain name or tenant ID) under which your application resides. Type: string (or Expression with resultType string).
        :param Any user_name: User name of the OData service. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'OData')
        pulumi.set(__self__, "url", url)
        if aad_resource_id is not None:
            pulumi.set(__self__, "aad_resource_id", aad_resource_id)
        if aad_service_principal_credential_type is not None:
            pulumi.set(__self__, "aad_service_principal_credential_type", aad_service_principal_credential_type)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if azure_cloud_type is not None:
            pulumi.set(__self__, "azure_cloud_type", azure_cloud_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if service_principal_embedded_cert is not None:
            pulumi.set(__self__, "service_principal_embedded_cert", service_principal_embedded_cert)
        if service_principal_embedded_cert_password is not None:
            pulumi.set(__self__, "service_principal_embedded_cert_password", service_principal_embedded_cert_password)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        The URL of the OData service endpoint. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="aadResourceId")
    def aad_resource_id(self) -> Optional[Any]:
        """
        Specify the resource you are requesting authorization to use Directory. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "aad_resource_id")

    @property
    @pulumi.getter(name="aadServicePrincipalCredentialType")
    def aad_service_principal_credential_type(self) -> Optional[str]:
        """
        Specify the credential type (key or cert) is used for service principal.
        """
        return pulumi.get(self, "aad_service_principal_credential_type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[str]:
        """
        Type of authentication used to connect to the OData service.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="azureCloudType")
    def azure_cloud_type(self) -> Optional[Any]:
        """
        Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions’ cloud type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_cloud_type")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password of the OData service.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="servicePrincipalEmbeddedCert")
    def service_principal_embedded_cert(self) -> Optional[Any]:
        """
        Specify the base64 encoded certificate of your application registered in Azure Active Directory. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_embedded_cert")

    @property
    @pulumi.getter(name="servicePrincipalEmbeddedCertPassword")
    def service_principal_embedded_cert_password(self) -> Optional[Any]:
        """
        Specify the password of your certificate if your certificate has a password and you are using AadServicePrincipal authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_embedded_cert_password")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        Specify the application id of your application registered in Azure Active Directory. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[Any]:
        """
        Specify the secret of your application registered in Azure Active Directory. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_key")

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        Specify the tenant information (domain name or tenant ID) under which your application resides. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        User name of the OData service. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ODataResourceDatasetResponse(dict):
    """
    The Open Data Protocol (OData) resource dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 path: Optional[Any] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The Open Data Protocol (OData) resource dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any path: The OData resource path. Type: string (or Expression with resultType string).
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'ODataResource')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def path(self) -> Optional[Any]:
        """
        The OData resource path. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OdbcLinkedServiceResponse(dict):
    """
    Open Database Connectivity (ODBC) linked service.
    """
    def __init__(__self__, *,
                 connection_string: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 authentication_type: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 credential: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        Open Database Connectivity (ODBC) linked service.
        :param Any connection_string: The non-access credential portion of the connection string as well as an optional encrypted credential. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any authentication_type: Type of authentication used to connect to the ODBC data store. Possible values are: Anonymous and Basic. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] credential: The access credential portion of the connection string specified in driver-specific property-value format.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password for Basic authentication.
        :param Any user_name: User name for Basic authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'Odbc')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The non-access credential portion of the connection string as well as an optional encrypted credential. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[Any]:
        """
        Type of authentication used to connect to the ODBC data store. Possible values are: Anonymous and Basic. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def credential(self) -> Optional[Any]:
        """
        The access credential portion of the connection string specified in driver-specific property-value format.
        """
        return pulumi.get(self, "credential")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password for Basic authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        User name for Basic authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OdbcTableDatasetResponse(dict):
    """
    The ODBC table dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The ODBC table dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The ODBC table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'OdbcTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The ODBC table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class Office365DatasetResponse(dict):
    """
    The Office365 account.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 table_name: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 predicate: Optional[Any] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The Office365 account.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param Any table_name: Name of the dataset to extract from Office 365. Type: string (or Expression with resultType string).
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any predicate: A predicate expression that can be used to filter the specific rows to extract from Office 365. Type: string (or Expression with resultType string).
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "table_name", table_name)
        pulumi.set(__self__, "type", 'Office365Table')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if predicate is not None:
            pulumi.set(__self__, "predicate", predicate)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Any:
        """
        Name of the dataset to extract from Office 365. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def predicate(self) -> Optional[Any]:
        """
        A predicate expression that can be used to filter the specific rows to extract from Office 365. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "predicate")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class Office365LinkedServiceResponse(dict):
    """
    Office365 linked service.
    """
    def __init__(__self__, *,
                 office365_tenant_id: Any,
                 service_principal_id: Any,
                 service_principal_key: Any,
                 service_principal_tenant_id: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None):
        """
        Office365 linked service.
        :param Any office365_tenant_id: Azure tenant ID to which the Office 365 account belongs. Type: string (or Expression with resultType string).
        :param Any service_principal_id: Specify the application's client ID. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] service_principal_key: Specify the application's key.
        :param Any service_principal_tenant_id: Specify the tenant information under which your Azure AD web application resides. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "office365_tenant_id", office365_tenant_id)
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "service_principal_key", service_principal_key)
        pulumi.set(__self__, "service_principal_tenant_id", service_principal_tenant_id)
        pulumi.set(__self__, "type", 'Office365')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="office365TenantId")
    def office365_tenant_id(self) -> Any:
        """
        Azure tenant ID to which the Office 365 account belongs. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "office365_tenant_id")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Any:
        """
        Specify the application's client ID. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Any:
        """
        Specify the application's key.
        """
        return pulumi.get(self, "service_principal_key")

    @property
    @pulumi.getter(name="servicePrincipalTenantId")
    def service_principal_tenant_id(self) -> Any:
        """
        Specify the tenant information under which your Azure AD web application resides. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OracleLinkedServiceResponse(dict):
    """
    Oracle database.
    """
    def __init__(__self__, *,
                 connection_string: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None):
        """
        Oracle database.
        :param Any connection_string: The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' password: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'Oracle')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "password")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OracleServiceCloudLinkedServiceResponse(dict):
    """
    Oracle Service Cloud linked service.
    """
    def __init__(__self__, *,
                 host: Any,
                 password: Any,
                 type: str,
                 username: Any,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Oracle Service Cloud linked service.
        :param Any host: The URL of the Oracle Service Cloud instance.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: The password corresponding to the user name that you provided in the username key.
        :param str type: Type of linked service.
        :param Any username: The user name that you use to access Oracle Service Cloud server.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression with resultType boolean).
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "type", 'OracleServiceCloud')
        pulumi.set(__self__, "username", username)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        The URL of the Oracle Service Cloud instance.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> Any:
        """
        The password corresponding to the user name that you provided in the username key.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def username(self) -> Any:
        """
        The user name that you use to access Oracle Service Cloud server.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "use_host_verification")

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "use_peer_verification")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OracleServiceCloudObjectDatasetResponse(dict):
    """
    Oracle Service Cloud dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Oracle Service Cloud dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'OracleServiceCloudObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OracleTableDatasetResponse(dict):
    """
    The on-premises Oracle database dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The on-premises Oracle database dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the on-premises Oracle database. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'OracleTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the on-premises Oracle database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OrcDatasetResponse(dict):
    """
    ORC dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 location: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 orc_compression_codec: Optional[str] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        ORC dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param Union['AmazonS3LocationResponseArgs', 'AzureBlobFSLocationResponseArgs', 'AzureBlobStorageLocationResponseArgs', 'AzureDataLakeStoreLocationResponseArgs', 'AzureFileStorageLocationResponseArgs', 'FileServerLocationResponseArgs', 'FtpServerLocationResponseArgs', 'GoogleCloudStorageLocationResponseArgs', 'HdfsLocationResponseArgs', 'HttpServerLocationResponseArgs', 'SftpLocationResponseArgs'] location: The location of the ORC data storage.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "type", 'Orc')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if orc_compression_codec is not None:
            pulumi.set(__self__, "orc_compression_codec", orc_compression_codec)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def location(self) -> Any:
        """
        The location of the ORC data storage.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter(name="orcCompressionCodec")
    def orc_compression_codec(self) -> Optional[str]:
        return pulumi.get(self, "orc_compression_codec")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OrcFormatResponse(dict):
    """
    The data stored in Optimized Row Columnar (ORC) format.
    """
    def __init__(__self__, *,
                 type: str,
                 deserializer: Optional[Any] = None,
                 serializer: Optional[Any] = None):
        """
        The data stored in Optimized Row Columnar (ORC) format.
        :param str type: Type of dataset storage format.
        :param Any deserializer: Deserializer. Type: string (or Expression with resultType string).
        :param Any serializer: Serializer. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'OrcFormat')
        if deserializer is not None:
            pulumi.set(__self__, "deserializer", deserializer)
        if serializer is not None:
            pulumi.set(__self__, "serializer", serializer)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset storage format.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def deserializer(self) -> Optional[Any]:
        """
        Deserializer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "deserializer")

    @property
    @pulumi.getter
    def serializer(self) -> Optional[Any]:
        """
        Serializer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "serializer")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PackageStoreResponse(dict):
    """
    Package store for the SSIS integration runtime.
    """
    def __init__(__self__, *,
                 name: str,
                 package_store_linked_service: 'outputs.EntityReferenceResponse'):
        """
        Package store for the SSIS integration runtime.
        :param str name: The name of the package store
        :param 'EntityReferenceResponseArgs' package_store_linked_service: The package store linked service reference.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "package_store_linked_service", package_store_linked_service)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the package store
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="packageStoreLinkedService")
    def package_store_linked_service(self) -> 'outputs.EntityReferenceResponse':
        """
        The package store linked service reference.
        """
        return pulumi.get(self, "package_store_linked_service")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ParameterSpecificationResponse(dict):
    """
    Definition of a single parameter for an entity.
    """
    def __init__(__self__, *,
                 type: str,
                 default_value: Optional[Any] = None):
        """
        Definition of a single parameter for an entity.
        :param str type: Parameter type.
        :param Any default_value: Default value of parameter.
        """
        pulumi.set(__self__, "type", type)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Parameter type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[Any]:
        """
        Default value of parameter.
        """
        return pulumi.get(self, "default_value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ParquetDatasetResponse(dict):
    """
    Parquet dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 location: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 compression_codec: Optional[str] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Parquet dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param Union['AmazonS3LocationResponseArgs', 'AzureBlobFSLocationResponseArgs', 'AzureBlobStorageLocationResponseArgs', 'AzureDataLakeStoreLocationResponseArgs', 'AzureFileStorageLocationResponseArgs', 'FileServerLocationResponseArgs', 'FtpServerLocationResponseArgs', 'GoogleCloudStorageLocationResponseArgs', 'HdfsLocationResponseArgs', 'HttpServerLocationResponseArgs', 'SftpLocationResponseArgs'] location: The location of the parquet storage.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "type", 'Parquet')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def location(self) -> Any:
        """
        The location of the parquet storage.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[str]:
        return pulumi.get(self, "compression_codec")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ParquetFormatResponse(dict):
    """
    The data stored in Parquet format.
    """
    def __init__(__self__, *,
                 type: str,
                 deserializer: Optional[Any] = None,
                 serializer: Optional[Any] = None):
        """
        The data stored in Parquet format.
        :param str type: Type of dataset storage format.
        :param Any deserializer: Deserializer. Type: string (or Expression with resultType string).
        :param Any serializer: Serializer. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'ParquetFormat')
        if deserializer is not None:
            pulumi.set(__self__, "deserializer", deserializer)
        if serializer is not None:
            pulumi.set(__self__, "serializer", serializer)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset storage format.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def deserializer(self) -> Optional[Any]:
        """
        Deserializer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "deserializer")

    @property
    @pulumi.getter
    def serializer(self) -> Optional[Any]:
        """
        Serializer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "serializer")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PaypalLinkedServiceResponse(dict):
    """
    Paypal Service linked service.
    """
    def __init__(__self__, *,
                 client_id: Any,
                 host: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 client_secret: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Paypal Service linked service.
        :param Any client_id: The client ID associated with your PayPal application.
        :param Any host: The URL of the PayPal instance. (i.e. api.sandbox.paypal.com)
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] client_secret: The client secret associated with your PayPal application.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'Paypal')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Any:
        """
        The client ID associated with your PayPal application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        The URL of the PayPal instance. (i.e. api.sandbox.paypal.com)
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[Any]:
        """
        The client secret associated with your PayPal application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PaypalObjectDatasetResponse(dict):
    """
    Paypal Service dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Paypal Service dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'PaypalObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PhoenixLinkedServiceResponse(dict):
    """
    Phoenix server linked service.
    """
    def __init__(__self__, *,
                 authentication_type: str,
                 host: Any,
                 type: str,
                 allow_host_name_cn_mismatch: Optional[Any] = None,
                 allow_self_signed_server_cert: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 enable_ssl: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 http_path: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 port: Optional[Any] = None,
                 trusted_cert_path: Optional[Any] = None,
                 use_system_trust_store: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Phoenix server linked service.
        :param str authentication_type: The authentication mechanism used to connect to the Phoenix server.
        :param Any host: The IP address or host name of the Phoenix server. (i.e. 192.168.222.160)
        :param str type: Type of linked service.
        :param Any allow_host_name_cn_mismatch: Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        :param Any allow_self_signed_server_cert: Specifies whether to allow self-signed certificates from the server. The default value is false.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any enable_ssl: Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any http_path: The partial URL corresponding to the Phoenix server. (i.e. /gateway/sandbox/phoenix/version). The default value is hbasephoenix if using WindowsAzureHDInsightService.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: The password corresponding to the user name.
        :param Any port: The TCP port that the Phoenix server uses to listen for client connections. The default value is 8765.
        :param Any trusted_cert_path: The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        :param Any use_system_trust_store: Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        :param Any username: The user name used to connect to the Phoenix server.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'Phoenix')
        if allow_host_name_cn_mismatch is not None:
            pulumi.set(__self__, "allow_host_name_cn_mismatch", allow_host_name_cn_mismatch)
        if allow_self_signed_server_cert is not None:
            pulumi.set(__self__, "allow_self_signed_server_cert", allow_self_signed_server_cert)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_ssl is not None:
            pulumi.set(__self__, "enable_ssl", enable_ssl)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if http_path is not None:
            pulumi.set(__self__, "http_path", http_path)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if trusted_cert_path is not None:
            pulumi.set(__self__, "trusted_cert_path", trusted_cert_path)
        if use_system_trust_store is not None:
            pulumi.set(__self__, "use_system_trust_store", use_system_trust_store)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        The authentication mechanism used to connect to the Phoenix server.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        The IP address or host name of the Phoenix server. (i.e. 192.168.222.160)
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="allowHostNameCNMismatch")
    def allow_host_name_cn_mismatch(self) -> Optional[Any]:
        """
        Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        """
        return pulumi.get(self, "allow_host_name_cn_mismatch")

    @property
    @pulumi.getter(name="allowSelfSignedServerCert")
    def allow_self_signed_server_cert(self) -> Optional[Any]:
        """
        Specifies whether to allow self-signed certificates from the server. The default value is false.
        """
        return pulumi.get(self, "allow_self_signed_server_cert")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="enableSsl")
    def enable_ssl(self) -> Optional[Any]:
        """
        Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        """
        return pulumi.get(self, "enable_ssl")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter(name="httpPath")
    def http_path(self) -> Optional[Any]:
        """
        The partial URL corresponding to the Phoenix server. (i.e. /gateway/sandbox/phoenix/version). The default value is hbasephoenix if using WindowsAzureHDInsightService.
        """
        return pulumi.get(self, "http_path")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        The password corresponding to the user name.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The TCP port that the Phoenix server uses to listen for client connections. The default value is 8765.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="trustedCertPath")
    def trusted_cert_path(self) -> Optional[Any]:
        """
        The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        """
        return pulumi.get(self, "trusted_cert_path")

    @property
    @pulumi.getter(name="useSystemTrustStore")
    def use_system_trust_store(self) -> Optional[Any]:
        """
        Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        """
        return pulumi.get(self, "use_system_trust_store")

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The user name used to connect to the Phoenix server.
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PhoenixObjectDatasetResponse(dict):
    """
    Phoenix server dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Phoenix server dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Phoenix. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'PhoenixObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Phoenix. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PipelineReferenceResponse(dict):
    """
    Pipeline reference type.
    """
    def __init__(__self__, *,
                 reference_name: str,
                 type: str,
                 name: Optional[str] = None):
        """
        Pipeline reference type.
        :param str reference_name: Reference pipeline name.
        :param str type: Pipeline reference type.
        :param str name: Reference name.
        """
        pulumi.set(__self__, "reference_name", reference_name)
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> str:
        """
        Reference pipeline name.
        """
        return pulumi.get(self, "reference_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Pipeline reference type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Reference name.
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PipelineResponseFolder(dict):
    """
    The folder that this Pipeline is in. If not specified, Pipeline will appear at the root level.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        The folder that this Pipeline is in. If not specified, Pipeline will appear at the root level.
        :param str name: The name of the folder that this Pipeline is in.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the folder that this Pipeline is in.
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PostgreSqlLinkedServiceResponse(dict):
    """
    Linked service for PostgreSQL data source.
    """
    def __init__(__self__, *,
                 connection_string: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None):
        """
        Linked service for PostgreSQL data source.
        :param Any connection_string: The connection string.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' password: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'PostgreSql')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The connection string.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "password")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PostgreSqlTableDatasetResponse(dict):
    """
    The PostgreSQL table dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The PostgreSQL table dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The PostgreSQL table name. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'PostgreSqlTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The PostgreSQL table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PrestoLinkedServiceResponse(dict):
    """
    Presto server linked service.
    """
    def __init__(__self__, *,
                 authentication_type: str,
                 catalog: Any,
                 host: Any,
                 server_version: Any,
                 type: str,
                 allow_host_name_cn_mismatch: Optional[Any] = None,
                 allow_self_signed_server_cert: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 enable_ssl: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 port: Optional[Any] = None,
                 time_zone_id: Optional[Any] = None,
                 trusted_cert_path: Optional[Any] = None,
                 use_system_trust_store: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Presto server linked service.
        :param str authentication_type: The authentication mechanism used to connect to the Presto server.
        :param Any catalog: The catalog context for all request against the server.
        :param Any host: The IP address or host name of the Presto server. (i.e. 192.168.222.160)
        :param Any server_version: The version of the Presto server. (i.e. 0.148-t)
        :param str type: Type of linked service.
        :param Any allow_host_name_cn_mismatch: Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        :param Any allow_self_signed_server_cert: Specifies whether to allow self-signed certificates from the server. The default value is false.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any enable_ssl: Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: The password corresponding to the user name.
        :param Any port: The TCP port that the Presto server uses to listen for client connections. The default value is 8080.
        :param Any time_zone_id: The local time zone used by the connection. Valid values for this option are specified in the IANA Time Zone Database. The default value is the system time zone.
        :param Any trusted_cert_path: The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        :param Any use_system_trust_store: Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        :param Any username: The user name used to connect to the Presto server.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "catalog", catalog)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "server_version", server_version)
        pulumi.set(__self__, "type", 'Presto')
        if allow_host_name_cn_mismatch is not None:
            pulumi.set(__self__, "allow_host_name_cn_mismatch", allow_host_name_cn_mismatch)
        if allow_self_signed_server_cert is not None:
            pulumi.set(__self__, "allow_self_signed_server_cert", allow_self_signed_server_cert)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_ssl is not None:
            pulumi.set(__self__, "enable_ssl", enable_ssl)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if time_zone_id is not None:
            pulumi.set(__self__, "time_zone_id", time_zone_id)
        if trusted_cert_path is not None:
            pulumi.set(__self__, "trusted_cert_path", trusted_cert_path)
        if use_system_trust_store is not None:
            pulumi.set(__self__, "use_system_trust_store", use_system_trust_store)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        The authentication mechanism used to connect to the Presto server.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter
    def catalog(self) -> Any:
        """
        The catalog context for all request against the server.
        """
        return pulumi.get(self, "catalog")

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        The IP address or host name of the Presto server. (i.e. 192.168.222.160)
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="serverVersion")
    def server_version(self) -> Any:
        """
        The version of the Presto server. (i.e. 0.148-t)
        """
        return pulumi.get(self, "server_version")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="allowHostNameCNMismatch")
    def allow_host_name_cn_mismatch(self) -> Optional[Any]:
        """
        Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        """
        return pulumi.get(self, "allow_host_name_cn_mismatch")

    @property
    @pulumi.getter(name="allowSelfSignedServerCert")
    def allow_self_signed_server_cert(self) -> Optional[Any]:
        """
        Specifies whether to allow self-signed certificates from the server. The default value is false.
        """
        return pulumi.get(self, "allow_self_signed_server_cert")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="enableSsl")
    def enable_ssl(self) -> Optional[Any]:
        """
        Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        """
        return pulumi.get(self, "enable_ssl")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        The password corresponding to the user name.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The TCP port that the Presto server uses to listen for client connections. The default value is 8080.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="timeZoneID")
    def time_zone_id(self) -> Optional[Any]:
        """
        The local time zone used by the connection. Valid values for this option are specified in the IANA Time Zone Database. The default value is the system time zone.
        """
        return pulumi.get(self, "time_zone_id")

    @property
    @pulumi.getter(name="trustedCertPath")
    def trusted_cert_path(self) -> Optional[Any]:
        """
        The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        """
        return pulumi.get(self, "trusted_cert_path")

    @property
    @pulumi.getter(name="useSystemTrustStore")
    def use_system_trust_store(self) -> Optional[Any]:
        """
        Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        """
        return pulumi.get(self, "use_system_trust_store")

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The user name used to connect to the Presto server.
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PrestoObjectDatasetResponse(dict):
    """
    Presto server dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Presto server dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Presto. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'PrestoObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Presto. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class QuickBooksLinkedServiceResponse(dict):
    """
    QuickBooks server linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 access_token: Optional[Any] = None,
                 access_token_secret: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 company_id: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_properties: Optional[Any] = None,
                 consumer_key: Optional[Any] = None,
                 consumer_secret: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 endpoint: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 use_encrypted_endpoints: Optional[Any] = None):
        """
        QuickBooks server linked service.
        :param str type: Type of linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] access_token: The access token for OAuth 1.0 authentication.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] access_token_secret: The access token secret for OAuth 1.0 authentication.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any company_id: The company ID of the QuickBooks company to authorize.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_properties: Properties used to connect to QuickBooks. It is mutually exclusive with any other properties in the linked service. Type: object.
        :param Any consumer_key: The consumer key for OAuth 1.0 authentication.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] consumer_secret: The consumer secret for OAuth 1.0 authentication.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any endpoint: The endpoint of the QuickBooks server. (i.e. quickbooks.api.intuit.com)
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        pulumi.set(__self__, "type", 'QuickBooks')
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if access_token_secret is not None:
            pulumi.set(__self__, "access_token_secret", access_token_secret)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if company_id is not None:
            pulumi.set(__self__, "company_id", company_id)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_properties is not None:
            pulumi.set(__self__, "connection_properties", connection_properties)
        if consumer_key is not None:
            pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[Any]:
        """
        The access token for OAuth 1.0 authentication.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="accessTokenSecret")
    def access_token_secret(self) -> Optional[Any]:
        """
        The access token secret for OAuth 1.0 authentication.
        """
        return pulumi.get(self, "access_token_secret")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="companyId")
    def company_id(self) -> Optional[Any]:
        """
        The company ID of the QuickBooks company to authorize.
        """
        return pulumi.get(self, "company_id")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionProperties")
    def connection_properties(self) -> Optional[Any]:
        """
        Properties used to connect to QuickBooks. It is mutually exclusive with any other properties in the linked service. Type: object.
        """
        return pulumi.get(self, "connection_properties")

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> Optional[Any]:
        """
        The consumer key for OAuth 1.0 authentication.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[Any]:
        """
        The consumer secret for OAuth 1.0 authentication.
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[Any]:
        """
        The endpoint of the QuickBooks server. (i.e. quickbooks.api.intuit.com)
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class QuickBooksObjectDatasetResponse(dict):
    """
    QuickBooks server dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        QuickBooks server dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'QuickBooksObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RelationalTableDatasetResponse(dict):
    """
    The relational table dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The relational table dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The relational table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'RelationalTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The relational table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RerunTumblingWindowTriggerResponse(dict):
    """
    Trigger that schedules pipeline reruns for all fixed time interval windows from a requested start time to requested end time.
    """
    def __init__(__self__, *,
                 parent_trigger: Any,
                 requested_end_time: str,
                 requested_start_time: str,
                 rerun_concurrency: int,
                 runtime_state: str,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None):
        """
        Trigger that schedules pipeline reruns for all fixed time interval windows from a requested start time to requested end time.
        :param Any parent_trigger: The parent trigger reference.
        :param str requested_end_time: The end time for the time period for which restatement is initiated. Only UTC time is currently supported.
        :param str requested_start_time: The start time for the time period for which restatement is initiated. Only UTC time is currently supported.
        :param int rerun_concurrency: The max number of parallel time windows (ready for execution) for which a rerun is triggered.
        :param str runtime_state: Indicates if trigger is running or not. Updated when Start/Stop APIs are called on the Trigger.
        :param str type: Trigger type.
        :param Sequence[Any] annotations: List of tags that can be used for describing the trigger.
        :param str description: Trigger description.
        """
        pulumi.set(__self__, "parent_trigger", parent_trigger)
        pulumi.set(__self__, "requested_end_time", requested_end_time)
        pulumi.set(__self__, "requested_start_time", requested_start_time)
        pulumi.set(__self__, "rerun_concurrency", rerun_concurrency)
        pulumi.set(__self__, "runtime_state", runtime_state)
        pulumi.set(__self__, "type", 'RerunTumblingWindowTrigger')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="parentTrigger")
    def parent_trigger(self) -> Any:
        """
        The parent trigger reference.
        """
        return pulumi.get(self, "parent_trigger")

    @property
    @pulumi.getter(name="requestedEndTime")
    def requested_end_time(self) -> str:
        """
        The end time for the time period for which restatement is initiated. Only UTC time is currently supported.
        """
        return pulumi.get(self, "requested_end_time")

    @property
    @pulumi.getter(name="requestedStartTime")
    def requested_start_time(self) -> str:
        """
        The start time for the time period for which restatement is initiated. Only UTC time is currently supported.
        """
        return pulumi.get(self, "requested_start_time")

    @property
    @pulumi.getter(name="rerunConcurrency")
    def rerun_concurrency(self) -> int:
        """
        The max number of parallel time windows (ready for execution) for which a rerun is triggered.
        """
        return pulumi.get(self, "rerun_concurrency")

    @property
    @pulumi.getter(name="runtimeState")
    def runtime_state(self) -> str:
        """
        Indicates if trigger is running or not. Updated when Start/Stop APIs are called on the Trigger.
        """
        return pulumi.get(self, "runtime_state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Trigger type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the trigger.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Trigger description.
        """
        return pulumi.get(self, "description")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResponsysLinkedServiceResponse(dict):
    """
    Responsys linked service.
    """
    def __init__(__self__, *,
                 client_id: Any,
                 endpoint: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 client_secret: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Responsys linked service.
        :param Any client_id: The client ID associated with the Responsys application. Type: string (or Expression with resultType string).
        :param Any endpoint: The endpoint of the Responsys server.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] client_secret: The client secret associated with the Responsys application. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression with resultType boolean).
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "type", 'Responsys')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Any:
        """
        The client ID associated with the Responsys application. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def endpoint(self) -> Any:
        """
        The endpoint of the Responsys server.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[Any]:
        """
        The client secret associated with the Responsys application. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "use_host_verification")

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "use_peer_verification")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResponsysObjectDatasetResponse(dict):
    """
    Responsys dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Responsys dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'ResponsysObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RestResourceDatasetResponse(dict):
    """
    A Rest service dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 additional_headers: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 pagination_rules: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 relative_url: Optional[Any] = None,
                 request_body: Optional[Any] = None,
                 request_method: Optional[Any] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        A Rest service dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Any additional_headers: The additional HTTP headers in the request to the RESTful API. Type: string (or Expression with resultType string).
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any pagination_rules: The pagination rules to compose next page requests. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any relative_url: The relative URL to the resource that the RESTful API provides. Type: string (or Expression with resultType string).
        :param Any request_body: The HTTP request body to the RESTful API if requestMethod is POST. Type: string (or Expression with resultType string).
        :param Any request_method: The HTTP method used to call the RESTful API. The default is GET. Type: string (or Expression with resultType string).
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'RestResource')
        if additional_headers is not None:
            pulumi.set(__self__, "additional_headers", additional_headers)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if pagination_rules is not None:
            pulumi.set(__self__, "pagination_rules", pagination_rules)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if relative_url is not None:
            pulumi.set(__self__, "relative_url", relative_url)
        if request_body is not None:
            pulumi.set(__self__, "request_body", request_body)
        if request_method is not None:
            pulumi.set(__self__, "request_method", request_method)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="additionalHeaders")
    def additional_headers(self) -> Optional[Any]:
        """
        The additional HTTP headers in the request to the RESTful API. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "additional_headers")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter(name="paginationRules")
    def pagination_rules(self) -> Optional[Any]:
        """
        The pagination rules to compose next page requests. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "pagination_rules")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="relativeUrl")
    def relative_url(self) -> Optional[Any]:
        """
        The relative URL to the resource that the RESTful API provides. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "relative_url")

    @property
    @pulumi.getter(name="requestBody")
    def request_body(self) -> Optional[Any]:
        """
        The HTTP request body to the RESTful API if requestMethod is POST. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "request_body")

    @property
    @pulumi.getter(name="requestMethod")
    def request_method(self) -> Optional[Any]:
        """
        The HTTP method used to call the RESTful API. The default is GET. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "request_method")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RestServiceLinkedServiceResponse(dict):
    """
    Rest Service linked service.
    """
    def __init__(__self__, *,
                 authentication_type: str,
                 type: str,
                 url: Any,
                 aad_resource_id: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 azure_cloud_type: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 enable_server_certificate_validation: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 service_principal_id: Optional[Any] = None,
                 service_principal_key: Optional[Any] = None,
                 tenant: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        Rest Service linked service.
        :param str authentication_type: Type of authentication used to connect to the REST service.
        :param str type: Type of linked service.
        :param Any url: The base URL of the REST service.
        :param Any aad_resource_id: The resource you are requesting authorization to use.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any azure_cloud_type: Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions’ cloud type. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any enable_server_certificate_validation: Whether to validate server side SSL certificate when connecting to the endpoint.The default value is true. Type: boolean (or Expression with resultType boolean).
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: The password used in Basic authentication type.
        :param Any service_principal_id: The application's client ID used in AadServicePrincipal authentication type.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] service_principal_key: The application's key used in AadServicePrincipal authentication type.
        :param Any tenant: The tenant information (domain name or tenant ID) used in AadServicePrincipal authentication type under which your application resides.
        :param Any user_name: The user name used in Basic authentication type.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "type", 'RestService')
        pulumi.set(__self__, "url", url)
        if aad_resource_id is not None:
            pulumi.set(__self__, "aad_resource_id", aad_resource_id)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if azure_cloud_type is not None:
            pulumi.set(__self__, "azure_cloud_type", azure_cloud_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_server_certificate_validation is not None:
            pulumi.set(__self__, "enable_server_certificate_validation", enable_server_certificate_validation)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if service_principal_key is not None:
            pulumi.set(__self__, "service_principal_key", service_principal_key)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        Type of authentication used to connect to the REST service.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        The base URL of the REST service.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="aadResourceId")
    def aad_resource_id(self) -> Optional[Any]:
        """
        The resource you are requesting authorization to use.
        """
        return pulumi.get(self, "aad_resource_id")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="azureCloudType")
    def azure_cloud_type(self) -> Optional[Any]:
        """
        Indicates the azure cloud type of the service principle auth. Allowed values are AzurePublic, AzureChina, AzureUsGovernment, AzureGermany. Default value is the data factory regions’ cloud type. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "azure_cloud_type")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="enableServerCertificateValidation")
    def enable_server_certificate_validation(self) -> Optional[Any]:
        """
        Whether to validate server side SSL certificate when connecting to the endpoint.The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "enable_server_certificate_validation")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        The password used in Basic authentication type.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[Any]:
        """
        The application's client ID used in AadServicePrincipal authentication type.
        """
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Optional[Any]:
        """
        The application's key used in AadServicePrincipal authentication type.
        """
        return pulumi.get(self, "service_principal_key")

    @property
    @pulumi.getter
    def tenant(self) -> Optional[Any]:
        """
        The tenant information (domain name or tenant ID) used in AadServicePrincipal authentication type under which your application resides.
        """
        return pulumi.get(self, "tenant")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        The user name used in Basic authentication type.
        """
        return pulumi.get(self, "user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RetryPolicyResponse(dict):
    """
    Execution policy for an activity.
    """
    def __init__(__self__, *,
                 count: Optional[Any] = None,
                 interval_in_seconds: Optional[int] = None):
        """
        Execution policy for an activity.
        :param Any count: Maximum ordinary retry attempts. Default is 0. Type: integer (or Expression with resultType integer), minimum: 0.
        :param int interval_in_seconds: Interval between retries in seconds. Default is 30.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if interval_in_seconds is not None:
            pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)

    @property
    @pulumi.getter
    def count(self) -> Optional[Any]:
        """
        Maximum ordinary retry attempts. Default is 0. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> Optional[int]:
        """
        Interval between retries in seconds. Default is 30.
        """
        return pulumi.get(self, "interval_in_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SalesforceLinkedServiceResponse(dict):
    """
    Linked service for Salesforce.
    """
    def __init__(__self__, *,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 api_version: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 environment_url: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 security_token: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Linked service for Salesforce.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any api_version: The Salesforce API version used in ADF. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any environment_url: The URL of Salesforce instance. Default is 'https://login.salesforce.com'. To copy data from sandbox, specify 'https://test.salesforce.com'. To copy data from custom domain, specify, for example, 'https://[domain].my.salesforce.com'. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: The password for Basic authentication of the Salesforce instance.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] security_token: The security token is optional to remotely access Salesforce instance.
        :param Any username: The username for Basic authentication of the Salesforce instance. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'Salesforce')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if environment_url is not None:
            pulumi.set(__self__, "environment_url", environment_url)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if security_token is not None:
            pulumi.set(__self__, "security_token", security_token)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[Any]:
        """
        The Salesforce API version used in ADF. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter(name="environmentUrl")
    def environment_url(self) -> Optional[Any]:
        """
        The URL of Salesforce instance. Default is 'https://login.salesforce.com'. To copy data from sandbox, specify 'https://test.salesforce.com'. To copy data from custom domain, specify, for example, 'https://[domain].my.salesforce.com'. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "environment_url")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        The password for Basic authentication of the Salesforce instance.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="securityToken")
    def security_token(self) -> Optional[Any]:
        """
        The security token is optional to remotely access Salesforce instance.
        """
        return pulumi.get(self, "security_token")

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The username for Basic authentication of the Salesforce instance. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SalesforceMarketingCloudLinkedServiceResponse(dict):
    """
    Salesforce Marketing Cloud linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 client_id: Optional[Any] = None,
                 client_secret: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_properties: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Salesforce Marketing Cloud linked service.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any client_id: The client ID associated with the Salesforce Marketing Cloud application. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] client_secret: The client secret associated with the Salesforce Marketing Cloud application. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_properties: Properties used to connect to Salesforce Marketing Cloud. It is mutually exclusive with any other properties in the linked service. Type: object.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression with resultType boolean).
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        pulumi.set(__self__, "type", 'SalesforceMarketingCloud')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_properties is not None:
            pulumi.set(__self__, "connection_properties", connection_properties)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[Any]:
        """
        The client ID associated with the Salesforce Marketing Cloud application. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[Any]:
        """
        The client secret associated with the Salesforce Marketing Cloud application. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionProperties")
    def connection_properties(self) -> Optional[Any]:
        """
        Properties used to connect to Salesforce Marketing Cloud. It is mutually exclusive with any other properties in the linked service. Type: object.
        """
        return pulumi.get(self, "connection_properties")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "use_host_verification")

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "use_peer_verification")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SalesforceMarketingCloudObjectDatasetResponse(dict):
    """
    Salesforce Marketing Cloud dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Salesforce Marketing Cloud dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SalesforceMarketingCloudObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SalesforceObjectDatasetResponse(dict):
    """
    The Salesforce object dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 object_api_name: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The Salesforce object dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any object_api_name: The Salesforce object API name. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SalesforceObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if object_api_name is not None:
            pulumi.set(__self__, "object_api_name", object_api_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter(name="objectApiName")
    def object_api_name(self) -> Optional[Any]:
        """
        The Salesforce object API name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "object_api_name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SalesforceServiceCloudLinkedServiceResponse(dict):
    """
    Linked service for Salesforce Service Cloud.
    """
    def __init__(__self__, *,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 api_version: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 environment_url: Optional[Any] = None,
                 extended_properties: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 security_token: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Linked service for Salesforce Service Cloud.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any api_version: The Salesforce API version used in ADF. Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any environment_url: The URL of Salesforce Service Cloud instance. Default is 'https://login.salesforce.com'. To copy data from sandbox, specify 'https://test.salesforce.com'. To copy data from custom domain, specify, for example, 'https://[domain].my.salesforce.com'. Type: string (or Expression with resultType string).
        :param Any extended_properties: Extended properties appended to the connection string. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: The password for Basic authentication of the Salesforce instance.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] security_token: The security token is optional to remotely access Salesforce instance.
        :param Any username: The username for Basic authentication of the Salesforce instance. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'SalesforceServiceCloud')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if environment_url is not None:
            pulumi.set(__self__, "environment_url", environment_url)
        if extended_properties is not None:
            pulumi.set(__self__, "extended_properties", extended_properties)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if security_token is not None:
            pulumi.set(__self__, "security_token", security_token)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[Any]:
        """
        The Salesforce API version used in ADF. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter(name="environmentUrl")
    def environment_url(self) -> Optional[Any]:
        """
        The URL of Salesforce Service Cloud instance. Default is 'https://login.salesforce.com'. To copy data from sandbox, specify 'https://test.salesforce.com'. To copy data from custom domain, specify, for example, 'https://[domain].my.salesforce.com'. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "environment_url")

    @property
    @pulumi.getter(name="extendedProperties")
    def extended_properties(self) -> Optional[Any]:
        """
        Extended properties appended to the connection string. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "extended_properties")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        The password for Basic authentication of the Salesforce instance.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="securityToken")
    def security_token(self) -> Optional[Any]:
        """
        The security token is optional to remotely access Salesforce instance.
        """
        return pulumi.get(self, "security_token")

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The username for Basic authentication of the Salesforce instance. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SalesforceServiceCloudObjectDatasetResponse(dict):
    """
    The Salesforce Service Cloud object dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 object_api_name: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The Salesforce Service Cloud object dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any object_api_name: The Salesforce Service Cloud object API name. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SalesforceServiceCloudObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if object_api_name is not None:
            pulumi.set(__self__, "object_api_name", object_api_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter(name="objectApiName")
    def object_api_name(self) -> Optional[Any]:
        """
        The Salesforce Service Cloud object API name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "object_api_name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SapBWLinkedServiceResponse(dict):
    """
    SAP Business Warehouse Linked Service.
    """
    def __init__(__self__, *,
                 client_id: Any,
                 server: Any,
                 system_number: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        SAP Business Warehouse Linked Service.
        :param Any client_id: Client ID of the client on the BW system. (Usually a three-digit decimal number represented as a string) Type: string (or Expression with resultType string).
        :param Any server: Host name of the SAP BW instance. Type: string (or Expression with resultType string).
        :param Any system_number: System number of the BW system. (Usually a two-digit decimal number represented as a string.) Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password to access the SAP BW server.
        :param Any user_name: Username to access the SAP BW server. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "server", server)
        pulumi.set(__self__, "system_number", system_number)
        pulumi.set(__self__, "type", 'SapBW')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Any:
        """
        Client ID of the client on the BW system. (Usually a three-digit decimal number represented as a string) Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def server(self) -> Any:
        """
        Host name of the SAP BW instance. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter(name="systemNumber")
    def system_number(self) -> Any:
        """
        System number of the BW system. (Usually a two-digit decimal number represented as a string.) Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "system_number")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password to access the SAP BW server.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        Username to access the SAP BW server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SapBwCubeDatasetResponse(dict):
    """
    The SAP BW cube dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The SAP BW cube dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SapBwCube')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SapCloudForCustomerLinkedServiceResponse(dict):
    """
    Linked service for SAP Cloud for Customer.
    """
    def __init__(__self__, *,
                 type: str,
                 url: Any,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Linked service for SAP Cloud for Customer.
        :param str type: Type of linked service.
        :param Any url: The URL of SAP Cloud for Customer OData API. For example, '[https://[tenantname].crm.ondemand.com/sap/c4c/odata/v1]'. Type: string (or Expression with resultType string).
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Either encryptedCredential or username/password must be provided. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: The password for Basic authentication.
        :param Any username: The username for Basic authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'SapCloudForCustomer')
        pulumi.set(__self__, "url", url)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        The URL of SAP Cloud for Customer OData API. For example, '[https://[tenantname].crm.ondemand.com/sap/c4c/odata/v1]'. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Either encryptedCredential or username/password must be provided. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        The password for Basic authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The username for Basic authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SapCloudForCustomerResourceDatasetResponse(dict):
    """
    The path of the SAP Cloud for Customer OData entity.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 path: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The path of the SAP Cloud for Customer OData entity.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param Any path: The path of the SAP Cloud for Customer OData entity. Type: string (or Expression with resultType string).
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", 'SapCloudForCustomerResource')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def path(self) -> Any:
        """
        The path of the SAP Cloud for Customer OData entity. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SapEccLinkedServiceResponse(dict):
    """
    Linked service for SAP ERP Central Component(SAP ECC).
    """
    def __init__(__self__, *,
                 type: str,
                 url: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[str] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 username: Optional[str] = None):
        """
        Linked service for SAP ERP Central Component(SAP ECC).
        :param str type: Type of linked service.
        :param str url: The URL of SAP ECC OData API. For example, '[https://hostname:port/sap/opu/odata/sap/servicename/]'. Type: string (or Expression with resultType string).
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param str encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Either encryptedCredential or username/password must be provided. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: The password for Basic authentication.
        :param str username: The username for Basic authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'SapEcc')
        pulumi.set(__self__, "url", url)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of SAP ECC OData API. For example, '[https://hostname:port/sap/opu/odata/sap/servicename/]'. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[str]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Either encryptedCredential or username/password must be provided. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        The password for Basic authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username for Basic authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SapEccResourceDatasetResponse(dict):
    """
    The path of the SAP ECC OData entity.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 path: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The path of the SAP ECC OData entity.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param Any path: The path of the SAP ECC OData entity. Type: string (or Expression with resultType string).
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", 'SapEccResource')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def path(self) -> Any:
        """
        The path of the SAP ECC OData entity. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SapHanaLinkedServiceResponse(dict):
    """
    SAP HANA Linked Service.
    """
    def __init__(__self__, *,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 authentication_type: Optional[str] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 server: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        SAP HANA Linked Service.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param str authentication_type: The authentication type to be used to connect to the SAP HANA server.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_string: SAP HANA ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password to access the SAP HANA server.
        :param Any server: Host name of the SAP HANA server. Type: string (or Expression with resultType string).
        :param Any user_name: Username to access the SAP HANA server. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'SapHana')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[str]:
        """
        The authentication type to be used to connect to the SAP HANA server.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        SAP HANA ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password to access the SAP HANA server.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def server(self) -> Optional[Any]:
        """
        Host name of the SAP HANA server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        Username to access the SAP HANA server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SapHanaTableDatasetResponse(dict):
    """
    SAP HANA Table properties.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None):
        """
        SAP HANA Table properties.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of SAP HANA. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SapHanaTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of SAP HANA. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SapOpenHubLinkedServiceResponse(dict):
    """
    SAP Business Warehouse Open Hub Destination Linked Service.
    """
    def __init__(__self__, *,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 client_id: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 language: Optional[Any] = None,
                 logon_group: Optional[Any] = None,
                 message_server: Optional[Any] = None,
                 message_server_service: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 server: Optional[Any] = None,
                 system_id: Optional[Any] = None,
                 system_number: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        SAP Business Warehouse Open Hub Destination Linked Service.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any client_id: Client ID of the client on the BW system where the open hub destination is located. (Usually a three-digit decimal number represented as a string) Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any language: Language of the BW system where the open hub destination is located. The default value is EN. Type: string (or Expression with resultType string).
        :param Any logon_group: The Logon Group for the SAP System. Type: string (or Expression with resultType string).
        :param Any message_server: The hostname of the SAP Message Server. Type: string (or Expression with resultType string).
        :param Any message_server_service: The service name or port number of the Message Server. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password to access the SAP BW server where the open hub destination is located.
        :param Any server: Host name of the SAP BW instance where the open hub destination is located. Type: string (or Expression with resultType string).
        :param Any system_id: SystemID of the SAP system where the table is located. Type: string (or Expression with resultType string).
        :param Any system_number: System number of the BW system where the open hub destination is located. (Usually a two-digit decimal number represented as a string.) Type: string (or Expression with resultType string).
        :param Any user_name: Username to access the SAP BW server where the open hub destination is located. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'SapOpenHub')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if language is not None:
            pulumi.set(__self__, "language", language)
        if logon_group is not None:
            pulumi.set(__self__, "logon_group", logon_group)
        if message_server is not None:
            pulumi.set(__self__, "message_server", message_server)
        if message_server_service is not None:
            pulumi.set(__self__, "message_server_service", message_server_service)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if system_id is not None:
            pulumi.set(__self__, "system_id", system_id)
        if system_number is not None:
            pulumi.set(__self__, "system_number", system_number)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[Any]:
        """
        Client ID of the client on the BW system where the open hub destination is located. (Usually a three-digit decimal number represented as a string) Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def language(self) -> Optional[Any]:
        """
        Language of the BW system where the open hub destination is located. The default value is EN. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "language")

    @property
    @pulumi.getter(name="logonGroup")
    def logon_group(self) -> Optional[Any]:
        """
        The Logon Group for the SAP System. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "logon_group")

    @property
    @pulumi.getter(name="messageServer")
    def message_server(self) -> Optional[Any]:
        """
        The hostname of the SAP Message Server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "message_server")

    @property
    @pulumi.getter(name="messageServerService")
    def message_server_service(self) -> Optional[Any]:
        """
        The service name or port number of the Message Server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "message_server_service")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password to access the SAP BW server where the open hub destination is located.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def server(self) -> Optional[Any]:
        """
        Host name of the SAP BW instance where the open hub destination is located. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter(name="systemId")
    def system_id(self) -> Optional[Any]:
        """
        SystemID of the SAP system where the table is located. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "system_id")

    @property
    @pulumi.getter(name="systemNumber")
    def system_number(self) -> Optional[Any]:
        """
        System number of the BW system where the open hub destination is located. (Usually a two-digit decimal number represented as a string.) Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "system_number")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        Username to access the SAP BW server where the open hub destination is located. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SapOpenHubTableDatasetResponse(dict):
    """
    Sap Business Warehouse Open Hub Destination Table properties.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 open_hub_destination_name: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 base_request_id: Optional[Any] = None,
                 description: Optional[str] = None,
                 exclude_last_request: Optional[Any] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Sap Business Warehouse Open Hub Destination Table properties.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param Any open_hub_destination_name: The name of the Open Hub Destination with destination type as Database Table. Type: string (or Expression with resultType string).
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param Any base_request_id: The ID of request for delta loading. Once it is set, only data with requestId larger than the value of this property will be retrieved. The default value is 0. Type: integer (or Expression with resultType integer ).
        :param str description: Dataset description.
        :param Any exclude_last_request: Whether to exclude the records of the last request. The default value is true. Type: boolean (or Expression with resultType boolean).
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "open_hub_destination_name", open_hub_destination_name)
        pulumi.set(__self__, "type", 'SapOpenHubTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if base_request_id is not None:
            pulumi.set(__self__, "base_request_id", base_request_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if exclude_last_request is not None:
            pulumi.set(__self__, "exclude_last_request", exclude_last_request)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="openHubDestinationName")
    def open_hub_destination_name(self) -> Any:
        """
        The name of the Open Hub Destination with destination type as Database Table. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "open_hub_destination_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="baseRequestId")
    def base_request_id(self) -> Optional[Any]:
        """
        The ID of request for delta loading. Once it is set, only data with requestId larger than the value of this property will be retrieved. The default value is 0. Type: integer (or Expression with resultType integer ).
        """
        return pulumi.get(self, "base_request_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="excludeLastRequest")
    def exclude_last_request(self) -> Optional[Any]:
        """
        Whether to exclude the records of the last request. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "exclude_last_request")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SapTableLinkedServiceResponse(dict):
    """
    SAP Table Linked Service.
    """
    def __init__(__self__, *,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 client_id: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 language: Optional[Any] = None,
                 logon_group: Optional[Any] = None,
                 message_server: Optional[Any] = None,
                 message_server_service: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 server: Optional[Any] = None,
                 snc_library_path: Optional[Any] = None,
                 snc_mode: Optional[Any] = None,
                 snc_my_name: Optional[Any] = None,
                 snc_partner_name: Optional[Any] = None,
                 snc_qop: Optional[Any] = None,
                 system_id: Optional[Any] = None,
                 system_number: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        SAP Table Linked Service.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any client_id: Client ID of the client on the SAP system where the table is located. (Usually a three-digit decimal number represented as a string) Type: string (or Expression with resultType string).
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any language: Language of the SAP system where the table is located. The default value is EN. Type: string (or Expression with resultType string).
        :param Any logon_group: The Logon Group for the SAP System. Type: string (or Expression with resultType string).
        :param Any message_server: The hostname of the SAP Message Server. Type: string (or Expression with resultType string).
        :param Any message_server_service: The service name or port number of the Message Server. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password to access the SAP server where the table is located.
        :param Any server: Host name of the SAP instance where the table is located. Type: string (or Expression with resultType string).
        :param Any snc_library_path: External security product's library to access the SAP server where the table is located. Type: string (or Expression with resultType string).
        :param Any snc_mode: SNC activation indicator to access the SAP server where the table is located. Must be either 0 (off) or 1 (on). Type: string (or Expression with resultType string).
        :param Any snc_my_name: Initiator's SNC name to access the SAP server where the table is located. Type: string (or Expression with resultType string).
        :param Any snc_partner_name: Communication partner's SNC name to access the SAP server where the table is located. Type: string (or Expression with resultType string).
        :param Any snc_qop: SNC Quality of Protection. Allowed value include: 1, 2, 3, 8, 9. Type: string (or Expression with resultType string).
        :param Any system_id: SystemID of the SAP system where the table is located. Type: string (or Expression with resultType string).
        :param Any system_number: System number of the SAP system where the table is located. (Usually a two-digit decimal number represented as a string.) Type: string (or Expression with resultType string).
        :param Any user_name: Username to access the SAP server where the table is located. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'SapTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if language is not None:
            pulumi.set(__self__, "language", language)
        if logon_group is not None:
            pulumi.set(__self__, "logon_group", logon_group)
        if message_server is not None:
            pulumi.set(__self__, "message_server", message_server)
        if message_server_service is not None:
            pulumi.set(__self__, "message_server_service", message_server_service)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if snc_library_path is not None:
            pulumi.set(__self__, "snc_library_path", snc_library_path)
        if snc_mode is not None:
            pulumi.set(__self__, "snc_mode", snc_mode)
        if snc_my_name is not None:
            pulumi.set(__self__, "snc_my_name", snc_my_name)
        if snc_partner_name is not None:
            pulumi.set(__self__, "snc_partner_name", snc_partner_name)
        if snc_qop is not None:
            pulumi.set(__self__, "snc_qop", snc_qop)
        if system_id is not None:
            pulumi.set(__self__, "system_id", system_id)
        if system_number is not None:
            pulumi.set(__self__, "system_number", system_number)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[Any]:
        """
        Client ID of the client on the SAP system where the table is located. (Usually a three-digit decimal number represented as a string) Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def language(self) -> Optional[Any]:
        """
        Language of the SAP system where the table is located. The default value is EN. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "language")

    @property
    @pulumi.getter(name="logonGroup")
    def logon_group(self) -> Optional[Any]:
        """
        The Logon Group for the SAP System. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "logon_group")

    @property
    @pulumi.getter(name="messageServer")
    def message_server(self) -> Optional[Any]:
        """
        The hostname of the SAP Message Server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "message_server")

    @property
    @pulumi.getter(name="messageServerService")
    def message_server_service(self) -> Optional[Any]:
        """
        The service name or port number of the Message Server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "message_server_service")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password to access the SAP server where the table is located.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def server(self) -> Optional[Any]:
        """
        Host name of the SAP instance where the table is located. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter(name="sncLibraryPath")
    def snc_library_path(self) -> Optional[Any]:
        """
        External security product's library to access the SAP server where the table is located. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "snc_library_path")

    @property
    @pulumi.getter(name="sncMode")
    def snc_mode(self) -> Optional[Any]:
        """
        SNC activation indicator to access the SAP server where the table is located. Must be either 0 (off) or 1 (on). Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "snc_mode")

    @property
    @pulumi.getter(name="sncMyName")
    def snc_my_name(self) -> Optional[Any]:
        """
        Initiator's SNC name to access the SAP server where the table is located. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "snc_my_name")

    @property
    @pulumi.getter(name="sncPartnerName")
    def snc_partner_name(self) -> Optional[Any]:
        """
        Communication partner's SNC name to access the SAP server where the table is located. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "snc_partner_name")

    @property
    @pulumi.getter(name="sncQop")
    def snc_qop(self) -> Optional[Any]:
        """
        SNC Quality of Protection. Allowed value include: 1, 2, 3, 8, 9. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "snc_qop")

    @property
    @pulumi.getter(name="systemId")
    def system_id(self) -> Optional[Any]:
        """
        SystemID of the SAP system where the table is located. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "system_id")

    @property
    @pulumi.getter(name="systemNumber")
    def system_number(self) -> Optional[Any]:
        """
        System number of the SAP system where the table is located. (Usually a two-digit decimal number represented as a string.) Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "system_number")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        Username to access the SAP server where the table is located. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SapTableResourceDatasetResponse(dict):
    """
    SAP Table Resource properties.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 table_name: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        SAP Table Resource properties.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param Any table_name: The name of the SAP Table. Type: string (or Expression with resultType string).
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "table_name", table_name)
        pulumi.set(__self__, "type", 'SapTableResource')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Any:
        """
        The name of the SAP Table. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScriptActionResponse(dict):
    """
    Custom script action to run on HDI ondemand cluster once it's up.
    """
    def __init__(__self__, *,
                 name: str,
                 roles: str,
                 uri: str,
                 parameters: Optional[str] = None):
        """
        Custom script action to run on HDI ondemand cluster once it's up.
        :param str name: The user provided name of the script action.
        :param str roles: The node types on which the script action should be executed.
        :param str uri: The URI for the script action.
        :param str parameters: The parameters for the script action.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "uri", uri)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The user provided name of the script action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def roles(self) -> str:
        """
        The node types on which the script action should be executed.
        """
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI for the script action.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters for the script action.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SecureStringResponse(dict):
    """
    Azure Data Factory secure string definition. The string value will be masked with asterisks '*' during Get or List API calls.
    """
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        Azure Data Factory secure string definition. The string value will be masked with asterisks '*' during Get or List API calls.
        :param str type: Type of the secret.
        :param str value: Value of secure string.
        """
        pulumi.set(__self__, "type", 'SecureString')
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the secret.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of secure string.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SelfDependencyTumblingWindowTriggerReferenceResponse(dict):
    """
    Self referenced tumbling window trigger dependency.
    """
    def __init__(__self__, *,
                 offset: str,
                 type: str,
                 size: Optional[str] = None):
        """
        Self referenced tumbling window trigger dependency.
        :param str offset: Timespan applied to the start time of a tumbling window when evaluating dependency.
        :param str type: The type of dependency reference.
        :param str size: The size of the window when evaluating the dependency. If undefined the frequency of the tumbling window will be used.
        """
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "type", 'SelfDependencyTumblingWindowTriggerReference')
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def offset(self) -> str:
        """
        Timespan applied to the start time of a tumbling window when evaluating dependency.
        """
        return pulumi.get(self, "offset")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of dependency reference.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        """
        The size of the window when evaluating the dependency. If undefined the frequency of the tumbling window will be used.
        """
        return pulumi.get(self, "size")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SelfHostedIntegrationRuntimeNodeResponseResult(dict):
    """
    Properties of Self-hosted integration runtime node.
    """
    def __init__(__self__, *,
                 capabilities: Mapping[str, str],
                 concurrent_jobs_limit: int,
                 expiry_time: str,
                 host_service_uri: str,
                 is_active_dispatcher: bool,
                 last_connect_time: str,
                 last_end_update_time: str,
                 last_start_time: str,
                 last_start_update_time: str,
                 last_stop_time: str,
                 last_update_result: str,
                 machine_name: str,
                 max_concurrent_jobs: int,
                 node_name: str,
                 register_time: str,
                 status: str,
                 version: str,
                 version_status: str):
        """
        Properties of Self-hosted integration runtime node.
        :param Mapping[str, str] capabilities: The integration runtime capabilities dictionary
        :param int concurrent_jobs_limit: Maximum concurrent jobs on the integration runtime node.
        :param str expiry_time: The time at which the integration runtime will expire in ISO8601 format.
        :param str host_service_uri: URI for the host machine of the integration runtime.
        :param bool is_active_dispatcher: Indicates whether this node is the active dispatcher for integration runtime requests.
        :param str last_connect_time: The most recent time at which the integration runtime was connected in ISO8601 format.
        :param str last_end_update_time: The last time for the integration runtime node update end.
        :param str last_start_time: The time the node last started up.
        :param str last_start_update_time: The last time for the integration runtime node update start.
        :param str last_stop_time: The integration runtime node last stop time.
        :param str last_update_result: The result of the last integration runtime node update.
        :param str machine_name: Machine name of the integration runtime node.
        :param int max_concurrent_jobs: The maximum concurrent jobs in this integration runtime.
        :param str node_name: Name of the integration runtime node.
        :param str register_time: The time at which the integration runtime node was registered in ISO8601 format.
        :param str status: Status of the integration runtime node.
        :param str version: Version of the integration runtime node.
        :param str version_status: Status of the integration runtime node version.
        """
        pulumi.set(__self__, "capabilities", capabilities)
        pulumi.set(__self__, "concurrent_jobs_limit", concurrent_jobs_limit)
        pulumi.set(__self__, "expiry_time", expiry_time)
        pulumi.set(__self__, "host_service_uri", host_service_uri)
        pulumi.set(__self__, "is_active_dispatcher", is_active_dispatcher)
        pulumi.set(__self__, "last_connect_time", last_connect_time)
        pulumi.set(__self__, "last_end_update_time", last_end_update_time)
        pulumi.set(__self__, "last_start_time", last_start_time)
        pulumi.set(__self__, "last_start_update_time", last_start_update_time)
        pulumi.set(__self__, "last_stop_time", last_stop_time)
        pulumi.set(__self__, "last_update_result", last_update_result)
        pulumi.set(__self__, "machine_name", machine_name)
        pulumi.set(__self__, "max_concurrent_jobs", max_concurrent_jobs)
        pulumi.set(__self__, "node_name", node_name)
        pulumi.set(__self__, "register_time", register_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "version_status", version_status)

    @property
    @pulumi.getter
    def capabilities(self) -> Mapping[str, str]:
        """
        The integration runtime capabilities dictionary
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter(name="concurrentJobsLimit")
    def concurrent_jobs_limit(self) -> int:
        """
        Maximum concurrent jobs on the integration runtime node.
        """
        return pulumi.get(self, "concurrent_jobs_limit")

    @property
    @pulumi.getter(name="expiryTime")
    def expiry_time(self) -> str:
        """
        The time at which the integration runtime will expire in ISO8601 format.
        """
        return pulumi.get(self, "expiry_time")

    @property
    @pulumi.getter(name="hostServiceUri")
    def host_service_uri(self) -> str:
        """
        URI for the host machine of the integration runtime.
        """
        return pulumi.get(self, "host_service_uri")

    @property
    @pulumi.getter(name="isActiveDispatcher")
    def is_active_dispatcher(self) -> bool:
        """
        Indicates whether this node is the active dispatcher for integration runtime requests.
        """
        return pulumi.get(self, "is_active_dispatcher")

    @property
    @pulumi.getter(name="lastConnectTime")
    def last_connect_time(self) -> str:
        """
        The most recent time at which the integration runtime was connected in ISO8601 format.
        """
        return pulumi.get(self, "last_connect_time")

    @property
    @pulumi.getter(name="lastEndUpdateTime")
    def last_end_update_time(self) -> str:
        """
        The last time for the integration runtime node update end.
        """
        return pulumi.get(self, "last_end_update_time")

    @property
    @pulumi.getter(name="lastStartTime")
    def last_start_time(self) -> str:
        """
        The time the node last started up.
        """
        return pulumi.get(self, "last_start_time")

    @property
    @pulumi.getter(name="lastStartUpdateTime")
    def last_start_update_time(self) -> str:
        """
        The last time for the integration runtime node update start.
        """
        return pulumi.get(self, "last_start_update_time")

    @property
    @pulumi.getter(name="lastStopTime")
    def last_stop_time(self) -> str:
        """
        The integration runtime node last stop time.
        """
        return pulumi.get(self, "last_stop_time")

    @property
    @pulumi.getter(name="lastUpdateResult")
    def last_update_result(self) -> str:
        """
        The result of the last integration runtime node update.
        """
        return pulumi.get(self, "last_update_result")

    @property
    @pulumi.getter(name="machineName")
    def machine_name(self) -> str:
        """
        Machine name of the integration runtime node.
        """
        return pulumi.get(self, "machine_name")

    @property
    @pulumi.getter(name="maxConcurrentJobs")
    def max_concurrent_jobs(self) -> int:
        """
        The maximum concurrent jobs in this integration runtime.
        """
        return pulumi.get(self, "max_concurrent_jobs")

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> str:
        """
        Name of the integration runtime node.
        """
        return pulumi.get(self, "node_name")

    @property
    @pulumi.getter(name="registerTime")
    def register_time(self) -> str:
        """
        The time at which the integration runtime node was registered in ISO8601 format.
        """
        return pulumi.get(self, "register_time")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the integration runtime node.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Version of the integration runtime node.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="versionStatus")
    def version_status(self) -> str:
        """
        Status of the integration runtime node version.
        """
        return pulumi.get(self, "version_status")


@pulumi.output_type
class SelfHostedIntegrationRuntimeResponse(dict):
    """
    Self-hosted integration runtime.
    """
    def __init__(__self__, *,
                 type: str,
                 description: Optional[str] = None,
                 linked_info: Optional[Any] = None):
        """
        Self-hosted integration runtime.
        :param str type: Type of integration runtime.
        :param str description: Integration runtime description.
        :param Union['LinkedIntegrationRuntimeKeyAuthorizationResponseArgs', 'LinkedIntegrationRuntimeRbacAuthorizationResponseArgs'] linked_info: The base definition of a linked integration runtime.
        """
        pulumi.set(__self__, "type", 'SelfHosted')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if linked_info is not None:
            pulumi.set(__self__, "linked_info", linked_info)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of integration runtime.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Integration runtime description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="linkedInfo")
    def linked_info(self) -> Optional[Any]:
        """
        The base definition of a linked integration runtime.
        """
        return pulumi.get(self, "linked_info")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SelfHostedIntegrationRuntimeStatusResponseResult(dict):
    """
    Self-hosted integration runtime status.
    """
    def __init__(__self__, *,
                 auto_update: str,
                 auto_update_eta: str,
                 capabilities: Mapping[str, str],
                 create_time: str,
                 data_factory_name: str,
                 internal_channel_encryption: str,
                 latest_version: str,
                 local_time_zone_offset: str,
                 pushed_version: str,
                 scheduled_update_date: str,
                 service_urls: Sequence[str],
                 state: str,
                 task_queue_id: str,
                 type: str,
                 update_delay_offset: str,
                 version: str,
                 version_status: str,
                 links: Optional[Sequence['outputs.LinkedIntegrationRuntimeResponseResult']] = None,
                 nodes: Optional[Sequence['outputs.SelfHostedIntegrationRuntimeNodeResponseResult']] = None):
        """
        Self-hosted integration runtime status.
        :param str auto_update: Whether Self-hosted integration runtime auto update has been turned on.
        :param str auto_update_eta: The estimated time when the self-hosted integration runtime will be updated.
        :param Mapping[str, str] capabilities: Object with additional information about integration runtime capabilities.
        :param str create_time: The time at which the integration runtime was created, in ISO8601 format.
        :param str data_factory_name: The data factory name which the integration runtime belong to.
        :param str internal_channel_encryption: It is used to set the encryption mode for node-node communication channel (when more than 2 self-hosted integration runtime nodes exist).
        :param str latest_version: The latest version on download center.
        :param str local_time_zone_offset: The local time zone offset in hours.
        :param str pushed_version: The version that the integration runtime is going to update to.
        :param str scheduled_update_date: The date at which the integration runtime will be scheduled to update, in ISO8601 format.
        :param Sequence[str] service_urls: The URLs for the services used in integration runtime backend service.
        :param str state: The state of integration runtime.
        :param str task_queue_id: The task queue id of the integration runtime.
        :param str type: Type of integration runtime.
        :param str update_delay_offset: The time in the date scheduled by service to update the integration runtime, e.g., PT03H is 3 hours
        :param str version: Version of the integration runtime.
        :param str version_status: Status of the integration runtime version.
        :param Sequence['LinkedIntegrationRuntimeResponseArgs'] links: The list of linked integration runtimes that are created to share with this integration runtime.
        :param Sequence['SelfHostedIntegrationRuntimeNodeResponseArgs'] nodes: The list of nodes for this integration runtime.
        """
        pulumi.set(__self__, "auto_update", auto_update)
        pulumi.set(__self__, "auto_update_eta", auto_update_eta)
        pulumi.set(__self__, "capabilities", capabilities)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "data_factory_name", data_factory_name)
        pulumi.set(__self__, "internal_channel_encryption", internal_channel_encryption)
        pulumi.set(__self__, "latest_version", latest_version)
        pulumi.set(__self__, "local_time_zone_offset", local_time_zone_offset)
        pulumi.set(__self__, "pushed_version", pushed_version)
        pulumi.set(__self__, "scheduled_update_date", scheduled_update_date)
        pulumi.set(__self__, "service_urls", service_urls)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "task_queue_id", task_queue_id)
        pulumi.set(__self__, "type", 'SelfHosted')
        pulumi.set(__self__, "update_delay_offset", update_delay_offset)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "version_status", version_status)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)

    @property
    @pulumi.getter(name="autoUpdate")
    def auto_update(self) -> str:
        """
        Whether Self-hosted integration runtime auto update has been turned on.
        """
        return pulumi.get(self, "auto_update")

    @property
    @pulumi.getter(name="autoUpdateETA")
    def auto_update_eta(self) -> str:
        """
        The estimated time when the self-hosted integration runtime will be updated.
        """
        return pulumi.get(self, "auto_update_eta")

    @property
    @pulumi.getter
    def capabilities(self) -> Mapping[str, str]:
        """
        Object with additional information about integration runtime capabilities.
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The time at which the integration runtime was created, in ISO8601 format.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="dataFactoryName")
    def data_factory_name(self) -> str:
        """
        The data factory name which the integration runtime belong to.
        """
        return pulumi.get(self, "data_factory_name")

    @property
    @pulumi.getter(name="internalChannelEncryption")
    def internal_channel_encryption(self) -> str:
        """
        It is used to set the encryption mode for node-node communication channel (when more than 2 self-hosted integration runtime nodes exist).
        """
        return pulumi.get(self, "internal_channel_encryption")

    @property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> str:
        """
        The latest version on download center.
        """
        return pulumi.get(self, "latest_version")

    @property
    @pulumi.getter(name="localTimeZoneOffset")
    def local_time_zone_offset(self) -> str:
        """
        The local time zone offset in hours.
        """
        return pulumi.get(self, "local_time_zone_offset")

    @property
    @pulumi.getter(name="pushedVersion")
    def pushed_version(self) -> str:
        """
        The version that the integration runtime is going to update to.
        """
        return pulumi.get(self, "pushed_version")

    @property
    @pulumi.getter(name="scheduledUpdateDate")
    def scheduled_update_date(self) -> str:
        """
        The date at which the integration runtime will be scheduled to update, in ISO8601 format.
        """
        return pulumi.get(self, "scheduled_update_date")

    @property
    @pulumi.getter(name="serviceUrls")
    def service_urls(self) -> Sequence[str]:
        """
        The URLs for the services used in integration runtime backend service.
        """
        return pulumi.get(self, "service_urls")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of integration runtime.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskQueueId")
    def task_queue_id(self) -> str:
        """
        The task queue id of the integration runtime.
        """
        return pulumi.get(self, "task_queue_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of integration runtime.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updateDelayOffset")
    def update_delay_offset(self) -> str:
        """
        The time in the date scheduled by service to update the integration runtime, e.g., PT03H is 3 hours
        """
        return pulumi.get(self, "update_delay_offset")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Version of the integration runtime.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="versionStatus")
    def version_status(self) -> str:
        """
        Status of the integration runtime version.
        """
        return pulumi.get(self, "version_status")

    @property
    @pulumi.getter
    def links(self) -> Optional[Sequence['outputs.LinkedIntegrationRuntimeResponseResult']]:
        """
        The list of linked integration runtimes that are created to share with this integration runtime.
        """
        return pulumi.get(self, "links")

    @property
    @pulumi.getter
    def nodes(self) -> Optional[Sequence['outputs.SelfHostedIntegrationRuntimeNodeResponseResult']]:
        """
        The list of nodes for this integration runtime.
        """
        return pulumi.get(self, "nodes")


@pulumi.output_type
class ServiceNowLinkedServiceResponse(dict):
    """
    ServiceNow server linked service.
    """
    def __init__(__self__, *,
                 authentication_type: str,
                 endpoint: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 client_id: Optional[Any] = None,
                 client_secret: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        ServiceNow server linked service.
        :param str authentication_type: The authentication type to use.
        :param Any endpoint: The endpoint of the ServiceNow server. (i.e. <instance>.service-now.com)
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any client_id: The client id for OAuth2 authentication.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] client_secret: The client secret for OAuth2 authentication.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: The password corresponding to the user name for Basic and OAuth2 authentication.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        :param Any username: The user name used to connect to the ServiceNow server for Basic and OAuth2 authentication.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "type", 'ServiceNow')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        The authentication type to use.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter
    def endpoint(self) -> Any:
        """
        The endpoint of the ServiceNow server. (i.e. <instance>.service-now.com)
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[Any]:
        """
        The client id for OAuth2 authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[Any]:
        """
        The client secret for OAuth2 authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        The password corresponding to the user name for Basic and OAuth2 authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The user name used to connect to the ServiceNow server for Basic and OAuth2 authentication.
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceNowObjectDatasetResponse(dict):
    """
    ServiceNow server dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        ServiceNow server dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'ServiceNowObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SftpLocationResponse(dict):
    """
    The location of SFTP dataset.
    """
    def __init__(__self__, *,
                 type: str,
                 file_name: Optional[Any] = None,
                 folder_path: Optional[Any] = None):
        """
        The location of SFTP dataset.
        :param str type: Type of dataset storage location.
        :param Any file_name: Specify the file name of dataset. Type: string (or Expression with resultType string).
        :param Any folder_path: Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        pulumi.set(__self__, "type", 'SftpLocation')
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset storage location.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[Any]:
        """
        Specify the file name of dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[Any]:
        """
        Specify the folder path of dataset. Type: string (or Expression with resultType string)
        """
        return pulumi.get(self, "folder_path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SftpServerLinkedServiceResponse(dict):
    """
    A linked service for an SSH File Transfer Protocol (SFTP) server. 
    """
    def __init__(__self__, *,
                 host: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 authentication_type: Optional[str] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 host_key_fingerprint: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 pass_phrase: Optional[Any] = None,
                 password: Optional[Any] = None,
                 port: Optional[Any] = None,
                 private_key_content: Optional[Any] = None,
                 private_key_path: Optional[Any] = None,
                 skip_host_key_validation: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        A linked service for an SSH File Transfer Protocol (SFTP) server. 
        :param Any host: The SFTP server host name. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param str authentication_type: The authentication type to be used to connect to the FTP server.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any host_key_fingerprint: The host key finger-print of the SFTP server. When SkipHostKeyValidation is false, HostKeyFingerprint should be specified. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] pass_phrase: The password to decrypt the SSH private key if the SSH private key is encrypted.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password to logon the SFTP server for Basic authentication.
        :param Any port: The TCP port number that the SFTP server uses to listen for client connections. Default value is 22. Type: integer (or Expression with resultType integer), minimum: 0.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] private_key_content: Base64 encoded SSH private key content for SshPublicKey authentication. For on-premises copy with SshPublicKey authentication, either PrivateKeyPath or PrivateKeyContent should be specified. SSH private key should be OpenSSH format.
        :param Any private_key_path: The SSH private key file path for SshPublicKey authentication. Only valid for on-premises copy. For on-premises copy with SshPublicKey authentication, either PrivateKeyPath or PrivateKeyContent should be specified. SSH private key should be OpenSSH format. Type: string (or Expression with resultType string).
        :param Any skip_host_key_validation: If true, skip the SSH host key validation. Default value is false. Type: boolean (or Expression with resultType boolean).
        :param Any user_name: The username used to log on to the SFTP server. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'Sftp')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if host_key_fingerprint is not None:
            pulumi.set(__self__, "host_key_fingerprint", host_key_fingerprint)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if pass_phrase is not None:
            pulumi.set(__self__, "pass_phrase", pass_phrase)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if private_key_content is not None:
            pulumi.set(__self__, "private_key_content", private_key_content)
        if private_key_path is not None:
            pulumi.set(__self__, "private_key_path", private_key_path)
        if skip_host_key_validation is not None:
            pulumi.set(__self__, "skip_host_key_validation", skip_host_key_validation)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        The SFTP server host name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[str]:
        """
        The authentication type to be used to connect to the FTP server.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter(name="hostKeyFingerprint")
    def host_key_fingerprint(self) -> Optional[Any]:
        """
        The host key finger-print of the SFTP server. When SkipHostKeyValidation is false, HostKeyFingerprint should be specified. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "host_key_fingerprint")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="passPhrase")
    def pass_phrase(self) -> Optional[Any]:
        """
        The password to decrypt the SSH private key if the SSH private key is encrypted.
        """
        return pulumi.get(self, "pass_phrase")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password to logon the SFTP server for Basic authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[Any]:
        """
        The TCP port number that the SFTP server uses to listen for client connections. Default value is 22. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="privateKeyContent")
    def private_key_content(self) -> Optional[Any]:
        """
        Base64 encoded SSH private key content for SshPublicKey authentication. For on-premises copy with SshPublicKey authentication, either PrivateKeyPath or PrivateKeyContent should be specified. SSH private key should be OpenSSH format.
        """
        return pulumi.get(self, "private_key_content")

    @property
    @pulumi.getter(name="privateKeyPath")
    def private_key_path(self) -> Optional[Any]:
        """
        The SSH private key file path for SshPublicKey authentication. Only valid for on-premises copy. For on-premises copy with SshPublicKey authentication, either PrivateKeyPath or PrivateKeyContent should be specified. SSH private key should be OpenSSH format. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "private_key_path")

    @property
    @pulumi.getter(name="skipHostKeyValidation")
    def skip_host_key_validation(self) -> Optional[Any]:
        """
        If true, skip the SSH host key validation. Default value is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "skip_host_key_validation")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        The username used to log on to the SFTP server. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SharePointOnlineListLinkedServiceResponse(dict):
    """
    SharePoint Online List linked service.
    """
    def __init__(__self__, *,
                 service_principal_id: Any,
                 service_principal_key: Any,
                 site_url: Any,
                 tenant_id: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None):
        """
        SharePoint Online List linked service.
        :param Any service_principal_id: The application (client) ID of your application registered in Azure Active Directory. Make sure to grant SharePoint site permission to this application. Type: string (or Expression with resultType string).
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] service_principal_key: The client secret of your application registered in Azure Active Directory. Type: string (or Expression with resultType string).
        :param Any site_url: The URL of the SharePoint Online site. For example, https://contoso.sharepoint.com/sites/siteName. Type: string (or Expression with resultType string).
        :param Any tenant_id: The tenant ID under which your application resides. You can find it from Azure portal Active Directory overview page. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "service_principal_key", service_principal_key)
        pulumi.set(__self__, "site_url", site_url)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", 'SharePointOnlineList')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Any:
        """
        The application (client) ID of your application registered in Azure Active Directory. Make sure to grant SharePoint site permission to this application. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="servicePrincipalKey")
    def service_principal_key(self) -> Any:
        """
        The client secret of your application registered in Azure Active Directory. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "service_principal_key")

    @property
    @pulumi.getter(name="siteUrl")
    def site_url(self) -> Any:
        """
        The URL of the SharePoint Online site. For example, https://contoso.sharepoint.com/sites/siteName. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "site_url")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Any:
        """
        The tenant ID under which your application resides. You can find it from Azure portal Active Directory overview page. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SharePointOnlineListResourceDatasetResponse(dict):
    """
    The sharepoint online list resource dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 list_name: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The sharepoint online list resource dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any list_name: The name of the SharePoint Online list. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SharePointOnlineListResource')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if list_name is not None:
            pulumi.set(__self__, "list_name", list_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter(name="listName")
    def list_name(self) -> Optional[Any]:
        """
        The name of the SharePoint Online list. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "list_name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ShopifyLinkedServiceResponse(dict):
    """
    Shopify Service linked service.
    """
    def __init__(__self__, *,
                 host: Any,
                 type: str,
                 access_token: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Shopify Service linked service.
        :param Any host: The endpoint of the Shopify server. (i.e. mystore.myshopify.com)
        :param str type: Type of linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] access_token: The API access token that can be used to access Shopify’s data. The token won't expire if it is offline mode.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "type", 'Shopify')
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        The endpoint of the Shopify server. (i.e. mystore.myshopify.com)
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[Any]:
        """
        The API access token that can be used to access Shopify’s data. The token won't expire if it is offline mode.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ShopifyObjectDatasetResponse(dict):
    """
    Shopify Service dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Shopify Service dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'ShopifyObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SnowflakeDatasetResponse(dict):
    """
    The snowflake dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None):
        """
        The snowflake dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Snowflake database. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SnowflakeTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Snowflake database. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SnowflakeLinkedServiceResponse(dict):
    """
    Snowflake linked service.
    """
    def __init__(__self__, *,
                 connection_string: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None):
        """
        Snowflake linked service.
        :param Any connection_string: The connection string of snowflake. Type: string, SecureString.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' password: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'Snowflake')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The connection string of snowflake. Type: string, SecureString.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "password")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SparkLinkedServiceResponse(dict):
    """
    Spark Server linked service.
    """
    def __init__(__self__, *,
                 authentication_type: str,
                 host: Any,
                 port: Any,
                 type: str,
                 allow_host_name_cn_mismatch: Optional[Any] = None,
                 allow_self_signed_server_cert: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 enable_ssl: Optional[Any] = None,
                 encrypted_credential: Optional[Any] = None,
                 http_path: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 server_type: Optional[str] = None,
                 thrift_transport_protocol: Optional[str] = None,
                 trusted_cert_path: Optional[Any] = None,
                 use_system_trust_store: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Spark Server linked service.
        :param str authentication_type: The authentication method used to access the Spark server.
        :param Any host: IP address or host name of the Spark server
        :param Any port: The TCP port that the Spark server uses to listen for client connections.
        :param str type: Type of linked service.
        :param Any allow_host_name_cn_mismatch: Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        :param Any allow_self_signed_server_cert: Specifies whether to allow self-signed certificates from the server. The default value is false.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any enable_ssl: Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any http_path: The partial URL corresponding to the Spark server.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: The password corresponding to the user name that you provided in the Username field
        :param str server_type: The type of Spark server.
        :param str thrift_transport_protocol: The transport protocol to use in the Thrift layer.
        :param Any trusted_cert_path: The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        :param Any use_system_trust_store: Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        :param Any username: The user name that you use to access Spark Server.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "type", 'Spark')
        if allow_host_name_cn_mismatch is not None:
            pulumi.set(__self__, "allow_host_name_cn_mismatch", allow_host_name_cn_mismatch)
        if allow_self_signed_server_cert is not None:
            pulumi.set(__self__, "allow_self_signed_server_cert", allow_self_signed_server_cert)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_ssl is not None:
            pulumi.set(__self__, "enable_ssl", enable_ssl)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if http_path is not None:
            pulumi.set(__self__, "http_path", http_path)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if server_type is not None:
            pulumi.set(__self__, "server_type", server_type)
        if thrift_transport_protocol is not None:
            pulumi.set(__self__, "thrift_transport_protocol", thrift_transport_protocol)
        if trusted_cert_path is not None:
            pulumi.set(__self__, "trusted_cert_path", trusted_cert_path)
        if use_system_trust_store is not None:
            pulumi.set(__self__, "use_system_trust_store", use_system_trust_store)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        The authentication method used to access the Spark server.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter
    def host(self) -> Any:
        """
        IP address or host name of the Spark server
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Any:
        """
        The TCP port that the Spark server uses to listen for client connections.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="allowHostNameCNMismatch")
    def allow_host_name_cn_mismatch(self) -> Optional[Any]:
        """
        Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
        """
        return pulumi.get(self, "allow_host_name_cn_mismatch")

    @property
    @pulumi.getter(name="allowSelfSignedServerCert")
    def allow_self_signed_server_cert(self) -> Optional[Any]:
        """
        Specifies whether to allow self-signed certificates from the server. The default value is false.
        """
        return pulumi.get(self, "allow_self_signed_server_cert")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="enableSsl")
    def enable_ssl(self) -> Optional[Any]:
        """
        Specifies whether the connections to the server are encrypted using SSL. The default value is false.
        """
        return pulumi.get(self, "enable_ssl")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter(name="httpPath")
    def http_path(self) -> Optional[Any]:
        """
        The partial URL corresponding to the Spark server.
        """
        return pulumi.get(self, "http_path")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        The password corresponding to the user name that you provided in the Username field
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> Optional[str]:
        """
        The type of Spark server.
        """
        return pulumi.get(self, "server_type")

    @property
    @pulumi.getter(name="thriftTransportProtocol")
    def thrift_transport_protocol(self) -> Optional[str]:
        """
        The transport protocol to use in the Thrift layer.
        """
        return pulumi.get(self, "thrift_transport_protocol")

    @property
    @pulumi.getter(name="trustedCertPath")
    def trusted_cert_path(self) -> Optional[Any]:
        """
        The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the IR.
        """
        return pulumi.get(self, "trusted_cert_path")

    @property
    @pulumi.getter(name="useSystemTrustStore")
    def use_system_trust_store(self) -> Optional[Any]:
        """
        Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
        """
        return pulumi.get(self, "use_system_trust_store")

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        The user name that you use to access Spark Server.
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SparkObjectDatasetResponse(dict):
    """
    Spark Server dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Spark Server dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Spark. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SparkObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Spark. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SqlServerLinkedServiceResponse(dict):
    """
    SQL Server linked service.
    """
    def __init__(__self__, *,
                 connection_string: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 user_name: Optional[Any] = None):
        """
        SQL Server linked service.
        :param Any connection_string: The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: The on-premises Windows authentication password.
        :param Any user_name: The on-premises Windows authentication user name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "type", 'SqlServer')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Any:
        """
        The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        The on-premises Windows authentication password.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[Any]:
        """
        The on-premises Windows authentication user name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SqlServerTableDatasetResponse(dict):
    """
    The on-premises SQL Server dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The on-premises SQL Server dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the SQL Server dataset. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SqlServerTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the SQL Server dataset. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SquareLinkedServiceResponse(dict):
    """
    Square Service linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 client_id: Optional[Any] = None,
                 client_secret: Optional[Any] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_properties: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 host: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 redirect_uri: Optional[Any] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Square Service linked service.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param Any client_id: The client ID associated with your Square application.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] client_secret: The client secret associated with your Square application.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_properties: Properties used to connect to Square. It is mutually exclusive with any other properties in the linked service. Type: object.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any host: The URL of the Square instance. (i.e. mystore.mysquare.com)
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Any redirect_uri: The redirect URL assigned in the Square application dashboard. (i.e. http://localhost:2500)
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "type", 'Square')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_properties is not None:
            pulumi.set(__self__, "connection_properties", connection_properties)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if redirect_uri is not None:
            pulumi.set(__self__, "redirect_uri", redirect_uri)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[Any]:
        """
        The client ID associated with your Square application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[Any]:
        """
        The client secret associated with your Square application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionProperties")
    def connection_properties(self) -> Optional[Any]:
        """
        Properties used to connect to Square. It is mutually exclusive with any other properties in the linked service. Type: object.
        """
        return pulumi.get(self, "connection_properties")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def host(self) -> Optional[Any]:
        """
        The URL of the Square instance. (i.e. mystore.mysquare.com)
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[Any]:
        """
        The redirect URL assigned in the Square application dashboard. (i.e. http://localhost:2500)
        """
        return pulumi.get(self, "redirect_uri")

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SquareObjectDatasetResponse(dict):
    """
    Square Service dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Square Service dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SquareObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SsisEnvironmentReferenceResponseResult(dict):
    """
    Ssis environment reference.
    """
    def __init__(__self__, *,
                 environment_folder_name: Optional[str] = None,
                 environment_name: Optional[str] = None,
                 id: Optional[int] = None,
                 reference_type: Optional[str] = None):
        """
        Ssis environment reference.
        :param str environment_folder_name: Environment folder name.
        :param str environment_name: Environment name.
        :param int id: Environment reference id.
        :param str reference_type: Reference type
        """
        if environment_folder_name is not None:
            pulumi.set(__self__, "environment_folder_name", environment_folder_name)
        if environment_name is not None:
            pulumi.set(__self__, "environment_name", environment_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if reference_type is not None:
            pulumi.set(__self__, "reference_type", reference_type)

    @property
    @pulumi.getter(name="environmentFolderName")
    def environment_folder_name(self) -> Optional[str]:
        """
        Environment folder name.
        """
        return pulumi.get(self, "environment_folder_name")

    @property
    @pulumi.getter(name="environmentName")
    def environment_name(self) -> Optional[str]:
        """
        Environment name.
        """
        return pulumi.get(self, "environment_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Environment reference id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="referenceType")
    def reference_type(self) -> Optional[str]:
        """
        Reference type
        """
        return pulumi.get(self, "reference_type")


@pulumi.output_type
class SsisEnvironmentResponseResult(dict):
    """
    Ssis environment.
    """
    def __init__(__self__, *,
                 type: str,
                 description: Optional[str] = None,
                 folder_id: Optional[int] = None,
                 id: Optional[int] = None,
                 name: Optional[str] = None,
                 variables: Optional[Sequence['outputs.SsisVariableResponseResult']] = None):
        """
        Ssis environment.
        :param str type: Type of metadata.
        :param str description: Metadata description.
        :param int folder_id: Folder id which contains environment.
        :param int id: Metadata id.
        :param str name: Metadata name.
        :param Sequence['SsisVariableResponseArgs'] variables: Variable in environment
        """
        pulumi.set(__self__, "type", 'Environment')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of metadata.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Metadata description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[int]:
        """
        Folder id which contains environment.
        """
        return pulumi.get(self, "folder_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Metadata id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Metadata name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def variables(self) -> Optional[Sequence['outputs.SsisVariableResponseResult']]:
        """
        Variable in environment
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class SsisFolderResponseResult(dict):
    """
    Ssis folder.
    """
    def __init__(__self__, *,
                 type: str,
                 description: Optional[str] = None,
                 id: Optional[int] = None,
                 name: Optional[str] = None):
        """
        Ssis folder.
        :param str type: Type of metadata.
        :param str description: Metadata description.
        :param int id: Metadata id.
        :param str name: Metadata name.
        """
        pulumi.set(__self__, "type", 'Folder')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of metadata.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Metadata description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Metadata id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Metadata name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SsisPackageResponseResult(dict):
    """
    Ssis Package.
    """
    def __init__(__self__, *,
                 type: str,
                 description: Optional[str] = None,
                 folder_id: Optional[int] = None,
                 id: Optional[int] = None,
                 name: Optional[str] = None,
                 parameters: Optional[Sequence['outputs.SsisParameterResponseResult']] = None,
                 project_id: Optional[int] = None,
                 project_version: Optional[int] = None):
        """
        Ssis Package.
        :param str type: Type of metadata.
        :param str description: Metadata description.
        :param int folder_id: Folder id which contains package.
        :param int id: Metadata id.
        :param str name: Metadata name.
        :param Sequence['SsisParameterResponseArgs'] parameters: Parameters in package
        :param int project_id: Project id which contains package.
        :param int project_version: Project version which contains package.
        """
        pulumi.set(__self__, "type", 'Package')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if project_version is not None:
            pulumi.set(__self__, "project_version", project_version)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of metadata.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Metadata description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[int]:
        """
        Folder id which contains package.
        """
        return pulumi.get(self, "folder_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Metadata id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Metadata name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.SsisParameterResponseResult']]:
        """
        Parameters in package
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[int]:
        """
        Project id which contains package.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="projectVersion")
    def project_version(self) -> Optional[int]:
        """
        Project version which contains package.
        """
        return pulumi.get(self, "project_version")


@pulumi.output_type
class SsisParameterResponseResult(dict):
    """
    Ssis parameter.
    """
    def __init__(__self__, *,
                 data_type: Optional[str] = None,
                 default_value: Optional[str] = None,
                 description: Optional[str] = None,
                 design_default_value: Optional[str] = None,
                 id: Optional[int] = None,
                 name: Optional[str] = None,
                 required: Optional[bool] = None,
                 sensitive: Optional[bool] = None,
                 sensitive_default_value: Optional[str] = None,
                 value_set: Optional[bool] = None,
                 value_type: Optional[str] = None,
                 variable: Optional[str] = None):
        """
        Ssis parameter.
        :param str data_type: Parameter type.
        :param str default_value: Default value of parameter.
        :param str description: Parameter description.
        :param str design_default_value: Design default value of parameter.
        :param int id: Parameter id.
        :param str name: Parameter name.
        :param bool required: Whether parameter is required.
        :param bool sensitive: Whether parameter is sensitive.
        :param str sensitive_default_value: Default sensitive value of parameter.
        :param bool value_set: Parameter value set.
        :param str value_type: Parameter value type.
        :param str variable: Parameter reference variable.
        """
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if design_default_value is not None:
            pulumi.set(__self__, "design_default_value", design_default_value)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if sensitive is not None:
            pulumi.set(__self__, "sensitive", sensitive)
        if sensitive_default_value is not None:
            pulumi.set(__self__, "sensitive_default_value", sensitive_default_value)
        if value_set is not None:
            pulumi.set(__self__, "value_set", value_set)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)
        if variable is not None:
            pulumi.set(__self__, "variable", variable)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[str]:
        """
        Parameter type.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[str]:
        """
        Default value of parameter.
        """
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Parameter description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="designDefaultValue")
    def design_default_value(self) -> Optional[str]:
        """
        Design default value of parameter.
        """
        return pulumi.get(self, "design_default_value")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Parameter id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Parameter name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def required(self) -> Optional[bool]:
        """
        Whether parameter is required.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter
    def sensitive(self) -> Optional[bool]:
        """
        Whether parameter is sensitive.
        """
        return pulumi.get(self, "sensitive")

    @property
    @pulumi.getter(name="sensitiveDefaultValue")
    def sensitive_default_value(self) -> Optional[str]:
        """
        Default sensitive value of parameter.
        """
        return pulumi.get(self, "sensitive_default_value")

    @property
    @pulumi.getter(name="valueSet")
    def value_set(self) -> Optional[bool]:
        """
        Parameter value set.
        """
        return pulumi.get(self, "value_set")

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[str]:
        """
        Parameter value type.
        """
        return pulumi.get(self, "value_type")

    @property
    @pulumi.getter
    def variable(self) -> Optional[str]:
        """
        Parameter reference variable.
        """
        return pulumi.get(self, "variable")


@pulumi.output_type
class SsisProjectResponseResult(dict):
    """
    Ssis project.
    """
    def __init__(__self__, *,
                 type: str,
                 description: Optional[str] = None,
                 environment_refs: Optional[Sequence['outputs.SsisEnvironmentReferenceResponseResult']] = None,
                 folder_id: Optional[int] = None,
                 id: Optional[int] = None,
                 name: Optional[str] = None,
                 parameters: Optional[Sequence['outputs.SsisParameterResponseResult']] = None,
                 version: Optional[int] = None):
        """
        Ssis project.
        :param str type: Type of metadata.
        :param str description: Metadata description.
        :param Sequence['SsisEnvironmentReferenceResponseArgs'] environment_refs: Environment reference in project
        :param int folder_id: Folder id which contains project.
        :param int id: Metadata id.
        :param str name: Metadata name.
        :param Sequence['SsisParameterResponseArgs'] parameters: Parameters in project
        :param int version: Project version.
        """
        pulumi.set(__self__, "type", 'Project')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if environment_refs is not None:
            pulumi.set(__self__, "environment_refs", environment_refs)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of metadata.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Metadata description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="environmentRefs")
    def environment_refs(self) -> Optional[Sequence['outputs.SsisEnvironmentReferenceResponseResult']]:
        """
        Environment reference in project
        """
        return pulumi.get(self, "environment_refs")

    @property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[int]:
        """
        Folder id which contains project.
        """
        return pulumi.get(self, "folder_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Metadata id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Metadata name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.SsisParameterResponseResult']]:
        """
        Parameters in project
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def version(self) -> Optional[int]:
        """
        Project version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SsisVariableResponseResult(dict):
    """
    Ssis variable.
    """
    def __init__(__self__, *,
                 data_type: Optional[str] = None,
                 description: Optional[str] = None,
                 id: Optional[int] = None,
                 name: Optional[str] = None,
                 sensitive: Optional[bool] = None,
                 sensitive_value: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Ssis variable.
        :param str data_type: Variable type.
        :param str description: Variable description.
        :param int id: Variable id.
        :param str name: Variable name.
        :param bool sensitive: Whether variable is sensitive.
        :param str sensitive_value: Variable sensitive value.
        :param str value: Variable value.
        """
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sensitive is not None:
            pulumi.set(__self__, "sensitive", sensitive)
        if sensitive_value is not None:
            pulumi.set(__self__, "sensitive_value", sensitive_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[str]:
        """
        Variable type.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Variable description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Variable id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Variable name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def sensitive(self) -> Optional[bool]:
        """
        Whether variable is sensitive.
        """
        return pulumi.get(self, "sensitive")

    @property
    @pulumi.getter(name="sensitiveValue")
    def sensitive_value(self) -> Optional[str]:
        """
        Variable sensitive value.
        """
        return pulumi.get(self, "sensitive_value")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Variable value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SybaseLinkedServiceResponse(dict):
    """
    Linked service for Sybase data source.
    """
    def __init__(__self__, *,
                 database: Any,
                 server: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 authentication_type: Optional[str] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 schema: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Linked service for Sybase data source.
        :param Any database: Database name for connection. Type: string (or Expression with resultType string).
        :param Any server: Server name for connection. Type: string (or Expression with resultType string).
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param str authentication_type: AuthenticationType to be used for connection.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password for authentication.
        :param Any schema: Schema name for connection. Type: string (or Expression with resultType string).
        :param Any username: Username for authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "server", server)
        pulumi.set(__self__, "type", 'Sybase')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> Any:
        """
        Database name for connection. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def server(self) -> Any:
        """
        Server name for connection. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[str]:
        """
        AuthenticationType to be used for connection.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password for authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Schema name for connection. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        Username for authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SybaseTableDatasetResponse(dict):
    """
    The Sybase table dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        The Sybase table dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The Sybase table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'SybaseTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The Sybase table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TeradataLinkedServiceResponse(dict):
    """
    Linked service for Teradata data source.
    """
    def __init__(__self__, *,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 authentication_type: Optional[str] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 password: Optional[Any] = None,
                 server: Optional[Any] = None,
                 username: Optional[Any] = None):
        """
        Linked service for Teradata data source.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param str authentication_type: AuthenticationType to be used for connection.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_string: Teradata ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password for authentication.
        :param Any server: Server name for connection. Type: string (or Expression with resultType string).
        :param Any username: Username for authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "type", 'Teradata')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[str]:
        """
        AuthenticationType to be used for connection.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        Teradata ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def password(self) -> Optional[Any]:
        """
        Password for authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def server(self) -> Optional[Any]:
        """
        Server name for connection. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def username(self) -> Optional[Any]:
        """
        Username for authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TeradataTableDatasetResponse(dict):
    """
    The Teradata database dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 database: Optional[Any] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None):
        """
        The Teradata database dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param Any database: The database name of Teradata. Type: string (or Expression with resultType string).
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of Teradata. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'TeradataTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def database(self) -> Optional[Any]:
        """
        The database name of Teradata. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of Teradata. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TextFormatResponse(dict):
    """
    The data stored in text format.
    """
    def __init__(__self__, *,
                 type: str,
                 column_delimiter: Optional[Any] = None,
                 deserializer: Optional[Any] = None,
                 encoding_name: Optional[Any] = None,
                 escape_char: Optional[Any] = None,
                 first_row_as_header: Optional[Any] = None,
                 null_value: Optional[Any] = None,
                 quote_char: Optional[Any] = None,
                 row_delimiter: Optional[Any] = None,
                 serializer: Optional[Any] = None,
                 skip_line_count: Optional[Any] = None,
                 treat_empty_as_null: Optional[Any] = None):
        """
        The data stored in text format.
        :param str type: Type of dataset storage format.
        :param Any column_delimiter: The column delimiter. Type: string (or Expression with resultType string).
        :param Any deserializer: Deserializer. Type: string (or Expression with resultType string).
        :param Any encoding_name: The code page name of the preferred encoding. If miss, the default value is ΓÇ£utf-8ΓÇ¥, unless BOM denotes another Unicode encoding. Refer to the ΓÇ£NameΓÇ¥ column of the table in the following link to set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType string).
        :param Any escape_char: The escape character. Type: string (or Expression with resultType string).
        :param Any first_row_as_header: When used as input, treat the first row of data as headers. When used as output,write the headers into the output as the first row of data. The default value is false. Type: boolean (or Expression with resultType boolean).
        :param Any null_value: The null value string. Type: string (or Expression with resultType string).
        :param Any quote_char: The quote character. Type: string (or Expression with resultType string).
        :param Any row_delimiter: The row delimiter. Type: string (or Expression with resultType string).
        :param Any serializer: Serializer. Type: string (or Expression with resultType string).
        :param Any skip_line_count: The number of lines/rows to be skipped when parsing text files. The default value is 0. Type: integer (or Expression with resultType integer).
        :param Any treat_empty_as_null: Treat empty column values in the text file as null. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        pulumi.set(__self__, "type", 'TextFormat')
        if column_delimiter is not None:
            pulumi.set(__self__, "column_delimiter", column_delimiter)
        if deserializer is not None:
            pulumi.set(__self__, "deserializer", deserializer)
        if encoding_name is not None:
            pulumi.set(__self__, "encoding_name", encoding_name)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if first_row_as_header is not None:
            pulumi.set(__self__, "first_row_as_header", first_row_as_header)
        if null_value is not None:
            pulumi.set(__self__, "null_value", null_value)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if row_delimiter is not None:
            pulumi.set(__self__, "row_delimiter", row_delimiter)
        if serializer is not None:
            pulumi.set(__self__, "serializer", serializer)
        if skip_line_count is not None:
            pulumi.set(__self__, "skip_line_count", skip_line_count)
        if treat_empty_as_null is not None:
            pulumi.set(__self__, "treat_empty_as_null", treat_empty_as_null)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset storage format.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="columnDelimiter")
    def column_delimiter(self) -> Optional[Any]:
        """
        The column delimiter. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "column_delimiter")

    @property
    @pulumi.getter
    def deserializer(self) -> Optional[Any]:
        """
        Deserializer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "deserializer")

    @property
    @pulumi.getter(name="encodingName")
    def encoding_name(self) -> Optional[Any]:
        """
        The code page name of the preferred encoding. If miss, the default value is ΓÇ£utf-8ΓÇ¥, unless BOM denotes another Unicode encoding. Refer to the ΓÇ£NameΓÇ¥ column of the table in the following link to set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encoding_name")

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[Any]:
        """
        The escape character. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "escape_char")

    @property
    @pulumi.getter(name="firstRowAsHeader")
    def first_row_as_header(self) -> Optional[Any]:
        """
        When used as input, treat the first row of data as headers. When used as output,write the headers into the output as the first row of data. The default value is false. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "first_row_as_header")

    @property
    @pulumi.getter(name="nullValue")
    def null_value(self) -> Optional[Any]:
        """
        The null value string. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "null_value")

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[Any]:
        """
        The quote character. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "quote_char")

    @property
    @pulumi.getter(name="rowDelimiter")
    def row_delimiter(self) -> Optional[Any]:
        """
        The row delimiter. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "row_delimiter")

    @property
    @pulumi.getter
    def serializer(self) -> Optional[Any]:
        """
        Serializer. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "serializer")

    @property
    @pulumi.getter(name="skipLineCount")
    def skip_line_count(self) -> Optional[Any]:
        """
        The number of lines/rows to be skipped when parsing text files. The default value is 0. Type: integer (or Expression with resultType integer).
        """
        return pulumi.get(self, "skip_line_count")

    @property
    @pulumi.getter(name="treatEmptyAsNull")
    def treat_empty_as_null(self) -> Optional[Any]:
        """
        Treat empty column values in the text file as null. The default value is true. Type: boolean (or Expression with resultType boolean).
        """
        return pulumi.get(self, "treat_empty_as_null")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TransformationResponse(dict):
    """
    A data flow transformation.
    """
    def __init__(__self__, *,
                 name: str,
                 description: Optional[str] = None):
        """
        A data flow transformation.
        :param str name: Transformation name.
        :param str description: Transformation description.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Transformation name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Transformation description.
        """
        return pulumi.get(self, "description")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TriggerDependencyReferenceResponse(dict):
    """
    Trigger referenced dependency.
    """
    def __init__(__self__, *,
                 reference_trigger: 'outputs.TriggerReferenceResponse',
                 type: str):
        """
        Trigger referenced dependency.
        :param 'TriggerReferenceResponseArgs' reference_trigger: Referenced trigger.
        :param str type: The type of dependency reference.
        """
        pulumi.set(__self__, "reference_trigger", reference_trigger)
        pulumi.set(__self__, "type", 'TriggerDependencyReference')

    @property
    @pulumi.getter(name="referenceTrigger")
    def reference_trigger(self) -> 'outputs.TriggerReferenceResponse':
        """
        Referenced trigger.
        """
        return pulumi.get(self, "reference_trigger")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of dependency reference.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TriggerPipelineReferenceResponse(dict):
    """
    Pipeline that needs to be triggered with the given parameters.
    """
    def __init__(__self__, *,
                 parameters: Optional[Mapping[str, Any]] = None,
                 pipeline_reference: Optional['outputs.PipelineReferenceResponse'] = None):
        """
        Pipeline that needs to be triggered with the given parameters.
        :param Mapping[str, Any] parameters: Pipeline parameters.
        :param 'PipelineReferenceResponseArgs' pipeline_reference: Pipeline reference.
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if pipeline_reference is not None:
            pulumi.set(__self__, "pipeline_reference", pipeline_reference)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, Any]]:
        """
        Pipeline parameters.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="pipelineReference")
    def pipeline_reference(self) -> Optional['outputs.PipelineReferenceResponse']:
        """
        Pipeline reference.
        """
        return pulumi.get(self, "pipeline_reference")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TriggerReferenceResponse(dict):
    """
    Trigger reference type.
    """
    def __init__(__self__, *,
                 reference_name: str,
                 type: str):
        """
        Trigger reference type.
        :param str reference_name: Reference trigger name.
        :param str type: Trigger reference type.
        """
        pulumi.set(__self__, "reference_name", reference_name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> str:
        """
        Reference trigger name.
        """
        return pulumi.get(self, "reference_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Trigger reference type.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class TumblingWindowTriggerResponse(dict):
    """
    Trigger that schedules pipeline runs for all fixed time interval windows from a start time without gaps and also supports backfill scenarios (when start time is in the past).
    """
    def __init__(__self__, *,
                 frequency: str,
                 interval: int,
                 max_concurrency: int,
                 pipeline: 'outputs.TriggerPipelineReferenceResponse',
                 runtime_state: str,
                 start_time: str,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 delay: Optional[Any] = None,
                 depends_on: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 end_time: Optional[str] = None,
                 retry_policy: Optional['outputs.RetryPolicyResponse'] = None):
        """
        Trigger that schedules pipeline runs for all fixed time interval windows from a start time without gaps and also supports backfill scenarios (when start time is in the past).
        :param str frequency: The frequency of the time windows.
        :param int interval: The interval of the time windows. The minimum interval allowed is 15 Minutes.
        :param int max_concurrency: The max number of parallel time windows (ready for execution) for which a new run is triggered.
        :param 'TriggerPipelineReferenceResponseArgs' pipeline: Pipeline for which runs are created when an event is fired for trigger window that is ready.
        :param str runtime_state: Indicates if trigger is running or not. Updated when Start/Stop APIs are called on the Trigger.
        :param str start_time: The start time for the time period for the trigger during which events are fired for windows that are ready. Only UTC time is currently supported.
        :param str type: Trigger type.
        :param Sequence[Any] annotations: List of tags that can be used for describing the trigger.
        :param Any delay: Specifies how long the trigger waits past due time before triggering new run. It doesn't alter window start and end time. The default is 0. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        :param Sequence[Union['SelfDependencyTumblingWindowTriggerReferenceResponseArgs', 'TriggerDependencyReferenceResponseArgs']] depends_on: Triggers that this trigger depends on. Only tumbling window triggers are supported.
        :param str description: Trigger description.
        :param str end_time: The end time for the time period for the trigger during which events are fired for windows that are ready. Only UTC time is currently supported.
        :param 'RetryPolicyResponseArgs' retry_policy: Retry policy that will be applied for failed pipeline runs.
        """
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "max_concurrency", max_concurrency)
        pulumi.set(__self__, "pipeline", pipeline)
        pulumi.set(__self__, "runtime_state", runtime_state)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "type", 'TumblingWindowTrigger')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)

    @property
    @pulumi.getter
    def frequency(self) -> str:
        """
        The frequency of the time windows.
        """
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter
    def interval(self) -> int:
        """
        The interval of the time windows. The minimum interval allowed is 15 Minutes.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> int:
        """
        The max number of parallel time windows (ready for execution) for which a new run is triggered.
        """
        return pulumi.get(self, "max_concurrency")

    @property
    @pulumi.getter
    def pipeline(self) -> 'outputs.TriggerPipelineReferenceResponse':
        """
        Pipeline for which runs are created when an event is fired for trigger window that is ready.
        """
        return pulumi.get(self, "pipeline")

    @property
    @pulumi.getter(name="runtimeState")
    def runtime_state(self) -> str:
        """
        Indicates if trigger is running or not. Updated when Start/Stop APIs are called on the Trigger.
        """
        return pulumi.get(self, "runtime_state")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        The start time for the time period for the trigger during which events are fired for windows that are ready. Only UTC time is currently supported.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Trigger type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the trigger.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def delay(self) -> Optional[Any]:
        """
        Specifies how long the trigger waits past due time before triggering new run. It doesn't alter window start and end time. The default is 0. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        """
        return pulumi.get(self, "delay")

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[Sequence[Any]]:
        """
        Triggers that this trigger depends on. Only tumbling window triggers are supported.
        """
        return pulumi.get(self, "depends_on")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Trigger description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        The end time for the time period for the trigger during which events are fired for windows that are ready. Only UTC time is currently supported.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.RetryPolicyResponse']:
        """
        Retry policy that will be applied for failed pipeline runs.
        """
        return pulumi.get(self, "retry_policy")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UserAccessPolicyResponseResult(dict):
    """
    Get Data Plane read only token request definition.
    """
    def __init__(__self__, *,
                 access_resource_path: Optional[str] = None,
                 expire_time: Optional[str] = None,
                 permissions: Optional[str] = None,
                 profile_name: Optional[str] = None,
                 start_time: Optional[str] = None):
        """
        Get Data Plane read only token request definition.
        :param str access_resource_path: The resource path to get access relative to factory. Currently only empty string is supported which corresponds to the factory resource.
        :param str expire_time: Expiration time for the token. Maximum duration for the token is eight hours and by default the token will expire in eight hours.
        :param str permissions: The string with permissions for Data Plane access. Currently only 'r' is supported which grants read only access.
        :param str profile_name: The name of the profile. Currently only the default is supported. The default value is DefaultProfile.
        :param str start_time: Start time for the token. If not specified the current time will be used.
        """
        if access_resource_path is not None:
            pulumi.set(__self__, "access_resource_path", access_resource_path)
        if expire_time is not None:
            pulumi.set(__self__, "expire_time", expire_time)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if profile_name is not None:
            pulumi.set(__self__, "profile_name", profile_name)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="accessResourcePath")
    def access_resource_path(self) -> Optional[str]:
        """
        The resource path to get access relative to factory. Currently only empty string is supported which corresponds to the factory resource.
        """
        return pulumi.get(self, "access_resource_path")

    @property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> Optional[str]:
        """
        Expiration time for the token. Maximum duration for the token is eight hours and by default the token will expire in eight hours.
        """
        return pulumi.get(self, "expire_time")

    @property
    @pulumi.getter
    def permissions(self) -> Optional[str]:
        """
        The string with permissions for Data Plane access. Currently only 'r' is supported which grants read only access.
        """
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter(name="profileName")
    def profile_name(self) -> Optional[str]:
        """
        The name of the profile. Currently only the default is supported. The default value is DefaultProfile.
        """
        return pulumi.get(self, "profile_name")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        Start time for the token. If not specified the current time will be used.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class UserPropertyResponse(dict):
    """
    User property.
    """
    def __init__(__self__, *,
                 name: str,
                 value: Any):
        """
        User property.
        :param str name: User property name.
        :param Any value: User property value. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        User property name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Any:
        """
        User property value. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class VariableSpecificationResponse(dict):
    """
    Definition of a single variable for a Pipeline.
    """
    def __init__(__self__, *,
                 type: str,
                 default_value: Optional[Any] = None):
        """
        Definition of a single variable for a Pipeline.
        :param str type: Variable type.
        :param Any default_value: Default value of variable.
        """
        pulumi.set(__self__, "type", type)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Variable type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[Any]:
        """
        Default value of variable.
        """
        return pulumi.get(self, "default_value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class VerticaLinkedServiceResponse(dict):
    """
    Vertica linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_string: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 pwd: Optional['outputs.AzureKeyVaultSecretReferenceResponse'] = None):
        """
        Vertica linked service.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_string: An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param 'AzureKeyVaultSecretReferenceResponseArgs' pwd: The Azure key vault secret reference of password in connection string.
        """
        pulumi.set(__self__, "type", 'Vertica')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if pwd is not None:
            pulumi.set(__self__, "pwd", pwd)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[Any]:
        """
        An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def pwd(self) -> Optional['outputs.AzureKeyVaultSecretReferenceResponse']:
        """
        The Azure key vault secret reference of password in connection string.
        """
        return pulumi.get(self, "pwd")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class VerticaTableDatasetResponse(dict):
    """
    Vertica dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Vertica dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table: The table name of the Vertica. Type: string (or Expression with resultType string).
        :param Any table_name: This property will be retired. Please consider using schema + table properties instead.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'VerticaTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter
    def table(self) -> Optional[Any]:
        """
        The table name of the Vertica. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        This property will be retired. Please consider using schema + table properties instead.
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class WebAnonymousAuthenticationResponse(dict):
    """
    A WebLinkedService that uses anonymous authentication to communicate with an HTTP endpoint.
    """
    def __init__(__self__, *,
                 authentication_type: str,
                 url: Any):
        """
        A WebLinkedService that uses anonymous authentication to communicate with an HTTP endpoint.
        :param str authentication_type: Type of authentication used to connect to the web table source.
        :param Any url: The URL of the web service endpoint, e.g. http://www.microsoft.com . Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "authentication_type", 'Anonymous')
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        Type of authentication used to connect to the web table source.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        The URL of the web service endpoint, e.g. http://www.microsoft.com . Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class WebBasicAuthenticationResponse(dict):
    """
    A WebLinkedService that uses basic authentication to communicate with an HTTP endpoint.
    """
    def __init__(__self__, *,
                 authentication_type: str,
                 password: Any,
                 url: Any,
                 username: Any):
        """
        A WebLinkedService that uses basic authentication to communicate with an HTTP endpoint.
        :param str authentication_type: Type of authentication used to connect to the web table source.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: The password for Basic authentication.
        :param Any url: The URL of the web service endpoint, e.g. http://www.microsoft.com . Type: string (or Expression with resultType string).
        :param Any username: User name for Basic authentication. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "authentication_type", 'Basic')
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        Type of authentication used to connect to the web table source.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter
    def password(self) -> Any:
        """
        The password for Basic authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        The URL of the web service endpoint, e.g. http://www.microsoft.com . Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> Any:
        """
        User name for Basic authentication. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class WebClientCertificateAuthenticationResponse(dict):
    """
    A WebLinkedService that uses client certificate based authentication to communicate with an HTTP endpoint. This scheme follows mutual authentication; the server must also provide valid credentials to the client.
    """
    def __init__(__self__, *,
                 authentication_type: str,
                 password: Any,
                 pfx: Any,
                 url: Any):
        """
        A WebLinkedService that uses client certificate based authentication to communicate with an HTTP endpoint. This scheme follows mutual authentication; the server must also provide valid credentials to the client.
        :param str authentication_type: Type of authentication used to connect to the web table source.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] password: Password for the PFX file.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] pfx: Base64-encoded contents of a PFX file.
        :param Any url: The URL of the web service endpoint, e.g. http://www.microsoft.com . Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "authentication_type", 'ClientCertificate')
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "pfx", pfx)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> str:
        """
        Type of authentication used to connect to the web table source.
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter
    def password(self) -> Any:
        """
        Password for the PFX file.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def pfx(self) -> Any:
        """
        Base64-encoded contents of a PFX file.
        """
        return pulumi.get(self, "pfx")

    @property
    @pulumi.getter
    def url(self) -> Any:
        """
        The URL of the web service endpoint, e.g. http://www.microsoft.com . Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "url")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class WebLinkedServiceResponse(dict):
    """
    Web linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 type_properties: Any,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 description: Optional[str] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None):
        """
        Web linked service.
        :param str type: Type of linked service.
        :param Union['WebAnonymousAuthenticationResponseArgs', 'WebBasicAuthenticationResponseArgs', 'WebClientCertificateAuthenticationResponseArgs'] type_properties: Web linked service properties.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param str description: Linked service description.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        """
        pulumi.set(__self__, "type", 'Web')
        pulumi.set(__self__, "type_properties", type_properties)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="typeProperties")
    def type_properties(self) -> Any:
        """
        Web linked service properties.
        """
        return pulumi.get(self, "type_properties")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class WebTableDatasetResponse(dict):
    """
    The dataset points to a HTML table in the web page.
    """
    def __init__(__self__, *,
                 index: Any,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 path: Optional[Any] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        The dataset points to a HTML table in the web page.
        :param Any index: The zero-based index of the table in the web page. Type: integer (or Expression with resultType integer), minimum: 0.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any path: The relative URL to the web page from the linked service URL. Type: string (or Expression with resultType string).
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'WebTable')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter
    def index(self) -> Any:
        """
        The zero-based index of the table in the web page. Type: integer (or Expression with resultType integer), minimum: 0.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def path(self) -> Optional[Any]:
        """
        The relative URL to the web page from the linked service URL. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class XeroLinkedServiceResponse(dict):
    """
    Xero Service linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_properties: Optional[Any] = None,
                 consumer_key: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 host: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 private_key: Optional[Any] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Xero Service linked service.
        :param str type: Type of linked service.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_properties: Properties used to connect to Xero. It is mutually exclusive with any other properties in the linked service. Type: object.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] consumer_key: The consumer key associated with the Xero application.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any host: The endpoint of the Xero server. (i.e. api.xero.com)
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] private_key: The private key from the .pem file that was generated for your Xero private application. You must include all the text from the .pem file, including the Unix line endings(
               ).
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "type", 'Xero')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_properties is not None:
            pulumi.set(__self__, "connection_properties", connection_properties)
        if consumer_key is not None:
            pulumi.set(__self__, "consumer_key", consumer_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionProperties")
    def connection_properties(self) -> Optional[Any]:
        """
        Properties used to connect to Xero. It is mutually exclusive with any other properties in the linked service. Type: object.
        """
        return pulumi.get(self, "connection_properties")

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> Optional[Any]:
        """
        The consumer key associated with the Xero application.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def host(self) -> Optional[Any]:
        """
        The endpoint of the Xero server. (i.e. api.xero.com)
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[Any]:
        """
        The private key from the .pem file that was generated for your Xero private application. You must include all the text from the .pem file, including the Unix line endings(
        ).
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class XeroObjectDatasetResponse(dict):
    """
    Xero Service dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Xero Service dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'XeroObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class XmlDatasetResponse(dict):
    """
    Xml dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 location: Any,
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 compression: Optional[Any] = None,
                 description: Optional[str] = None,
                 encoding_name: Optional[Any] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 null_value: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None):
        """
        Xml dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param Union['AmazonS3LocationResponseArgs', 'AzureBlobFSLocationResponseArgs', 'AzureBlobStorageLocationResponseArgs', 'AzureDataLakeStoreLocationResponseArgs', 'AzureFileStorageLocationResponseArgs', 'FileServerLocationResponseArgs', 'FtpServerLocationResponseArgs', 'GoogleCloudStorageLocationResponseArgs', 'HdfsLocationResponseArgs', 'HttpServerLocationResponseArgs', 'SftpLocationResponseArgs'] location: The location of the json data storage.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param Union['DatasetBZip2CompressionResponseArgs', 'DatasetDeflateCompressionResponseArgs', 'DatasetGZipCompressionResponseArgs', 'DatasetTarCompressionResponseArgs', 'DatasetTarGZipCompressionResponseArgs', 'DatasetZipDeflateCompressionResponseArgs'] compression: The data compression method used for the json dataset.
        :param str description: Dataset description.
        :param Any encoding_name: The code page name of the preferred encoding. If not specified, the default value is UTF-8, unless BOM denotes another Unicode encoding. Refer to the name column of the table in the following link to set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType string).
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Any null_value: The null value string. Type: string (or Expression with resultType string).
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "type", 'Xml')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encoding_name is not None:
            pulumi.set(__self__, "encoding_name", encoding_name)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if null_value is not None:
            pulumi.set(__self__, "null_value", null_value)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def location(self) -> Any:
        """
        The location of the json data storage.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def compression(self) -> Optional[Any]:
        """
        The data compression method used for the json dataset.
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encodingName")
    def encoding_name(self) -> Optional[Any]:
        """
        The code page name of the preferred encoding. If not specified, the default value is UTF-8, unless BOM denotes another Unicode encoding. Refer to the name column of the table in the following link to set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encoding_name")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter(name="nullValue")
    def null_value(self) -> Optional[Any]:
        """
        The null value string. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "null_value")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ZohoLinkedServiceResponse(dict):
    """
    Zoho server linked service.
    """
    def __init__(__self__, *,
                 type: str,
                 access_token: Optional[Any] = None,
                 annotations: Optional[Sequence[Any]] = None,
                 connect_via: Optional['outputs.IntegrationRuntimeReferenceResponse'] = None,
                 connection_properties: Optional[Any] = None,
                 description: Optional[str] = None,
                 encrypted_credential: Optional[Any] = None,
                 endpoint: Optional[Any] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 use_encrypted_endpoints: Optional[Any] = None,
                 use_host_verification: Optional[Any] = None,
                 use_peer_verification: Optional[Any] = None):
        """
        Zoho server linked service.
        :param str type: Type of linked service.
        :param Union['AzureKeyVaultSecretReferenceResponseArgs', 'SecureStringResponseArgs'] access_token: The access token for Zoho authentication.
        :param Sequence[Any] annotations: List of tags that can be used for describing the linked service.
        :param 'IntegrationRuntimeReferenceResponseArgs' connect_via: The integration runtime reference.
        :param Any connection_properties: Properties used to connect to Zoho. It is mutually exclusive with any other properties in the linked service. Type: object.
        :param str description: Linked service description.
        :param Any encrypted_credential: The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        :param Any endpoint: The endpoint of the Zoho server. (i.e. crm.zoho.com/crm/private)
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for linked service.
        :param Any use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        :param Any use_host_verification: Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        :param Any use_peer_verification: Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        pulumi.set(__self__, "type", 'Zoho')
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if connection_properties is not None:
            pulumi.set(__self__, "connection_properties", connection_properties)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_credential is not None:
            pulumi.set(__self__, "encrypted_credential", encrypted_credential)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if use_encrypted_endpoints is not None:
            pulumi.set(__self__, "use_encrypted_endpoints", use_encrypted_endpoints)
        if use_host_verification is not None:
            pulumi.set(__self__, "use_host_verification", use_host_verification)
        if use_peer_verification is not None:
            pulumi.set(__self__, "use_peer_verification", use_peer_verification)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of linked service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[Any]:
        """
        The access token for Zoho authentication.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the linked service.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.IntegrationRuntimeReferenceResponse']:
        """
        The integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @property
    @pulumi.getter(name="connectionProperties")
    def connection_properties(self) -> Optional[Any]:
        """
        Properties used to connect to Zoho. It is mutually exclusive with any other properties in the linked service. Type: object.
        """
        return pulumi.get(self, "connection_properties")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Linked service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptedCredential")
    def encrypted_credential(self) -> Optional[Any]:
        """
        The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "encrypted_credential")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[Any]:
        """
        The endpoint of the Zoho server. (i.e. crm.zoho.com/crm/private)
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for linked service.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="useEncryptedEndpoints")
    def use_encrypted_endpoints(self) -> Optional[Any]:
        """
        Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
        """
        return pulumi.get(self, "use_encrypted_endpoints")

    @property
    @pulumi.getter(name="useHostVerification")
    def use_host_verification(self) -> Optional[Any]:
        """
        Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_host_verification")

    @property
    @pulumi.getter(name="usePeerVerification")
    def use_peer_verification(self) -> Optional[Any]:
        """
        Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
        """
        return pulumi.get(self, "use_peer_verification")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ZohoObjectDatasetResponse(dict):
    """
    Zoho server dataset.
    """
    def __init__(__self__, *,
                 linked_service_name: 'outputs.LinkedServiceReferenceResponse',
                 type: str,
                 annotations: Optional[Sequence[Any]] = None,
                 description: Optional[str] = None,
                 folder: Optional['outputs.DatasetResponseFolder'] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']] = None,
                 schema: Optional[Any] = None,
                 structure: Optional[Any] = None,
                 table_name: Optional[Any] = None):
        """
        Zoho server dataset.
        :param 'LinkedServiceReferenceResponseArgs' linked_service_name: Linked service reference.
        :param str type: Type of dataset.
        :param Sequence[Any] annotations: List of tags that can be used for describing the Dataset.
        :param str description: Dataset description.
        :param 'DatasetResponseFolderArgs' folder: The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        :param Mapping[str, 'ParameterSpecificationResponseArgs'] parameters: Parameters for dataset.
        :param Any schema: Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        :param Any structure: Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        :param Any table_name: The table name. Type: string (or Expression with resultType string).
        """
        pulumi.set(__self__, "linked_service_name", linked_service_name)
        pulumi.set(__self__, "type", 'ZohoObject')
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if structure is not None:
            pulumi.set(__self__, "structure", structure)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="linkedServiceName")
    def linked_service_name(self) -> 'outputs.LinkedServiceReferenceResponse':
        """
        Linked service reference.
        """
        return pulumi.get(self, "linked_service_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of dataset.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Sequence[Any]]:
        """
        List of tags that can be used for describing the Dataset.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Dataset description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def folder(self) -> Optional['outputs.DatasetResponseFolder']:
        """
        The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterSpecificationResponse']]:
        """
        Parameters for dataset.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def structure(self) -> Optional[Any]:
        """
        Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
        """
        return pulumi.get(self, "structure")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[Any]:
        """
        The table name. Type: string (or Expression with resultType string).
        """
        return pulumi.get(self, "table_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


