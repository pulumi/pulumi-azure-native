# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AntivirusRulesetResponse',
    'ApiFlowOptionsResponse',
    'ArchiveRulesetResponse',
    'ConnectionPropertiesResponse',
    'DataSizeRulesetResponse',
    'FlowProfilePropertiesResponse',
    'FlowProfileRulesetsResponse',
    'FlowPropertiesResponse',
    'FlowResponse',
    'InternalMetadataPropertiesResponse',
    'ListFlowsByPipelineConnectionResponse',
    'ManagedServiceIdentityResponse',
    'MessagingOptionsResponse',
    'MimeFilterRulesetResponse',
    'MimeTypeFilterResponse',
    'OperationStatusPropertiesResponse',
    'PendingConnectionResponse',
    'PendingFlowResponse',
    'PipelineConnectionResponse',
    'PipelineConnectionResponseProperties',
    'PipelinePropertiesResponse',
    'PlanResponse',
    'SchemaResponse',
    'SelectedResourceResponse',
    'StreamSourceAddressesResponse',
    'SubscriberResponse',
    'SystemDataResponse',
    'TextMatchResponse',
    'TextMatchingRulesetResponse',
    'UserAssignedIdentityResponse',
    'XmlFilterRulesetResponse',
]

@pulumi.output_type
class AntivirusRulesetResponse(dict):
    """
    Antivirus scanning rules for replicating data. By default, all antivirus scanning solutions are disabled.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avSolutions":
            suggest = "av_solutions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AntivirusRulesetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AntivirusRulesetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AntivirusRulesetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 av_solutions: Optional[Sequence[_builtins.str]] = None):
        """
        Antivirus scanning rules for replicating data. By default, all antivirus scanning solutions are disabled.
        :param Sequence[_builtins.str] av_solutions: Optional. The list of antiviruses to be used as a scanning solution for replicating data.
        """
        if av_solutions is not None:
            pulumi.set(__self__, "av_solutions", av_solutions)

    @_builtins.property
    @pulumi.getter(name="avSolutions")
    def av_solutions(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional. The list of antiviruses to be used as a scanning solution for replicating data.
        """
        return pulumi.get(self, "av_solutions")


@pulumi.output_type
class ApiFlowOptionsResponse(dict):
    """
    Properties specific to API Flow Type
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiMode":
            suggest = "api_mode"
        elif key == "audienceOverride":
            suggest = "audience_override"
        elif key == "identityTranslation":
            suggest = "identity_translation"
        elif key == "remoteCallingModeClientId":
            suggest = "remote_calling_mode_client_id"
        elif key == "remoteEndpoint":
            suggest = "remote_endpoint"
        elif key == "senderClientId":
            suggest = "sender_client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiFlowOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiFlowOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiFlowOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_mode: Optional[_builtins.str] = None,
                 audience_override: Optional[_builtins.str] = None,
                 cname: Optional[_builtins.str] = None,
                 identity_translation: Optional[_builtins.str] = None,
                 remote_calling_mode_client_id: Optional[_builtins.str] = None,
                 remote_endpoint: Optional[_builtins.str] = None,
                 sender_client_id: Optional[_builtins.str] = None):
        """
        Properties specific to API Flow Type
        :param _builtins.str api_mode: Remote Calling Mode in the Azure Data Transfer API Flow, which describes how the API Flow will be invoked
        :param _builtins.str audience_override: Optional field to override the audience of the remote endpoint. The property has reached end of life support starting version 2025-05-30-preview. Please create and use the authentication property instead.
        :param _builtins.str cname: Unique CNAME to represent the Azure Data Transfer API Flow instance
        :param _builtins.str identity_translation: Determines which identity to use for extracting the user token for Azure Data Transfer API Flow. The property has reached end of life support starting version 2025-05-30-preview. Please create and use the authentication property instead.
        :param _builtins.str remote_calling_mode_client_id: Remote stub app registration Client ID. The property has reached end of life support starting version 2025-05-30-preview. Please create and use the authentication property instead.
        :param _builtins.str remote_endpoint: Remote host to which communication needs to be made. The property has reached end of life support starting version 2025-05-30-preview. Please create and use the remoteEndpointSettings.endpoint property instead.
        :param _builtins.str sender_client_id: Sender's app user assigned Manage Identity client ID. The property has reached end of life support starting version 2025-05-30-preview. Please create and use the authentication property instead.
        """
        if api_mode is not None:
            pulumi.set(__self__, "api_mode", api_mode)
        if audience_override is not None:
            pulumi.set(__self__, "audience_override", audience_override)
        if cname is not None:
            pulumi.set(__self__, "cname", cname)
        if identity_translation is not None:
            pulumi.set(__self__, "identity_translation", identity_translation)
        if remote_calling_mode_client_id is not None:
            pulumi.set(__self__, "remote_calling_mode_client_id", remote_calling_mode_client_id)
        if remote_endpoint is not None:
            pulumi.set(__self__, "remote_endpoint", remote_endpoint)
        if sender_client_id is not None:
            pulumi.set(__self__, "sender_client_id", sender_client_id)

    @_builtins.property
    @pulumi.getter(name="apiMode")
    def api_mode(self) -> Optional[_builtins.str]:
        """
        Remote Calling Mode in the Azure Data Transfer API Flow, which describes how the API Flow will be invoked
        """
        return pulumi.get(self, "api_mode")

    @_builtins.property
    @pulumi.getter(name="audienceOverride")
    def audience_override(self) -> Optional[_builtins.str]:
        """
        Optional field to override the audience of the remote endpoint. The property has reached end of life support starting version 2025-05-30-preview. Please create and use the authentication property instead.
        """
        return pulumi.get(self, "audience_override")

    @_builtins.property
    @pulumi.getter
    def cname(self) -> Optional[_builtins.str]:
        """
        Unique CNAME to represent the Azure Data Transfer API Flow instance
        """
        return pulumi.get(self, "cname")

    @_builtins.property
    @pulumi.getter(name="identityTranslation")
    def identity_translation(self) -> Optional[_builtins.str]:
        """
        Determines which identity to use for extracting the user token for Azure Data Transfer API Flow. The property has reached end of life support starting version 2025-05-30-preview. Please create and use the authentication property instead.
        """
        return pulumi.get(self, "identity_translation")

    @_builtins.property
    @pulumi.getter(name="remoteCallingModeClientId")
    def remote_calling_mode_client_id(self) -> Optional[_builtins.str]:
        """
        Remote stub app registration Client ID. The property has reached end of life support starting version 2025-05-30-preview. Please create and use the authentication property instead.
        """
        return pulumi.get(self, "remote_calling_mode_client_id")

    @_builtins.property
    @pulumi.getter(name="remoteEndpoint")
    def remote_endpoint(self) -> Optional[_builtins.str]:
        """
        Remote host to which communication needs to be made. The property has reached end of life support starting version 2025-05-30-preview. Please create and use the remoteEndpointSettings.endpoint property instead.
        """
        return pulumi.get(self, "remote_endpoint")

    @_builtins.property
    @pulumi.getter(name="senderClientId")
    def sender_client_id(self) -> Optional[_builtins.str]:
        """
        Sender's app user assigned Manage Identity client ID. The property has reached end of life support starting version 2025-05-30-preview. Please create and use the authentication property instead.
        """
        return pulumi.get(self, "sender_client_id")


@pulumi.output_type
class ArchiveRulesetResponse(dict):
    """
    Rules for regulating supported archive files (BZip2, Cpio, Deb, GZip, Rpm, Tar, Zip) during data replication. All properties are optional and only the configured options will be applied against archives. As an example, suppose minimumSizeForExpansion is 10 MiB and maximumExpansionSizeLimit is 1 GiB. Then all archives smaller than 10 MiB will be treated as though the archive ruleset is disabled, although other rulesets will apply as usual. Furthermore, all archives at least 10 MiB in size but with a decompressed size greater than 1 GiB will fail the ruleset. All other archives will have their contents extracted and each extracted element will be applied to all rulesets.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumCompressionRatioLimit":
            suggest = "maximum_compression_ratio_limit"
        elif key == "maximumDepthLimit":
            suggest = "maximum_depth_limit"
        elif key == "maximumExpansionSizeLimit":
            suggest = "maximum_expansion_size_limit"
        elif key == "minimumSizeForExpansion":
            suggest = "minimum_size_for_expansion"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArchiveRulesetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArchiveRulesetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArchiveRulesetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_compression_ratio_limit: Optional[_builtins.float] = None,
                 maximum_depth_limit: Optional[_builtins.float] = None,
                 maximum_expansion_size_limit: Optional[_builtins.float] = None,
                 minimum_size_for_expansion: Optional[_builtins.float] = None):
        """
        Rules for regulating supported archive files (BZip2, Cpio, Deb, GZip, Rpm, Tar, Zip) during data replication. All properties are optional and only the configured options will be applied against archives. As an example, suppose minimumSizeForExpansion is 10 MiB and maximumExpansionSizeLimit is 1 GiB. Then all archives smaller than 10 MiB will be treated as though the archive ruleset is disabled, although other rulesets will apply as usual. Furthermore, all archives at least 10 MiB in size but with a decompressed size greater than 1 GiB will fail the ruleset. All other archives will have their contents extracted and each extracted element will be applied to all rulesets.
        :param _builtins.float maximum_compression_ratio_limit: Optional. Provides the multiplication value for an archive in total based on the initial object being validated. This value takes the root object size and multiplies it by this value to create a maximum. Once this maximum is exceeded, the archive is failed. Used to detect and block archives with suspiciously high compression (e.g., zip bombs).
        :param _builtins.float maximum_depth_limit: Optional. The maximum depth of nested archives that can be expanded. Limits how many layers of embedded archives will be processed. Archives exceeding the max limit will be denied for replication.
        :param _builtins.float maximum_expansion_size_limit: Optional. The combined maximum size (in bytes) of all extracted files that an expanded archive is allowed to reach. Archives exceeding the max limit will be denied for replication.
        :param _builtins.float minimum_size_for_expansion: Optional. Default is 0. The minimum archive file size (in bytes) required to trigger expansion during replication. Any archive file size below the configured threshold will skip the rest of the configured rulesets for archives.
        """
        if maximum_compression_ratio_limit is not None:
            pulumi.set(__self__, "maximum_compression_ratio_limit", maximum_compression_ratio_limit)
        if maximum_depth_limit is not None:
            pulumi.set(__self__, "maximum_depth_limit", maximum_depth_limit)
        if maximum_expansion_size_limit is not None:
            pulumi.set(__self__, "maximum_expansion_size_limit", maximum_expansion_size_limit)
        if minimum_size_for_expansion is None:
            minimum_size_for_expansion = 0
        if minimum_size_for_expansion is not None:
            pulumi.set(__self__, "minimum_size_for_expansion", minimum_size_for_expansion)

    @_builtins.property
    @pulumi.getter(name="maximumCompressionRatioLimit")
    def maximum_compression_ratio_limit(self) -> Optional[_builtins.float]:
        """
        Optional. Provides the multiplication value for an archive in total based on the initial object being validated. This value takes the root object size and multiplies it by this value to create a maximum. Once this maximum is exceeded, the archive is failed. Used to detect and block archives with suspiciously high compression (e.g., zip bombs).
        """
        return pulumi.get(self, "maximum_compression_ratio_limit")

    @_builtins.property
    @pulumi.getter(name="maximumDepthLimit")
    def maximum_depth_limit(self) -> Optional[_builtins.float]:
        """
        Optional. The maximum depth of nested archives that can be expanded. Limits how many layers of embedded archives will be processed. Archives exceeding the max limit will be denied for replication.
        """
        return pulumi.get(self, "maximum_depth_limit")

    @_builtins.property
    @pulumi.getter(name="maximumExpansionSizeLimit")
    def maximum_expansion_size_limit(self) -> Optional[_builtins.float]:
        """
        Optional. The combined maximum size (in bytes) of all extracted files that an expanded archive is allowed to reach. Archives exceeding the max limit will be denied for replication.
        """
        return pulumi.get(self, "maximum_expansion_size_limit")

    @_builtins.property
    @pulumi.getter(name="minimumSizeForExpansion")
    def minimum_size_for_expansion(self) -> Optional[_builtins.float]:
        """
        Optional. Default is 0. The minimum archive file size (in bytes) required to trigger expansion during replication. Any archive file size below the configured threshold will skip the rest of the configured rulesets for archives.
        """
        return pulumi.get(self, "minimum_size_for_expansion")


@pulumi.output_type
class ConnectionPropertiesResponse(dict):
    """
    Properties of connection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateSubmitted":
            suggest = "date_submitted"
        elif key == "linkStatus":
            suggest = "link_status"
        elif key == "linkedConnectionId":
            suggest = "linked_connection_id"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "statusReason":
            suggest = "status_reason"
        elif key == "flowTypes":
            suggest = "flow_types"
        elif key == "primaryContact":
            suggest = "primary_contact"
        elif key == "remoteSubscriptionId":
            suggest = "remote_subscription_id"
        elif key == "requirementId":
            suggest = "requirement_id"
        elif key == "schemaUris":
            suggest = "schema_uris"
        elif key == "secondaryContacts":
            suggest = "secondary_contacts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approver: _builtins.str,
                 date_submitted: _builtins.str,
                 link_status: _builtins.str,
                 linked_connection_id: _builtins.str,
                 pipeline: _builtins.str,
                 provisioning_state: _builtins.str,
                 status: _builtins.str,
                 status_reason: _builtins.str,
                 direction: Optional[_builtins.str] = None,
                 flow_types: Optional[Sequence[_builtins.str]] = None,
                 justification: Optional[_builtins.str] = None,
                 pin: Optional[_builtins.str] = None,
                 policies: Optional[Sequence[_builtins.str]] = None,
                 primary_contact: Optional[_builtins.str] = None,
                 remote_subscription_id: Optional[_builtins.str] = None,
                 requirement_id: Optional[_builtins.str] = None,
                 schema_uris: Optional[Sequence[_builtins.str]] = None,
                 schemas: Optional[Sequence['outputs.SchemaResponse']] = None,
                 secondary_contacts: Optional[Sequence[_builtins.str]] = None):
        """
        Properties of connection
        :param _builtins.str approver: Approver of this connection request
        :param _builtins.str date_submitted: The timestamp that this connection request was submitted at
        :param _builtins.str link_status: Link status of the current connection
        :param _builtins.str linked_connection_id: Resource ID of the linked connection
        :param _builtins.str pipeline: Pipeline to use to transfer data
        :param _builtins.str provisioning_state: Provisioning state of the connection
        :param _builtins.str status: Status of the connection
        :param _builtins.str status_reason: Reason for status
        :param _builtins.str direction: Direction of data movement
        :param Sequence[_builtins.str] flow_types: The flow types being requested for this connection
        :param _builtins.str justification: Justification for the connection request
        :param _builtins.str pin: PIN to link requests together
        :param Sequence[_builtins.str] policies: The policies for this connection
        :param _builtins.str primary_contact: The primary contact for this connection request
        :param _builtins.str remote_subscription_id: Subscription ID to link cloud subscriptions together
        :param _builtins.str requirement_id: Requirement ID of the connection
        :param Sequence[_builtins.str] schema_uris: The schema URIs for this connection
        :param Sequence['SchemaResponse'] schemas: The schemas for this connection
        :param Sequence[_builtins.str] secondary_contacts: The secondary contacts for this connection request
        """
        pulumi.set(__self__, "approver", approver)
        pulumi.set(__self__, "date_submitted", date_submitted)
        pulumi.set(__self__, "link_status", link_status)
        pulumi.set(__self__, "linked_connection_id", linked_connection_id)
        pulumi.set(__self__, "pipeline", pipeline)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_reason", status_reason)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if flow_types is not None:
            pulumi.set(__self__, "flow_types", flow_types)
        if justification is not None:
            pulumi.set(__self__, "justification", justification)
        if pin is not None:
            pulumi.set(__self__, "pin", pin)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if primary_contact is not None:
            pulumi.set(__self__, "primary_contact", primary_contact)
        if remote_subscription_id is not None:
            pulumi.set(__self__, "remote_subscription_id", remote_subscription_id)
        if requirement_id is not None:
            pulumi.set(__self__, "requirement_id", requirement_id)
        if schema_uris is not None:
            pulumi.set(__self__, "schema_uris", schema_uris)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)
        if secondary_contacts is not None:
            pulumi.set(__self__, "secondary_contacts", secondary_contacts)

    @_builtins.property
    @pulumi.getter
    def approver(self) -> _builtins.str:
        """
        Approver of this connection request
        """
        return pulumi.get(self, "approver")

    @_builtins.property
    @pulumi.getter(name="dateSubmitted")
    def date_submitted(self) -> _builtins.str:
        """
        The timestamp that this connection request was submitted at
        """
        return pulumi.get(self, "date_submitted")

    @_builtins.property
    @pulumi.getter(name="linkStatus")
    def link_status(self) -> _builtins.str:
        """
        Link status of the current connection
        """
        return pulumi.get(self, "link_status")

    @_builtins.property
    @pulumi.getter(name="linkedConnectionId")
    def linked_connection_id(self) -> _builtins.str:
        """
        Resource ID of the linked connection
        """
        return pulumi.get(self, "linked_connection_id")

    @_builtins.property
    @pulumi.getter
    def pipeline(self) -> _builtins.str:
        """
        Pipeline to use to transfer data
        """
        return pulumi.get(self, "pipeline")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the connection
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Status of the connection
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusReason")
    def status_reason(self) -> _builtins.str:
        """
        Reason for status
        """
        return pulumi.get(self, "status_reason")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        Direction of data movement
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="flowTypes")
    def flow_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The flow types being requested for this connection
        """
        return pulumi.get(self, "flow_types")

    @_builtins.property
    @pulumi.getter
    def justification(self) -> Optional[_builtins.str]:
        """
        Justification for the connection request
        """
        return pulumi.get(self, "justification")

    @_builtins.property
    @pulumi.getter
    def pin(self) -> Optional[_builtins.str]:
        """
        PIN to link requests together
        """
        return pulumi.get(self, "pin")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[_builtins.str]]:
        """
        The policies for this connection
        """
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter(name="primaryContact")
    def primary_contact(self) -> Optional[_builtins.str]:
        """
        The primary contact for this connection request
        """
        return pulumi.get(self, "primary_contact")

    @_builtins.property
    @pulumi.getter(name="remoteSubscriptionId")
    def remote_subscription_id(self) -> Optional[_builtins.str]:
        """
        Subscription ID to link cloud subscriptions together
        """
        return pulumi.get(self, "remote_subscription_id")

    @_builtins.property
    @pulumi.getter(name="requirementId")
    def requirement_id(self) -> Optional[_builtins.str]:
        """
        Requirement ID of the connection
        """
        return pulumi.get(self, "requirement_id")

    @_builtins.property
    @pulumi.getter(name="schemaUris")
    def schema_uris(self) -> Optional[Sequence[_builtins.str]]:
        """
        The schema URIs for this connection
        """
        return pulumi.get(self, "schema_uris")

    @_builtins.property
    @pulumi.getter
    def schemas(self) -> Optional[Sequence['outputs.SchemaResponse']]:
        """
        The schemas for this connection
        """
        return pulumi.get(self, "schemas")

    @_builtins.property
    @pulumi.getter(name="secondaryContacts")
    def secondary_contacts(self) -> Optional[Sequence[_builtins.str]]:
        """
        The secondary contacts for this connection request
        """
        return pulumi.get(self, "secondary_contacts")


@pulumi.output_type
class DataSizeRulesetResponse(dict):
    """
    Defines rules that enforce minimum and maximum file size limits for data replication.
    """
    def __init__(__self__, *,
                 maximum: Optional[_builtins.float] = None,
                 minimum: Optional[_builtins.float] = None):
        """
        Defines rules that enforce minimum and maximum file size limits for data replication.
        :param _builtins.float maximum: Optional. Specifies the maximum allowed size (in bytes) for files to be replicated. Any file size greater than maximum will be denied replication.
        :param _builtins.float minimum: Optional. Default is 0. Specifies the minimum required size (in bytes) for a file to be eligible for replication. Any file size less than minimum will be denied replication.
        """
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is None:
            minimum = 0
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> Optional[_builtins.float]:
        """
        Optional. Specifies the maximum allowed size (in bytes) for files to be replicated. Any file size greater than maximum will be denied replication.
        """
        return pulumi.get(self, "maximum")

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> Optional[_builtins.float]:
        """
        Optional. Default is 0. Specifies the minimum required size (in bytes) for a file to be eligible for replication. Any file size less than minimum will be denied replication.
        """
        return pulumi.get(self, "minimum")


@pulumi.output_type
class FlowProfilePropertiesResponse(dict):
    """
    Defines the full set of properties for a FlowProfile resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flowProfileId":
            suggest = "flow_profile_id"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "replicationScenario":
            suggest = "replication_scenario"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowProfilePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowProfilePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowProfilePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: _builtins.str,
                 flow_profile_id: _builtins.str,
                 provisioning_state: _builtins.str,
                 replication_scenario: _builtins.str,
                 status: _builtins.str,
                 rulesets: Optional['outputs.FlowProfileRulesetsResponse'] = None):
        """
        Defines the full set of properties for a FlowProfile resource.
        :param _builtins.str description: A user-defined description of the FlowProfile.
        :param _builtins.str flow_profile_id: A guid represented as a string for the FlowProfile resource, assigned by the system.
        :param _builtins.str provisioning_state: The current provisioning state of the FlowProfile.
        :param _builtins.str replication_scenario: The data replication scenario handled by this FlowProfile. Please not, that this value cannot be updated after creation.
        :param _builtins.str status: The operational status of the FlowProfile.
        :param 'FlowProfileRulesetsResponse' rulesets: A set of configurable rulesets applied to this FlowProfile.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "flow_profile_id", flow_profile_id)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "replication_scenario", replication_scenario)
        pulumi.set(__self__, "status", status)
        if rulesets is not None:
            pulumi.set(__self__, "rulesets", rulesets)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A user-defined description of the FlowProfile.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="flowProfileId")
    def flow_profile_id(self) -> _builtins.str:
        """
        A guid represented as a string for the FlowProfile resource, assigned by the system.
        """
        return pulumi.get(self, "flow_profile_id")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The current provisioning state of the FlowProfile.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="replicationScenario")
    def replication_scenario(self) -> _builtins.str:
        """
        The data replication scenario handled by this FlowProfile. Please not, that this value cannot be updated after creation.
        """
        return pulumi.get(self, "replication_scenario")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The operational status of the FlowProfile.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def rulesets(self) -> Optional['outputs.FlowProfileRulesetsResponse']:
        """
        A set of configurable rulesets applied to this FlowProfile.
        """
        return pulumi.get(self, "rulesets")


@pulumi.output_type
class FlowProfileRulesetsResponse(dict):
    """
    The allowed set of configurable rulesets for a FlowProfile resource, used during data replication. All rulesets are optional, and any ruleset configured will be applied to every applicable replicating data. Any data that fails a ruleset will be denied replication. If a ruleset is not configured then the ruleset is considered disabled and will not apply towards replicating data.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSize":
            suggest = "data_size"
        elif key == "mimeFilters":
            suggest = "mime_filters"
        elif key == "textMatching":
            suggest = "text_matching"
        elif key == "xmlFilters":
            suggest = "xml_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowProfileRulesetsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowProfileRulesetsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowProfileRulesetsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 antivirus: Optional['outputs.AntivirusRulesetResponse'] = None,
                 archives: Optional['outputs.ArchiveRulesetResponse'] = None,
                 data_size: Optional['outputs.DataSizeRulesetResponse'] = None,
                 mime_filters: Optional['outputs.MimeFilterRulesetResponse'] = None,
                 text_matching: Optional['outputs.TextMatchingRulesetResponse'] = None,
                 xml_filters: Optional['outputs.XmlFilterRulesetResponse'] = None):
        """
        The allowed set of configurable rulesets for a FlowProfile resource, used during data replication. All rulesets are optional, and any ruleset configured will be applied to every applicable replicating data. Any data that fails a ruleset will be denied replication. If a ruleset is not configured then the ruleset is considered disabled and will not apply towards replicating data.
        :param 'AntivirusRulesetResponse' antivirus: Antivirus scanning rules for replicated data.
        :param 'ArchiveRulesetResponse' archives: Rules for handling archive files during replication.
        :param 'DataSizeRulesetResponse' data_size: Rules that enforce minimum and maximum data size limits.
        :param 'MimeFilterRulesetResponse' mime_filters: Rules for filtering files based on MIME types.
        :param 'TextMatchingRulesetResponse' text_matching: Rules for detecting and blocking specific text patterns.
        :param 'XmlFilterRulesetResponse' xml_filters: Rules for filtering XML content using XSD schemas.
        """
        if antivirus is not None:
            pulumi.set(__self__, "antivirus", antivirus)
        if archives is not None:
            pulumi.set(__self__, "archives", archives)
        if data_size is not None:
            pulumi.set(__self__, "data_size", data_size)
        if mime_filters is not None:
            pulumi.set(__self__, "mime_filters", mime_filters)
        if text_matching is not None:
            pulumi.set(__self__, "text_matching", text_matching)
        if xml_filters is not None:
            pulumi.set(__self__, "xml_filters", xml_filters)

    @_builtins.property
    @pulumi.getter
    def antivirus(self) -> Optional['outputs.AntivirusRulesetResponse']:
        """
        Antivirus scanning rules for replicated data.
        """
        return pulumi.get(self, "antivirus")

    @_builtins.property
    @pulumi.getter
    def archives(self) -> Optional['outputs.ArchiveRulesetResponse']:
        """
        Rules for handling archive files during replication.
        """
        return pulumi.get(self, "archives")

    @_builtins.property
    @pulumi.getter(name="dataSize")
    def data_size(self) -> Optional['outputs.DataSizeRulesetResponse']:
        """
        Rules that enforce minimum and maximum data size limits.
        """
        return pulumi.get(self, "data_size")

    @_builtins.property
    @pulumi.getter(name="mimeFilters")
    def mime_filters(self) -> Optional['outputs.MimeFilterRulesetResponse']:
        """
        Rules for filtering files based on MIME types.
        """
        return pulumi.get(self, "mime_filters")

    @_builtins.property
    @pulumi.getter(name="textMatching")
    def text_matching(self) -> Optional['outputs.TextMatchingRulesetResponse']:
        """
        Rules for detecting and blocking specific text patterns.
        """
        return pulumi.get(self, "text_matching")

    @_builtins.property
    @pulumi.getter(name="xmlFilters")
    def xml_filters(self) -> Optional['outputs.XmlFilterRulesetResponse']:
        """
        Rules for filtering XML content using XSD schemas.
        """
        return pulumi.get(self, "xml_filters")


@pulumi.output_type
class FlowPropertiesResponse(dict):
    """
    Properties of flow
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flowId":
            suggest = "flow_id"
        elif key == "forceDisabledStatus":
            suggest = "force_disabled_status"
        elif key == "linkStatus":
            suggest = "link_status"
        elif key == "linkedFlowId":
            suggest = "linked_flow_id"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "apiFlowOptions":
            suggest = "api_flow_options"
        elif key == "consumerGroup":
            suggest = "consumer_group"
        elif key == "customerManagedKeyVaultUri":
            suggest = "customer_managed_key_vault_uri"
        elif key == "dataType":
            suggest = "data_type"
        elif key == "destinationEndpointPorts":
            suggest = "destination_endpoint_ports"
        elif key == "destinationEndpoints":
            suggest = "destination_endpoints"
        elif key == "eventHubId":
            suggest = "event_hub_id"
        elif key == "flowType":
            suggest = "flow_type"
        elif key == "keyVaultUri":
            suggest = "key_vault_uri"
        elif key == "messagingOptions":
            suggest = "messaging_options"
        elif key == "serviceBusQueueId":
            suggest = "service_bus_queue_id"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "storageAccountId":
            suggest = "storage_account_id"
        elif key == "storageAccountName":
            suggest = "storage_account_name"
        elif key == "storageContainerName":
            suggest = "storage_container_name"
        elif key == "storageTableName":
            suggest = "storage_table_name"
        elif key == "streamId":
            suggest = "stream_id"
        elif key == "streamLatency":
            suggest = "stream_latency"
        elif key == "streamProtocol":
            suggest = "stream_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flow_id: _builtins.str,
                 force_disabled_status: Sequence[_builtins.str],
                 link_status: _builtins.str,
                 linked_flow_id: _builtins.str,
                 provisioning_state: _builtins.str,
                 api_flow_options: Optional['outputs.ApiFlowOptionsResponse'] = None,
                 connection: Optional['outputs.SelectedResourceResponse'] = None,
                 consumer_group: Optional[_builtins.str] = None,
                 customer_managed_key_vault_uri: Optional[_builtins.str] = None,
                 data_type: Optional[_builtins.str] = None,
                 destination_endpoint_ports: Optional[Sequence[_builtins.float]] = None,
                 destination_endpoints: Optional[Sequence[_builtins.str]] = None,
                 event_hub_id: Optional[_builtins.str] = None,
                 flow_type: Optional[_builtins.str] = None,
                 key_vault_uri: Optional[_builtins.str] = None,
                 messaging_options: Optional['outputs.MessagingOptionsResponse'] = None,
                 passphrase: Optional[_builtins.str] = None,
                 policies: Optional[Sequence[_builtins.str]] = None,
                 schema: Optional['outputs.SchemaResponse'] = None,
                 service_bus_queue_id: Optional[_builtins.str] = None,
                 source_addresses: Optional['outputs.StreamSourceAddressesResponse'] = None,
                 status: Optional[_builtins.str] = None,
                 storage_account_id: Optional[_builtins.str] = None,
                 storage_account_name: Optional[_builtins.str] = None,
                 storage_container_name: Optional[_builtins.str] = None,
                 storage_table_name: Optional[_builtins.str] = None,
                 stream_id: Optional[_builtins.str] = None,
                 stream_latency: Optional[_builtins.float] = None,
                 stream_protocol: Optional[_builtins.str] = None):
        """
        Properties of flow
        :param _builtins.str flow_id: Dataflow GUID associated with this flow
        :param Sequence[_builtins.str] force_disabled_status: Force disablement status of the current flow
        :param _builtins.str link_status: Link status of the current flow
        :param _builtins.str linked_flow_id: Resource ID of the linked flow
        :param _builtins.str provisioning_state: Provisioning state of the flow
        :param 'ApiFlowOptionsResponse' api_flow_options: The API Flow configuration options for Azure Data Transfer API Flow type.
        :param 'SelectedResourceResponse' connection: The connection associated with this flow
        :param _builtins.str consumer_group: Event Hub Consumer Group
        :param _builtins.str customer_managed_key_vault_uri: The URI to the customer managed key for this flow
        :param _builtins.str data_type: Type of data to transfer via the flow. The property has reached end of life support starting version 2025-05-30-preview. Please create and use a FlowProfile resource instead.
        :param Sequence[_builtins.float] destination_endpoint_ports: The destination endpoint ports of the stream
        :param Sequence[_builtins.str] destination_endpoints: The destination endpoints of the stream
        :param _builtins.str event_hub_id: Event Hub ID
        :param _builtins.str flow_type: The flow type for this flow. The property has reached end of life support starting version 2025-05-30-preview. Please create and use a FlowProfile resource instead.
        :param _builtins.str key_vault_uri: URI to a Key Vault Secret containing a SAS token.
        :param 'MessagingOptionsResponse' messaging_options: The messaging options for this flow
        :param _builtins.str passphrase: The passphrase used for SRT streams
        :param Sequence[_builtins.str] policies: The policies for this flow. The property has reached end of life support starting version 2025-05-30-preview. Please create and use a FlowProfile resource instead.
        :param 'SchemaResponse' schema: The selected schema for this flow. The property has reached end of life support starting version 2025-05-30-preview. Please create and use a FlowProfile resource instead.
        :param _builtins.str service_bus_queue_id: Service Bus Queue ID
        :param 'StreamSourceAddressesResponse' source_addresses: The source IP address and CIDR ranges of the stream
        :param _builtins.str status: Status of the current flow
        :param _builtins.str storage_account_id: Storage Account ID
        :param _builtins.str storage_account_name: Storage Account
        :param _builtins.str storage_container_name: Storage Container Name
        :param _builtins.str storage_table_name: Storage Table Name
        :param _builtins.str stream_id: The flow stream identifier
        :param _builtins.float stream_latency: The latency of the stream in milliseconds
        :param _builtins.str stream_protocol: The protocol of the stream
        """
        pulumi.set(__self__, "flow_id", flow_id)
        pulumi.set(__self__, "force_disabled_status", force_disabled_status)
        pulumi.set(__self__, "link_status", link_status)
        pulumi.set(__self__, "linked_flow_id", linked_flow_id)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if api_flow_options is not None:
            pulumi.set(__self__, "api_flow_options", api_flow_options)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if customer_managed_key_vault_uri is not None:
            pulumi.set(__self__, "customer_managed_key_vault_uri", customer_managed_key_vault_uri)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if destination_endpoint_ports is not None:
            pulumi.set(__self__, "destination_endpoint_ports", destination_endpoint_ports)
        if destination_endpoints is not None:
            pulumi.set(__self__, "destination_endpoints", destination_endpoints)
        if event_hub_id is not None:
            pulumi.set(__self__, "event_hub_id", event_hub_id)
        if flow_type is not None:
            pulumi.set(__self__, "flow_type", flow_type)
        if key_vault_uri is not None:
            pulumi.set(__self__, "key_vault_uri", key_vault_uri)
        if messaging_options is not None:
            pulumi.set(__self__, "messaging_options", messaging_options)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if service_bus_queue_id is not None:
            pulumi.set(__self__, "service_bus_queue_id", service_bus_queue_id)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if storage_account_id is not None:
            pulumi.set(__self__, "storage_account_id", storage_account_id)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)
        if storage_container_name is not None:
            pulumi.set(__self__, "storage_container_name", storage_container_name)
        if storage_table_name is not None:
            pulumi.set(__self__, "storage_table_name", storage_table_name)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if stream_latency is not None:
            pulumi.set(__self__, "stream_latency", stream_latency)
        if stream_protocol is not None:
            pulumi.set(__self__, "stream_protocol", stream_protocol)

    @_builtins.property
    @pulumi.getter(name="flowId")
    def flow_id(self) -> _builtins.str:
        """
        Dataflow GUID associated with this flow
        """
        return pulumi.get(self, "flow_id")

    @_builtins.property
    @pulumi.getter(name="forceDisabledStatus")
    def force_disabled_status(self) -> Sequence[_builtins.str]:
        """
        Force disablement status of the current flow
        """
        return pulumi.get(self, "force_disabled_status")

    @_builtins.property
    @pulumi.getter(name="linkStatus")
    def link_status(self) -> _builtins.str:
        """
        Link status of the current flow
        """
        return pulumi.get(self, "link_status")

    @_builtins.property
    @pulumi.getter(name="linkedFlowId")
    def linked_flow_id(self) -> _builtins.str:
        """
        Resource ID of the linked flow
        """
        return pulumi.get(self, "linked_flow_id")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the flow
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="apiFlowOptions")
    def api_flow_options(self) -> Optional['outputs.ApiFlowOptionsResponse']:
        """
        The API Flow configuration options for Azure Data Transfer API Flow type.
        """
        return pulumi.get(self, "api_flow_options")

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional['outputs.SelectedResourceResponse']:
        """
        The connection associated with this flow
        """
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[_builtins.str]:
        """
        Event Hub Consumer Group
        """
        return pulumi.get(self, "consumer_group")

    @_builtins.property
    @pulumi.getter(name="customerManagedKeyVaultUri")
    def customer_managed_key_vault_uri(self) -> Optional[_builtins.str]:
        """
        The URI to the customer managed key for this flow
        """
        return pulumi.get(self, "customer_managed_key_vault_uri")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        Type of data to transfer via the flow. The property has reached end of life support starting version 2025-05-30-preview. Please create and use a FlowProfile resource instead.
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter(name="destinationEndpointPorts")
    def destination_endpoint_ports(self) -> Optional[Sequence[_builtins.float]]:
        """
        The destination endpoint ports of the stream
        """
        return pulumi.get(self, "destination_endpoint_ports")

    @_builtins.property
    @pulumi.getter(name="destinationEndpoints")
    def destination_endpoints(self) -> Optional[Sequence[_builtins.str]]:
        """
        The destination endpoints of the stream
        """
        return pulumi.get(self, "destination_endpoints")

    @_builtins.property
    @pulumi.getter(name="eventHubId")
    def event_hub_id(self) -> Optional[_builtins.str]:
        """
        Event Hub ID
        """
        return pulumi.get(self, "event_hub_id")

    @_builtins.property
    @pulumi.getter(name="flowType")
    def flow_type(self) -> Optional[_builtins.str]:
        """
        The flow type for this flow. The property has reached end of life support starting version 2025-05-30-preview. Please create and use a FlowProfile resource instead.
        """
        return pulumi.get(self, "flow_type")

    @_builtins.property
    @pulumi.getter(name="keyVaultUri")
    def key_vault_uri(self) -> Optional[_builtins.str]:
        """
        URI to a Key Vault Secret containing a SAS token.
        """
        return pulumi.get(self, "key_vault_uri")

    @_builtins.property
    @pulumi.getter(name="messagingOptions")
    def messaging_options(self) -> Optional['outputs.MessagingOptionsResponse']:
        """
        The messaging options for this flow
        """
        return pulumi.get(self, "messaging_options")

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[_builtins.str]:
        """
        The passphrase used for SRT streams
        """
        return pulumi.get(self, "passphrase")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[_builtins.str]]:
        """
        The policies for this flow. The property has reached end of life support starting version 2025-05-30-preview. Please create and use a FlowProfile resource instead.
        """
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional['outputs.SchemaResponse']:
        """
        The selected schema for this flow. The property has reached end of life support starting version 2025-05-30-preview. Please create and use a FlowProfile resource instead.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter(name="serviceBusQueueId")
    def service_bus_queue_id(self) -> Optional[_builtins.str]:
        """
        Service Bus Queue ID
        """
        return pulumi.get(self, "service_bus_queue_id")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional['outputs.StreamSourceAddressesResponse']:
        """
        The source IP address and CIDR ranges of the stream
        """
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the current flow
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> Optional[_builtins.str]:
        """
        Storage Account ID
        """
        return pulumi.get(self, "storage_account_id")

    @_builtins.property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[_builtins.str]:
        """
        Storage Account
        """
        return pulumi.get(self, "storage_account_name")

    @_builtins.property
    @pulumi.getter(name="storageContainerName")
    def storage_container_name(self) -> Optional[_builtins.str]:
        """
        Storage Container Name
        """
        return pulumi.get(self, "storage_container_name")

    @_builtins.property
    @pulumi.getter(name="storageTableName")
    def storage_table_name(self) -> Optional[_builtins.str]:
        """
        Storage Table Name
        """
        return pulumi.get(self, "storage_table_name")

    @_builtins.property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[_builtins.str]:
        """
        The flow stream identifier
        """
        return pulumi.get(self, "stream_id")

    @_builtins.property
    @pulumi.getter(name="streamLatency")
    def stream_latency(self) -> Optional[_builtins.float]:
        """
        The latency of the stream in milliseconds
        """
        return pulumi.get(self, "stream_latency")

    @_builtins.property
    @pulumi.getter(name="streamProtocol")
    def stream_protocol(self) -> Optional[_builtins.str]:
        """
        The protocol of the stream
        """
        return pulumi.get(self, "stream_protocol")


@pulumi.output_type
class FlowResponse(dict):
    """
    The flow resource definition.
    """
    def __init__(__self__, *,
                 id: _builtins.str,
                 location: _builtins.str,
                 name: _builtins.str,
                 system_data: 'outputs.SystemDataResponse',
                 type: _builtins.str,
                 identity: Optional['outputs.ManagedServiceIdentityResponse'] = None,
                 plan: Optional['outputs.PlanResponse'] = None,
                 properties: Optional['outputs.FlowPropertiesResponse'] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        The flow resource definition.
        :param _builtins.str id: Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        :param _builtins.str location: The geo-location where the resource lives
        :param _builtins.str name: The name of the resource
        :param 'SystemDataResponse' system_data: Azure Resource Manager metadata containing createdBy and modifiedBy information.
        :param _builtins.str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param 'ManagedServiceIdentityResponse' identity: The managed service identities assigned to this resource.
        :param 'PlanResponse' plan: Details of the resource plan.
        :param 'FlowPropertiesResponse' properties: Properties of flow
        :param Mapping[str, _builtins.str] tags: Resource tags.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "system_data", system_data)
        pulumi.set(__self__, "type", type)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if plan is not None:
            pulumi.set(__self__, "plan", plan)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        The geo-location where the resource lives
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Azure Resource Manager metadata containing createdBy and modifiedBy information.
        """
        return pulumi.get(self, "system_data")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional['outputs.ManagedServiceIdentityResponse']:
        """
        The managed service identities assigned to this resource.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter
    def plan(self) -> Optional['outputs.PlanResponse']:
        """
        Details of the resource plan.
        """
        return pulumi.get(self, "plan")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional['outputs.FlowPropertiesResponse']:
        """
        Properties of flow
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class InternalMetadataPropertiesResponse(dict):
    """
    Internal metadata of the connection inside pipeline.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusSetBy":
            suggest = "status_set_by"
        elif key == "operationStatus":
            suggest = "operation_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternalMetadataPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternalMetadataPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternalMetadataPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_set_by: _builtins.str,
                 operation_status: Optional['outputs.OperationStatusPropertiesResponse'] = None):
        """
        Internal metadata of the connection inside pipeline.
        :param _builtins.str status_set_by: User that last set the approved status for this connection
        :param 'OperationStatusPropertiesResponse' operation_status: Operation status associated with the last patch request
        """
        pulumi.set(__self__, "status_set_by", status_set_by)
        if operation_status is not None:
            pulumi.set(__self__, "operation_status", operation_status)

    @_builtins.property
    @pulumi.getter(name="statusSetBy")
    def status_set_by(self) -> _builtins.str:
        """
        User that last set the approved status for this connection
        """
        return pulumi.get(self, "status_set_by")

    @_builtins.property
    @pulumi.getter(name="operationStatus")
    def operation_status(self) -> Optional['outputs.OperationStatusPropertiesResponse']:
        """
        Operation status associated with the last patch request
        """
        return pulumi.get(self, "operation_status")


@pulumi.output_type
class ListFlowsByPipelineConnectionResponse(dict):
    """
    A connection resource id in addition to all child flow resources under this connection.
    """
    def __init__(__self__, *,
                 flows: Optional[Sequence['outputs.FlowResponse']] = None,
                 id: Optional[_builtins.str] = None):
        """
        A connection resource id in addition to all child flow resources under this connection.
        :param Sequence['FlowResponse'] flows: List of flows associated with the connection.
        :param _builtins.str id: ID of the connection.
        """
        if flows is not None:
            pulumi.set(__self__, "flows", flows)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def flows(self) -> Optional[Sequence['outputs.FlowResponse']]:
        """
        List of flows associated with the connection.
        """
        return pulumi.get(self, "flows")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the connection.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity (system assigned and/or user assigned identities)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: _builtins.str,
                 tenant_id: _builtins.str,
                 type: _builtins.str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param _builtins.str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param _builtins.str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param _builtins.str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class MessagingOptionsResponse(dict):
    """
    The option associated with messaging flows.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "billingTier":
            suggest = "billing_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MessagingOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MessagingOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MessagingOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 billing_tier: Optional[_builtins.str] = None):
        """
        The option associated with messaging flows.
        :param _builtins.str billing_tier: Billing tier for this messaging flow
        """
        if billing_tier is not None:
            pulumi.set(__self__, "billing_tier", billing_tier)

    @_builtins.property
    @pulumi.getter(name="billingTier")
    def billing_tier(self) -> Optional[_builtins.str]:
        """
        Billing tier for this messaging flow
        """
        return pulumi.get(self, "billing_tier")


@pulumi.output_type
class MimeFilterRulesetResponse(dict):
    """
    Rules for filtering files based on Media types (f.k.a MIME types).
    """
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.MimeTypeFilterResponse']] = None,
                 type: Optional[_builtins.str] = None):
        """
        Rules for filtering files based on Media types (f.k.a MIME types).
        :param Sequence['MimeTypeFilterResponse'] filters: Defines the Media types (f.k.a MIME types) and associated file extensions to be filtered. For more detail, please refer to the MimeTypeFiler model.
        :param _builtins.str type: Specifies whether the filter is an allow list or deny list. For more detail, please refer to the FilterType model.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.MimeTypeFilterResponse']]:
        """
        Defines the Media types (f.k.a MIME types) and associated file extensions to be filtered. For more detail, please refer to the MimeTypeFiler model.
        """
        return pulumi.get(self, "filters")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies whether the filter is an allow list or deny list. For more detail, please refer to the FilterType model.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MimeTypeFilterResponse(dict):
    """
    Defines a list of Media types (f.k.a MIME Types) and associated file extensions subject to filtering.
    """
    def __init__(__self__, *,
                 extensions: Optional[Sequence[_builtins.str]] = None,
                 media: Optional[_builtins.str] = None):
        """
        Defines a list of Media types (f.k.a MIME Types) and associated file extensions subject to filtering.
        :param Sequence[_builtins.str] extensions: A list of file extensions associated with the specified Media type (e.g., .json, .png). To specify files with no extension, use an empty string ""."
        :param _builtins.str media: The Media Types (f.k.a MIME types), following IANA standards (e.g., application/json, image/png). For a more detailed list of allowed media types please refer to the Tika documentation: https://github.com/apache/tika/blob/main/tika-core/src/main/resources/org/apache/tika/mime/tika-mimetypes.xml
        """
        if extensions is not None:
            pulumi.set(__self__, "extensions", extensions)
        if media is not None:
            pulumi.set(__self__, "media", media)

    @_builtins.property
    @pulumi.getter
    def extensions(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of file extensions associated with the specified Media type (e.g., .json, .png). To specify files with no extension, use an empty string ""."
        """
        return pulumi.get(self, "extensions")

    @_builtins.property
    @pulumi.getter
    def media(self) -> Optional[_builtins.str]:
        """
        The Media Types (f.k.a MIME types), following IANA standards (e.g., application/json, image/png). For a more detailed list of allowed media types please refer to the Tika documentation: https://github.com/apache/tika/blob/main/tika-core/src/main/resources/org/apache/tika/mime/tika-mimetypes.xml
        """
        return pulumi.get(self, "media")


@pulumi.output_type
class OperationStatusPropertiesResponse(dict):
    """
    Operation status associated with the last patch request
    """
    def __init__(__self__, *,
                 id: _builtins.str,
                 message: _builtins.str,
                 status: _builtins.str):
        """
        Operation status associated with the last patch request
        :param _builtins.str id: Operation status ID of the last patch request for this connection.
        :param _builtins.str message: Message for the operation for the last patch request for this connection.
        :param _builtins.str status: Operation status for the last patch request for this connection.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Operation status ID of the last patch request for this connection.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        Message for the operation for the last patch request for this connection.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Operation status for the last patch request for this connection.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class PendingConnectionResponse(dict):
    """
    Pending connection object
    """
    def __init__(__self__, *,
                 approver: _builtins.str,
                 date_submitted: _builtins.str,
                 id: _builtins.str,
                 link_status: _builtins.str,
                 linked_connection_id: _builtins.str,
                 location: _builtins.str,
                 name: _builtins.str,
                 pipeline: _builtins.str,
                 provisioning_state: _builtins.str,
                 status: _builtins.str,
                 status_reason: _builtins.str,
                 subscription_id: _builtins.str,
                 system_data: 'outputs.SystemDataResponse',
                 type: _builtins.str,
                 direction: Optional[_builtins.str] = None,
                 flow_types: Optional[Sequence[_builtins.str]] = None,
                 justification: Optional[_builtins.str] = None,
                 pin: Optional[_builtins.str] = None,
                 policies: Optional[Sequence[_builtins.str]] = None,
                 primary_contact: Optional[_builtins.str] = None,
                 remote_subscription_id: Optional[_builtins.str] = None,
                 requirement_id: Optional[_builtins.str] = None,
                 schema_uris: Optional[Sequence[_builtins.str]] = None,
                 schemas: Optional[Sequence['outputs.SchemaResponse']] = None,
                 secondary_contacts: Optional[Sequence[_builtins.str]] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        Pending connection object
        :param _builtins.str approver: Approver of this connection request
        :param _builtins.str date_submitted: The timestamp that this connection request was submitted at
        :param _builtins.str id: Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        :param _builtins.str link_status: Link status of the current connection
        :param _builtins.str linked_connection_id: Resource ID of the linked connection
        :param _builtins.str location: The geo-location where the resource lives
        :param _builtins.str name: The name of the resource
        :param _builtins.str pipeline: Pipeline to use to transfer data
        :param _builtins.str provisioning_state: Provisioning state of the connection
        :param _builtins.str status: Status of the connection
        :param _builtins.str status_reason: Reason for status
        :param _builtins.str subscription_id: Subscription ID of the pending connection.
        :param 'SystemDataResponse' system_data: Azure Resource Manager metadata containing createdBy and modifiedBy information.
        :param _builtins.str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param _builtins.str direction: Direction of data movement
        :param Sequence[_builtins.str] flow_types: The flow types being requested for this connection
        :param _builtins.str justification: Justification for the connection request
        :param _builtins.str pin: PIN to link requests together
        :param Sequence[_builtins.str] policies: The policies for this connection
        :param _builtins.str primary_contact: The primary contact for this connection request
        :param _builtins.str remote_subscription_id: Subscription ID to link cloud subscriptions together
        :param _builtins.str requirement_id: Requirement ID of the connection
        :param Sequence[_builtins.str] schema_uris: The schema URIs for this connection
        :param Sequence['SchemaResponse'] schemas: The schemas for this connection
        :param Sequence[_builtins.str] secondary_contacts: The secondary contacts for this connection request
        :param Mapping[str, _builtins.str] tags: Resource tags.
        """
        pulumi.set(__self__, "approver", approver)
        pulumi.set(__self__, "date_submitted", date_submitted)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "link_status", link_status)
        pulumi.set(__self__, "linked_connection_id", linked_connection_id)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pipeline", pipeline)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_reason", status_reason)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "system_data", system_data)
        pulumi.set(__self__, "type", type)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if flow_types is not None:
            pulumi.set(__self__, "flow_types", flow_types)
        if justification is not None:
            pulumi.set(__self__, "justification", justification)
        if pin is not None:
            pulumi.set(__self__, "pin", pin)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if primary_contact is not None:
            pulumi.set(__self__, "primary_contact", primary_contact)
        if remote_subscription_id is not None:
            pulumi.set(__self__, "remote_subscription_id", remote_subscription_id)
        if requirement_id is not None:
            pulumi.set(__self__, "requirement_id", requirement_id)
        if schema_uris is not None:
            pulumi.set(__self__, "schema_uris", schema_uris)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)
        if secondary_contacts is not None:
            pulumi.set(__self__, "secondary_contacts", secondary_contacts)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def approver(self) -> _builtins.str:
        """
        Approver of this connection request
        """
        return pulumi.get(self, "approver")

    @_builtins.property
    @pulumi.getter(name="dateSubmitted")
    def date_submitted(self) -> _builtins.str:
        """
        The timestamp that this connection request was submitted at
        """
        return pulumi.get(self, "date_submitted")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="linkStatus")
    def link_status(self) -> _builtins.str:
        """
        Link status of the current connection
        """
        return pulumi.get(self, "link_status")

    @_builtins.property
    @pulumi.getter(name="linkedConnectionId")
    def linked_connection_id(self) -> _builtins.str:
        """
        Resource ID of the linked connection
        """
        return pulumi.get(self, "linked_connection_id")

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        The geo-location where the resource lives
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def pipeline(self) -> _builtins.str:
        """
        Pipeline to use to transfer data
        """
        return pulumi.get(self, "pipeline")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the connection
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Status of the connection
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusReason")
    def status_reason(self) -> _builtins.str:
        """
        Reason for status
        """
        return pulumi.get(self, "status_reason")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        """
        Subscription ID of the pending connection.
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Azure Resource Manager metadata containing createdBy and modifiedBy information.
        """
        return pulumi.get(self, "system_data")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        Direction of data movement
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="flowTypes")
    def flow_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The flow types being requested for this connection
        """
        return pulumi.get(self, "flow_types")

    @_builtins.property
    @pulumi.getter
    def justification(self) -> Optional[_builtins.str]:
        """
        Justification for the connection request
        """
        return pulumi.get(self, "justification")

    @_builtins.property
    @pulumi.getter
    def pin(self) -> Optional[_builtins.str]:
        """
        PIN to link requests together
        """
        return pulumi.get(self, "pin")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[_builtins.str]]:
        """
        The policies for this connection
        """
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter(name="primaryContact")
    def primary_contact(self) -> Optional[_builtins.str]:
        """
        The primary contact for this connection request
        """
        return pulumi.get(self, "primary_contact")

    @_builtins.property
    @pulumi.getter(name="remoteSubscriptionId")
    def remote_subscription_id(self) -> Optional[_builtins.str]:
        """
        Subscription ID to link cloud subscriptions together
        """
        return pulumi.get(self, "remote_subscription_id")

    @_builtins.property
    @pulumi.getter(name="requirementId")
    def requirement_id(self) -> Optional[_builtins.str]:
        """
        Requirement ID of the connection
        """
        return pulumi.get(self, "requirement_id")

    @_builtins.property
    @pulumi.getter(name="schemaUris")
    def schema_uris(self) -> Optional[Sequence[_builtins.str]]:
        """
        The schema URIs for this connection
        """
        return pulumi.get(self, "schema_uris")

    @_builtins.property
    @pulumi.getter
    def schemas(self) -> Optional[Sequence['outputs.SchemaResponse']]:
        """
        The schemas for this connection
        """
        return pulumi.get(self, "schemas")

    @_builtins.property
    @pulumi.getter(name="secondaryContacts")
    def secondary_contacts(self) -> Optional[Sequence[_builtins.str]]:
        """
        The secondary contacts for this connection request
        """
        return pulumi.get(self, "secondary_contacts")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class PendingFlowResponse(dict):
    """
    Pending flow object
    """
    def __init__(__self__, *,
                 connection_id: _builtins.str,
                 flow_id: _builtins.str,
                 id: _builtins.str,
                 link_status: _builtins.str,
                 linked_flow_id: _builtins.str,
                 location: _builtins.str,
                 name: _builtins.str,
                 provisioning_state: _builtins.str,
                 subscription_id: _builtins.str,
                 system_data: 'outputs.SystemDataResponse',
                 type: _builtins.str,
                 connection: Optional['outputs.SelectedResourceResponse'] = None,
                 customer_managed_key_vault_uri: Optional[_builtins.str] = None,
                 data_type: Optional[_builtins.str] = None,
                 destination_endpoint_ports: Optional[Sequence[_builtins.float]] = None,
                 destination_endpoints: Optional[Sequence[_builtins.str]] = None,
                 flow_type: Optional[_builtins.str] = None,
                 key_vault_uri: Optional[_builtins.str] = None,
                 messaging_options: Optional['outputs.MessagingOptionsResponse'] = None,
                 passphrase: Optional[_builtins.str] = None,
                 policies: Optional[Sequence[_builtins.str]] = None,
                 schema: Optional['outputs.SchemaResponse'] = None,
                 service_bus_queue_id: Optional[_builtins.str] = None,
                 source_addresses: Optional['outputs.StreamSourceAddressesResponse'] = None,
                 status: Optional[_builtins.str] = None,
                 storage_account_id: Optional[_builtins.str] = None,
                 storage_account_name: Optional[_builtins.str] = None,
                 storage_container_name: Optional[_builtins.str] = None,
                 stream_id: Optional[_builtins.str] = None,
                 stream_latency: Optional[_builtins.float] = None,
                 stream_protocol: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        Pending flow object
        :param _builtins.str connection_id: Connection ID of the pending flow.
        :param _builtins.str flow_id: Dataflow GUID associated with this flow
        :param _builtins.str id: Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        :param _builtins.str link_status: Link status of the current flow
        :param _builtins.str linked_flow_id: Resource ID of the linked flow
        :param _builtins.str location: The geo-location where the resource lives
        :param _builtins.str name: The name of the resource
        :param _builtins.str provisioning_state: Provisioning state of the flow
        :param _builtins.str subscription_id: Subscription ID of the pending flow.
        :param 'SystemDataResponse' system_data: Azure Resource Manager metadata containing createdBy and modifiedBy information.
        :param _builtins.str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param 'SelectedResourceResponse' connection: The connection associated with this flow
        :param _builtins.str customer_managed_key_vault_uri: The URI to the customer managed key for this flow
        :param _builtins.str data_type: Transfer Storage Blobs or Tables
        :param Sequence[_builtins.float] destination_endpoint_ports: The destination endpoint ports of the stream
        :param Sequence[_builtins.str] destination_endpoints: The destination endpoints of the stream
        :param _builtins.str flow_type: The flow type for this flow
        :param _builtins.str key_vault_uri: AME, PME, or TORUS only! AKV Chain Containing SAS Token
        :param 'MessagingOptionsResponse' messaging_options: The messaging options for this flow
        :param _builtins.str passphrase: The passphrase used for SRT streams
        :param Sequence[_builtins.str] policies: The policies for this flow
        :param 'SchemaResponse' schema: The selected schema for this flow
        :param _builtins.str service_bus_queue_id: Service Bus Queue ID
        :param 'StreamSourceAddressesResponse' source_addresses: The source IP address and CIDR ranges of the stream
        :param _builtins.str status: Status of the current flow
        :param _builtins.str storage_account_id: Storage Account ID
        :param _builtins.str storage_account_name: Storage Account
        :param _builtins.str storage_container_name: Storage Container Name
        :param _builtins.str stream_id: The flow stream identifier
        :param _builtins.float stream_latency: The latency of the stream in milliseconds
        :param _builtins.str stream_protocol: The protocol of the stream
        :param Mapping[str, _builtins.str] tags: Resource tags.
        """
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "flow_id", flow_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "link_status", link_status)
        pulumi.set(__self__, "linked_flow_id", linked_flow_id)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "system_data", system_data)
        pulumi.set(__self__, "type", type)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if customer_managed_key_vault_uri is not None:
            pulumi.set(__self__, "customer_managed_key_vault_uri", customer_managed_key_vault_uri)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if destination_endpoint_ports is not None:
            pulumi.set(__self__, "destination_endpoint_ports", destination_endpoint_ports)
        if destination_endpoints is not None:
            pulumi.set(__self__, "destination_endpoints", destination_endpoints)
        if flow_type is not None:
            pulumi.set(__self__, "flow_type", flow_type)
        if key_vault_uri is not None:
            pulumi.set(__self__, "key_vault_uri", key_vault_uri)
        if messaging_options is not None:
            pulumi.set(__self__, "messaging_options", messaging_options)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if service_bus_queue_id is not None:
            pulumi.set(__self__, "service_bus_queue_id", service_bus_queue_id)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if storage_account_id is not None:
            pulumi.set(__self__, "storage_account_id", storage_account_id)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)
        if storage_container_name is not None:
            pulumi.set(__self__, "storage_container_name", storage_container_name)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if stream_latency is not None:
            pulumi.set(__self__, "stream_latency", stream_latency)
        if stream_protocol is not None:
            pulumi.set(__self__, "stream_protocol", stream_protocol)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> _builtins.str:
        """
        Connection ID of the pending flow.
        """
        return pulumi.get(self, "connection_id")

    @_builtins.property
    @pulumi.getter(name="flowId")
    def flow_id(self) -> _builtins.str:
        """
        Dataflow GUID associated with this flow
        """
        return pulumi.get(self, "flow_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="linkStatus")
    def link_status(self) -> _builtins.str:
        """
        Link status of the current flow
        """
        return pulumi.get(self, "link_status")

    @_builtins.property
    @pulumi.getter(name="linkedFlowId")
    def linked_flow_id(self) -> _builtins.str:
        """
        Resource ID of the linked flow
        """
        return pulumi.get(self, "linked_flow_id")

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        The geo-location where the resource lives
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the flow
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        """
        Subscription ID of the pending flow.
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Azure Resource Manager metadata containing createdBy and modifiedBy information.
        """
        return pulumi.get(self, "system_data")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional['outputs.SelectedResourceResponse']:
        """
        The connection associated with this flow
        """
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter(name="customerManagedKeyVaultUri")
    def customer_managed_key_vault_uri(self) -> Optional[_builtins.str]:
        """
        The URI to the customer managed key for this flow
        """
        return pulumi.get(self, "customer_managed_key_vault_uri")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        Transfer Storage Blobs or Tables
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter(name="destinationEndpointPorts")
    def destination_endpoint_ports(self) -> Optional[Sequence[_builtins.float]]:
        """
        The destination endpoint ports of the stream
        """
        return pulumi.get(self, "destination_endpoint_ports")

    @_builtins.property
    @pulumi.getter(name="destinationEndpoints")
    def destination_endpoints(self) -> Optional[Sequence[_builtins.str]]:
        """
        The destination endpoints of the stream
        """
        return pulumi.get(self, "destination_endpoints")

    @_builtins.property
    @pulumi.getter(name="flowType")
    def flow_type(self) -> Optional[_builtins.str]:
        """
        The flow type for this flow
        """
        return pulumi.get(self, "flow_type")

    @_builtins.property
    @pulumi.getter(name="keyVaultUri")
    def key_vault_uri(self) -> Optional[_builtins.str]:
        """
        AME, PME, or TORUS only! AKV Chain Containing SAS Token
        """
        return pulumi.get(self, "key_vault_uri")

    @_builtins.property
    @pulumi.getter(name="messagingOptions")
    def messaging_options(self) -> Optional['outputs.MessagingOptionsResponse']:
        """
        The messaging options for this flow
        """
        return pulumi.get(self, "messaging_options")

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[_builtins.str]:
        """
        The passphrase used for SRT streams
        """
        return pulumi.get(self, "passphrase")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[_builtins.str]]:
        """
        The policies for this flow
        """
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional['outputs.SchemaResponse']:
        """
        The selected schema for this flow
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter(name="serviceBusQueueId")
    def service_bus_queue_id(self) -> Optional[_builtins.str]:
        """
        Service Bus Queue ID
        """
        return pulumi.get(self, "service_bus_queue_id")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional['outputs.StreamSourceAddressesResponse']:
        """
        The source IP address and CIDR ranges of the stream
        """
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the current flow
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> Optional[_builtins.str]:
        """
        Storage Account ID
        """
        return pulumi.get(self, "storage_account_id")

    @_builtins.property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[_builtins.str]:
        """
        Storage Account
        """
        return pulumi.get(self, "storage_account_name")

    @_builtins.property
    @pulumi.getter(name="storageContainerName")
    def storage_container_name(self) -> Optional[_builtins.str]:
        """
        Storage Container Name
        """
        return pulumi.get(self, "storage_container_name")

    @_builtins.property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[_builtins.str]:
        """
        The flow stream identifier
        """
        return pulumi.get(self, "stream_id")

    @_builtins.property
    @pulumi.getter(name="streamLatency")
    def stream_latency(self) -> Optional[_builtins.float]:
        """
        The latency of the stream in milliseconds
        """
        return pulumi.get(self, "stream_latency")

    @_builtins.property
    @pulumi.getter(name="streamProtocol")
    def stream_protocol(self) -> Optional[_builtins.str]:
        """
        The protocol of the stream
        """
        return pulumi.get(self, "stream_protocol")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class PipelineConnectionResponse(dict):
    """
    Connection body inside a pipeline
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemData":
            suggest = "system_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 etag: _builtins.str,
                 id: _builtins.str,
                 location: _builtins.str,
                 name: _builtins.str,
                 system_data: 'outputs.SystemDataResponse',
                 type: _builtins.str,
                 properties: Optional['outputs.PipelineConnectionResponseProperties'] = None):
        """
        Connection body inside a pipeline
        :param _builtins.str etag: Connection etag inside pipeline
        :param _builtins.str id: Connection id inside pipeline
        :param _builtins.str location: Connection location inside pipeline
        :param _builtins.str name: Connection name inside pipeline
        :param 'SystemDataResponse' system_data: Metadata pertaining to creation and last modification of the resource.
        :param _builtins.str type: Connection type inside pipeline
        :param 'PipelineConnectionResponseProperties' properties: Connection properties inside pipeline
        """
        pulumi.set(__self__, "etag", etag)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "system_data", system_data)
        pulumi.set(__self__, "type", type)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def etag(self) -> _builtins.str:
        """
        Connection etag inside pipeline
        """
        return pulumi.get(self, "etag")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Connection id inside pipeline
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        Connection location inside pipeline
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Connection name inside pipeline
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Metadata pertaining to creation and last modification of the resource.
        """
        return pulumi.get(self, "system_data")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Connection type inside pipeline
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional['outputs.PipelineConnectionResponseProperties']:
        """
        Connection properties inside pipeline
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class PipelineConnectionResponseProperties(dict):
    """
    Connection properties inside pipeline
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalMetadata":
            suggest = "internal_metadata"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineConnectionResponseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineConnectionResponseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineConnectionResponseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 internal_metadata: Optional['outputs.InternalMetadataPropertiesResponse'] = None):
        """
        Connection properties inside pipeline
        :param 'InternalMetadataPropertiesResponse' internal_metadata: Internal metadata of the connection inside pipeline.
        """
        if internal_metadata is not None:
            pulumi.set(__self__, "internal_metadata", internal_metadata)

    @_builtins.property
    @pulumi.getter(name="internalMetadata")
    def internal_metadata(self) -> Optional['outputs.InternalMetadataPropertiesResponse']:
        """
        Internal metadata of the connection inside pipeline.
        """
        return pulumi.get(self, "internal_metadata")


@pulumi.output_type
class PipelinePropertiesResponse(dict):
    """
    Properties of pipeline
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "remoteCloud":
            suggest = "remote_cloud"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "flowTypes":
            suggest = "flow_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelinePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelinePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelinePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connections: Sequence['outputs.PipelineConnectionResponse'],
                 provisioning_state: _builtins.str,
                 remote_cloud: _builtins.str,
                 display_name: Optional[_builtins.str] = None,
                 flow_types: Optional[Sequence[_builtins.str]] = None,
                 policies: Optional[Sequence[_builtins.str]] = None,
                 subscribers: Optional[Sequence['outputs.SubscriberResponse']] = None):
        """
        Properties of pipeline
        :param Sequence['PipelineConnectionResponse'] connections: Connections associated with pipeline
        :param _builtins.str provisioning_state: Provisioning state of the pipeline
        :param _builtins.str remote_cloud: Remote cloud of the data to be transferred or received
        :param _builtins.str display_name: Display name of this pipeline
        :param Sequence[_builtins.str] flow_types: The flow types allowed for this pipeline
        :param Sequence[_builtins.str] policies: The policies for this pipeline
        :param Sequence['SubscriberResponse'] subscribers: Subscribers of this resource
        """
        pulumi.set(__self__, "connections", connections)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "remote_cloud", remote_cloud)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if flow_types is not None:
            pulumi.set(__self__, "flow_types", flow_types)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if subscribers is not None:
            pulumi.set(__self__, "subscribers", subscribers)

    @_builtins.property
    @pulumi.getter
    def connections(self) -> Sequence['outputs.PipelineConnectionResponse']:
        """
        Connections associated with pipeline
        """
        return pulumi.get(self, "connections")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the pipeline
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="remoteCloud")
    def remote_cloud(self) -> _builtins.str:
        """
        Remote cloud of the data to be transferred or received
        """
        return pulumi.get(self, "remote_cloud")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        Display name of this pipeline
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="flowTypes")
    def flow_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The flow types allowed for this pipeline
        """
        return pulumi.get(self, "flow_types")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[_builtins.str]]:
        """
        The policies for this pipeline
        """
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter
    def subscribers(self) -> Optional[Sequence['outputs.SubscriberResponse']]:
        """
        Subscribers of this resource
        """
        return pulumi.get(self, "subscribers")


@pulumi.output_type
class PlanResponse(dict):
    """
    Plan for the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "promotionCode":
            suggest = "promotion_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 product: _builtins.str,
                 publisher: _builtins.str,
                 promotion_code: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        Plan for the resource.
        :param _builtins.str name: A user defined name of the 3rd Party Artifact that is being procured.
        :param _builtins.str product: The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding. 
        :param _builtins.str publisher: The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
        :param _builtins.str promotion_code: A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
        :param _builtins.str version: The version of the desired product/artifact.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)
        if promotion_code is not None:
            pulumi.set(__self__, "promotion_code", promotion_code)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A user defined name of the 3rd Party Artifact that is being procured.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def product(self) -> _builtins.str:
        """
        The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding. 
        """
        return pulumi.get(self, "product")

    @_builtins.property
    @pulumi.getter
    def publisher(self) -> _builtins.str:
        """
        The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
        """
        return pulumi.get(self, "publisher")

    @_builtins.property
    @pulumi.getter(name="promotionCode")
    def promotion_code(self) -> Optional[_builtins.str]:
        """
        A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
        """
        return pulumi.get(self, "promotion_code")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The version of the desired product/artifact.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SchemaResponse(dict):
    """
    The schema object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionId":
            suggest = "connection_id"
        elif key == "schemaType":
            suggest = "schema_type"
        elif key == "schemaUri":
            suggest = "schema_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SchemaResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SchemaResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SchemaResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_id: Optional[_builtins.str] = None,
                 content: Optional[_builtins.str] = None,
                 direction: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 schema_type: Optional[_builtins.str] = None,
                 schema_uri: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        The schema object.
        :param _builtins.str connection_id: Connection ID associated with this schema
        :param _builtins.str content: Content of the schema
        :param _builtins.str direction: The direction of the schema.
        :param _builtins.str id: ID associated with this schema
        :param _builtins.str name: Name of the schema
        :param _builtins.str schema_type: The Schema Type
        :param _builtins.str schema_uri: Uri containing SAS token for the zipped schema
        :param _builtins.str status: Status of the schema
        """
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schema_type is not None:
            pulumi.set(__self__, "schema_type", schema_type)
        if schema_uri is not None:
            pulumi.set(__self__, "schema_uri", schema_uri)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[_builtins.str]:
        """
        Connection ID associated with this schema
        """
        return pulumi.get(self, "connection_id")

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        """
        Content of the schema
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The direction of the schema.
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID associated with this schema
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the schema
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="schemaType")
    def schema_type(self) -> Optional[_builtins.str]:
        """
        The Schema Type
        """
        return pulumi.get(self, "schema_type")

    @_builtins.property
    @pulumi.getter(name="schemaUri")
    def schema_uri(self) -> Optional[_builtins.str]:
        """
        Uri containing SAS token for the zipped schema
        """
        return pulumi.get(self, "schema_uri")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the schema
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SelectedResourceResponse(dict):
    """
    A resource selected from ARM
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subscriptionName":
            suggest = "subscription_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SelectedResourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SelectedResourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SelectedResourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 location: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 subscription_name: Optional[_builtins.str] = None):
        """
        A resource selected from ARM
        :param _builtins.str id: Id of the connection
        :param _builtins.str location: Location of the connection
        :param _builtins.str name: Name of the connection
        :param _builtins.str subscription_name: Name of the subscription with the connection
        """
        pulumi.set(__self__, "id", id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if subscription_name is not None:
            pulumi.set(__self__, "subscription_name", subscription_name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Id of the connection
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        Location of the connection
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the connection
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="subscriptionName")
    def subscription_name(self) -> Optional[_builtins.str]:
        """
        Name of the subscription with the connection
        """
        return pulumi.get(self, "subscription_name")


@pulumi.output_type
class StreamSourceAddressesResponse(dict):
    """
    The source IP address and CIDR ranges of the stream
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceAddresses":
            suggest = "source_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceAddressesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceAddressesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceAddressesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_addresses: Optional[Sequence[_builtins.str]] = None):
        """
        The source IP address and CIDR ranges of the stream
        :param Sequence[_builtins.str] source_addresses: A source IP address or CIDR range
        """
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        A source IP address or CIDR range
        """
        return pulumi.get(self, "source_addresses")


@pulumi.output_type
class SubscriberResponse(dict):
    def __init__(__self__, *,
                 email: Optional[_builtins.str] = None,
                 notifications: Optional[_builtins.float] = None):
        """
        :param _builtins.str email: Email of the subscriber
        :param _builtins.float notifications: Number specifying what notifications to receive
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if notifications is not None:
            pulumi.set(__self__, "notifications", notifications)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        Email of the subscriber
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def notifications(self) -> Optional[_builtins.float]:
        """
        Number specifying what notifications to receive
        """
        return pulumi.get(self, "notifications")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 created_by_type: Optional[_builtins.str] = None,
                 last_modified_at: Optional[_builtins.str] = None,
                 last_modified_by: Optional[_builtins.str] = None,
                 last_modified_by_type: Optional[_builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param _builtins.str created_at: The timestamp of resource creation (UTC).
        :param _builtins.str created_by: The identity that created the resource.
        :param _builtins.str created_by_type: The type of identity that created the resource.
        :param _builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param _builtins.str last_modified_by: The identity that last modified the resource.
        :param _builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @_builtins.property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @_builtins.property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[_builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @_builtins.property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TextMatchResponse(dict):
    """
    Configuration options for the text matching ruleset. For example, if the configuration is to deny "hello world" for partial case-insensitive words then "chello worlds" would get detected and the resulting file would be denied.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitivity":
            suggest = "case_sensitivity"
        elif key == "matchType":
            suggest = "match_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TextMatchResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TextMatchResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TextMatchResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 case_sensitivity: Optional[_builtins.str] = None,
                 match_type: Optional[_builtins.str] = None,
                 text: _builtins.str):
        """
        Configuration options for the text matching ruleset. For example, if the configuration is to deny "hello world" for partial case-insensitive words then "chello worlds" would get detected and the resulting file would be denied.
        :param _builtins.str case_sensitivity: Specifies the text matching conditions based on casing. For more detail please refer to the Casing model.
        :param _builtins.str match_type: Specifies the text matching condition for text comparison. For more detail please refer to the MatchType model.
        :param _builtins.str text: The word or phrase to match against replicated content. A phrase with spaces will be considered a single substring.
        """
        if case_sensitivity is None:
            case_sensitivity = 'Insensitive'
        pulumi.set(__self__, "case_sensitivity", case_sensitivity)
        if match_type is None:
            match_type = 'Partial'
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="caseSensitivity")
    def case_sensitivity(self) -> _builtins.str:
        """
        Specifies the text matching conditions based on casing. For more detail please refer to the Casing model.
        """
        return pulumi.get(self, "case_sensitivity")

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> _builtins.str:
        """
        Specifies the text matching condition for text comparison. For more detail please refer to the MatchType model.
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter
    def text(self) -> _builtins.str:
        """
        The word or phrase to match against replicated content. A phrase with spaces will be considered a single substring.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class TextMatchingRulesetResponse(dict):
    """
    Rules for detecting and blocking specific text patterns. If a file contains a text pattern that is part of the configured deny list, the file will be denied.
    """
    def __init__(__self__, *,
                 deny: Optional[Sequence['outputs.TextMatchResponse']] = None):
        """
        Rules for detecting and blocking specific text patterns. If a file contains a text pattern that is part of the configured deny list, the file will be denied.
        :param Sequence['TextMatchResponse'] deny: A list of text patterns to block, each with matching rules and case sensitivity options.
        """
        if deny is not None:
            pulumi.set(__self__, "deny", deny)

    @_builtins.property
    @pulumi.getter
    def deny(self) -> Optional[Sequence['outputs.TextMatchResponse']]:
        """
        A list of text patterns to block, each with matching rules and case sensitivity options.
        """
        return pulumi.get(self, "deny")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 principal_id: _builtins.str):
        """
        User assigned identity properties
        :param _builtins.str client_id: The client ID of the assigned identity.
        :param _builtins.str principal_id: The principal ID of the assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class XmlFilterRulesetResponse(dict):
    """
    Rules for filtering XML content using XSD schemas.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultNamespace":
            suggest = "default_namespace"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in XmlFilterRulesetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        XmlFilterRulesetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        XmlFilterRulesetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_namespace: Optional[_builtins.str] = None,
                 reference: Optional[_builtins.str] = None,
                 schema: Optional[_builtins.str] = None):
        """
        Rules for filtering XML content using XSD schemas.
        :param _builtins.str default_namespace: The default XML namespace used for schema validation.
        :param _builtins.str reference: Defines the method for referencing the xml schema.
        :param _builtins.str schema: The inline XSD schema to be used for validation.
        """
        if default_namespace is not None:
            pulumi.set(__self__, "default_namespace", default_namespace)
        if reference is not None:
            pulumi.set(__self__, "reference", reference)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)

    @_builtins.property
    @pulumi.getter(name="defaultNamespace")
    def default_namespace(self) -> Optional[_builtins.str]:
        """
        The default XML namespace used for schema validation.
        """
        return pulumi.get(self, "default_namespace")

    @_builtins.property
    @pulumi.getter
    def reference(self) -> Optional[_builtins.str]:
        """
        Defines the method for referencing the xml schema.
        """
        return pulumi.get(self, "reference")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        """
        The inline XSD schema to be used for validation.
        """
        return pulumi.get(self, "schema")


