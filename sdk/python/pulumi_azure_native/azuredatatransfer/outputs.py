# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ConnectionPropertiesResponse',
    'FlowPropertiesResponse',
    'InternalMetadataPropertiesResponse',
    'ManagedServiceIdentityResponse',
    'MessagingOptionsResponse',
    'OperationStatusPropertiesResponse',
    'PendingConnectionResponse',
    'PendingFlowResponse',
    'PipelineConnectionResponse',
    'PipelineConnectionResponseProperties',
    'PipelinePropertiesResponse',
    'PlanResponse',
    'SchemaResponse',
    'SelectedResourceResponse',
    'StreamSourceAddressesResponse',
    'SubscriberResponse',
    'SystemDataResponse',
    'UserAssignedIdentityResponse',
]

@pulumi.output_type
class ConnectionPropertiesResponse(dict):
    """
    Properties of connection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateSubmitted":
            suggest = "date_submitted"
        elif key == "linkStatus":
            suggest = "link_status"
        elif key == "linkedConnectionId":
            suggest = "linked_connection_id"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "statusReason":
            suggest = "status_reason"
        elif key == "flowTypes":
            suggest = "flow_types"
        elif key == "primaryContact":
            suggest = "primary_contact"
        elif key == "remoteSubscriptionId":
            suggest = "remote_subscription_id"
        elif key == "requirementId":
            suggest = "requirement_id"
        elif key == "schemaUris":
            suggest = "schema_uris"
        elif key == "secondaryContacts":
            suggest = "secondary_contacts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approver: builtins.str,
                 date_submitted: builtins.str,
                 link_status: builtins.str,
                 linked_connection_id: builtins.str,
                 pipeline: builtins.str,
                 provisioning_state: builtins.str,
                 status: builtins.str,
                 status_reason: builtins.str,
                 direction: Optional[builtins.str] = None,
                 flow_types: Optional[Sequence[builtins.str]] = None,
                 justification: Optional[builtins.str] = None,
                 pin: Optional[builtins.str] = None,
                 policies: Optional[Sequence[builtins.str]] = None,
                 primary_contact: Optional[builtins.str] = None,
                 remote_subscription_id: Optional[builtins.str] = None,
                 requirement_id: Optional[builtins.str] = None,
                 schema_uris: Optional[Sequence[builtins.str]] = None,
                 schemas: Optional[Sequence['outputs.SchemaResponse']] = None,
                 secondary_contacts: Optional[Sequence[builtins.str]] = None):
        """
        Properties of connection
        :param builtins.str approver: Approver of this connection request
        :param builtins.str date_submitted: The timestamp that this connection request was submitted at
        :param builtins.str link_status: Link status of the current connection
        :param builtins.str linked_connection_id: Resource ID of the linked connection
        :param builtins.str pipeline: Pipeline to use to transfer data
        :param builtins.str provisioning_state: Provisioning state of the connection
        :param builtins.str status: Status of the connection
        :param builtins.str status_reason: Reason for status
        :param builtins.str direction: Direction of data movement
        :param Sequence[builtins.str] flow_types: The flow types being requested for this connection
        :param builtins.str justification: Justification for the connection request
        :param builtins.str pin: PIN to link requests together
        :param Sequence[builtins.str] policies: The policies for this connection
        :param builtins.str primary_contact: The primary contact for this connection request
        :param builtins.str remote_subscription_id: Subscription ID to link cloud subscriptions together
        :param builtins.str requirement_id: Requirement ID of the connection
        :param Sequence[builtins.str] schema_uris: The schema URIs for this connection
        :param Sequence['SchemaResponse'] schemas: The schemas for this connection
        :param Sequence[builtins.str] secondary_contacts: The secondary contacts for this connection request
        """
        pulumi.set(__self__, "approver", approver)
        pulumi.set(__self__, "date_submitted", date_submitted)
        pulumi.set(__self__, "link_status", link_status)
        pulumi.set(__self__, "linked_connection_id", linked_connection_id)
        pulumi.set(__self__, "pipeline", pipeline)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_reason", status_reason)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if flow_types is not None:
            pulumi.set(__self__, "flow_types", flow_types)
        if justification is not None:
            pulumi.set(__self__, "justification", justification)
        if pin is not None:
            pulumi.set(__self__, "pin", pin)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if primary_contact is not None:
            pulumi.set(__self__, "primary_contact", primary_contact)
        if remote_subscription_id is not None:
            pulumi.set(__self__, "remote_subscription_id", remote_subscription_id)
        if requirement_id is not None:
            pulumi.set(__self__, "requirement_id", requirement_id)
        if schema_uris is not None:
            pulumi.set(__self__, "schema_uris", schema_uris)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)
        if secondary_contacts is not None:
            pulumi.set(__self__, "secondary_contacts", secondary_contacts)

    @property
    @pulumi.getter
    def approver(self) -> builtins.str:
        """
        Approver of this connection request
        """
        return pulumi.get(self, "approver")

    @property
    @pulumi.getter(name="dateSubmitted")
    def date_submitted(self) -> builtins.str:
        """
        The timestamp that this connection request was submitted at
        """
        return pulumi.get(self, "date_submitted")

    @property
    @pulumi.getter(name="linkStatus")
    def link_status(self) -> builtins.str:
        """
        Link status of the current connection
        """
        return pulumi.get(self, "link_status")

    @property
    @pulumi.getter(name="linkedConnectionId")
    def linked_connection_id(self) -> builtins.str:
        """
        Resource ID of the linked connection
        """
        return pulumi.get(self, "linked_connection_id")

    @property
    @pulumi.getter
    def pipeline(self) -> builtins.str:
        """
        Pipeline to use to transfer data
        """
        return pulumi.get(self, "pipeline")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state of the connection
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Status of the connection
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusReason")
    def status_reason(self) -> builtins.str:
        """
        Reason for status
        """
        return pulumi.get(self, "status_reason")

    @property
    @pulumi.getter
    def direction(self) -> Optional[builtins.str]:
        """
        Direction of data movement
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="flowTypes")
    def flow_types(self) -> Optional[Sequence[builtins.str]]:
        """
        The flow types being requested for this connection
        """
        return pulumi.get(self, "flow_types")

    @property
    @pulumi.getter
    def justification(self) -> Optional[builtins.str]:
        """
        Justification for the connection request
        """
        return pulumi.get(self, "justification")

    @property
    @pulumi.getter
    def pin(self) -> Optional[builtins.str]:
        """
        PIN to link requests together
        """
        return pulumi.get(self, "pin")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[builtins.str]]:
        """
        The policies for this connection
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="primaryContact")
    def primary_contact(self) -> Optional[builtins.str]:
        """
        The primary contact for this connection request
        """
        return pulumi.get(self, "primary_contact")

    @property
    @pulumi.getter(name="remoteSubscriptionId")
    def remote_subscription_id(self) -> Optional[builtins.str]:
        """
        Subscription ID to link cloud subscriptions together
        """
        return pulumi.get(self, "remote_subscription_id")

    @property
    @pulumi.getter(name="requirementId")
    def requirement_id(self) -> Optional[builtins.str]:
        """
        Requirement ID of the connection
        """
        return pulumi.get(self, "requirement_id")

    @property
    @pulumi.getter(name="schemaUris")
    def schema_uris(self) -> Optional[Sequence[builtins.str]]:
        """
        The schema URIs for this connection
        """
        return pulumi.get(self, "schema_uris")

    @property
    @pulumi.getter
    def schemas(self) -> Optional[Sequence['outputs.SchemaResponse']]:
        """
        The schemas for this connection
        """
        return pulumi.get(self, "schemas")

    @property
    @pulumi.getter(name="secondaryContacts")
    def secondary_contacts(self) -> Optional[Sequence[builtins.str]]:
        """
        The secondary contacts for this connection request
        """
        return pulumi.get(self, "secondary_contacts")


@pulumi.output_type
class FlowPropertiesResponse(dict):
    """
    Properties of flow
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flowId":
            suggest = "flow_id"
        elif key == "linkStatus":
            suggest = "link_status"
        elif key == "linkedFlowId":
            suggest = "linked_flow_id"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "customerManagedKeyVaultUri":
            suggest = "customer_managed_key_vault_uri"
        elif key == "dataType":
            suggest = "data_type"
        elif key == "destinationEndpointPorts":
            suggest = "destination_endpoint_ports"
        elif key == "destinationEndpoints":
            suggest = "destination_endpoints"
        elif key == "flowType":
            suggest = "flow_type"
        elif key == "keyVaultUri":
            suggest = "key_vault_uri"
        elif key == "messagingOptions":
            suggest = "messaging_options"
        elif key == "serviceBusQueueId":
            suggest = "service_bus_queue_id"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "storageAccountId":
            suggest = "storage_account_id"
        elif key == "storageAccountName":
            suggest = "storage_account_name"
        elif key == "storageContainerName":
            suggest = "storage_container_name"
        elif key == "streamId":
            suggest = "stream_id"
        elif key == "streamLatency":
            suggest = "stream_latency"
        elif key == "streamProtocol":
            suggest = "stream_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flow_id: builtins.str,
                 link_status: builtins.str,
                 linked_flow_id: builtins.str,
                 provisioning_state: builtins.str,
                 connection: Optional['outputs.SelectedResourceResponse'] = None,
                 customer_managed_key_vault_uri: Optional[builtins.str] = None,
                 data_type: Optional[builtins.str] = None,
                 destination_endpoint_ports: Optional[Sequence[builtins.float]] = None,
                 destination_endpoints: Optional[Sequence[builtins.str]] = None,
                 flow_type: Optional[builtins.str] = None,
                 key_vault_uri: Optional[builtins.str] = None,
                 messaging_options: Optional['outputs.MessagingOptionsResponse'] = None,
                 passphrase: Optional[builtins.str] = None,
                 policies: Optional[Sequence[builtins.str]] = None,
                 schema: Optional['outputs.SchemaResponse'] = None,
                 service_bus_queue_id: Optional[builtins.str] = None,
                 source_addresses: Optional['outputs.StreamSourceAddressesResponse'] = None,
                 status: Optional[builtins.str] = None,
                 storage_account_id: Optional[builtins.str] = None,
                 storage_account_name: Optional[builtins.str] = None,
                 storage_container_name: Optional[builtins.str] = None,
                 stream_id: Optional[builtins.str] = None,
                 stream_latency: Optional[builtins.float] = None,
                 stream_protocol: Optional[builtins.str] = None):
        """
        Properties of flow
        :param builtins.str flow_id: Dataflow GUID associated with this flow
        :param builtins.str link_status: Link status of the current flow
        :param builtins.str linked_flow_id: Resource ID of the linked flow
        :param builtins.str provisioning_state: Provisioning state of the flow
        :param 'SelectedResourceResponse' connection: The connection associated with this flow
        :param builtins.str customer_managed_key_vault_uri: The URI to the customer managed key for this flow
        :param builtins.str data_type: Transfer Storage Blobs or Tables
        :param Sequence[builtins.float] destination_endpoint_ports: The destination endpoint ports of the stream
        :param Sequence[builtins.str] destination_endpoints: The destination endpoints of the stream
        :param builtins.str flow_type: The flow type for this flow
        :param builtins.str key_vault_uri: AME, PME, or TORUS only! AKV Chain Containing SAS Token
        :param 'MessagingOptionsResponse' messaging_options: The messaging options for this flow
        :param builtins.str passphrase: The passphrase used for SRT streams
        :param Sequence[builtins.str] policies: The policies for this flow
        :param 'SchemaResponse' schema: The selected schema for this flow
        :param builtins.str service_bus_queue_id: Service Bus Queue ID
        :param 'StreamSourceAddressesResponse' source_addresses: The source IP address and CIDR ranges of the stream
        :param builtins.str status: Status of the current flow
        :param builtins.str storage_account_id: Storage Account ID
        :param builtins.str storage_account_name: Storage Account
        :param builtins.str storage_container_name: Storage Container Name
        :param builtins.str stream_id: The flow stream identifier
        :param builtins.float stream_latency: The latency of the stream in milliseconds
        :param builtins.str stream_protocol: The protocol of the stream
        """
        pulumi.set(__self__, "flow_id", flow_id)
        pulumi.set(__self__, "link_status", link_status)
        pulumi.set(__self__, "linked_flow_id", linked_flow_id)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if customer_managed_key_vault_uri is not None:
            pulumi.set(__self__, "customer_managed_key_vault_uri", customer_managed_key_vault_uri)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if destination_endpoint_ports is not None:
            pulumi.set(__self__, "destination_endpoint_ports", destination_endpoint_ports)
        if destination_endpoints is not None:
            pulumi.set(__self__, "destination_endpoints", destination_endpoints)
        if flow_type is not None:
            pulumi.set(__self__, "flow_type", flow_type)
        if key_vault_uri is not None:
            pulumi.set(__self__, "key_vault_uri", key_vault_uri)
        if messaging_options is not None:
            pulumi.set(__self__, "messaging_options", messaging_options)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if service_bus_queue_id is not None:
            pulumi.set(__self__, "service_bus_queue_id", service_bus_queue_id)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if storage_account_id is not None:
            pulumi.set(__self__, "storage_account_id", storage_account_id)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)
        if storage_container_name is not None:
            pulumi.set(__self__, "storage_container_name", storage_container_name)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if stream_latency is not None:
            pulumi.set(__self__, "stream_latency", stream_latency)
        if stream_protocol is not None:
            pulumi.set(__self__, "stream_protocol", stream_protocol)

    @property
    @pulumi.getter(name="flowId")
    def flow_id(self) -> builtins.str:
        """
        Dataflow GUID associated with this flow
        """
        return pulumi.get(self, "flow_id")

    @property
    @pulumi.getter(name="linkStatus")
    def link_status(self) -> builtins.str:
        """
        Link status of the current flow
        """
        return pulumi.get(self, "link_status")

    @property
    @pulumi.getter(name="linkedFlowId")
    def linked_flow_id(self) -> builtins.str:
        """
        Resource ID of the linked flow
        """
        return pulumi.get(self, "linked_flow_id")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state of the flow
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def connection(self) -> Optional['outputs.SelectedResourceResponse']:
        """
        The connection associated with this flow
        """
        return pulumi.get(self, "connection")

    @property
    @pulumi.getter(name="customerManagedKeyVaultUri")
    def customer_managed_key_vault_uri(self) -> Optional[builtins.str]:
        """
        The URI to the customer managed key for this flow
        """
        return pulumi.get(self, "customer_managed_key_vault_uri")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[builtins.str]:
        """
        Transfer Storage Blobs or Tables
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="destinationEndpointPorts")
    def destination_endpoint_ports(self) -> Optional[Sequence[builtins.float]]:
        """
        The destination endpoint ports of the stream
        """
        return pulumi.get(self, "destination_endpoint_ports")

    @property
    @pulumi.getter(name="destinationEndpoints")
    def destination_endpoints(self) -> Optional[Sequence[builtins.str]]:
        """
        The destination endpoints of the stream
        """
        return pulumi.get(self, "destination_endpoints")

    @property
    @pulumi.getter(name="flowType")
    def flow_type(self) -> Optional[builtins.str]:
        """
        The flow type for this flow
        """
        return pulumi.get(self, "flow_type")

    @property
    @pulumi.getter(name="keyVaultUri")
    def key_vault_uri(self) -> Optional[builtins.str]:
        """
        AME, PME, or TORUS only! AKV Chain Containing SAS Token
        """
        return pulumi.get(self, "key_vault_uri")

    @property
    @pulumi.getter(name="messagingOptions")
    def messaging_options(self) -> Optional['outputs.MessagingOptionsResponse']:
        """
        The messaging options for this flow
        """
        return pulumi.get(self, "messaging_options")

    @property
    @pulumi.getter
    def passphrase(self) -> Optional[builtins.str]:
        """
        The passphrase used for SRT streams
        """
        return pulumi.get(self, "passphrase")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[builtins.str]]:
        """
        The policies for this flow
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter
    def schema(self) -> Optional['outputs.SchemaResponse']:
        """
        The selected schema for this flow
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter(name="serviceBusQueueId")
    def service_bus_queue_id(self) -> Optional[builtins.str]:
        """
        Service Bus Queue ID
        """
        return pulumi.get(self, "service_bus_queue_id")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional['outputs.StreamSourceAddressesResponse']:
        """
        The source IP address and CIDR ranges of the stream
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Status of the current flow
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> Optional[builtins.str]:
        """
        Storage Account ID
        """
        return pulumi.get(self, "storage_account_id")

    @property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[builtins.str]:
        """
        Storage Account
        """
        return pulumi.get(self, "storage_account_name")

    @property
    @pulumi.getter(name="storageContainerName")
    def storage_container_name(self) -> Optional[builtins.str]:
        """
        Storage Container Name
        """
        return pulumi.get(self, "storage_container_name")

    @property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[builtins.str]:
        """
        The flow stream identifier
        """
        return pulumi.get(self, "stream_id")

    @property
    @pulumi.getter(name="streamLatency")
    def stream_latency(self) -> Optional[builtins.float]:
        """
        The latency of the stream in milliseconds
        """
        return pulumi.get(self, "stream_latency")

    @property
    @pulumi.getter(name="streamProtocol")
    def stream_protocol(self) -> Optional[builtins.str]:
        """
        The protocol of the stream
        """
        return pulumi.get(self, "stream_protocol")


@pulumi.output_type
class InternalMetadataPropertiesResponse(dict):
    """
    Internal metadata of the connection inside pipeline.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusSetBy":
            suggest = "status_set_by"
        elif key == "operationStatus":
            suggest = "operation_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternalMetadataPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternalMetadataPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternalMetadataPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_set_by: builtins.str,
                 operation_status: Optional['outputs.OperationStatusPropertiesResponse'] = None):
        """
        Internal metadata of the connection inside pipeline.
        :param builtins.str status_set_by: User that last set the approved status for this connection
        :param 'OperationStatusPropertiesResponse' operation_status: Operation status associated with the last patch request
        """
        pulumi.set(__self__, "status_set_by", status_set_by)
        if operation_status is not None:
            pulumi.set(__self__, "operation_status", operation_status)

    @property
    @pulumi.getter(name="statusSetBy")
    def status_set_by(self) -> builtins.str:
        """
        User that last set the approved status for this connection
        """
        return pulumi.get(self, "status_set_by")

    @property
    @pulumi.getter(name="operationStatus")
    def operation_status(self) -> Optional['outputs.OperationStatusPropertiesResponse']:
        """
        Operation status associated with the last patch request
        """
        return pulumi.get(self, "operation_status")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity (system assigned and/or user assigned identities)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: builtins.str,
                 tenant_id: builtins.str,
                 type: builtins.str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param builtins.str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param builtins.str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param builtins.str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> builtins.str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> builtins.str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class MessagingOptionsResponse(dict):
    """
    The option associated with messaging flows.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "billingTier":
            suggest = "billing_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MessagingOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MessagingOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MessagingOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 billing_tier: Optional[builtins.str] = None):
        """
        The option associated with messaging flows.
        :param builtins.str billing_tier: Billing tier for this messaging flow
        """
        if billing_tier is not None:
            pulumi.set(__self__, "billing_tier", billing_tier)

    @property
    @pulumi.getter(name="billingTier")
    def billing_tier(self) -> Optional[builtins.str]:
        """
        Billing tier for this messaging flow
        """
        return pulumi.get(self, "billing_tier")


@pulumi.output_type
class OperationStatusPropertiesResponse(dict):
    """
    Operation status associated with the last patch request
    """
    def __init__(__self__, *,
                 id: builtins.str,
                 message: builtins.str,
                 status: builtins.str):
        """
        Operation status associated with the last patch request
        :param builtins.str id: Operation status ID of the last patch request for this connection.
        :param builtins.str message: Message for the operation for the last patch request for this connection.
        :param builtins.str status: Operation status for the last patch request for this connection.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Operation status ID of the last patch request for this connection.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def message(self) -> builtins.str:
        """
        Message for the operation for the last patch request for this connection.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Operation status for the last patch request for this connection.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class PendingConnectionResponse(dict):
    """
    Pending connection object
    """
    def __init__(__self__, *,
                 approver: builtins.str,
                 date_submitted: builtins.str,
                 id: builtins.str,
                 link_status: builtins.str,
                 linked_connection_id: builtins.str,
                 location: builtins.str,
                 name: builtins.str,
                 pipeline: builtins.str,
                 provisioning_state: builtins.str,
                 status: builtins.str,
                 status_reason: builtins.str,
                 subscription_id: builtins.str,
                 system_data: 'outputs.SystemDataResponse',
                 type: builtins.str,
                 direction: Optional[builtins.str] = None,
                 flow_types: Optional[Sequence[builtins.str]] = None,
                 justification: Optional[builtins.str] = None,
                 pin: Optional[builtins.str] = None,
                 policies: Optional[Sequence[builtins.str]] = None,
                 primary_contact: Optional[builtins.str] = None,
                 remote_subscription_id: Optional[builtins.str] = None,
                 requirement_id: Optional[builtins.str] = None,
                 schema_uris: Optional[Sequence[builtins.str]] = None,
                 schemas: Optional[Sequence['outputs.SchemaResponse']] = None,
                 secondary_contacts: Optional[Sequence[builtins.str]] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Pending connection object
        :param builtins.str approver: Approver of this connection request
        :param builtins.str date_submitted: The timestamp that this connection request was submitted at
        :param builtins.str id: Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        :param builtins.str link_status: Link status of the current connection
        :param builtins.str linked_connection_id: Resource ID of the linked connection
        :param builtins.str location: The geo-location where the resource lives
        :param builtins.str name: The name of the resource
        :param builtins.str pipeline: Pipeline to use to transfer data
        :param builtins.str provisioning_state: Provisioning state of the connection
        :param builtins.str status: Status of the connection
        :param builtins.str status_reason: Reason for status
        :param builtins.str subscription_id: Subscription ID of the pending connection.
        :param 'SystemDataResponse' system_data: Azure Resource Manager metadata containing createdBy and modifiedBy information.
        :param builtins.str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param builtins.str direction: Direction of data movement
        :param Sequence[builtins.str] flow_types: The flow types being requested for this connection
        :param builtins.str justification: Justification for the connection request
        :param builtins.str pin: PIN to link requests together
        :param Sequence[builtins.str] policies: The policies for this connection
        :param builtins.str primary_contact: The primary contact for this connection request
        :param builtins.str remote_subscription_id: Subscription ID to link cloud subscriptions together
        :param builtins.str requirement_id: Requirement ID of the connection
        :param Sequence[builtins.str] schema_uris: The schema URIs for this connection
        :param Sequence['SchemaResponse'] schemas: The schemas for this connection
        :param Sequence[builtins.str] secondary_contacts: The secondary contacts for this connection request
        :param Mapping[str, builtins.str] tags: Resource tags.
        """
        pulumi.set(__self__, "approver", approver)
        pulumi.set(__self__, "date_submitted", date_submitted)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "link_status", link_status)
        pulumi.set(__self__, "linked_connection_id", linked_connection_id)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pipeline", pipeline)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_reason", status_reason)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "system_data", system_data)
        pulumi.set(__self__, "type", type)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if flow_types is not None:
            pulumi.set(__self__, "flow_types", flow_types)
        if justification is not None:
            pulumi.set(__self__, "justification", justification)
        if pin is not None:
            pulumi.set(__self__, "pin", pin)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if primary_contact is not None:
            pulumi.set(__self__, "primary_contact", primary_contact)
        if remote_subscription_id is not None:
            pulumi.set(__self__, "remote_subscription_id", remote_subscription_id)
        if requirement_id is not None:
            pulumi.set(__self__, "requirement_id", requirement_id)
        if schema_uris is not None:
            pulumi.set(__self__, "schema_uris", schema_uris)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)
        if secondary_contacts is not None:
            pulumi.set(__self__, "secondary_contacts", secondary_contacts)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def approver(self) -> builtins.str:
        """
        Approver of this connection request
        """
        return pulumi.get(self, "approver")

    @property
    @pulumi.getter(name="dateSubmitted")
    def date_submitted(self) -> builtins.str:
        """
        The timestamp that this connection request was submitted at
        """
        return pulumi.get(self, "date_submitted")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="linkStatus")
    def link_status(self) -> builtins.str:
        """
        Link status of the current connection
        """
        return pulumi.get(self, "link_status")

    @property
    @pulumi.getter(name="linkedConnectionId")
    def linked_connection_id(self) -> builtins.str:
        """
        Resource ID of the linked connection
        """
        return pulumi.get(self, "linked_connection_id")

    @property
    @pulumi.getter
    def location(self) -> builtins.str:
        """
        The geo-location where the resource lives
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pipeline(self) -> builtins.str:
        """
        Pipeline to use to transfer data
        """
        return pulumi.get(self, "pipeline")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state of the connection
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Status of the connection
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusReason")
    def status_reason(self) -> builtins.str:
        """
        Reason for status
        """
        return pulumi.get(self, "status_reason")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> builtins.str:
        """
        Subscription ID of the pending connection.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Azure Resource Manager metadata containing createdBy and modifiedBy information.
        """
        return pulumi.get(self, "system_data")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def direction(self) -> Optional[builtins.str]:
        """
        Direction of data movement
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="flowTypes")
    def flow_types(self) -> Optional[Sequence[builtins.str]]:
        """
        The flow types being requested for this connection
        """
        return pulumi.get(self, "flow_types")

    @property
    @pulumi.getter
    def justification(self) -> Optional[builtins.str]:
        """
        Justification for the connection request
        """
        return pulumi.get(self, "justification")

    @property
    @pulumi.getter
    def pin(self) -> Optional[builtins.str]:
        """
        PIN to link requests together
        """
        return pulumi.get(self, "pin")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[builtins.str]]:
        """
        The policies for this connection
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="primaryContact")
    def primary_contact(self) -> Optional[builtins.str]:
        """
        The primary contact for this connection request
        """
        return pulumi.get(self, "primary_contact")

    @property
    @pulumi.getter(name="remoteSubscriptionId")
    def remote_subscription_id(self) -> Optional[builtins.str]:
        """
        Subscription ID to link cloud subscriptions together
        """
        return pulumi.get(self, "remote_subscription_id")

    @property
    @pulumi.getter(name="requirementId")
    def requirement_id(self) -> Optional[builtins.str]:
        """
        Requirement ID of the connection
        """
        return pulumi.get(self, "requirement_id")

    @property
    @pulumi.getter(name="schemaUris")
    def schema_uris(self) -> Optional[Sequence[builtins.str]]:
        """
        The schema URIs for this connection
        """
        return pulumi.get(self, "schema_uris")

    @property
    @pulumi.getter
    def schemas(self) -> Optional[Sequence['outputs.SchemaResponse']]:
        """
        The schemas for this connection
        """
        return pulumi.get(self, "schemas")

    @property
    @pulumi.getter(name="secondaryContacts")
    def secondary_contacts(self) -> Optional[Sequence[builtins.str]]:
        """
        The secondary contacts for this connection request
        """
        return pulumi.get(self, "secondary_contacts")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class PendingFlowResponse(dict):
    """
    Pending flow object
    """
    def __init__(__self__, *,
                 connection_id: builtins.str,
                 flow_id: builtins.str,
                 id: builtins.str,
                 link_status: builtins.str,
                 linked_flow_id: builtins.str,
                 location: builtins.str,
                 name: builtins.str,
                 provisioning_state: builtins.str,
                 subscription_id: builtins.str,
                 system_data: 'outputs.SystemDataResponse',
                 type: builtins.str,
                 connection: Optional['outputs.SelectedResourceResponse'] = None,
                 customer_managed_key_vault_uri: Optional[builtins.str] = None,
                 data_type: Optional[builtins.str] = None,
                 destination_endpoint_ports: Optional[Sequence[builtins.float]] = None,
                 destination_endpoints: Optional[Sequence[builtins.str]] = None,
                 flow_type: Optional[builtins.str] = None,
                 key_vault_uri: Optional[builtins.str] = None,
                 messaging_options: Optional['outputs.MessagingOptionsResponse'] = None,
                 passphrase: Optional[builtins.str] = None,
                 policies: Optional[Sequence[builtins.str]] = None,
                 schema: Optional['outputs.SchemaResponse'] = None,
                 service_bus_queue_id: Optional[builtins.str] = None,
                 source_addresses: Optional['outputs.StreamSourceAddressesResponse'] = None,
                 status: Optional[builtins.str] = None,
                 storage_account_id: Optional[builtins.str] = None,
                 storage_account_name: Optional[builtins.str] = None,
                 storage_container_name: Optional[builtins.str] = None,
                 stream_id: Optional[builtins.str] = None,
                 stream_latency: Optional[builtins.float] = None,
                 stream_protocol: Optional[builtins.str] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Pending flow object
        :param builtins.str connection_id: Connection ID of the pending flow.
        :param builtins.str flow_id: Dataflow GUID associated with this flow
        :param builtins.str id: Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        :param builtins.str link_status: Link status of the current flow
        :param builtins.str linked_flow_id: Resource ID of the linked flow
        :param builtins.str location: The geo-location where the resource lives
        :param builtins.str name: The name of the resource
        :param builtins.str provisioning_state: Provisioning state of the flow
        :param builtins.str subscription_id: Subscription ID of the pending flow.
        :param 'SystemDataResponse' system_data: Azure Resource Manager metadata containing createdBy and modifiedBy information.
        :param builtins.str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param 'SelectedResourceResponse' connection: The connection associated with this flow
        :param builtins.str customer_managed_key_vault_uri: The URI to the customer managed key for this flow
        :param builtins.str data_type: Transfer Storage Blobs or Tables
        :param Sequence[builtins.float] destination_endpoint_ports: The destination endpoint ports of the stream
        :param Sequence[builtins.str] destination_endpoints: The destination endpoints of the stream
        :param builtins.str flow_type: The flow type for this flow
        :param builtins.str key_vault_uri: AME, PME, or TORUS only! AKV Chain Containing SAS Token
        :param 'MessagingOptionsResponse' messaging_options: The messaging options for this flow
        :param builtins.str passphrase: The passphrase used for SRT streams
        :param Sequence[builtins.str] policies: The policies for this flow
        :param 'SchemaResponse' schema: The selected schema for this flow
        :param builtins.str service_bus_queue_id: Service Bus Queue ID
        :param 'StreamSourceAddressesResponse' source_addresses: The source IP address and CIDR ranges of the stream
        :param builtins.str status: Status of the current flow
        :param builtins.str storage_account_id: Storage Account ID
        :param builtins.str storage_account_name: Storage Account
        :param builtins.str storage_container_name: Storage Container Name
        :param builtins.str stream_id: The flow stream identifier
        :param builtins.float stream_latency: The latency of the stream in milliseconds
        :param builtins.str stream_protocol: The protocol of the stream
        :param Mapping[str, builtins.str] tags: Resource tags.
        """
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "flow_id", flow_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "link_status", link_status)
        pulumi.set(__self__, "linked_flow_id", linked_flow_id)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "system_data", system_data)
        pulumi.set(__self__, "type", type)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if customer_managed_key_vault_uri is not None:
            pulumi.set(__self__, "customer_managed_key_vault_uri", customer_managed_key_vault_uri)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if destination_endpoint_ports is not None:
            pulumi.set(__self__, "destination_endpoint_ports", destination_endpoint_ports)
        if destination_endpoints is not None:
            pulumi.set(__self__, "destination_endpoints", destination_endpoints)
        if flow_type is not None:
            pulumi.set(__self__, "flow_type", flow_type)
        if key_vault_uri is not None:
            pulumi.set(__self__, "key_vault_uri", key_vault_uri)
        if messaging_options is not None:
            pulumi.set(__self__, "messaging_options", messaging_options)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if service_bus_queue_id is not None:
            pulumi.set(__self__, "service_bus_queue_id", service_bus_queue_id)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if storage_account_id is not None:
            pulumi.set(__self__, "storage_account_id", storage_account_id)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)
        if storage_container_name is not None:
            pulumi.set(__self__, "storage_container_name", storage_container_name)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if stream_latency is not None:
            pulumi.set(__self__, "stream_latency", stream_latency)
        if stream_protocol is not None:
            pulumi.set(__self__, "stream_protocol", stream_protocol)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> builtins.str:
        """
        Connection ID of the pending flow.
        """
        return pulumi.get(self, "connection_id")

    @property
    @pulumi.getter(name="flowId")
    def flow_id(self) -> builtins.str:
        """
        Dataflow GUID associated with this flow
        """
        return pulumi.get(self, "flow_id")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="linkStatus")
    def link_status(self) -> builtins.str:
        """
        Link status of the current flow
        """
        return pulumi.get(self, "link_status")

    @property
    @pulumi.getter(name="linkedFlowId")
    def linked_flow_id(self) -> builtins.str:
        """
        Resource ID of the linked flow
        """
        return pulumi.get(self, "linked_flow_id")

    @property
    @pulumi.getter
    def location(self) -> builtins.str:
        """
        The geo-location where the resource lives
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state of the flow
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> builtins.str:
        """
        Subscription ID of the pending flow.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Azure Resource Manager metadata containing createdBy and modifiedBy information.
        """
        return pulumi.get(self, "system_data")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def connection(self) -> Optional['outputs.SelectedResourceResponse']:
        """
        The connection associated with this flow
        """
        return pulumi.get(self, "connection")

    @property
    @pulumi.getter(name="customerManagedKeyVaultUri")
    def customer_managed_key_vault_uri(self) -> Optional[builtins.str]:
        """
        The URI to the customer managed key for this flow
        """
        return pulumi.get(self, "customer_managed_key_vault_uri")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[builtins.str]:
        """
        Transfer Storage Blobs or Tables
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="destinationEndpointPorts")
    def destination_endpoint_ports(self) -> Optional[Sequence[builtins.float]]:
        """
        The destination endpoint ports of the stream
        """
        return pulumi.get(self, "destination_endpoint_ports")

    @property
    @pulumi.getter(name="destinationEndpoints")
    def destination_endpoints(self) -> Optional[Sequence[builtins.str]]:
        """
        The destination endpoints of the stream
        """
        return pulumi.get(self, "destination_endpoints")

    @property
    @pulumi.getter(name="flowType")
    def flow_type(self) -> Optional[builtins.str]:
        """
        The flow type for this flow
        """
        return pulumi.get(self, "flow_type")

    @property
    @pulumi.getter(name="keyVaultUri")
    def key_vault_uri(self) -> Optional[builtins.str]:
        """
        AME, PME, or TORUS only! AKV Chain Containing SAS Token
        """
        return pulumi.get(self, "key_vault_uri")

    @property
    @pulumi.getter(name="messagingOptions")
    def messaging_options(self) -> Optional['outputs.MessagingOptionsResponse']:
        """
        The messaging options for this flow
        """
        return pulumi.get(self, "messaging_options")

    @property
    @pulumi.getter
    def passphrase(self) -> Optional[builtins.str]:
        """
        The passphrase used for SRT streams
        """
        return pulumi.get(self, "passphrase")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[builtins.str]]:
        """
        The policies for this flow
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter
    def schema(self) -> Optional['outputs.SchemaResponse']:
        """
        The selected schema for this flow
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter(name="serviceBusQueueId")
    def service_bus_queue_id(self) -> Optional[builtins.str]:
        """
        Service Bus Queue ID
        """
        return pulumi.get(self, "service_bus_queue_id")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional['outputs.StreamSourceAddressesResponse']:
        """
        The source IP address and CIDR ranges of the stream
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Status of the current flow
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> Optional[builtins.str]:
        """
        Storage Account ID
        """
        return pulumi.get(self, "storage_account_id")

    @property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[builtins.str]:
        """
        Storage Account
        """
        return pulumi.get(self, "storage_account_name")

    @property
    @pulumi.getter(name="storageContainerName")
    def storage_container_name(self) -> Optional[builtins.str]:
        """
        Storage Container Name
        """
        return pulumi.get(self, "storage_container_name")

    @property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[builtins.str]:
        """
        The flow stream identifier
        """
        return pulumi.get(self, "stream_id")

    @property
    @pulumi.getter(name="streamLatency")
    def stream_latency(self) -> Optional[builtins.float]:
        """
        The latency of the stream in milliseconds
        """
        return pulumi.get(self, "stream_latency")

    @property
    @pulumi.getter(name="streamProtocol")
    def stream_protocol(self) -> Optional[builtins.str]:
        """
        The protocol of the stream
        """
        return pulumi.get(self, "stream_protocol")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class PipelineConnectionResponse(dict):
    """
    Connection body inside a pipeline
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemData":
            suggest = "system_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 etag: builtins.str,
                 id: builtins.str,
                 location: builtins.str,
                 name: builtins.str,
                 system_data: 'outputs.SystemDataResponse',
                 type: builtins.str,
                 properties: Optional['outputs.PipelineConnectionResponseProperties'] = None):
        """
        Connection body inside a pipeline
        :param builtins.str etag: Connection etag inside pipeline
        :param builtins.str id: Connection id inside pipeline
        :param builtins.str location: Connection location inside pipeline
        :param builtins.str name: Connection name inside pipeline
        :param 'SystemDataResponse' system_data: Metadata pertaining to creation and last modification of the resource.
        :param builtins.str type: Connection type inside pipeline
        :param 'PipelineConnectionResponseProperties' properties: Connection properties inside pipeline
        """
        pulumi.set(__self__, "etag", etag)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "system_data", system_data)
        pulumi.set(__self__, "type", type)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter
    def etag(self) -> builtins.str:
        """
        Connection etag inside pipeline
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Connection id inside pipeline
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> builtins.str:
        """
        Connection location inside pipeline
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Connection name inside pipeline
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Metadata pertaining to creation and last modification of the resource.
        """
        return pulumi.get(self, "system_data")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Connection type inside pipeline
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.PipelineConnectionResponseProperties']:
        """
        Connection properties inside pipeline
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class PipelineConnectionResponseProperties(dict):
    """
    Connection properties inside pipeline
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalMetadata":
            suggest = "internal_metadata"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineConnectionResponseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineConnectionResponseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineConnectionResponseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 internal_metadata: Optional['outputs.InternalMetadataPropertiesResponse'] = None):
        """
        Connection properties inside pipeline
        :param 'InternalMetadataPropertiesResponse' internal_metadata: Internal metadata of the connection inside pipeline.
        """
        if internal_metadata is not None:
            pulumi.set(__self__, "internal_metadata", internal_metadata)

    @property
    @pulumi.getter(name="internalMetadata")
    def internal_metadata(self) -> Optional['outputs.InternalMetadataPropertiesResponse']:
        """
        Internal metadata of the connection inside pipeline.
        """
        return pulumi.get(self, "internal_metadata")


@pulumi.output_type
class PipelinePropertiesResponse(dict):
    """
    Properties of pipeline
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "remoteCloud":
            suggest = "remote_cloud"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "flowTypes":
            suggest = "flow_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelinePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelinePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelinePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connections: Sequence['outputs.PipelineConnectionResponse'],
                 provisioning_state: builtins.str,
                 remote_cloud: builtins.str,
                 display_name: Optional[builtins.str] = None,
                 flow_types: Optional[Sequence[builtins.str]] = None,
                 policies: Optional[Sequence[builtins.str]] = None,
                 subscribers: Optional[Sequence['outputs.SubscriberResponse']] = None):
        """
        Properties of pipeline
        :param Sequence['PipelineConnectionResponse'] connections: Connections associated with pipeline
        :param builtins.str provisioning_state: Provisioning state of the pipeline
        :param builtins.str remote_cloud: Remote cloud of the data to be transferred or received
        :param builtins.str display_name: Display name of this pipeline
        :param Sequence[builtins.str] flow_types: The flow types allowed for this pipeline
        :param Sequence[builtins.str] policies: The policies for this pipeline
        :param Sequence['SubscriberResponse'] subscribers: Subscribers of this resource
        """
        pulumi.set(__self__, "connections", connections)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "remote_cloud", remote_cloud)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if flow_types is not None:
            pulumi.set(__self__, "flow_types", flow_types)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if subscribers is not None:
            pulumi.set(__self__, "subscribers", subscribers)

    @property
    @pulumi.getter
    def connections(self) -> Sequence['outputs.PipelineConnectionResponse']:
        """
        Connections associated with pipeline
        """
        return pulumi.get(self, "connections")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state of the pipeline
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="remoteCloud")
    def remote_cloud(self) -> builtins.str:
        """
        Remote cloud of the data to be transferred or received
        """
        return pulumi.get(self, "remote_cloud")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        Display name of this pipeline
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="flowTypes")
    def flow_types(self) -> Optional[Sequence[builtins.str]]:
        """
        The flow types allowed for this pipeline
        """
        return pulumi.get(self, "flow_types")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[builtins.str]]:
        """
        The policies for this pipeline
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter
    def subscribers(self) -> Optional[Sequence['outputs.SubscriberResponse']]:
        """
        Subscribers of this resource
        """
        return pulumi.get(self, "subscribers")


@pulumi.output_type
class PlanResponse(dict):
    """
    Plan for the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "promotionCode":
            suggest = "promotion_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 product: builtins.str,
                 publisher: builtins.str,
                 promotion_code: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        Plan for the resource.
        :param builtins.str name: A user defined name of the 3rd Party Artifact that is being procured.
        :param builtins.str product: The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding. 
        :param builtins.str publisher: The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
        :param builtins.str promotion_code: A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
        :param builtins.str version: The version of the desired product/artifact.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)
        if promotion_code is not None:
            pulumi.set(__self__, "promotion_code", promotion_code)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        A user defined name of the 3rd Party Artifact that is being procured.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def product(self) -> builtins.str:
        """
        The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding. 
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter
    def publisher(self) -> builtins.str:
        """
        The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter(name="promotionCode")
    def promotion_code(self) -> Optional[builtins.str]:
        """
        A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
        """
        return pulumi.get(self, "promotion_code")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        The version of the desired product/artifact.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SchemaResponse(dict):
    """
    The schema object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionId":
            suggest = "connection_id"
        elif key == "schemaType":
            suggest = "schema_type"
        elif key == "schemaUri":
            suggest = "schema_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SchemaResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SchemaResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SchemaResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_id: Optional[builtins.str] = None,
                 content: Optional[builtins.str] = None,
                 direction: Optional[builtins.str] = None,
                 id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 schema_type: Optional[builtins.str] = None,
                 schema_uri: Optional[builtins.str] = None,
                 status: Optional[builtins.str] = None):
        """
        The schema object.
        :param builtins.str connection_id: Connection ID associated with this schema
        :param builtins.str content: Content of the schema
        :param builtins.str direction: The direction of the schema.
        :param builtins.str id: ID associated with this schema
        :param builtins.str name: Name of the schema
        :param builtins.str schema_type: The Schema Type
        :param builtins.str schema_uri: Uri containing SAS token for the zipped schema
        :param builtins.str status: Status of the schema
        """
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schema_type is not None:
            pulumi.set(__self__, "schema_type", schema_type)
        if schema_uri is not None:
            pulumi.set(__self__, "schema_uri", schema_uri)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[builtins.str]:
        """
        Connection ID associated with this schema
        """
        return pulumi.get(self, "connection_id")

    @property
    @pulumi.getter
    def content(self) -> Optional[builtins.str]:
        """
        Content of the schema
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def direction(self) -> Optional[builtins.str]:
        """
        The direction of the schema.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        ID associated with this schema
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the schema
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="schemaType")
    def schema_type(self) -> Optional[builtins.str]:
        """
        The Schema Type
        """
        return pulumi.get(self, "schema_type")

    @property
    @pulumi.getter(name="schemaUri")
    def schema_uri(self) -> Optional[builtins.str]:
        """
        Uri containing SAS token for the zipped schema
        """
        return pulumi.get(self, "schema_uri")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Status of the schema
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SelectedResourceResponse(dict):
    """
    A resource selected from ARM
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subscriptionName":
            suggest = "subscription_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SelectedResourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SelectedResourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SelectedResourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: builtins.str,
                 location: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 subscription_name: Optional[builtins.str] = None):
        """
        A resource selected from ARM
        :param builtins.str id: Id of the connection
        :param builtins.str location: Location of the connection
        :param builtins.str name: Name of the connection
        :param builtins.str subscription_name: Name of the subscription with the connection
        """
        pulumi.set(__self__, "id", id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if subscription_name is not None:
            pulumi.set(__self__, "subscription_name", subscription_name)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Id of the connection
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> Optional[builtins.str]:
        """
        Location of the connection
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the connection
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="subscriptionName")
    def subscription_name(self) -> Optional[builtins.str]:
        """
        Name of the subscription with the connection
        """
        return pulumi.get(self, "subscription_name")


@pulumi.output_type
class StreamSourceAddressesResponse(dict):
    """
    The source IP address and CIDR ranges of the stream
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceAddresses":
            suggest = "source_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceAddressesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceAddressesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceAddressesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_addresses: Optional[Sequence[builtins.str]] = None):
        """
        The source IP address and CIDR ranges of the stream
        :param Sequence[builtins.str] source_addresses: A source IP address or CIDR range
        """
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[builtins.str]]:
        """
        A source IP address or CIDR range
        """
        return pulumi.get(self, "source_addresses")


@pulumi.output_type
class SubscriberResponse(dict):
    def __init__(__self__, *,
                 email: Optional[builtins.str] = None,
                 notifications: Optional[builtins.float] = None):
        """
        :param builtins.str email: Email of the subscriber
        :param builtins.float notifications: Number specifying what notifications to receive
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if notifications is not None:
            pulumi.set(__self__, "notifications", notifications)

    @property
    @pulumi.getter
    def email(self) -> Optional[builtins.str]:
        """
        Email of the subscriber
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def notifications(self) -> Optional[builtins.float]:
        """
        Number specifying what notifications to receive
        """
        return pulumi.get(self, "notifications")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[builtins.str] = None,
                 created_by: Optional[builtins.str] = None,
                 created_by_type: Optional[builtins.str] = None,
                 last_modified_at: Optional[builtins.str] = None,
                 last_modified_by: Optional[builtins.str] = None,
                 last_modified_by_type: Optional[builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param builtins.str created_at: The timestamp of resource creation (UTC).
        :param builtins.str created_by: The identity that created the resource.
        :param builtins.str created_by_type: The type of identity that created the resource.
        :param builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param builtins.str last_modified_by: The identity that last modified the resource.
        :param builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: builtins.str,
                 principal_id: builtins.str):
        """
        User assigned identity properties
        :param builtins.str client_id: The client ID of the assigned identity.
        :param builtins.str principal_id: The principal ID of the assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> builtins.str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> builtins.str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")


