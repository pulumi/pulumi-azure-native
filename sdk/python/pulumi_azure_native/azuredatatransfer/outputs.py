# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ApiFlowOptionsResponse',
    'ConnectionPropertiesResponse',
    'FlowPropertiesResponse',
    'FlowResponse',
    'InternalMetadataPropertiesResponse',
    'ListFlowsByPipelineConnectionResponse',
    'ManagedServiceIdentityResponse',
    'MessagingOptionsResponse',
    'OperationStatusPropertiesResponse',
    'PendingConnectionResponse',
    'PendingFlowResponse',
    'PipelineConnectionResponse',
    'PipelineConnectionResponseProperties',
    'PipelinePropertiesResponse',
    'PlanResponse',
    'SchemaResponse',
    'SelectedResourceResponse',
    'StreamSourceAddressesResponse',
    'SubscriberResponse',
    'SystemDataResponse',
    'UserAssignedIdentityResponse',
]

@pulumi.output_type
class ApiFlowOptionsResponse(dict):
    """
    Properties specific to API Flow Type
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiMode":
            suggest = "api_mode"
        elif key == "audienceOverride":
            suggest = "audience_override"
        elif key == "identityTranslation":
            suggest = "identity_translation"
        elif key == "remoteCallingModeClientId":
            suggest = "remote_calling_mode_client_id"
        elif key == "remoteEndpoint":
            suggest = "remote_endpoint"
        elif key == "senderClientId":
            suggest = "sender_client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiFlowOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiFlowOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiFlowOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_mode: Optional[_builtins.str] = None,
                 audience_override: Optional[_builtins.str] = None,
                 cname: Optional[_builtins.str] = None,
                 identity_translation: Optional[_builtins.str] = None,
                 remote_calling_mode_client_id: Optional[_builtins.str] = None,
                 remote_endpoint: Optional[_builtins.str] = None,
                 sender_client_id: Optional[_builtins.str] = None):
        """
        Properties specific to API Flow Type
        :param _builtins.str api_mode: Remote Calling Mode in the Azure Data Transfer API Flow, which describes how the API Flow will be invoked
        :param _builtins.str audience_override: Optional field to override the audience of the remote endpoint
        :param _builtins.str cname: Unique CNAME to represent the Azure Data Transfer API Flow instance
        :param _builtins.str identity_translation: Flag for if Azure Data Transfer API Flow should extract the user token
        :param _builtins.str remote_calling_mode_client_id: Remote stub app registration Client ID
        :param _builtins.str remote_endpoint: Remote host to which communication needs to be made
        :param _builtins.str sender_client_id: Sender's app user assigned Manage Identity client ID
        """
        if api_mode is not None:
            pulumi.set(__self__, "api_mode", api_mode)
        if audience_override is not None:
            pulumi.set(__self__, "audience_override", audience_override)
        if cname is not None:
            pulumi.set(__self__, "cname", cname)
        if identity_translation is not None:
            pulumi.set(__self__, "identity_translation", identity_translation)
        if remote_calling_mode_client_id is not None:
            pulumi.set(__self__, "remote_calling_mode_client_id", remote_calling_mode_client_id)
        if remote_endpoint is not None:
            pulumi.set(__self__, "remote_endpoint", remote_endpoint)
        if sender_client_id is not None:
            pulumi.set(__self__, "sender_client_id", sender_client_id)

    @_builtins.property
    @pulumi.getter(name="apiMode")
    def api_mode(self) -> Optional[_builtins.str]:
        """
        Remote Calling Mode in the Azure Data Transfer API Flow, which describes how the API Flow will be invoked
        """
        return pulumi.get(self, "api_mode")

    @_builtins.property
    @pulumi.getter(name="audienceOverride")
    def audience_override(self) -> Optional[_builtins.str]:
        """
        Optional field to override the audience of the remote endpoint
        """
        return pulumi.get(self, "audience_override")

    @_builtins.property
    @pulumi.getter
    def cname(self) -> Optional[_builtins.str]:
        """
        Unique CNAME to represent the Azure Data Transfer API Flow instance
        """
        return pulumi.get(self, "cname")

    @_builtins.property
    @pulumi.getter(name="identityTranslation")
    def identity_translation(self) -> Optional[_builtins.str]:
        """
        Flag for if Azure Data Transfer API Flow should extract the user token
        """
        return pulumi.get(self, "identity_translation")

    @_builtins.property
    @pulumi.getter(name="remoteCallingModeClientId")
    def remote_calling_mode_client_id(self) -> Optional[_builtins.str]:
        """
        Remote stub app registration Client ID
        """
        return pulumi.get(self, "remote_calling_mode_client_id")

    @_builtins.property
    @pulumi.getter(name="remoteEndpoint")
    def remote_endpoint(self) -> Optional[_builtins.str]:
        """
        Remote host to which communication needs to be made
        """
        return pulumi.get(self, "remote_endpoint")

    @_builtins.property
    @pulumi.getter(name="senderClientId")
    def sender_client_id(self) -> Optional[_builtins.str]:
        """
        Sender's app user assigned Manage Identity client ID
        """
        return pulumi.get(self, "sender_client_id")


@pulumi.output_type
class ConnectionPropertiesResponse(dict):
    """
    Properties of connection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateSubmitted":
            suggest = "date_submitted"
        elif key == "linkStatus":
            suggest = "link_status"
        elif key == "linkedConnectionId":
            suggest = "linked_connection_id"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "statusReason":
            suggest = "status_reason"
        elif key == "flowTypes":
            suggest = "flow_types"
        elif key == "primaryContact":
            suggest = "primary_contact"
        elif key == "remoteSubscriptionId":
            suggest = "remote_subscription_id"
        elif key == "requirementId":
            suggest = "requirement_id"
        elif key == "schemaUris":
            suggest = "schema_uris"
        elif key == "secondaryContacts":
            suggest = "secondary_contacts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approver: _builtins.str,
                 date_submitted: _builtins.str,
                 link_status: _builtins.str,
                 linked_connection_id: _builtins.str,
                 pipeline: _builtins.str,
                 provisioning_state: _builtins.str,
                 status: _builtins.str,
                 status_reason: _builtins.str,
                 direction: Optional[_builtins.str] = None,
                 flow_types: Optional[Sequence[_builtins.str]] = None,
                 justification: Optional[_builtins.str] = None,
                 pin: Optional[_builtins.str] = None,
                 policies: Optional[Sequence[_builtins.str]] = None,
                 primary_contact: Optional[_builtins.str] = None,
                 remote_subscription_id: Optional[_builtins.str] = None,
                 requirement_id: Optional[_builtins.str] = None,
                 schema_uris: Optional[Sequence[_builtins.str]] = None,
                 schemas: Optional[Sequence['outputs.SchemaResponse']] = None,
                 secondary_contacts: Optional[Sequence[_builtins.str]] = None):
        """
        Properties of connection
        :param _builtins.str approver: Approver of this connection request
        :param _builtins.str date_submitted: The timestamp that this connection request was submitted at
        :param _builtins.str link_status: Link status of the current connection
        :param _builtins.str linked_connection_id: Resource ID of the linked connection
        :param _builtins.str pipeline: Pipeline to use to transfer data
        :param _builtins.str provisioning_state: Provisioning state of the connection
        :param _builtins.str status: Status of the connection
        :param _builtins.str status_reason: Reason for status
        :param _builtins.str direction: Direction of data movement
        :param Sequence[_builtins.str] flow_types: The flow types being requested for this connection
        :param _builtins.str justification: Justification for the connection request
        :param _builtins.str pin: PIN to link requests together
        :param Sequence[_builtins.str] policies: The policies for this connection
        :param _builtins.str primary_contact: The primary contact for this connection request
        :param _builtins.str remote_subscription_id: Subscription ID to link cloud subscriptions together
        :param _builtins.str requirement_id: Requirement ID of the connection
        :param Sequence[_builtins.str] schema_uris: The schema URIs for this connection
        :param Sequence['SchemaResponse'] schemas: The schemas for this connection
        :param Sequence[_builtins.str] secondary_contacts: The secondary contacts for this connection request
        """
        pulumi.set(__self__, "approver", approver)
        pulumi.set(__self__, "date_submitted", date_submitted)
        pulumi.set(__self__, "link_status", link_status)
        pulumi.set(__self__, "linked_connection_id", linked_connection_id)
        pulumi.set(__self__, "pipeline", pipeline)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_reason", status_reason)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if flow_types is not None:
            pulumi.set(__self__, "flow_types", flow_types)
        if justification is not None:
            pulumi.set(__self__, "justification", justification)
        if pin is not None:
            pulumi.set(__self__, "pin", pin)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if primary_contact is not None:
            pulumi.set(__self__, "primary_contact", primary_contact)
        if remote_subscription_id is not None:
            pulumi.set(__self__, "remote_subscription_id", remote_subscription_id)
        if requirement_id is not None:
            pulumi.set(__self__, "requirement_id", requirement_id)
        if schema_uris is not None:
            pulumi.set(__self__, "schema_uris", schema_uris)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)
        if secondary_contacts is not None:
            pulumi.set(__self__, "secondary_contacts", secondary_contacts)

    @_builtins.property
    @pulumi.getter
    def approver(self) -> _builtins.str:
        """
        Approver of this connection request
        """
        return pulumi.get(self, "approver")

    @_builtins.property
    @pulumi.getter(name="dateSubmitted")
    def date_submitted(self) -> _builtins.str:
        """
        The timestamp that this connection request was submitted at
        """
        return pulumi.get(self, "date_submitted")

    @_builtins.property
    @pulumi.getter(name="linkStatus")
    def link_status(self) -> _builtins.str:
        """
        Link status of the current connection
        """
        return pulumi.get(self, "link_status")

    @_builtins.property
    @pulumi.getter(name="linkedConnectionId")
    def linked_connection_id(self) -> _builtins.str:
        """
        Resource ID of the linked connection
        """
        return pulumi.get(self, "linked_connection_id")

    @_builtins.property
    @pulumi.getter
    def pipeline(self) -> _builtins.str:
        """
        Pipeline to use to transfer data
        """
        return pulumi.get(self, "pipeline")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the connection
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Status of the connection
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusReason")
    def status_reason(self) -> _builtins.str:
        """
        Reason for status
        """
        return pulumi.get(self, "status_reason")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        Direction of data movement
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="flowTypes")
    def flow_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The flow types being requested for this connection
        """
        return pulumi.get(self, "flow_types")

    @_builtins.property
    @pulumi.getter
    def justification(self) -> Optional[_builtins.str]:
        """
        Justification for the connection request
        """
        return pulumi.get(self, "justification")

    @_builtins.property
    @pulumi.getter
    def pin(self) -> Optional[_builtins.str]:
        """
        PIN to link requests together
        """
        return pulumi.get(self, "pin")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[_builtins.str]]:
        """
        The policies for this connection
        """
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter(name="primaryContact")
    def primary_contact(self) -> Optional[_builtins.str]:
        """
        The primary contact for this connection request
        """
        return pulumi.get(self, "primary_contact")

    @_builtins.property
    @pulumi.getter(name="remoteSubscriptionId")
    def remote_subscription_id(self) -> Optional[_builtins.str]:
        """
        Subscription ID to link cloud subscriptions together
        """
        return pulumi.get(self, "remote_subscription_id")

    @_builtins.property
    @pulumi.getter(name="requirementId")
    def requirement_id(self) -> Optional[_builtins.str]:
        """
        Requirement ID of the connection
        """
        return pulumi.get(self, "requirement_id")

    @_builtins.property
    @pulumi.getter(name="schemaUris")
    def schema_uris(self) -> Optional[Sequence[_builtins.str]]:
        """
        The schema URIs for this connection
        """
        return pulumi.get(self, "schema_uris")

    @_builtins.property
    @pulumi.getter
    def schemas(self) -> Optional[Sequence['outputs.SchemaResponse']]:
        """
        The schemas for this connection
        """
        return pulumi.get(self, "schemas")

    @_builtins.property
    @pulumi.getter(name="secondaryContacts")
    def secondary_contacts(self) -> Optional[Sequence[_builtins.str]]:
        """
        The secondary contacts for this connection request
        """
        return pulumi.get(self, "secondary_contacts")


@pulumi.output_type
class FlowPropertiesResponse(dict):
    """
    Properties of flow
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flowId":
            suggest = "flow_id"
        elif key == "forceDisabledStatus":
            suggest = "force_disabled_status"
        elif key == "linkStatus":
            suggest = "link_status"
        elif key == "linkedFlowId":
            suggest = "linked_flow_id"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "apiFlowOptions":
            suggest = "api_flow_options"
        elif key == "consumerGroup":
            suggest = "consumer_group"
        elif key == "customerManagedKeyVaultUri":
            suggest = "customer_managed_key_vault_uri"
        elif key == "dataType":
            suggest = "data_type"
        elif key == "destinationEndpointPorts":
            suggest = "destination_endpoint_ports"
        elif key == "destinationEndpoints":
            suggest = "destination_endpoints"
        elif key == "eventHubId":
            suggest = "event_hub_id"
        elif key == "flowType":
            suggest = "flow_type"
        elif key == "keyVaultUri":
            suggest = "key_vault_uri"
        elif key == "messagingOptions":
            suggest = "messaging_options"
        elif key == "serviceBusQueueId":
            suggest = "service_bus_queue_id"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "storageAccountId":
            suggest = "storage_account_id"
        elif key == "storageAccountName":
            suggest = "storage_account_name"
        elif key == "storageContainerName":
            suggest = "storage_container_name"
        elif key == "storageTableName":
            suggest = "storage_table_name"
        elif key == "streamId":
            suggest = "stream_id"
        elif key == "streamLatency":
            suggest = "stream_latency"
        elif key == "streamProtocol":
            suggest = "stream_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flow_id: _builtins.str,
                 force_disabled_status: Sequence[_builtins.str],
                 link_status: _builtins.str,
                 linked_flow_id: _builtins.str,
                 provisioning_state: _builtins.str,
                 api_flow_options: Optional['outputs.ApiFlowOptionsResponse'] = None,
                 connection: Optional['outputs.SelectedResourceResponse'] = None,
                 consumer_group: Optional[_builtins.str] = None,
                 customer_managed_key_vault_uri: Optional[_builtins.str] = None,
                 data_type: Optional[_builtins.str] = None,
                 destination_endpoint_ports: Optional[Sequence[_builtins.float]] = None,
                 destination_endpoints: Optional[Sequence[_builtins.str]] = None,
                 event_hub_id: Optional[_builtins.str] = None,
                 flow_type: Optional[_builtins.str] = None,
                 key_vault_uri: Optional[_builtins.str] = None,
                 messaging_options: Optional['outputs.MessagingOptionsResponse'] = None,
                 passphrase: Optional[_builtins.str] = None,
                 policies: Optional[Sequence[_builtins.str]] = None,
                 schema: Optional['outputs.SchemaResponse'] = None,
                 service_bus_queue_id: Optional[_builtins.str] = None,
                 source_addresses: Optional['outputs.StreamSourceAddressesResponse'] = None,
                 status: Optional[_builtins.str] = None,
                 storage_account_id: Optional[_builtins.str] = None,
                 storage_account_name: Optional[_builtins.str] = None,
                 storage_container_name: Optional[_builtins.str] = None,
                 storage_table_name: Optional[_builtins.str] = None,
                 stream_id: Optional[_builtins.str] = None,
                 stream_latency: Optional[_builtins.float] = None,
                 stream_protocol: Optional[_builtins.str] = None):
        """
        Properties of flow
        :param _builtins.str flow_id: Dataflow GUID associated with this flow
        :param Sequence[_builtins.str] force_disabled_status: Force disablement status of the current flow
        :param _builtins.str link_status: Link status of the current flow
        :param _builtins.str linked_flow_id: Resource ID of the linked flow
        :param _builtins.str provisioning_state: Provisioning state of the flow
        :param 'ApiFlowOptionsResponse' api_flow_options: The API Flow configuration options for Azure Data Transfer API Flow type.
        :param 'SelectedResourceResponse' connection: The connection associated with this flow
        :param _builtins.str consumer_group: Event Hub Consumer Group
        :param _builtins.str customer_managed_key_vault_uri: The URI to the customer managed key for this flow
        :param _builtins.str data_type: Type of data to transfer via the flow.
        :param Sequence[_builtins.float] destination_endpoint_ports: The destination endpoint ports of the stream
        :param Sequence[_builtins.str] destination_endpoints: The destination endpoints of the stream
        :param _builtins.str event_hub_id: Event Hub ID
        :param _builtins.str flow_type: The flow type for this flow
        :param _builtins.str key_vault_uri: URI to a Key Vault Secret containing a SAS token.
        :param 'MessagingOptionsResponse' messaging_options: The messaging options for this flow
        :param _builtins.str passphrase: The passphrase used for SRT streams
        :param Sequence[_builtins.str] policies: The policies for this flow
        :param 'SchemaResponse' schema: The selected schema for this flow
        :param _builtins.str service_bus_queue_id: Service Bus Queue ID
        :param 'StreamSourceAddressesResponse' source_addresses: The source IP address and CIDR ranges of the stream
        :param _builtins.str status: Status of the current flow
        :param _builtins.str storage_account_id: Storage Account ID
        :param _builtins.str storage_account_name: Storage Account
        :param _builtins.str storage_container_name: Storage Container Name
        :param _builtins.str storage_table_name: Storage Table Name
        :param _builtins.str stream_id: The flow stream identifier
        :param _builtins.float stream_latency: The latency of the stream in milliseconds
        :param _builtins.str stream_protocol: The protocol of the stream
        """
        pulumi.set(__self__, "flow_id", flow_id)
        pulumi.set(__self__, "force_disabled_status", force_disabled_status)
        pulumi.set(__self__, "link_status", link_status)
        pulumi.set(__self__, "linked_flow_id", linked_flow_id)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if api_flow_options is not None:
            pulumi.set(__self__, "api_flow_options", api_flow_options)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if customer_managed_key_vault_uri is not None:
            pulumi.set(__self__, "customer_managed_key_vault_uri", customer_managed_key_vault_uri)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if destination_endpoint_ports is not None:
            pulumi.set(__self__, "destination_endpoint_ports", destination_endpoint_ports)
        if destination_endpoints is not None:
            pulumi.set(__self__, "destination_endpoints", destination_endpoints)
        if event_hub_id is not None:
            pulumi.set(__self__, "event_hub_id", event_hub_id)
        if flow_type is not None:
            pulumi.set(__self__, "flow_type", flow_type)
        if key_vault_uri is not None:
            pulumi.set(__self__, "key_vault_uri", key_vault_uri)
        if messaging_options is not None:
            pulumi.set(__self__, "messaging_options", messaging_options)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if service_bus_queue_id is not None:
            pulumi.set(__self__, "service_bus_queue_id", service_bus_queue_id)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if storage_account_id is not None:
            pulumi.set(__self__, "storage_account_id", storage_account_id)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)
        if storage_container_name is not None:
            pulumi.set(__self__, "storage_container_name", storage_container_name)
        if storage_table_name is not None:
            pulumi.set(__self__, "storage_table_name", storage_table_name)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if stream_latency is not None:
            pulumi.set(__self__, "stream_latency", stream_latency)
        if stream_protocol is not None:
            pulumi.set(__self__, "stream_protocol", stream_protocol)

    @_builtins.property
    @pulumi.getter(name="flowId")
    def flow_id(self) -> _builtins.str:
        """
        Dataflow GUID associated with this flow
        """
        return pulumi.get(self, "flow_id")

    @_builtins.property
    @pulumi.getter(name="forceDisabledStatus")
    def force_disabled_status(self) -> Sequence[_builtins.str]:
        """
        Force disablement status of the current flow
        """
        return pulumi.get(self, "force_disabled_status")

    @_builtins.property
    @pulumi.getter(name="linkStatus")
    def link_status(self) -> _builtins.str:
        """
        Link status of the current flow
        """
        return pulumi.get(self, "link_status")

    @_builtins.property
    @pulumi.getter(name="linkedFlowId")
    def linked_flow_id(self) -> _builtins.str:
        """
        Resource ID of the linked flow
        """
        return pulumi.get(self, "linked_flow_id")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the flow
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="apiFlowOptions")
    def api_flow_options(self) -> Optional['outputs.ApiFlowOptionsResponse']:
        """
        The API Flow configuration options for Azure Data Transfer API Flow type.
        """
        return pulumi.get(self, "api_flow_options")

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional['outputs.SelectedResourceResponse']:
        """
        The connection associated with this flow
        """
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[_builtins.str]:
        """
        Event Hub Consumer Group
        """
        return pulumi.get(self, "consumer_group")

    @_builtins.property
    @pulumi.getter(name="customerManagedKeyVaultUri")
    def customer_managed_key_vault_uri(self) -> Optional[_builtins.str]:
        """
        The URI to the customer managed key for this flow
        """
        return pulumi.get(self, "customer_managed_key_vault_uri")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        Type of data to transfer via the flow.
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter(name="destinationEndpointPorts")
    def destination_endpoint_ports(self) -> Optional[Sequence[_builtins.float]]:
        """
        The destination endpoint ports of the stream
        """
        return pulumi.get(self, "destination_endpoint_ports")

    @_builtins.property
    @pulumi.getter(name="destinationEndpoints")
    def destination_endpoints(self) -> Optional[Sequence[_builtins.str]]:
        """
        The destination endpoints of the stream
        """
        return pulumi.get(self, "destination_endpoints")

    @_builtins.property
    @pulumi.getter(name="eventHubId")
    def event_hub_id(self) -> Optional[_builtins.str]:
        """
        Event Hub ID
        """
        return pulumi.get(self, "event_hub_id")

    @_builtins.property
    @pulumi.getter(name="flowType")
    def flow_type(self) -> Optional[_builtins.str]:
        """
        The flow type for this flow
        """
        return pulumi.get(self, "flow_type")

    @_builtins.property
    @pulumi.getter(name="keyVaultUri")
    def key_vault_uri(self) -> Optional[_builtins.str]:
        """
        URI to a Key Vault Secret containing a SAS token.
        """
        return pulumi.get(self, "key_vault_uri")

    @_builtins.property
    @pulumi.getter(name="messagingOptions")
    def messaging_options(self) -> Optional['outputs.MessagingOptionsResponse']:
        """
        The messaging options for this flow
        """
        return pulumi.get(self, "messaging_options")

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[_builtins.str]:
        """
        The passphrase used for SRT streams
        """
        return pulumi.get(self, "passphrase")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[_builtins.str]]:
        """
        The policies for this flow
        """
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional['outputs.SchemaResponse']:
        """
        The selected schema for this flow
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter(name="serviceBusQueueId")
    def service_bus_queue_id(self) -> Optional[_builtins.str]:
        """
        Service Bus Queue ID
        """
        return pulumi.get(self, "service_bus_queue_id")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional['outputs.StreamSourceAddressesResponse']:
        """
        The source IP address and CIDR ranges of the stream
        """
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the current flow
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> Optional[_builtins.str]:
        """
        Storage Account ID
        """
        return pulumi.get(self, "storage_account_id")

    @_builtins.property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[_builtins.str]:
        """
        Storage Account
        """
        return pulumi.get(self, "storage_account_name")

    @_builtins.property
    @pulumi.getter(name="storageContainerName")
    def storage_container_name(self) -> Optional[_builtins.str]:
        """
        Storage Container Name
        """
        return pulumi.get(self, "storage_container_name")

    @_builtins.property
    @pulumi.getter(name="storageTableName")
    def storage_table_name(self) -> Optional[_builtins.str]:
        """
        Storage Table Name
        """
        return pulumi.get(self, "storage_table_name")

    @_builtins.property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[_builtins.str]:
        """
        The flow stream identifier
        """
        return pulumi.get(self, "stream_id")

    @_builtins.property
    @pulumi.getter(name="streamLatency")
    def stream_latency(self) -> Optional[_builtins.float]:
        """
        The latency of the stream in milliseconds
        """
        return pulumi.get(self, "stream_latency")

    @_builtins.property
    @pulumi.getter(name="streamProtocol")
    def stream_protocol(self) -> Optional[_builtins.str]:
        """
        The protocol of the stream
        """
        return pulumi.get(self, "stream_protocol")


@pulumi.output_type
class FlowResponse(dict):
    """
    The flow resource definition.
    """
    def __init__(__self__, *,
                 id: _builtins.str,
                 location: _builtins.str,
                 name: _builtins.str,
                 system_data: 'outputs.SystemDataResponse',
                 type: _builtins.str,
                 identity: Optional['outputs.ManagedServiceIdentityResponse'] = None,
                 plan: Optional['outputs.PlanResponse'] = None,
                 properties: Optional['outputs.FlowPropertiesResponse'] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        The flow resource definition.
        :param _builtins.str id: Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        :param _builtins.str location: The geo-location where the resource lives
        :param _builtins.str name: The name of the resource
        :param 'SystemDataResponse' system_data: Azure Resource Manager metadata containing createdBy and modifiedBy information.
        :param _builtins.str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param 'ManagedServiceIdentityResponse' identity: The managed service identities assigned to this resource.
        :param 'PlanResponse' plan: Details of the resource plan.
        :param 'FlowPropertiesResponse' properties: Properties of flow
        :param Mapping[str, _builtins.str] tags: Resource tags.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "system_data", system_data)
        pulumi.set(__self__, "type", type)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if plan is not None:
            pulumi.set(__self__, "plan", plan)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        The geo-location where the resource lives
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Azure Resource Manager metadata containing createdBy and modifiedBy information.
        """
        return pulumi.get(self, "system_data")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional['outputs.ManagedServiceIdentityResponse']:
        """
        The managed service identities assigned to this resource.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter
    def plan(self) -> Optional['outputs.PlanResponse']:
        """
        Details of the resource plan.
        """
        return pulumi.get(self, "plan")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional['outputs.FlowPropertiesResponse']:
        """
        Properties of flow
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class InternalMetadataPropertiesResponse(dict):
    """
    Internal metadata of the connection inside pipeline.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusSetBy":
            suggest = "status_set_by"
        elif key == "operationStatus":
            suggest = "operation_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternalMetadataPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternalMetadataPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternalMetadataPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_set_by: _builtins.str,
                 operation_status: Optional['outputs.OperationStatusPropertiesResponse'] = None):
        """
        Internal metadata of the connection inside pipeline.
        :param _builtins.str status_set_by: User that last set the approved status for this connection
        :param 'OperationStatusPropertiesResponse' operation_status: Operation status associated with the last patch request
        """
        pulumi.set(__self__, "status_set_by", status_set_by)
        if operation_status is not None:
            pulumi.set(__self__, "operation_status", operation_status)

    @_builtins.property
    @pulumi.getter(name="statusSetBy")
    def status_set_by(self) -> _builtins.str:
        """
        User that last set the approved status for this connection
        """
        return pulumi.get(self, "status_set_by")

    @_builtins.property
    @pulumi.getter(name="operationStatus")
    def operation_status(self) -> Optional['outputs.OperationStatusPropertiesResponse']:
        """
        Operation status associated with the last patch request
        """
        return pulumi.get(self, "operation_status")


@pulumi.output_type
class ListFlowsByPipelineConnectionResponse(dict):
    """
    A connection resource id in addition to all child flow resources under this connection.
    """
    def __init__(__self__, *,
                 flows: Optional[Sequence['outputs.FlowResponse']] = None,
                 id: Optional[_builtins.str] = None):
        """
        A connection resource id in addition to all child flow resources under this connection.
        :param Sequence['FlowResponse'] flows: List of flows associated with the connection.
        :param _builtins.str id: ID of the connection.
        """
        if flows is not None:
            pulumi.set(__self__, "flows", flows)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def flows(self) -> Optional[Sequence['outputs.FlowResponse']]:
        """
        List of flows associated with the connection.
        """
        return pulumi.get(self, "flows")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the connection.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity (system assigned and/or user assigned identities)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: _builtins.str,
                 tenant_id: _builtins.str,
                 type: _builtins.str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param _builtins.str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param _builtins.str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param _builtins.str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class MessagingOptionsResponse(dict):
    """
    The option associated with messaging flows.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "billingTier":
            suggest = "billing_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MessagingOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MessagingOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MessagingOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 billing_tier: Optional[_builtins.str] = None):
        """
        The option associated with messaging flows.
        :param _builtins.str billing_tier: Billing tier for this messaging flow
        """
        if billing_tier is not None:
            pulumi.set(__self__, "billing_tier", billing_tier)

    @_builtins.property
    @pulumi.getter(name="billingTier")
    def billing_tier(self) -> Optional[_builtins.str]:
        """
        Billing tier for this messaging flow
        """
        return pulumi.get(self, "billing_tier")


@pulumi.output_type
class OperationStatusPropertiesResponse(dict):
    """
    Operation status associated with the last patch request
    """
    def __init__(__self__, *,
                 id: _builtins.str,
                 message: _builtins.str,
                 status: _builtins.str):
        """
        Operation status associated with the last patch request
        :param _builtins.str id: Operation status ID of the last patch request for this connection.
        :param _builtins.str message: Message for the operation for the last patch request for this connection.
        :param _builtins.str status: Operation status for the last patch request for this connection.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Operation status ID of the last patch request for this connection.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        Message for the operation for the last patch request for this connection.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Operation status for the last patch request for this connection.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class PendingConnectionResponse(dict):
    """
    Pending connection object
    """
    def __init__(__self__, *,
                 approver: _builtins.str,
                 date_submitted: _builtins.str,
                 id: _builtins.str,
                 link_status: _builtins.str,
                 linked_connection_id: _builtins.str,
                 location: _builtins.str,
                 name: _builtins.str,
                 pipeline: _builtins.str,
                 provisioning_state: _builtins.str,
                 status: _builtins.str,
                 status_reason: _builtins.str,
                 subscription_id: _builtins.str,
                 system_data: 'outputs.SystemDataResponse',
                 type: _builtins.str,
                 direction: Optional[_builtins.str] = None,
                 flow_types: Optional[Sequence[_builtins.str]] = None,
                 justification: Optional[_builtins.str] = None,
                 pin: Optional[_builtins.str] = None,
                 policies: Optional[Sequence[_builtins.str]] = None,
                 primary_contact: Optional[_builtins.str] = None,
                 remote_subscription_id: Optional[_builtins.str] = None,
                 requirement_id: Optional[_builtins.str] = None,
                 schema_uris: Optional[Sequence[_builtins.str]] = None,
                 schemas: Optional[Sequence['outputs.SchemaResponse']] = None,
                 secondary_contacts: Optional[Sequence[_builtins.str]] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        Pending connection object
        :param _builtins.str approver: Approver of this connection request
        :param _builtins.str date_submitted: The timestamp that this connection request was submitted at
        :param _builtins.str id: Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        :param _builtins.str link_status: Link status of the current connection
        :param _builtins.str linked_connection_id: Resource ID of the linked connection
        :param _builtins.str location: The geo-location where the resource lives
        :param _builtins.str name: The name of the resource
        :param _builtins.str pipeline: Pipeline to use to transfer data
        :param _builtins.str provisioning_state: Provisioning state of the connection
        :param _builtins.str status: Status of the connection
        :param _builtins.str status_reason: Reason for status
        :param _builtins.str subscription_id: Subscription ID of the pending connection.
        :param 'SystemDataResponse' system_data: Azure Resource Manager metadata containing createdBy and modifiedBy information.
        :param _builtins.str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param _builtins.str direction: Direction of data movement
        :param Sequence[_builtins.str] flow_types: The flow types being requested for this connection
        :param _builtins.str justification: Justification for the connection request
        :param _builtins.str pin: PIN to link requests together
        :param Sequence[_builtins.str] policies: The policies for this connection
        :param _builtins.str primary_contact: The primary contact for this connection request
        :param _builtins.str remote_subscription_id: Subscription ID to link cloud subscriptions together
        :param _builtins.str requirement_id: Requirement ID of the connection
        :param Sequence[_builtins.str] schema_uris: The schema URIs for this connection
        :param Sequence['SchemaResponse'] schemas: The schemas for this connection
        :param Sequence[_builtins.str] secondary_contacts: The secondary contacts for this connection request
        :param Mapping[str, _builtins.str] tags: Resource tags.
        """
        pulumi.set(__self__, "approver", approver)
        pulumi.set(__self__, "date_submitted", date_submitted)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "link_status", link_status)
        pulumi.set(__self__, "linked_connection_id", linked_connection_id)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pipeline", pipeline)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_reason", status_reason)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "system_data", system_data)
        pulumi.set(__self__, "type", type)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if flow_types is not None:
            pulumi.set(__self__, "flow_types", flow_types)
        if justification is not None:
            pulumi.set(__self__, "justification", justification)
        if pin is not None:
            pulumi.set(__self__, "pin", pin)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if primary_contact is not None:
            pulumi.set(__self__, "primary_contact", primary_contact)
        if remote_subscription_id is not None:
            pulumi.set(__self__, "remote_subscription_id", remote_subscription_id)
        if requirement_id is not None:
            pulumi.set(__self__, "requirement_id", requirement_id)
        if schema_uris is not None:
            pulumi.set(__self__, "schema_uris", schema_uris)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)
        if secondary_contacts is not None:
            pulumi.set(__self__, "secondary_contacts", secondary_contacts)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def approver(self) -> _builtins.str:
        """
        Approver of this connection request
        """
        return pulumi.get(self, "approver")

    @_builtins.property
    @pulumi.getter(name="dateSubmitted")
    def date_submitted(self) -> _builtins.str:
        """
        The timestamp that this connection request was submitted at
        """
        return pulumi.get(self, "date_submitted")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="linkStatus")
    def link_status(self) -> _builtins.str:
        """
        Link status of the current connection
        """
        return pulumi.get(self, "link_status")

    @_builtins.property
    @pulumi.getter(name="linkedConnectionId")
    def linked_connection_id(self) -> _builtins.str:
        """
        Resource ID of the linked connection
        """
        return pulumi.get(self, "linked_connection_id")

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        The geo-location where the resource lives
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def pipeline(self) -> _builtins.str:
        """
        Pipeline to use to transfer data
        """
        return pulumi.get(self, "pipeline")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the connection
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Status of the connection
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusReason")
    def status_reason(self) -> _builtins.str:
        """
        Reason for status
        """
        return pulumi.get(self, "status_reason")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        """
        Subscription ID of the pending connection.
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Azure Resource Manager metadata containing createdBy and modifiedBy information.
        """
        return pulumi.get(self, "system_data")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        Direction of data movement
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="flowTypes")
    def flow_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The flow types being requested for this connection
        """
        return pulumi.get(self, "flow_types")

    @_builtins.property
    @pulumi.getter
    def justification(self) -> Optional[_builtins.str]:
        """
        Justification for the connection request
        """
        return pulumi.get(self, "justification")

    @_builtins.property
    @pulumi.getter
    def pin(self) -> Optional[_builtins.str]:
        """
        PIN to link requests together
        """
        return pulumi.get(self, "pin")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[_builtins.str]]:
        """
        The policies for this connection
        """
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter(name="primaryContact")
    def primary_contact(self) -> Optional[_builtins.str]:
        """
        The primary contact for this connection request
        """
        return pulumi.get(self, "primary_contact")

    @_builtins.property
    @pulumi.getter(name="remoteSubscriptionId")
    def remote_subscription_id(self) -> Optional[_builtins.str]:
        """
        Subscription ID to link cloud subscriptions together
        """
        return pulumi.get(self, "remote_subscription_id")

    @_builtins.property
    @pulumi.getter(name="requirementId")
    def requirement_id(self) -> Optional[_builtins.str]:
        """
        Requirement ID of the connection
        """
        return pulumi.get(self, "requirement_id")

    @_builtins.property
    @pulumi.getter(name="schemaUris")
    def schema_uris(self) -> Optional[Sequence[_builtins.str]]:
        """
        The schema URIs for this connection
        """
        return pulumi.get(self, "schema_uris")

    @_builtins.property
    @pulumi.getter
    def schemas(self) -> Optional[Sequence['outputs.SchemaResponse']]:
        """
        The schemas for this connection
        """
        return pulumi.get(self, "schemas")

    @_builtins.property
    @pulumi.getter(name="secondaryContacts")
    def secondary_contacts(self) -> Optional[Sequence[_builtins.str]]:
        """
        The secondary contacts for this connection request
        """
        return pulumi.get(self, "secondary_contacts")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class PendingFlowResponse(dict):
    """
    Pending flow object
    """
    def __init__(__self__, *,
                 connection_id: _builtins.str,
                 flow_id: _builtins.str,
                 id: _builtins.str,
                 link_status: _builtins.str,
                 linked_flow_id: _builtins.str,
                 location: _builtins.str,
                 name: _builtins.str,
                 provisioning_state: _builtins.str,
                 subscription_id: _builtins.str,
                 system_data: 'outputs.SystemDataResponse',
                 type: _builtins.str,
                 connection: Optional['outputs.SelectedResourceResponse'] = None,
                 customer_managed_key_vault_uri: Optional[_builtins.str] = None,
                 data_type: Optional[_builtins.str] = None,
                 destination_endpoint_ports: Optional[Sequence[_builtins.float]] = None,
                 destination_endpoints: Optional[Sequence[_builtins.str]] = None,
                 flow_type: Optional[_builtins.str] = None,
                 key_vault_uri: Optional[_builtins.str] = None,
                 messaging_options: Optional['outputs.MessagingOptionsResponse'] = None,
                 passphrase: Optional[_builtins.str] = None,
                 policies: Optional[Sequence[_builtins.str]] = None,
                 schema: Optional['outputs.SchemaResponse'] = None,
                 service_bus_queue_id: Optional[_builtins.str] = None,
                 source_addresses: Optional['outputs.StreamSourceAddressesResponse'] = None,
                 status: Optional[_builtins.str] = None,
                 storage_account_id: Optional[_builtins.str] = None,
                 storage_account_name: Optional[_builtins.str] = None,
                 storage_container_name: Optional[_builtins.str] = None,
                 stream_id: Optional[_builtins.str] = None,
                 stream_latency: Optional[_builtins.float] = None,
                 stream_protocol: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        Pending flow object
        :param _builtins.str connection_id: Connection ID of the pending flow.
        :param _builtins.str flow_id: Dataflow GUID associated with this flow
        :param _builtins.str id: Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        :param _builtins.str link_status: Link status of the current flow
        :param _builtins.str linked_flow_id: Resource ID of the linked flow
        :param _builtins.str location: The geo-location where the resource lives
        :param _builtins.str name: The name of the resource
        :param _builtins.str provisioning_state: Provisioning state of the flow
        :param _builtins.str subscription_id: Subscription ID of the pending flow.
        :param 'SystemDataResponse' system_data: Azure Resource Manager metadata containing createdBy and modifiedBy information.
        :param _builtins.str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param 'SelectedResourceResponse' connection: The connection associated with this flow
        :param _builtins.str customer_managed_key_vault_uri: The URI to the customer managed key for this flow
        :param _builtins.str data_type: Transfer Storage Blobs or Tables
        :param Sequence[_builtins.float] destination_endpoint_ports: The destination endpoint ports of the stream
        :param Sequence[_builtins.str] destination_endpoints: The destination endpoints of the stream
        :param _builtins.str flow_type: The flow type for this flow
        :param _builtins.str key_vault_uri: AME, PME, or TORUS only! AKV Chain Containing SAS Token
        :param 'MessagingOptionsResponse' messaging_options: The messaging options for this flow
        :param _builtins.str passphrase: The passphrase used for SRT streams
        :param Sequence[_builtins.str] policies: The policies for this flow
        :param 'SchemaResponse' schema: The selected schema for this flow
        :param _builtins.str service_bus_queue_id: Service Bus Queue ID
        :param 'StreamSourceAddressesResponse' source_addresses: The source IP address and CIDR ranges of the stream
        :param _builtins.str status: Status of the current flow
        :param _builtins.str storage_account_id: Storage Account ID
        :param _builtins.str storage_account_name: Storage Account
        :param _builtins.str storage_container_name: Storage Container Name
        :param _builtins.str stream_id: The flow stream identifier
        :param _builtins.float stream_latency: The latency of the stream in milliseconds
        :param _builtins.str stream_protocol: The protocol of the stream
        :param Mapping[str, _builtins.str] tags: Resource tags.
        """
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "flow_id", flow_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "link_status", link_status)
        pulumi.set(__self__, "linked_flow_id", linked_flow_id)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "system_data", system_data)
        pulumi.set(__self__, "type", type)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if customer_managed_key_vault_uri is not None:
            pulumi.set(__self__, "customer_managed_key_vault_uri", customer_managed_key_vault_uri)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if destination_endpoint_ports is not None:
            pulumi.set(__self__, "destination_endpoint_ports", destination_endpoint_ports)
        if destination_endpoints is not None:
            pulumi.set(__self__, "destination_endpoints", destination_endpoints)
        if flow_type is not None:
            pulumi.set(__self__, "flow_type", flow_type)
        if key_vault_uri is not None:
            pulumi.set(__self__, "key_vault_uri", key_vault_uri)
        if messaging_options is not None:
            pulumi.set(__self__, "messaging_options", messaging_options)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if service_bus_queue_id is not None:
            pulumi.set(__self__, "service_bus_queue_id", service_bus_queue_id)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if storage_account_id is not None:
            pulumi.set(__self__, "storage_account_id", storage_account_id)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)
        if storage_container_name is not None:
            pulumi.set(__self__, "storage_container_name", storage_container_name)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if stream_latency is not None:
            pulumi.set(__self__, "stream_latency", stream_latency)
        if stream_protocol is not None:
            pulumi.set(__self__, "stream_protocol", stream_protocol)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> _builtins.str:
        """
        Connection ID of the pending flow.
        """
        return pulumi.get(self, "connection_id")

    @_builtins.property
    @pulumi.getter(name="flowId")
    def flow_id(self) -> _builtins.str:
        """
        Dataflow GUID associated with this flow
        """
        return pulumi.get(self, "flow_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="linkStatus")
    def link_status(self) -> _builtins.str:
        """
        Link status of the current flow
        """
        return pulumi.get(self, "link_status")

    @_builtins.property
    @pulumi.getter(name="linkedFlowId")
    def linked_flow_id(self) -> _builtins.str:
        """
        Resource ID of the linked flow
        """
        return pulumi.get(self, "linked_flow_id")

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        The geo-location where the resource lives
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the flow
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        """
        Subscription ID of the pending flow.
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Azure Resource Manager metadata containing createdBy and modifiedBy information.
        """
        return pulumi.get(self, "system_data")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional['outputs.SelectedResourceResponse']:
        """
        The connection associated with this flow
        """
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter(name="customerManagedKeyVaultUri")
    def customer_managed_key_vault_uri(self) -> Optional[_builtins.str]:
        """
        The URI to the customer managed key for this flow
        """
        return pulumi.get(self, "customer_managed_key_vault_uri")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        Transfer Storage Blobs or Tables
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter(name="destinationEndpointPorts")
    def destination_endpoint_ports(self) -> Optional[Sequence[_builtins.float]]:
        """
        The destination endpoint ports of the stream
        """
        return pulumi.get(self, "destination_endpoint_ports")

    @_builtins.property
    @pulumi.getter(name="destinationEndpoints")
    def destination_endpoints(self) -> Optional[Sequence[_builtins.str]]:
        """
        The destination endpoints of the stream
        """
        return pulumi.get(self, "destination_endpoints")

    @_builtins.property
    @pulumi.getter(name="flowType")
    def flow_type(self) -> Optional[_builtins.str]:
        """
        The flow type for this flow
        """
        return pulumi.get(self, "flow_type")

    @_builtins.property
    @pulumi.getter(name="keyVaultUri")
    def key_vault_uri(self) -> Optional[_builtins.str]:
        """
        AME, PME, or TORUS only! AKV Chain Containing SAS Token
        """
        return pulumi.get(self, "key_vault_uri")

    @_builtins.property
    @pulumi.getter(name="messagingOptions")
    def messaging_options(self) -> Optional['outputs.MessagingOptionsResponse']:
        """
        The messaging options for this flow
        """
        return pulumi.get(self, "messaging_options")

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[_builtins.str]:
        """
        The passphrase used for SRT streams
        """
        return pulumi.get(self, "passphrase")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[_builtins.str]]:
        """
        The policies for this flow
        """
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional['outputs.SchemaResponse']:
        """
        The selected schema for this flow
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter(name="serviceBusQueueId")
    def service_bus_queue_id(self) -> Optional[_builtins.str]:
        """
        Service Bus Queue ID
        """
        return pulumi.get(self, "service_bus_queue_id")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional['outputs.StreamSourceAddressesResponse']:
        """
        The source IP address and CIDR ranges of the stream
        """
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the current flow
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> Optional[_builtins.str]:
        """
        Storage Account ID
        """
        return pulumi.get(self, "storage_account_id")

    @_builtins.property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[_builtins.str]:
        """
        Storage Account
        """
        return pulumi.get(self, "storage_account_name")

    @_builtins.property
    @pulumi.getter(name="storageContainerName")
    def storage_container_name(self) -> Optional[_builtins.str]:
        """
        Storage Container Name
        """
        return pulumi.get(self, "storage_container_name")

    @_builtins.property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[_builtins.str]:
        """
        The flow stream identifier
        """
        return pulumi.get(self, "stream_id")

    @_builtins.property
    @pulumi.getter(name="streamLatency")
    def stream_latency(self) -> Optional[_builtins.float]:
        """
        The latency of the stream in milliseconds
        """
        return pulumi.get(self, "stream_latency")

    @_builtins.property
    @pulumi.getter(name="streamProtocol")
    def stream_protocol(self) -> Optional[_builtins.str]:
        """
        The protocol of the stream
        """
        return pulumi.get(self, "stream_protocol")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class PipelineConnectionResponse(dict):
    """
    Connection body inside a pipeline
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemData":
            suggest = "system_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 etag: _builtins.str,
                 id: _builtins.str,
                 location: _builtins.str,
                 name: _builtins.str,
                 system_data: 'outputs.SystemDataResponse',
                 type: _builtins.str,
                 properties: Optional['outputs.PipelineConnectionResponseProperties'] = None):
        """
        Connection body inside a pipeline
        :param _builtins.str etag: Connection etag inside pipeline
        :param _builtins.str id: Connection id inside pipeline
        :param _builtins.str location: Connection location inside pipeline
        :param _builtins.str name: Connection name inside pipeline
        :param 'SystemDataResponse' system_data: Metadata pertaining to creation and last modification of the resource.
        :param _builtins.str type: Connection type inside pipeline
        :param 'PipelineConnectionResponseProperties' properties: Connection properties inside pipeline
        """
        pulumi.set(__self__, "etag", etag)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "system_data", system_data)
        pulumi.set(__self__, "type", type)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def etag(self) -> _builtins.str:
        """
        Connection etag inside pipeline
        """
        return pulumi.get(self, "etag")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Connection id inside pipeline
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        Connection location inside pipeline
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Connection name inside pipeline
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Metadata pertaining to creation and last modification of the resource.
        """
        return pulumi.get(self, "system_data")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Connection type inside pipeline
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional['outputs.PipelineConnectionResponseProperties']:
        """
        Connection properties inside pipeline
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class PipelineConnectionResponseProperties(dict):
    """
    Connection properties inside pipeline
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalMetadata":
            suggest = "internal_metadata"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineConnectionResponseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineConnectionResponseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineConnectionResponseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 internal_metadata: Optional['outputs.InternalMetadataPropertiesResponse'] = None):
        """
        Connection properties inside pipeline
        :param 'InternalMetadataPropertiesResponse' internal_metadata: Internal metadata of the connection inside pipeline.
        """
        if internal_metadata is not None:
            pulumi.set(__self__, "internal_metadata", internal_metadata)

    @_builtins.property
    @pulumi.getter(name="internalMetadata")
    def internal_metadata(self) -> Optional['outputs.InternalMetadataPropertiesResponse']:
        """
        Internal metadata of the connection inside pipeline.
        """
        return pulumi.get(self, "internal_metadata")


@pulumi.output_type
class PipelinePropertiesResponse(dict):
    """
    Properties of pipeline
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "remoteCloud":
            suggest = "remote_cloud"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "flowTypes":
            suggest = "flow_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelinePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelinePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelinePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connections: Sequence['outputs.PipelineConnectionResponse'],
                 provisioning_state: _builtins.str,
                 remote_cloud: _builtins.str,
                 display_name: Optional[_builtins.str] = None,
                 flow_types: Optional[Sequence[_builtins.str]] = None,
                 policies: Optional[Sequence[_builtins.str]] = None,
                 subscribers: Optional[Sequence['outputs.SubscriberResponse']] = None):
        """
        Properties of pipeline
        :param Sequence['PipelineConnectionResponse'] connections: Connections associated with pipeline
        :param _builtins.str provisioning_state: Provisioning state of the pipeline
        :param _builtins.str remote_cloud: Remote cloud of the data to be transferred or received
        :param _builtins.str display_name: Display name of this pipeline
        :param Sequence[_builtins.str] flow_types: The flow types allowed for this pipeline
        :param Sequence[_builtins.str] policies: The policies for this pipeline
        :param Sequence['SubscriberResponse'] subscribers: Subscribers of this resource
        """
        pulumi.set(__self__, "connections", connections)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "remote_cloud", remote_cloud)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if flow_types is not None:
            pulumi.set(__self__, "flow_types", flow_types)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if subscribers is not None:
            pulumi.set(__self__, "subscribers", subscribers)

    @_builtins.property
    @pulumi.getter
    def connections(self) -> Sequence['outputs.PipelineConnectionResponse']:
        """
        Connections associated with pipeline
        """
        return pulumi.get(self, "connections")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the pipeline
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="remoteCloud")
    def remote_cloud(self) -> _builtins.str:
        """
        Remote cloud of the data to be transferred or received
        """
        return pulumi.get(self, "remote_cloud")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        Display name of this pipeline
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="flowTypes")
    def flow_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The flow types allowed for this pipeline
        """
        return pulumi.get(self, "flow_types")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[_builtins.str]]:
        """
        The policies for this pipeline
        """
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter
    def subscribers(self) -> Optional[Sequence['outputs.SubscriberResponse']]:
        """
        Subscribers of this resource
        """
        return pulumi.get(self, "subscribers")


@pulumi.output_type
class PlanResponse(dict):
    """
    Plan for the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "promotionCode":
            suggest = "promotion_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 product: _builtins.str,
                 publisher: _builtins.str,
                 promotion_code: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        Plan for the resource.
        :param _builtins.str name: A user defined name of the 3rd Party Artifact that is being procured.
        :param _builtins.str product: The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding. 
        :param _builtins.str publisher: The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
        :param _builtins.str promotion_code: A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
        :param _builtins.str version: The version of the desired product/artifact.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)
        if promotion_code is not None:
            pulumi.set(__self__, "promotion_code", promotion_code)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A user defined name of the 3rd Party Artifact that is being procured.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def product(self) -> _builtins.str:
        """
        The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding. 
        """
        return pulumi.get(self, "product")

    @_builtins.property
    @pulumi.getter
    def publisher(self) -> _builtins.str:
        """
        The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
        """
        return pulumi.get(self, "publisher")

    @_builtins.property
    @pulumi.getter(name="promotionCode")
    def promotion_code(self) -> Optional[_builtins.str]:
        """
        A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
        """
        return pulumi.get(self, "promotion_code")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The version of the desired product/artifact.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SchemaResponse(dict):
    """
    The schema object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionId":
            suggest = "connection_id"
        elif key == "schemaType":
            suggest = "schema_type"
        elif key == "schemaUri":
            suggest = "schema_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SchemaResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SchemaResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SchemaResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_id: Optional[_builtins.str] = None,
                 content: Optional[_builtins.str] = None,
                 direction: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 schema_type: Optional[_builtins.str] = None,
                 schema_uri: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        The schema object.
        :param _builtins.str connection_id: Connection ID associated with this schema
        :param _builtins.str content: Content of the schema
        :param _builtins.str direction: The direction of the schema.
        :param _builtins.str id: ID associated with this schema
        :param _builtins.str name: Name of the schema
        :param _builtins.str schema_type: The Schema Type
        :param _builtins.str schema_uri: Uri containing SAS token for the zipped schema
        :param _builtins.str status: Status of the schema
        """
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schema_type is not None:
            pulumi.set(__self__, "schema_type", schema_type)
        if schema_uri is not None:
            pulumi.set(__self__, "schema_uri", schema_uri)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[_builtins.str]:
        """
        Connection ID associated with this schema
        """
        return pulumi.get(self, "connection_id")

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        """
        Content of the schema
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The direction of the schema.
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID associated with this schema
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the schema
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="schemaType")
    def schema_type(self) -> Optional[_builtins.str]:
        """
        The Schema Type
        """
        return pulumi.get(self, "schema_type")

    @_builtins.property
    @pulumi.getter(name="schemaUri")
    def schema_uri(self) -> Optional[_builtins.str]:
        """
        Uri containing SAS token for the zipped schema
        """
        return pulumi.get(self, "schema_uri")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the schema
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SelectedResourceResponse(dict):
    """
    A resource selected from ARM
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subscriptionName":
            suggest = "subscription_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SelectedResourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SelectedResourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SelectedResourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 location: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 subscription_name: Optional[_builtins.str] = None):
        """
        A resource selected from ARM
        :param _builtins.str id: Id of the connection
        :param _builtins.str location: Location of the connection
        :param _builtins.str name: Name of the connection
        :param _builtins.str subscription_name: Name of the subscription with the connection
        """
        pulumi.set(__self__, "id", id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if subscription_name is not None:
            pulumi.set(__self__, "subscription_name", subscription_name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Id of the connection
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        Location of the connection
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the connection
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="subscriptionName")
    def subscription_name(self) -> Optional[_builtins.str]:
        """
        Name of the subscription with the connection
        """
        return pulumi.get(self, "subscription_name")


@pulumi.output_type
class StreamSourceAddressesResponse(dict):
    """
    The source IP address and CIDR ranges of the stream
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceAddresses":
            suggest = "source_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceAddressesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceAddressesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceAddressesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_addresses: Optional[Sequence[_builtins.str]] = None):
        """
        The source IP address and CIDR ranges of the stream
        :param Sequence[_builtins.str] source_addresses: A source IP address or CIDR range
        """
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        A source IP address or CIDR range
        """
        return pulumi.get(self, "source_addresses")


@pulumi.output_type
class SubscriberResponse(dict):
    def __init__(__self__, *,
                 email: Optional[_builtins.str] = None,
                 notifications: Optional[_builtins.float] = None):
        """
        :param _builtins.str email: Email of the subscriber
        :param _builtins.float notifications: Number specifying what notifications to receive
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if notifications is not None:
            pulumi.set(__self__, "notifications", notifications)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        Email of the subscriber
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def notifications(self) -> Optional[_builtins.float]:
        """
        Number specifying what notifications to receive
        """
        return pulumi.get(self, "notifications")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 created_by_type: Optional[_builtins.str] = None,
                 last_modified_at: Optional[_builtins.str] = None,
                 last_modified_by: Optional[_builtins.str] = None,
                 last_modified_by_type: Optional[_builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param _builtins.str created_at: The timestamp of resource creation (UTC).
        :param _builtins.str created_by: The identity that created the resource.
        :param _builtins.str created_by_type: The type of identity that created the resource.
        :param _builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param _builtins.str last_modified_by: The identity that last modified the resource.
        :param _builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @_builtins.property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @_builtins.property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[_builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @_builtins.property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 principal_id: _builtins.str):
        """
        User assigned identity properties
        :param _builtins.str client_id: The client ID of the assigned identity.
        :param _builtins.str principal_id: The principal ID of the assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")


