# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AntivirusRulesetArgs',
    'AntivirusRulesetArgsDict',
    'ArchiveRulesetArgs',
    'ArchiveRulesetArgsDict',
    'ConnectionPropertiesArgs',
    'ConnectionPropertiesArgsDict',
    'DataSizeRulesetArgs',
    'DataSizeRulesetArgsDict',
    'FlowProfilePropertiesArgs',
    'FlowProfilePropertiesArgsDict',
    'FlowProfileRulesetsArgs',
    'FlowProfileRulesetsArgsDict',
    'FlowPropertiesArgs',
    'FlowPropertiesArgsDict',
    'ManagedServiceIdentityArgs',
    'ManagedServiceIdentityArgsDict',
    'MessagingOptionsArgs',
    'MessagingOptionsArgsDict',
    'MimeFilterRulesetArgs',
    'MimeFilterRulesetArgsDict',
    'MimeTypeFilterArgs',
    'MimeTypeFilterArgsDict',
    'PipelinePropertiesArgs',
    'PipelinePropertiesArgsDict',
    'PlanArgs',
    'PlanArgsDict',
    'SchemaArgs',
    'SchemaArgsDict',
    'SelectedResourceArgs',
    'SelectedResourceArgsDict',
    'StreamSourceAddressesArgs',
    'StreamSourceAddressesArgsDict',
    'SubscriberArgs',
    'SubscriberArgsDict',
    'TextMatchingRulesetArgs',
    'TextMatchingRulesetArgsDict',
    'TextMatchArgs',
    'TextMatchArgsDict',
    'XmlFilterRulesetArgs',
    'XmlFilterRulesetArgsDict',
]

MYPY = False

if not MYPY:
    class AntivirusRulesetArgsDict(TypedDict):
        """
        Antivirus scanning rules for replicating data. By default, all antivirus scanning solutions are disabled.
        """
        av_solutions: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'AntivirusSolutions']]]]]
        """
        Optional. The list of antiviruses to be used as a scanning solution for replicating data.
        """
elif False:
    AntivirusRulesetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AntivirusRulesetArgs:
    def __init__(__self__, *,
                 av_solutions: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'AntivirusSolutions']]]]] = None):
        """
        Antivirus scanning rules for replicating data. By default, all antivirus scanning solutions are disabled.
        :param pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'AntivirusSolutions']]]] av_solutions: Optional. The list of antiviruses to be used as a scanning solution for replicating data.
        """
        if av_solutions is not None:
            pulumi.set(__self__, "av_solutions", av_solutions)

    @_builtins.property
    @pulumi.getter(name="avSolutions")
    def av_solutions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'AntivirusSolutions']]]]]:
        """
        Optional. The list of antiviruses to be used as a scanning solution for replicating data.
        """
        return pulumi.get(self, "av_solutions")

    @av_solutions.setter
    def av_solutions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'AntivirusSolutions']]]]]):
        pulumi.set(self, "av_solutions", value)


if not MYPY:
    class ArchiveRulesetArgsDict(TypedDict):
        """
        Rules for regulating supported archive files (BZip2, Cpio, Deb, GZip, Rpm, Tar, Zip) during data replication. All properties are optional and only the configured options will be applied against archives. As an example, suppose minimumSizeForExpansion is 10 MiB and maximumExpansionSizeLimit is 1 GiB. Then all archives smaller than 10 MiB will be treated as though the archive ruleset is disabled, although other rulesets will apply as usual. Furthermore, all archives at least 10 MiB in size but with a decompressed size greater than 1 GiB will fail the ruleset. All other archives will have their contents extracted and each extracted element will be applied to all rulesets.
        """
        maximum_compression_ratio_limit: NotRequired[pulumi.Input[_builtins.float]]
        """
        Optional. Provides the multiplication value for an archive in total based on the initial object being validated. This value takes the root object size and multiplies it by this value to create a maximum. Once this maximum is exceeded, the archive is failed. Used to detect and block archives with suspiciously high compression (e.g., zip bombs).
        """
        maximum_depth_limit: NotRequired[pulumi.Input[_builtins.float]]
        """
        Optional. The maximum depth of nested archives that can be expanded. Limits how many layers of embedded archives will be processed. Archives exceeding the max limit will be denied for replication.
        """
        maximum_expansion_size_limit: NotRequired[pulumi.Input[_builtins.float]]
        """
        Optional. The combined maximum size (in bytes) of all extracted files that an expanded archive is allowed to reach. Archives exceeding the max limit will be denied for replication.
        """
        minimum_size_for_expansion: NotRequired[pulumi.Input[_builtins.float]]
        """
        Optional. Default is 0. The minimum archive file size (in bytes) required to trigger expansion during replication. Any archive file size below the configured threshold will skip the rest of the configured rulesets for archives.
        """
elif False:
    ArchiveRulesetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArchiveRulesetArgs:
    def __init__(__self__, *,
                 maximum_compression_ratio_limit: Optional[pulumi.Input[_builtins.float]] = None,
                 maximum_depth_limit: Optional[pulumi.Input[_builtins.float]] = None,
                 maximum_expansion_size_limit: Optional[pulumi.Input[_builtins.float]] = None,
                 minimum_size_for_expansion: Optional[pulumi.Input[_builtins.float]] = None):
        """
        Rules for regulating supported archive files (BZip2, Cpio, Deb, GZip, Rpm, Tar, Zip) during data replication. All properties are optional and only the configured options will be applied against archives. As an example, suppose minimumSizeForExpansion is 10 MiB and maximumExpansionSizeLimit is 1 GiB. Then all archives smaller than 10 MiB will be treated as though the archive ruleset is disabled, although other rulesets will apply as usual. Furthermore, all archives at least 10 MiB in size but with a decompressed size greater than 1 GiB will fail the ruleset. All other archives will have their contents extracted and each extracted element will be applied to all rulesets.
        :param pulumi.Input[_builtins.float] maximum_compression_ratio_limit: Optional. Provides the multiplication value for an archive in total based on the initial object being validated. This value takes the root object size and multiplies it by this value to create a maximum. Once this maximum is exceeded, the archive is failed. Used to detect and block archives with suspiciously high compression (e.g., zip bombs).
        :param pulumi.Input[_builtins.float] maximum_depth_limit: Optional. The maximum depth of nested archives that can be expanded. Limits how many layers of embedded archives will be processed. Archives exceeding the max limit will be denied for replication.
        :param pulumi.Input[_builtins.float] maximum_expansion_size_limit: Optional. The combined maximum size (in bytes) of all extracted files that an expanded archive is allowed to reach. Archives exceeding the max limit will be denied for replication.
        :param pulumi.Input[_builtins.float] minimum_size_for_expansion: Optional. Default is 0. The minimum archive file size (in bytes) required to trigger expansion during replication. Any archive file size below the configured threshold will skip the rest of the configured rulesets for archives.
        """
        if maximum_compression_ratio_limit is not None:
            pulumi.set(__self__, "maximum_compression_ratio_limit", maximum_compression_ratio_limit)
        if maximum_depth_limit is not None:
            pulumi.set(__self__, "maximum_depth_limit", maximum_depth_limit)
        if maximum_expansion_size_limit is not None:
            pulumi.set(__self__, "maximum_expansion_size_limit", maximum_expansion_size_limit)
        if minimum_size_for_expansion is None:
            minimum_size_for_expansion = 0
        if minimum_size_for_expansion is not None:
            pulumi.set(__self__, "minimum_size_for_expansion", minimum_size_for_expansion)

    @_builtins.property
    @pulumi.getter(name="maximumCompressionRatioLimit")
    def maximum_compression_ratio_limit(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Optional. Provides the multiplication value for an archive in total based on the initial object being validated. This value takes the root object size and multiplies it by this value to create a maximum. Once this maximum is exceeded, the archive is failed. Used to detect and block archives with suspiciously high compression (e.g., zip bombs).
        """
        return pulumi.get(self, "maximum_compression_ratio_limit")

    @maximum_compression_ratio_limit.setter
    def maximum_compression_ratio_limit(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "maximum_compression_ratio_limit", value)

    @_builtins.property
    @pulumi.getter(name="maximumDepthLimit")
    def maximum_depth_limit(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Optional. The maximum depth of nested archives that can be expanded. Limits how many layers of embedded archives will be processed. Archives exceeding the max limit will be denied for replication.
        """
        return pulumi.get(self, "maximum_depth_limit")

    @maximum_depth_limit.setter
    def maximum_depth_limit(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "maximum_depth_limit", value)

    @_builtins.property
    @pulumi.getter(name="maximumExpansionSizeLimit")
    def maximum_expansion_size_limit(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Optional. The combined maximum size (in bytes) of all extracted files that an expanded archive is allowed to reach. Archives exceeding the max limit will be denied for replication.
        """
        return pulumi.get(self, "maximum_expansion_size_limit")

    @maximum_expansion_size_limit.setter
    def maximum_expansion_size_limit(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "maximum_expansion_size_limit", value)

    @_builtins.property
    @pulumi.getter(name="minimumSizeForExpansion")
    def minimum_size_for_expansion(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Optional. Default is 0. The minimum archive file size (in bytes) required to trigger expansion during replication. Any archive file size below the configured threshold will skip the rest of the configured rulesets for archives.
        """
        return pulumi.get(self, "minimum_size_for_expansion")

    @minimum_size_for_expansion.setter
    def minimum_size_for_expansion(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "minimum_size_for_expansion", value)


if not MYPY:
    class ConnectionPropertiesArgsDict(TypedDict):
        """
        Properties of connection
        """
        pipeline: pulumi.Input[_builtins.str]
        """
        Pipeline to use to transfer data
        """
        direction: NotRequired[pulumi.Input[Union[_builtins.str, 'Direction']]]
        """
        Direction of data movement
        """
        flow_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'FlowType']]]]]
        """
        The flow types being requested for this connection
        """
        justification: NotRequired[pulumi.Input[_builtins.str]]
        """
        Justification for the connection request
        """
        pin: NotRequired[pulumi.Input[_builtins.str]]
        """
        PIN to link requests together
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The policies for this connection
        """
        primary_contact: NotRequired[pulumi.Input[_builtins.str]]
        """
        The primary contact for this connection request
        """
        remote_subscription_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Subscription ID to link cloud subscriptions together
        """
        requirement_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Requirement ID of the connection
        """
        schema_uris: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The schema URIs for this connection
        """
        schemas: NotRequired[pulumi.Input[Sequence[pulumi.Input['SchemaArgsDict']]]]
        """
        The schemas for this connection
        """
        secondary_contacts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The secondary contacts for this connection request
        """
elif False:
    ConnectionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionPropertiesArgs:
    def __init__(__self__, *,
                 pipeline: pulumi.Input[_builtins.str],
                 direction: Optional[pulumi.Input[Union[_builtins.str, 'Direction']]] = None,
                 flow_types: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'FlowType']]]]] = None,
                 justification: Optional[pulumi.Input[_builtins.str]] = None,
                 pin: Optional[pulumi.Input[_builtins.str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 primary_contact: Optional[pulumi.Input[_builtins.str]] = None,
                 remote_subscription_id: Optional[pulumi.Input[_builtins.str]] = None,
                 requirement_id: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_uris: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 schemas: Optional[pulumi.Input[Sequence[pulumi.Input['SchemaArgs']]]] = None,
                 secondary_contacts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        Properties of connection
        :param pulumi.Input[_builtins.str] pipeline: Pipeline to use to transfer data
        :param pulumi.Input[Union[_builtins.str, 'Direction']] direction: Direction of data movement
        :param pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'FlowType']]]] flow_types: The flow types being requested for this connection
        :param pulumi.Input[_builtins.str] justification: Justification for the connection request
        :param pulumi.Input[_builtins.str] pin: PIN to link requests together
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] policies: The policies for this connection
        :param pulumi.Input[_builtins.str] primary_contact: The primary contact for this connection request
        :param pulumi.Input[_builtins.str] remote_subscription_id: Subscription ID to link cloud subscriptions together
        :param pulumi.Input[_builtins.str] requirement_id: Requirement ID of the connection
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] schema_uris: The schema URIs for this connection
        :param pulumi.Input[Sequence[pulumi.Input['SchemaArgs']]] schemas: The schemas for this connection
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] secondary_contacts: The secondary contacts for this connection request
        """
        pulumi.set(__self__, "pipeline", pipeline)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if flow_types is not None:
            pulumi.set(__self__, "flow_types", flow_types)
        if justification is not None:
            pulumi.set(__self__, "justification", justification)
        if pin is not None:
            pulumi.set(__self__, "pin", pin)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if primary_contact is not None:
            pulumi.set(__self__, "primary_contact", primary_contact)
        if remote_subscription_id is not None:
            pulumi.set(__self__, "remote_subscription_id", remote_subscription_id)
        if requirement_id is not None:
            pulumi.set(__self__, "requirement_id", requirement_id)
        if schema_uris is not None:
            pulumi.set(__self__, "schema_uris", schema_uris)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)
        if secondary_contacts is not None:
            pulumi.set(__self__, "secondary_contacts", secondary_contacts)

    @_builtins.property
    @pulumi.getter
    def pipeline(self) -> pulumi.Input[_builtins.str]:
        """
        Pipeline to use to transfer data
        """
        return pulumi.get(self, "pipeline")

    @pipeline.setter
    def pipeline(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pipeline", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[Union[_builtins.str, 'Direction']]]:
        """
        Direction of data movement
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[Union[_builtins.str, 'Direction']]]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter(name="flowTypes")
    def flow_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'FlowType']]]]]:
        """
        The flow types being requested for this connection
        """
        return pulumi.get(self, "flow_types")

    @flow_types.setter
    def flow_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'FlowType']]]]]):
        pulumi.set(self, "flow_types", value)

    @_builtins.property
    @pulumi.getter
    def justification(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Justification for the connection request
        """
        return pulumi.get(self, "justification")

    @justification.setter
    def justification(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "justification", value)

    @_builtins.property
    @pulumi.getter
    def pin(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        PIN to link requests together
        """
        return pulumi.get(self, "pin")

    @pin.setter
    def pin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pin", value)

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The policies for this connection
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "policies", value)

    @_builtins.property
    @pulumi.getter(name="primaryContact")
    def primary_contact(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The primary contact for this connection request
        """
        return pulumi.get(self, "primary_contact")

    @primary_contact.setter
    def primary_contact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "primary_contact", value)

    @_builtins.property
    @pulumi.getter(name="remoteSubscriptionId")
    def remote_subscription_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Subscription ID to link cloud subscriptions together
        """
        return pulumi.get(self, "remote_subscription_id")

    @remote_subscription_id.setter
    def remote_subscription_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_subscription_id", value)

    @_builtins.property
    @pulumi.getter(name="requirementId")
    def requirement_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Requirement ID of the connection
        """
        return pulumi.get(self, "requirement_id")

    @requirement_id.setter
    def requirement_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "requirement_id", value)

    @_builtins.property
    @pulumi.getter(name="schemaUris")
    def schema_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The schema URIs for this connection
        """
        return pulumi.get(self, "schema_uris")

    @schema_uris.setter
    def schema_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "schema_uris", value)

    @_builtins.property
    @pulumi.getter
    def schemas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SchemaArgs']]]]:
        """
        The schemas for this connection
        """
        return pulumi.get(self, "schemas")

    @schemas.setter
    def schemas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SchemaArgs']]]]):
        pulumi.set(self, "schemas", value)

    @_builtins.property
    @pulumi.getter(name="secondaryContacts")
    def secondary_contacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The secondary contacts for this connection request
        """
        return pulumi.get(self, "secondary_contacts")

    @secondary_contacts.setter
    def secondary_contacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "secondary_contacts", value)


if not MYPY:
    class DataSizeRulesetArgsDict(TypedDict):
        """
        Defines rules that enforce minimum and maximum file size limits for data replication.
        """
        maximum: NotRequired[pulumi.Input[_builtins.float]]
        """
        Optional. Specifies the maximum allowed size (in bytes) for files to be replicated. Any file size greater than maximum will be denied replication.
        """
        minimum: NotRequired[pulumi.Input[_builtins.float]]
        """
        Optional. Default is 0. Specifies the minimum required size (in bytes) for a file to be eligible for replication. Any file size less than minimum will be denied replication.
        """
elif False:
    DataSizeRulesetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSizeRulesetArgs:
    def __init__(__self__, *,
                 maximum: Optional[pulumi.Input[_builtins.float]] = None,
                 minimum: Optional[pulumi.Input[_builtins.float]] = None):
        """
        Defines rules that enforce minimum and maximum file size limits for data replication.
        :param pulumi.Input[_builtins.float] maximum: Optional. Specifies the maximum allowed size (in bytes) for files to be replicated. Any file size greater than maximum will be denied replication.
        :param pulumi.Input[_builtins.float] minimum: Optional. Default is 0. Specifies the minimum required size (in bytes) for a file to be eligible for replication. Any file size less than minimum will be denied replication.
        """
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is None:
            minimum = 0
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Optional. Specifies the maximum allowed size (in bytes) for files to be replicated. Any file size greater than maximum will be denied replication.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "maximum", value)

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Optional. Default is 0. Specifies the minimum required size (in bytes) for a file to be eligible for replication. Any file size less than minimum will be denied replication.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "minimum", value)


if not MYPY:
    class FlowProfilePropertiesArgsDict(TypedDict):
        """
        Defines the full set of properties for a FlowProfile resource.
        """
        description: pulumi.Input[_builtins.str]
        """
        A user-defined description of the FlowProfile.
        """
        replication_scenario: pulumi.Input[Union[_builtins.str, 'DataClassType']]
        """
        The data replication scenario handled by this FlowProfile. Please not, that this value cannot be updated after creation.
        """
        status: pulumi.Input[Union[_builtins.str, 'FlowProfileStatus']]
        """
        The operational status of the FlowProfile.
        """
        rulesets: NotRequired[pulumi.Input['FlowProfileRulesetsArgsDict']]
        """
        A set of configurable rulesets applied to this FlowProfile.
        """
elif False:
    FlowProfilePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowProfilePropertiesArgs:
    def __init__(__self__, *,
                 description: pulumi.Input[_builtins.str],
                 replication_scenario: pulumi.Input[Union[_builtins.str, 'DataClassType']],
                 status: pulumi.Input[Union[_builtins.str, 'FlowProfileStatus']],
                 rulesets: Optional[pulumi.Input['FlowProfileRulesetsArgs']] = None):
        """
        Defines the full set of properties for a FlowProfile resource.
        :param pulumi.Input[_builtins.str] description: A user-defined description of the FlowProfile.
        :param pulumi.Input[Union[_builtins.str, 'DataClassType']] replication_scenario: The data replication scenario handled by this FlowProfile. Please not, that this value cannot be updated after creation.
        :param pulumi.Input[Union[_builtins.str, 'FlowProfileStatus']] status: The operational status of the FlowProfile.
        :param pulumi.Input['FlowProfileRulesetsArgs'] rulesets: A set of configurable rulesets applied to this FlowProfile.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "replication_scenario", replication_scenario)
        pulumi.set(__self__, "status", status)
        if rulesets is not None:
            pulumi.set(__self__, "rulesets", rulesets)

    @_builtins.property
    @pulumi.getter
    def description(self) -> pulumi.Input[_builtins.str]:
        """
        A user-defined description of the FlowProfile.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="replicationScenario")
    def replication_scenario(self) -> pulumi.Input[Union[_builtins.str, 'DataClassType']]:
        """
        The data replication scenario handled by this FlowProfile. Please not, that this value cannot be updated after creation.
        """
        return pulumi.get(self, "replication_scenario")

    @replication_scenario.setter
    def replication_scenario(self, value: pulumi.Input[Union[_builtins.str, 'DataClassType']]):
        pulumi.set(self, "replication_scenario", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[Union[_builtins.str, 'FlowProfileStatus']]:
        """
        The operational status of the FlowProfile.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[Union[_builtins.str, 'FlowProfileStatus']]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def rulesets(self) -> Optional[pulumi.Input['FlowProfileRulesetsArgs']]:
        """
        A set of configurable rulesets applied to this FlowProfile.
        """
        return pulumi.get(self, "rulesets")

    @rulesets.setter
    def rulesets(self, value: Optional[pulumi.Input['FlowProfileRulesetsArgs']]):
        pulumi.set(self, "rulesets", value)


if not MYPY:
    class FlowProfileRulesetsArgsDict(TypedDict):
        """
        The allowed set of configurable rulesets for a FlowProfile resource, used during data replication. All rulesets are optional, and any ruleset configured will be applied to every applicable replicating data. Any data that fails a ruleset will be denied replication. If a ruleset is not configured then the ruleset is considered disabled and will not apply towards replicating data.
        """
        antivirus: NotRequired[pulumi.Input['AntivirusRulesetArgsDict']]
        """
        Antivirus scanning rules for replicated data.
        """
        archives: NotRequired[pulumi.Input['ArchiveRulesetArgsDict']]
        """
        Rules for handling archive files during replication.
        """
        data_size: NotRequired[pulumi.Input['DataSizeRulesetArgsDict']]
        """
        Rules that enforce minimum and maximum data size limits.
        """
        mime_filters: NotRequired[pulumi.Input['MimeFilterRulesetArgsDict']]
        """
        Rules for filtering files based on MIME types.
        """
        text_matching: NotRequired[pulumi.Input['TextMatchingRulesetArgsDict']]
        """
        Rules for detecting and blocking specific text patterns.
        """
        xml_filters: NotRequired[pulumi.Input['XmlFilterRulesetArgsDict']]
        """
        Rules for filtering XML content using XSD schemas.
        """
elif False:
    FlowProfileRulesetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowProfileRulesetsArgs:
    def __init__(__self__, *,
                 antivirus: Optional[pulumi.Input['AntivirusRulesetArgs']] = None,
                 archives: Optional[pulumi.Input['ArchiveRulesetArgs']] = None,
                 data_size: Optional[pulumi.Input['DataSizeRulesetArgs']] = None,
                 mime_filters: Optional[pulumi.Input['MimeFilterRulesetArgs']] = None,
                 text_matching: Optional[pulumi.Input['TextMatchingRulesetArgs']] = None,
                 xml_filters: Optional[pulumi.Input['XmlFilterRulesetArgs']] = None):
        """
        The allowed set of configurable rulesets for a FlowProfile resource, used during data replication. All rulesets are optional, and any ruleset configured will be applied to every applicable replicating data. Any data that fails a ruleset will be denied replication. If a ruleset is not configured then the ruleset is considered disabled and will not apply towards replicating data.
        :param pulumi.Input['AntivirusRulesetArgs'] antivirus: Antivirus scanning rules for replicated data.
        :param pulumi.Input['ArchiveRulesetArgs'] archives: Rules for handling archive files during replication.
        :param pulumi.Input['DataSizeRulesetArgs'] data_size: Rules that enforce minimum and maximum data size limits.
        :param pulumi.Input['MimeFilterRulesetArgs'] mime_filters: Rules for filtering files based on MIME types.
        :param pulumi.Input['TextMatchingRulesetArgs'] text_matching: Rules for detecting and blocking specific text patterns.
        :param pulumi.Input['XmlFilterRulesetArgs'] xml_filters: Rules for filtering XML content using XSD schemas.
        """
        if antivirus is not None:
            pulumi.set(__self__, "antivirus", antivirus)
        if archives is not None:
            pulumi.set(__self__, "archives", archives)
        if data_size is not None:
            pulumi.set(__self__, "data_size", data_size)
        if mime_filters is not None:
            pulumi.set(__self__, "mime_filters", mime_filters)
        if text_matching is not None:
            pulumi.set(__self__, "text_matching", text_matching)
        if xml_filters is not None:
            pulumi.set(__self__, "xml_filters", xml_filters)

    @_builtins.property
    @pulumi.getter
    def antivirus(self) -> Optional[pulumi.Input['AntivirusRulesetArgs']]:
        """
        Antivirus scanning rules for replicated data.
        """
        return pulumi.get(self, "antivirus")

    @antivirus.setter
    def antivirus(self, value: Optional[pulumi.Input['AntivirusRulesetArgs']]):
        pulumi.set(self, "antivirus", value)

    @_builtins.property
    @pulumi.getter
    def archives(self) -> Optional[pulumi.Input['ArchiveRulesetArgs']]:
        """
        Rules for handling archive files during replication.
        """
        return pulumi.get(self, "archives")

    @archives.setter
    def archives(self, value: Optional[pulumi.Input['ArchiveRulesetArgs']]):
        pulumi.set(self, "archives", value)

    @_builtins.property
    @pulumi.getter(name="dataSize")
    def data_size(self) -> Optional[pulumi.Input['DataSizeRulesetArgs']]:
        """
        Rules that enforce minimum and maximum data size limits.
        """
        return pulumi.get(self, "data_size")

    @data_size.setter
    def data_size(self, value: Optional[pulumi.Input['DataSizeRulesetArgs']]):
        pulumi.set(self, "data_size", value)

    @_builtins.property
    @pulumi.getter(name="mimeFilters")
    def mime_filters(self) -> Optional[pulumi.Input['MimeFilterRulesetArgs']]:
        """
        Rules for filtering files based on MIME types.
        """
        return pulumi.get(self, "mime_filters")

    @mime_filters.setter
    def mime_filters(self, value: Optional[pulumi.Input['MimeFilterRulesetArgs']]):
        pulumi.set(self, "mime_filters", value)

    @_builtins.property
    @pulumi.getter(name="textMatching")
    def text_matching(self) -> Optional[pulumi.Input['TextMatchingRulesetArgs']]:
        """
        Rules for detecting and blocking specific text patterns.
        """
        return pulumi.get(self, "text_matching")

    @text_matching.setter
    def text_matching(self, value: Optional[pulumi.Input['TextMatchingRulesetArgs']]):
        pulumi.set(self, "text_matching", value)

    @_builtins.property
    @pulumi.getter(name="xmlFilters")
    def xml_filters(self) -> Optional[pulumi.Input['XmlFilterRulesetArgs']]:
        """
        Rules for filtering XML content using XSD schemas.
        """
        return pulumi.get(self, "xml_filters")

    @xml_filters.setter
    def xml_filters(self, value: Optional[pulumi.Input['XmlFilterRulesetArgs']]):
        pulumi.set(self, "xml_filters", value)


if not MYPY:
    class FlowPropertiesArgsDict(TypedDict):
        """
        Properties of flow
        """
        connection: NotRequired[pulumi.Input['SelectedResourceArgsDict']]
        """
        The connection associated with this flow
        """
        customer_managed_key_vault_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URI to the customer managed key for this flow
        """
        data_type: NotRequired[pulumi.Input[Union[_builtins.str, 'DataType']]]
        """
        Transfer Storage Blobs or Tables
        """
        destination_endpoint_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.float]]]]
        """
        The destination endpoint ports of the stream
        """
        destination_endpoints: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The destination endpoints of the stream
        """
        flow_type: NotRequired[pulumi.Input[Union[_builtins.str, 'FlowType']]]
        """
        The flow type for this flow
        """
        key_vault_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        AME, PME, or TORUS only! AKV Chain Containing SAS Token
        """
        messaging_options: NotRequired[pulumi.Input['MessagingOptionsArgsDict']]
        """
        The messaging options for this flow
        """
        passphrase: NotRequired[pulumi.Input[_builtins.str]]
        """
        The passphrase used for SRT streams
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The policies for this flow
        """
        schema: NotRequired[pulumi.Input['SchemaArgsDict']]
        """
        The selected schema for this flow
        """
        service_bus_queue_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Service Bus Queue ID
        """
        source_addresses: NotRequired[pulumi.Input['StreamSourceAddressesArgsDict']]
        """
        The source IP address and CIDR ranges of the stream
        """
        status: NotRequired[pulumi.Input[Union[_builtins.str, 'FlowStatus']]]
        """
        Status of the current flow
        """
        storage_account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Storage Account ID
        """
        storage_account_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Storage Account
        """
        storage_container_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Storage Container Name
        """
        stream_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The flow stream identifier
        """
        stream_latency: NotRequired[pulumi.Input[_builtins.float]]
        """
        The latency of the stream in milliseconds
        """
        stream_protocol: NotRequired[pulumi.Input[Union[_builtins.str, 'StreamProtocol']]]
        """
        The protocol of the stream
        """
elif False:
    FlowPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowPropertiesArgs:
    def __init__(__self__, *,
                 connection: Optional[pulumi.Input['SelectedResourceArgs']] = None,
                 customer_managed_key_vault_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 data_type: Optional[pulumi.Input[Union[_builtins.str, 'DataType']]] = None,
                 destination_endpoint_ports: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.float]]]] = None,
                 destination_endpoints: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 flow_type: Optional[pulumi.Input[Union[_builtins.str, 'FlowType']]] = None,
                 key_vault_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 messaging_options: Optional[pulumi.Input['MessagingOptionsArgs']] = None,
                 passphrase: Optional[pulumi.Input[_builtins.str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 schema: Optional[pulumi.Input['SchemaArgs']] = None,
                 service_bus_queue_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_addresses: Optional[pulumi.Input['StreamSourceAddressesArgs']] = None,
                 status: Optional[pulumi.Input[Union[_builtins.str, 'FlowStatus']]] = None,
                 storage_account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 storage_account_name: Optional[pulumi.Input[_builtins.str]] = None,
                 storage_container_name: Optional[pulumi.Input[_builtins.str]] = None,
                 stream_id: Optional[pulumi.Input[_builtins.str]] = None,
                 stream_latency: Optional[pulumi.Input[_builtins.float]] = None,
                 stream_protocol: Optional[pulumi.Input[Union[_builtins.str, 'StreamProtocol']]] = None):
        """
        Properties of flow
        :param pulumi.Input['SelectedResourceArgs'] connection: The connection associated with this flow
        :param pulumi.Input[_builtins.str] customer_managed_key_vault_uri: The URI to the customer managed key for this flow
        :param pulumi.Input[Union[_builtins.str, 'DataType']] data_type: Transfer Storage Blobs or Tables
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.float]]] destination_endpoint_ports: The destination endpoint ports of the stream
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] destination_endpoints: The destination endpoints of the stream
        :param pulumi.Input[Union[_builtins.str, 'FlowType']] flow_type: The flow type for this flow
        :param pulumi.Input[_builtins.str] key_vault_uri: AME, PME, or TORUS only! AKV Chain Containing SAS Token
        :param pulumi.Input['MessagingOptionsArgs'] messaging_options: The messaging options for this flow
        :param pulumi.Input[_builtins.str] passphrase: The passphrase used for SRT streams
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] policies: The policies for this flow
        :param pulumi.Input['SchemaArgs'] schema: The selected schema for this flow
        :param pulumi.Input[_builtins.str] service_bus_queue_id: Service Bus Queue ID
        :param pulumi.Input['StreamSourceAddressesArgs'] source_addresses: The source IP address and CIDR ranges of the stream
        :param pulumi.Input[Union[_builtins.str, 'FlowStatus']] status: Status of the current flow
        :param pulumi.Input[_builtins.str] storage_account_id: Storage Account ID
        :param pulumi.Input[_builtins.str] storage_account_name: Storage Account
        :param pulumi.Input[_builtins.str] storage_container_name: Storage Container Name
        :param pulumi.Input[_builtins.str] stream_id: The flow stream identifier
        :param pulumi.Input[_builtins.float] stream_latency: The latency of the stream in milliseconds
        :param pulumi.Input[Union[_builtins.str, 'StreamProtocol']] stream_protocol: The protocol of the stream
        """
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if customer_managed_key_vault_uri is not None:
            pulumi.set(__self__, "customer_managed_key_vault_uri", customer_managed_key_vault_uri)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if destination_endpoint_ports is not None:
            pulumi.set(__self__, "destination_endpoint_ports", destination_endpoint_ports)
        if destination_endpoints is not None:
            pulumi.set(__self__, "destination_endpoints", destination_endpoints)
        if flow_type is not None:
            pulumi.set(__self__, "flow_type", flow_type)
        if key_vault_uri is not None:
            pulumi.set(__self__, "key_vault_uri", key_vault_uri)
        if messaging_options is not None:
            pulumi.set(__self__, "messaging_options", messaging_options)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if service_bus_queue_id is not None:
            pulumi.set(__self__, "service_bus_queue_id", service_bus_queue_id)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if storage_account_id is not None:
            pulumi.set(__self__, "storage_account_id", storage_account_id)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)
        if storage_container_name is not None:
            pulumi.set(__self__, "storage_container_name", storage_container_name)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if stream_latency is not None:
            pulumi.set(__self__, "stream_latency", stream_latency)
        if stream_protocol is not None:
            pulumi.set(__self__, "stream_protocol", stream_protocol)

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional[pulumi.Input['SelectedResourceArgs']]:
        """
        The connection associated with this flow
        """
        return pulumi.get(self, "connection")

    @connection.setter
    def connection(self, value: Optional[pulumi.Input['SelectedResourceArgs']]):
        pulumi.set(self, "connection", value)

    @_builtins.property
    @pulumi.getter(name="customerManagedKeyVaultUri")
    def customer_managed_key_vault_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URI to the customer managed key for this flow
        """
        return pulumi.get(self, "customer_managed_key_vault_uri")

    @customer_managed_key_vault_uri.setter
    def customer_managed_key_vault_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "customer_managed_key_vault_uri", value)

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[Union[_builtins.str, 'DataType']]]:
        """
        Transfer Storage Blobs or Tables
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[Union[_builtins.str, 'DataType']]]):
        pulumi.set(self, "data_type", value)

    @_builtins.property
    @pulumi.getter(name="destinationEndpointPorts")
    def destination_endpoint_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.float]]]]:
        """
        The destination endpoint ports of the stream
        """
        return pulumi.get(self, "destination_endpoint_ports")

    @destination_endpoint_ports.setter
    def destination_endpoint_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.float]]]]):
        pulumi.set(self, "destination_endpoint_ports", value)

    @_builtins.property
    @pulumi.getter(name="destinationEndpoints")
    def destination_endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The destination endpoints of the stream
        """
        return pulumi.get(self, "destination_endpoints")

    @destination_endpoints.setter
    def destination_endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "destination_endpoints", value)

    @_builtins.property
    @pulumi.getter(name="flowType")
    def flow_type(self) -> Optional[pulumi.Input[Union[_builtins.str, 'FlowType']]]:
        """
        The flow type for this flow
        """
        return pulumi.get(self, "flow_type")

    @flow_type.setter
    def flow_type(self, value: Optional[pulumi.Input[Union[_builtins.str, 'FlowType']]]):
        pulumi.set(self, "flow_type", value)

    @_builtins.property
    @pulumi.getter(name="keyVaultUri")
    def key_vault_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AME, PME, or TORUS only! AKV Chain Containing SAS Token
        """
        return pulumi.get(self, "key_vault_uri")

    @key_vault_uri.setter
    def key_vault_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_vault_uri", value)

    @_builtins.property
    @pulumi.getter(name="messagingOptions")
    def messaging_options(self) -> Optional[pulumi.Input['MessagingOptionsArgs']]:
        """
        The messaging options for this flow
        """
        return pulumi.get(self, "messaging_options")

    @messaging_options.setter
    def messaging_options(self, value: Optional[pulumi.Input['MessagingOptionsArgs']]):
        pulumi.set(self, "messaging_options", value)

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The passphrase used for SRT streams
        """
        return pulumi.get(self, "passphrase")

    @passphrase.setter
    def passphrase(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "passphrase", value)

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The policies for this flow
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "policies", value)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input['SchemaArgs']]:
        """
        The selected schema for this flow
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input['SchemaArgs']]):
        pulumi.set(self, "schema", value)

    @_builtins.property
    @pulumi.getter(name="serviceBusQueueId")
    def service_bus_queue_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Service Bus Queue ID
        """
        return pulumi.get(self, "service_bus_queue_id")

    @service_bus_queue_id.setter
    def service_bus_queue_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_bus_queue_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[pulumi.Input['StreamSourceAddressesArgs']]:
        """
        The source IP address and CIDR ranges of the stream
        """
        return pulumi.get(self, "source_addresses")

    @source_addresses.setter
    def source_addresses(self, value: Optional[pulumi.Input['StreamSourceAddressesArgs']]):
        pulumi.set(self, "source_addresses", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[_builtins.str, 'FlowStatus']]]:
        """
        Status of the current flow
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[_builtins.str, 'FlowStatus']]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Storage Account ID
        """
        return pulumi.get(self, "storage_account_id")

    @storage_account_id.setter
    def storage_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage_account_id", value)

    @_builtins.property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Storage Account
        """
        return pulumi.get(self, "storage_account_name")

    @storage_account_name.setter
    def storage_account_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage_account_name", value)

    @_builtins.property
    @pulumi.getter(name="storageContainerName")
    def storage_container_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Storage Container Name
        """
        return pulumi.get(self, "storage_container_name")

    @storage_container_name.setter
    def storage_container_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage_container_name", value)

    @_builtins.property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The flow stream identifier
        """
        return pulumi.get(self, "stream_id")

    @stream_id.setter
    def stream_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stream_id", value)

    @_builtins.property
    @pulumi.getter(name="streamLatency")
    def stream_latency(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The latency of the stream in milliseconds
        """
        return pulumi.get(self, "stream_latency")

    @stream_latency.setter
    def stream_latency(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "stream_latency", value)

    @_builtins.property
    @pulumi.getter(name="streamProtocol")
    def stream_protocol(self) -> Optional[pulumi.Input[Union[_builtins.str, 'StreamProtocol']]]:
        """
        The protocol of the stream
        """
        return pulumi.get(self, "stream_protocol")

    @stream_protocol.setter
    def stream_protocol(self, value: Optional[pulumi.Input[Union[_builtins.str, 'StreamProtocol']]]):
        pulumi.set(self, "stream_protocol", value)


if not MYPY:
    class ManagedServiceIdentityArgsDict(TypedDict):
        """
        Managed service identity (system assigned and/or user assigned identities)
        """
        type: pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']]
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    ManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class MessagingOptionsArgsDict(TypedDict):
        """
        The option associated with messaging flows.
        """
        billing_tier: NotRequired[pulumi.Input[Union[_builtins.str, 'FlowBillingTier']]]
        """
        Billing tier for this messaging flow
        """
elif False:
    MessagingOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MessagingOptionsArgs:
    def __init__(__self__, *,
                 billing_tier: Optional[pulumi.Input[Union[_builtins.str, 'FlowBillingTier']]] = None):
        """
        The option associated with messaging flows.
        :param pulumi.Input[Union[_builtins.str, 'FlowBillingTier']] billing_tier: Billing tier for this messaging flow
        """
        if billing_tier is not None:
            pulumi.set(__self__, "billing_tier", billing_tier)

    @_builtins.property
    @pulumi.getter(name="billingTier")
    def billing_tier(self) -> Optional[pulumi.Input[Union[_builtins.str, 'FlowBillingTier']]]:
        """
        Billing tier for this messaging flow
        """
        return pulumi.get(self, "billing_tier")

    @billing_tier.setter
    def billing_tier(self, value: Optional[pulumi.Input[Union[_builtins.str, 'FlowBillingTier']]]):
        pulumi.set(self, "billing_tier", value)


if not MYPY:
    class MimeFilterRulesetArgsDict(TypedDict):
        """
        Rules for filtering files based on Media types (f.k.a MIME types).
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['MimeTypeFilterArgsDict']]]]
        """
        Defines the Media types (f.k.a MIME types) and associated file extensions to be filtered. For more detail, please refer to the MimeTypeFiler model.
        """
        type: NotRequired[pulumi.Input[Union[_builtins.str, 'FilterType']]]
        """
        Specifies whether the filter is an allow list or deny list. For more detail, please refer to the FilterType model.
        """
elif False:
    MimeFilterRulesetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MimeFilterRulesetArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['MimeTypeFilterArgs']]]] = None,
                 type: Optional[pulumi.Input[Union[_builtins.str, 'FilterType']]] = None):
        """
        Rules for filtering files based on Media types (f.k.a MIME types).
        :param pulumi.Input[Sequence[pulumi.Input['MimeTypeFilterArgs']]] filters: Defines the Media types (f.k.a MIME types) and associated file extensions to be filtered. For more detail, please refer to the MimeTypeFiler model.
        :param pulumi.Input[Union[_builtins.str, 'FilterType']] type: Specifies whether the filter is an allow list or deny list. For more detail, please refer to the FilterType model.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MimeTypeFilterArgs']]]]:
        """
        Defines the Media types (f.k.a MIME types) and associated file extensions to be filtered. For more detail, please refer to the MimeTypeFiler model.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MimeTypeFilterArgs']]]]):
        pulumi.set(self, "filters", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[_builtins.str, 'FilterType']]]:
        """
        Specifies whether the filter is an allow list or deny list. For more detail, please refer to the FilterType model.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[_builtins.str, 'FilterType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MimeTypeFilterArgsDict(TypedDict):
        """
        Defines a list of Media types (f.k.a MIME Types) and associated file extensions subject to filtering.
        """
        extensions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of file extensions associated with the specified Media type (e.g., .json, .png). To specify files with no extension, use an empty string ""."
        """
        media: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Media Types (f.k.a MIME types), following IANA standards (e.g., application/json, image/png). For a more detailed list of allowed media types please refer to the Tika documentation: https://github.com/apache/tika/blob/main/tika-core/src/main/resources/org/apache/tika/mime/tika-mimetypes.xml
        """
elif False:
    MimeTypeFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MimeTypeFilterArgs:
    def __init__(__self__, *,
                 extensions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 media: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Defines a list of Media types (f.k.a MIME Types) and associated file extensions subject to filtering.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] extensions: A list of file extensions associated with the specified Media type (e.g., .json, .png). To specify files with no extension, use an empty string ""."
        :param pulumi.Input[_builtins.str] media: The Media Types (f.k.a MIME types), following IANA standards (e.g., application/json, image/png). For a more detailed list of allowed media types please refer to the Tika documentation: https://github.com/apache/tika/blob/main/tika-core/src/main/resources/org/apache/tika/mime/tika-mimetypes.xml
        """
        if extensions is not None:
            pulumi.set(__self__, "extensions", extensions)
        if media is not None:
            pulumi.set(__self__, "media", media)

    @_builtins.property
    @pulumi.getter
    def extensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of file extensions associated with the specified Media type (e.g., .json, .png). To specify files with no extension, use an empty string ""."
        """
        return pulumi.get(self, "extensions")

    @extensions.setter
    def extensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "extensions", value)

    @_builtins.property
    @pulumi.getter
    def media(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Media Types (f.k.a MIME types), following IANA standards (e.g., application/json, image/png). For a more detailed list of allowed media types please refer to the Tika documentation: https://github.com/apache/tika/blob/main/tika-core/src/main/resources/org/apache/tika/mime/tika-mimetypes.xml
        """
        return pulumi.get(self, "media")

    @media.setter
    def media(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "media", value)


if not MYPY:
    class PipelinePropertiesArgsDict(TypedDict):
        """
        Properties of pipeline
        """
        remote_cloud: pulumi.Input[_builtins.str]
        """
        Remote cloud of the data to be transferred or received
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name of this pipeline
        """
        flow_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'FlowType']]]]]
        """
        The flow types allowed for this pipeline
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The policies for this pipeline
        """
        subscribers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubscriberArgsDict']]]]
        """
        Subscribers of this resource
        """
elif False:
    PipelinePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelinePropertiesArgs:
    def __init__(__self__, *,
                 remote_cloud: pulumi.Input[_builtins.str],
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 flow_types: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'FlowType']]]]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 subscribers: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriberArgs']]]] = None):
        """
        Properties of pipeline
        :param pulumi.Input[_builtins.str] remote_cloud: Remote cloud of the data to be transferred or received
        :param pulumi.Input[_builtins.str] display_name: Display name of this pipeline
        :param pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'FlowType']]]] flow_types: The flow types allowed for this pipeline
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] policies: The policies for this pipeline
        :param pulumi.Input[Sequence[pulumi.Input['SubscriberArgs']]] subscribers: Subscribers of this resource
        """
        pulumi.set(__self__, "remote_cloud", remote_cloud)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if flow_types is not None:
            pulumi.set(__self__, "flow_types", flow_types)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if subscribers is not None:
            pulumi.set(__self__, "subscribers", subscribers)

    @_builtins.property
    @pulumi.getter(name="remoteCloud")
    def remote_cloud(self) -> pulumi.Input[_builtins.str]:
        """
        Remote cloud of the data to be transferred or received
        """
        return pulumi.get(self, "remote_cloud")

    @remote_cloud.setter
    def remote_cloud(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "remote_cloud", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name of this pipeline
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="flowTypes")
    def flow_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'FlowType']]]]]:
        """
        The flow types allowed for this pipeline
        """
        return pulumi.get(self, "flow_types")

    @flow_types.setter
    def flow_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'FlowType']]]]]):
        pulumi.set(self, "flow_types", value)

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The policies for this pipeline
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "policies", value)

    @_builtins.property
    @pulumi.getter
    def subscribers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubscriberArgs']]]]:
        """
        Subscribers of this resource
        """
        return pulumi.get(self, "subscribers")

    @subscribers.setter
    def subscribers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriberArgs']]]]):
        pulumi.set(self, "subscribers", value)


if not MYPY:
    class PlanArgsDict(TypedDict):
        """
        Plan for the resource.
        """
        name: pulumi.Input[_builtins.str]
        """
        A user defined name of the 3rd Party Artifact that is being procured.
        """
        product: pulumi.Input[_builtins.str]
        """
        The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding. 
        """
        publisher: pulumi.Input[_builtins.str]
        """
        The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
        """
        promotion_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version of the desired product/artifact.
        """
elif False:
    PlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 product: pulumi.Input[_builtins.str],
                 publisher: pulumi.Input[_builtins.str],
                 promotion_code: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Plan for the resource.
        :param pulumi.Input[_builtins.str] name: A user defined name of the 3rd Party Artifact that is being procured.
        :param pulumi.Input[_builtins.str] product: The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding. 
        :param pulumi.Input[_builtins.str] publisher: The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
        :param pulumi.Input[_builtins.str] promotion_code: A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
        :param pulumi.Input[_builtins.str] version: The version of the desired product/artifact.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)
        if promotion_code is not None:
            pulumi.set(__self__, "promotion_code", promotion_code)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A user defined name of the 3rd Party Artifact that is being procured.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def product(self) -> pulumi.Input[_builtins.str]:
        """
        The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding. 
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "product", value)

    @_builtins.property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[_builtins.str]:
        """
        The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "publisher", value)

    @_builtins.property
    @pulumi.getter(name="promotionCode")
    def promotion_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
        """
        return pulumi.get(self, "promotion_code")

    @promotion_code.setter
    def promotion_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "promotion_code", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version of the desired product/artifact.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class SchemaArgsDict(TypedDict):
        """
        The schema object.
        """
        connection_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Connection ID associated with this schema
        """
        content: NotRequired[pulumi.Input[_builtins.str]]
        """
        Content of the schema
        """
        direction: NotRequired[pulumi.Input[Union[_builtins.str, 'SchemaDirection']]]
        """
        The direction of the schema.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID associated with this schema
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the schema
        """
        schema_type: NotRequired[pulumi.Input[Union[_builtins.str, 'SchemaType']]]
        """
        The Schema Type
        """
        schema_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Uri containing SAS token for the zipped schema
        """
        status: NotRequired[pulumi.Input[Union[_builtins.str, 'SchemaStatus']]]
        """
        Status of the schema
        """
elif False:
    SchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SchemaArgs:
    def __init__(__self__, *,
                 connection_id: Optional[pulumi.Input[_builtins.str]] = None,
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 direction: Optional[pulumi.Input[Union[_builtins.str, 'SchemaDirection']]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_type: Optional[pulumi.Input[Union[_builtins.str, 'SchemaType']]] = None,
                 schema_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[Union[_builtins.str, 'SchemaStatus']]] = None):
        """
        The schema object.
        :param pulumi.Input[_builtins.str] connection_id: Connection ID associated with this schema
        :param pulumi.Input[_builtins.str] content: Content of the schema
        :param pulumi.Input[Union[_builtins.str, 'SchemaDirection']] direction: The direction of the schema.
        :param pulumi.Input[_builtins.str] id: ID associated with this schema
        :param pulumi.Input[_builtins.str] name: Name of the schema
        :param pulumi.Input[Union[_builtins.str, 'SchemaType']] schema_type: The Schema Type
        :param pulumi.Input[_builtins.str] schema_uri: Uri containing SAS token for the zipped schema
        :param pulumi.Input[Union[_builtins.str, 'SchemaStatus']] status: Status of the schema
        """
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schema_type is not None:
            pulumi.set(__self__, "schema_type", schema_type)
        if schema_uri is not None:
            pulumi.set(__self__, "schema_uri", schema_uri)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Connection ID associated with this schema
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_id", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Content of the schema
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[Union[_builtins.str, 'SchemaDirection']]]:
        """
        The direction of the schema.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[Union[_builtins.str, 'SchemaDirection']]]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID associated with this schema
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the schema
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="schemaType")
    def schema_type(self) -> Optional[pulumi.Input[Union[_builtins.str, 'SchemaType']]]:
        """
        The Schema Type
        """
        return pulumi.get(self, "schema_type")

    @schema_type.setter
    def schema_type(self, value: Optional[pulumi.Input[Union[_builtins.str, 'SchemaType']]]):
        pulumi.set(self, "schema_type", value)

    @_builtins.property
    @pulumi.getter(name="schemaUri")
    def schema_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Uri containing SAS token for the zipped schema
        """
        return pulumi.get(self, "schema_uri")

    @schema_uri.setter
    def schema_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_uri", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[_builtins.str, 'SchemaStatus']]]:
        """
        Status of the schema
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[_builtins.str, 'SchemaStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class SelectedResourceArgsDict(TypedDict):
        """
        A resource selected from ARM
        """
        id: pulumi.Input[_builtins.str]
        """
        Id of the connection
        """
        location: NotRequired[pulumi.Input[_builtins.str]]
        """
        Location of the connection
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the connection
        """
        subscription_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the subscription with the connection
        """
elif False:
    SelectedResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SelectedResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 subscription_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        A resource selected from ARM
        :param pulumi.Input[_builtins.str] id: Id of the connection
        :param pulumi.Input[_builtins.str] location: Location of the connection
        :param pulumi.Input[_builtins.str] name: Name of the connection
        :param pulumi.Input[_builtins.str] subscription_name: Name of the subscription with the connection
        """
        pulumi.set(__self__, "id", id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if subscription_name is not None:
            pulumi.set(__self__, "subscription_name", subscription_name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Id of the connection
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Location of the connection
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the connection
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="subscriptionName")
    def subscription_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the subscription with the connection
        """
        return pulumi.get(self, "subscription_name")

    @subscription_name.setter
    def subscription_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subscription_name", value)


if not MYPY:
    class StreamSourceAddressesArgsDict(TypedDict):
        """
        The source IP address and CIDR ranges of the stream
        """
        source_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A source IP address or CIDR range
        """
elif False:
    StreamSourceAddressesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceAddressesArgs:
    def __init__(__self__, *,
                 source_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        The source IP address and CIDR ranges of the stream
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] source_addresses: A source IP address or CIDR range
        """
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A source IP address or CIDR range
        """
        return pulumi.get(self, "source_addresses")

    @source_addresses.setter
    def source_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "source_addresses", value)


if not MYPY:
    class SubscriberArgsDict(TypedDict):
        email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email of the subscriber
        """
        notifications: NotRequired[pulumi.Input[_builtins.float]]
        """
        Number specifying what notifications to receive
        """
elif False:
    SubscriberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriberArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[_builtins.str]] = None,
                 notifications: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] email: Email of the subscriber
        :param pulumi.Input[_builtins.float] notifications: Number specifying what notifications to receive
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if notifications is not None:
            pulumi.set(__self__, "notifications", notifications)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email of the subscriber
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter
    def notifications(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Number specifying what notifications to receive
        """
        return pulumi.get(self, "notifications")

    @notifications.setter
    def notifications(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "notifications", value)


if not MYPY:
    class TextMatchingRulesetArgsDict(TypedDict):
        """
        Rules for detecting and blocking specific text patterns. If a file contains a text pattern that is part of the configured deny list, the file will be denied.
        """
        deny: NotRequired[pulumi.Input[Sequence[pulumi.Input['TextMatchArgsDict']]]]
        """
        A list of text patterns to block, each with matching rules and case sensitivity options.
        """
elif False:
    TextMatchingRulesetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TextMatchingRulesetArgs:
    def __init__(__self__, *,
                 deny: Optional[pulumi.Input[Sequence[pulumi.Input['TextMatchArgs']]]] = None):
        """
        Rules for detecting and blocking specific text patterns. If a file contains a text pattern that is part of the configured deny list, the file will be denied.
        :param pulumi.Input[Sequence[pulumi.Input['TextMatchArgs']]] deny: A list of text patterns to block, each with matching rules and case sensitivity options.
        """
        if deny is not None:
            pulumi.set(__self__, "deny", deny)

    @_builtins.property
    @pulumi.getter
    def deny(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TextMatchArgs']]]]:
        """
        A list of text patterns to block, each with matching rules and case sensitivity options.
        """
        return pulumi.get(self, "deny")

    @deny.setter
    def deny(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TextMatchArgs']]]]):
        pulumi.set(self, "deny", value)


if not MYPY:
    class TextMatchArgsDict(TypedDict):
        """
        Configuration options for the text matching ruleset. For example, if the configuration is to deny "hello world" for partial case-insensitive words then "chello worlds" would get detected and the resulting file would be denied.
        """
        case_sensitivity: pulumi.Input[Union[_builtins.str, 'Casing']]
        """
        Specifies the text matching conditions based on casing. For more detail please refer to the Casing model.
        """
        match_type: pulumi.Input[Union[_builtins.str, 'MatchType']]
        """
        Specifies the text matching condition for text comparison. For more detail please refer to the MatchType model.
        """
        text: pulumi.Input[_builtins.str]
        """
        The word or phrase to match against replicated content. A phrase with spaces will be considered a single substring.
        """
elif False:
    TextMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TextMatchArgs:
    def __init__(__self__, *,
                 case_sensitivity: Optional[pulumi.Input[Union[_builtins.str, 'Casing']]] = None,
                 match_type: Optional[pulumi.Input[Union[_builtins.str, 'MatchType']]] = None,
                 text: pulumi.Input[_builtins.str]):
        """
        Configuration options for the text matching ruleset. For example, if the configuration is to deny "hello world" for partial case-insensitive words then "chello worlds" would get detected and the resulting file would be denied.
        :param pulumi.Input[Union[_builtins.str, 'Casing']] case_sensitivity: Specifies the text matching conditions based on casing. For more detail please refer to the Casing model.
        :param pulumi.Input[Union[_builtins.str, 'MatchType']] match_type: Specifies the text matching condition for text comparison. For more detail please refer to the MatchType model.
        :param pulumi.Input[_builtins.str] text: The word or phrase to match against replicated content. A phrase with spaces will be considered a single substring.
        """
        if case_sensitivity is None:
            case_sensitivity = 'Insensitive'
        pulumi.set(__self__, "case_sensitivity", case_sensitivity)
        if match_type is None:
            match_type = 'Partial'
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="caseSensitivity")
    def case_sensitivity(self) -> pulumi.Input[Union[_builtins.str, 'Casing']]:
        """
        Specifies the text matching conditions based on casing. For more detail please refer to the Casing model.
        """
        return pulumi.get(self, "case_sensitivity")

    @case_sensitivity.setter
    def case_sensitivity(self, value: pulumi.Input[Union[_builtins.str, 'Casing']]):
        pulumi.set(self, "case_sensitivity", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> pulumi.Input[Union[_builtins.str, 'MatchType']]:
        """
        Specifies the text matching condition for text comparison. For more detail please refer to the MatchType model.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: pulumi.Input[Union[_builtins.str, 'MatchType']]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input[_builtins.str]:
        """
        The word or phrase to match against replicated content. A phrase with spaces will be considered a single substring.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text", value)


if not MYPY:
    class XmlFilterRulesetArgsDict(TypedDict):
        """
        Rules for filtering XML content using XSD schemas.
        """
        default_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default XML namespace used for schema validation.
        """
        reference: NotRequired[pulumi.Input[Union[_builtins.str, 'XmlReferenceType']]]
        """
        Defines the method for referencing the xml schema.
        """
        schema: NotRequired[pulumi.Input[_builtins.str]]
        """
        The inline XSD schema to be used for validation.
        """
elif False:
    XmlFilterRulesetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class XmlFilterRulesetArgs:
    def __init__(__self__, *,
                 default_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 reference: Optional[pulumi.Input[Union[_builtins.str, 'XmlReferenceType']]] = None,
                 schema: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Rules for filtering XML content using XSD schemas.
        :param pulumi.Input[_builtins.str] default_namespace: The default XML namespace used for schema validation.
        :param pulumi.Input[Union[_builtins.str, 'XmlReferenceType']] reference: Defines the method for referencing the xml schema.
        :param pulumi.Input[_builtins.str] schema: The inline XSD schema to be used for validation.
        """
        if default_namespace is not None:
            pulumi.set(__self__, "default_namespace", default_namespace)
        if reference is not None:
            pulumi.set(__self__, "reference", reference)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)

    @_builtins.property
    @pulumi.getter(name="defaultNamespace")
    def default_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default XML namespace used for schema validation.
        """
        return pulumi.get(self, "default_namespace")

    @default_namespace.setter
    def default_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_namespace", value)

    @_builtins.property
    @pulumi.getter
    def reference(self) -> Optional[pulumi.Input[Union[_builtins.str, 'XmlReferenceType']]]:
        """
        Defines the method for referencing the xml schema.
        """
        return pulumi.get(self, "reference")

    @reference.setter
    def reference(self, value: Optional[pulumi.Input[Union[_builtins.str, 'XmlReferenceType']]]):
        pulumi.set(self, "reference", value)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The inline XSD schema to be used for validation.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema", value)


