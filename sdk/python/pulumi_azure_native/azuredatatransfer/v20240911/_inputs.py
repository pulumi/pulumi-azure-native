# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'ConnectionPropertiesArgs',
    'ConnectionPropertiesArgsDict',
    'FlowPropertiesArgs',
    'FlowPropertiesArgsDict',
    'ManagedServiceIdentityArgs',
    'ManagedServiceIdentityArgsDict',
    'MessagingOptionsArgs',
    'MessagingOptionsArgsDict',
    'PipelinePropertiesArgs',
    'PipelinePropertiesArgsDict',
    'PlanArgs',
    'PlanArgsDict',
    'SchemaArgs',
    'SchemaArgsDict',
    'SelectedResourceArgs',
    'SelectedResourceArgsDict',
    'SubscriberArgs',
    'SubscriberArgsDict',
]

MYPY = False

if not MYPY:
    class ConnectionPropertiesArgsDict(TypedDict):
        """
        Properties of connection
        """
        pipeline: pulumi.Input[str]
        """
        Pipeline to use to transfer data
        """
        direction: NotRequired[pulumi.Input[Union[str, 'Direction']]]
        """
        Direction of data movement
        """
        flow_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'FlowType']]]]]
        """
        The flow types being requested for this connection
        """
        justification: NotRequired[pulumi.Input[str]]
        """
        Justification for the connection request
        """
        pin: NotRequired[pulumi.Input[str]]
        """
        PIN to link requests together
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The policies for this connection
        """
        primary_contact: NotRequired[pulumi.Input[str]]
        """
        The primary contact for this connection request
        """
        remote_subscription_id: NotRequired[pulumi.Input[str]]
        """
        Subscription ID to link cloud subscriptions together
        """
        requirement_id: NotRequired[pulumi.Input[str]]
        """
        Requirement ID of the connection
        """
        schema_uris: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The schema URIs for this connection
        """
        schemas: NotRequired[pulumi.Input[Sequence[pulumi.Input['SchemaArgsDict']]]]
        """
        The schemas for this connection
        """
        secondary_contacts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The secondary contacts for this connection request
        """
elif False:
    ConnectionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionPropertiesArgs:
    def __init__(__self__, *,
                 pipeline: pulumi.Input[str],
                 direction: Optional[pulumi.Input[Union[str, 'Direction']]] = None,
                 flow_types: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'FlowType']]]]] = None,
                 justification: Optional[pulumi.Input[str]] = None,
                 pin: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 primary_contact: Optional[pulumi.Input[str]] = None,
                 remote_subscription_id: Optional[pulumi.Input[str]] = None,
                 requirement_id: Optional[pulumi.Input[str]] = None,
                 schema_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 schemas: Optional[pulumi.Input[Sequence[pulumi.Input['SchemaArgs']]]] = None,
                 secondary_contacts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Properties of connection
        :param pulumi.Input[str] pipeline: Pipeline to use to transfer data
        :param pulumi.Input[Union[str, 'Direction']] direction: Direction of data movement
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'FlowType']]]] flow_types: The flow types being requested for this connection
        :param pulumi.Input[str] justification: Justification for the connection request
        :param pulumi.Input[str] pin: PIN to link requests together
        :param pulumi.Input[Sequence[pulumi.Input[str]]] policies: The policies for this connection
        :param pulumi.Input[str] primary_contact: The primary contact for this connection request
        :param pulumi.Input[str] remote_subscription_id: Subscription ID to link cloud subscriptions together
        :param pulumi.Input[str] requirement_id: Requirement ID of the connection
        :param pulumi.Input[Sequence[pulumi.Input[str]]] schema_uris: The schema URIs for this connection
        :param pulumi.Input[Sequence[pulumi.Input['SchemaArgs']]] schemas: The schemas for this connection
        :param pulumi.Input[Sequence[pulumi.Input[str]]] secondary_contacts: The secondary contacts for this connection request
        """
        pulumi.set(__self__, "pipeline", pipeline)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if flow_types is not None:
            pulumi.set(__self__, "flow_types", flow_types)
        if justification is not None:
            pulumi.set(__self__, "justification", justification)
        if pin is not None:
            pulumi.set(__self__, "pin", pin)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if primary_contact is not None:
            pulumi.set(__self__, "primary_contact", primary_contact)
        if remote_subscription_id is not None:
            pulumi.set(__self__, "remote_subscription_id", remote_subscription_id)
        if requirement_id is not None:
            pulumi.set(__self__, "requirement_id", requirement_id)
        if schema_uris is not None:
            pulumi.set(__self__, "schema_uris", schema_uris)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)
        if secondary_contacts is not None:
            pulumi.set(__self__, "secondary_contacts", secondary_contacts)

    @property
    @pulumi.getter
    def pipeline(self) -> pulumi.Input[str]:
        """
        Pipeline to use to transfer data
        """
        return pulumi.get(self, "pipeline")

    @pipeline.setter
    def pipeline(self, value: pulumi.Input[str]):
        pulumi.set(self, "pipeline", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[Union[str, 'Direction']]]:
        """
        Direction of data movement
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[Union[str, 'Direction']]]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter(name="flowTypes")
    def flow_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'FlowType']]]]]:
        """
        The flow types being requested for this connection
        """
        return pulumi.get(self, "flow_types")

    @flow_types.setter
    def flow_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'FlowType']]]]]):
        pulumi.set(self, "flow_types", value)

    @property
    @pulumi.getter
    def justification(self) -> Optional[pulumi.Input[str]]:
        """
        Justification for the connection request
        """
        return pulumi.get(self, "justification")

    @justification.setter
    def justification(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "justification", value)

    @property
    @pulumi.getter
    def pin(self) -> Optional[pulumi.Input[str]]:
        """
        PIN to link requests together
        """
        return pulumi.get(self, "pin")

    @pin.setter
    def pin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pin", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The policies for this connection
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter(name="primaryContact")
    def primary_contact(self) -> Optional[pulumi.Input[str]]:
        """
        The primary contact for this connection request
        """
        return pulumi.get(self, "primary_contact")

    @primary_contact.setter
    def primary_contact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_contact", value)

    @property
    @pulumi.getter(name="remoteSubscriptionId")
    def remote_subscription_id(self) -> Optional[pulumi.Input[str]]:
        """
        Subscription ID to link cloud subscriptions together
        """
        return pulumi.get(self, "remote_subscription_id")

    @remote_subscription_id.setter
    def remote_subscription_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_subscription_id", value)

    @property
    @pulumi.getter(name="requirementId")
    def requirement_id(self) -> Optional[pulumi.Input[str]]:
        """
        Requirement ID of the connection
        """
        return pulumi.get(self, "requirement_id")

    @requirement_id.setter
    def requirement_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requirement_id", value)

    @property
    @pulumi.getter(name="schemaUris")
    def schema_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The schema URIs for this connection
        """
        return pulumi.get(self, "schema_uris")

    @schema_uris.setter
    def schema_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "schema_uris", value)

    @property
    @pulumi.getter
    def schemas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SchemaArgs']]]]:
        """
        The schemas for this connection
        """
        return pulumi.get(self, "schemas")

    @schemas.setter
    def schemas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SchemaArgs']]]]):
        pulumi.set(self, "schemas", value)

    @property
    @pulumi.getter(name="secondaryContacts")
    def secondary_contacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The secondary contacts for this connection request
        """
        return pulumi.get(self, "secondary_contacts")

    @secondary_contacts.setter
    def secondary_contacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "secondary_contacts", value)


if not MYPY:
    class FlowPropertiesArgsDict(TypedDict):
        """
        Properties of flow
        """
        connection: NotRequired[pulumi.Input['SelectedResourceArgsDict']]
        """
        The connection associated with this flow
        """
        customer_managed_key_vault_uri: NotRequired[pulumi.Input[str]]
        """
        The URI to the customer managed key for this flow
        """
        data_type: NotRequired[pulumi.Input[Union[str, 'DataType']]]
        """
        Transfer Storage Blobs or Tables
        """
        flow_type: NotRequired[pulumi.Input[Union[str, 'FlowType']]]
        """
        The flow type for this flow
        """
        key_vault_uri: NotRequired[pulumi.Input[str]]
        """
        AME, PME, or TORUS only! AKV Chain Containing SAS Token
        """
        messaging_options: NotRequired[pulumi.Input['MessagingOptionsArgsDict']]
        """
        The messaging options for this flow
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The policies for this flow
        """
        schema: NotRequired[pulumi.Input['SchemaArgsDict']]
        """
        The selected schema for this flow
        """
        service_bus_queue_id: NotRequired[pulumi.Input[str]]
        """
        Service Bus Queue ID
        """
        status: NotRequired[pulumi.Input[Union[str, 'FlowStatus']]]
        """
        Status of the current flow
        """
        storage_account_id: NotRequired[pulumi.Input[str]]
        """
        Storage Account ID
        """
        storage_account_name: NotRequired[pulumi.Input[str]]
        """
        Storage Account
        """
        storage_container_name: NotRequired[pulumi.Input[str]]
        """
        Storage Container Name
        """
elif False:
    FlowPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowPropertiesArgs:
    def __init__(__self__, *,
                 connection: Optional[pulumi.Input['SelectedResourceArgs']] = None,
                 customer_managed_key_vault_uri: Optional[pulumi.Input[str]] = None,
                 data_type: Optional[pulumi.Input[Union[str, 'DataType']]] = None,
                 flow_type: Optional[pulumi.Input[Union[str, 'FlowType']]] = None,
                 key_vault_uri: Optional[pulumi.Input[str]] = None,
                 messaging_options: Optional[pulumi.Input['MessagingOptionsArgs']] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 schema: Optional[pulumi.Input['SchemaArgs']] = None,
                 service_bus_queue_id: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[Union[str, 'FlowStatus']]] = None,
                 storage_account_id: Optional[pulumi.Input[str]] = None,
                 storage_account_name: Optional[pulumi.Input[str]] = None,
                 storage_container_name: Optional[pulumi.Input[str]] = None):
        """
        Properties of flow
        :param pulumi.Input['SelectedResourceArgs'] connection: The connection associated with this flow
        :param pulumi.Input[str] customer_managed_key_vault_uri: The URI to the customer managed key for this flow
        :param pulumi.Input[Union[str, 'DataType']] data_type: Transfer Storage Blobs or Tables
        :param pulumi.Input[Union[str, 'FlowType']] flow_type: The flow type for this flow
        :param pulumi.Input[str] key_vault_uri: AME, PME, or TORUS only! AKV Chain Containing SAS Token
        :param pulumi.Input['MessagingOptionsArgs'] messaging_options: The messaging options for this flow
        :param pulumi.Input[Sequence[pulumi.Input[str]]] policies: The policies for this flow
        :param pulumi.Input['SchemaArgs'] schema: The selected schema for this flow
        :param pulumi.Input[str] service_bus_queue_id: Service Bus Queue ID
        :param pulumi.Input[Union[str, 'FlowStatus']] status: Status of the current flow
        :param pulumi.Input[str] storage_account_id: Storage Account ID
        :param pulumi.Input[str] storage_account_name: Storage Account
        :param pulumi.Input[str] storage_container_name: Storage Container Name
        """
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if customer_managed_key_vault_uri is not None:
            pulumi.set(__self__, "customer_managed_key_vault_uri", customer_managed_key_vault_uri)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if flow_type is not None:
            pulumi.set(__self__, "flow_type", flow_type)
        if key_vault_uri is not None:
            pulumi.set(__self__, "key_vault_uri", key_vault_uri)
        if messaging_options is not None:
            pulumi.set(__self__, "messaging_options", messaging_options)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if service_bus_queue_id is not None:
            pulumi.set(__self__, "service_bus_queue_id", service_bus_queue_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if storage_account_id is not None:
            pulumi.set(__self__, "storage_account_id", storage_account_id)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)
        if storage_container_name is not None:
            pulumi.set(__self__, "storage_container_name", storage_container_name)

    @property
    @pulumi.getter
    def connection(self) -> Optional[pulumi.Input['SelectedResourceArgs']]:
        """
        The connection associated with this flow
        """
        return pulumi.get(self, "connection")

    @connection.setter
    def connection(self, value: Optional[pulumi.Input['SelectedResourceArgs']]):
        pulumi.set(self, "connection", value)

    @property
    @pulumi.getter(name="customerManagedKeyVaultUri")
    def customer_managed_key_vault_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The URI to the customer managed key for this flow
        """
        return pulumi.get(self, "customer_managed_key_vault_uri")

    @customer_managed_key_vault_uri.setter
    def customer_managed_key_vault_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "customer_managed_key_vault_uri", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[Union[str, 'DataType']]]:
        """
        Transfer Storage Blobs or Tables
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[Union[str, 'DataType']]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter(name="flowType")
    def flow_type(self) -> Optional[pulumi.Input[Union[str, 'FlowType']]]:
        """
        The flow type for this flow
        """
        return pulumi.get(self, "flow_type")

    @flow_type.setter
    def flow_type(self, value: Optional[pulumi.Input[Union[str, 'FlowType']]]):
        pulumi.set(self, "flow_type", value)

    @property
    @pulumi.getter(name="keyVaultUri")
    def key_vault_uri(self) -> Optional[pulumi.Input[str]]:
        """
        AME, PME, or TORUS only! AKV Chain Containing SAS Token
        """
        return pulumi.get(self, "key_vault_uri")

    @key_vault_uri.setter
    def key_vault_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_vault_uri", value)

    @property
    @pulumi.getter(name="messagingOptions")
    def messaging_options(self) -> Optional[pulumi.Input['MessagingOptionsArgs']]:
        """
        The messaging options for this flow
        """
        return pulumi.get(self, "messaging_options")

    @messaging_options.setter
    def messaging_options(self, value: Optional[pulumi.Input['MessagingOptionsArgs']]):
        pulumi.set(self, "messaging_options", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The policies for this flow
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input['SchemaArgs']]:
        """
        The selected schema for this flow
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input['SchemaArgs']]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter(name="serviceBusQueueId")
    def service_bus_queue_id(self) -> Optional[pulumi.Input[str]]:
        """
        Service Bus Queue ID
        """
        return pulumi.get(self, "service_bus_queue_id")

    @service_bus_queue_id.setter
    def service_bus_queue_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_bus_queue_id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[str, 'FlowStatus']]]:
        """
        Status of the current flow
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[str, 'FlowStatus']]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="storageAccountId")
    def storage_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        Storage Account ID
        """
        return pulumi.get(self, "storage_account_id")

    @storage_account_id.setter
    def storage_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_id", value)

    @property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[pulumi.Input[str]]:
        """
        Storage Account
        """
        return pulumi.get(self, "storage_account_name")

    @storage_account_name.setter
    def storage_account_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_name", value)

    @property
    @pulumi.getter(name="storageContainerName")
    def storage_container_name(self) -> Optional[pulumi.Input[str]]:
        """
        Storage Container Name
        """
        return pulumi.get(self, "storage_container_name")

    @storage_container_name.setter
    def storage_container_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_container_name", value)


if not MYPY:
    class ManagedServiceIdentityArgsDict(TypedDict):
        """
        Managed service identity (system assigned and/or user assigned identities)
        """
        type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    ManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param pulumi.Input[Union[str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class MessagingOptionsArgsDict(TypedDict):
        """
        The option associated with messaging flows.
        """
        billing_tier: NotRequired[pulumi.Input[Union[str, 'FlowBillingTier']]]
        """
        Billing tier for this messaging flow
        """
elif False:
    MessagingOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MessagingOptionsArgs:
    def __init__(__self__, *,
                 billing_tier: Optional[pulumi.Input[Union[str, 'FlowBillingTier']]] = None):
        """
        The option associated with messaging flows.
        :param pulumi.Input[Union[str, 'FlowBillingTier']] billing_tier: Billing tier for this messaging flow
        """
        if billing_tier is not None:
            pulumi.set(__self__, "billing_tier", billing_tier)

    @property
    @pulumi.getter(name="billingTier")
    def billing_tier(self) -> Optional[pulumi.Input[Union[str, 'FlowBillingTier']]]:
        """
        Billing tier for this messaging flow
        """
        return pulumi.get(self, "billing_tier")

    @billing_tier.setter
    def billing_tier(self, value: Optional[pulumi.Input[Union[str, 'FlowBillingTier']]]):
        pulumi.set(self, "billing_tier", value)


if not MYPY:
    class PipelinePropertiesArgsDict(TypedDict):
        """
        Properties of pipeline
        """
        remote_cloud: pulumi.Input[str]
        """
        Remote cloud of the data to be transferred or received
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        Display name of this pipeline
        """
        flow_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'FlowType']]]]]
        """
        The flow types allowed for this pipeline
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The policies for this pipeline
        """
        subscribers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubscriberArgsDict']]]]
        """
        Subscribers of this resource
        """
elif False:
    PipelinePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelinePropertiesArgs:
    def __init__(__self__, *,
                 remote_cloud: pulumi.Input[str],
                 display_name: Optional[pulumi.Input[str]] = None,
                 flow_types: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'FlowType']]]]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subscribers: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriberArgs']]]] = None):
        """
        Properties of pipeline
        :param pulumi.Input[str] remote_cloud: Remote cloud of the data to be transferred or received
        :param pulumi.Input[str] display_name: Display name of this pipeline
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'FlowType']]]] flow_types: The flow types allowed for this pipeline
        :param pulumi.Input[Sequence[pulumi.Input[str]]] policies: The policies for this pipeline
        :param pulumi.Input[Sequence[pulumi.Input['SubscriberArgs']]] subscribers: Subscribers of this resource
        """
        pulumi.set(__self__, "remote_cloud", remote_cloud)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if flow_types is not None:
            pulumi.set(__self__, "flow_types", flow_types)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if subscribers is not None:
            pulumi.set(__self__, "subscribers", subscribers)

    @property
    @pulumi.getter(name="remoteCloud")
    def remote_cloud(self) -> pulumi.Input[str]:
        """
        Remote cloud of the data to be transferred or received
        """
        return pulumi.get(self, "remote_cloud")

    @remote_cloud.setter
    def remote_cloud(self, value: pulumi.Input[str]):
        pulumi.set(self, "remote_cloud", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Display name of this pipeline
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="flowTypes")
    def flow_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'FlowType']]]]]:
        """
        The flow types allowed for this pipeline
        """
        return pulumi.get(self, "flow_types")

    @flow_types.setter
    def flow_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'FlowType']]]]]):
        pulumi.set(self, "flow_types", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The policies for this pipeline
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter
    def subscribers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubscriberArgs']]]]:
        """
        Subscribers of this resource
        """
        return pulumi.get(self, "subscribers")

    @subscribers.setter
    def subscribers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriberArgs']]]]):
        pulumi.set(self, "subscribers", value)


if not MYPY:
    class PlanArgsDict(TypedDict):
        """
        Plan for the resource.
        """
        name: pulumi.Input[str]
        """
        A user defined name of the 3rd Party Artifact that is being procured.
        """
        product: pulumi.Input[str]
        """
        The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding. 
        """
        publisher: pulumi.Input[str]
        """
        The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
        """
        promotion_code: NotRequired[pulumi.Input[str]]
        """
        A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        The version of the desired product/artifact.
        """
elif False:
    PlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 product: pulumi.Input[str],
                 publisher: pulumi.Input[str],
                 promotion_code: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        Plan for the resource.
        :param pulumi.Input[str] name: A user defined name of the 3rd Party Artifact that is being procured.
        :param pulumi.Input[str] product: The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding. 
        :param pulumi.Input[str] publisher: The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
        :param pulumi.Input[str] promotion_code: A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
        :param pulumi.Input[str] version: The version of the desired product/artifact.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)
        if promotion_code is not None:
            pulumi.set(__self__, "promotion_code", promotion_code)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A user defined name of the 3rd Party Artifact that is being procured.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def product(self) -> pulumi.Input[str]:
        """
        The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding. 
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: pulumi.Input[str]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter(name="promotionCode")
    def promotion_code(self) -> Optional[pulumi.Input[str]]:
        """
        A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
        """
        return pulumi.get(self, "promotion_code")

    @promotion_code.setter
    def promotion_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "promotion_code", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the desired product/artifact.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class SchemaArgsDict(TypedDict):
        """
        The schema object.
        """
        connection_id: NotRequired[pulumi.Input[str]]
        """
        Connection ID associated with this schema
        """
        content: NotRequired[pulumi.Input[str]]
        """
        Content of the schema
        """
        direction: NotRequired[pulumi.Input[Union[str, 'SchemaDirection']]]
        """
        The direction of the schema.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        ID associated with this schema
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the schema
        """
        schema_type: NotRequired[pulumi.Input[Union[str, 'SchemaType']]]
        """
        The Schema Type
        """
        schema_uri: NotRequired[pulumi.Input[str]]
        """
        Uri containing SAS token for the zipped schema
        """
        status: NotRequired[pulumi.Input[Union[str, 'SchemaStatus']]]
        """
        Status of the schema
        """
elif False:
    SchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SchemaArgs:
    def __init__(__self__, *,
                 connection_id: Optional[pulumi.Input[str]] = None,
                 content: Optional[pulumi.Input[str]] = None,
                 direction: Optional[pulumi.Input[Union[str, 'SchemaDirection']]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 schema_type: Optional[pulumi.Input[Union[str, 'SchemaType']]] = None,
                 schema_uri: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[Union[str, 'SchemaStatus']]] = None):
        """
        The schema object.
        :param pulumi.Input[str] connection_id: Connection ID associated with this schema
        :param pulumi.Input[str] content: Content of the schema
        :param pulumi.Input[Union[str, 'SchemaDirection']] direction: The direction of the schema.
        :param pulumi.Input[str] id: ID associated with this schema
        :param pulumi.Input[str] name: Name of the schema
        :param pulumi.Input[Union[str, 'SchemaType']] schema_type: The Schema Type
        :param pulumi.Input[str] schema_uri: Uri containing SAS token for the zipped schema
        :param pulumi.Input[Union[str, 'SchemaStatus']] status: Status of the schema
        """
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schema_type is not None:
            pulumi.set(__self__, "schema_type", schema_type)
        if schema_uri is not None:
            pulumi.set(__self__, "schema_uri", schema_uri)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        Connection ID associated with this schema
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_id", value)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        Content of the schema
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[Union[str, 'SchemaDirection']]]:
        """
        The direction of the schema.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[Union[str, 'SchemaDirection']]]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID associated with this schema
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the schema
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="schemaType")
    def schema_type(self) -> Optional[pulumi.Input[Union[str, 'SchemaType']]]:
        """
        The Schema Type
        """
        return pulumi.get(self, "schema_type")

    @schema_type.setter
    def schema_type(self, value: Optional[pulumi.Input[Union[str, 'SchemaType']]]):
        pulumi.set(self, "schema_type", value)

    @property
    @pulumi.getter(name="schemaUri")
    def schema_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Uri containing SAS token for the zipped schema
        """
        return pulumi.get(self, "schema_uri")

    @schema_uri.setter
    def schema_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema_uri", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[str, 'SchemaStatus']]]:
        """
        Status of the schema
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[str, 'SchemaStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class SelectedResourceArgsDict(TypedDict):
        """
        A resource selected from ARM
        """
        id: pulumi.Input[str]
        """
        Id of the connection
        """
        location: NotRequired[pulumi.Input[str]]
        """
        Location of the connection
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the connection
        """
        subscription_name: NotRequired[pulumi.Input[str]]
        """
        Name of the subscription with the connection
        """
elif False:
    SelectedResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SelectedResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 location: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 subscription_name: Optional[pulumi.Input[str]] = None):
        """
        A resource selected from ARM
        :param pulumi.Input[str] id: Id of the connection
        :param pulumi.Input[str] location: Location of the connection
        :param pulumi.Input[str] name: Name of the connection
        :param pulumi.Input[str] subscription_name: Name of the subscription with the connection
        """
        pulumi.set(__self__, "id", id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if subscription_name is not None:
            pulumi.set(__self__, "subscription_name", subscription_name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Id of the connection
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        Location of the connection
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the connection
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="subscriptionName")
    def subscription_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the subscription with the connection
        """
        return pulumi.get(self, "subscription_name")

    @subscription_name.setter
    def subscription_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subscription_name", value)


if not MYPY:
    class SubscriberArgsDict(TypedDict):
        email: NotRequired[pulumi.Input[str]]
        """
        Email of the subscriber
        """
        notifications: NotRequired[pulumi.Input[float]]
        """
        Number specifying what notifications to receive
        """
elif False:
    SubscriberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriberArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[str]] = None,
                 notifications: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] email: Email of the subscriber
        :param pulumi.Input[float] notifications: Number specifying what notifications to receive
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if notifications is not None:
            pulumi.set(__self__, "notifications", notifications)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        Email of the subscriber
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def notifications(self) -> Optional[pulumi.Input[float]]:
        """
        Number specifying what notifications to receive
        """
        return pulumi.get(self, "notifications")

    @notifications.setter
    def notifications(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "notifications", value)


