# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'AuthCredentialArgs',
    'AuthCredentialArgsDict',
    'ExportPipelineTargetPropertiesArgs',
    'ExportPipelineTargetPropertiesArgsDict',
    'IdentityPropertiesArgs',
    'IdentityPropertiesArgsDict',
    'ImportPipelineSourcePropertiesArgs',
    'ImportPipelineSourcePropertiesArgsDict',
    'LoggingPropertiesArgs',
    'LoggingPropertiesArgsDict',
    'ParentPropertiesArgs',
    'ParentPropertiesArgsDict',
    'PipelineRunRequestArgs',
    'PipelineRunRequestArgsDict',
    'PipelineRunSourcePropertiesArgs',
    'PipelineRunSourcePropertiesArgsDict',
    'PipelineRunTargetPropertiesArgs',
    'PipelineRunTargetPropertiesArgsDict',
    'PipelineSourceTriggerPropertiesArgs',
    'PipelineSourceTriggerPropertiesArgsDict',
    'PipelineTriggerPropertiesArgs',
    'PipelineTriggerPropertiesArgsDict',
    'SyncPropertiesArgs',
    'SyncPropertiesArgsDict',
    'UserIdentityPropertiesArgs',
    'UserIdentityPropertiesArgsDict',
]

MYPY = False

if not MYPY:
    class AuthCredentialArgsDict(TypedDict):
        """
        Authentication credential stored for an upstream.
        """
        name: NotRequired[pulumi.Input[Union[str, 'CredentialName']]]
        """
        The name of the credential.
        """
        password_secret_identifier: NotRequired[pulumi.Input[str]]
        """
        KeyVault Secret URI for accessing the password.
        """
        username_secret_identifier: NotRequired[pulumi.Input[str]]
        """
        KeyVault Secret URI for accessing the username.
        """
elif False:
    AuthCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthCredentialArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[Union[str, 'CredentialName']]] = None,
                 password_secret_identifier: Optional[pulumi.Input[str]] = None,
                 username_secret_identifier: Optional[pulumi.Input[str]] = None):
        """
        Authentication credential stored for an upstream.
        :param pulumi.Input[Union[str, 'CredentialName']] name: The name of the credential.
        :param pulumi.Input[str] password_secret_identifier: KeyVault Secret URI for accessing the password.
        :param pulumi.Input[str] username_secret_identifier: KeyVault Secret URI for accessing the username.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password_secret_identifier is not None:
            pulumi.set(__self__, "password_secret_identifier", password_secret_identifier)
        if username_secret_identifier is not None:
            pulumi.set(__self__, "username_secret_identifier", username_secret_identifier)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[Union[str, 'CredentialName']]]:
        """
        The name of the credential.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[Union[str, 'CredentialName']]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="passwordSecretIdentifier")
    def password_secret_identifier(self) -> Optional[pulumi.Input[str]]:
        """
        KeyVault Secret URI for accessing the password.
        """
        return pulumi.get(self, "password_secret_identifier")

    @password_secret_identifier.setter
    def password_secret_identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password_secret_identifier", value)

    @property
    @pulumi.getter(name="usernameSecretIdentifier")
    def username_secret_identifier(self) -> Optional[pulumi.Input[str]]:
        """
        KeyVault Secret URI for accessing the username.
        """
        return pulumi.get(self, "username_secret_identifier")

    @username_secret_identifier.setter
    def username_secret_identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username_secret_identifier", value)


if not MYPY:
    class ExportPipelineTargetPropertiesArgsDict(TypedDict):
        """
        The properties of the export pipeline target.
        """
        key_vault_uri: pulumi.Input[str]
        """
        They key vault secret uri to obtain the target storage SAS token.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of target for the export pipeline.
        """
        uri: NotRequired[pulumi.Input[str]]
        """
        The target uri of the export pipeline.
        When 'AzureStorageBlob': "https://accountName.blob.core.windows.net/containerName/blobName"
        When 'AzureStorageBlobContainer':  "https://accountName.blob.core.windows.net/containerName"
        """
elif False:
    ExportPipelineTargetPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExportPipelineTargetPropertiesArgs:
    def __init__(__self__, *,
                 key_vault_uri: pulumi.Input[str],
                 type: Optional[pulumi.Input[str]] = None,
                 uri: Optional[pulumi.Input[str]] = None):
        """
        The properties of the export pipeline target.
        :param pulumi.Input[str] key_vault_uri: They key vault secret uri to obtain the target storage SAS token.
        :param pulumi.Input[str] type: The type of target for the export pipeline.
        :param pulumi.Input[str] uri: The target uri of the export pipeline.
               When 'AzureStorageBlob': "https://accountName.blob.core.windows.net/containerName/blobName"
               When 'AzureStorageBlobContainer':  "https://accountName.blob.core.windows.net/containerName"
        """
        pulumi.set(__self__, "key_vault_uri", key_vault_uri)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter(name="keyVaultUri")
    def key_vault_uri(self) -> pulumi.Input[str]:
        """
        They key vault secret uri to obtain the target storage SAS token.
        """
        return pulumi.get(self, "key_vault_uri")

    @key_vault_uri.setter
    def key_vault_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_uri", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of target for the export pipeline.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        """
        The target uri of the export pipeline.
        When 'AzureStorageBlob': "https://accountName.blob.core.windows.net/containerName/blobName"
        When 'AzureStorageBlobContainer':  "https://accountName.blob.core.windows.net/containerName"
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class IdentityPropertiesArgsDict(TypedDict):
        """
        Managed identity for the resource.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The principal ID of resource identity.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The tenant ID of resource.
        """
        type: NotRequired[pulumi.Input['ResourceIdentityType']]
        """
        The identity type.
        """
        user_assigned_identities: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['UserIdentityPropertiesArgsDict']]]]
        """
        The list of user identities associated with the resource. The user identity 
        dictionary key references will be ARM resource ids in the form: 
        '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/
            providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
elif False:
    IdentityPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityPropertiesArgs:
    def __init__(__self__, *,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input['ResourceIdentityType']] = None,
                 user_assigned_identities: Optional[pulumi.Input[Mapping[str, pulumi.Input['UserIdentityPropertiesArgs']]]] = None):
        """
        Managed identity for the resource.
        :param pulumi.Input[str] principal_id: The principal ID of resource identity.
        :param pulumi.Input[str] tenant_id: The tenant ID of resource.
        :param pulumi.Input['ResourceIdentityType'] type: The identity type.
        :param pulumi.Input[Mapping[str, pulumi.Input['UserIdentityPropertiesArgs']]] user_assigned_identities: The list of user identities associated with the resource. The user identity 
               dictionary key references will be ARM resource ids in the form: 
               '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/
                   providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The principal ID of resource identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The tenant ID of resource.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['ResourceIdentityType']]:
        """
        The identity type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['ResourceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['UserIdentityPropertiesArgs']]]]:
        """
        The list of user identities associated with the resource. The user identity 
        dictionary key references will be ARM resource ids in the form: 
        '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/
            providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['UserIdentityPropertiesArgs']]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class ImportPipelineSourcePropertiesArgsDict(TypedDict):
        """
        The properties of the import pipeline source.
        """
        key_vault_uri: pulumi.Input[str]
        """
        They key vault secret uri to obtain the source storage SAS token.
        """
        type: NotRequired[pulumi.Input[Union[str, 'PipelineSourceType']]]
        """
        The type of source for the import pipeline.
        """
        uri: NotRequired[pulumi.Input[str]]
        """
        The source uri of the import pipeline.
        When 'AzureStorageBlob': "https://accountName.blob.core.windows.net/containerName/blobName"
        When 'AzureStorageBlobContainer': "https://accountName.blob.core.windows.net/containerName"
        """
elif False:
    ImportPipelineSourcePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImportPipelineSourcePropertiesArgs:
    def __init__(__self__, *,
                 key_vault_uri: pulumi.Input[str],
                 type: Optional[pulumi.Input[Union[str, 'PipelineSourceType']]] = None,
                 uri: Optional[pulumi.Input[str]] = None):
        """
        The properties of the import pipeline source.
        :param pulumi.Input[str] key_vault_uri: They key vault secret uri to obtain the source storage SAS token.
        :param pulumi.Input[Union[str, 'PipelineSourceType']] type: The type of source for the import pipeline.
        :param pulumi.Input[str] uri: The source uri of the import pipeline.
               When 'AzureStorageBlob': "https://accountName.blob.core.windows.net/containerName/blobName"
               When 'AzureStorageBlobContainer': "https://accountName.blob.core.windows.net/containerName"
        """
        pulumi.set(__self__, "key_vault_uri", key_vault_uri)
        if type is None:
            type = 'AzureStorageBlobContainer'
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter(name="keyVaultUri")
    def key_vault_uri(self) -> pulumi.Input[str]:
        """
        They key vault secret uri to obtain the source storage SAS token.
        """
        return pulumi.get(self, "key_vault_uri")

    @key_vault_uri.setter
    def key_vault_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_uri", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'PipelineSourceType']]]:
        """
        The type of source for the import pipeline.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'PipelineSourceType']]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        """
        The source uri of the import pipeline.
        When 'AzureStorageBlob': "https://accountName.blob.core.windows.net/containerName/blobName"
        When 'AzureStorageBlobContainer': "https://accountName.blob.core.windows.net/containerName"
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class LoggingPropertiesArgsDict(TypedDict):
        """
        The logging properties of the connected registry.
        """
        audit_log_status: NotRequired[pulumi.Input[Union[str, 'AuditLogStatus']]]
        """
        Indicates whether audit logs are enabled on the connected registry.
        """
        log_level: NotRequired[pulumi.Input[Union[str, 'LogLevel']]]
        """
        The verbosity of logs persisted on the connected registry.
        """
elif False:
    LoggingPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoggingPropertiesArgs:
    def __init__(__self__, *,
                 audit_log_status: Optional[pulumi.Input[Union[str, 'AuditLogStatus']]] = None,
                 log_level: Optional[pulumi.Input[Union[str, 'LogLevel']]] = None):
        """
        The logging properties of the connected registry.
        :param pulumi.Input[Union[str, 'AuditLogStatus']] audit_log_status: Indicates whether audit logs are enabled on the connected registry.
        :param pulumi.Input[Union[str, 'LogLevel']] log_level: The verbosity of logs persisted on the connected registry.
        """
        if audit_log_status is None:
            audit_log_status = 'Disabled'
        if audit_log_status is not None:
            pulumi.set(__self__, "audit_log_status", audit_log_status)
        if log_level is None:
            log_level = 'Information'
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)

    @property
    @pulumi.getter(name="auditLogStatus")
    def audit_log_status(self) -> Optional[pulumi.Input[Union[str, 'AuditLogStatus']]]:
        """
        Indicates whether audit logs are enabled on the connected registry.
        """
        return pulumi.get(self, "audit_log_status")

    @audit_log_status.setter
    def audit_log_status(self, value: Optional[pulumi.Input[Union[str, 'AuditLogStatus']]]):
        pulumi.set(self, "audit_log_status", value)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[pulumi.Input[Union[str, 'LogLevel']]]:
        """
        The verbosity of logs persisted on the connected registry.
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[pulumi.Input[Union[str, 'LogLevel']]]):
        pulumi.set(self, "log_level", value)


if not MYPY:
    class ParentPropertiesArgsDict(TypedDict):
        """
        The properties of the connected registry parent.
        """
        sync_properties: pulumi.Input['SyncPropertiesArgsDict']
        """
        The sync properties of the connected registry with its parent.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The resource ID of the parent to which the connected registry will be associated.
        """
elif False:
    ParentPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ParentPropertiesArgs:
    def __init__(__self__, *,
                 sync_properties: pulumi.Input['SyncPropertiesArgs'],
                 id: Optional[pulumi.Input[str]] = None):
        """
        The properties of the connected registry parent.
        :param pulumi.Input['SyncPropertiesArgs'] sync_properties: The sync properties of the connected registry with its parent.
        :param pulumi.Input[str] id: The resource ID of the parent to which the connected registry will be associated.
        """
        pulumi.set(__self__, "sync_properties", sync_properties)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="syncProperties")
    def sync_properties(self) -> pulumi.Input['SyncPropertiesArgs']:
        """
        The sync properties of the connected registry with its parent.
        """
        return pulumi.get(self, "sync_properties")

    @sync_properties.setter
    def sync_properties(self, value: pulumi.Input['SyncPropertiesArgs']):
        pulumi.set(self, "sync_properties", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource ID of the parent to which the connected registry will be associated.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PipelineRunRequestArgsDict(TypedDict):
        """
        The request properties provided for a pipeline run.
        """
        artifacts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of source artifacts to be transferred by the pipeline. 
        Specify an image by repository ('hello-world'). This will use the 'latest' tag.
        Specify an image by tag ('hello-world:latest').
        Specify an image by sha256-based manifest digest ('hello-world@sha256:abc123').
        """
        catalog_digest: NotRequired[pulumi.Input[str]]
        """
        The digest of the tar used to transfer the artifacts.
        """
        pipeline_resource_id: NotRequired[pulumi.Input[str]]
        """
        The resource ID of the pipeline to run.
        """
        source: NotRequired[pulumi.Input['PipelineRunSourcePropertiesArgsDict']]
        """
        The source properties of the pipeline run.
        """
        target: NotRequired[pulumi.Input['PipelineRunTargetPropertiesArgsDict']]
        """
        The target properties of the pipeline run.
        """
elif False:
    PipelineRunRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineRunRequestArgs:
    def __init__(__self__, *,
                 artifacts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 catalog_digest: Optional[pulumi.Input[str]] = None,
                 pipeline_resource_id: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input['PipelineRunSourcePropertiesArgs']] = None,
                 target: Optional[pulumi.Input['PipelineRunTargetPropertiesArgs']] = None):
        """
        The request properties provided for a pipeline run.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] artifacts: List of source artifacts to be transferred by the pipeline. 
               Specify an image by repository ('hello-world'). This will use the 'latest' tag.
               Specify an image by tag ('hello-world:latest').
               Specify an image by sha256-based manifest digest ('hello-world@sha256:abc123').
        :param pulumi.Input[str] catalog_digest: The digest of the tar used to transfer the artifacts.
        :param pulumi.Input[str] pipeline_resource_id: The resource ID of the pipeline to run.
        :param pulumi.Input['PipelineRunSourcePropertiesArgs'] source: The source properties of the pipeline run.
        :param pulumi.Input['PipelineRunTargetPropertiesArgs'] target: The target properties of the pipeline run.
        """
        if artifacts is not None:
            pulumi.set(__self__, "artifacts", artifacts)
        if catalog_digest is not None:
            pulumi.set(__self__, "catalog_digest", catalog_digest)
        if pipeline_resource_id is not None:
            pulumi.set(__self__, "pipeline_resource_id", pipeline_resource_id)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def artifacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of source artifacts to be transferred by the pipeline. 
        Specify an image by repository ('hello-world'). This will use the 'latest' tag.
        Specify an image by tag ('hello-world:latest').
        Specify an image by sha256-based manifest digest ('hello-world@sha256:abc123').
        """
        return pulumi.get(self, "artifacts")

    @artifacts.setter
    def artifacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "artifacts", value)

    @property
    @pulumi.getter(name="catalogDigest")
    def catalog_digest(self) -> Optional[pulumi.Input[str]]:
        """
        The digest of the tar used to transfer the artifacts.
        """
        return pulumi.get(self, "catalog_digest")

    @catalog_digest.setter
    def catalog_digest(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog_digest", value)

    @property
    @pulumi.getter(name="pipelineResourceId")
    def pipeline_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource ID of the pipeline to run.
        """
        return pulumi.get(self, "pipeline_resource_id")

    @pipeline_resource_id.setter
    def pipeline_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pipeline_resource_id", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['PipelineRunSourcePropertiesArgs']]:
        """
        The source properties of the pipeline run.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['PipelineRunSourcePropertiesArgs']]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['PipelineRunTargetPropertiesArgs']]:
        """
        The target properties of the pipeline run.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['PipelineRunTargetPropertiesArgs']]):
        pulumi.set(self, "target", value)


if not MYPY:
    class PipelineRunSourcePropertiesArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the source.
        """
        type: NotRequired[pulumi.Input[Union[str, 'PipelineRunSourceType']]]
        """
        The type of the source.
        """
elif False:
    PipelineRunSourcePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineRunSourcePropertiesArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[Union[str, 'PipelineRunSourceType']]] = None):
        """
        :param pulumi.Input[str] name: The name of the source.
        :param pulumi.Input[Union[str, 'PipelineRunSourceType']] type: The type of the source.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is None:
            type = 'AzureStorageBlob'
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the source.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'PipelineRunSourceType']]]:
        """
        The type of the source.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'PipelineRunSourceType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PipelineRunTargetPropertiesArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the target.
        """
        type: NotRequired[pulumi.Input[Union[str, 'PipelineRunTargetType']]]
        """
        The type of the target.
        """
elif False:
    PipelineRunTargetPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineRunTargetPropertiesArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[Union[str, 'PipelineRunTargetType']]] = None):
        """
        :param pulumi.Input[str] name: The name of the target.
        :param pulumi.Input[Union[str, 'PipelineRunTargetType']] type: The type of the target.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is None:
            type = 'AzureStorageBlob'
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'PipelineRunTargetType']]]:
        """
        The type of the target.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'PipelineRunTargetType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PipelineSourceTriggerPropertiesArgsDict(TypedDict):
        status: pulumi.Input[Union[str, 'TriggerStatus']]
        """
        The current status of the source trigger.
        """
elif False:
    PipelineSourceTriggerPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineSourceTriggerPropertiesArgs:
    def __init__(__self__, *,
                 status: Optional[pulumi.Input[Union[str, 'TriggerStatus']]] = None):
        """
        :param pulumi.Input[Union[str, 'TriggerStatus']] status: The current status of the source trigger.
        """
        if status is None:
            status = 'Enabled'
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[Union[str, 'TriggerStatus']]:
        """
        The current status of the source trigger.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[Union[str, 'TriggerStatus']]):
        pulumi.set(self, "status", value)


if not MYPY:
    class PipelineTriggerPropertiesArgsDict(TypedDict):
        source_trigger: NotRequired[pulumi.Input['PipelineSourceTriggerPropertiesArgsDict']]
        """
        The source trigger properties of the pipeline.
        """
elif False:
    PipelineTriggerPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerPropertiesArgs:
    def __init__(__self__, *,
                 source_trigger: Optional[pulumi.Input['PipelineSourceTriggerPropertiesArgs']] = None):
        """
        :param pulumi.Input['PipelineSourceTriggerPropertiesArgs'] source_trigger: The source trigger properties of the pipeline.
        """
        if source_trigger is not None:
            pulumi.set(__self__, "source_trigger", source_trigger)

    @property
    @pulumi.getter(name="sourceTrigger")
    def source_trigger(self) -> Optional[pulumi.Input['PipelineSourceTriggerPropertiesArgs']]:
        """
        The source trigger properties of the pipeline.
        """
        return pulumi.get(self, "source_trigger")

    @source_trigger.setter
    def source_trigger(self, value: Optional[pulumi.Input['PipelineSourceTriggerPropertiesArgs']]):
        pulumi.set(self, "source_trigger", value)


if not MYPY:
    class SyncPropertiesArgsDict(TypedDict):
        """
        The sync properties of the connected registry with its parent.
        """
        message_ttl: pulumi.Input[str]
        """
        The period of time for which a message is available to sync before it is expired. Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as per ISO8601.
        """
        token_id: pulumi.Input[str]
        """
        The resource ID of the ACR token used to authenticate the connected registry to its parent during sync.
        """
        schedule: NotRequired[pulumi.Input[str]]
        """
        The cron expression indicating the schedule that the connected registry will sync with its parent.
        """
        sync_window: NotRequired[pulumi.Input[str]]
        """
        The time window during which sync is enabled for each schedule occurrence. Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as per ISO8601.
        """
elif False:
    SyncPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SyncPropertiesArgs:
    def __init__(__self__, *,
                 message_ttl: pulumi.Input[str],
                 token_id: pulumi.Input[str],
                 schedule: Optional[pulumi.Input[str]] = None,
                 sync_window: Optional[pulumi.Input[str]] = None):
        """
        The sync properties of the connected registry with its parent.
        :param pulumi.Input[str] message_ttl: The period of time for which a message is available to sync before it is expired. Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as per ISO8601.
        :param pulumi.Input[str] token_id: The resource ID of the ACR token used to authenticate the connected registry to its parent during sync.
        :param pulumi.Input[str] schedule: The cron expression indicating the schedule that the connected registry will sync with its parent.
        :param pulumi.Input[str] sync_window: The time window during which sync is enabled for each schedule occurrence. Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as per ISO8601.
        """
        pulumi.set(__self__, "message_ttl", message_ttl)
        pulumi.set(__self__, "token_id", token_id)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if sync_window is not None:
            pulumi.set(__self__, "sync_window", sync_window)

    @property
    @pulumi.getter(name="messageTtl")
    def message_ttl(self) -> pulumi.Input[str]:
        """
        The period of time for which a message is available to sync before it is expired. Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as per ISO8601.
        """
        return pulumi.get(self, "message_ttl")

    @message_ttl.setter
    def message_ttl(self, value: pulumi.Input[str]):
        pulumi.set(self, "message_ttl", value)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[str]:
        """
        The resource ID of the ACR token used to authenticate the connected registry to its parent during sync.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_id", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input[str]]:
        """
        The cron expression indicating the schedule that the connected registry will sync with its parent.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="syncWindow")
    def sync_window(self) -> Optional[pulumi.Input[str]]:
        """
        The time window during which sync is enabled for each schedule occurrence. Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as per ISO8601.
        """
        return pulumi.get(self, "sync_window")

    @sync_window.setter
    def sync_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sync_window", value)


if not MYPY:
    class UserIdentityPropertiesArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[str]]
        """
        The client id of user assigned identity.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        The principal id of user assigned identity.
        """
elif False:
    UserIdentityPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserIdentityPropertiesArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The client id of user assigned identity.
        :param pulumi.Input[str] principal_id: The principal id of user assigned identity.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The client id of user assigned identity.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The principal id of user assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)


