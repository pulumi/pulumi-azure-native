# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'DnsConfigArgs',
    'DnsConfigArgsDict',
    'EndpointPropertiesCustomHeadersArgs',
    'EndpointPropertiesCustomHeadersArgsDict',
    'EndpointPropertiesSubnetsArgs',
    'EndpointPropertiesSubnetsArgsDict',
    'EndpointArgs',
    'EndpointArgsDict',
    'MonitorConfigCustomHeadersArgs',
    'MonitorConfigCustomHeadersArgsDict',
    'MonitorConfigExpectedStatusCodeRangesArgs',
    'MonitorConfigExpectedStatusCodeRangesArgsDict',
    'MonitorConfigArgs',
    'MonitorConfigArgsDict',
]

MYPY = False

if not MYPY:
    class DnsConfigArgsDict(TypedDict):
        """
        Class containing DNS settings in a Traffic Manager profile.
        """
        relative_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The relative DNS name provided by this Traffic Manager profile. This value is combined with the DNS domain name used by Azure Traffic Manager to form the fully-qualified domain name (FQDN) of the profile.
        """
        ttl: NotRequired[pulumi.Input[builtins.float]]
        """
        The DNS Time-To-Live (TTL), in seconds. This informs the local DNS resolvers and DNS clients how long to cache DNS responses provided by this Traffic Manager profile.
        """
elif False:
    DnsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsConfigArgs:
    def __init__(__self__, *,
                 relative_name: Optional[pulumi.Input[builtins.str]] = None,
                 ttl: Optional[pulumi.Input[builtins.float]] = None):
        """
        Class containing DNS settings in a Traffic Manager profile.
        :param pulumi.Input[builtins.str] relative_name: The relative DNS name provided by this Traffic Manager profile. This value is combined with the DNS domain name used by Azure Traffic Manager to form the fully-qualified domain name (FQDN) of the profile.
        :param pulumi.Input[builtins.float] ttl: The DNS Time-To-Live (TTL), in seconds. This informs the local DNS resolvers and DNS clients how long to cache DNS responses provided by this Traffic Manager profile.
        """
        if relative_name is not None:
            pulumi.set(__self__, "relative_name", relative_name)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="relativeName")
    def relative_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The relative DNS name provided by this Traffic Manager profile. This value is combined with the DNS domain name used by Azure Traffic Manager to form the fully-qualified domain name (FQDN) of the profile.
        """
        return pulumi.get(self, "relative_name")

    @relative_name.setter
    def relative_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "relative_name", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The DNS Time-To-Live (TTL), in seconds. This informs the local DNS resolvers and DNS clients how long to cache DNS responses provided by this Traffic Manager profile.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class EndpointPropertiesCustomHeadersArgsDict(TypedDict):
        """
        Custom header name and value.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Header name.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Header value.
        """
elif False:
    EndpointPropertiesCustomHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointPropertiesCustomHeadersArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        Custom header name and value.
        :param pulumi.Input[builtins.str] name: Header name.
        :param pulumi.Input[builtins.str] value: Header value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Header name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Header value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EndpointPropertiesSubnetsArgsDict(TypedDict):
        """
        Subnet first address, scope, and/or last address.
        """
        first: NotRequired[pulumi.Input[builtins.str]]
        """
        First address in the subnet.
        """
        last: NotRequired[pulumi.Input[builtins.str]]
        """
        Last address in the subnet.
        """
        scope: NotRequired[pulumi.Input[builtins.int]]
        """
        Block size (number of leading bits in the subnet mask).
        """
elif False:
    EndpointPropertiesSubnetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointPropertiesSubnetsArgs:
    def __init__(__self__, *,
                 first: Optional[pulumi.Input[builtins.str]] = None,
                 last: Optional[pulumi.Input[builtins.str]] = None,
                 scope: Optional[pulumi.Input[builtins.int]] = None):
        """
        Subnet first address, scope, and/or last address.
        :param pulumi.Input[builtins.str] first: First address in the subnet.
        :param pulumi.Input[builtins.str] last: Last address in the subnet.
        :param pulumi.Input[builtins.int] scope: Block size (number of leading bits in the subnet mask).
        """
        if first is not None:
            pulumi.set(__self__, "first", first)
        if last is not None:
            pulumi.set(__self__, "last", last)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def first(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        First address in the subnet.
        """
        return pulumi.get(self, "first")

    @first.setter
    def first(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "first", value)

    @property
    @pulumi.getter
    def last(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last address in the subnet.
        """
        return pulumi.get(self, "last")

    @last.setter
    def last(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Block size (number of leading bits in the subnet mask).
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class EndpointArgsDict(TypedDict):
        """
        Class representing a Traffic Manager endpoint.
        """
        always_serve: NotRequired[pulumi.Input[Union[builtins.str, 'AlwaysServe']]]
        """
        If Always Serve is enabled, probing for endpoint health will be disabled and endpoints will be included in the traffic routing method.
        """
        custom_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['EndpointPropertiesCustomHeadersArgsDict']]]]
        """
        List of custom headers.
        """
        endpoint_location: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the location of the external or nested endpoints when using the 'Performance' traffic routing method.
        """
        endpoint_monitor_status: NotRequired[pulumi.Input[Union[builtins.str, 'EndpointMonitorStatus']]]
        """
        The monitoring status of the endpoint.
        """
        endpoint_status: NotRequired[pulumi.Input[Union[builtins.str, 'EndpointStatus']]]
        """
        The status of the endpoint. If the endpoint is Enabled, it is probed for endpoint health and is included in the traffic routing method.
        """
        geo_mapping: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of countries/regions mapped to this endpoint when using the 'Geographic' traffic routing method. Please consult Traffic Manager Geographic documentation for a full list of accepted values.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}
        """
        min_child_endpoints: NotRequired[pulumi.Input[builtins.float]]
        """
        The minimum number of endpoints that must be available in the child profile in order for the parent profile to be considered available. Only applicable to endpoint of type 'NestedEndpoints'.
        """
        min_child_endpoints_i_pv4: NotRequired[pulumi.Input[builtins.float]]
        """
        The minimum number of IPv4 (DNS record type A) endpoints that must be available in the child profile in order for the parent profile to be considered available. Only applicable to endpoint of type 'NestedEndpoints'.
        """
        min_child_endpoints_i_pv6: NotRequired[pulumi.Input[builtins.float]]
        """
        The minimum number of IPv6 (DNS record type AAAA) endpoints that must be available in the child profile in order for the parent profile to be considered available. Only applicable to endpoint of type 'NestedEndpoints'.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the resource
        """
        priority: NotRequired[pulumi.Input[builtins.float]]
        """
        The priority of this endpoint when using the 'Priority' traffic routing method. Possible values are from 1 to 1000, lower values represent higher priority. This is an optional parameter.  If specified, it must be specified on all endpoints, and no two endpoints can share the same priority value.
        """
        subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input['EndpointPropertiesSubnetsArgsDict']]]]
        """
        The list of subnets, IP addresses, and/or address ranges mapped to this endpoint when using the 'Subnet' traffic routing method. An empty list will match all ranges not covered by other endpoints.
        """
        target: NotRequired[pulumi.Input[builtins.str]]
        """
        The fully-qualified DNS name or IP address of the endpoint. Traffic Manager returns this value in DNS responses to direct traffic to this endpoint.
        """
        target_resource_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The Azure Resource URI of the of the endpoint. Not applicable to endpoints of type 'ExternalEndpoints'.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
        """
        weight: NotRequired[pulumi.Input[builtins.float]]
        """
        The weight of this endpoint when using the 'Weighted' traffic routing method. Possible values are from 1 to 1000.
        """
elif False:
    EndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointArgs:
    def __init__(__self__, *,
                 always_serve: Optional[pulumi.Input[Union[builtins.str, 'AlwaysServe']]] = None,
                 custom_headers: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointPropertiesCustomHeadersArgs']]]] = None,
                 endpoint_location: Optional[pulumi.Input[builtins.str]] = None,
                 endpoint_monitor_status: Optional[pulumi.Input[Union[builtins.str, 'EndpointMonitorStatus']]] = None,
                 endpoint_status: Optional[pulumi.Input[Union[builtins.str, 'EndpointStatus']]] = None,
                 geo_mapping: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 min_child_endpoints: Optional[pulumi.Input[builtins.float]] = None,
                 min_child_endpoints_i_pv4: Optional[pulumi.Input[builtins.float]] = None,
                 min_child_endpoints_i_pv6: Optional[pulumi.Input[builtins.float]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 priority: Optional[pulumi.Input[builtins.float]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointPropertiesSubnetsArgs']]]] = None,
                 target: Optional[pulumi.Input[builtins.str]] = None,
                 target_resource_id: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 weight: Optional[pulumi.Input[builtins.float]] = None):
        """
        Class representing a Traffic Manager endpoint.
        :param pulumi.Input[Union[builtins.str, 'AlwaysServe']] always_serve: If Always Serve is enabled, probing for endpoint health will be disabled and endpoints will be included in the traffic routing method.
        :param pulumi.Input[Sequence[pulumi.Input['EndpointPropertiesCustomHeadersArgs']]] custom_headers: List of custom headers.
        :param pulumi.Input[builtins.str] endpoint_location: Specifies the location of the external or nested endpoints when using the 'Performance' traffic routing method.
        :param pulumi.Input[Union[builtins.str, 'EndpointMonitorStatus']] endpoint_monitor_status: The monitoring status of the endpoint.
        :param pulumi.Input[Union[builtins.str, 'EndpointStatus']] endpoint_status: The status of the endpoint. If the endpoint is Enabled, it is probed for endpoint health and is included in the traffic routing method.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] geo_mapping: The list of countries/regions mapped to this endpoint when using the 'Geographic' traffic routing method. Please consult Traffic Manager Geographic documentation for a full list of accepted values.
        :param pulumi.Input[builtins.str] id: Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}
        :param pulumi.Input[builtins.float] min_child_endpoints: The minimum number of endpoints that must be available in the child profile in order for the parent profile to be considered available. Only applicable to endpoint of type 'NestedEndpoints'.
        :param pulumi.Input[builtins.float] min_child_endpoints_i_pv4: The minimum number of IPv4 (DNS record type A) endpoints that must be available in the child profile in order for the parent profile to be considered available. Only applicable to endpoint of type 'NestedEndpoints'.
        :param pulumi.Input[builtins.float] min_child_endpoints_i_pv6: The minimum number of IPv6 (DNS record type AAAA) endpoints that must be available in the child profile in order for the parent profile to be considered available. Only applicable to endpoint of type 'NestedEndpoints'.
        :param pulumi.Input[builtins.str] name: The name of the resource
        :param pulumi.Input[builtins.float] priority: The priority of this endpoint when using the 'Priority' traffic routing method. Possible values are from 1 to 1000, lower values represent higher priority. This is an optional parameter.  If specified, it must be specified on all endpoints, and no two endpoints can share the same priority value.
        :param pulumi.Input[Sequence[pulumi.Input['EndpointPropertiesSubnetsArgs']]] subnets: The list of subnets, IP addresses, and/or address ranges mapped to this endpoint when using the 'Subnet' traffic routing method. An empty list will match all ranges not covered by other endpoints.
        :param pulumi.Input[builtins.str] target: The fully-qualified DNS name or IP address of the endpoint. Traffic Manager returns this value in DNS responses to direct traffic to this endpoint.
        :param pulumi.Input[builtins.str] target_resource_id: The Azure Resource URI of the of the endpoint. Not applicable to endpoints of type 'ExternalEndpoints'.
        :param pulumi.Input[builtins.str] type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
        :param pulumi.Input[builtins.float] weight: The weight of this endpoint when using the 'Weighted' traffic routing method. Possible values are from 1 to 1000.
        """
        if always_serve is not None:
            pulumi.set(__self__, "always_serve", always_serve)
        if custom_headers is not None:
            pulumi.set(__self__, "custom_headers", custom_headers)
        if endpoint_location is not None:
            pulumi.set(__self__, "endpoint_location", endpoint_location)
        if endpoint_monitor_status is not None:
            pulumi.set(__self__, "endpoint_monitor_status", endpoint_monitor_status)
        if endpoint_status is not None:
            pulumi.set(__self__, "endpoint_status", endpoint_status)
        if geo_mapping is not None:
            pulumi.set(__self__, "geo_mapping", geo_mapping)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if min_child_endpoints is not None:
            pulumi.set(__self__, "min_child_endpoints", min_child_endpoints)
        if min_child_endpoints_i_pv4 is not None:
            pulumi.set(__self__, "min_child_endpoints_i_pv4", min_child_endpoints_i_pv4)
        if min_child_endpoints_i_pv6 is not None:
            pulumi.set(__self__, "min_child_endpoints_i_pv6", min_child_endpoints_i_pv6)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if target_resource_id is not None:
            pulumi.set(__self__, "target_resource_id", target_resource_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="alwaysServe")
    def always_serve(self) -> Optional[pulumi.Input[Union[builtins.str, 'AlwaysServe']]]:
        """
        If Always Serve is enabled, probing for endpoint health will be disabled and endpoints will be included in the traffic routing method.
        """
        return pulumi.get(self, "always_serve")

    @always_serve.setter
    def always_serve(self, value: Optional[pulumi.Input[Union[builtins.str, 'AlwaysServe']]]):
        pulumi.set(self, "always_serve", value)

    @property
    @pulumi.getter(name="customHeaders")
    def custom_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EndpointPropertiesCustomHeadersArgs']]]]:
        """
        List of custom headers.
        """
        return pulumi.get(self, "custom_headers")

    @custom_headers.setter
    def custom_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointPropertiesCustomHeadersArgs']]]]):
        pulumi.set(self, "custom_headers", value)

    @property
    @pulumi.getter(name="endpointLocation")
    def endpoint_location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the location of the external or nested endpoints when using the 'Performance' traffic routing method.
        """
        return pulumi.get(self, "endpoint_location")

    @endpoint_location.setter
    def endpoint_location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "endpoint_location", value)

    @property
    @pulumi.getter(name="endpointMonitorStatus")
    def endpoint_monitor_status(self) -> Optional[pulumi.Input[Union[builtins.str, 'EndpointMonitorStatus']]]:
        """
        The monitoring status of the endpoint.
        """
        return pulumi.get(self, "endpoint_monitor_status")

    @endpoint_monitor_status.setter
    def endpoint_monitor_status(self, value: Optional[pulumi.Input[Union[builtins.str, 'EndpointMonitorStatus']]]):
        pulumi.set(self, "endpoint_monitor_status", value)

    @property
    @pulumi.getter(name="endpointStatus")
    def endpoint_status(self) -> Optional[pulumi.Input[Union[builtins.str, 'EndpointStatus']]]:
        """
        The status of the endpoint. If the endpoint is Enabled, it is probed for endpoint health and is included in the traffic routing method.
        """
        return pulumi.get(self, "endpoint_status")

    @endpoint_status.setter
    def endpoint_status(self, value: Optional[pulumi.Input[Union[builtins.str, 'EndpointStatus']]]):
        pulumi.set(self, "endpoint_status", value)

    @property
    @pulumi.getter(name="geoMapping")
    def geo_mapping(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of countries/regions mapped to this endpoint when using the 'Geographic' traffic routing method. Please consult Traffic Manager Geographic documentation for a full list of accepted values.
        """
        return pulumi.get(self, "geo_mapping")

    @geo_mapping.setter
    def geo_mapping(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "geo_mapping", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="minChildEndpoints")
    def min_child_endpoints(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The minimum number of endpoints that must be available in the child profile in order for the parent profile to be considered available. Only applicable to endpoint of type 'NestedEndpoints'.
        """
        return pulumi.get(self, "min_child_endpoints")

    @min_child_endpoints.setter
    def min_child_endpoints(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "min_child_endpoints", value)

    @property
    @pulumi.getter(name="minChildEndpointsIPv4")
    def min_child_endpoints_i_pv4(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The minimum number of IPv4 (DNS record type A) endpoints that must be available in the child profile in order for the parent profile to be considered available. Only applicable to endpoint of type 'NestedEndpoints'.
        """
        return pulumi.get(self, "min_child_endpoints_i_pv4")

    @min_child_endpoints_i_pv4.setter
    def min_child_endpoints_i_pv4(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "min_child_endpoints_i_pv4", value)

    @property
    @pulumi.getter(name="minChildEndpointsIPv6")
    def min_child_endpoints_i_pv6(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The minimum number of IPv6 (DNS record type AAAA) endpoints that must be available in the child profile in order for the parent profile to be considered available. Only applicable to endpoint of type 'NestedEndpoints'.
        """
        return pulumi.get(self, "min_child_endpoints_i_pv6")

    @min_child_endpoints_i_pv6.setter
    def min_child_endpoints_i_pv6(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "min_child_endpoints_i_pv6", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The priority of this endpoint when using the 'Priority' traffic routing method. Possible values are from 1 to 1000, lower values represent higher priority. This is an optional parameter.  If specified, it must be specified on all endpoints, and no two endpoints can share the same priority value.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EndpointPropertiesSubnetsArgs']]]]:
        """
        The list of subnets, IP addresses, and/or address ranges mapped to this endpoint when using the 'Subnet' traffic routing method. An empty list will match all ranges not covered by other endpoints.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EndpointPropertiesSubnetsArgs']]]]):
        pulumi.set(self, "subnets", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The fully-qualified DNS name or IP address of the endpoint. Traffic Manager returns this value in DNS responses to direct traffic to this endpoint.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="targetResourceId")
    def target_resource_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Azure Resource URI of the of the endpoint. Not applicable to endpoints of type 'ExternalEndpoints'.
        """
        return pulumi.get(self, "target_resource_id")

    @target_resource_id.setter
    def target_resource_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "target_resource_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The weight of this endpoint when using the 'Weighted' traffic routing method. Possible values are from 1 to 1000.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class MonitorConfigCustomHeadersArgsDict(TypedDict):
        """
        Custom header name and value.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Header name.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Header value.
        """
elif False:
    MonitorConfigCustomHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorConfigCustomHeadersArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        Custom header name and value.
        :param pulumi.Input[builtins.str] name: Header name.
        :param pulumi.Input[builtins.str] value: Header value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Header name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Header value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MonitorConfigExpectedStatusCodeRangesArgsDict(TypedDict):
        """
        Min and max value of a status code range.
        """
        max: NotRequired[pulumi.Input[builtins.int]]
        """
        Max status code.
        """
        min: NotRequired[pulumi.Input[builtins.int]]
        """
        Min status code.
        """
elif False:
    MonitorConfigExpectedStatusCodeRangesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorConfigExpectedStatusCodeRangesArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[builtins.int]] = None,
                 min: Optional[pulumi.Input[builtins.int]] = None):
        """
        Min and max value of a status code range.
        :param pulumi.Input[builtins.int] max: Max status code.
        :param pulumi.Input[builtins.int] min: Min status code.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Max status code.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Min status code.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class MonitorConfigArgsDict(TypedDict):
        """
        Class containing endpoint monitoring settings in a Traffic Manager profile.
        """
        custom_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitorConfigCustomHeadersArgsDict']]]]
        """
        List of custom headers.
        """
        expected_status_code_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitorConfigExpectedStatusCodeRangesArgsDict']]]]
        """
        List of expected status code ranges.
        """
        interval_in_seconds: NotRequired[pulumi.Input[builtins.float]]
        """
        The monitor interval for endpoints in this profile. This is the interval at which Traffic Manager will check the health of each endpoint in this profile.
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        The path relative to the endpoint domain name used to probe for endpoint health.
        """
        port: NotRequired[pulumi.Input[builtins.float]]
        """
        The TCP port used to probe for endpoint health.
        """
        profile_monitor_status: NotRequired[pulumi.Input[Union[builtins.str, 'ProfileMonitorStatus']]]
        """
        The profile-level monitoring status of the Traffic Manager profile.
        """
        protocol: NotRequired[pulumi.Input[Union[builtins.str, 'MonitorProtocol']]]
        """
        The protocol (HTTP, HTTPS or TCP) used to probe for endpoint health.
        """
        timeout_in_seconds: NotRequired[pulumi.Input[builtins.float]]
        """
        The monitor timeout for endpoints in this profile. This is the time that Traffic Manager allows endpoints in this profile to response to the health check.
        """
        tolerated_number_of_failures: NotRequired[pulumi.Input[builtins.float]]
        """
        The number of consecutive failed health check that Traffic Manager tolerates before declaring an endpoint in this profile Degraded after the next failed health check.
        """
elif False:
    MonitorConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorConfigArgs:
    def __init__(__self__, *,
                 custom_headers: Optional[pulumi.Input[Sequence[pulumi.Input['MonitorConfigCustomHeadersArgs']]]] = None,
                 expected_status_code_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['MonitorConfigExpectedStatusCodeRangesArgs']]]] = None,
                 interval_in_seconds: Optional[pulumi.Input[builtins.float]] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.float]] = None,
                 profile_monitor_status: Optional[pulumi.Input[Union[builtins.str, 'ProfileMonitorStatus']]] = None,
                 protocol: Optional[pulumi.Input[Union[builtins.str, 'MonitorProtocol']]] = None,
                 timeout_in_seconds: Optional[pulumi.Input[builtins.float]] = None,
                 tolerated_number_of_failures: Optional[pulumi.Input[builtins.float]] = None):
        """
        Class containing endpoint monitoring settings in a Traffic Manager profile.
        :param pulumi.Input[Sequence[pulumi.Input['MonitorConfigCustomHeadersArgs']]] custom_headers: List of custom headers.
        :param pulumi.Input[Sequence[pulumi.Input['MonitorConfigExpectedStatusCodeRangesArgs']]] expected_status_code_ranges: List of expected status code ranges.
        :param pulumi.Input[builtins.float] interval_in_seconds: The monitor interval for endpoints in this profile. This is the interval at which Traffic Manager will check the health of each endpoint in this profile.
        :param pulumi.Input[builtins.str] path: The path relative to the endpoint domain name used to probe for endpoint health.
        :param pulumi.Input[builtins.float] port: The TCP port used to probe for endpoint health.
        :param pulumi.Input[Union[builtins.str, 'ProfileMonitorStatus']] profile_monitor_status: The profile-level monitoring status of the Traffic Manager profile.
        :param pulumi.Input[Union[builtins.str, 'MonitorProtocol']] protocol: The protocol (HTTP, HTTPS or TCP) used to probe for endpoint health.
        :param pulumi.Input[builtins.float] timeout_in_seconds: The monitor timeout for endpoints in this profile. This is the time that Traffic Manager allows endpoints in this profile to response to the health check.
        :param pulumi.Input[builtins.float] tolerated_number_of_failures: The number of consecutive failed health check that Traffic Manager tolerates before declaring an endpoint in this profile Degraded after the next failed health check.
        """
        if custom_headers is not None:
            pulumi.set(__self__, "custom_headers", custom_headers)
        if expected_status_code_ranges is not None:
            pulumi.set(__self__, "expected_status_code_ranges", expected_status_code_ranges)
        if interval_in_seconds is not None:
            pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if profile_monitor_status is not None:
            pulumi.set(__self__, "profile_monitor_status", profile_monitor_status)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if tolerated_number_of_failures is not None:
            pulumi.set(__self__, "tolerated_number_of_failures", tolerated_number_of_failures)

    @property
    @pulumi.getter(name="customHeaders")
    def custom_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitorConfigCustomHeadersArgs']]]]:
        """
        List of custom headers.
        """
        return pulumi.get(self, "custom_headers")

    @custom_headers.setter
    def custom_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitorConfigCustomHeadersArgs']]]]):
        pulumi.set(self, "custom_headers", value)

    @property
    @pulumi.getter(name="expectedStatusCodeRanges")
    def expected_status_code_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitorConfigExpectedStatusCodeRangesArgs']]]]:
        """
        List of expected status code ranges.
        """
        return pulumi.get(self, "expected_status_code_ranges")

    @expected_status_code_ranges.setter
    def expected_status_code_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitorConfigExpectedStatusCodeRangesArgs']]]]):
        pulumi.set(self, "expected_status_code_ranges", value)

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The monitor interval for endpoints in this profile. This is the interval at which Traffic Manager will check the health of each endpoint in this profile.
        """
        return pulumi.get(self, "interval_in_seconds")

    @interval_in_seconds.setter
    def interval_in_seconds(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "interval_in_seconds", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The path relative to the endpoint domain name used to probe for endpoint health.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The TCP port used to probe for endpoint health.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="profileMonitorStatus")
    def profile_monitor_status(self) -> Optional[pulumi.Input[Union[builtins.str, 'ProfileMonitorStatus']]]:
        """
        The profile-level monitoring status of the Traffic Manager profile.
        """
        return pulumi.get(self, "profile_monitor_status")

    @profile_monitor_status.setter
    def profile_monitor_status(self, value: Optional[pulumi.Input[Union[builtins.str, 'ProfileMonitorStatus']]]):
        pulumi.set(self, "profile_monitor_status", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[Union[builtins.str, 'MonitorProtocol']]]:
        """
        The protocol (HTTP, HTTPS or TCP) used to probe for endpoint health.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[Union[builtins.str, 'MonitorProtocol']]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The monitor timeout for endpoints in this profile. This is the time that Traffic Manager allows endpoints in this profile to response to the health check.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @timeout_in_seconds.setter
    def timeout_in_seconds(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "timeout_in_seconds", value)

    @property
    @pulumi.getter(name="toleratedNumberOfFailures")
    def tolerated_number_of_failures(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The number of consecutive failed health check that Traffic Manager tolerates before declaring an endpoint in this profile Degraded after the next failed health check.
        """
        return pulumi.get(self, "tolerated_number_of_failures")

    @tolerated_number_of_failures.setter
    def tolerated_number_of_failures(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "tolerated_number_of_failures", value)


