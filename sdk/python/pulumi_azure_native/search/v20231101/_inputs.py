# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'DataPlaneAadOrApiKeyAuthOptionArgs',
    'DataPlaneAadOrApiKeyAuthOptionArgsDict',
    'DataPlaneAuthOptionsArgs',
    'DataPlaneAuthOptionsArgsDict',
    'EncryptionWithCmkArgs',
    'EncryptionWithCmkArgsDict',
    'IdentityArgs',
    'IdentityArgsDict',
    'IpRuleArgs',
    'IpRuleArgsDict',
    'NetworkRuleSetArgs',
    'NetworkRuleSetArgsDict',
    'SkuArgs',
    'SkuArgsDict',
]

MYPY = False

if not MYPY:
    class DataPlaneAadOrApiKeyAuthOptionArgsDict(TypedDict):
        """
        Indicates that either the API key or an access token from a Microsoft Entra ID tenant can be used for authentication.
        """
        aad_auth_failure_mode: NotRequired[pulumi.Input['AadAuthFailureMode']]
        """
        Describes what response the data plane API of a search service would send for requests that failed authentication.
        """
elif False:
    DataPlaneAadOrApiKeyAuthOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataPlaneAadOrApiKeyAuthOptionArgs:
    def __init__(__self__, *,
                 aad_auth_failure_mode: Optional[pulumi.Input['AadAuthFailureMode']] = None):
        """
        Indicates that either the API key or an access token from a Microsoft Entra ID tenant can be used for authentication.
        :param pulumi.Input['AadAuthFailureMode'] aad_auth_failure_mode: Describes what response the data plane API of a search service would send for requests that failed authentication.
        """
        if aad_auth_failure_mode is not None:
            pulumi.set(__self__, "aad_auth_failure_mode", aad_auth_failure_mode)

    @property
    @pulumi.getter(name="aadAuthFailureMode")
    def aad_auth_failure_mode(self) -> Optional[pulumi.Input['AadAuthFailureMode']]:
        """
        Describes what response the data plane API of a search service would send for requests that failed authentication.
        """
        return pulumi.get(self, "aad_auth_failure_mode")

    @aad_auth_failure_mode.setter
    def aad_auth_failure_mode(self, value: Optional[pulumi.Input['AadAuthFailureMode']]):
        pulumi.set(self, "aad_auth_failure_mode", value)


if not MYPY:
    class DataPlaneAuthOptionsArgsDict(TypedDict):
        """
        Defines the options for how the search service authenticates a data plane request. This cannot be set if 'disableLocalAuth' is set to true.
        """
        aad_or_api_key: NotRequired[pulumi.Input['DataPlaneAadOrApiKeyAuthOptionArgsDict']]
        """
        Indicates that either the API key or an access token from a Microsoft Entra ID tenant can be used for authentication.
        """
        api_key_only: NotRequired[Any]
        """
        Indicates that only the API key can be used for authentication.
        """
elif False:
    DataPlaneAuthOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataPlaneAuthOptionsArgs:
    def __init__(__self__, *,
                 aad_or_api_key: Optional[pulumi.Input['DataPlaneAadOrApiKeyAuthOptionArgs']] = None,
                 api_key_only: Optional[Any] = None):
        """
        Defines the options for how the search service authenticates a data plane request. This cannot be set if 'disableLocalAuth' is set to true.
        :param pulumi.Input['DataPlaneAadOrApiKeyAuthOptionArgs'] aad_or_api_key: Indicates that either the API key or an access token from a Microsoft Entra ID tenant can be used for authentication.
        :param Any api_key_only: Indicates that only the API key can be used for authentication.
        """
        if aad_or_api_key is not None:
            pulumi.set(__self__, "aad_or_api_key", aad_or_api_key)
        if api_key_only is not None:
            pulumi.set(__self__, "api_key_only", api_key_only)

    @property
    @pulumi.getter(name="aadOrApiKey")
    def aad_or_api_key(self) -> Optional[pulumi.Input['DataPlaneAadOrApiKeyAuthOptionArgs']]:
        """
        Indicates that either the API key or an access token from a Microsoft Entra ID tenant can be used for authentication.
        """
        return pulumi.get(self, "aad_or_api_key")

    @aad_or_api_key.setter
    def aad_or_api_key(self, value: Optional[pulumi.Input['DataPlaneAadOrApiKeyAuthOptionArgs']]):
        pulumi.set(self, "aad_or_api_key", value)

    @property
    @pulumi.getter(name="apiKeyOnly")
    def api_key_only(self) -> Optional[Any]:
        """
        Indicates that only the API key can be used for authentication.
        """
        return pulumi.get(self, "api_key_only")

    @api_key_only.setter
    def api_key_only(self, value: Optional[Any]):
        pulumi.set(self, "api_key_only", value)


if not MYPY:
    class EncryptionWithCmkArgsDict(TypedDict):
        """
        Describes a policy that determines how resources within the search service are to be encrypted with customer=managed keys.
        """
        enforcement: NotRequired[pulumi.Input['SearchEncryptionWithCmk']]
        """
        Describes how a search service should enforce having one or more non-customer-encrypted resources.
        """
elif False:
    EncryptionWithCmkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EncryptionWithCmkArgs:
    def __init__(__self__, *,
                 enforcement: Optional[pulumi.Input['SearchEncryptionWithCmk']] = None):
        """
        Describes a policy that determines how resources within the search service are to be encrypted with customer=managed keys.
        :param pulumi.Input['SearchEncryptionWithCmk'] enforcement: Describes how a search service should enforce having one or more non-customer-encrypted resources.
        """
        if enforcement is not None:
            pulumi.set(__self__, "enforcement", enforcement)

    @property
    @pulumi.getter
    def enforcement(self) -> Optional[pulumi.Input['SearchEncryptionWithCmk']]:
        """
        Describes how a search service should enforce having one or more non-customer-encrypted resources.
        """
        return pulumi.get(self, "enforcement")

    @enforcement.setter
    def enforcement(self, value: Optional[pulumi.Input['SearchEncryptionWithCmk']]):
        pulumi.set(self, "enforcement", value)


if not MYPY:
    class IdentityArgsDict(TypedDict):
        """
        Identity for the resource.
        """
        type: pulumi.Input['IdentityType']
        """
        The identity type.
        """
elif False:
    IdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['IdentityType']):
        """
        Identity for the resource.
        :param pulumi.Input['IdentityType'] type: The identity type.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['IdentityType']:
        """
        The identity type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['IdentityType']):
        pulumi.set(self, "type", value)


if not MYPY:
    class IpRuleArgsDict(TypedDict):
        """
        The IP restriction rule of the search service.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value corresponding to a single IPv4 address (for example, 123.1.2.3) or an IP range in CIDR format (for example, 123.1.2.3/24) to be allowed.
        """
elif False:
    IpRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpRuleArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        The IP restriction rule of the search service.
        :param pulumi.Input[str] value: Value corresponding to a single IPv4 address (for example, 123.1.2.3) or an IP range in CIDR format (for example, 123.1.2.3/24) to be allowed.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value corresponding to a single IPv4 address (for example, 123.1.2.3) or an IP range in CIDR format (for example, 123.1.2.3/24) to be allowed.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NetworkRuleSetArgsDict(TypedDict):
        """
        Network-specific rules that determine how the search service can be reached.
        """
        ip_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['IpRuleArgsDict']]]]
        """
        A list of IP restriction rules used for an IP firewall. Any IPs that do not match the rules are blocked by the firewall. These rules are only applied when the 'publicNetworkAccess' of the search service is 'enabled'.
        """
elif False:
    NetworkRuleSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkRuleSetArgs:
    def __init__(__self__, *,
                 ip_rules: Optional[pulumi.Input[Sequence[pulumi.Input['IpRuleArgs']]]] = None):
        """
        Network-specific rules that determine how the search service can be reached.
        :param pulumi.Input[Sequence[pulumi.Input['IpRuleArgs']]] ip_rules: A list of IP restriction rules used for an IP firewall. Any IPs that do not match the rules are blocked by the firewall. These rules are only applied when the 'publicNetworkAccess' of the search service is 'enabled'.
        """
        if ip_rules is not None:
            pulumi.set(__self__, "ip_rules", ip_rules)

    @property
    @pulumi.getter(name="ipRules")
    def ip_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IpRuleArgs']]]]:
        """
        A list of IP restriction rules used for an IP firewall. Any IPs that do not match the rules are blocked by the firewall. These rules are only applied when the 'publicNetworkAccess' of the search service is 'enabled'.
        """
        return pulumi.get(self, "ip_rules")

    @ip_rules.setter
    def ip_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IpRuleArgs']]]]):
        pulumi.set(self, "ip_rules", value)


if not MYPY:
    class SkuArgsDict(TypedDict):
        """
        Defines the SKU of a search service, which determines billing rate and capacity limits.
        """
        name: NotRequired[pulumi.Input['SkuName']]
        """
        The SKU of the search service. Valid values include: 'free': Shared service. 'basic': Dedicated service with up to 3 replicas. 'standard': Dedicated service with up to 12 partitions and 12 replicas. 'standard2': Similar to standard, but with more capacity per search unit. 'standard3': The largest Standard offering with up to 12 partitions and 12 replicas (or up to 3 partitions with more indexes if you also set the hostingMode property to 'highDensity'). 'storage_optimized_l1': Supports 1TB per partition, up to 12 partitions. 'storage_optimized_l2': Supports 2TB per partition, up to 12 partitions.'
        """
elif False:
    SkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SkuArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input['SkuName']] = None):
        """
        Defines the SKU of a search service, which determines billing rate and capacity limits.
        :param pulumi.Input['SkuName'] name: The SKU of the search service. Valid values include: 'free': Shared service. 'basic': Dedicated service with up to 3 replicas. 'standard': Dedicated service with up to 12 partitions and 12 replicas. 'standard2': Similar to standard, but with more capacity per search unit. 'standard3': The largest Standard offering with up to 12 partitions and 12 replicas (or up to 3 partitions with more indexes if you also set the hostingMode property to 'highDensity'). 'storage_optimized_l1': Supports 1TB per partition, up to 12 partitions. 'storage_optimized_l2': Supports 2TB per partition, up to 12 partitions.'
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input['SkuName']]:
        """
        The SKU of the search service. Valid values include: 'free': Shared service. 'basic': Dedicated service with up to 3 replicas. 'standard': Dedicated service with up to 12 partitions and 12 replicas. 'standard2': Similar to standard, but with more capacity per search unit. 'standard3': The largest Standard offering with up to 12 partitions and 12 replicas (or up to 3 partitions with more indexes if you also set the hostingMode property to 'highDensity'). 'storage_optimized_l1': Supports 1TB per partition, up to 12 partitions. 'storage_optimized_l2': Supports 2TB per partition, up to 12 partitions.'
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input['SkuName']]):
        pulumi.set(self, "name", value)


