# coding=utf-8
# *** WARNING: this file was generated by pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AsymmetricEncryptedSecretResponse',
    'AuthenticationResponse',
    'FileSourceInfoResponse',
    'IoTDeviceInfoResponse',
    'MountPointMapResponse',
    'PeriodicTimerSourceInfoResponse',
    'RoleSinkInfoResponse',
    'ShareAccessRightResponse',
    'SymmetricKeyResponse',
]

@pulumi.output_type
class AsymmetricEncryptedSecretResponse(dict):
    """
    Represent the secrets intended for encryption with asymmetric key pair.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionAlgorithm":
            suggest = "encryption_algorithm"
        elif key == "encryptionCertThumbprint":
            suggest = "encryption_cert_thumbprint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AsymmetricEncryptedSecretResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AsymmetricEncryptedSecretResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AsymmetricEncryptedSecretResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_algorithm: str,
                 value: str,
                 encryption_cert_thumbprint: Optional[str] = None):
        """
        Represent the secrets intended for encryption with asymmetric key pair.
        :param str encryption_algorithm: The algorithm used to encrypt "Value".
        :param str value: The value of the secret.
        :param str encryption_cert_thumbprint: Thumbprint certificate used to encrypt \\"Value\\". If the value is unencrypted, it will be null.
        """
        pulumi.set(__self__, "encryption_algorithm", encryption_algorithm)
        pulumi.set(__self__, "value", value)
        if encryption_cert_thumbprint is not None:
            pulumi.set(__self__, "encryption_cert_thumbprint", encryption_cert_thumbprint)

    @property
    @pulumi.getter(name="encryptionAlgorithm")
    def encryption_algorithm(self) -> str:
        """
        The algorithm used to encrypt "Value".
        """
        return pulumi.get(self, "encryption_algorithm")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the secret.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="encryptionCertThumbprint")
    def encryption_cert_thumbprint(self) -> Optional[str]:
        """
        Thumbprint certificate used to encrypt \\"Value\\". If the value is unencrypted, it will be null.
        """
        return pulumi.get(self, "encryption_cert_thumbprint")


@pulumi.output_type
class AuthenticationResponse(dict):
    """
    Authentication mechanism for IoT devices.
    """
    def __init__(__self__, *,
                 symmetric_key: Optional['outputs.SymmetricKeyResponse'] = None):
        """
        Authentication mechanism for IoT devices.
        :param 'SymmetricKeyResponse' symmetric_key: Symmetric key for authentication.
        """
        if symmetric_key is not None:
            pulumi.set(__self__, "symmetric_key", symmetric_key)

    @property
    @pulumi.getter(name="symmetricKey")
    def symmetric_key(self) -> Optional['outputs.SymmetricKeyResponse']:
        """
        Symmetric key for authentication.
        """
        return pulumi.get(self, "symmetric_key")


@pulumi.output_type
class FileSourceInfoResponse(dict):
    """
    File source details.
    """
    def __init__(__self__, *,
                 share_id: str):
        """
        File source details.
        :param str share_id: File share ID.
        """
        pulumi.set(__self__, "share_id", share_id)

    @property
    @pulumi.getter(name="shareId")
    def share_id(self) -> str:
        """
        File share ID.
        """
        return pulumi.get(self, "share_id")


@pulumi.output_type
class IoTDeviceInfoResponse(dict):
    """
    Metadata of IoT device/IoT Edge device to be configured.
    """
    def __init__(__self__, *,
                 device_id: str,
                 io_t_host_hub: str,
                 authentication: Optional['outputs.AuthenticationResponse'] = None,
                 io_t_host_hub_id: Optional[str] = None):
        """
        Metadata of IoT device/IoT Edge device to be configured.
        :param str device_id: ID of the IoT device/edge device.
        :param str io_t_host_hub: Host name for the IoT hub associated to the device.
        :param 'AuthenticationResponse' authentication: IoT device authentication info.
        :param str io_t_host_hub_id: Id of the IoT hub associated to the device.
        """
        pulumi.set(__self__, "device_id", device_id)
        pulumi.set(__self__, "io_t_host_hub", io_t_host_hub)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if io_t_host_hub_id is not None:
            pulumi.set(__self__, "io_t_host_hub_id", io_t_host_hub_id)

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> str:
        """
        ID of the IoT device/edge device.
        """
        return pulumi.get(self, "device_id")

    @property
    @pulumi.getter(name="ioTHostHub")
    def io_t_host_hub(self) -> str:
        """
        Host name for the IoT hub associated to the device.
        """
        return pulumi.get(self, "io_t_host_hub")

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.AuthenticationResponse']:
        """
        IoT device authentication info.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="ioTHostHubId")
    def io_t_host_hub_id(self) -> Optional[str]:
        """
        Id of the IoT hub associated to the device.
        """
        return pulumi.get(self, "io_t_host_hub_id")


@pulumi.output_type
class MountPointMapResponse(dict):
    """
    The share mount point.
    """
    def __init__(__self__, *,
                 mount_point: str,
                 role_id: str,
                 role_type: str,
                 share_id: str):
        """
        The share mount point.
        :param str mount_point: Mount point for the share.
        :param str role_id: ID of the role to which share is mounted.
        :param str role_type: Role type.
        :param str share_id: ID of the share mounted to the role VM.
        """
        pulumi.set(__self__, "mount_point", mount_point)
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "role_type", role_type)
        pulumi.set(__self__, "share_id", share_id)

    @property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> str:
        """
        Mount point for the share.
        """
        return pulumi.get(self, "mount_point")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        """
        ID of the role to which share is mounted.
        """
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="roleType")
    def role_type(self) -> str:
        """
        Role type.
        """
        return pulumi.get(self, "role_type")

    @property
    @pulumi.getter(name="shareId")
    def share_id(self) -> str:
        """
        ID of the share mounted to the role VM.
        """
        return pulumi.get(self, "share_id")


@pulumi.output_type
class PeriodicTimerSourceInfoResponse(dict):
    """
    Periodic timer event source.
    """
    def __init__(__self__, *,
                 schedule: str,
                 start_time: str,
                 topic: Optional[str] = None):
        """
        Periodic timer event source.
        :param str schedule: Periodic frequency at which timer event needs to be raised. Supports daily, hourly, minutes, and seconds.
        :param str start_time: The time of the day that results in a valid trigger. Schedule is computed with reference to the time specified upto seconds. If timezone is not specified the time will considered to be in device timezone. The value will always be returned as UTC time.
        :param str topic: Topic where periodic events are published to IoT device.
        """
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "start_time", start_time)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter
    def schedule(self) -> str:
        """
        Periodic frequency at which timer event needs to be raised. Supports daily, hourly, minutes, and seconds.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        The time of the day that results in a valid trigger. Schedule is computed with reference to the time specified upto seconds. If timezone is not specified the time will considered to be in device timezone. The value will always be returned as UTC time.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def topic(self) -> Optional[str]:
        """
        Topic where periodic events are published to IoT device.
        """
        return pulumi.get(self, "topic")


@pulumi.output_type
class RoleSinkInfoResponse(dict):
    """
    Compute role against which events will be raised.
    """
    def __init__(__self__, *,
                 role_id: str):
        """
        Compute role against which events will be raised.
        :param str role_id: Compute role ID.
        """
        pulumi.set(__self__, "role_id", role_id)

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        """
        Compute role ID.
        """
        return pulumi.get(self, "role_id")


@pulumi.output_type
class ShareAccessRightResponse(dict):
    """
    Specifies the mapping between this particular user and the type of access he has on shares on this device.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessType":
            suggest = "access_type"
        elif key == "shareId":
            suggest = "share_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ShareAccessRightResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ShareAccessRightResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ShareAccessRightResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_type: str,
                 share_id: str):
        """
        Specifies the mapping between this particular user and the type of access he has on shares on this device.
        :param str access_type: Type of access to be allowed on the share for this user.
        :param str share_id: The share ID.
        """
        pulumi.set(__self__, "access_type", access_type)
        pulumi.set(__self__, "share_id", share_id)

    @property
    @pulumi.getter(name="accessType")
    def access_type(self) -> str:
        """
        Type of access to be allowed on the share for this user.
        """
        return pulumi.get(self, "access_type")

    @property
    @pulumi.getter(name="shareId")
    def share_id(self) -> str:
        """
        The share ID.
        """
        return pulumi.get(self, "share_id")


@pulumi.output_type
class SymmetricKeyResponse(dict):
    """
    Symmetric key for authentication.
    """
    def __init__(__self__, *,
                 connection_string: Optional['outputs.AsymmetricEncryptedSecretResponse'] = None):
        """
        Symmetric key for authentication.
        :param 'AsymmetricEncryptedSecretResponse' connection_string: Connection string based on the symmetric key.
        """
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional['outputs.AsymmetricEncryptedSecretResponse']:
        """
        Connection string based on the symmetric key.
        """
        return pulumi.get(self, "connection_string")


