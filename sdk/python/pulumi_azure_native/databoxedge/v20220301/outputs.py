# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AddressResponse',
    'AsymmetricEncryptedSecretResponse',
    'AuthenticationResponse',
    'AzureContainerInfoResponse',
    'ClientAccessRightResponse',
    'ContactDetailsResponse',
    'DataResidencyResponse',
    'EdgeProfileResponse',
    'EdgeProfileSubscriptionResponse',
    'IoTDeviceInfoResponse',
    'MetricConfigurationResponse',
    'MetricCounterResponse',
    'MetricCounterSetResponse',
    'MetricDimensionResponse',
    'MountPointMapResponse',
    'OrderStatusResponse',
    'RefreshDetailsResponse',
    'ResourceIdentityResponse',
    'ResourceMoveDetailsResponse',
    'SecretResponse',
    'ShareAccessRightResponse',
    'SkuResponse',
    'SubscriptionRegisteredFeaturesResponse',
    'SymmetricKeyResponse',
    'SystemDataResponse',
    'TrackingInfoResponse',
    'UserAccessRightResponse',
]

@pulumi.output_type
class AddressResponse(dict):
    """
    The shipping address of the customer.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressLine1":
            suggest = "address_line1"
        elif key == "addressLine2":
            suggest = "address_line2"
        elif key == "addressLine3":
            suggest = "address_line3"
        elif key == "postalCode":
            suggest = "postal_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AddressResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AddressResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AddressResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country: str,
                 address_line1: Optional[str] = None,
                 address_line2: Optional[str] = None,
                 address_line3: Optional[str] = None,
                 city: Optional[str] = None,
                 postal_code: Optional[str] = None,
                 state: Optional[str] = None):
        """
        The shipping address of the customer.
        :param str country: The country name.
        :param str address_line1: The address line1.
        :param str address_line2: The address line2.
        :param str address_line3: The address line3.
        :param str city: The city name.
        :param str postal_code: The postal code.
        :param str state: The state name.
        """
        AddressResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            country=country,
            address_line1=address_line1,
            address_line2=address_line2,
            address_line3=address_line3,
            city=city,
            postal_code=postal_code,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             country: Optional[str] = None,
             address_line1: Optional[str] = None,
             address_line2: Optional[str] = None,
             address_line3: Optional[str] = None,
             city: Optional[str] = None,
             postal_code: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if country is None:
            raise TypeError("Missing 'country' argument")
        if address_line1 is None and 'addressLine1' in kwargs:
            address_line1 = kwargs['addressLine1']
        if address_line2 is None and 'addressLine2' in kwargs:
            address_line2 = kwargs['addressLine2']
        if address_line3 is None and 'addressLine3' in kwargs:
            address_line3 = kwargs['addressLine3']
        if postal_code is None and 'postalCode' in kwargs:
            postal_code = kwargs['postalCode']

        _setter("country", country)
        if address_line1 is not None:
            _setter("address_line1", address_line1)
        if address_line2 is not None:
            _setter("address_line2", address_line2)
        if address_line3 is not None:
            _setter("address_line3", address_line3)
        if city is not None:
            _setter("city", city)
        if postal_code is not None:
            _setter("postal_code", postal_code)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter
    def country(self) -> str:
        """
        The country name.
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter(name="addressLine1")
    def address_line1(self) -> Optional[str]:
        """
        The address line1.
        """
        return pulumi.get(self, "address_line1")

    @property
    @pulumi.getter(name="addressLine2")
    def address_line2(self) -> Optional[str]:
        """
        The address line2.
        """
        return pulumi.get(self, "address_line2")

    @property
    @pulumi.getter(name="addressLine3")
    def address_line3(self) -> Optional[str]:
        """
        The address line3.
        """
        return pulumi.get(self, "address_line3")

    @property
    @pulumi.getter
    def city(self) -> Optional[str]:
        """
        The city name.
        """
        return pulumi.get(self, "city")

    @property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[str]:
        """
        The postal code.
        """
        return pulumi.get(self, "postal_code")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The state name.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class AsymmetricEncryptedSecretResponse(dict):
    """
    Represent the secrets intended for encryption with asymmetric key pair.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionAlgorithm":
            suggest = "encryption_algorithm"
        elif key == "encryptionCertThumbprint":
            suggest = "encryption_cert_thumbprint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AsymmetricEncryptedSecretResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AsymmetricEncryptedSecretResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AsymmetricEncryptedSecretResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_algorithm: str,
                 value: str,
                 encryption_cert_thumbprint: Optional[str] = None):
        """
        Represent the secrets intended for encryption with asymmetric key pair.
        :param str encryption_algorithm: The algorithm used to encrypt "Value".
        :param str value: The value of the secret.
        :param str encryption_cert_thumbprint: Thumbprint certificate used to encrypt \\"Value\\". If the value is unencrypted, it will be null.
        """
        AsymmetricEncryptedSecretResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            encryption_algorithm=encryption_algorithm,
            value=value,
            encryption_cert_thumbprint=encryption_cert_thumbprint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             encryption_algorithm: Optional[str] = None,
             value: Optional[str] = None,
             encryption_cert_thumbprint: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if encryption_algorithm is None and 'encryptionAlgorithm' in kwargs:
            encryption_algorithm = kwargs['encryptionAlgorithm']
        if encryption_algorithm is None:
            raise TypeError("Missing 'encryption_algorithm' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")
        if encryption_cert_thumbprint is None and 'encryptionCertThumbprint' in kwargs:
            encryption_cert_thumbprint = kwargs['encryptionCertThumbprint']

        _setter("encryption_algorithm", encryption_algorithm)
        _setter("value", value)
        if encryption_cert_thumbprint is not None:
            _setter("encryption_cert_thumbprint", encryption_cert_thumbprint)

    @property
    @pulumi.getter(name="encryptionAlgorithm")
    def encryption_algorithm(self) -> str:
        """
        The algorithm used to encrypt "Value".
        """
        return pulumi.get(self, "encryption_algorithm")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the secret.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="encryptionCertThumbprint")
    def encryption_cert_thumbprint(self) -> Optional[str]:
        """
        Thumbprint certificate used to encrypt \\"Value\\". If the value is unencrypted, it will be null.
        """
        return pulumi.get(self, "encryption_cert_thumbprint")


@pulumi.output_type
class AuthenticationResponse(dict):
    """
    Authentication mechanism for IoT devices.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "symmetricKey":
            suggest = "symmetric_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 symmetric_key: Optional['outputs.SymmetricKeyResponse'] = None):
        """
        Authentication mechanism for IoT devices.
        :param 'SymmetricKeyResponse' symmetric_key: Symmetric key for authentication.
        """
        AuthenticationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            symmetric_key=symmetric_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             symmetric_key: Optional['outputs.SymmetricKeyResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if symmetric_key is None and 'symmetricKey' in kwargs:
            symmetric_key = kwargs['symmetricKey']

        if symmetric_key is not None:
            _setter("symmetric_key", symmetric_key)

    @property
    @pulumi.getter(name="symmetricKey")
    def symmetric_key(self) -> Optional['outputs.SymmetricKeyResponse']:
        """
        Symmetric key for authentication.
        """
        return pulumi.get(self, "symmetric_key")


@pulumi.output_type
class AzureContainerInfoResponse(dict):
    """
    Azure container mapping of the endpoint.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerName":
            suggest = "container_name"
        elif key == "dataFormat":
            suggest = "data_format"
        elif key == "storageAccountCredentialId":
            suggest = "storage_account_credential_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureContainerInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureContainerInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureContainerInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_name: str,
                 data_format: str,
                 storage_account_credential_id: str):
        """
        Azure container mapping of the endpoint.
        :param str container_name: Container name (Based on the data format specified, this represents the name of Azure Files/Page blob/Block blob).
        :param str data_format: Storage format used for the file represented by the share.
        :param str storage_account_credential_id: ID of the storage account credential used to access storage.
        """
        AzureContainerInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            container_name=container_name,
            data_format=data_format,
            storage_account_credential_id=storage_account_credential_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             container_name: Optional[str] = None,
             data_format: Optional[str] = None,
             storage_account_credential_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if container_name is None and 'containerName' in kwargs:
            container_name = kwargs['containerName']
        if container_name is None:
            raise TypeError("Missing 'container_name' argument")
        if data_format is None and 'dataFormat' in kwargs:
            data_format = kwargs['dataFormat']
        if data_format is None:
            raise TypeError("Missing 'data_format' argument")
        if storage_account_credential_id is None and 'storageAccountCredentialId' in kwargs:
            storage_account_credential_id = kwargs['storageAccountCredentialId']
        if storage_account_credential_id is None:
            raise TypeError("Missing 'storage_account_credential_id' argument")

        _setter("container_name", container_name)
        _setter("data_format", data_format)
        _setter("storage_account_credential_id", storage_account_credential_id)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        """
        Container name (Based on the data format specified, this represents the name of Azure Files/Page blob/Block blob).
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter(name="dataFormat")
    def data_format(self) -> str:
        """
        Storage format used for the file represented by the share.
        """
        return pulumi.get(self, "data_format")

    @property
    @pulumi.getter(name="storageAccountCredentialId")
    def storage_account_credential_id(self) -> str:
        """
        ID of the storage account credential used to access storage.
        """
        return pulumi.get(self, "storage_account_credential_id")


@pulumi.output_type
class ClientAccessRightResponse(dict):
    """
    The mapping between a particular client IP and the type of access client has on the NFS share.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessPermission":
            suggest = "access_permission"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientAccessRightResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientAccessRightResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientAccessRightResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_permission: str,
                 client: str):
        """
        The mapping between a particular client IP and the type of access client has on the NFS share.
        :param str access_permission: Type of access to be allowed for the client.
        :param str client: IP of the client.
        """
        ClientAccessRightResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_permission=access_permission,
            client=client,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_permission: Optional[str] = None,
             client: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if access_permission is None and 'accessPermission' in kwargs:
            access_permission = kwargs['accessPermission']
        if access_permission is None:
            raise TypeError("Missing 'access_permission' argument")
        if client is None:
            raise TypeError("Missing 'client' argument")

        _setter("access_permission", access_permission)
        _setter("client", client)

    @property
    @pulumi.getter(name="accessPermission")
    def access_permission(self) -> str:
        """
        Type of access to be allowed for the client.
        """
        return pulumi.get(self, "access_permission")

    @property
    @pulumi.getter
    def client(self) -> str:
        """
        IP of the client.
        """
        return pulumi.get(self, "client")


@pulumi.output_type
class ContactDetailsResponse(dict):
    """
    Contains all the contact details of the customer.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "companyName":
            suggest = "company_name"
        elif key == "contactPerson":
            suggest = "contact_person"
        elif key == "emailList":
            suggest = "email_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContactDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContactDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContactDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 company_name: str,
                 contact_person: str,
                 email_list: Sequence[str],
                 phone: str):
        """
        Contains all the contact details of the customer.
        :param str company_name: The name of the company.
        :param str contact_person: The contact person name.
        :param Sequence[str] email_list: The email list.
        :param str phone: The phone number.
        """
        ContactDetailsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            company_name=company_name,
            contact_person=contact_person,
            email_list=email_list,
            phone=phone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             company_name: Optional[str] = None,
             contact_person: Optional[str] = None,
             email_list: Optional[Sequence[str]] = None,
             phone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if company_name is None and 'companyName' in kwargs:
            company_name = kwargs['companyName']
        if company_name is None:
            raise TypeError("Missing 'company_name' argument")
        if contact_person is None and 'contactPerson' in kwargs:
            contact_person = kwargs['contactPerson']
        if contact_person is None:
            raise TypeError("Missing 'contact_person' argument")
        if email_list is None and 'emailList' in kwargs:
            email_list = kwargs['emailList']
        if email_list is None:
            raise TypeError("Missing 'email_list' argument")
        if phone is None:
            raise TypeError("Missing 'phone' argument")

        _setter("company_name", company_name)
        _setter("contact_person", contact_person)
        _setter("email_list", email_list)
        _setter("phone", phone)

    @property
    @pulumi.getter(name="companyName")
    def company_name(self) -> str:
        """
        The name of the company.
        """
        return pulumi.get(self, "company_name")

    @property
    @pulumi.getter(name="contactPerson")
    def contact_person(self) -> str:
        """
        The contact person name.
        """
        return pulumi.get(self, "contact_person")

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Sequence[str]:
        """
        The email list.
        """
        return pulumi.get(self, "email_list")

    @property
    @pulumi.getter
    def phone(self) -> str:
        """
        The phone number.
        """
        return pulumi.get(self, "phone")


@pulumi.output_type
class DataResidencyResponse(dict):
    """
    Wraps data-residency related information for edge-resource and this should be used with ARM layer.
    """
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        Wraps data-residency related information for edge-resource and this should be used with ARM layer.
        :param str type: DataResidencyType enum
        """
        DataResidencyResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        DataResidencyType enum
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EdgeProfileResponse(dict):
    """
    Details about Edge Profile for the resource
    """
    def __init__(__self__, *,
                 subscription: Optional['outputs.EdgeProfileSubscriptionResponse'] = None):
        """
        Details about Edge Profile for the resource
        :param 'EdgeProfileSubscriptionResponse' subscription: Edge Profile Subscription
        """
        EdgeProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subscription=subscription,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subscription: Optional['outputs.EdgeProfileSubscriptionResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if subscription is not None:
            _setter("subscription", subscription)

    @property
    @pulumi.getter
    def subscription(self) -> Optional['outputs.EdgeProfileSubscriptionResponse']:
        """
        Edge Profile Subscription
        """
        return pulumi.get(self, "subscription")


@pulumi.output_type
class EdgeProfileSubscriptionResponse(dict):
    """
    Subscription details for the Edge Profile
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "locationPlacementId":
            suggest = "location_placement_id"
        elif key == "quotaId":
            suggest = "quota_id"
        elif key == "registeredFeatures":
            suggest = "registered_features"
        elif key == "registrationDate":
            suggest = "registration_date"
        elif key == "registrationId":
            suggest = "registration_id"
        elif key == "serializedDetails":
            suggest = "serialized_details"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EdgeProfileSubscriptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EdgeProfileSubscriptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EdgeProfileSubscriptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 location_placement_id: Optional[str] = None,
                 quota_id: Optional[str] = None,
                 registered_features: Optional[Sequence['outputs.SubscriptionRegisteredFeaturesResponse']] = None,
                 registration_date: Optional[str] = None,
                 registration_id: Optional[str] = None,
                 serialized_details: Optional[str] = None,
                 state: Optional[str] = None,
                 subscription_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        Subscription details for the Edge Profile
        :param str id: ARM ID of the subscription
        :param str registration_id: Edge Subscription Registration ID
        """
        EdgeProfileSubscriptionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            location_placement_id=location_placement_id,
            quota_id=quota_id,
            registered_features=registered_features,
            registration_date=registration_date,
            registration_id=registration_id,
            serialized_details=serialized_details,
            state=state,
            subscription_id=subscription_id,
            tenant_id=tenant_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             location_placement_id: Optional[str] = None,
             quota_id: Optional[str] = None,
             registered_features: Optional[Sequence['outputs.SubscriptionRegisteredFeaturesResponse']] = None,
             registration_date: Optional[str] = None,
             registration_id: Optional[str] = None,
             serialized_details: Optional[str] = None,
             state: Optional[str] = None,
             subscription_id: Optional[str] = None,
             tenant_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if location_placement_id is None and 'locationPlacementId' in kwargs:
            location_placement_id = kwargs['locationPlacementId']
        if quota_id is None and 'quotaId' in kwargs:
            quota_id = kwargs['quotaId']
        if registered_features is None and 'registeredFeatures' in kwargs:
            registered_features = kwargs['registeredFeatures']
        if registration_date is None and 'registrationDate' in kwargs:
            registration_date = kwargs['registrationDate']
        if registration_id is None and 'registrationId' in kwargs:
            registration_id = kwargs['registrationId']
        if serialized_details is None and 'serializedDetails' in kwargs:
            serialized_details = kwargs['serializedDetails']
        if subscription_id is None and 'subscriptionId' in kwargs:
            subscription_id = kwargs['subscriptionId']
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']

        if id is not None:
            _setter("id", id)
        if location_placement_id is not None:
            _setter("location_placement_id", location_placement_id)
        if quota_id is not None:
            _setter("quota_id", quota_id)
        if registered_features is not None:
            _setter("registered_features", registered_features)
        if registration_date is not None:
            _setter("registration_date", registration_date)
        if registration_id is not None:
            _setter("registration_id", registration_id)
        if serialized_details is not None:
            _setter("serialized_details", serialized_details)
        if state is not None:
            _setter("state", state)
        if subscription_id is not None:
            _setter("subscription_id", subscription_id)
        if tenant_id is not None:
            _setter("tenant_id", tenant_id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ARM ID of the subscription
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="locationPlacementId")
    def location_placement_id(self) -> Optional[str]:
        return pulumi.get(self, "location_placement_id")

    @property
    @pulumi.getter(name="quotaId")
    def quota_id(self) -> Optional[str]:
        return pulumi.get(self, "quota_id")

    @property
    @pulumi.getter(name="registeredFeatures")
    def registered_features(self) -> Optional[Sequence['outputs.SubscriptionRegisteredFeaturesResponse']]:
        return pulumi.get(self, "registered_features")

    @property
    @pulumi.getter(name="registrationDate")
    def registration_date(self) -> Optional[str]:
        return pulumi.get(self, "registration_date")

    @property
    @pulumi.getter(name="registrationId")
    def registration_id(self) -> Optional[str]:
        """
        Edge Subscription Registration ID
        """
        return pulumi.get(self, "registration_id")

    @property
    @pulumi.getter(name="serializedDetails")
    def serialized_details(self) -> Optional[str]:
        return pulumi.get(self, "serialized_details")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class IoTDeviceInfoResponse(dict):
    """
    Metadata of IoT device/IoT Edge device to be configured.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceId":
            suggest = "device_id"
        elif key == "ioTHostHub":
            suggest = "io_t_host_hub"
        elif key == "ioTHostHubId":
            suggest = "io_t_host_hub_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IoTDeviceInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IoTDeviceInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IoTDeviceInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_id: str,
                 io_t_host_hub: str,
                 authentication: Optional['outputs.AuthenticationResponse'] = None,
                 io_t_host_hub_id: Optional[str] = None):
        """
        Metadata of IoT device/IoT Edge device to be configured.
        :param str device_id: ID of the IoT device/edge device.
        :param str io_t_host_hub: Host name for the IoT hub associated to the device.
        :param 'AuthenticationResponse' authentication: Encrypted IoT device/IoT edge device connection string.
        :param str io_t_host_hub_id: Id for the IoT hub associated to the device.
        """
        IoTDeviceInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_id=device_id,
            io_t_host_hub=io_t_host_hub,
            authentication=authentication,
            io_t_host_hub_id=io_t_host_hub_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_id: Optional[str] = None,
             io_t_host_hub: Optional[str] = None,
             authentication: Optional['outputs.AuthenticationResponse'] = None,
             io_t_host_hub_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if device_id is None and 'deviceId' in kwargs:
            device_id = kwargs['deviceId']
        if device_id is None:
            raise TypeError("Missing 'device_id' argument")
        if io_t_host_hub is None and 'ioTHostHub' in kwargs:
            io_t_host_hub = kwargs['ioTHostHub']
        if io_t_host_hub is None:
            raise TypeError("Missing 'io_t_host_hub' argument")
        if io_t_host_hub_id is None and 'ioTHostHubId' in kwargs:
            io_t_host_hub_id = kwargs['ioTHostHubId']

        _setter("device_id", device_id)
        _setter("io_t_host_hub", io_t_host_hub)
        if authentication is not None:
            _setter("authentication", authentication)
        if io_t_host_hub_id is not None:
            _setter("io_t_host_hub_id", io_t_host_hub_id)

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> str:
        """
        ID of the IoT device/edge device.
        """
        return pulumi.get(self, "device_id")

    @property
    @pulumi.getter(name="ioTHostHub")
    def io_t_host_hub(self) -> str:
        """
        Host name for the IoT hub associated to the device.
        """
        return pulumi.get(self, "io_t_host_hub")

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.AuthenticationResponse']:
        """
        Encrypted IoT device/IoT edge device connection string.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="ioTHostHubId")
    def io_t_host_hub_id(self) -> Optional[str]:
        """
        Id for the IoT hub associated to the device.
        """
        return pulumi.get(self, "io_t_host_hub_id")


@pulumi.output_type
class MetricConfigurationResponse(dict):
    """
    Metric configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "counterSets":
            suggest = "counter_sets"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "mdmAccount":
            suggest = "mdm_account"
        elif key == "metricNameSpace":
            suggest = "metric_name_space"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 counter_sets: Sequence['outputs.MetricCounterSetResponse'],
                 resource_id: str,
                 mdm_account: Optional[str] = None,
                 metric_name_space: Optional[str] = None):
        """
        Metric configuration.
        :param Sequence['MetricCounterSetResponse'] counter_sets: Host name for the IoT hub associated to the device.
        :param str resource_id: The Resource ID on which the metrics should be pushed.
        :param str mdm_account: The MDM account to which the counters should be pushed.
        :param str metric_name_space: The MDM namespace to which the counters should be pushed. This is required if MDMAccount is specified
        """
        MetricConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            counter_sets=counter_sets,
            resource_id=resource_id,
            mdm_account=mdm_account,
            metric_name_space=metric_name_space,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             counter_sets: Optional[Sequence['outputs.MetricCounterSetResponse']] = None,
             resource_id: Optional[str] = None,
             mdm_account: Optional[str] = None,
             metric_name_space: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if counter_sets is None and 'counterSets' in kwargs:
            counter_sets = kwargs['counterSets']
        if counter_sets is None:
            raise TypeError("Missing 'counter_sets' argument")
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if resource_id is None:
            raise TypeError("Missing 'resource_id' argument")
        if mdm_account is None and 'mdmAccount' in kwargs:
            mdm_account = kwargs['mdmAccount']
        if metric_name_space is None and 'metricNameSpace' in kwargs:
            metric_name_space = kwargs['metricNameSpace']

        _setter("counter_sets", counter_sets)
        _setter("resource_id", resource_id)
        if mdm_account is not None:
            _setter("mdm_account", mdm_account)
        if metric_name_space is not None:
            _setter("metric_name_space", metric_name_space)

    @property
    @pulumi.getter(name="counterSets")
    def counter_sets(self) -> Sequence['outputs.MetricCounterSetResponse']:
        """
        Host name for the IoT hub associated to the device.
        """
        return pulumi.get(self, "counter_sets")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        """
        The Resource ID on which the metrics should be pushed.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="mdmAccount")
    def mdm_account(self) -> Optional[str]:
        """
        The MDM account to which the counters should be pushed.
        """
        return pulumi.get(self, "mdm_account")

    @property
    @pulumi.getter(name="metricNameSpace")
    def metric_name_space(self) -> Optional[str]:
        """
        The MDM namespace to which the counters should be pushed. This is required if MDMAccount is specified
        """
        return pulumi.get(self, "metric_name_space")


@pulumi.output_type
class MetricCounterResponse(dict):
    """
    The metric counter
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalDimensions":
            suggest = "additional_dimensions"
        elif key == "dimensionFilter":
            suggest = "dimension_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricCounterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricCounterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricCounterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 additional_dimensions: Optional[Sequence['outputs.MetricDimensionResponse']] = None,
                 dimension_filter: Optional[Sequence['outputs.MetricDimensionResponse']] = None,
                 instance: Optional[str] = None):
        """
        The metric counter
        :param str name: The counter name.
        :param Sequence['MetricDimensionResponse'] additional_dimensions: The additional dimensions to be added to metric.
        :param Sequence['MetricDimensionResponse'] dimension_filter: The dimension filter.
        :param str instance: The instance from which counter should be collected.
        """
        MetricCounterResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            additional_dimensions=additional_dimensions,
            dimension_filter=dimension_filter,
            instance=instance,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             additional_dimensions: Optional[Sequence['outputs.MetricDimensionResponse']] = None,
             dimension_filter: Optional[Sequence['outputs.MetricDimensionResponse']] = None,
             instance: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if additional_dimensions is None and 'additionalDimensions' in kwargs:
            additional_dimensions = kwargs['additionalDimensions']
        if dimension_filter is None and 'dimensionFilter' in kwargs:
            dimension_filter = kwargs['dimensionFilter']

        _setter("name", name)
        if additional_dimensions is not None:
            _setter("additional_dimensions", additional_dimensions)
        if dimension_filter is not None:
            _setter("dimension_filter", dimension_filter)
        if instance is not None:
            _setter("instance", instance)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The counter name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="additionalDimensions")
    def additional_dimensions(self) -> Optional[Sequence['outputs.MetricDimensionResponse']]:
        """
        The additional dimensions to be added to metric.
        """
        return pulumi.get(self, "additional_dimensions")

    @property
    @pulumi.getter(name="dimensionFilter")
    def dimension_filter(self) -> Optional[Sequence['outputs.MetricDimensionResponse']]:
        """
        The dimension filter.
        """
        return pulumi.get(self, "dimension_filter")

    @property
    @pulumi.getter
    def instance(self) -> Optional[str]:
        """
        The instance from which counter should be collected.
        """
        return pulumi.get(self, "instance")


@pulumi.output_type
class MetricCounterSetResponse(dict):
    """
    The metric counter set
    """
    def __init__(__self__, *,
                 counters: Sequence['outputs.MetricCounterResponse']):
        """
        The metric counter set
        :param Sequence['MetricCounterResponse'] counters: The counters that should be collected in this set.
        """
        MetricCounterSetResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            counters=counters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             counters: Optional[Sequence['outputs.MetricCounterResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if counters is None:
            raise TypeError("Missing 'counters' argument")

        _setter("counters", counters)

    @property
    @pulumi.getter
    def counters(self) -> Sequence['outputs.MetricCounterResponse']:
        """
        The counters that should be collected in this set.
        """
        return pulumi.get(self, "counters")


@pulumi.output_type
class MetricDimensionResponse(dict):
    """
    The metric dimension
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceName":
            suggest = "source_name"
        elif key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricDimensionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricDimensionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricDimensionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_name: str,
                 source_type: str):
        """
        The metric dimension
        :param str source_name: The dimension value.
        :param str source_type: The dimension type.
        """
        MetricDimensionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_name=source_name,
            source_type=source_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_name: Optional[str] = None,
             source_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if source_name is None and 'sourceName' in kwargs:
            source_name = kwargs['sourceName']
        if source_name is None:
            raise TypeError("Missing 'source_name' argument")
        if source_type is None and 'sourceType' in kwargs:
            source_type = kwargs['sourceType']
        if source_type is None:
            raise TypeError("Missing 'source_type' argument")

        _setter("source_name", source_name)
        _setter("source_type", source_type)

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> str:
        """
        The dimension value.
        """
        return pulumi.get(self, "source_name")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        The dimension type.
        """
        return pulumi.get(self, "source_type")


@pulumi.output_type
class MountPointMapResponse(dict):
    """
    The share mount point.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountPoint":
            suggest = "mount_point"
        elif key == "mountType":
            suggest = "mount_type"
        elif key == "roleId":
            suggest = "role_id"
        elif key == "roleType":
            suggest = "role_type"
        elif key == "shareId":
            suggest = "share_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MountPointMapResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MountPointMapResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MountPointMapResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_point: str,
                 mount_type: str,
                 role_id: str,
                 role_type: str,
                 share_id: str):
        """
        The share mount point.
        :param str mount_point: Mount point for the share.
        :param str mount_type: Mounting type.
        :param str role_id: ID of the role to which share is mounted.
        :param str role_type: Role type.
        :param str share_id: ID of the share mounted to the role VM.
        """
        MountPointMapResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mount_point=mount_point,
            mount_type=mount_type,
            role_id=role_id,
            role_type=role_type,
            share_id=share_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mount_point: Optional[str] = None,
             mount_type: Optional[str] = None,
             role_id: Optional[str] = None,
             role_type: Optional[str] = None,
             share_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mount_point is None and 'mountPoint' in kwargs:
            mount_point = kwargs['mountPoint']
        if mount_point is None:
            raise TypeError("Missing 'mount_point' argument")
        if mount_type is None and 'mountType' in kwargs:
            mount_type = kwargs['mountType']
        if mount_type is None:
            raise TypeError("Missing 'mount_type' argument")
        if role_id is None and 'roleId' in kwargs:
            role_id = kwargs['roleId']
        if role_id is None:
            raise TypeError("Missing 'role_id' argument")
        if role_type is None and 'roleType' in kwargs:
            role_type = kwargs['roleType']
        if role_type is None:
            raise TypeError("Missing 'role_type' argument")
        if share_id is None and 'shareId' in kwargs:
            share_id = kwargs['shareId']
        if share_id is None:
            raise TypeError("Missing 'share_id' argument")

        _setter("mount_point", mount_point)
        _setter("mount_type", mount_type)
        _setter("role_id", role_id)
        _setter("role_type", role_type)
        _setter("share_id", share_id)

    @property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> str:
        """
        Mount point for the share.
        """
        return pulumi.get(self, "mount_point")

    @property
    @pulumi.getter(name="mountType")
    def mount_type(self) -> str:
        """
        Mounting type.
        """
        return pulumi.get(self, "mount_type")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        """
        ID of the role to which share is mounted.
        """
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="roleType")
    def role_type(self) -> str:
        """
        Role type.
        """
        return pulumi.get(self, "role_type")

    @property
    @pulumi.getter(name="shareId")
    def share_id(self) -> str:
        """
        ID of the share mounted to the role VM.
        """
        return pulumi.get(self, "share_id")


@pulumi.output_type
class OrderStatusResponse(dict):
    """
    Represents a single status change.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalOrderDetails":
            suggest = "additional_order_details"
        elif key == "trackingInformation":
            suggest = "tracking_information"
        elif key == "updateDateTime":
            suggest = "update_date_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrderStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrderStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrderStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_order_details: Mapping[str, str],
                 status: str,
                 tracking_information: 'outputs.TrackingInfoResponse',
                 update_date_time: str,
                 comments: Optional[str] = None):
        """
        Represents a single status change.
        :param Mapping[str, str] additional_order_details: Dictionary to hold generic information which is not stored
               by the already existing properties
        :param str status: Status of the order as per the allowed status types.
        :param 'TrackingInfoResponse' tracking_information: Tracking information related to the state in the ordering flow
        :param str update_date_time: Time of status update.
        :param str comments: Comments related to this status change.
        """
        OrderStatusResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_order_details=additional_order_details,
            status=status,
            tracking_information=tracking_information,
            update_date_time=update_date_time,
            comments=comments,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_order_details: Optional[Mapping[str, str]] = None,
             status: Optional[str] = None,
             tracking_information: Optional['outputs.TrackingInfoResponse'] = None,
             update_date_time: Optional[str] = None,
             comments: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if additional_order_details is None and 'additionalOrderDetails' in kwargs:
            additional_order_details = kwargs['additionalOrderDetails']
        if additional_order_details is None:
            raise TypeError("Missing 'additional_order_details' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if tracking_information is None and 'trackingInformation' in kwargs:
            tracking_information = kwargs['trackingInformation']
        if tracking_information is None:
            raise TypeError("Missing 'tracking_information' argument")
        if update_date_time is None and 'updateDateTime' in kwargs:
            update_date_time = kwargs['updateDateTime']
        if update_date_time is None:
            raise TypeError("Missing 'update_date_time' argument")

        _setter("additional_order_details", additional_order_details)
        _setter("status", status)
        _setter("tracking_information", tracking_information)
        _setter("update_date_time", update_date_time)
        if comments is not None:
            _setter("comments", comments)

    @property
    @pulumi.getter(name="additionalOrderDetails")
    def additional_order_details(self) -> Mapping[str, str]:
        """
        Dictionary to hold generic information which is not stored
        by the already existing properties
        """
        return pulumi.get(self, "additional_order_details")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the order as per the allowed status types.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="trackingInformation")
    def tracking_information(self) -> 'outputs.TrackingInfoResponse':
        """
        Tracking information related to the state in the ordering flow
        """
        return pulumi.get(self, "tracking_information")

    @property
    @pulumi.getter(name="updateDateTime")
    def update_date_time(self) -> str:
        """
        Time of status update.
        """
        return pulumi.get(self, "update_date_time")

    @property
    @pulumi.getter
    def comments(self) -> Optional[str]:
        """
        Comments related to this status change.
        """
        return pulumi.get(self, "comments")


@pulumi.output_type
class RefreshDetailsResponse(dict):
    """
    Fields for tracking refresh job on the share or container.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorManifestFile":
            suggest = "error_manifest_file"
        elif key == "inProgressRefreshJobId":
            suggest = "in_progress_refresh_job_id"
        elif key == "lastCompletedRefreshJobTimeInUTC":
            suggest = "last_completed_refresh_job_time_in_utc"
        elif key == "lastJob":
            suggest = "last_job"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RefreshDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RefreshDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RefreshDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_manifest_file: Optional[str] = None,
                 in_progress_refresh_job_id: Optional[str] = None,
                 last_completed_refresh_job_time_in_utc: Optional[str] = None,
                 last_job: Optional[str] = None):
        """
        Fields for tracking refresh job on the share or container.
        :param str error_manifest_file: Indicates the relative path of the error xml for the last refresh job on this particular share or container, if any. This could be a failed job or a successful job.
        :param str in_progress_refresh_job_id: If a refresh job is currently in progress on this share or container, this field indicates the ARM resource ID of that job. The field is empty if no job is in progress.
        :param str last_completed_refresh_job_time_in_utc: Indicates the completed time for the last refresh job on this particular share or container, if any.This could be a failed job or a successful job.
        :param str last_job: Indicates the id of the last refresh job on this particular share or container,if any. This could be a failed job or a successful job.
        """
        RefreshDetailsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error_manifest_file=error_manifest_file,
            in_progress_refresh_job_id=in_progress_refresh_job_id,
            last_completed_refresh_job_time_in_utc=last_completed_refresh_job_time_in_utc,
            last_job=last_job,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error_manifest_file: Optional[str] = None,
             in_progress_refresh_job_id: Optional[str] = None,
             last_completed_refresh_job_time_in_utc: Optional[str] = None,
             last_job: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if error_manifest_file is None and 'errorManifestFile' in kwargs:
            error_manifest_file = kwargs['errorManifestFile']
        if in_progress_refresh_job_id is None and 'inProgressRefreshJobId' in kwargs:
            in_progress_refresh_job_id = kwargs['inProgressRefreshJobId']
        if last_completed_refresh_job_time_in_utc is None and 'lastCompletedRefreshJobTimeInUTC' in kwargs:
            last_completed_refresh_job_time_in_utc = kwargs['lastCompletedRefreshJobTimeInUTC']
        if last_job is None and 'lastJob' in kwargs:
            last_job = kwargs['lastJob']

        if error_manifest_file is not None:
            _setter("error_manifest_file", error_manifest_file)
        if in_progress_refresh_job_id is not None:
            _setter("in_progress_refresh_job_id", in_progress_refresh_job_id)
        if last_completed_refresh_job_time_in_utc is not None:
            _setter("last_completed_refresh_job_time_in_utc", last_completed_refresh_job_time_in_utc)
        if last_job is not None:
            _setter("last_job", last_job)

    @property
    @pulumi.getter(name="errorManifestFile")
    def error_manifest_file(self) -> Optional[str]:
        """
        Indicates the relative path of the error xml for the last refresh job on this particular share or container, if any. This could be a failed job or a successful job.
        """
        return pulumi.get(self, "error_manifest_file")

    @property
    @pulumi.getter(name="inProgressRefreshJobId")
    def in_progress_refresh_job_id(self) -> Optional[str]:
        """
        If a refresh job is currently in progress on this share or container, this field indicates the ARM resource ID of that job. The field is empty if no job is in progress.
        """
        return pulumi.get(self, "in_progress_refresh_job_id")

    @property
    @pulumi.getter(name="lastCompletedRefreshJobTimeInUTC")
    def last_completed_refresh_job_time_in_utc(self) -> Optional[str]:
        """
        Indicates the completed time for the last refresh job on this particular share or container, if any.This could be a failed job or a successful job.
        """
        return pulumi.get(self, "last_completed_refresh_job_time_in_utc")

    @property
    @pulumi.getter(name="lastJob")
    def last_job(self) -> Optional[str]:
        """
        Indicates the id of the last refresh job on this particular share or container,if any. This could be a failed job or a successful job.
        """
        return pulumi.get(self, "last_job")


@pulumi.output_type
class ResourceIdentityResponse(dict):
    """
    Msi identity details of the resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: Optional[str] = None):
        """
        Msi identity details of the resource
        :param str principal_id: Service Principal Id backing the Msi
        :param str tenant_id: Home Tenant Id
        :param str type: Identity type
        """
        ResourceIdentityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            principal_id=principal_id,
            tenant_id=tenant_id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             principal_id: Optional[str] = None,
             tenant_id: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if principal_id is None and 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if principal_id is None:
            raise TypeError("Missing 'principal_id' argument")
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_id is None:
            raise TypeError("Missing 'tenant_id' argument")

        _setter("principal_id", principal_id)
        _setter("tenant_id", tenant_id)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        Service Principal Id backing the Msi
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Home Tenant Id
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Identity type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ResourceMoveDetailsResponse(dict):
    """
    Fields for tracking resource move
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operationInProgress":
            suggest = "operation_in_progress"
        elif key == "operationInProgressLockTimeoutInUTC":
            suggest = "operation_in_progress_lock_timeout_in_utc"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMoveDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMoveDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMoveDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operation_in_progress: Optional[str] = None,
                 operation_in_progress_lock_timeout_in_utc: Optional[str] = None):
        """
        Fields for tracking resource move
        :param str operation_in_progress: Denotes whether move operation is in progress
        :param str operation_in_progress_lock_timeout_in_utc: Denotes the timeout of the operation to finish
        """
        ResourceMoveDetailsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operation_in_progress=operation_in_progress,
            operation_in_progress_lock_timeout_in_utc=operation_in_progress_lock_timeout_in_utc,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operation_in_progress: Optional[str] = None,
             operation_in_progress_lock_timeout_in_utc: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operation_in_progress is None and 'operationInProgress' in kwargs:
            operation_in_progress = kwargs['operationInProgress']
        if operation_in_progress_lock_timeout_in_utc is None and 'operationInProgressLockTimeoutInUTC' in kwargs:
            operation_in_progress_lock_timeout_in_utc = kwargs['operationInProgressLockTimeoutInUTC']

        if operation_in_progress is not None:
            _setter("operation_in_progress", operation_in_progress)
        if operation_in_progress_lock_timeout_in_utc is not None:
            _setter("operation_in_progress_lock_timeout_in_utc", operation_in_progress_lock_timeout_in_utc)

    @property
    @pulumi.getter(name="operationInProgress")
    def operation_in_progress(self) -> Optional[str]:
        """
        Denotes whether move operation is in progress
        """
        return pulumi.get(self, "operation_in_progress")

    @property
    @pulumi.getter(name="operationInProgressLockTimeoutInUTC")
    def operation_in_progress_lock_timeout_in_utc(self) -> Optional[str]:
        """
        Denotes the timeout of the operation to finish
        """
        return pulumi.get(self, "operation_in_progress_lock_timeout_in_utc")


@pulumi.output_type
class SecretResponse(dict):
    """
    Holds device secret either as a KeyVault reference or as an encrypted value.
    """
    def __init__(__self__, *,
                 encrypted_secret: Optional['outputs.AsymmetricEncryptedSecretResponse'] = None,
                 key_vault_id: Optional[str] = None):
        """
        Holds device secret either as a KeyVault reference or as an encrypted value.
        :param 'AsymmetricEncryptedSecretResponse' encrypted_secret: Encrypted (using device public key) secret value.
        :param str key_vault_id: Id of the Key-Vault where secret is stored (ex: secrets/AuthClientSecret/82ef4346187a4033a10d629cde07d740).
        """
        SecretResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            encrypted_secret=encrypted_secret,
            key_vault_id=key_vault_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             encrypted_secret: Optional['outputs.AsymmetricEncryptedSecretResponse'] = None,
             key_vault_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if encrypted_secret is None and 'encryptedSecret' in kwargs:
            encrypted_secret = kwargs['encryptedSecret']
        if key_vault_id is None and 'keyVaultId' in kwargs:
            key_vault_id = kwargs['keyVaultId']

        if encrypted_secret is not None:
            _setter("encrypted_secret", encrypted_secret)
        if key_vault_id is not None:
            _setter("key_vault_id", key_vault_id)

    @property
    @pulumi.getter(name="encryptedSecret")
    def encrypted_secret(self) -> Optional['outputs.AsymmetricEncryptedSecretResponse']:
        """
        Encrypted (using device public key) secret value.
        """
        return pulumi.get(self, "encrypted_secret")

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> Optional[str]:
        """
        Id of the Key-Vault where secret is stored (ex: secrets/AuthClientSecret/82ef4346187a4033a10d629cde07d740).
        """
        return pulumi.get(self, "key_vault_id")


@pulumi.output_type
class ShareAccessRightResponse(dict):
    """
    Specifies the mapping between this particular user and the type of access he has on shares on this device.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessType":
            suggest = "access_type"
        elif key == "shareId":
            suggest = "share_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ShareAccessRightResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ShareAccessRightResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ShareAccessRightResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_type: str,
                 share_id: str):
        """
        Specifies the mapping between this particular user and the type of access he has on shares on this device.
        :param str access_type: Type of access to be allowed on the share for this user.
        :param str share_id: The share ID.
        """
        ShareAccessRightResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_type=access_type,
            share_id=share_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_type: Optional[str] = None,
             share_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if access_type is None and 'accessType' in kwargs:
            access_type = kwargs['accessType']
        if access_type is None:
            raise TypeError("Missing 'access_type' argument")
        if share_id is None and 'shareId' in kwargs:
            share_id = kwargs['shareId']
        if share_id is None:
            raise TypeError("Missing 'share_id' argument")

        _setter("access_type", access_type)
        _setter("share_id", share_id)

    @property
    @pulumi.getter(name="accessType")
    def access_type(self) -> str:
        """
        Type of access to be allowed on the share for this user.
        """
        return pulumi.get(self, "access_type")

    @property
    @pulumi.getter(name="shareId")
    def share_id(self) -> str:
        """
        The share ID.
        """
        return pulumi.get(self, "share_id")


@pulumi.output_type
class SkuResponse(dict):
    """
    The SKU type.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 tier: Optional[str] = None):
        """
        The SKU type.
        :param str name: SKU name.
        :param str tier: The SKU tier. This is based on the SKU name.
        """
        SkuResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            tier=tier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             tier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if tier is not None:
            _setter("tier", tier)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        SKU name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        """
        The SKU tier. This is based on the SKU name.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class SubscriptionRegisteredFeaturesResponse(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 state: Optional[str] = None):
        SubscriptionRegisteredFeaturesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class SymmetricKeyResponse(dict):
    """
    Symmetric key for authentication.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionString":
            suggest = "connection_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SymmetricKeyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SymmetricKeyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SymmetricKeyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_string: Optional['outputs.AsymmetricEncryptedSecretResponse'] = None):
        """
        Symmetric key for authentication.
        :param 'AsymmetricEncryptedSecretResponse' connection_string: Connection string based on the symmetric key.
        """
        SymmetricKeyResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_string=connection_string,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_string: Optional['outputs.AsymmetricEncryptedSecretResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_string is None and 'connectionString' in kwargs:
            connection_string = kwargs['connectionString']

        if connection_string is not None:
            _setter("connection_string", connection_string)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional['outputs.AsymmetricEncryptedSecretResponse']:
        """
        Connection string based on the symmetric key.
        """
        return pulumi.get(self, "connection_string")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        SystemDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            created_by=created_by,
            created_by_type=created_by_type,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            last_modified_by_type=last_modified_by_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: Optional[str] = None,
             created_by: Optional[str] = None,
             created_by_type: Optional[str] = None,
             last_modified_at: Optional[str] = None,
             last_modified_by: Optional[str] = None,
             last_modified_by_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if created_at is None and 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if created_by_type is None and 'createdByType' in kwargs:
            created_by_type = kwargs['createdByType']
        if last_modified_at is None and 'lastModifiedAt' in kwargs:
            last_modified_at = kwargs['lastModifiedAt']
        if last_modified_by is None and 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if last_modified_by_type is None and 'lastModifiedByType' in kwargs:
            last_modified_by_type = kwargs['lastModifiedByType']

        if created_at is not None:
            _setter("created_at", created_at)
        if created_by is not None:
            _setter("created_by", created_by)
        if created_by_type is not None:
            _setter("created_by_type", created_by_type)
        if last_modified_at is not None:
            _setter("last_modified_at", last_modified_at)
        if last_modified_by is not None:
            _setter("last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            _setter("last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TrackingInfoResponse(dict):
    """
    Tracking courier information.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "carrierName":
            suggest = "carrier_name"
        elif key == "serialNumber":
            suggest = "serial_number"
        elif key == "trackingId":
            suggest = "tracking_id"
        elif key == "trackingUrl":
            suggest = "tracking_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrackingInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrackingInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrackingInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 carrier_name: Optional[str] = None,
                 serial_number: Optional[str] = None,
                 tracking_id: Optional[str] = None,
                 tracking_url: Optional[str] = None):
        """
        Tracking courier information.
        :param str carrier_name: Name of the carrier used in the delivery.
        :param str serial_number: Serial number of the device being tracked.
        :param str tracking_id: Tracking ID of the shipment.
        :param str tracking_url: Tracking URL of the shipment.
        """
        TrackingInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            carrier_name=carrier_name,
            serial_number=serial_number,
            tracking_id=tracking_id,
            tracking_url=tracking_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             carrier_name: Optional[str] = None,
             serial_number: Optional[str] = None,
             tracking_id: Optional[str] = None,
             tracking_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if carrier_name is None and 'carrierName' in kwargs:
            carrier_name = kwargs['carrierName']
        if serial_number is None and 'serialNumber' in kwargs:
            serial_number = kwargs['serialNumber']
        if tracking_id is None and 'trackingId' in kwargs:
            tracking_id = kwargs['trackingId']
        if tracking_url is None and 'trackingUrl' in kwargs:
            tracking_url = kwargs['trackingUrl']

        if carrier_name is not None:
            _setter("carrier_name", carrier_name)
        if serial_number is not None:
            _setter("serial_number", serial_number)
        if tracking_id is not None:
            _setter("tracking_id", tracking_id)
        if tracking_url is not None:
            _setter("tracking_url", tracking_url)

    @property
    @pulumi.getter(name="carrierName")
    def carrier_name(self) -> Optional[str]:
        """
        Name of the carrier used in the delivery.
        """
        return pulumi.get(self, "carrier_name")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[str]:
        """
        Serial number of the device being tracked.
        """
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter(name="trackingId")
    def tracking_id(self) -> Optional[str]:
        """
        Tracking ID of the shipment.
        """
        return pulumi.get(self, "tracking_id")

    @property
    @pulumi.getter(name="trackingUrl")
    def tracking_url(self) -> Optional[str]:
        """
        Tracking URL of the shipment.
        """
        return pulumi.get(self, "tracking_url")


@pulumi.output_type
class UserAccessRightResponse(dict):
    """
    The mapping between a particular user and the access type on the SMB share.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessType":
            suggest = "access_type"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAccessRightResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAccessRightResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAccessRightResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_type: str,
                 user_id: str):
        """
        The mapping between a particular user and the access type on the SMB share.
        :param str access_type: Type of access to be allowed for the user.
        :param str user_id: User ID (already existing in the device).
        """
        UserAccessRightResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_type=access_type,
            user_id=user_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_type: Optional[str] = None,
             user_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if access_type is None and 'accessType' in kwargs:
            access_type = kwargs['accessType']
        if access_type is None:
            raise TypeError("Missing 'access_type' argument")
        if user_id is None and 'userId' in kwargs:
            user_id = kwargs['userId']
        if user_id is None:
            raise TypeError("Missing 'user_id' argument")

        _setter("access_type", access_type)
        _setter("user_id", user_id)

    @property
    @pulumi.getter(name="accessType")
    def access_type(self) -> str:
        """
        Type of access to be allowed for the user.
        """
        return pulumi.get(self, "access_type")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        User ID (already existing in the device).
        """
        return pulumi.get(self, "user_id")


