# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AADAuthenticationSettingsArgs',
    'AADAuthenticationSettingsArgsDict',
    'AdditionalFeaturesServerConfigurationsArgs',
    'AdditionalFeaturesServerConfigurationsArgsDict',
    'AgConfigurationArgs',
    'AgConfigurationArgsDict',
    'AgReplicaArgs',
    'AgReplicaArgsDict',
    'AssessmentSettingsArgs',
    'AssessmentSettingsArgsDict',
    'AutoBackupSettingsArgs',
    'AutoBackupSettingsArgsDict',
    'AutoPatchingSettingsArgs',
    'AutoPatchingSettingsArgsDict',
    'KeyVaultCredentialSettingsArgs',
    'KeyVaultCredentialSettingsArgsDict',
    'LoadBalancerConfigurationArgs',
    'LoadBalancerConfigurationArgsDict',
    'MultiSubnetIpConfigurationArgs',
    'MultiSubnetIpConfigurationArgsDict',
    'PrivateIPAddressArgs',
    'PrivateIPAddressArgsDict',
    'ResourceIdentityArgs',
    'ResourceIdentityArgsDict',
    'SQLInstanceSettingsArgs',
    'SQLInstanceSettingsArgsDict',
    'SQLStorageSettingsArgs',
    'SQLStorageSettingsArgsDict',
    'SQLTempDbSettingsArgs',
    'SQLTempDbSettingsArgsDict',
    'ScheduleArgs',
    'ScheduleArgsDict',
    'ServerConfigurationsManagementSettingsArgs',
    'ServerConfigurationsManagementSettingsArgsDict',
    'SqlConnectivityUpdateSettingsArgs',
    'SqlConnectivityUpdateSettingsArgsDict',
    'SqlStorageUpdateSettingsArgs',
    'SqlStorageUpdateSettingsArgsDict',
    'SqlWorkloadTypeUpdateSettingsArgs',
    'SqlWorkloadTypeUpdateSettingsArgsDict',
    'StorageConfigurationSettingsArgs',
    'StorageConfigurationSettingsArgsDict',
    'VirtualMachineIdentityArgs',
    'VirtualMachineIdentityArgsDict',
    'WsfcDomainCredentialsArgs',
    'WsfcDomainCredentialsArgsDict',
    'WsfcDomainProfileArgs',
    'WsfcDomainProfileArgsDict',
]

MYPY = False

if not MYPY:
    class AADAuthenticationSettingsArgsDict(TypedDict):
        """
        Enable AAD authentication for SQL VM.
        """
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The client Id of the Managed Identity to query Microsoft Graph API. An empty string must be used for the system assigned Managed Identity
        """
elif False:
    AADAuthenticationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AADAuthenticationSettingsArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Enable AAD authentication for SQL VM.
        :param pulumi.Input[builtins.str] client_id: The client Id of the Managed Identity to query Microsoft Graph API. An empty string must be used for the system assigned Managed Identity
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client Id of the Managed Identity to query Microsoft Graph API. An empty string must be used for the system assigned Managed Identity
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)


if not MYPY:
    class AdditionalFeaturesServerConfigurationsArgsDict(TypedDict):
        """
        Additional SQL Server feature settings.
        """
        is_r_services_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable R services (SQL 2016 onwards).
        """
elif False:
    AdditionalFeaturesServerConfigurationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdditionalFeaturesServerConfigurationsArgs:
    def __init__(__self__, *,
                 is_r_services_enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        Additional SQL Server feature settings.
        :param pulumi.Input[builtins.bool] is_r_services_enabled: Enable or disable R services (SQL 2016 onwards).
        """
        if is_r_services_enabled is not None:
            pulumi.set(__self__, "is_r_services_enabled", is_r_services_enabled)

    @property
    @pulumi.getter(name="isRServicesEnabled")
    def is_r_services_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable R services (SQL 2016 onwards).
        """
        return pulumi.get(self, "is_r_services_enabled")

    @is_r_services_enabled.setter
    def is_r_services_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_r_services_enabled", value)


if not MYPY:
    class AgConfigurationArgsDict(TypedDict):
        """
        Availability group configuration.
        """
        replicas: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgReplicaArgsDict']]]]
        """
        Replica configurations.
        """
elif False:
    AgConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgConfigurationArgs:
    def __init__(__self__, *,
                 replicas: Optional[pulumi.Input[Sequence[pulumi.Input['AgReplicaArgs']]]] = None):
        """
        Availability group configuration.
        :param pulumi.Input[Sequence[pulumi.Input['AgReplicaArgs']]] replicas: Replica configurations.
        """
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgReplicaArgs']]]]:
        """
        Replica configurations.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgReplicaArgs']]]]):
        pulumi.set(self, "replicas", value)


if not MYPY:
    class AgReplicaArgsDict(TypedDict):
        """
        Availability group replica configuration.
        """
        commit: NotRequired[pulumi.Input[Union[builtins.str, 'Commit']]]
        """
        Replica commit mode in availability group.
        """
        failover: NotRequired[pulumi.Input[Union[builtins.str, 'Failover']]]
        """
        Replica failover mode in availability group.
        """
        readable_secondary: NotRequired[pulumi.Input[Union[builtins.str, 'ReadableSecondary']]]
        """
        Replica readable secondary mode in availability group.
        """
        role: NotRequired[pulumi.Input[Union[builtins.str, 'Role']]]
        """
        Replica Role in availability group.
        """
        sql_virtual_machine_instance_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Sql VirtualMachine Instance Id.
        """
elif False:
    AgReplicaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgReplicaArgs:
    def __init__(__self__, *,
                 commit: Optional[pulumi.Input[Union[builtins.str, 'Commit']]] = None,
                 failover: Optional[pulumi.Input[Union[builtins.str, 'Failover']]] = None,
                 readable_secondary: Optional[pulumi.Input[Union[builtins.str, 'ReadableSecondary']]] = None,
                 role: Optional[pulumi.Input[Union[builtins.str, 'Role']]] = None,
                 sql_virtual_machine_instance_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Availability group replica configuration.
        :param pulumi.Input[Union[builtins.str, 'Commit']] commit: Replica commit mode in availability group.
        :param pulumi.Input[Union[builtins.str, 'Failover']] failover: Replica failover mode in availability group.
        :param pulumi.Input[Union[builtins.str, 'ReadableSecondary']] readable_secondary: Replica readable secondary mode in availability group.
        :param pulumi.Input[Union[builtins.str, 'Role']] role: Replica Role in availability group.
        :param pulumi.Input[builtins.str] sql_virtual_machine_instance_id: Sql VirtualMachine Instance Id.
        """
        if commit is not None:
            pulumi.set(__self__, "commit", commit)
        if failover is not None:
            pulumi.set(__self__, "failover", failover)
        if readable_secondary is not None:
            pulumi.set(__self__, "readable_secondary", readable_secondary)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if sql_virtual_machine_instance_id is not None:
            pulumi.set(__self__, "sql_virtual_machine_instance_id", sql_virtual_machine_instance_id)

    @property
    @pulumi.getter
    def commit(self) -> Optional[pulumi.Input[Union[builtins.str, 'Commit']]]:
        """
        Replica commit mode in availability group.
        """
        return pulumi.get(self, "commit")

    @commit.setter
    def commit(self, value: Optional[pulumi.Input[Union[builtins.str, 'Commit']]]):
        pulumi.set(self, "commit", value)

    @property
    @pulumi.getter
    def failover(self) -> Optional[pulumi.Input[Union[builtins.str, 'Failover']]]:
        """
        Replica failover mode in availability group.
        """
        return pulumi.get(self, "failover")

    @failover.setter
    def failover(self, value: Optional[pulumi.Input[Union[builtins.str, 'Failover']]]):
        pulumi.set(self, "failover", value)

    @property
    @pulumi.getter(name="readableSecondary")
    def readable_secondary(self) -> Optional[pulumi.Input[Union[builtins.str, 'ReadableSecondary']]]:
        """
        Replica readable secondary mode in availability group.
        """
        return pulumi.get(self, "readable_secondary")

    @readable_secondary.setter
    def readable_secondary(self, value: Optional[pulumi.Input[Union[builtins.str, 'ReadableSecondary']]]):
        pulumi.set(self, "readable_secondary", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[Union[builtins.str, 'Role']]]:
        """
        Replica Role in availability group.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[Union[builtins.str, 'Role']]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="sqlVirtualMachineInstanceId")
    def sql_virtual_machine_instance_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Sql VirtualMachine Instance Id.
        """
        return pulumi.get(self, "sql_virtual_machine_instance_id")

    @sql_virtual_machine_instance_id.setter
    def sql_virtual_machine_instance_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sql_virtual_machine_instance_id", value)


if not MYPY:
    class AssessmentSettingsArgsDict(TypedDict):
        """
        Configure SQL best practices Assessment for databases in your SQL virtual machine.
        """
        enable: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable SQL best practices Assessment feature on SQL virtual machine.
        """
        run_immediately: NotRequired[pulumi.Input[builtins.bool]]
        """
        Run SQL best practices Assessment immediately on SQL virtual machine.
        """
        schedule: NotRequired[pulumi.Input['ScheduleArgsDict']]
        """
        Schedule for SQL best practices Assessment.
        """
elif False:
    AssessmentSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssessmentSettingsArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[builtins.bool]] = None,
                 run_immediately: Optional[pulumi.Input[builtins.bool]] = None,
                 schedule: Optional[pulumi.Input['ScheduleArgs']] = None):
        """
        Configure SQL best practices Assessment for databases in your SQL virtual machine.
        :param pulumi.Input[builtins.bool] enable: Enable or disable SQL best practices Assessment feature on SQL virtual machine.
        :param pulumi.Input[builtins.bool] run_immediately: Run SQL best practices Assessment immediately on SQL virtual machine.
        :param pulumi.Input['ScheduleArgs'] schedule: Schedule for SQL best practices Assessment.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if run_immediately is not None:
            pulumi.set(__self__, "run_immediately", run_immediately)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable SQL best practices Assessment feature on SQL virtual machine.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="runImmediately")
    def run_immediately(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Run SQL best practices Assessment immediately on SQL virtual machine.
        """
        return pulumi.get(self, "run_immediately")

    @run_immediately.setter
    def run_immediately(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "run_immediately", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['ScheduleArgs']]:
        """
        Schedule for SQL best practices Assessment.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['ScheduleArgs']]):
        pulumi.set(self, "schedule", value)


if not MYPY:
    class AutoBackupSettingsArgsDict(TypedDict):
        """
        Configure backups for databases in your SQL virtual machine.
        """
        backup_schedule_type: NotRequired[pulumi.Input[Union[builtins.str, 'BackupScheduleType']]]
        """
        Backup schedule type.
        """
        backup_system_dbs: NotRequired[pulumi.Input[builtins.bool]]
        """
        Include or exclude system databases from auto backup.
        """
        days_of_week: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'AutoBackupDaysOfWeek']]]]]
        """
        Days of the week for the backups when FullBackupFrequency is set to Weekly.
        """
        enable: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable autobackup on SQL virtual machine.
        """
        enable_encryption: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable encryption for backup on SQL virtual machine.
        """
        full_backup_frequency: NotRequired[pulumi.Input[Union[builtins.str, 'FullBackupFrequencyType']]]
        """
        Frequency of full backups. In both cases, full backups begin during the next scheduled time window.
        """
        full_backup_start_time: NotRequired[pulumi.Input[builtins.int]]
        """
        Start time of a given day during which full backups can take place. 0-23 hours.
        """
        full_backup_window_hours: NotRequired[pulumi.Input[builtins.int]]
        """
        Duration of the time window of a given day during which full backups can take place. 1-23 hours.
        """
        log_backup_frequency: NotRequired[pulumi.Input[builtins.int]]
        """
        Frequency of log backups. 5-60 minutes.
        """
        password: NotRequired[pulumi.Input[builtins.str]]
        """
        Password for encryption on backup.
        """
        retention_period: NotRequired[pulumi.Input[builtins.int]]
        """
        Retention period of backup: 1-90 days.
        """
        storage_access_key: NotRequired[pulumi.Input[builtins.str]]
        """
        Storage account key where backup will be taken to.
        """
        storage_account_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Storage account url where backup will be taken to.
        """
        storage_container_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Storage container name where backup will be taken to.
        """
elif False:
    AutoBackupSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoBackupSettingsArgs:
    def __init__(__self__, *,
                 backup_schedule_type: Optional[pulumi.Input[Union[builtins.str, 'BackupScheduleType']]] = None,
                 backup_system_dbs: Optional[pulumi.Input[builtins.bool]] = None,
                 days_of_week: Optional[pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'AutoBackupDaysOfWeek']]]]] = None,
                 enable: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_encryption: Optional[pulumi.Input[builtins.bool]] = None,
                 full_backup_frequency: Optional[pulumi.Input[Union[builtins.str, 'FullBackupFrequencyType']]] = None,
                 full_backup_start_time: Optional[pulumi.Input[builtins.int]] = None,
                 full_backup_window_hours: Optional[pulumi.Input[builtins.int]] = None,
                 log_backup_frequency: Optional[pulumi.Input[builtins.int]] = None,
                 password: Optional[pulumi.Input[builtins.str]] = None,
                 retention_period: Optional[pulumi.Input[builtins.int]] = None,
                 storage_access_key: Optional[pulumi.Input[builtins.str]] = None,
                 storage_account_url: Optional[pulumi.Input[builtins.str]] = None,
                 storage_container_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        Configure backups for databases in your SQL virtual machine.
        :param pulumi.Input[Union[builtins.str, 'BackupScheduleType']] backup_schedule_type: Backup schedule type.
        :param pulumi.Input[builtins.bool] backup_system_dbs: Include or exclude system databases from auto backup.
        :param pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'AutoBackupDaysOfWeek']]]] days_of_week: Days of the week for the backups when FullBackupFrequency is set to Weekly.
        :param pulumi.Input[builtins.bool] enable: Enable or disable autobackup on SQL virtual machine.
        :param pulumi.Input[builtins.bool] enable_encryption: Enable or disable encryption for backup on SQL virtual machine.
        :param pulumi.Input[Union[builtins.str, 'FullBackupFrequencyType']] full_backup_frequency: Frequency of full backups. In both cases, full backups begin during the next scheduled time window.
        :param pulumi.Input[builtins.int] full_backup_start_time: Start time of a given day during which full backups can take place. 0-23 hours.
        :param pulumi.Input[builtins.int] full_backup_window_hours: Duration of the time window of a given day during which full backups can take place. 1-23 hours.
        :param pulumi.Input[builtins.int] log_backup_frequency: Frequency of log backups. 5-60 minutes.
        :param pulumi.Input[builtins.str] password: Password for encryption on backup.
        :param pulumi.Input[builtins.int] retention_period: Retention period of backup: 1-90 days.
        :param pulumi.Input[builtins.str] storage_access_key: Storage account key where backup will be taken to.
        :param pulumi.Input[builtins.str] storage_account_url: Storage account url where backup will be taken to.
        :param pulumi.Input[builtins.str] storage_container_name: Storage container name where backup will be taken to.
        """
        if backup_schedule_type is not None:
            pulumi.set(__self__, "backup_schedule_type", backup_schedule_type)
        if backup_system_dbs is not None:
            pulumi.set(__self__, "backup_system_dbs", backup_system_dbs)
        if days_of_week is not None:
            pulumi.set(__self__, "days_of_week", days_of_week)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if full_backup_frequency is not None:
            pulumi.set(__self__, "full_backup_frequency", full_backup_frequency)
        if full_backup_start_time is not None:
            pulumi.set(__self__, "full_backup_start_time", full_backup_start_time)
        if full_backup_window_hours is not None:
            pulumi.set(__self__, "full_backup_window_hours", full_backup_window_hours)
        if log_backup_frequency is not None:
            pulumi.set(__self__, "log_backup_frequency", log_backup_frequency)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if retention_period is not None:
            pulumi.set(__self__, "retention_period", retention_period)
        if storage_access_key is not None:
            pulumi.set(__self__, "storage_access_key", storage_access_key)
        if storage_account_url is not None:
            pulumi.set(__self__, "storage_account_url", storage_account_url)
        if storage_container_name is not None:
            pulumi.set(__self__, "storage_container_name", storage_container_name)

    @property
    @pulumi.getter(name="backupScheduleType")
    def backup_schedule_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'BackupScheduleType']]]:
        """
        Backup schedule type.
        """
        return pulumi.get(self, "backup_schedule_type")

    @backup_schedule_type.setter
    def backup_schedule_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'BackupScheduleType']]]):
        pulumi.set(self, "backup_schedule_type", value)

    @property
    @pulumi.getter(name="backupSystemDbs")
    def backup_system_dbs(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Include or exclude system databases from auto backup.
        """
        return pulumi.get(self, "backup_system_dbs")

    @backup_system_dbs.setter
    def backup_system_dbs(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "backup_system_dbs", value)

    @property
    @pulumi.getter(name="daysOfWeek")
    def days_of_week(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'AutoBackupDaysOfWeek']]]]]:
        """
        Days of the week for the backups when FullBackupFrequency is set to Weekly.
        """
        return pulumi.get(self, "days_of_week")

    @days_of_week.setter
    def days_of_week(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'AutoBackupDaysOfWeek']]]]]):
        pulumi.set(self, "days_of_week", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable autobackup on SQL virtual machine.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable encryption for backup on SQL virtual machine.
        """
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="fullBackupFrequency")
    def full_backup_frequency(self) -> Optional[pulumi.Input[Union[builtins.str, 'FullBackupFrequencyType']]]:
        """
        Frequency of full backups. In both cases, full backups begin during the next scheduled time window.
        """
        return pulumi.get(self, "full_backup_frequency")

    @full_backup_frequency.setter
    def full_backup_frequency(self, value: Optional[pulumi.Input[Union[builtins.str, 'FullBackupFrequencyType']]]):
        pulumi.set(self, "full_backup_frequency", value)

    @property
    @pulumi.getter(name="fullBackupStartTime")
    def full_backup_start_time(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Start time of a given day during which full backups can take place. 0-23 hours.
        """
        return pulumi.get(self, "full_backup_start_time")

    @full_backup_start_time.setter
    def full_backup_start_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "full_backup_start_time", value)

    @property
    @pulumi.getter(name="fullBackupWindowHours")
    def full_backup_window_hours(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Duration of the time window of a given day during which full backups can take place. 1-23 hours.
        """
        return pulumi.get(self, "full_backup_window_hours")

    @full_backup_window_hours.setter
    def full_backup_window_hours(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "full_backup_window_hours", value)

    @property
    @pulumi.getter(name="logBackupFrequency")
    def log_backup_frequency(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Frequency of log backups. 5-60 minutes.
        """
        return pulumi.get(self, "log_backup_frequency")

    @log_backup_frequency.setter
    def log_backup_frequency(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "log_backup_frequency", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Password for encryption on backup.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="retentionPeriod")
    def retention_period(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Retention period of backup: 1-90 days.
        """
        return pulumi.get(self, "retention_period")

    @retention_period.setter
    def retention_period(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "retention_period", value)

    @property
    @pulumi.getter(name="storageAccessKey")
    def storage_access_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Storage account key where backup will be taken to.
        """
        return pulumi.get(self, "storage_access_key")

    @storage_access_key.setter
    def storage_access_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "storage_access_key", value)

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Storage account url where backup will be taken to.
        """
        return pulumi.get(self, "storage_account_url")

    @storage_account_url.setter
    def storage_account_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "storage_account_url", value)

    @property
    @pulumi.getter(name="storageContainerName")
    def storage_container_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Storage container name where backup will be taken to.
        """
        return pulumi.get(self, "storage_container_name")

    @storage_container_name.setter
    def storage_container_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "storage_container_name", value)


if not MYPY:
    class AutoPatchingSettingsArgsDict(TypedDict):
        """
        Set a patching window during which Windows and SQL patches will be applied.
        """
        additional_vm_patch: NotRequired[pulumi.Input[Union[builtins.str, 'AdditionalVmPatch']]]
        """
        Additional Patch to be enable or enabled on the SQL Virtual Machine.
        """
        day_of_week: NotRequired[pulumi.Input['DayOfWeek']]
        """
        Day of week to apply the patch on.
        """
        enable: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable autopatching on SQL virtual machine.
        """
        maintenance_window_duration: NotRequired[pulumi.Input[builtins.int]]
        """
        Duration of patching.
        """
        maintenance_window_starting_hour: NotRequired[pulumi.Input[builtins.int]]
        """
        Hour of the day when patching is initiated. Local VM time.
        """
elif False:
    AutoPatchingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoPatchingSettingsArgs:
    def __init__(__self__, *,
                 additional_vm_patch: Optional[pulumi.Input[Union[builtins.str, 'AdditionalVmPatch']]] = None,
                 day_of_week: Optional[pulumi.Input['DayOfWeek']] = None,
                 enable: Optional[pulumi.Input[builtins.bool]] = None,
                 maintenance_window_duration: Optional[pulumi.Input[builtins.int]] = None,
                 maintenance_window_starting_hour: Optional[pulumi.Input[builtins.int]] = None):
        """
        Set a patching window during which Windows and SQL patches will be applied.
        :param pulumi.Input[Union[builtins.str, 'AdditionalVmPatch']] additional_vm_patch: Additional Patch to be enable or enabled on the SQL Virtual Machine.
        :param pulumi.Input['DayOfWeek'] day_of_week: Day of week to apply the patch on.
        :param pulumi.Input[builtins.bool] enable: Enable or disable autopatching on SQL virtual machine.
        :param pulumi.Input[builtins.int] maintenance_window_duration: Duration of patching.
        :param pulumi.Input[builtins.int] maintenance_window_starting_hour: Hour of the day when patching is initiated. Local VM time.
        """
        if additional_vm_patch is None:
            additional_vm_patch = 'NotSet'
        if additional_vm_patch is not None:
            pulumi.set(__self__, "additional_vm_patch", additional_vm_patch)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if maintenance_window_duration is not None:
            pulumi.set(__self__, "maintenance_window_duration", maintenance_window_duration)
        if maintenance_window_starting_hour is not None:
            pulumi.set(__self__, "maintenance_window_starting_hour", maintenance_window_starting_hour)

    @property
    @pulumi.getter(name="additionalVmPatch")
    def additional_vm_patch(self) -> Optional[pulumi.Input[Union[builtins.str, 'AdditionalVmPatch']]]:
        """
        Additional Patch to be enable or enabled on the SQL Virtual Machine.
        """
        return pulumi.get(self, "additional_vm_patch")

    @additional_vm_patch.setter
    def additional_vm_patch(self, value: Optional[pulumi.Input[Union[builtins.str, 'AdditionalVmPatch']]]):
        pulumi.set(self, "additional_vm_patch", value)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input['DayOfWeek']]:
        """
        Day of week to apply the patch on.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input['DayOfWeek']]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable autopatching on SQL virtual machine.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="maintenanceWindowDuration")
    def maintenance_window_duration(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Duration of patching.
        """
        return pulumi.get(self, "maintenance_window_duration")

    @maintenance_window_duration.setter
    def maintenance_window_duration(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "maintenance_window_duration", value)

    @property
    @pulumi.getter(name="maintenanceWindowStartingHour")
    def maintenance_window_starting_hour(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Hour of the day when patching is initiated. Local VM time.
        """
        return pulumi.get(self, "maintenance_window_starting_hour")

    @maintenance_window_starting_hour.setter
    def maintenance_window_starting_hour(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "maintenance_window_starting_hour", value)


if not MYPY:
    class KeyVaultCredentialSettingsArgsDict(TypedDict):
        """
        Configure your SQL virtual machine to be able to connect to the Azure Key Vault service.
        """
        azure_key_vault_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Azure Key Vault url.
        """
        credential_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Credential name.
        """
        enable: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable key vault credential setting.
        """
        service_principal_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Service principal name to access key vault.
        """
        service_principal_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        Service principal name secret to access key vault.
        """
elif False:
    KeyVaultCredentialSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeyVaultCredentialSettingsArgs:
    def __init__(__self__, *,
                 azure_key_vault_url: Optional[pulumi.Input[builtins.str]] = None,
                 credential_name: Optional[pulumi.Input[builtins.str]] = None,
                 enable: Optional[pulumi.Input[builtins.bool]] = None,
                 service_principal_name: Optional[pulumi.Input[builtins.str]] = None,
                 service_principal_secret: Optional[pulumi.Input[builtins.str]] = None):
        """
        Configure your SQL virtual machine to be able to connect to the Azure Key Vault service.
        :param pulumi.Input[builtins.str] azure_key_vault_url: Azure Key Vault url.
        :param pulumi.Input[builtins.str] credential_name: Credential name.
        :param pulumi.Input[builtins.bool] enable: Enable or disable key vault credential setting.
        :param pulumi.Input[builtins.str] service_principal_name: Service principal name to access key vault.
        :param pulumi.Input[builtins.str] service_principal_secret: Service principal name secret to access key vault.
        """
        if azure_key_vault_url is not None:
            pulumi.set(__self__, "azure_key_vault_url", azure_key_vault_url)
        if credential_name is not None:
            pulumi.set(__self__, "credential_name", credential_name)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if service_principal_name is not None:
            pulumi.set(__self__, "service_principal_name", service_principal_name)
        if service_principal_secret is not None:
            pulumi.set(__self__, "service_principal_secret", service_principal_secret)

    @property
    @pulumi.getter(name="azureKeyVaultUrl")
    def azure_key_vault_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Azure Key Vault url.
        """
        return pulumi.get(self, "azure_key_vault_url")

    @azure_key_vault_url.setter
    def azure_key_vault_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "azure_key_vault_url", value)

    @property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Credential name.
        """
        return pulumi.get(self, "credential_name")

    @credential_name.setter
    def credential_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "credential_name", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable key vault credential setting.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="servicePrincipalName")
    def service_principal_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Service principal name to access key vault.
        """
        return pulumi.get(self, "service_principal_name")

    @service_principal_name.setter
    def service_principal_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "service_principal_name", value)

    @property
    @pulumi.getter(name="servicePrincipalSecret")
    def service_principal_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Service principal name secret to access key vault.
        """
        return pulumi.get(self, "service_principal_secret")

    @service_principal_secret.setter
    def service_principal_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "service_principal_secret", value)


if not MYPY:
    class LoadBalancerConfigurationArgsDict(TypedDict):
        """
        A load balancer configuration for an availability group listener.
        """
        load_balancer_resource_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource id of the load balancer.
        """
        private_ip_address: NotRequired[pulumi.Input['PrivateIPAddressArgsDict']]
        """
        Private IP address.
        """
        probe_port: NotRequired[pulumi.Input[builtins.int]]
        """
        Probe port.
        """
        public_ip_address_resource_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource id of the public IP.
        """
        sql_virtual_machine_instances: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of the SQL virtual machine instance resource id's that are enrolled into the availability group listener.
        """
elif False:
    LoadBalancerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerConfigurationArgs:
    def __init__(__self__, *,
                 load_balancer_resource_id: Optional[pulumi.Input[builtins.str]] = None,
                 private_ip_address: Optional[pulumi.Input['PrivateIPAddressArgs']] = None,
                 probe_port: Optional[pulumi.Input[builtins.int]] = None,
                 public_ip_address_resource_id: Optional[pulumi.Input[builtins.str]] = None,
                 sql_virtual_machine_instances: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        A load balancer configuration for an availability group listener.
        :param pulumi.Input[builtins.str] load_balancer_resource_id: Resource id of the load balancer.
        :param pulumi.Input['PrivateIPAddressArgs'] private_ip_address: Private IP address.
        :param pulumi.Input[builtins.int] probe_port: Probe port.
        :param pulumi.Input[builtins.str] public_ip_address_resource_id: Resource id of the public IP.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] sql_virtual_machine_instances: List of the SQL virtual machine instance resource id's that are enrolled into the availability group listener.
        """
        if load_balancer_resource_id is not None:
            pulumi.set(__self__, "load_balancer_resource_id", load_balancer_resource_id)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if probe_port is not None:
            pulumi.set(__self__, "probe_port", probe_port)
        if public_ip_address_resource_id is not None:
            pulumi.set(__self__, "public_ip_address_resource_id", public_ip_address_resource_id)
        if sql_virtual_machine_instances is not None:
            pulumi.set(__self__, "sql_virtual_machine_instances", sql_virtual_machine_instances)

    @property
    @pulumi.getter(name="loadBalancerResourceId")
    def load_balancer_resource_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource id of the load balancer.
        """
        return pulumi.get(self, "load_balancer_resource_id")

    @load_balancer_resource_id.setter
    def load_balancer_resource_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "load_balancer_resource_id", value)

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[pulumi.Input['PrivateIPAddressArgs']]:
        """
        Private IP address.
        """
        return pulumi.get(self, "private_ip_address")

    @private_ip_address.setter
    def private_ip_address(self, value: Optional[pulumi.Input['PrivateIPAddressArgs']]):
        pulumi.set(self, "private_ip_address", value)

    @property
    @pulumi.getter(name="probePort")
    def probe_port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Probe port.
        """
        return pulumi.get(self, "probe_port")

    @probe_port.setter
    def probe_port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "probe_port", value)

    @property
    @pulumi.getter(name="publicIpAddressResourceId")
    def public_ip_address_resource_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource id of the public IP.
        """
        return pulumi.get(self, "public_ip_address_resource_id")

    @public_ip_address_resource_id.setter
    def public_ip_address_resource_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "public_ip_address_resource_id", value)

    @property
    @pulumi.getter(name="sqlVirtualMachineInstances")
    def sql_virtual_machine_instances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of the SQL virtual machine instance resource id's that are enrolled into the availability group listener.
        """
        return pulumi.get(self, "sql_virtual_machine_instances")

    @sql_virtual_machine_instances.setter
    def sql_virtual_machine_instances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "sql_virtual_machine_instances", value)


if not MYPY:
    class MultiSubnetIpConfigurationArgsDict(TypedDict):
        """
        Multi subnet ip configuration for an availability group listener.
        """
        private_ip_address: pulumi.Input['PrivateIPAddressArgsDict']
        """
        Private IP address.
        """
        sql_virtual_machine_instance: pulumi.Input[builtins.str]
        """
        SQL virtual machine instance resource id that are enrolled into the availability group listener.
        """
elif False:
    MultiSubnetIpConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultiSubnetIpConfigurationArgs:
    def __init__(__self__, *,
                 private_ip_address: pulumi.Input['PrivateIPAddressArgs'],
                 sql_virtual_machine_instance: pulumi.Input[builtins.str]):
        """
        Multi subnet ip configuration for an availability group listener.
        :param pulumi.Input['PrivateIPAddressArgs'] private_ip_address: Private IP address.
        :param pulumi.Input[builtins.str] sql_virtual_machine_instance: SQL virtual machine instance resource id that are enrolled into the availability group listener.
        """
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        pulumi.set(__self__, "sql_virtual_machine_instance", sql_virtual_machine_instance)

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> pulumi.Input['PrivateIPAddressArgs']:
        """
        Private IP address.
        """
        return pulumi.get(self, "private_ip_address")

    @private_ip_address.setter
    def private_ip_address(self, value: pulumi.Input['PrivateIPAddressArgs']):
        pulumi.set(self, "private_ip_address", value)

    @property
    @pulumi.getter(name="sqlVirtualMachineInstance")
    def sql_virtual_machine_instance(self) -> pulumi.Input[builtins.str]:
        """
        SQL virtual machine instance resource id that are enrolled into the availability group listener.
        """
        return pulumi.get(self, "sql_virtual_machine_instance")

    @sql_virtual_machine_instance.setter
    def sql_virtual_machine_instance(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "sql_virtual_machine_instance", value)


if not MYPY:
    class PrivateIPAddressArgsDict(TypedDict):
        """
        A private IP address bound to the availability group listener.
        """
        ip_address: NotRequired[pulumi.Input[builtins.str]]
        """
        Private IP address bound to the availability group listener.
        """
        subnet_resource_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Subnet used to include private IP.
        """
elif False:
    PrivateIPAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateIPAddressArgs:
    def __init__(__self__, *,
                 ip_address: Optional[pulumi.Input[builtins.str]] = None,
                 subnet_resource_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        A private IP address bound to the availability group listener.
        :param pulumi.Input[builtins.str] ip_address: Private IP address bound to the availability group listener.
        :param pulumi.Input[builtins.str] subnet_resource_id: Subnet used to include private IP.
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if subnet_resource_id is not None:
            pulumi.set(__self__, "subnet_resource_id", subnet_resource_id)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Private IP address bound to the availability group listener.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="subnetResourceId")
    def subnet_resource_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Subnet used to include private IP.
        """
        return pulumi.get(self, "subnet_resource_id")

    @subnet_resource_id.setter
    def subnet_resource_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subnet_resource_id", value)


if not MYPY:
    class ResourceIdentityArgsDict(TypedDict):
        """
        Azure Active Directory identity configuration for a resource.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'IdentityType']]]
        """
        The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory principal for the resource.
        """
elif False:
    ResourceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceIdentityArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[Union[builtins.str, 'IdentityType']]] = None):
        """
        Azure Active Directory identity configuration for a resource.
        :param pulumi.Input[Union[builtins.str, 'IdentityType']] type: The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory principal for the resource.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'IdentityType']]]:
        """
        The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory principal for the resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'IdentityType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SQLInstanceSettingsArgsDict(TypedDict):
        """
        Set the server/instance-level settings for SQL Server.
        """
        collation: NotRequired[pulumi.Input[builtins.str]]
        """
        SQL Server Collation.
        """
        is_ifi_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        SQL Server IFI.
        """
        is_lpim_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        SQL Server LPIM.
        """
        is_optimize_for_ad_hoc_workloads_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        SQL Server Optimize for Adhoc workloads.
        """
        max_dop: NotRequired[pulumi.Input[builtins.int]]
        """
        SQL Server MAXDOP.
        """
        max_server_memory_mb: NotRequired[pulumi.Input[builtins.int]]
        """
        SQL Server maximum memory.
        """
        min_server_memory_mb: NotRequired[pulumi.Input[builtins.int]]
        """
        SQL Server minimum memory.
        """
elif False:
    SQLInstanceSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SQLInstanceSettingsArgs:
    def __init__(__self__, *,
                 collation: Optional[pulumi.Input[builtins.str]] = None,
                 is_ifi_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 is_lpim_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 is_optimize_for_ad_hoc_workloads_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 max_dop: Optional[pulumi.Input[builtins.int]] = None,
                 max_server_memory_mb: Optional[pulumi.Input[builtins.int]] = None,
                 min_server_memory_mb: Optional[pulumi.Input[builtins.int]] = None):
        """
        Set the server/instance-level settings for SQL Server.
        :param pulumi.Input[builtins.str] collation: SQL Server Collation.
        :param pulumi.Input[builtins.bool] is_ifi_enabled: SQL Server IFI.
        :param pulumi.Input[builtins.bool] is_lpim_enabled: SQL Server LPIM.
        :param pulumi.Input[builtins.bool] is_optimize_for_ad_hoc_workloads_enabled: SQL Server Optimize for Adhoc workloads.
        :param pulumi.Input[builtins.int] max_dop: SQL Server MAXDOP.
        :param pulumi.Input[builtins.int] max_server_memory_mb: SQL Server maximum memory.
        :param pulumi.Input[builtins.int] min_server_memory_mb: SQL Server minimum memory.
        """
        if collation is not None:
            pulumi.set(__self__, "collation", collation)
        if is_ifi_enabled is not None:
            pulumi.set(__self__, "is_ifi_enabled", is_ifi_enabled)
        if is_lpim_enabled is not None:
            pulumi.set(__self__, "is_lpim_enabled", is_lpim_enabled)
        if is_optimize_for_ad_hoc_workloads_enabled is not None:
            pulumi.set(__self__, "is_optimize_for_ad_hoc_workloads_enabled", is_optimize_for_ad_hoc_workloads_enabled)
        if max_dop is not None:
            pulumi.set(__self__, "max_dop", max_dop)
        if max_server_memory_mb is not None:
            pulumi.set(__self__, "max_server_memory_mb", max_server_memory_mb)
        if min_server_memory_mb is not None:
            pulumi.set(__self__, "min_server_memory_mb", min_server_memory_mb)

    @property
    @pulumi.getter
    def collation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SQL Server Collation.
        """
        return pulumi.get(self, "collation")

    @collation.setter
    def collation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "collation", value)

    @property
    @pulumi.getter(name="isIfiEnabled")
    def is_ifi_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        SQL Server IFI.
        """
        return pulumi.get(self, "is_ifi_enabled")

    @is_ifi_enabled.setter
    def is_ifi_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_ifi_enabled", value)

    @property
    @pulumi.getter(name="isLpimEnabled")
    def is_lpim_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        SQL Server LPIM.
        """
        return pulumi.get(self, "is_lpim_enabled")

    @is_lpim_enabled.setter
    def is_lpim_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_lpim_enabled", value)

    @property
    @pulumi.getter(name="isOptimizeForAdHocWorkloadsEnabled")
    def is_optimize_for_ad_hoc_workloads_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        SQL Server Optimize for Adhoc workloads.
        """
        return pulumi.get(self, "is_optimize_for_ad_hoc_workloads_enabled")

    @is_optimize_for_ad_hoc_workloads_enabled.setter
    def is_optimize_for_ad_hoc_workloads_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_optimize_for_ad_hoc_workloads_enabled", value)

    @property
    @pulumi.getter(name="maxDop")
    def max_dop(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        SQL Server MAXDOP.
        """
        return pulumi.get(self, "max_dop")

    @max_dop.setter
    def max_dop(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_dop", value)

    @property
    @pulumi.getter(name="maxServerMemoryMB")
    def max_server_memory_mb(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        SQL Server maximum memory.
        """
        return pulumi.get(self, "max_server_memory_mb")

    @max_server_memory_mb.setter
    def max_server_memory_mb(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_server_memory_mb", value)

    @property
    @pulumi.getter(name="minServerMemoryMB")
    def min_server_memory_mb(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        SQL Server minimum memory.
        """
        return pulumi.get(self, "min_server_memory_mb")

    @min_server_memory_mb.setter
    def min_server_memory_mb(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_server_memory_mb", value)


if not MYPY:
    class SQLStorageSettingsArgsDict(TypedDict):
        """
        Set disk storage settings for SQL Server.
        """
        default_file_path: NotRequired[pulumi.Input[builtins.str]]
        """
        SQL Server default file path
        """
        luns: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        Logical Unit Numbers for the disks.
        """
        use_storage_pool: NotRequired[pulumi.Input[builtins.bool]]
        """
        Use storage pool to build a drive if true or not provided
        """
elif False:
    SQLStorageSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SQLStorageSettingsArgs:
    def __init__(__self__, *,
                 default_file_path: Optional[pulumi.Input[builtins.str]] = None,
                 luns: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 use_storage_pool: Optional[pulumi.Input[builtins.bool]] = None):
        """
        Set disk storage settings for SQL Server.
        :param pulumi.Input[builtins.str] default_file_path: SQL Server default file path
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] luns: Logical Unit Numbers for the disks.
        :param pulumi.Input[builtins.bool] use_storage_pool: Use storage pool to build a drive if true or not provided
        """
        if default_file_path is not None:
            pulumi.set(__self__, "default_file_path", default_file_path)
        if luns is not None:
            pulumi.set(__self__, "luns", luns)
        if use_storage_pool is not None:
            pulumi.set(__self__, "use_storage_pool", use_storage_pool)

    @property
    @pulumi.getter(name="defaultFilePath")
    def default_file_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SQL Server default file path
        """
        return pulumi.get(self, "default_file_path")

    @default_file_path.setter
    def default_file_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_file_path", value)

    @property
    @pulumi.getter
    def luns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        Logical Unit Numbers for the disks.
        """
        return pulumi.get(self, "luns")

    @luns.setter
    def luns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "luns", value)

    @property
    @pulumi.getter(name="useStoragePool")
    def use_storage_pool(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Use storage pool to build a drive if true or not provided
        """
        return pulumi.get(self, "use_storage_pool")

    @use_storage_pool.setter
    def use_storage_pool(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_storage_pool", value)


if not MYPY:
    class SQLTempDbSettingsArgsDict(TypedDict):
        """
        Set tempDb storage settings for SQL Server.
        """
        data_file_count: NotRequired[pulumi.Input[builtins.int]]
        """
        SQL Server tempdb data file count
        """
        data_file_size: NotRequired[pulumi.Input[builtins.int]]
        """
        SQL Server tempdb data file size
        """
        data_growth: NotRequired[pulumi.Input[builtins.int]]
        """
        SQL Server tempdb data file autoGrowth size
        """
        default_file_path: NotRequired[pulumi.Input[builtins.str]]
        """
        SQL Server default file path
        """
        log_file_size: NotRequired[pulumi.Input[builtins.int]]
        """
        SQL Server tempdb log file size
        """
        log_growth: NotRequired[pulumi.Input[builtins.int]]
        """
        SQL Server tempdb log file autoGrowth size
        """
        luns: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        Logical Unit Numbers for the disks.
        """
        persist_folder: NotRequired[pulumi.Input[builtins.bool]]
        """
        SQL Server tempdb persist folder choice
        """
        persist_folder_path: NotRequired[pulumi.Input[builtins.str]]
        """
        SQL Server tempdb persist folder location
        """
        use_storage_pool: NotRequired[pulumi.Input[builtins.bool]]
        """
        Use storage pool to build a drive if true or not provided
        """
elif False:
    SQLTempDbSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SQLTempDbSettingsArgs:
    def __init__(__self__, *,
                 data_file_count: Optional[pulumi.Input[builtins.int]] = None,
                 data_file_size: Optional[pulumi.Input[builtins.int]] = None,
                 data_growth: Optional[pulumi.Input[builtins.int]] = None,
                 default_file_path: Optional[pulumi.Input[builtins.str]] = None,
                 log_file_size: Optional[pulumi.Input[builtins.int]] = None,
                 log_growth: Optional[pulumi.Input[builtins.int]] = None,
                 luns: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 persist_folder: Optional[pulumi.Input[builtins.bool]] = None,
                 persist_folder_path: Optional[pulumi.Input[builtins.str]] = None,
                 use_storage_pool: Optional[pulumi.Input[builtins.bool]] = None):
        """
        Set tempDb storage settings for SQL Server.
        :param pulumi.Input[builtins.int] data_file_count: SQL Server tempdb data file count
        :param pulumi.Input[builtins.int] data_file_size: SQL Server tempdb data file size
        :param pulumi.Input[builtins.int] data_growth: SQL Server tempdb data file autoGrowth size
        :param pulumi.Input[builtins.str] default_file_path: SQL Server default file path
        :param pulumi.Input[builtins.int] log_file_size: SQL Server tempdb log file size
        :param pulumi.Input[builtins.int] log_growth: SQL Server tempdb log file autoGrowth size
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] luns: Logical Unit Numbers for the disks.
        :param pulumi.Input[builtins.bool] persist_folder: SQL Server tempdb persist folder choice
        :param pulumi.Input[builtins.str] persist_folder_path: SQL Server tempdb persist folder location
        :param pulumi.Input[builtins.bool] use_storage_pool: Use storage pool to build a drive if true or not provided
        """
        if data_file_count is not None:
            pulumi.set(__self__, "data_file_count", data_file_count)
        if data_file_size is not None:
            pulumi.set(__self__, "data_file_size", data_file_size)
        if data_growth is not None:
            pulumi.set(__self__, "data_growth", data_growth)
        if default_file_path is not None:
            pulumi.set(__self__, "default_file_path", default_file_path)
        if log_file_size is not None:
            pulumi.set(__self__, "log_file_size", log_file_size)
        if log_growth is not None:
            pulumi.set(__self__, "log_growth", log_growth)
        if luns is not None:
            pulumi.set(__self__, "luns", luns)
        if persist_folder is not None:
            pulumi.set(__self__, "persist_folder", persist_folder)
        if persist_folder_path is not None:
            pulumi.set(__self__, "persist_folder_path", persist_folder_path)
        if use_storage_pool is not None:
            pulumi.set(__self__, "use_storage_pool", use_storage_pool)

    @property
    @pulumi.getter(name="dataFileCount")
    def data_file_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        SQL Server tempdb data file count
        """
        return pulumi.get(self, "data_file_count")

    @data_file_count.setter
    def data_file_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "data_file_count", value)

    @property
    @pulumi.getter(name="dataFileSize")
    def data_file_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        SQL Server tempdb data file size
        """
        return pulumi.get(self, "data_file_size")

    @data_file_size.setter
    def data_file_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "data_file_size", value)

    @property
    @pulumi.getter(name="dataGrowth")
    def data_growth(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        SQL Server tempdb data file autoGrowth size
        """
        return pulumi.get(self, "data_growth")

    @data_growth.setter
    def data_growth(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "data_growth", value)

    @property
    @pulumi.getter(name="defaultFilePath")
    def default_file_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SQL Server default file path
        """
        return pulumi.get(self, "default_file_path")

    @default_file_path.setter
    def default_file_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_file_path", value)

    @property
    @pulumi.getter(name="logFileSize")
    def log_file_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        SQL Server tempdb log file size
        """
        return pulumi.get(self, "log_file_size")

    @log_file_size.setter
    def log_file_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "log_file_size", value)

    @property
    @pulumi.getter(name="logGrowth")
    def log_growth(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        SQL Server tempdb log file autoGrowth size
        """
        return pulumi.get(self, "log_growth")

    @log_growth.setter
    def log_growth(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "log_growth", value)

    @property
    @pulumi.getter
    def luns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        Logical Unit Numbers for the disks.
        """
        return pulumi.get(self, "luns")

    @luns.setter
    def luns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "luns", value)

    @property
    @pulumi.getter(name="persistFolder")
    def persist_folder(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        SQL Server tempdb persist folder choice
        """
        return pulumi.get(self, "persist_folder")

    @persist_folder.setter
    def persist_folder(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "persist_folder", value)

    @property
    @pulumi.getter(name="persistFolderPath")
    def persist_folder_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SQL Server tempdb persist folder location
        """
        return pulumi.get(self, "persist_folder_path")

    @persist_folder_path.setter
    def persist_folder_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "persist_folder_path", value)

    @property
    @pulumi.getter(name="useStoragePool")
    def use_storage_pool(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Use storage pool to build a drive if true or not provided
        """
        return pulumi.get(self, "use_storage_pool")

    @use_storage_pool.setter
    def use_storage_pool(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_storage_pool", value)


if not MYPY:
    class ScheduleArgsDict(TypedDict):
        """
        Set assessment schedule for SQL Server.
        """
        day_of_week: NotRequired[pulumi.Input['AssessmentDayOfWeek']]
        """
        Day of the week to run assessment.
        """
        enable: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable assessment schedule on SQL virtual machine.
        """
        monthly_occurrence: NotRequired[pulumi.Input[builtins.int]]
        """
        Occurrence of the DayOfWeek day within a month to schedule assessment. Takes values: 1,2,3,4 and -1. Use -1 for last DayOfWeek day of the month
        """
        start_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Time of the day in HH:mm format. Eg. 17:30
        """
        weekly_interval: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of weeks to schedule between 2 assessment runs. Takes value from 1-6
        """
elif False:
    ScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleArgs:
    def __init__(__self__, *,
                 day_of_week: Optional[pulumi.Input['AssessmentDayOfWeek']] = None,
                 enable: Optional[pulumi.Input[builtins.bool]] = None,
                 monthly_occurrence: Optional[pulumi.Input[builtins.int]] = None,
                 start_time: Optional[pulumi.Input[builtins.str]] = None,
                 weekly_interval: Optional[pulumi.Input[builtins.int]] = None):
        """
        Set assessment schedule for SQL Server.
        :param pulumi.Input['AssessmentDayOfWeek'] day_of_week: Day of the week to run assessment.
        :param pulumi.Input[builtins.bool] enable: Enable or disable assessment schedule on SQL virtual machine.
        :param pulumi.Input[builtins.int] monthly_occurrence: Occurrence of the DayOfWeek day within a month to schedule assessment. Takes values: 1,2,3,4 and -1. Use -1 for last DayOfWeek day of the month
        :param pulumi.Input[builtins.str] start_time: Time of the day in HH:mm format. Eg. 17:30
        :param pulumi.Input[builtins.int] weekly_interval: Number of weeks to schedule between 2 assessment runs. Takes value from 1-6
        """
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if monthly_occurrence is not None:
            pulumi.set(__self__, "monthly_occurrence", monthly_occurrence)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if weekly_interval is not None:
            pulumi.set(__self__, "weekly_interval", weekly_interval)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input['AssessmentDayOfWeek']]:
        """
        Day of the week to run assessment.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input['AssessmentDayOfWeek']]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable assessment schedule on SQL virtual machine.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="monthlyOccurrence")
    def monthly_occurrence(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Occurrence of the DayOfWeek day within a month to schedule assessment. Takes values: 1,2,3,4 and -1. Use -1 for last DayOfWeek day of the month
        """
        return pulumi.get(self, "monthly_occurrence")

    @monthly_occurrence.setter
    def monthly_occurrence(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "monthly_occurrence", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time of the day in HH:mm format. Eg. 17:30
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="weeklyInterval")
    def weekly_interval(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of weeks to schedule between 2 assessment runs. Takes value from 1-6
        """
        return pulumi.get(self, "weekly_interval")

    @weekly_interval.setter
    def weekly_interval(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "weekly_interval", value)


if not MYPY:
    class ServerConfigurationsManagementSettingsArgsDict(TypedDict):
        """
        Set the connectivity, storage and workload settings.
        """
        additional_features_server_configurations: NotRequired[pulumi.Input['AdditionalFeaturesServerConfigurationsArgsDict']]
        """
        Additional SQL feature settings.
        """
        azure_ad_authentication_settings: NotRequired[pulumi.Input['AADAuthenticationSettingsArgsDict']]
        """
        Azure AD authentication Settings.
        """
        sql_connectivity_update_settings: NotRequired[pulumi.Input['SqlConnectivityUpdateSettingsArgsDict']]
        """
        SQL connectivity type settings.
        """
        sql_instance_settings: NotRequired[pulumi.Input['SQLInstanceSettingsArgsDict']]
        """
        SQL Instance settings.
        """
        sql_storage_update_settings: NotRequired[pulumi.Input['SqlStorageUpdateSettingsArgsDict']]
        """
        SQL storage update settings.
        """
        sql_workload_type_update_settings: NotRequired[pulumi.Input['SqlWorkloadTypeUpdateSettingsArgsDict']]
        """
        SQL workload type settings.
        """
elif False:
    ServerConfigurationsManagementSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerConfigurationsManagementSettingsArgs:
    def __init__(__self__, *,
                 additional_features_server_configurations: Optional[pulumi.Input['AdditionalFeaturesServerConfigurationsArgs']] = None,
                 azure_ad_authentication_settings: Optional[pulumi.Input['AADAuthenticationSettingsArgs']] = None,
                 sql_connectivity_update_settings: Optional[pulumi.Input['SqlConnectivityUpdateSettingsArgs']] = None,
                 sql_instance_settings: Optional[pulumi.Input['SQLInstanceSettingsArgs']] = None,
                 sql_storage_update_settings: Optional[pulumi.Input['SqlStorageUpdateSettingsArgs']] = None,
                 sql_workload_type_update_settings: Optional[pulumi.Input['SqlWorkloadTypeUpdateSettingsArgs']] = None):
        """
        Set the connectivity, storage and workload settings.
        :param pulumi.Input['AdditionalFeaturesServerConfigurationsArgs'] additional_features_server_configurations: Additional SQL feature settings.
        :param pulumi.Input['AADAuthenticationSettingsArgs'] azure_ad_authentication_settings: Azure AD authentication Settings.
        :param pulumi.Input['SqlConnectivityUpdateSettingsArgs'] sql_connectivity_update_settings: SQL connectivity type settings.
        :param pulumi.Input['SQLInstanceSettingsArgs'] sql_instance_settings: SQL Instance settings.
        :param pulumi.Input['SqlStorageUpdateSettingsArgs'] sql_storage_update_settings: SQL storage update settings.
        :param pulumi.Input['SqlWorkloadTypeUpdateSettingsArgs'] sql_workload_type_update_settings: SQL workload type settings.
        """
        if additional_features_server_configurations is not None:
            pulumi.set(__self__, "additional_features_server_configurations", additional_features_server_configurations)
        if azure_ad_authentication_settings is not None:
            pulumi.set(__self__, "azure_ad_authentication_settings", azure_ad_authentication_settings)
        if sql_connectivity_update_settings is not None:
            pulumi.set(__self__, "sql_connectivity_update_settings", sql_connectivity_update_settings)
        if sql_instance_settings is not None:
            pulumi.set(__self__, "sql_instance_settings", sql_instance_settings)
        if sql_storage_update_settings is not None:
            pulumi.set(__self__, "sql_storage_update_settings", sql_storage_update_settings)
        if sql_workload_type_update_settings is not None:
            pulumi.set(__self__, "sql_workload_type_update_settings", sql_workload_type_update_settings)

    @property
    @pulumi.getter(name="additionalFeaturesServerConfigurations")
    def additional_features_server_configurations(self) -> Optional[pulumi.Input['AdditionalFeaturesServerConfigurationsArgs']]:
        """
        Additional SQL feature settings.
        """
        return pulumi.get(self, "additional_features_server_configurations")

    @additional_features_server_configurations.setter
    def additional_features_server_configurations(self, value: Optional[pulumi.Input['AdditionalFeaturesServerConfigurationsArgs']]):
        pulumi.set(self, "additional_features_server_configurations", value)

    @property
    @pulumi.getter(name="azureAdAuthenticationSettings")
    def azure_ad_authentication_settings(self) -> Optional[pulumi.Input['AADAuthenticationSettingsArgs']]:
        """
        Azure AD authentication Settings.
        """
        return pulumi.get(self, "azure_ad_authentication_settings")

    @azure_ad_authentication_settings.setter
    def azure_ad_authentication_settings(self, value: Optional[pulumi.Input['AADAuthenticationSettingsArgs']]):
        pulumi.set(self, "azure_ad_authentication_settings", value)

    @property
    @pulumi.getter(name="sqlConnectivityUpdateSettings")
    def sql_connectivity_update_settings(self) -> Optional[pulumi.Input['SqlConnectivityUpdateSettingsArgs']]:
        """
        SQL connectivity type settings.
        """
        return pulumi.get(self, "sql_connectivity_update_settings")

    @sql_connectivity_update_settings.setter
    def sql_connectivity_update_settings(self, value: Optional[pulumi.Input['SqlConnectivityUpdateSettingsArgs']]):
        pulumi.set(self, "sql_connectivity_update_settings", value)

    @property
    @pulumi.getter(name="sqlInstanceSettings")
    def sql_instance_settings(self) -> Optional[pulumi.Input['SQLInstanceSettingsArgs']]:
        """
        SQL Instance settings.
        """
        return pulumi.get(self, "sql_instance_settings")

    @sql_instance_settings.setter
    def sql_instance_settings(self, value: Optional[pulumi.Input['SQLInstanceSettingsArgs']]):
        pulumi.set(self, "sql_instance_settings", value)

    @property
    @pulumi.getter(name="sqlStorageUpdateSettings")
    def sql_storage_update_settings(self) -> Optional[pulumi.Input['SqlStorageUpdateSettingsArgs']]:
        """
        SQL storage update settings.
        """
        return pulumi.get(self, "sql_storage_update_settings")

    @sql_storage_update_settings.setter
    def sql_storage_update_settings(self, value: Optional[pulumi.Input['SqlStorageUpdateSettingsArgs']]):
        pulumi.set(self, "sql_storage_update_settings", value)

    @property
    @pulumi.getter(name="sqlWorkloadTypeUpdateSettings")
    def sql_workload_type_update_settings(self) -> Optional[pulumi.Input['SqlWorkloadTypeUpdateSettingsArgs']]:
        """
        SQL workload type settings.
        """
        return pulumi.get(self, "sql_workload_type_update_settings")

    @sql_workload_type_update_settings.setter
    def sql_workload_type_update_settings(self, value: Optional[pulumi.Input['SqlWorkloadTypeUpdateSettingsArgs']]):
        pulumi.set(self, "sql_workload_type_update_settings", value)


if not MYPY:
    class SqlConnectivityUpdateSettingsArgsDict(TypedDict):
        """
        Set the access level and network port settings for SQL Server.
        """
        connectivity_type: NotRequired[pulumi.Input[Union[builtins.str, 'ConnectivityType']]]
        """
        SQL Server connectivity option.
        """
        port: NotRequired[pulumi.Input[builtins.int]]
        """
        SQL Server port.
        """
        sql_auth_update_password: NotRequired[pulumi.Input[builtins.str]]
        """
        SQL Server sysadmin login password.
        """
        sql_auth_update_user_name: NotRequired[pulumi.Input[builtins.str]]
        """
        SQL Server sysadmin login to create.
        """
elif False:
    SqlConnectivityUpdateSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlConnectivityUpdateSettingsArgs:
    def __init__(__self__, *,
                 connectivity_type: Optional[pulumi.Input[Union[builtins.str, 'ConnectivityType']]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 sql_auth_update_password: Optional[pulumi.Input[builtins.str]] = None,
                 sql_auth_update_user_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        Set the access level and network port settings for SQL Server.
        :param pulumi.Input[Union[builtins.str, 'ConnectivityType']] connectivity_type: SQL Server connectivity option.
        :param pulumi.Input[builtins.int] port: SQL Server port.
        :param pulumi.Input[builtins.str] sql_auth_update_password: SQL Server sysadmin login password.
        :param pulumi.Input[builtins.str] sql_auth_update_user_name: SQL Server sysadmin login to create.
        """
        if connectivity_type is not None:
            pulumi.set(__self__, "connectivity_type", connectivity_type)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if sql_auth_update_password is not None:
            pulumi.set(__self__, "sql_auth_update_password", sql_auth_update_password)
        if sql_auth_update_user_name is not None:
            pulumi.set(__self__, "sql_auth_update_user_name", sql_auth_update_user_name)

    @property
    @pulumi.getter(name="connectivityType")
    def connectivity_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'ConnectivityType']]]:
        """
        SQL Server connectivity option.
        """
        return pulumi.get(self, "connectivity_type")

    @connectivity_type.setter
    def connectivity_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'ConnectivityType']]]):
        pulumi.set(self, "connectivity_type", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        SQL Server port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sqlAuthUpdatePassword")
    def sql_auth_update_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SQL Server sysadmin login password.
        """
        return pulumi.get(self, "sql_auth_update_password")

    @sql_auth_update_password.setter
    def sql_auth_update_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sql_auth_update_password", value)

    @property
    @pulumi.getter(name="sqlAuthUpdateUserName")
    def sql_auth_update_user_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SQL Server sysadmin login to create.
        """
        return pulumi.get(self, "sql_auth_update_user_name")

    @sql_auth_update_user_name.setter
    def sql_auth_update_user_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sql_auth_update_user_name", value)


if not MYPY:
    class SqlStorageUpdateSettingsArgsDict(TypedDict):
        """
        Set disk storage settings for SQL Server.
        """
        disk_configuration_type: NotRequired[pulumi.Input[Union[builtins.str, 'DiskConfigurationType']]]
        """
        Disk configuration to apply to SQL Server.
        """
        disk_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Virtual machine disk count.
        """
        starting_device_id: NotRequired[pulumi.Input[builtins.int]]
        """
        Device id of the first disk to be updated.
        """
elif False:
    SqlStorageUpdateSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlStorageUpdateSettingsArgs:
    def __init__(__self__, *,
                 disk_configuration_type: Optional[pulumi.Input[Union[builtins.str, 'DiskConfigurationType']]] = None,
                 disk_count: Optional[pulumi.Input[builtins.int]] = None,
                 starting_device_id: Optional[pulumi.Input[builtins.int]] = None):
        """
        Set disk storage settings for SQL Server.
        :param pulumi.Input[Union[builtins.str, 'DiskConfigurationType']] disk_configuration_type: Disk configuration to apply to SQL Server.
        :param pulumi.Input[builtins.int] disk_count: Virtual machine disk count.
        :param pulumi.Input[builtins.int] starting_device_id: Device id of the first disk to be updated.
        """
        if disk_configuration_type is not None:
            pulumi.set(__self__, "disk_configuration_type", disk_configuration_type)
        if disk_count is not None:
            pulumi.set(__self__, "disk_count", disk_count)
        if starting_device_id is not None:
            pulumi.set(__self__, "starting_device_id", starting_device_id)

    @property
    @pulumi.getter(name="diskConfigurationType")
    def disk_configuration_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'DiskConfigurationType']]]:
        """
        Disk configuration to apply to SQL Server.
        """
        return pulumi.get(self, "disk_configuration_type")

    @disk_configuration_type.setter
    def disk_configuration_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'DiskConfigurationType']]]):
        pulumi.set(self, "disk_configuration_type", value)

    @property
    @pulumi.getter(name="diskCount")
    def disk_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Virtual machine disk count.
        """
        return pulumi.get(self, "disk_count")

    @disk_count.setter
    def disk_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "disk_count", value)

    @property
    @pulumi.getter(name="startingDeviceId")
    def starting_device_id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Device id of the first disk to be updated.
        """
        return pulumi.get(self, "starting_device_id")

    @starting_device_id.setter
    def starting_device_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "starting_device_id", value)


if not MYPY:
    class SqlWorkloadTypeUpdateSettingsArgsDict(TypedDict):
        """
        Set workload type to optimize storage for SQL Server.
        """
        sql_workload_type: NotRequired[pulumi.Input[Union[builtins.str, 'SqlWorkloadType']]]
        """
        SQL Server workload type.
        """
elif False:
    SqlWorkloadTypeUpdateSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlWorkloadTypeUpdateSettingsArgs:
    def __init__(__self__, *,
                 sql_workload_type: Optional[pulumi.Input[Union[builtins.str, 'SqlWorkloadType']]] = None):
        """
        Set workload type to optimize storage for SQL Server.
        :param pulumi.Input[Union[builtins.str, 'SqlWorkloadType']] sql_workload_type: SQL Server workload type.
        """
        if sql_workload_type is not None:
            pulumi.set(__self__, "sql_workload_type", sql_workload_type)

    @property
    @pulumi.getter(name="sqlWorkloadType")
    def sql_workload_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'SqlWorkloadType']]]:
        """
        SQL Server workload type.
        """
        return pulumi.get(self, "sql_workload_type")

    @sql_workload_type.setter
    def sql_workload_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'SqlWorkloadType']]]):
        pulumi.set(self, "sql_workload_type", value)


if not MYPY:
    class StorageConfigurationSettingsArgsDict(TypedDict):
        """
        Storage Configurations for SQL Data, Log and TempDb.
        """
        disk_configuration_type: NotRequired[pulumi.Input[Union[builtins.str, 'DiskConfigurationType']]]
        """
        Disk configuration to apply to SQL Server.
        """
        enable_storage_config_blade: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable SQL IaaS Agent storage configuration blade in Azure Portal.
        """
        sql_data_settings: NotRequired[pulumi.Input['SQLStorageSettingsArgsDict']]
        """
        SQL Server Data Storage Settings.
        """
        sql_log_settings: NotRequired[pulumi.Input['SQLStorageSettingsArgsDict']]
        """
        SQL Server Log Storage Settings.
        """
        sql_system_db_on_data_disk: NotRequired[pulumi.Input[builtins.bool]]
        """
        SQL Server SystemDb Storage on DataPool if true.
        """
        sql_temp_db_settings: NotRequired[pulumi.Input['SQLTempDbSettingsArgsDict']]
        """
        SQL Server TempDb Storage Settings.
        """
        storage_workload_type: NotRequired[pulumi.Input[Union[builtins.str, 'StorageWorkloadType']]]
        """
        Storage workload type.
        """
elif False:
    StorageConfigurationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageConfigurationSettingsArgs:
    def __init__(__self__, *,
                 disk_configuration_type: Optional[pulumi.Input[Union[builtins.str, 'DiskConfigurationType']]] = None,
                 enable_storage_config_blade: Optional[pulumi.Input[builtins.bool]] = None,
                 sql_data_settings: Optional[pulumi.Input['SQLStorageSettingsArgs']] = None,
                 sql_log_settings: Optional[pulumi.Input['SQLStorageSettingsArgs']] = None,
                 sql_system_db_on_data_disk: Optional[pulumi.Input[builtins.bool]] = None,
                 sql_temp_db_settings: Optional[pulumi.Input['SQLTempDbSettingsArgs']] = None,
                 storage_workload_type: Optional[pulumi.Input[Union[builtins.str, 'StorageWorkloadType']]] = None):
        """
        Storage Configurations for SQL Data, Log and TempDb.
        :param pulumi.Input[Union[builtins.str, 'DiskConfigurationType']] disk_configuration_type: Disk configuration to apply to SQL Server.
        :param pulumi.Input[builtins.bool] enable_storage_config_blade: Enable SQL IaaS Agent storage configuration blade in Azure Portal.
        :param pulumi.Input['SQLStorageSettingsArgs'] sql_data_settings: SQL Server Data Storage Settings.
        :param pulumi.Input['SQLStorageSettingsArgs'] sql_log_settings: SQL Server Log Storage Settings.
        :param pulumi.Input[builtins.bool] sql_system_db_on_data_disk: SQL Server SystemDb Storage on DataPool if true.
        :param pulumi.Input['SQLTempDbSettingsArgs'] sql_temp_db_settings: SQL Server TempDb Storage Settings.
        :param pulumi.Input[Union[builtins.str, 'StorageWorkloadType']] storage_workload_type: Storage workload type.
        """
        if disk_configuration_type is not None:
            pulumi.set(__self__, "disk_configuration_type", disk_configuration_type)
        if enable_storage_config_blade is None:
            enable_storage_config_blade = False
        if enable_storage_config_blade is not None:
            pulumi.set(__self__, "enable_storage_config_blade", enable_storage_config_blade)
        if sql_data_settings is not None:
            pulumi.set(__self__, "sql_data_settings", sql_data_settings)
        if sql_log_settings is not None:
            pulumi.set(__self__, "sql_log_settings", sql_log_settings)
        if sql_system_db_on_data_disk is not None:
            pulumi.set(__self__, "sql_system_db_on_data_disk", sql_system_db_on_data_disk)
        if sql_temp_db_settings is not None:
            pulumi.set(__self__, "sql_temp_db_settings", sql_temp_db_settings)
        if storage_workload_type is not None:
            pulumi.set(__self__, "storage_workload_type", storage_workload_type)

    @property
    @pulumi.getter(name="diskConfigurationType")
    def disk_configuration_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'DiskConfigurationType']]]:
        """
        Disk configuration to apply to SQL Server.
        """
        return pulumi.get(self, "disk_configuration_type")

    @disk_configuration_type.setter
    def disk_configuration_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'DiskConfigurationType']]]):
        pulumi.set(self, "disk_configuration_type", value)

    @property
    @pulumi.getter(name="enableStorageConfigBlade")
    def enable_storage_config_blade(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable SQL IaaS Agent storage configuration blade in Azure Portal.
        """
        return pulumi.get(self, "enable_storage_config_blade")

    @enable_storage_config_blade.setter
    def enable_storage_config_blade(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_storage_config_blade", value)

    @property
    @pulumi.getter(name="sqlDataSettings")
    def sql_data_settings(self) -> Optional[pulumi.Input['SQLStorageSettingsArgs']]:
        """
        SQL Server Data Storage Settings.
        """
        return pulumi.get(self, "sql_data_settings")

    @sql_data_settings.setter
    def sql_data_settings(self, value: Optional[pulumi.Input['SQLStorageSettingsArgs']]):
        pulumi.set(self, "sql_data_settings", value)

    @property
    @pulumi.getter(name="sqlLogSettings")
    def sql_log_settings(self) -> Optional[pulumi.Input['SQLStorageSettingsArgs']]:
        """
        SQL Server Log Storage Settings.
        """
        return pulumi.get(self, "sql_log_settings")

    @sql_log_settings.setter
    def sql_log_settings(self, value: Optional[pulumi.Input['SQLStorageSettingsArgs']]):
        pulumi.set(self, "sql_log_settings", value)

    @property
    @pulumi.getter(name="sqlSystemDbOnDataDisk")
    def sql_system_db_on_data_disk(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        SQL Server SystemDb Storage on DataPool if true.
        """
        return pulumi.get(self, "sql_system_db_on_data_disk")

    @sql_system_db_on_data_disk.setter
    def sql_system_db_on_data_disk(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "sql_system_db_on_data_disk", value)

    @property
    @pulumi.getter(name="sqlTempDbSettings")
    def sql_temp_db_settings(self) -> Optional[pulumi.Input['SQLTempDbSettingsArgs']]:
        """
        SQL Server TempDb Storage Settings.
        """
        return pulumi.get(self, "sql_temp_db_settings")

    @sql_temp_db_settings.setter
    def sql_temp_db_settings(self, value: Optional[pulumi.Input['SQLTempDbSettingsArgs']]):
        pulumi.set(self, "sql_temp_db_settings", value)

    @property
    @pulumi.getter(name="storageWorkloadType")
    def storage_workload_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'StorageWorkloadType']]]:
        """
        Storage workload type.
        """
        return pulumi.get(self, "storage_workload_type")

    @storage_workload_type.setter
    def storage_workload_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'StorageWorkloadType']]]):
        pulumi.set(self, "storage_workload_type", value)


if not MYPY:
    class VirtualMachineIdentityArgsDict(TypedDict):
        """
        Virtual Machine Identity details used for Sql IaaS extension configurations.
        """
        resource_id: NotRequired[pulumi.Input[builtins.str]]
        """
        ARM Resource Id of the identity. Only required when UserAssigned identity is selected.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'VmIdentityType']]]
        """
        Identity type of the virtual machine. Specify None to opt-out of Managed Identities.
        """
elif False:
    VirtualMachineIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineIdentityArgs:
    def __init__(__self__, *,
                 resource_id: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[Union[builtins.str, 'VmIdentityType']]] = None):
        """
        Virtual Machine Identity details used for Sql IaaS extension configurations.
        :param pulumi.Input[builtins.str] resource_id: ARM Resource Id of the identity. Only required when UserAssigned identity is selected.
        :param pulumi.Input[Union[builtins.str, 'VmIdentityType']] type: Identity type of the virtual machine. Specify None to opt-out of Managed Identities.
        """
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ARM Resource Id of the identity. Only required when UserAssigned identity is selected.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'VmIdentityType']]]:
        """
        Identity type of the virtual machine. Specify None to opt-out of Managed Identities.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'VmIdentityType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WsfcDomainCredentialsArgsDict(TypedDict):
        """
        Domain credentials for setting up Windows Server Failover Cluster for SQL availability group.
        """
        cluster_bootstrap_account_password: NotRequired[pulumi.Input[builtins.str]]
        """
        Cluster bootstrap account password.
        """
        cluster_operator_account_password: NotRequired[pulumi.Input[builtins.str]]
        """
        Cluster operator account password.
        """
        sql_service_account_password: NotRequired[pulumi.Input[builtins.str]]
        """
        SQL service account password.
        """
elif False:
    WsfcDomainCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WsfcDomainCredentialsArgs:
    def __init__(__self__, *,
                 cluster_bootstrap_account_password: Optional[pulumi.Input[builtins.str]] = None,
                 cluster_operator_account_password: Optional[pulumi.Input[builtins.str]] = None,
                 sql_service_account_password: Optional[pulumi.Input[builtins.str]] = None):
        """
        Domain credentials for setting up Windows Server Failover Cluster for SQL availability group.
        :param pulumi.Input[builtins.str] cluster_bootstrap_account_password: Cluster bootstrap account password.
        :param pulumi.Input[builtins.str] cluster_operator_account_password: Cluster operator account password.
        :param pulumi.Input[builtins.str] sql_service_account_password: SQL service account password.
        """
        if cluster_bootstrap_account_password is not None:
            pulumi.set(__self__, "cluster_bootstrap_account_password", cluster_bootstrap_account_password)
        if cluster_operator_account_password is not None:
            pulumi.set(__self__, "cluster_operator_account_password", cluster_operator_account_password)
        if sql_service_account_password is not None:
            pulumi.set(__self__, "sql_service_account_password", sql_service_account_password)

    @property
    @pulumi.getter(name="clusterBootstrapAccountPassword")
    def cluster_bootstrap_account_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Cluster bootstrap account password.
        """
        return pulumi.get(self, "cluster_bootstrap_account_password")

    @cluster_bootstrap_account_password.setter
    def cluster_bootstrap_account_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_bootstrap_account_password", value)

    @property
    @pulumi.getter(name="clusterOperatorAccountPassword")
    def cluster_operator_account_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Cluster operator account password.
        """
        return pulumi.get(self, "cluster_operator_account_password")

    @cluster_operator_account_password.setter
    def cluster_operator_account_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_operator_account_password", value)

    @property
    @pulumi.getter(name="sqlServiceAccountPassword")
    def sql_service_account_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SQL service account password.
        """
        return pulumi.get(self, "sql_service_account_password")

    @sql_service_account_password.setter
    def sql_service_account_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sql_service_account_password", value)


if not MYPY:
    class WsfcDomainProfileArgsDict(TypedDict):
        """
        Active Directory account details to operate Windows Server Failover Cluster.
        """
        cluster_bootstrap_account: NotRequired[pulumi.Input[builtins.str]]
        """
        Account name used for creating cluster (at minimum needs permissions to 'Create Computer Objects' in domain).
        """
        cluster_operator_account: NotRequired[pulumi.Input[builtins.str]]
        """
        Account name used for operating cluster i.e. will be part of administrators group on all the participating virtual machines in the cluster.
        """
        cluster_subnet_type: NotRequired[pulumi.Input[Union[builtins.str, 'ClusterSubnetType']]]
        """
        Cluster subnet type.
        """
        domain_fqdn: NotRequired[pulumi.Input[builtins.str]]
        """
        Fully qualified name of the domain.
        """
        file_share_witness_path: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional path for fileshare witness.
        """
        is_sql_service_account_gmsa: NotRequired[pulumi.Input[builtins.bool]]
        """
        The flag to check if SQL service account is GMSA.
        """
        ou_path: NotRequired[pulumi.Input[builtins.str]]
        """
        Organizational Unit path in which the nodes and cluster will be present.
        """
        sql_service_account: NotRequired[pulumi.Input[builtins.str]]
        """
        Account name under which SQL service will run on all participating SQL virtual machines in the cluster.
        """
        storage_account_primary_key: NotRequired[pulumi.Input[builtins.str]]
        """
        Primary key of the witness storage account.
        """
        storage_account_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Fully qualified ARM resource id of the witness storage account.
        """
elif False:
    WsfcDomainProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WsfcDomainProfileArgs:
    def __init__(__self__, *,
                 cluster_bootstrap_account: Optional[pulumi.Input[builtins.str]] = None,
                 cluster_operator_account: Optional[pulumi.Input[builtins.str]] = None,
                 cluster_subnet_type: Optional[pulumi.Input[Union[builtins.str, 'ClusterSubnetType']]] = None,
                 domain_fqdn: Optional[pulumi.Input[builtins.str]] = None,
                 file_share_witness_path: Optional[pulumi.Input[builtins.str]] = None,
                 is_sql_service_account_gmsa: Optional[pulumi.Input[builtins.bool]] = None,
                 ou_path: Optional[pulumi.Input[builtins.str]] = None,
                 sql_service_account: Optional[pulumi.Input[builtins.str]] = None,
                 storage_account_primary_key: Optional[pulumi.Input[builtins.str]] = None,
                 storage_account_url: Optional[pulumi.Input[builtins.str]] = None):
        """
        Active Directory account details to operate Windows Server Failover Cluster.
        :param pulumi.Input[builtins.str] cluster_bootstrap_account: Account name used for creating cluster (at minimum needs permissions to 'Create Computer Objects' in domain).
        :param pulumi.Input[builtins.str] cluster_operator_account: Account name used for operating cluster i.e. will be part of administrators group on all the participating virtual machines in the cluster.
        :param pulumi.Input[Union[builtins.str, 'ClusterSubnetType']] cluster_subnet_type: Cluster subnet type.
        :param pulumi.Input[builtins.str] domain_fqdn: Fully qualified name of the domain.
        :param pulumi.Input[builtins.str] file_share_witness_path: Optional path for fileshare witness.
        :param pulumi.Input[builtins.bool] is_sql_service_account_gmsa: The flag to check if SQL service account is GMSA.
        :param pulumi.Input[builtins.str] ou_path: Organizational Unit path in which the nodes and cluster will be present.
        :param pulumi.Input[builtins.str] sql_service_account: Account name under which SQL service will run on all participating SQL virtual machines in the cluster.
        :param pulumi.Input[builtins.str] storage_account_primary_key: Primary key of the witness storage account.
        :param pulumi.Input[builtins.str] storage_account_url: Fully qualified ARM resource id of the witness storage account.
        """
        if cluster_bootstrap_account is not None:
            pulumi.set(__self__, "cluster_bootstrap_account", cluster_bootstrap_account)
        if cluster_operator_account is not None:
            pulumi.set(__self__, "cluster_operator_account", cluster_operator_account)
        if cluster_subnet_type is not None:
            pulumi.set(__self__, "cluster_subnet_type", cluster_subnet_type)
        if domain_fqdn is not None:
            pulumi.set(__self__, "domain_fqdn", domain_fqdn)
        if file_share_witness_path is not None:
            pulumi.set(__self__, "file_share_witness_path", file_share_witness_path)
        if is_sql_service_account_gmsa is not None:
            pulumi.set(__self__, "is_sql_service_account_gmsa", is_sql_service_account_gmsa)
        if ou_path is not None:
            pulumi.set(__self__, "ou_path", ou_path)
        if sql_service_account is not None:
            pulumi.set(__self__, "sql_service_account", sql_service_account)
        if storage_account_primary_key is not None:
            pulumi.set(__self__, "storage_account_primary_key", storage_account_primary_key)
        if storage_account_url is not None:
            pulumi.set(__self__, "storage_account_url", storage_account_url)

    @property
    @pulumi.getter(name="clusterBootstrapAccount")
    def cluster_bootstrap_account(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Account name used for creating cluster (at minimum needs permissions to 'Create Computer Objects' in domain).
        """
        return pulumi.get(self, "cluster_bootstrap_account")

    @cluster_bootstrap_account.setter
    def cluster_bootstrap_account(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_bootstrap_account", value)

    @property
    @pulumi.getter(name="clusterOperatorAccount")
    def cluster_operator_account(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Account name used for operating cluster i.e. will be part of administrators group on all the participating virtual machines in the cluster.
        """
        return pulumi.get(self, "cluster_operator_account")

    @cluster_operator_account.setter
    def cluster_operator_account(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_operator_account", value)

    @property
    @pulumi.getter(name="clusterSubnetType")
    def cluster_subnet_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'ClusterSubnetType']]]:
        """
        Cluster subnet type.
        """
        return pulumi.get(self, "cluster_subnet_type")

    @cluster_subnet_type.setter
    def cluster_subnet_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'ClusterSubnetType']]]):
        pulumi.set(self, "cluster_subnet_type", value)

    @property
    @pulumi.getter(name="domainFqdn")
    def domain_fqdn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Fully qualified name of the domain.
        """
        return pulumi.get(self, "domain_fqdn")

    @domain_fqdn.setter
    def domain_fqdn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "domain_fqdn", value)

    @property
    @pulumi.getter(name="fileShareWitnessPath")
    def file_share_witness_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional path for fileshare witness.
        """
        return pulumi.get(self, "file_share_witness_path")

    @file_share_witness_path.setter
    def file_share_witness_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "file_share_witness_path", value)

    @property
    @pulumi.getter(name="isSqlServiceAccountGmsa")
    def is_sql_service_account_gmsa(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        The flag to check if SQL service account is GMSA.
        """
        return pulumi.get(self, "is_sql_service_account_gmsa")

    @is_sql_service_account_gmsa.setter
    def is_sql_service_account_gmsa(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_sql_service_account_gmsa", value)

    @property
    @pulumi.getter(name="ouPath")
    def ou_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Organizational Unit path in which the nodes and cluster will be present.
        """
        return pulumi.get(self, "ou_path")

    @ou_path.setter
    def ou_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ou_path", value)

    @property
    @pulumi.getter(name="sqlServiceAccount")
    def sql_service_account(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Account name under which SQL service will run on all participating SQL virtual machines in the cluster.
        """
        return pulumi.get(self, "sql_service_account")

    @sql_service_account.setter
    def sql_service_account(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sql_service_account", value)

    @property
    @pulumi.getter(name="storageAccountPrimaryKey")
    def storage_account_primary_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Primary key of the witness storage account.
        """
        return pulumi.get(self, "storage_account_primary_key")

    @storage_account_primary_key.setter
    def storage_account_primary_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "storage_account_primary_key", value)

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Fully qualified ARM resource id of the witness storage account.
        """
        return pulumi.get(self, "storage_account_url")

    @storage_account_url.setter
    def storage_account_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "storage_account_url", value)


