# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AzureDataLakeSectionResponse',
    'AzureMySqlSectionResponse',
    'AzurePostgreSqlSectionResponse',
    'AzureSqlDatabaseSectionResponse',
    'AzureStorageSectionResponse',
    'ClientCredentialsResponse',
    'DatasetResponse',
    'DatasetResponseDataPath',
    'DatasetResponseLatest',
    'DatasetResponseSqlDataPath',
    'DatasetStateResponse',
    'DatasetStateResponseDeprecatedBy',
    'DatastoreResponse',
    'GlusterFsSectionResponse',
    'IdentityResponse',
    'LinkedInfoResponse',
    'SkuResponse',
    'UserAssignedIdentityResponse',
    'UserInfoResponse',
]

@pulumi.output_type
class AzureDataLakeSectionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorityUrl":
            suggest = "authority_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "credentialType":
            suggest = "credential_type"
        elif key == "isCertAuth":
            suggest = "is_cert_auth"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "resourceUri":
            suggest = "resource_uri"
        elif key == "serviceDataAccessAuthIdentity":
            suggest = "service_data_access_auth_identity"
        elif key == "storeName":
            suggest = "store_name"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureDataLakeSectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureDataLakeSectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureDataLakeSectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authority_url: Optional[str] = None,
                 certificate: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 credential_type: Optional[str] = None,
                 is_cert_auth: Optional[bool] = None,
                 resource_group: Optional[str] = None,
                 resource_uri: Optional[str] = None,
                 service_data_access_auth_identity: Optional[str] = None,
                 store_name: Optional[str] = None,
                 subscription_id: Optional[str] = None,
                 tenant_id: Optional[str] = None,
                 thumbprint: Optional[str] = None):
        """
        :param str authority_url: The authority URL used for authentication.
        :param str certificate: The content of the certificate used for authentication.
        :param str client_id: The Client ID/Application ID
        :param str client_secret: The client secret.
        :param str credential_type: The Azure Data Lake credential type.
        :param bool is_cert_auth:  Is it using certificate to authenticate. If false then use client secret.
        :param str resource_group: Resource Group.
        :param str resource_uri: The resource the service principal/app has access to.
        :param str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param str store_name: The Azure Data Lake store name.
        :param str subscription_id: Subscription ID.
        :param str tenant_id: The ID of the tenant the service principal/app belongs to.
        :param str thumbprint: The thumbprint of the certificate above.
        """
        if authority_url is not None:
            pulumi.set(__self__, "authority_url", authority_url)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if is_cert_auth is not None:
            pulumi.set(__self__, "is_cert_auth", is_cert_auth)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if resource_uri is not None:
            pulumi.set(__self__, "resource_uri", resource_uri)
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if store_name is not None:
            pulumi.set(__self__, "store_name", store_name)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)

    @property
    @pulumi.getter(name="authorityUrl")
    def authority_url(self) -> Optional[str]:
        """
        The authority URL used for authentication.
        """
        return pulumi.get(self, "authority_url")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        The content of the certificate used for authentication.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID/Application ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[str]:
        """
        The Azure Data Lake credential type.
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter(name="isCertAuth")
    def is_cert_auth(self) -> Optional[bool]:
        """
         Is it using certificate to authenticate. If false then use client secret.
        """
        return pulumi.get(self, "is_cert_auth")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[str]:
        """
        Resource Group.
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[str]:
        """
        The resource the service principal/app has access to.
        """
        return pulumi.get(self, "resource_uri")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> Optional[str]:
        """
        The Azure Data Lake store name.
        """
        return pulumi.get(self, "store_name")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        Subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The ID of the tenant the service principal/app belongs to.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[str]:
        """
        The thumbprint of the certificate above.
        """
        return pulumi.get(self, "thumbprint")


@pulumi.output_type
class AzureMySqlSectionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorityUrl":
            suggest = "authority_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "credentialType":
            suggest = "credential_type"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "isCertAuth":
            suggest = "is_cert_auth"
        elif key == "portNumber":
            suggest = "port_number"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "resourceUri":
            suggest = "resource_uri"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "serviceDataAccessAuthIdentity":
            suggest = "service_data_access_auth_identity"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userId":
            suggest = "user_id"
        elif key == "userPassword":
            suggest = "user_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureMySqlSectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureMySqlSectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureMySqlSectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authority_url: Optional[str] = None,
                 certificate: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 credential_type: Optional[str] = None,
                 database_name: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 is_cert_auth: Optional[bool] = None,
                 port_number: Optional[str] = None,
                 resource_group: Optional[str] = None,
                 resource_uri: Optional[str] = None,
                 server_name: Optional[str] = None,
                 service_data_access_auth_identity: Optional[str] = None,
                 subscription_id: Optional[str] = None,
                 tenant_id: Optional[str] = None,
                 thumbprint: Optional[str] = None,
                 user_id: Optional[str] = None,
                 user_password: Optional[str] = None):
        """
        :param str authority_url: The authority URL used for authentication.
        :param str certificate: The content of the certificate used for authentication.
        :param str client_id: The Client ID/Application ID
        :param str client_secret: The client secret.
        :param str credential_type: Sql Authentication type.
        :param str database_name: The Azure SQL database name.
        :param str endpoint: The server host endpoint.
        :param bool is_cert_auth:  Is it using certificate to authenticate. If false then use client secret.
        :param str port_number: / The Azure SQL port number.
        :param str resource_group: Resource Group.
        :param str resource_uri: The resource the service principal/app has access to.
        :param str server_name: The Azure SQL server name.
        :param str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param str subscription_id: Subscription ID.
        :param str tenant_id: The ID of the tenant the service principal/app belongs to.
        :param str thumbprint: The thumbprint of the certificate above.
        :param str user_id: The Azure SQL user id.
        :param str user_password: The Azure SQL user password.
        """
        if authority_url is not None:
            pulumi.set(__self__, "authority_url", authority_url)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if is_cert_auth is not None:
            pulumi.set(__self__, "is_cert_auth", is_cert_auth)
        if port_number is not None:
            pulumi.set(__self__, "port_number", port_number)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if resource_uri is not None:
            pulumi.set(__self__, "resource_uri", resource_uri)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if user_password is not None:
            pulumi.set(__self__, "user_password", user_password)

    @property
    @pulumi.getter(name="authorityUrl")
    def authority_url(self) -> Optional[str]:
        """
        The authority URL used for authentication.
        """
        return pulumi.get(self, "authority_url")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        The content of the certificate used for authentication.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID/Application ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[str]:
        """
        Sql Authentication type.
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The Azure SQL database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The server host endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="isCertAuth")
    def is_cert_auth(self) -> Optional[bool]:
        """
         Is it using certificate to authenticate. If false then use client secret.
        """
        return pulumi.get(self, "is_cert_auth")

    @property
    @pulumi.getter(name="portNumber")
    def port_number(self) -> Optional[str]:
        """
        / The Azure SQL port number.
        """
        return pulumi.get(self, "port_number")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[str]:
        """
        Resource Group.
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[str]:
        """
        The resource the service principal/app has access to.
        """
        return pulumi.get(self, "resource_uri")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        The Azure SQL server name.
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        Subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The ID of the tenant the service principal/app belongs to.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[str]:
        """
        The thumbprint of the certificate above.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        """
        The Azure SQL user id.
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter(name="userPassword")
    def user_password(self) -> Optional[str]:
        """
        The Azure SQL user password.
        """
        return pulumi.get(self, "user_password")


@pulumi.output_type
class AzurePostgreSqlSectionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorityUrl":
            suggest = "authority_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "credentialType":
            suggest = "credential_type"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "enableSsl":
            suggest = "enable_ssl"
        elif key == "isCertAuth":
            suggest = "is_cert_auth"
        elif key == "portNumber":
            suggest = "port_number"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "resourceUri":
            suggest = "resource_uri"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "serviceDataAccessAuthIdentity":
            suggest = "service_data_access_auth_identity"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userId":
            suggest = "user_id"
        elif key == "userPassword":
            suggest = "user_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzurePostgreSqlSectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzurePostgreSqlSectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzurePostgreSqlSectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authority_url: Optional[str] = None,
                 certificate: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 credential_type: Optional[str] = None,
                 database_name: Optional[str] = None,
                 enable_ssl: Optional[bool] = None,
                 endpoint: Optional[str] = None,
                 is_cert_auth: Optional[bool] = None,
                 port_number: Optional[str] = None,
                 resource_group: Optional[str] = None,
                 resource_uri: Optional[str] = None,
                 server_name: Optional[str] = None,
                 service_data_access_auth_identity: Optional[str] = None,
                 subscription_id: Optional[str] = None,
                 tenant_id: Optional[str] = None,
                 thumbprint: Optional[str] = None,
                 user_id: Optional[str] = None,
                 user_password: Optional[str] = None):
        """
        :param str authority_url: The authority URL used for authentication.
        :param str certificate: The content of the certificate used for authentication.
        :param str client_id: The Client ID/Application ID
        :param str client_secret: The client secret.
        :param str credential_type: Sql Authentication type.
        :param str database_name: The Azure SQL database name.
        :param bool enable_ssl: Indicates SSL requirement of Azure Postgresql server.
        :param str endpoint: The server host endpoint.
        :param bool is_cert_auth:  Is it using certificate to authenticate. If false then use client secret.
        :param str port_number: / The Azure SQL port number.
        :param str resource_group: Resource Group.
        :param str resource_uri: The resource the service principal/app has access to.
        :param str server_name: The Azure SQL server name.
        :param str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param str subscription_id: Subscription ID.
        :param str tenant_id: The ID of the tenant the service principal/app belongs to.
        :param str thumbprint: The thumbprint of the certificate above.
        :param str user_id: The Azure SQL user id.
        :param str user_password: The Azure SQL user password.
        """
        if authority_url is not None:
            pulumi.set(__self__, "authority_url", authority_url)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if enable_ssl is not None:
            pulumi.set(__self__, "enable_ssl", enable_ssl)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if is_cert_auth is not None:
            pulumi.set(__self__, "is_cert_auth", is_cert_auth)
        if port_number is not None:
            pulumi.set(__self__, "port_number", port_number)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if resource_uri is not None:
            pulumi.set(__self__, "resource_uri", resource_uri)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if user_password is not None:
            pulumi.set(__self__, "user_password", user_password)

    @property
    @pulumi.getter(name="authorityUrl")
    def authority_url(self) -> Optional[str]:
        """
        The authority URL used for authentication.
        """
        return pulumi.get(self, "authority_url")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        The content of the certificate used for authentication.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID/Application ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[str]:
        """
        Sql Authentication type.
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The Azure SQL database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="enableSsl")
    def enable_ssl(self) -> Optional[bool]:
        """
        Indicates SSL requirement of Azure Postgresql server.
        """
        return pulumi.get(self, "enable_ssl")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The server host endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="isCertAuth")
    def is_cert_auth(self) -> Optional[bool]:
        """
         Is it using certificate to authenticate. If false then use client secret.
        """
        return pulumi.get(self, "is_cert_auth")

    @property
    @pulumi.getter(name="portNumber")
    def port_number(self) -> Optional[str]:
        """
        / The Azure SQL port number.
        """
        return pulumi.get(self, "port_number")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[str]:
        """
        Resource Group.
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[str]:
        """
        The resource the service principal/app has access to.
        """
        return pulumi.get(self, "resource_uri")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        The Azure SQL server name.
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        Subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The ID of the tenant the service principal/app belongs to.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[str]:
        """
        The thumbprint of the certificate above.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        """
        The Azure SQL user id.
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter(name="userPassword")
    def user_password(self) -> Optional[str]:
        """
        The Azure SQL user password.
        """
        return pulumi.get(self, "user_password")


@pulumi.output_type
class AzureSqlDatabaseSectionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorityUrl":
            suggest = "authority_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "credentialType":
            suggest = "credential_type"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "isCertAuth":
            suggest = "is_cert_auth"
        elif key == "portNumber":
            suggest = "port_number"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "resourceUri":
            suggest = "resource_uri"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "serviceDataAccessAuthIdentity":
            suggest = "service_data_access_auth_identity"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userId":
            suggest = "user_id"
        elif key == "userPassword":
            suggest = "user_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureSqlDatabaseSectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureSqlDatabaseSectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureSqlDatabaseSectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authority_url: Optional[str] = None,
                 certificate: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 credential_type: Optional[str] = None,
                 database_name: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 is_cert_auth: Optional[bool] = None,
                 port_number: Optional[str] = None,
                 resource_group: Optional[str] = None,
                 resource_uri: Optional[str] = None,
                 server_name: Optional[str] = None,
                 service_data_access_auth_identity: Optional[str] = None,
                 subscription_id: Optional[str] = None,
                 tenant_id: Optional[str] = None,
                 thumbprint: Optional[str] = None,
                 user_id: Optional[str] = None,
                 user_password: Optional[str] = None):
        """
        :param str authority_url: The authority URL used for authentication.
        :param str certificate: The content of the certificate used for authentication.
        :param str client_id: The Client ID/Application ID
        :param str client_secret: The client secret.
        :param str credential_type: Sql Authentication type.
        :param str database_name: The Azure SQL database name.
        :param str endpoint: The server host endpoint.
        :param bool is_cert_auth:  Is it using certificate to authenticate. If false then use client secret.
        :param str port_number: / The Azure SQL port number.
        :param str resource_group: Resource Group.
        :param str resource_uri: The resource the service principal/app has access to.
        :param str server_name: The Azure SQL server name.
        :param str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param str subscription_id: Subscription ID.
        :param str tenant_id: The ID of the tenant the service principal/app belongs to.
        :param str thumbprint: The thumbprint of the certificate above.
        :param str user_id: The Azure SQL user id.
        :param str user_password: The Azure SQL user password.
        """
        if authority_url is not None:
            pulumi.set(__self__, "authority_url", authority_url)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if is_cert_auth is not None:
            pulumi.set(__self__, "is_cert_auth", is_cert_auth)
        if port_number is not None:
            pulumi.set(__self__, "port_number", port_number)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if resource_uri is not None:
            pulumi.set(__self__, "resource_uri", resource_uri)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if user_password is not None:
            pulumi.set(__self__, "user_password", user_password)

    @property
    @pulumi.getter(name="authorityUrl")
    def authority_url(self) -> Optional[str]:
        """
        The authority URL used for authentication.
        """
        return pulumi.get(self, "authority_url")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        The content of the certificate used for authentication.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID/Application ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[str]:
        """
        Sql Authentication type.
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The Azure SQL database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The server host endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="isCertAuth")
    def is_cert_auth(self) -> Optional[bool]:
        """
         Is it using certificate to authenticate. If false then use client secret.
        """
        return pulumi.get(self, "is_cert_auth")

    @property
    @pulumi.getter(name="portNumber")
    def port_number(self) -> Optional[str]:
        """
        / The Azure SQL port number.
        """
        return pulumi.get(self, "port_number")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[str]:
        """
        Resource Group.
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[str]:
        """
        The resource the service principal/app has access to.
        """
        return pulumi.get(self, "resource_uri")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        The Azure SQL server name.
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        Subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The ID of the tenant the service principal/app belongs to.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[str]:
        """
        The thumbprint of the certificate above.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        """
        The Azure SQL user id.
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter(name="userPassword")
    def user_password(self) -> Optional[str]:
        """
        The Azure SQL user password.
        """
        return pulumi.get(self, "user_password")


@pulumi.output_type
class AzureStorageSectionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountKey":
            suggest = "account_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "areWorkspaceManagedIdentitiesAllowed":
            suggest = "are_workspace_managed_identities_allowed"
        elif key == "blobCacheTimeout":
            suggest = "blob_cache_timeout"
        elif key == "clientCredentials":
            suggest = "client_credentials"
        elif key == "containerName":
            suggest = "container_name"
        elif key == "credentialType":
            suggest = "credential_type"
        elif key == "isSas":
            suggest = "is_sas"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "sasToken":
            suggest = "sas_token"
        elif key == "serviceDataAccessAuthIdentity":
            suggest = "service_data_access_auth_identity"
        elif key == "subscriptionId":
            suggest = "subscription_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureStorageSectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureStorageSectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureStorageSectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_key: Optional[str] = None,
                 account_name: Optional[str] = None,
                 are_workspace_managed_identities_allowed: Optional[bool] = None,
                 blob_cache_timeout: Optional[int] = None,
                 client_credentials: Optional['outputs.ClientCredentialsResponse'] = None,
                 container_name: Optional[str] = None,
                 credential: Optional[str] = None,
                 credential_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 is_sas: Optional[bool] = None,
                 protocol: Optional[str] = None,
                 resource_group: Optional[str] = None,
                 sas_token: Optional[str] = None,
                 service_data_access_auth_identity: Optional[str] = None,
                 subscription_id: Optional[str] = None):
        """
        :param str account_key:  Storage Account Key (Deprecated).
        :param str account_name: Storage Account Name.
        :param bool are_workspace_managed_identities_allowed: Indicate if we are using Workspace ManagedIdentities/MSI token (Deprecated).
        :param int blob_cache_timeout:  If this is an "DataStoreType.AzureBlob", the length of time (in seconds) to cache files locally after they are accessed (downloaded).
        :param str container_name: The storage container name.
        :param str credential: The credential.
        :param str credential_type:  The credential type.
        :param str endpoint: The host of the container.
        :param bool is_sas: Indicate if we are using SAS token or Account Key (Deprecated).
        :param str protocol: The protocol to use. Defaults to https.
        :param str resource_group: Resource Group.
        :param str sas_token:  SAS Token for the container (Deprecated).
        :param str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param str subscription_id: Subscription ID.
        """
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if are_workspace_managed_identities_allowed is not None:
            pulumi.set(__self__, "are_workspace_managed_identities_allowed", are_workspace_managed_identities_allowed)
        if blob_cache_timeout is not None:
            pulumi.set(__self__, "blob_cache_timeout", blob_cache_timeout)
        if client_credentials is not None:
            pulumi.set(__self__, "client_credentials", client_credentials)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if is_sas is not None:
            pulumi.set(__self__, "is_sas", is_sas)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[str]:
        """
         Storage Account Key (Deprecated).
        """
        return pulumi.get(self, "account_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[str]:
        """
        Storage Account Name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="areWorkspaceManagedIdentitiesAllowed")
    def are_workspace_managed_identities_allowed(self) -> Optional[bool]:
        """
        Indicate if we are using Workspace ManagedIdentities/MSI token (Deprecated).
        """
        return pulumi.get(self, "are_workspace_managed_identities_allowed")

    @property
    @pulumi.getter(name="blobCacheTimeout")
    def blob_cache_timeout(self) -> Optional[int]:
        """
         If this is an "DataStoreType.AzureBlob", the length of time (in seconds) to cache files locally after they are accessed (downloaded).
        """
        return pulumi.get(self, "blob_cache_timeout")

    @property
    @pulumi.getter(name="clientCredentials")
    def client_credentials(self) -> Optional['outputs.ClientCredentialsResponse']:
        return pulumi.get(self, "client_credentials")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        """
        The storage container name.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def credential(self) -> Optional[str]:
        """
        The credential.
        """
        return pulumi.get(self, "credential")

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[str]:
        """
         The credential type.
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The host of the container.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="isSas")
    def is_sas(self) -> Optional[bool]:
        """
        Indicate if we are using SAS token or Account Key (Deprecated).
        """
        return pulumi.get(self, "is_sas")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol to use. Defaults to https.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[str]:
        """
        Resource Group.
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional[str]:
        """
         SAS Token for the container (Deprecated).
        """
        return pulumi.get(self, "sas_token")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        Subscription ID.
        """
        return pulumi.get(self, "subscription_id")


@pulumi.output_type
class ClientCredentialsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorityUrl":
            suggest = "authority_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "isCertAuth":
            suggest = "is_cert_auth"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "resourceUri":
            suggest = "resource_uri"
        elif key == "serviceDataAccessAuthIdentity":
            suggest = "service_data_access_auth_identity"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authority_url: Optional[str] = None,
                 certificate: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 is_cert_auth: Optional[bool] = None,
                 resource_group: Optional[str] = None,
                 resource_uri: Optional[str] = None,
                 service_data_access_auth_identity: Optional[str] = None,
                 subscription_id: Optional[str] = None,
                 tenant_id: Optional[str] = None,
                 thumbprint: Optional[str] = None):
        """
        :param str authority_url: The authority URL used for authentication.
        :param str certificate: The content of the certificate used for authentication.
        :param str client_id: The Client ID/Application ID
        :param str client_secret: The client secret.
        :param bool is_cert_auth:  Is it using certificate to authenticate. If false then use client secret.
        :param str resource_group: Resource Group.
        :param str resource_uri: The resource the service principal/app has access to.
        :param str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param str subscription_id: Subscription ID.
        :param str tenant_id: The ID of the tenant the service principal/app belongs to.
        :param str thumbprint: The thumbprint of the certificate above.
        """
        if authority_url is not None:
            pulumi.set(__self__, "authority_url", authority_url)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if is_cert_auth is not None:
            pulumi.set(__self__, "is_cert_auth", is_cert_auth)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if resource_uri is not None:
            pulumi.set(__self__, "resource_uri", resource_uri)
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)

    @property
    @pulumi.getter(name="authorityUrl")
    def authority_url(self) -> Optional[str]:
        """
        The authority URL used for authentication.
        """
        return pulumi.get(self, "authority_url")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        The content of the certificate used for authentication.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID/Application ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="isCertAuth")
    def is_cert_auth(self) -> Optional[bool]:
        """
         Is it using certificate to authenticate. If false then use client secret.
        """
        return pulumi.get(self, "is_cert_auth")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[str]:
        """
        Resource Group.
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[str]:
        """
        The resource the service principal/app has access to.
        """
        return pulumi.get(self, "resource_uri")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        Subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The ID of the tenant the service principal/app belongs to.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[str]:
        """
        The thumbprint of the certificate above.
        """
        return pulumi.get(self, "thumbprint")


@pulumi.output_type
class DatasetResponse(dict):
    """
    Machine Learning dataset object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdTime":
            suggest = "created_time"
        elif key == "datasetId":
            suggest = "dataset_id"
        elif key == "datasetType":
            suggest = "dataset_type"
        elif key == "defaultCompute":
            suggest = "default_compute"
        elif key == "isVisible":
            suggest = "is_visible"
        elif key == "modifiedTime":
            suggest = "modified_time"
        elif key == "datasetState":
            suggest = "dataset_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_time: str,
                 dataset_id: str,
                 dataset_type: str,
                 default_compute: str,
                 description: str,
                 etag: str,
                 is_visible: bool,
                 modified_time: str,
                 name: str,
                 tags: Mapping[str, str],
                 dataset_state: Optional['outputs.DatasetStateResponse'] = None,
                 latest: Optional['outputs.DatasetResponseLatest'] = None):
        """
        Machine Learning dataset object.
        :param str created_time: The dataset creation time (UTC).
        :param str dataset_id: Unique Dataset identifier.
        :param str dataset_type: Dataset Type.
        :param str default_compute: Name of the default compute to be used for any Dataset actions (such as Profile, Write).
        :param str description: Description about this dataset version.
        :param str etag: eTag description
        :param bool is_visible: Flag to hide Dataset in UI
        :param str modified_time: The dataset last modified time (UTC).
        :param str name: Unique dataset name
        :param Mapping[str, str] tags: Tags for this dataset version.
        :param 'DatasetStateResponse' dataset_state: Dataset state
        :param 'DatasetResponseLatest' latest: Last created Dataset definition.
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "dataset_type", dataset_type)
        pulumi.set(__self__, "default_compute", default_compute)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "etag", etag)
        pulumi.set(__self__, "is_visible", is_visible)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tags", tags)
        if dataset_state is not None:
            pulumi.set(__self__, "dataset_state", dataset_state)
        if latest is not None:
            pulumi.set(__self__, "latest", latest)

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> str:
        """
        The dataset creation time (UTC).
        """
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> str:
        """
        Unique Dataset identifier.
        """
        return pulumi.get(self, "dataset_id")

    @property
    @pulumi.getter(name="datasetType")
    def dataset_type(self) -> str:
        """
        Dataset Type.
        """
        return pulumi.get(self, "dataset_type")

    @property
    @pulumi.getter(name="defaultCompute")
    def default_compute(self) -> str:
        """
        Name of the default compute to be used for any Dataset actions (such as Profile, Write).
        """
        return pulumi.get(self, "default_compute")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description about this dataset version.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        eTag description
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="isVisible")
    def is_visible(self) -> bool:
        """
        Flag to hide Dataset in UI
        """
        return pulumi.get(self, "is_visible")

    @property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> str:
        """
        The dataset last modified time (UTC).
        """
        return pulumi.get(self, "modified_time")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique dataset name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        """
        Tags for this dataset version.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="datasetState")
    def dataset_state(self) -> Optional['outputs.DatasetStateResponse']:
        """
        Dataset state
        """
        return pulumi.get(self, "dataset_state")

    @property
    @pulumi.getter
    def latest(self) -> Optional['outputs.DatasetResponseLatest']:
        """
        Last created Dataset definition.
        """
        return pulumi.get(self, "latest")


@pulumi.output_type
class DatasetResponseDataPath(dict):
    """
     Datastore and reference to location of data such as relativePath, Sql Query and etc.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureFilePath":
            suggest = "azure_file_path"
        elif key == "datastoreName":
            suggest = "datastore_name"
        elif key == "httpUrl":
            suggest = "http_url"
        elif key == "partitionFormat":
            suggest = "partition_format"
        elif key == "partitionFormatIgnoreError":
            suggest = "partition_format_ignore_error"
        elif key == "relativePath":
            suggest = "relative_path"
        elif key == "additionalProperties":
            suggest = "additional_properties"
        elif key == "sqlDataPath":
            suggest = "sql_data_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetResponseDataPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetResponseDataPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetResponseDataPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_file_path: str,
                 datastore_name: str,
                 http_url: str,
                 partition_format: str,
                 partition_format_ignore_error: bool,
                 paths: Sequence[str],
                 relative_path: str,
                 additional_properties: Optional[Mapping[str, Any]] = None,
                 sql_data_path: Optional['outputs.DatasetResponseSqlDataPath'] = None):
        """
         Datastore and reference to location of data such as relativePath, Sql Query and etc.
        :param str azure_file_path: Azure path for Azure Blob or File
        :param str datastore_name: Data store Name
        :param str http_url: HTTP URL.
        :param str partition_format: Specify the partition format of path. Defaults to None.
        :param bool partition_format_ignore_error: Whether or not to ignore unmatched path.
        :param Sequence[str] paths: List of files expanded from a file GLOB specified
        :param str relative_path: Relative path in the data store
        :param Mapping[str, Any] additional_properties: Additional Properties.
        :param 'DatasetResponseSqlDataPath' sql_data_path: Sql Query/Table/Stored Procedure details.
        """
        pulumi.set(__self__, "azure_file_path", azure_file_path)
        pulumi.set(__self__, "datastore_name", datastore_name)
        pulumi.set(__self__, "http_url", http_url)
        pulumi.set(__self__, "partition_format", partition_format)
        pulumi.set(__self__, "partition_format_ignore_error", partition_format_ignore_error)
        pulumi.set(__self__, "paths", paths)
        pulumi.set(__self__, "relative_path", relative_path)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if sql_data_path is not None:
            pulumi.set(__self__, "sql_data_path", sql_data_path)

    @property
    @pulumi.getter(name="azureFilePath")
    def azure_file_path(self) -> str:
        """
        Azure path for Azure Blob or File
        """
        return pulumi.get(self, "azure_file_path")

    @property
    @pulumi.getter(name="datastoreName")
    def datastore_name(self) -> str:
        """
        Data store Name
        """
        return pulumi.get(self, "datastore_name")

    @property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> str:
        """
        HTTP URL.
        """
        return pulumi.get(self, "http_url")

    @property
    @pulumi.getter(name="partitionFormat")
    def partition_format(self) -> str:
        """
        Specify the partition format of path. Defaults to None.
        """
        return pulumi.get(self, "partition_format")

    @property
    @pulumi.getter(name="partitionFormatIgnoreError")
    def partition_format_ignore_error(self) -> bool:
        """
        Whether or not to ignore unmatched path.
        """
        return pulumi.get(self, "partition_format_ignore_error")

    @property
    @pulumi.getter
    def paths(self) -> Sequence[str]:
        """
        List of files expanded from a file GLOB specified
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> str:
        """
        Relative path in the data store
        """
        return pulumi.get(self, "relative_path")

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[Mapping[str, Any]]:
        """
        Additional Properties.
        """
        return pulumi.get(self, "additional_properties")

    @property
    @pulumi.getter(name="sqlDataPath")
    def sql_data_path(self) -> Optional['outputs.DatasetResponseSqlDataPath']:
        """
        Sql Query/Table/Stored Procedure details.
        """
        return pulumi.get(self, "sql_data_path")


@pulumi.output_type
class DatasetResponseLatest(dict):
    """
    Last created Dataset definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdTime":
            suggest = "created_time"
        elif key == "datasetId":
            suggest = "dataset_id"
        elif key == "fileType":
            suggest = "file_type"
        elif key == "modifiedTime":
            suggest = "modified_time"
        elif key == "partitionFormatInPath":
            suggest = "partition_format_in_path"
        elif key == "savedDatasetId":
            suggest = "saved_dataset_id"
        elif key == "telemetryInfo":
            suggest = "telemetry_info"
        elif key == "useDescriptionTagsFromDefinition":
            suggest = "use_description_tags_from_definition"
        elif key == "versionId":
            suggest = "version_id"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "dataPath":
            suggest = "data_path"
        elif key == "datasetDefinitionState":
            suggest = "dataset_definition_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetResponseLatest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetResponseLatest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetResponseLatest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_time: str,
                 dataflow: str,
                 dataset_id: str,
                 description: str,
                 etag: str,
                 file_type: str,
                 modified_time: str,
                 notes: str,
                 partition_format_in_path: bool,
                 saved_dataset_id: str,
                 tags: Mapping[str, str],
                 telemetry_info: Mapping[str, str],
                 use_description_tags_from_definition: bool,
                 version_id: str,
                 created_by: Optional['outputs.UserInfoResponse'] = None,
                 data_path: Optional['outputs.DatasetResponseDataPath'] = None,
                 dataset_definition_state: Optional['outputs.DatasetStateResponse'] = None,
                 properties: Optional[Mapping[str, Any]] = None):
        """
        Last created Dataset definition.
        :param str created_time: The dataset creation time (UTC).
        :param str dataflow: Dataflow Json
        :param str dataset_id: Unique Dataset identifier.
        :param str description: Description about the dataset.
        :param str etag: eTag description
        :param str file_type: Dataset FileType, specified by user.
        :param str modified_time: The dataset last modified time (UTC).
        :param str notes: Summary of Definition changes.
        :param bool partition_format_in_path: Indicates how the source data is partitioned. This is defined to filter on a range of partitioned data before performing actions or materialization.
        :param str saved_dataset_id: Indicates the saved dataset this definition is mapping to, populated on Get.
        :param Mapping[str, str] tags: Tags associated with the dataset.
        :param Mapping[str, str] telemetry_info:  Telemetry information about the dataset including information like which service the dataset was created from.
        :param bool use_description_tags_from_definition:  Whether to use description and tags from the definition level as opposed to dataset level (old behavior).
        :param str version_id: An identifier uniquely identifies a definition change.
        :param 'UserInfoResponse' created_by: User who created.
        :param 'DatasetResponseDataPath' data_path:  Datastore and reference to location of data such as relativePath, Sql Query and etc.
        :param 'DatasetStateResponse' dataset_definition_state: Dataset state
        :param Mapping[str, Any] properties: Properties stores information like name of time series column for time series dataset.
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "dataflow", dataflow)
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "etag", etag)
        pulumi.set(__self__, "file_type", file_type)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "notes", notes)
        pulumi.set(__self__, "partition_format_in_path", partition_format_in_path)
        pulumi.set(__self__, "saved_dataset_id", saved_dataset_id)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "telemetry_info", telemetry_info)
        pulumi.set(__self__, "use_description_tags_from_definition", use_description_tags_from_definition)
        pulumi.set(__self__, "version_id", version_id)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if data_path is not None:
            pulumi.set(__self__, "data_path", data_path)
        if dataset_definition_state is not None:
            pulumi.set(__self__, "dataset_definition_state", dataset_definition_state)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> str:
        """
        The dataset creation time (UTC).
        """
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter
    def dataflow(self) -> str:
        """
        Dataflow Json
        """
        return pulumi.get(self, "dataflow")

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> str:
        """
        Unique Dataset identifier.
        """
        return pulumi.get(self, "dataset_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description about the dataset.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        eTag description
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="fileType")
    def file_type(self) -> str:
        """
        Dataset FileType, specified by user.
        """
        return pulumi.get(self, "file_type")

    @property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> str:
        """
        The dataset last modified time (UTC).
        """
        return pulumi.get(self, "modified_time")

    @property
    @pulumi.getter
    def notes(self) -> str:
        """
        Summary of Definition changes.
        """
        return pulumi.get(self, "notes")

    @property
    @pulumi.getter(name="partitionFormatInPath")
    def partition_format_in_path(self) -> bool:
        """
        Indicates how the source data is partitioned. This is defined to filter on a range of partitioned data before performing actions or materialization.
        """
        return pulumi.get(self, "partition_format_in_path")

    @property
    @pulumi.getter(name="savedDatasetId")
    def saved_dataset_id(self) -> str:
        """
        Indicates the saved dataset this definition is mapping to, populated on Get.
        """
        return pulumi.get(self, "saved_dataset_id")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        """
        Tags associated with the dataset.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="telemetryInfo")
    def telemetry_info(self) -> Mapping[str, str]:
        """
         Telemetry information about the dataset including information like which service the dataset was created from.
        """
        return pulumi.get(self, "telemetry_info")

    @property
    @pulumi.getter(name="useDescriptionTagsFromDefinition")
    def use_description_tags_from_definition(self) -> bool:
        """
         Whether to use description and tags from the definition level as opposed to dataset level (old behavior).
        """
        return pulumi.get(self, "use_description_tags_from_definition")

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> str:
        """
        An identifier uniquely identifies a definition change.
        """
        return pulumi.get(self, "version_id")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional['outputs.UserInfoResponse']:
        """
        User who created.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="dataPath")
    def data_path(self) -> Optional['outputs.DatasetResponseDataPath']:
        """
         Datastore and reference to location of data such as relativePath, Sql Query and etc.
        """
        return pulumi.get(self, "data_path")

    @property
    @pulumi.getter(name="datasetDefinitionState")
    def dataset_definition_state(self) -> Optional['outputs.DatasetStateResponse']:
        """
        Dataset state
        """
        return pulumi.get(self, "dataset_definition_state")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, Any]]:
        """
        Properties stores information like name of time series column for time series dataset.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class DatasetResponseSqlDataPath(dict):
    """
    Sql Query/Table/Stored Procedure details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryTimeout":
            suggest = "query_timeout"
        elif key == "sqlQuery":
            suggest = "sql_query"
        elif key == "sqlStoredProcedureName":
            suggest = "sql_stored_procedure_name"
        elif key == "sqlTableName":
            suggest = "sql_table_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetResponseSqlDataPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetResponseSqlDataPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetResponseSqlDataPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_timeout: float,
                 sql_query: str,
                 sql_stored_procedure_name: str,
                 sql_table_name: str):
        """
        Sql Query/Table/Stored Procedure details.
        :param float query_timeout: SQL query timeout. Unit in seconds.
        :param str sql_query: SQL query
        :param str sql_stored_procedure_name: SQL storedProcedure name
        :param str sql_table_name: SQL table name
        """
        pulumi.set(__self__, "query_timeout", query_timeout)
        pulumi.set(__self__, "sql_query", sql_query)
        pulumi.set(__self__, "sql_stored_procedure_name", sql_stored_procedure_name)
        pulumi.set(__self__, "sql_table_name", sql_table_name)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> float:
        """
        SQL query timeout. Unit in seconds.
        """
        return pulumi.get(self, "query_timeout")

    @property
    @pulumi.getter(name="sqlQuery")
    def sql_query(self) -> str:
        """
        SQL query
        """
        return pulumi.get(self, "sql_query")

    @property
    @pulumi.getter(name="sqlStoredProcedureName")
    def sql_stored_procedure_name(self) -> str:
        """
        SQL storedProcedure name
        """
        return pulumi.get(self, "sql_stored_procedure_name")

    @property
    @pulumi.getter(name="sqlTableName")
    def sql_table_name(self) -> str:
        """
        SQL table name
        """
        return pulumi.get(self, "sql_table_name")


@pulumi.output_type
class DatasetStateResponse(dict):
    """
    Dataset state
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deprecatedBy":
            suggest = "deprecated_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 etag: str,
                 deprecated_by: Optional['outputs.DatasetStateResponseDeprecatedBy'] = None,
                 state: Optional[str] = None):
        """
        Dataset state
        :param str etag: eTag description
        :param 'DatasetStateResponseDeprecatedBy' deprecated_by: Reference to better Dataset or a Definition
        :param str state: Dataset state
        """
        pulumi.set(__self__, "etag", etag)
        if deprecated_by is not None:
            pulumi.set(__self__, "deprecated_by", deprecated_by)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        eTag description
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="deprecatedBy")
    def deprecated_by(self) -> Optional['outputs.DatasetStateResponseDeprecatedBy']:
        """
        Reference to better Dataset or a Definition
        """
        return pulumi.get(self, "deprecated_by")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        Dataset state
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DatasetStateResponseDeprecatedBy(dict):
    """
    Reference to better Dataset or a Definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetId":
            suggest = "dataset_id"
        elif key == "definitionVersion":
            suggest = "definition_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetStateResponseDeprecatedBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetStateResponseDeprecatedBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetStateResponseDeprecatedBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_id: str,
                 definition_version: Optional[str] = None):
        """
        Reference to better Dataset or a Definition
        :param str dataset_id: Unique Dataset identifier.
        :param str definition_version: Definition Version
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        if definition_version is not None:
            pulumi.set(__self__, "definition_version", definition_version)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> str:
        """
        Unique Dataset identifier.
        """
        return pulumi.get(self, "dataset_id")

    @property
    @pulumi.getter(name="definitionVersion")
    def definition_version(self) -> Optional[str]:
        """
        Definition Version
        """
        return pulumi.get(self, "definition_version")


@pulumi.output_type
class DatastoreResponse(dict):
    """
    Machine Learning datastore object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdBy":
            suggest = "created_by"
        elif key == "createdTime":
            suggest = "created_time"
        elif key == "modifiedBy":
            suggest = "modified_by"
        elif key == "modifiedTime":
            suggest = "modified_time"
        elif key == "azureDataLakeSection":
            suggest = "azure_data_lake_section"
        elif key == "azureMySqlSection":
            suggest = "azure_my_sql_section"
        elif key == "azurePostgreSqlSection":
            suggest = "azure_postgre_sql_section"
        elif key == "azureSqlDatabaseSection":
            suggest = "azure_sql_database_section"
        elif key == "azureStorageSection":
            suggest = "azure_storage_section"
        elif key == "dataStoreType":
            suggest = "data_store_type"
        elif key == "glusterFsSection":
            suggest = "gluster_fs_section"
        elif key == "hasBeenValidated":
            suggest = "has_been_validated"
        elif key == "linkedInfo":
            suggest = "linked_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatastoreResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatastoreResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatastoreResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_by: 'outputs.UserInfoResponse',
                 created_time: str,
                 modified_by: 'outputs.UserInfoResponse',
                 modified_time: str,
                 tags: Mapping[str, str],
                 azure_data_lake_section: Optional['outputs.AzureDataLakeSectionResponse'] = None,
                 azure_my_sql_section: Optional['outputs.AzureMySqlSectionResponse'] = None,
                 azure_postgre_sql_section: Optional['outputs.AzurePostgreSqlSectionResponse'] = None,
                 azure_sql_database_section: Optional['outputs.AzureSqlDatabaseSectionResponse'] = None,
                 azure_storage_section: Optional['outputs.AzureStorageSectionResponse'] = None,
                 data_store_type: Optional[str] = None,
                 description: Optional[str] = None,
                 gluster_fs_section: Optional['outputs.GlusterFsSectionResponse'] = None,
                 has_been_validated: Optional[bool] = None,
                 linked_info: Optional['outputs.LinkedInfoResponse'] = None,
                 name: Optional[str] = None):
        """
        Machine Learning datastore object.
        :param 'UserInfoResponse' created_by: The User who created the datastore.
        :param str created_time: The date and time when the datastore was created.
        :param 'UserInfoResponse' modified_by: The User who modified the datastore.
        :param str modified_time: The date and time when the datastore was last modified.
        :param Mapping[str, str] tags: Tags for this datastore.
        :param str data_store_type: The datastore type.
        :param str description: Description of the datastore.
        :param 'GlusterFsSectionResponse' gluster_fs_section: Data specific to GlusterFS.
        :param bool has_been_validated: A read only property that denotes whether the service datastore has been validated with credentials.
        :param 'LinkedInfoResponse' linked_info: Info about origin if it is linked.
        :param str name: Name of the datastore.
        """
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "modified_by", modified_by)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "tags", tags)
        if azure_data_lake_section is not None:
            pulumi.set(__self__, "azure_data_lake_section", azure_data_lake_section)
        if azure_my_sql_section is not None:
            pulumi.set(__self__, "azure_my_sql_section", azure_my_sql_section)
        if azure_postgre_sql_section is not None:
            pulumi.set(__self__, "azure_postgre_sql_section", azure_postgre_sql_section)
        if azure_sql_database_section is not None:
            pulumi.set(__self__, "azure_sql_database_section", azure_sql_database_section)
        if azure_storage_section is not None:
            pulumi.set(__self__, "azure_storage_section", azure_storage_section)
        if data_store_type is not None:
            pulumi.set(__self__, "data_store_type", data_store_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if gluster_fs_section is not None:
            pulumi.set(__self__, "gluster_fs_section", gluster_fs_section)
        if has_been_validated is None:
            has_been_validated = False
        if has_been_validated is not None:
            pulumi.set(__self__, "has_been_validated", has_been_validated)
        if linked_info is not None:
            pulumi.set(__self__, "linked_info", linked_info)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> 'outputs.UserInfoResponse':
        """
        The User who created the datastore.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> str:
        """
        The date and time when the datastore was created.
        """
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter(name="modifiedBy")
    def modified_by(self) -> 'outputs.UserInfoResponse':
        """
        The User who modified the datastore.
        """
        return pulumi.get(self, "modified_by")

    @property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> str:
        """
        The date and time when the datastore was last modified.
        """
        return pulumi.get(self, "modified_time")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        """
        Tags for this datastore.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="azureDataLakeSection")
    def azure_data_lake_section(self) -> Optional['outputs.AzureDataLakeSectionResponse']:
        return pulumi.get(self, "azure_data_lake_section")

    @property
    @pulumi.getter(name="azureMySqlSection")
    def azure_my_sql_section(self) -> Optional['outputs.AzureMySqlSectionResponse']:
        return pulumi.get(self, "azure_my_sql_section")

    @property
    @pulumi.getter(name="azurePostgreSqlSection")
    def azure_postgre_sql_section(self) -> Optional['outputs.AzurePostgreSqlSectionResponse']:
        return pulumi.get(self, "azure_postgre_sql_section")

    @property
    @pulumi.getter(name="azureSqlDatabaseSection")
    def azure_sql_database_section(self) -> Optional['outputs.AzureSqlDatabaseSectionResponse']:
        return pulumi.get(self, "azure_sql_database_section")

    @property
    @pulumi.getter(name="azureStorageSection")
    def azure_storage_section(self) -> Optional['outputs.AzureStorageSectionResponse']:
        return pulumi.get(self, "azure_storage_section")

    @property
    @pulumi.getter(name="dataStoreType")
    def data_store_type(self) -> Optional[str]:
        """
        The datastore type.
        """
        return pulumi.get(self, "data_store_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the datastore.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="glusterFsSection")
    def gluster_fs_section(self) -> Optional['outputs.GlusterFsSectionResponse']:
        """
        Data specific to GlusterFS.
        """
        return pulumi.get(self, "gluster_fs_section")

    @property
    @pulumi.getter(name="hasBeenValidated")
    def has_been_validated(self) -> Optional[bool]:
        """
        A read only property that denotes whether the service datastore has been validated with credentials.
        """
        return pulumi.get(self, "has_been_validated")

    @property
    @pulumi.getter(name="linkedInfo")
    def linked_info(self) -> Optional['outputs.LinkedInfoResponse']:
        """
        Info about origin if it is linked.
        """
        return pulumi.get(self, "linked_info")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the datastore.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GlusterFsSectionResponse(dict):
    """
    Data specific to GlusterFS.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverAddress":
            suggest = "server_address"
        elif key == "volumeName":
            suggest = "volume_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlusterFsSectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlusterFsSectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlusterFsSectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_address: str,
                 volume_name: str):
        """
        Data specific to GlusterFS.
        :param str server_address: The server address of one of the servers that hosts the GlusterFS. Can be either the IP address or server name.
        :param str volume_name: The name of the created GlusterFS volume.
        """
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "volume_name", volume_name)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        """
        The server address of one of the servers that hosts the GlusterFS. Can be either the IP address or server name.
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> str:
        """
        The name of the created GlusterFS volume.
        """
        return pulumi.get(self, "volume_name")


@pulumi.output_type
class IdentityResponse(dict):
    """
    Identity for the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: Optional[str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Identity for the resource.
        :param str principal_id: The principal ID of resource identity.
        :param str tenant_id: The tenant ID of resource.
        :param str type: The identity type.
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The user assigned identities associated with the resource.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of resource identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of resource.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The identity type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The user assigned identities associated with the resource.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class LinkedInfoResponse(dict):
    """
    Info about origin if it is linked.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedId":
            suggest = "linked_id"
        elif key == "linkedResourceName":
            suggest = "linked_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_id: Optional[str] = None,
                 linked_resource_name: Optional[str] = None,
                 origin: Optional[str] = None):
        """
        Info about origin if it is linked.
        :param str linked_id: LinkedId id.
        :param str linked_resource_name: Linked resource name.
        :param str origin: Datastore origin
        """
        if linked_id is not None:
            pulumi.set(__self__, "linked_id", linked_id)
        if linked_resource_name is not None:
            pulumi.set(__self__, "linked_resource_name", linked_resource_name)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)

    @property
    @pulumi.getter(name="linkedId")
    def linked_id(self) -> Optional[str]:
        """
        LinkedId id.
        """
        return pulumi.get(self, "linked_id")

    @property
    @pulumi.getter(name="linkedResourceName")
    def linked_resource_name(self) -> Optional[str]:
        """
        Linked resource name.
        """
        return pulumi.get(self, "linked_resource_name")

    @property
    @pulumi.getter
    def origin(self) -> Optional[str]:
        """
        Datastore origin
        """
        return pulumi.get(self, "origin")


@pulumi.output_type
class SkuResponse(dict):
    """
    Sku of the resource
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 tier: Optional[str] = None):
        """
        Sku of the resource
        :param str name: Name of the sku
        :param str tier: Tier of the sku like Basic or Enterprise
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the sku
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        """
        Tier of the sku like Basic or Enterprise
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User Assigned Identity
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str,
                 tenant_id: str):
        """
        User Assigned Identity
        :param str client_id: The clientId(aka appId) of the user assigned identity.
        :param str principal_id: The principal ID of the user assigned identity.
        :param str tenant_id: The tenant ID of the user assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The clientId(aka appId) of the user assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of the user assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of the user assigned identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class UserInfoResponse(dict):
    """
    User who created.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userAltSecId":
            suggest = "user_alt_sec_id"
        elif key == "userIdp":
            suggest = "user_idp"
        elif key == "userIss":
            suggest = "user_iss"
        elif key == "userName":
            suggest = "user_name"
        elif key == "userObjectId":
            suggest = "user_object_id"
        elif key == "userPuId":
            suggest = "user_pu_id"
        elif key == "userTenantId":
            suggest = "user_tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_alt_sec_id: Optional[str] = None,
                 user_idp: Optional[str] = None,
                 user_iss: Optional[str] = None,
                 user_name: Optional[str] = None,
                 user_object_id: Optional[str] = None,
                 user_pu_id: Optional[str] = None,
                 user_tenant_id: Optional[str] = None):
        """
        User who created.
        :param str user_alt_sec_id: A user alternate sec id. This represents the user in a different identity provider system Eg.1:live.com:puid
        :param str user_idp: A user identity provider. Eg live.com
        :param str user_iss: The issuer which issued the token for this user.
        :param str user_name:  A user's full name or a service principal's app ID.
        :param str user_object_id: A user or service principal's object ID..
        :param str user_pu_id: A user or service principal's PuID.
        :param str user_tenant_id: A user or service principal's tenant ID.
        """
        if user_alt_sec_id is not None:
            pulumi.set(__self__, "user_alt_sec_id", user_alt_sec_id)
        if user_idp is not None:
            pulumi.set(__self__, "user_idp", user_idp)
        if user_iss is not None:
            pulumi.set(__self__, "user_iss", user_iss)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)
        if user_object_id is not None:
            pulumi.set(__self__, "user_object_id", user_object_id)
        if user_pu_id is not None:
            pulumi.set(__self__, "user_pu_id", user_pu_id)
        if user_tenant_id is not None:
            pulumi.set(__self__, "user_tenant_id", user_tenant_id)

    @property
    @pulumi.getter(name="userAltSecId")
    def user_alt_sec_id(self) -> Optional[str]:
        """
        A user alternate sec id. This represents the user in a different identity provider system Eg.1:live.com:puid
        """
        return pulumi.get(self, "user_alt_sec_id")

    @property
    @pulumi.getter(name="userIdp")
    def user_idp(self) -> Optional[str]:
        """
        A user identity provider. Eg live.com
        """
        return pulumi.get(self, "user_idp")

    @property
    @pulumi.getter(name="userIss")
    def user_iss(self) -> Optional[str]:
        """
        The issuer which issued the token for this user.
        """
        return pulumi.get(self, "user_iss")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        """
         A user's full name or a service principal's app ID.
        """
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter(name="userObjectId")
    def user_object_id(self) -> Optional[str]:
        """
        A user or service principal's object ID..
        """
        return pulumi.get(self, "user_object_id")

    @property
    @pulumi.getter(name="userPuId")
    def user_pu_id(self) -> Optional[str]:
        """
        A user or service principal's PuID.
        """
        return pulumi.get(self, "user_pu_id")

    @property
    @pulumi.getter(name="userTenantId")
    def user_tenant_id(self) -> Optional[str]:
        """
        A user or service principal's tenant ID.
        """
        return pulumi.get(self, "user_tenant_id")


