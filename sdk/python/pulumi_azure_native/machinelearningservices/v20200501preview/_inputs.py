# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from ._enums import *

__all__ = [
    'DatasetCreateRequestDataPathArgs',
    'DatasetCreateRequestParametersArgs',
    'DatasetCreateRequestPathArgs',
    'DatasetCreateRequestQueryArgs',
    'DatasetCreateRequestRegistrationArgs',
    'DatasetCreateRequestTimeSeriesArgs',
]

@pulumi.input_type
class DatasetCreateRequestDataPathArgs:
    def __init__(__self__, *,
                 datastore_name: Optional[pulumi.Input[str]] = None,
                 relative_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] datastore_name: The datastore name.
        :param pulumi.Input[str] relative_path: Path within the datastore.
        """
        if datastore_name is not None:
            pulumi.set(__self__, "datastore_name", datastore_name)
        if relative_path is not None:
            pulumi.set(__self__, "relative_path", relative_path)

    @property
    @pulumi.getter(name="datastoreName")
    def datastore_name(self) -> Optional[pulumi.Input[str]]:
        """
        The datastore name.
        """
        return pulumi.get(self, "datastore_name")

    @datastore_name.setter
    def datastore_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore_name", value)

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> Optional[pulumi.Input[str]]:
        """
        Path within the datastore.
        """
        return pulumi.get(self, "relative_path")

    @relative_path.setter
    def relative_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relative_path", value)


@pulumi.input_type
class DatasetCreateRequestParametersArgs:
    def __init__(__self__, *,
                 header: Optional[pulumi.Input[Union[str, 'Header']]] = None,
                 include_path: Optional[pulumi.Input[bool]] = None,
                 partition_format: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input['DatasetCreateRequestPathArgs']] = None,
                 query: Optional[pulumi.Input['DatasetCreateRequestQueryArgs']] = None,
                 separator: Optional[pulumi.Input[str]] = None,
                 source_type: Optional[pulumi.Input[Union[str, 'SourceType']]] = None):
        """
        :param pulumi.Input[Union[str, 'Header']] header: Header type.
        :param pulumi.Input[bool] include_path: Boolean to keep path information as column in the dataset. Defaults to False. This is useful when reading multiple files, and want to know which file a particular record originated from, or to keep useful information in file path.
        :param pulumi.Input[str] partition_format: The partition information of each path will be extracted into columns based on the specified format. Format part '{column_name}' creates string column, and '{column_name:yyyy/MM/dd/HH/mm/ss}' creates datetime column, where 'yyyy', 'MM', 'dd', 'HH', 'mm' and 'ss' are used to extract year, month, day, hour, minute and second for the datetime type. The format should start from the position of first partition key until the end of file path. For example, given the path '../USA/2019/01/01/data.parquet' where the partition is by country/region and time, partition_format='/{CountryOrRegion}/{PartitionDate:yyyy/MM/dd}/data.csv' creates a string column 'CountryOrRegion' with the value 'USA' and a datetime column 'PartitionDate' with the value '2019-01-01
        :param pulumi.Input[str] separator: The separator used to split columns for 'delimited_files' sourceType.
        :param pulumi.Input[Union[str, 'SourceType']] source_type: Data source type.
        """
        if header is not None:
            pulumi.set(__self__, "header", header)
        if include_path is None:
            include_path = False
        if include_path is not None:
            pulumi.set(__self__, "include_path", include_path)
        if partition_format is not None:
            pulumi.set(__self__, "partition_format", partition_format)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if separator is not None:
            pulumi.set(__self__, "separator", separator)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[Union[str, 'Header']]]:
        """
        Header type.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[Union[str, 'Header']]]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter(name="includePath")
    def include_path(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean to keep path information as column in the dataset. Defaults to False. This is useful when reading multiple files, and want to know which file a particular record originated from, or to keep useful information in file path.
        """
        return pulumi.get(self, "include_path")

    @include_path.setter
    def include_path(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_path", value)

    @property
    @pulumi.getter(name="partitionFormat")
    def partition_format(self) -> Optional[pulumi.Input[str]]:
        """
        The partition information of each path will be extracted into columns based on the specified format. Format part '{column_name}' creates string column, and '{column_name:yyyy/MM/dd/HH/mm/ss}' creates datetime column, where 'yyyy', 'MM', 'dd', 'HH', 'mm' and 'ss' are used to extract year, month, day, hour, minute and second for the datetime type. The format should start from the position of first partition key until the end of file path. For example, given the path '../USA/2019/01/01/data.parquet' where the partition is by country/region and time, partition_format='/{CountryOrRegion}/{PartitionDate:yyyy/MM/dd}/data.csv' creates a string column 'CountryOrRegion' with the value 'USA' and a datetime column 'PartitionDate' with the value '2019-01-01
        """
        return pulumi.get(self, "partition_format")

    @partition_format.setter
    def partition_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "partition_format", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['DatasetCreateRequestPathArgs']]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['DatasetCreateRequestPathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input['DatasetCreateRequestQueryArgs']]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input['DatasetCreateRequestQueryArgs']]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def separator(self) -> Optional[pulumi.Input[str]]:
        """
        The separator used to split columns for 'delimited_files' sourceType.
        """
        return pulumi.get(self, "separator")

    @separator.setter
    def separator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "separator", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[pulumi.Input[Union[str, 'SourceType']]]:
        """
        Data source type.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: Optional[pulumi.Input[Union[str, 'SourceType']]]):
        pulumi.set(self, "source_type", value)


@pulumi.input_type
class DatasetCreateRequestPathArgs:
    def __init__(__self__, *,
                 data_path: Optional[pulumi.Input['DatasetCreateRequestDataPathArgs']] = None,
                 http_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] http_url: The Http URL.
        """
        if data_path is not None:
            pulumi.set(__self__, "data_path", data_path)
        if http_url is not None:
            pulumi.set(__self__, "http_url", http_url)

    @property
    @pulumi.getter(name="dataPath")
    def data_path(self) -> Optional[pulumi.Input['DatasetCreateRequestDataPathArgs']]:
        return pulumi.get(self, "data_path")

    @data_path.setter
    def data_path(self, value: Optional[pulumi.Input['DatasetCreateRequestDataPathArgs']]):
        pulumi.set(self, "data_path", value)

    @property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> Optional[pulumi.Input[str]]:
        """
        The Http URL.
        """
        return pulumi.get(self, "http_url")

    @http_url.setter
    def http_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_url", value)


@pulumi.input_type
class DatasetCreateRequestQueryArgs:
    def __init__(__self__, *,
                 datastore_name: Optional[pulumi.Input[str]] = None,
                 query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] datastore_name: The SQL/PostgreSQL/MySQL datastore name.
        :param pulumi.Input[str] query: SQL Quey.
        """
        if datastore_name is not None:
            pulumi.set(__self__, "datastore_name", datastore_name)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter(name="datastoreName")
    def datastore_name(self) -> Optional[pulumi.Input[str]]:
        """
        The SQL/PostgreSQL/MySQL datastore name.
        """
        return pulumi.get(self, "datastore_name")

    @datastore_name.setter
    def datastore_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore_name", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        SQL Quey.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DatasetCreateRequestRegistrationArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] description: The description for the dataset.
        :param pulumi.Input[str] name: The name of the dataset.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: Tags associated with the dataset.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description for the dataset.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the dataset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Tags associated with the dataset.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class DatasetCreateRequestTimeSeriesArgs:
    def __init__(__self__, *,
                 coarse_grain_timestamp: Optional[pulumi.Input[str]] = None,
                 fine_grain_timestamp: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] coarse_grain_timestamp: Column name to be used as CoarseGrainTimestamp. Can only be used if 'fineGrainTimestamp' is specified and cannot be same as 'fineGrainTimestamp'.
        :param pulumi.Input[str] fine_grain_timestamp:  Column name to be used as FineGrainTimestamp
        """
        if coarse_grain_timestamp is not None:
            pulumi.set(__self__, "coarse_grain_timestamp", coarse_grain_timestamp)
        if fine_grain_timestamp is not None:
            pulumi.set(__self__, "fine_grain_timestamp", fine_grain_timestamp)

    @property
    @pulumi.getter(name="coarseGrainTimestamp")
    def coarse_grain_timestamp(self) -> Optional[pulumi.Input[str]]:
        """
        Column name to be used as CoarseGrainTimestamp. Can only be used if 'fineGrainTimestamp' is specified and cannot be same as 'fineGrainTimestamp'.
        """
        return pulumi.get(self, "coarse_grain_timestamp")

    @coarse_grain_timestamp.setter
    def coarse_grain_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "coarse_grain_timestamp", value)

    @property
    @pulumi.getter(name="fineGrainTimestamp")
    def fine_grain_timestamp(self) -> Optional[pulumi.Input[str]]:
        """
         Column name to be used as FineGrainTimestamp
        """
        return pulumi.get(self, "fine_grain_timestamp")

    @fine_grain_timestamp.setter
    def fine_grain_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fine_grain_timestamp", value)


