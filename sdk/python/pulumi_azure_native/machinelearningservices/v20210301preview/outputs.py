# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AccountKeyDatastoreCredentialsResponse',
    'AmlTokenResponse',
    'AutoScaleSettingsResponse',
    'AzureBlobContentsResponse',
    'AzureDataLakeGen1ContentsResponse',
    'AzureDataLakeGen2ContentsResponse',
    'AzureFileContentsResponse',
    'AzurePostgreSqlContentsResponse',
    'AzureSqlDatabaseContentsResponse',
    'BanditPolicyResponse',
    'BatchDeploymentResponse',
    'BatchEndpointResponse',
    'BatchOutputConfigurationResponse',
    'BatchRetrySettingsResponse',
    'CertificateDatastoreCredentialsResponse',
    'CodeConfigurationResponse',
    'CodeContainerResponse',
    'CodeVersionResponse',
    'CommandJobResponse',
    'ComputeConfigurationResponse',
    'ContainerResourceRequirementsResponse',
    'DataContainerResponse',
    'DataPathAssetReferenceResponse',
    'DataVersionResponse',
    'DatastorePropertiesResponse',
    'DockerBuildResponse',
    'DockerImagePlatformResponse',
    'DockerImageResponse',
    'EnvironmentContainerResponse',
    'EnvironmentSpecificationVersionResponse',
    'FlavorDataResponse',
    'GlusterFsContentsResponse',
    'IdAssetReferenceResponse',
    'InferenceContainerPropertiesResponse',
    'InputDataBindingResponse',
    'JobEndpointResponse',
    'JobOutputResponse',
    'K8sOnlineDeploymentResponse',
    'LabelCategoryResponse',
    'LabelClassResponse',
    'LabelingDatasetConfigurationResponse',
    'LabelingJobImagePropertiesResponse',
    'LabelingJobInstructionsResponse',
    'LabelingJobResponse',
    'LabelingJobTextPropertiesResponse',
    'LinkedInfoResponse',
    'MLAssistConfigurationResponse',
    'ManagedIdentityResponse',
    'ManagedOnlineDeploymentResponse',
    'ManualScaleSettingsResponse',
    'MedianStoppingPolicyResponse',
    'ModelContainerResponse',
    'ModelVersionResponse',
    'MpiResponse',
    'NoneDatastoreCredentialsResponse',
    'ObjectiveResponse',
    'OnlineEndpointResponse',
    'OnlineRequestSettingsResponse',
    'OutputDataBindingResponse',
    'OutputPathAssetReferenceResponse',
    'ProbeSettingsResponse',
    'ProgressMetricsResponse',
    'PyTorchResponse',
    'ResourceIdentityResponse',
    'RouteResponse',
    'SasDatastoreCredentialsResponse',
    'ServicePrincipalDatastoreCredentialsResponse',
    'SqlAdminDatastoreCredentialsResponse',
    'StatusMessageResponse',
    'SweepJobResponse',
    'SystemDataResponse',
    'TensorFlowResponse',
    'TrialComponentResponse',
    'TruncationSelectionPolicyResponse',
    'UserAssignedIdentityMetaResponse',
]

@pulumi.output_type
class AccountKeyDatastoreCredentialsResponse(dict):
    """
    Account key datastore credentials configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsType":
            suggest = "credentials_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountKeyDatastoreCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountKeyDatastoreCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountKeyDatastoreCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_type: str):
        """
        Account key datastore credentials configuration.
        :param str credentials_type: Enum to determine the datastore credentials type.
               Expected value is 'AccountKey'.
        """
        AccountKeyDatastoreCredentialsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials_type=credentials_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if credentials_type is None and 'credentialsType' in kwargs:
            credentials_type = kwargs['credentialsType']
        if credentials_type is None:
            raise TypeError("Missing 'credentials_type' argument")

        _setter("credentials_type", 'AccountKey')

    @property
    @pulumi.getter(name="credentialsType")
    def credentials_type(self) -> str:
        """
        Enum to determine the datastore credentials type.
        Expected value is 'AccountKey'.
        """
        return pulumi.get(self, "credentials_type")


@pulumi.output_type
class AmlTokenResponse(dict):
    """
    AML Token identity configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityType":
            suggest = "identity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmlTokenResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmlTokenResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmlTokenResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_type: str):
        """
        AML Token identity configuration.
        :param str identity_type: Enum to determine identity framework.
               Expected value is 'AMLToken'.
        """
        AmlTokenResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_type=identity_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if identity_type is None and 'identityType' in kwargs:
            identity_type = kwargs['identityType']
        if identity_type is None:
            raise TypeError("Missing 'identity_type' argument")

        _setter("identity_type", 'AMLToken')

    @property
    @pulumi.getter(name="identityType")
    def identity_type(self) -> str:
        """
        Enum to determine identity framework.
        Expected value is 'AMLToken'.
        """
        return pulumi.get(self, "identity_type")


@pulumi.output_type
class AutoScaleSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleType":
            suggest = "scale_type"
        elif key == "maxInstances":
            suggest = "max_instances"
        elif key == "minInstances":
            suggest = "min_instances"
        elif key == "pollingInterval":
            suggest = "polling_interval"
        elif key == "targetUtilizationPercentage":
            suggest = "target_utilization_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScaleSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScaleSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScaleSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scale_type: str,
                 max_instances: Optional[int] = None,
                 min_instances: Optional[int] = None,
                 polling_interval: Optional[str] = None,
                 target_utilization_percentage: Optional[int] = None):
        """
        :param str scale_type: 
               Expected value is 'Auto'.
        :param int max_instances: Maximum number of instances for this deployment.
        :param int min_instances: Minimum number of instances for this deployment.
        :param str polling_interval: The polling interval in ISO 8691 format. Only supports duration with precision as low as Seconds.
        :param int target_utilization_percentage: Target CPU usage for the autoscaler.
        """
        AutoScaleSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scale_type=scale_type,
            max_instances=max_instances,
            min_instances=min_instances,
            polling_interval=polling_interval,
            target_utilization_percentage=target_utilization_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scale_type: Optional[str] = None,
             max_instances: Optional[int] = None,
             min_instances: Optional[int] = None,
             polling_interval: Optional[str] = None,
             target_utilization_percentage: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if scale_type is None and 'scaleType' in kwargs:
            scale_type = kwargs['scaleType']
        if scale_type is None:
            raise TypeError("Missing 'scale_type' argument")
        if max_instances is None and 'maxInstances' in kwargs:
            max_instances = kwargs['maxInstances']
        if min_instances is None and 'minInstances' in kwargs:
            min_instances = kwargs['minInstances']
        if polling_interval is None and 'pollingInterval' in kwargs:
            polling_interval = kwargs['pollingInterval']
        if target_utilization_percentage is None and 'targetUtilizationPercentage' in kwargs:
            target_utilization_percentage = kwargs['targetUtilizationPercentage']

        _setter("scale_type", 'Auto')
        if max_instances is not None:
            _setter("max_instances", max_instances)
        if min_instances is not None:
            _setter("min_instances", min_instances)
        if polling_interval is not None:
            _setter("polling_interval", polling_interval)
        if target_utilization_percentage is not None:
            _setter("target_utilization_percentage", target_utilization_percentage)

    @property
    @pulumi.getter(name="scaleType")
    def scale_type(self) -> str:
        """

        Expected value is 'Auto'.
        """
        return pulumi.get(self, "scale_type")

    @property
    @pulumi.getter(name="maxInstances")
    def max_instances(self) -> Optional[int]:
        """
        Maximum number of instances for this deployment.
        """
        return pulumi.get(self, "max_instances")

    @property
    @pulumi.getter(name="minInstances")
    def min_instances(self) -> Optional[int]:
        """
        Minimum number of instances for this deployment.
        """
        return pulumi.get(self, "min_instances")

    @property
    @pulumi.getter(name="pollingInterval")
    def polling_interval(self) -> Optional[str]:
        """
        The polling interval in ISO 8691 format. Only supports duration with precision as low as Seconds.
        """
        return pulumi.get(self, "polling_interval")

    @property
    @pulumi.getter(name="targetUtilizationPercentage")
    def target_utilization_percentage(self) -> Optional[int]:
        """
        Target CPU usage for the autoscaler.
        """
        return pulumi.get(self, "target_utilization_percentage")


@pulumi.output_type
class AzureBlobContentsResponse(dict):
    """
    Azure Blob datastore configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountName":
            suggest = "account_name"
        elif key == "containerName":
            suggest = "container_name"
        elif key == "contentsType":
            suggest = "contents_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureBlobContentsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureBlobContentsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureBlobContentsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_name: str,
                 container_name: str,
                 contents_type: str,
                 credentials: Any,
                 endpoint: str,
                 protocol: str):
        """
        Azure Blob datastore configuration.
        :param str account_name: [Required] Storage account name.
        :param str container_name: [Required] Storage account container name.
        :param str contents_type: Enum to determine the datastore contents type.
               Expected value is 'AzureBlob'.
        :param Union['AccountKeyDatastoreCredentialsResponse', 'CertificateDatastoreCredentialsResponse', 'NoneDatastoreCredentialsResponse', 'SasDatastoreCredentialsResponse', 'ServicePrincipalDatastoreCredentialsResponse', 'SqlAdminDatastoreCredentialsResponse'] credentials: [Required] Account credentials.
        :param str endpoint: [Required] Azure cloud endpoint for the storage account.
        :param str protocol: [Required] Protocol used to communicate with the storage account.
        """
        AzureBlobContentsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_name=account_name,
            container_name=container_name,
            contents_type=contents_type,
            credentials=credentials,
            endpoint=endpoint,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_name: Optional[str] = None,
             container_name: Optional[str] = None,
             contents_type: Optional[str] = None,
             credentials: Optional[Any] = None,
             endpoint: Optional[str] = None,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if account_name is None and 'accountName' in kwargs:
            account_name = kwargs['accountName']
        if account_name is None:
            raise TypeError("Missing 'account_name' argument")
        if container_name is None and 'containerName' in kwargs:
            container_name = kwargs['containerName']
        if container_name is None:
            raise TypeError("Missing 'container_name' argument")
        if contents_type is None and 'contentsType' in kwargs:
            contents_type = kwargs['contentsType']
        if contents_type is None:
            raise TypeError("Missing 'contents_type' argument")
        if credentials is None:
            raise TypeError("Missing 'credentials' argument")
        if endpoint is None:
            raise TypeError("Missing 'endpoint' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")

        _setter("account_name", account_name)
        _setter("container_name", container_name)
        _setter("contents_type", 'AzureBlob')
        _setter("credentials", credentials)
        _setter("endpoint", endpoint)
        _setter("protocol", protocol)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        [Required] Storage account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        """
        [Required] Storage account container name.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter(name="contentsType")
    def contents_type(self) -> str:
        """
        Enum to determine the datastore contents type.
        Expected value is 'AzureBlob'.
        """
        return pulumi.get(self, "contents_type")

    @property
    @pulumi.getter
    def credentials(self) -> Any:
        """
        [Required] Account credentials.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        [Required] Azure cloud endpoint for the storage account.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        [Required] Protocol used to communicate with the storage account.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class AzureDataLakeGen1ContentsResponse(dict):
    """
    Azure Data Lake Gen1 datastore configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentsType":
            suggest = "contents_type"
        elif key == "storeName":
            suggest = "store_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureDataLakeGen1ContentsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureDataLakeGen1ContentsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureDataLakeGen1ContentsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contents_type: str,
                 credentials: Any,
                 store_name: str):
        """
        Azure Data Lake Gen1 datastore configuration.
        :param str contents_type: Enum to determine the datastore contents type.
               Expected value is 'AzureDataLakeGen1'.
        :param Union['AccountKeyDatastoreCredentialsResponse', 'CertificateDatastoreCredentialsResponse', 'NoneDatastoreCredentialsResponse', 'SasDatastoreCredentialsResponse', 'ServicePrincipalDatastoreCredentialsResponse', 'SqlAdminDatastoreCredentialsResponse'] credentials: [Required] Account credentials.
        :param str store_name: [Required] Azure Data Lake store name.
        """
        AzureDataLakeGen1ContentsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            contents_type=contents_type,
            credentials=credentials,
            store_name=store_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             contents_type: Optional[str] = None,
             credentials: Optional[Any] = None,
             store_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if contents_type is None and 'contentsType' in kwargs:
            contents_type = kwargs['contentsType']
        if contents_type is None:
            raise TypeError("Missing 'contents_type' argument")
        if credentials is None:
            raise TypeError("Missing 'credentials' argument")
        if store_name is None and 'storeName' in kwargs:
            store_name = kwargs['storeName']
        if store_name is None:
            raise TypeError("Missing 'store_name' argument")

        _setter("contents_type", 'AzureDataLakeGen1')
        _setter("credentials", credentials)
        _setter("store_name", store_name)

    @property
    @pulumi.getter(name="contentsType")
    def contents_type(self) -> str:
        """
        Enum to determine the datastore contents type.
        Expected value is 'AzureDataLakeGen1'.
        """
        return pulumi.get(self, "contents_type")

    @property
    @pulumi.getter
    def credentials(self) -> Any:
        """
        [Required] Account credentials.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> str:
        """
        [Required] Azure Data Lake store name.
        """
        return pulumi.get(self, "store_name")


@pulumi.output_type
class AzureDataLakeGen2ContentsResponse(dict):
    """
    Azure Data Lake Gen2 datastore configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountName":
            suggest = "account_name"
        elif key == "containerName":
            suggest = "container_name"
        elif key == "contentsType":
            suggest = "contents_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureDataLakeGen2ContentsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureDataLakeGen2ContentsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureDataLakeGen2ContentsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_name: str,
                 container_name: str,
                 contents_type: str,
                 credentials: Any,
                 endpoint: str,
                 protocol: str):
        """
        Azure Data Lake Gen2 datastore configuration.
        :param str account_name: [Required] Storage account name.
        :param str container_name: [Required] Storage account container name.
        :param str contents_type: Enum to determine the datastore contents type.
               Expected value is 'AzureDataLakeGen2'.
        :param Union['AccountKeyDatastoreCredentialsResponse', 'CertificateDatastoreCredentialsResponse', 'NoneDatastoreCredentialsResponse', 'SasDatastoreCredentialsResponse', 'ServicePrincipalDatastoreCredentialsResponse', 'SqlAdminDatastoreCredentialsResponse'] credentials: [Required] Account credentials.
        :param str endpoint: [Required] Azure cloud endpoint for the storage account.
        :param str protocol: [Required] Protocol used to communicate with the storage account.
        """
        AzureDataLakeGen2ContentsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_name=account_name,
            container_name=container_name,
            contents_type=contents_type,
            credentials=credentials,
            endpoint=endpoint,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_name: Optional[str] = None,
             container_name: Optional[str] = None,
             contents_type: Optional[str] = None,
             credentials: Optional[Any] = None,
             endpoint: Optional[str] = None,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if account_name is None and 'accountName' in kwargs:
            account_name = kwargs['accountName']
        if account_name is None:
            raise TypeError("Missing 'account_name' argument")
        if container_name is None and 'containerName' in kwargs:
            container_name = kwargs['containerName']
        if container_name is None:
            raise TypeError("Missing 'container_name' argument")
        if contents_type is None and 'contentsType' in kwargs:
            contents_type = kwargs['contentsType']
        if contents_type is None:
            raise TypeError("Missing 'contents_type' argument")
        if credentials is None:
            raise TypeError("Missing 'credentials' argument")
        if endpoint is None:
            raise TypeError("Missing 'endpoint' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")

        _setter("account_name", account_name)
        _setter("container_name", container_name)
        _setter("contents_type", 'AzureDataLakeGen2')
        _setter("credentials", credentials)
        _setter("endpoint", endpoint)
        _setter("protocol", protocol)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        [Required] Storage account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        """
        [Required] Storage account container name.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter(name="contentsType")
    def contents_type(self) -> str:
        """
        Enum to determine the datastore contents type.
        Expected value is 'AzureDataLakeGen2'.
        """
        return pulumi.get(self, "contents_type")

    @property
    @pulumi.getter
    def credentials(self) -> Any:
        """
        [Required] Account credentials.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        [Required] Azure cloud endpoint for the storage account.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        [Required] Protocol used to communicate with the storage account.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class AzureFileContentsResponse(dict):
    """
    Azure File datastore configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountName":
            suggest = "account_name"
        elif key == "containerName":
            suggest = "container_name"
        elif key == "contentsType":
            suggest = "contents_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureFileContentsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureFileContentsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureFileContentsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_name: str,
                 container_name: str,
                 contents_type: str,
                 credentials: Any,
                 endpoint: str,
                 protocol: str):
        """
        Azure File datastore configuration.
        :param str account_name: [Required] Storage account name.
        :param str container_name: [Required] Storage account container name.
        :param str contents_type: Enum to determine the datastore contents type.
               Expected value is 'AzureFile'.
        :param Union['AccountKeyDatastoreCredentialsResponse', 'CertificateDatastoreCredentialsResponse', 'NoneDatastoreCredentialsResponse', 'SasDatastoreCredentialsResponse', 'ServicePrincipalDatastoreCredentialsResponse', 'SqlAdminDatastoreCredentialsResponse'] credentials: [Required] Account credentials.
        :param str endpoint: [Required] Azure cloud endpoint for the storage account.
        :param str protocol: [Required] Protocol used to communicate with the storage account.
        """
        AzureFileContentsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_name=account_name,
            container_name=container_name,
            contents_type=contents_type,
            credentials=credentials,
            endpoint=endpoint,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_name: Optional[str] = None,
             container_name: Optional[str] = None,
             contents_type: Optional[str] = None,
             credentials: Optional[Any] = None,
             endpoint: Optional[str] = None,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if account_name is None and 'accountName' in kwargs:
            account_name = kwargs['accountName']
        if account_name is None:
            raise TypeError("Missing 'account_name' argument")
        if container_name is None and 'containerName' in kwargs:
            container_name = kwargs['containerName']
        if container_name is None:
            raise TypeError("Missing 'container_name' argument")
        if contents_type is None and 'contentsType' in kwargs:
            contents_type = kwargs['contentsType']
        if contents_type is None:
            raise TypeError("Missing 'contents_type' argument")
        if credentials is None:
            raise TypeError("Missing 'credentials' argument")
        if endpoint is None:
            raise TypeError("Missing 'endpoint' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")

        _setter("account_name", account_name)
        _setter("container_name", container_name)
        _setter("contents_type", 'AzureFile')
        _setter("credentials", credentials)
        _setter("endpoint", endpoint)
        _setter("protocol", protocol)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        [Required] Storage account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        """
        [Required] Storage account container name.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter(name="contentsType")
    def contents_type(self) -> str:
        """
        Enum to determine the datastore contents type.
        Expected value is 'AzureFile'.
        """
        return pulumi.get(self, "contents_type")

    @property
    @pulumi.getter
    def credentials(self) -> Any:
        """
        [Required] Account credentials.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        [Required] Azure cloud endpoint for the storage account.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        [Required] Protocol used to communicate with the storage account.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class AzurePostgreSqlContentsResponse(dict):
    """
    Azure Postgre SQL datastore configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentsType":
            suggest = "contents_type"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "portNumber":
            suggest = "port_number"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "enableSSL":
            suggest = "enable_ssl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzurePostgreSqlContentsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzurePostgreSqlContentsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzurePostgreSqlContentsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contents_type: str,
                 credentials: Any,
                 database_name: str,
                 endpoint: str,
                 port_number: int,
                 server_name: str,
                 enable_ssl: Optional[bool] = None):
        """
        Azure Postgre SQL datastore configuration.
        :param str contents_type: Enum to determine the datastore contents type.
               Expected value is 'AzurePostgreSql'.
        :param Union['AccountKeyDatastoreCredentialsResponse', 'CertificateDatastoreCredentialsResponse', 'NoneDatastoreCredentialsResponse', 'SasDatastoreCredentialsResponse', 'ServicePrincipalDatastoreCredentialsResponse', 'SqlAdminDatastoreCredentialsResponse'] credentials: [Required] Account credentials.
        :param str database_name: [Required] Azure SQL database name.
        :param str endpoint: [Required] Azure cloud endpoint for the database.
        :param int port_number: [Required] Azure SQL server port.
        :param str server_name: [Required] Azure SQL server name.
        :param bool enable_ssl: Whether the Azure PostgreSQL server requires SSL.
        """
        AzurePostgreSqlContentsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            contents_type=contents_type,
            credentials=credentials,
            database_name=database_name,
            endpoint=endpoint,
            port_number=port_number,
            server_name=server_name,
            enable_ssl=enable_ssl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             contents_type: Optional[str] = None,
             credentials: Optional[Any] = None,
             database_name: Optional[str] = None,
             endpoint: Optional[str] = None,
             port_number: Optional[int] = None,
             server_name: Optional[str] = None,
             enable_ssl: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if contents_type is None and 'contentsType' in kwargs:
            contents_type = kwargs['contentsType']
        if contents_type is None:
            raise TypeError("Missing 'contents_type' argument")
        if credentials is None:
            raise TypeError("Missing 'credentials' argument")
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if endpoint is None:
            raise TypeError("Missing 'endpoint' argument")
        if port_number is None and 'portNumber' in kwargs:
            port_number = kwargs['portNumber']
        if port_number is None:
            raise TypeError("Missing 'port_number' argument")
        if server_name is None and 'serverName' in kwargs:
            server_name = kwargs['serverName']
        if server_name is None:
            raise TypeError("Missing 'server_name' argument")
        if enable_ssl is None and 'enableSSL' in kwargs:
            enable_ssl = kwargs['enableSSL']

        _setter("contents_type", 'AzurePostgreSql')
        _setter("credentials", credentials)
        _setter("database_name", database_name)
        _setter("endpoint", endpoint)
        _setter("port_number", port_number)
        _setter("server_name", server_name)
        if enable_ssl is not None:
            _setter("enable_ssl", enable_ssl)

    @property
    @pulumi.getter(name="contentsType")
    def contents_type(self) -> str:
        """
        Enum to determine the datastore contents type.
        Expected value is 'AzurePostgreSql'.
        """
        return pulumi.get(self, "contents_type")

    @property
    @pulumi.getter
    def credentials(self) -> Any:
        """
        [Required] Account credentials.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        [Required] Azure SQL database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        [Required] Azure cloud endpoint for the database.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="portNumber")
    def port_number(self) -> int:
        """
        [Required] Azure SQL server port.
        """
        return pulumi.get(self, "port_number")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> str:
        """
        [Required] Azure SQL server name.
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter(name="enableSSL")
    def enable_ssl(self) -> Optional[bool]:
        """
        Whether the Azure PostgreSQL server requires SSL.
        """
        return pulumi.get(self, "enable_ssl")


@pulumi.output_type
class AzureSqlDatabaseContentsResponse(dict):
    """
    Azure SQL Database datastore configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentsType":
            suggest = "contents_type"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "portNumber":
            suggest = "port_number"
        elif key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureSqlDatabaseContentsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureSqlDatabaseContentsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureSqlDatabaseContentsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contents_type: str,
                 credentials: Any,
                 database_name: str,
                 endpoint: str,
                 port_number: int,
                 server_name: str):
        """
        Azure SQL Database datastore configuration.
        :param str contents_type: Enum to determine the datastore contents type.
               Expected value is 'AzureSqlDatabase'.
        :param Union['AccountKeyDatastoreCredentialsResponse', 'CertificateDatastoreCredentialsResponse', 'NoneDatastoreCredentialsResponse', 'SasDatastoreCredentialsResponse', 'ServicePrincipalDatastoreCredentialsResponse', 'SqlAdminDatastoreCredentialsResponse'] credentials: [Required] Account credentials.
        :param str database_name: [Required] Azure SQL database name.
        :param str endpoint: [Required] Azure cloud endpoint for the database.
        :param int port_number: [Required] Azure SQL server port.
        :param str server_name: [Required] Azure SQL server name.
        """
        AzureSqlDatabaseContentsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            contents_type=contents_type,
            credentials=credentials,
            database_name=database_name,
            endpoint=endpoint,
            port_number=port_number,
            server_name=server_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             contents_type: Optional[str] = None,
             credentials: Optional[Any] = None,
             database_name: Optional[str] = None,
             endpoint: Optional[str] = None,
             port_number: Optional[int] = None,
             server_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if contents_type is None and 'contentsType' in kwargs:
            contents_type = kwargs['contentsType']
        if contents_type is None:
            raise TypeError("Missing 'contents_type' argument")
        if credentials is None:
            raise TypeError("Missing 'credentials' argument")
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if endpoint is None:
            raise TypeError("Missing 'endpoint' argument")
        if port_number is None and 'portNumber' in kwargs:
            port_number = kwargs['portNumber']
        if port_number is None:
            raise TypeError("Missing 'port_number' argument")
        if server_name is None and 'serverName' in kwargs:
            server_name = kwargs['serverName']
        if server_name is None:
            raise TypeError("Missing 'server_name' argument")

        _setter("contents_type", 'AzureSqlDatabase')
        _setter("credentials", credentials)
        _setter("database_name", database_name)
        _setter("endpoint", endpoint)
        _setter("port_number", port_number)
        _setter("server_name", server_name)

    @property
    @pulumi.getter(name="contentsType")
    def contents_type(self) -> str:
        """
        Enum to determine the datastore contents type.
        Expected value is 'AzureSqlDatabase'.
        """
        return pulumi.get(self, "contents_type")

    @property
    @pulumi.getter
    def credentials(self) -> Any:
        """
        [Required] Account credentials.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        [Required] Azure SQL database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        [Required] Azure cloud endpoint for the database.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="portNumber")
    def port_number(self) -> int:
        """
        [Required] Azure SQL server port.
        """
        return pulumi.get(self, "port_number")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> str:
        """
        [Required] Azure SQL server name.
        """
        return pulumi.get(self, "server_name")


@pulumi.output_type
class BanditPolicyResponse(dict):
    """
    Defines an early termination policy based on slack criteria, and a frequency and delay interval for evaluation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyType":
            suggest = "policy_type"
        elif key == "delayEvaluation":
            suggest = "delay_evaluation"
        elif key == "evaluationInterval":
            suggest = "evaluation_interval"
        elif key == "slackAmount":
            suggest = "slack_amount"
        elif key == "slackFactor":
            suggest = "slack_factor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BanditPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BanditPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BanditPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_type: str,
                 delay_evaluation: Optional[int] = None,
                 evaluation_interval: Optional[int] = None,
                 slack_amount: Optional[float] = None,
                 slack_factor: Optional[float] = None):
        """
        Defines an early termination policy based on slack criteria, and a frequency and delay interval for evaluation.
        :param str policy_type: 
               Expected value is 'Bandit'.
        :param int delay_evaluation: Number of intervals by which to delay the first evaluation.
        :param int evaluation_interval: Interval (number of runs) between policy evaluations.
        :param float slack_amount: Absolute distance allowed from the best performing run.
        :param float slack_factor: Ratio of the allowed distance from the best performing run.
        """
        BanditPolicyResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy_type=policy_type,
            delay_evaluation=delay_evaluation,
            evaluation_interval=evaluation_interval,
            slack_amount=slack_amount,
            slack_factor=slack_factor,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy_type: Optional[str] = None,
             delay_evaluation: Optional[int] = None,
             evaluation_interval: Optional[int] = None,
             slack_amount: Optional[float] = None,
             slack_factor: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if policy_type is None and 'policyType' in kwargs:
            policy_type = kwargs['policyType']
        if policy_type is None:
            raise TypeError("Missing 'policy_type' argument")
        if delay_evaluation is None and 'delayEvaluation' in kwargs:
            delay_evaluation = kwargs['delayEvaluation']
        if evaluation_interval is None and 'evaluationInterval' in kwargs:
            evaluation_interval = kwargs['evaluationInterval']
        if slack_amount is None and 'slackAmount' in kwargs:
            slack_amount = kwargs['slackAmount']
        if slack_factor is None and 'slackFactor' in kwargs:
            slack_factor = kwargs['slackFactor']

        _setter("policy_type", 'Bandit')
        if delay_evaluation is not None:
            _setter("delay_evaluation", delay_evaluation)
        if evaluation_interval is not None:
            _setter("evaluation_interval", evaluation_interval)
        if slack_amount is not None:
            _setter("slack_amount", slack_amount)
        if slack_factor is not None:
            _setter("slack_factor", slack_factor)

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> str:
        """

        Expected value is 'Bandit'.
        """
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="delayEvaluation")
    def delay_evaluation(self) -> Optional[int]:
        """
        Number of intervals by which to delay the first evaluation.
        """
        return pulumi.get(self, "delay_evaluation")

    @property
    @pulumi.getter(name="evaluationInterval")
    def evaluation_interval(self) -> Optional[int]:
        """
        Interval (number of runs) between policy evaluations.
        """
        return pulumi.get(self, "evaluation_interval")

    @property
    @pulumi.getter(name="slackAmount")
    def slack_amount(self) -> Optional[float]:
        """
        Absolute distance allowed from the best performing run.
        """
        return pulumi.get(self, "slack_amount")

    @property
    @pulumi.getter(name="slackFactor")
    def slack_factor(self) -> Optional[float]:
        """
        Ratio of the allowed distance from the best performing run.
        """
        return pulumi.get(self, "slack_factor")


@pulumi.output_type
class BatchDeploymentResponse(dict):
    """
    Batch inference settings per deployment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codeConfiguration":
            suggest = "code_configuration"
        elif key == "environmentId":
            suggest = "environment_id"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "errorThreshold":
            suggest = "error_threshold"
        elif key == "loggingLevel":
            suggest = "logging_level"
        elif key == "miniBatchSize":
            suggest = "mini_batch_size"
        elif key == "outputConfiguration":
            suggest = "output_configuration"
        elif key == "partitionKeys":
            suggest = "partition_keys"
        elif key == "retrySettings":
            suggest = "retry_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BatchDeploymentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BatchDeploymentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BatchDeploymentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code_configuration: Optional['outputs.CodeConfigurationResponse'] = None,
                 compute: Optional['outputs.ComputeConfigurationResponse'] = None,
                 description: Optional[str] = None,
                 environment_id: Optional[str] = None,
                 environment_variables: Optional[Mapping[str, str]] = None,
                 error_threshold: Optional[int] = None,
                 logging_level: Optional[str] = None,
                 mini_batch_size: Optional[float] = None,
                 model: Optional[Any] = None,
                 output_configuration: Optional['outputs.BatchOutputConfigurationResponse'] = None,
                 partition_keys: Optional[Sequence[str]] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 retry_settings: Optional['outputs.BatchRetrySettingsResponse'] = None):
        """
        Batch inference settings per deployment.
        :param 'CodeConfigurationResponse' code_configuration: Code configuration for the endpoint deployment.
        :param 'ComputeConfigurationResponse' compute: Configuration for compute binding.
        :param str description: Description of the endpoint deployment.
        :param str environment_id: ARM resource ID of the environment specification for the endpoint deployment.
        :param Mapping[str, str] environment_variables: Environment variables configuration for the deployment.
        :param int error_threshold: Error threshold, if the error count for the entire input goes above this value,
               the batch inference will be aborted. Range is [-1, int.MaxValue].
               For FileDataset, this value is the count of file failures.
               For TabularDataset, this value is the count of record failures.
               If set to -1 (the lower bound), all failures during batch inference will be ignored.
        :param str logging_level: Logging level for batch inference operation.
        :param float mini_batch_size: Size of the mini-batch passed to each batch invocation.
               For FileDataset, this is the number of files per mini-batch.
               For TabularDataset, this is the size of the records in bytes, per mini-batch.
        :param Union['DataPathAssetReferenceResponse', 'IdAssetReferenceResponse', 'OutputPathAssetReferenceResponse'] model: Reference to the model asset for the endpoint deployment.
        :param 'BatchOutputConfigurationResponse' output_configuration: Output configuration for the batch inference operation.
        :param Sequence[str] partition_keys: Partition keys list used for Named partitioning.
        :param Mapping[str, str] properties: Property dictionary. Properties can be added, but not removed or altered.
        :param 'BatchRetrySettingsResponse' retry_settings: Retry Settings for the batch inference operation.
        """
        BatchDeploymentResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code_configuration=code_configuration,
            compute=compute,
            description=description,
            environment_id=environment_id,
            environment_variables=environment_variables,
            error_threshold=error_threshold,
            logging_level=logging_level,
            mini_batch_size=mini_batch_size,
            model=model,
            output_configuration=output_configuration,
            partition_keys=partition_keys,
            properties=properties,
            retry_settings=retry_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code_configuration: Optional['outputs.CodeConfigurationResponse'] = None,
             compute: Optional['outputs.ComputeConfigurationResponse'] = None,
             description: Optional[str] = None,
             environment_id: Optional[str] = None,
             environment_variables: Optional[Mapping[str, str]] = None,
             error_threshold: Optional[int] = None,
             logging_level: Optional[str] = None,
             mini_batch_size: Optional[float] = None,
             model: Optional[Any] = None,
             output_configuration: Optional['outputs.BatchOutputConfigurationResponse'] = None,
             partition_keys: Optional[Sequence[str]] = None,
             properties: Optional[Mapping[str, str]] = None,
             retry_settings: Optional['outputs.BatchRetrySettingsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if code_configuration is None and 'codeConfiguration' in kwargs:
            code_configuration = kwargs['codeConfiguration']
        if environment_id is None and 'environmentId' in kwargs:
            environment_id = kwargs['environmentId']
        if environment_variables is None and 'environmentVariables' in kwargs:
            environment_variables = kwargs['environmentVariables']
        if error_threshold is None and 'errorThreshold' in kwargs:
            error_threshold = kwargs['errorThreshold']
        if logging_level is None and 'loggingLevel' in kwargs:
            logging_level = kwargs['loggingLevel']
        if mini_batch_size is None and 'miniBatchSize' in kwargs:
            mini_batch_size = kwargs['miniBatchSize']
        if output_configuration is None and 'outputConfiguration' in kwargs:
            output_configuration = kwargs['outputConfiguration']
        if partition_keys is None and 'partitionKeys' in kwargs:
            partition_keys = kwargs['partitionKeys']
        if retry_settings is None and 'retrySettings' in kwargs:
            retry_settings = kwargs['retrySettings']

        if code_configuration is not None:
            _setter("code_configuration", code_configuration)
        if compute is not None:
            _setter("compute", compute)
        if description is not None:
            _setter("description", description)
        if environment_id is not None:
            _setter("environment_id", environment_id)
        if environment_variables is not None:
            _setter("environment_variables", environment_variables)
        if error_threshold is not None:
            _setter("error_threshold", error_threshold)
        if logging_level is not None:
            _setter("logging_level", logging_level)
        if mini_batch_size is not None:
            _setter("mini_batch_size", mini_batch_size)
        if model is not None:
            _setter("model", model)
        if output_configuration is not None:
            _setter("output_configuration", output_configuration)
        if partition_keys is not None:
            _setter("partition_keys", partition_keys)
        if properties is not None:
            _setter("properties", properties)
        if retry_settings is not None:
            _setter("retry_settings", retry_settings)

    @property
    @pulumi.getter(name="codeConfiguration")
    def code_configuration(self) -> Optional['outputs.CodeConfigurationResponse']:
        """
        Code configuration for the endpoint deployment.
        """
        return pulumi.get(self, "code_configuration")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.ComputeConfigurationResponse']:
        """
        Configuration for compute binding.
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the endpoint deployment.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[str]:
        """
        ARM resource ID of the environment specification for the endpoint deployment.
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, str]]:
        """
        Environment variables configuration for the deployment.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="errorThreshold")
    def error_threshold(self) -> Optional[int]:
        """
        Error threshold, if the error count for the entire input goes above this value,
        the batch inference will be aborted. Range is [-1, int.MaxValue].
        For FileDataset, this value is the count of file failures.
        For TabularDataset, this value is the count of record failures.
        If set to -1 (the lower bound), all failures during batch inference will be ignored.
        """
        return pulumi.get(self, "error_threshold")

    @property
    @pulumi.getter(name="loggingLevel")
    def logging_level(self) -> Optional[str]:
        """
        Logging level for batch inference operation.
        """
        return pulumi.get(self, "logging_level")

    @property
    @pulumi.getter(name="miniBatchSize")
    def mini_batch_size(self) -> Optional[float]:
        """
        Size of the mini-batch passed to each batch invocation.
        For FileDataset, this is the number of files per mini-batch.
        For TabularDataset, this is the size of the records in bytes, per mini-batch.
        """
        return pulumi.get(self, "mini_batch_size")

    @property
    @pulumi.getter
    def model(self) -> Optional[Any]:
        """
        Reference to the model asset for the endpoint deployment.
        """
        return pulumi.get(self, "model")

    @property
    @pulumi.getter(name="outputConfiguration")
    def output_configuration(self) -> Optional['outputs.BatchOutputConfigurationResponse']:
        """
        Output configuration for the batch inference operation.
        """
        return pulumi.get(self, "output_configuration")

    @property
    @pulumi.getter(name="partitionKeys")
    def partition_keys(self) -> Optional[Sequence[str]]:
        """
        Partition keys list used for Named partitioning.
        """
        return pulumi.get(self, "partition_keys")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="retrySettings")
    def retry_settings(self) -> Optional['outputs.BatchRetrySettingsResponse']:
        """
        Retry Settings for the batch inference operation.
        """
        return pulumi.get(self, "retry_settings")


@pulumi.output_type
class BatchEndpointResponse(dict):
    """
    Batch endpoint configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scoringUri":
            suggest = "scoring_uri"
        elif key == "swaggerUri":
            suggest = "swagger_uri"
        elif key == "authMode":
            suggest = "auth_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BatchEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BatchEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BatchEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scoring_uri: str,
                 swagger_uri: str,
                 auth_mode: Optional[str] = None,
                 description: Optional[str] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 traffic: Optional[Mapping[str, int]] = None):
        """
        Batch endpoint configuration.
        :param str scoring_uri: Endpoint URI.
        :param str swagger_uri: Endpoint Swagger URI.
        :param str auth_mode: [Required] Inference endpoint authentication mode type
        :param str description: Description of the inference endpoint.
        :param Mapping[str, str] properties: Property dictionary. Properties can be added, but not removed or altered.
        :param Mapping[str, int] traffic: Traffic rules on how the traffic will be routed across deployments.
        """
        BatchEndpointResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scoring_uri=scoring_uri,
            swagger_uri=swagger_uri,
            auth_mode=auth_mode,
            description=description,
            properties=properties,
            traffic=traffic,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scoring_uri: Optional[str] = None,
             swagger_uri: Optional[str] = None,
             auth_mode: Optional[str] = None,
             description: Optional[str] = None,
             properties: Optional[Mapping[str, str]] = None,
             traffic: Optional[Mapping[str, int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if scoring_uri is None and 'scoringUri' in kwargs:
            scoring_uri = kwargs['scoringUri']
        if scoring_uri is None:
            raise TypeError("Missing 'scoring_uri' argument")
        if swagger_uri is None and 'swaggerUri' in kwargs:
            swagger_uri = kwargs['swaggerUri']
        if swagger_uri is None:
            raise TypeError("Missing 'swagger_uri' argument")
        if auth_mode is None and 'authMode' in kwargs:
            auth_mode = kwargs['authMode']

        _setter("scoring_uri", scoring_uri)
        _setter("swagger_uri", swagger_uri)
        if auth_mode is not None:
            _setter("auth_mode", auth_mode)
        if description is not None:
            _setter("description", description)
        if properties is not None:
            _setter("properties", properties)
        if traffic is not None:
            _setter("traffic", traffic)

    @property
    @pulumi.getter(name="scoringUri")
    def scoring_uri(self) -> str:
        """
        Endpoint URI.
        """
        return pulumi.get(self, "scoring_uri")

    @property
    @pulumi.getter(name="swaggerUri")
    def swagger_uri(self) -> str:
        """
        Endpoint Swagger URI.
        """
        return pulumi.get(self, "swagger_uri")

    @property
    @pulumi.getter(name="authMode")
    def auth_mode(self) -> Optional[str]:
        """
        [Required] Inference endpoint authentication mode type
        """
        return pulumi.get(self, "auth_mode")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the inference endpoint.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def traffic(self) -> Optional[Mapping[str, int]]:
        """
        Traffic rules on how the traffic will be routed across deployments.
        """
        return pulumi.get(self, "traffic")


@pulumi.output_type
class BatchOutputConfigurationResponse(dict):
    """
    Batch inference output configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appendRowFileName":
            suggest = "append_row_file_name"
        elif key == "outputAction":
            suggest = "output_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BatchOutputConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BatchOutputConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BatchOutputConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 append_row_file_name: Optional[str] = None,
                 output_action: Optional[str] = None):
        """
        Batch inference output configuration.
        :param str append_row_file_name: Customized output file name for append_row output action.
        :param str output_action: Indicates how the output will be organized.
        """
        BatchOutputConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            append_row_file_name=append_row_file_name,
            output_action=output_action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             append_row_file_name: Optional[str] = None,
             output_action: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if append_row_file_name is None and 'appendRowFileName' in kwargs:
            append_row_file_name = kwargs['appendRowFileName']
        if output_action is None and 'outputAction' in kwargs:
            output_action = kwargs['outputAction']

        if append_row_file_name is not None:
            _setter("append_row_file_name", append_row_file_name)
        if output_action is not None:
            _setter("output_action", output_action)

    @property
    @pulumi.getter(name="appendRowFileName")
    def append_row_file_name(self) -> Optional[str]:
        """
        Customized output file name for append_row output action.
        """
        return pulumi.get(self, "append_row_file_name")

    @property
    @pulumi.getter(name="outputAction")
    def output_action(self) -> Optional[str]:
        """
        Indicates how the output will be organized.
        """
        return pulumi.get(self, "output_action")


@pulumi.output_type
class BatchRetrySettingsResponse(dict):
    """
    Retry settings for a batch inference operation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxRetries":
            suggest = "max_retries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BatchRetrySettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BatchRetrySettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BatchRetrySettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_retries: Optional[int] = None,
                 timeout: Optional[str] = None):
        """
        Retry settings for a batch inference operation.
        :param int max_retries: Maximum retry count for a mini-batch
        :param str timeout: Invocation timeout for a mini-batch, in ISO 8601 format.
        """
        BatchRetrySettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_retries=max_retries,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_retries: Optional[int] = None,
             timeout: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_retries is None and 'maxRetries' in kwargs:
            max_retries = kwargs['maxRetries']

        if max_retries is not None:
            _setter("max_retries", max_retries)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[int]:
        """
        Maximum retry count for a mini-batch
        """
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        Invocation timeout for a mini-batch, in ISO 8601 format.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class CertificateDatastoreCredentialsResponse(dict):
    """
    Certificate datastore credentials configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "credentialsType":
            suggest = "credentials_type"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "authorityUrl":
            suggest = "authority_url"
        elif key == "resourceUri":
            suggest = "resource_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificateDatastoreCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificateDatastoreCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificateDatastoreCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 credentials_type: str,
                 tenant_id: str,
                 thumbprint: str,
                 authority_url: Optional[str] = None,
                 resource_uri: Optional[str] = None):
        """
        Certificate datastore credentials configuration.
        :param str client_id: [Required] Service principal client ID.
        :param str credentials_type: Enum to determine the datastore credentials type.
               Expected value is 'Certificate'.
        :param str tenant_id: [Required] ID of the tenant to which the service principal belongs.
        :param str thumbprint: [Required] Thumbprint of the certificate used for authentication.
        :param str authority_url: Authority URL used for authentication.
        :param str resource_uri: Resource the service principal has access to.
        """
        CertificateDatastoreCredentialsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            credentials_type=credentials_type,
            tenant_id=tenant_id,
            thumbprint=thumbprint,
            authority_url=authority_url,
            resource_uri=resource_uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[str] = None,
             credentials_type: Optional[str] = None,
             tenant_id: Optional[str] = None,
             thumbprint: Optional[str] = None,
             authority_url: Optional[str] = None,
             resource_uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_id is None:
            raise TypeError("Missing 'client_id' argument")
        if credentials_type is None and 'credentialsType' in kwargs:
            credentials_type = kwargs['credentialsType']
        if credentials_type is None:
            raise TypeError("Missing 'credentials_type' argument")
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_id is None:
            raise TypeError("Missing 'tenant_id' argument")
        if thumbprint is None:
            raise TypeError("Missing 'thumbprint' argument")
        if authority_url is None and 'authorityUrl' in kwargs:
            authority_url = kwargs['authorityUrl']
        if resource_uri is None and 'resourceUri' in kwargs:
            resource_uri = kwargs['resourceUri']

        _setter("client_id", client_id)
        _setter("credentials_type", 'Certificate')
        _setter("tenant_id", tenant_id)
        _setter("thumbprint", thumbprint)
        if authority_url is not None:
            _setter("authority_url", authority_url)
        if resource_uri is not None:
            _setter("resource_uri", resource_uri)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        [Required] Service principal client ID.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="credentialsType")
    def credentials_type(self) -> str:
        """
        Enum to determine the datastore credentials type.
        Expected value is 'Certificate'.
        """
        return pulumi.get(self, "credentials_type")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        [Required] ID of the tenant to which the service principal belongs.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def thumbprint(self) -> str:
        """
        [Required] Thumbprint of the certificate used for authentication.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter(name="authorityUrl")
    def authority_url(self) -> Optional[str]:
        """
        Authority URL used for authentication.
        """
        return pulumi.get(self, "authority_url")

    @property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[str]:
        """
        Resource the service principal has access to.
        """
        return pulumi.get(self, "resource_uri")


@pulumi.output_type
class CodeConfigurationResponse(dict):
    """
    Configuration for a scoring code asset.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scoringScript":
            suggest = "scoring_script"
        elif key == "codeId":
            suggest = "code_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scoring_script: str,
                 code_id: Optional[str] = None):
        """
        Configuration for a scoring code asset.
        :param str scoring_script: [Required] The script to execute on startup. eg. "score.py"
        :param str code_id: ARM resource ID of the code asset.
        """
        CodeConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scoring_script=scoring_script,
            code_id=code_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scoring_script: Optional[str] = None,
             code_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if scoring_script is None and 'scoringScript' in kwargs:
            scoring_script = kwargs['scoringScript']
        if scoring_script is None:
            raise TypeError("Missing 'scoring_script' argument")
        if code_id is None and 'codeId' in kwargs:
            code_id = kwargs['codeId']

        _setter("scoring_script", scoring_script)
        if code_id is not None:
            _setter("code_id", code_id)

    @property
    @pulumi.getter(name="scoringScript")
    def scoring_script(self) -> str:
        """
        [Required] The script to execute on startup. eg. "score.py"
        """
        return pulumi.get(self, "scoring_script")

    @property
    @pulumi.getter(name="codeId")
    def code_id(self) -> Optional[str]:
        """
        ARM resource ID of the code asset.
        """
        return pulumi.get(self, "code_id")


@pulumi.output_type
class CodeContainerResponse(dict):
    """
    Container for code asset versions.
    """
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Container for code asset versions.
        :param str description: The asset description text.
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        CodeContainerResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if description is not None:
            _setter("description", description)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CodeVersionResponse(dict):
    """
    Code asset version details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datastoreId":
            suggest = "datastore_id"
        elif key == "isAnonymous":
            suggest = "is_anonymous"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 datastore_id: Optional[str] = None,
                 description: Optional[str] = None,
                 is_anonymous: Optional[bool] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Code asset version details.
        :param str path: [Required] The path of the file/directory in the datastore.
        :param str datastore_id: ARM resource ID of the datastore where the asset is located.
        :param str description: The asset description text.
        :param bool is_anonymous: If the name version are system generated (anonymous registration).
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        CodeVersionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            datastore_id=datastore_id,
            description=description,
            is_anonymous=is_anonymous,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[str] = None,
             datastore_id: Optional[str] = None,
             description: Optional[str] = None,
             is_anonymous: Optional[bool] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if path is None:
            raise TypeError("Missing 'path' argument")
        if datastore_id is None and 'datastoreId' in kwargs:
            datastore_id = kwargs['datastoreId']
        if is_anonymous is None and 'isAnonymous' in kwargs:
            is_anonymous = kwargs['isAnonymous']

        _setter("path", path)
        if datastore_id is not None:
            _setter("datastore_id", datastore_id)
        if description is not None:
            _setter("description", description)
        if is_anonymous is not None:
            _setter("is_anonymous", is_anonymous)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        [Required] The path of the file/directory in the datastore.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[str]:
        """
        ARM resource ID of the datastore where the asset is located.
        """
        return pulumi.get(self, "datastore_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[bool]:
        """
        If the name version are system generated (anonymous registration).
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CommandJobResponse(dict):
    """
    Command job definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interactionEndpoints":
            suggest = "interaction_endpoints"
        elif key == "jobType":
            suggest = "job_type"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "codeId":
            suggest = "code_id"
        elif key == "environmentId":
            suggest = "environment_id"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "experimentName":
            suggest = "experiment_name"
        elif key == "inputDataBindings":
            suggest = "input_data_bindings"
        elif key == "outputDataBindings":
            suggest = "output_data_bindings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CommandJobResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CommandJobResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CommandJobResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command: str,
                 compute: 'outputs.ComputeConfigurationResponse',
                 interaction_endpoints: Mapping[str, 'outputs.JobEndpointResponse'],
                 job_type: str,
                 output: 'outputs.JobOutputResponse',
                 parameters: Any,
                 provisioning_state: str,
                 status: str,
                 code_id: Optional[str] = None,
                 description: Optional[str] = None,
                 distribution: Optional[Any] = None,
                 environment_id: Optional[str] = None,
                 environment_variables: Optional[Mapping[str, str]] = None,
                 experiment_name: Optional[str] = None,
                 identity: Optional[Any] = None,
                 input_data_bindings: Optional[Mapping[str, 'outputs.InputDataBindingResponse']] = None,
                 output_data_bindings: Optional[Mapping[str, 'outputs.OutputDataBindingResponse']] = None,
                 priority: Optional[int] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 timeout: Optional[str] = None):
        """
        Command job definition.
        :param str command: [Required] The command to execute on startup of the job. eg. "python train.py"
        :param 'ComputeConfigurationResponse' compute: [Required] Compute binding for the job.
        :param Mapping[str, 'JobEndpointResponse'] interaction_endpoints: List of JobEndpoints.
               For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        :param str job_type: Enum to determine the type of job.
               Expected value is 'Command'.
        :param 'JobOutputResponse' output: Location of the job output logs and artifacts.
        :param Any parameters: Input parameters.
        :param str provisioning_state: Specifies the job provisioning state.
        :param str status: Status of the job.
        :param str code_id: ARM resource ID of the code asset.
        :param str description: The asset description text.
        :param Union['MpiResponse', 'PyTorchResponse', 'TensorFlowResponse'] distribution: Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, or null.
        :param str environment_id: The ARM resource ID of the Environment specification for the job.
        :param Mapping[str, str] environment_variables: Environment variables included in the job.
        :param str experiment_name: The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        :param Union['AmlTokenResponse', 'ManagedIdentityResponse'] identity: Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, or null.
               Defaults to AmlToken if null.
        :param Mapping[str, 'InputDataBindingResponse'] input_data_bindings: Mapping of input data bindings used in the job.
        :param Mapping[str, 'OutputDataBindingResponse'] output_data_bindings: Mapping of output data bindings used in the job.
        :param int priority: Job priority for scheduling policy. Only applies to AMLCompute.
               Private preview feature and only available to users on the allow list.
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        :param str timeout: The max run duration in ISO 8601 format, after which the job will be cancelled. Only supports duration with precision as low as Seconds.
        """
        CommandJobResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            command=command,
            compute=compute,
            interaction_endpoints=interaction_endpoints,
            job_type=job_type,
            output=output,
            parameters=parameters,
            provisioning_state=provisioning_state,
            status=status,
            code_id=code_id,
            description=description,
            distribution=distribution,
            environment_id=environment_id,
            environment_variables=environment_variables,
            experiment_name=experiment_name,
            identity=identity,
            input_data_bindings=input_data_bindings,
            output_data_bindings=output_data_bindings,
            priority=priority,
            properties=properties,
            tags=tags,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             command: Optional[str] = None,
             compute: Optional['outputs.ComputeConfigurationResponse'] = None,
             interaction_endpoints: Optional[Mapping[str, 'outputs.JobEndpointResponse']] = None,
             job_type: Optional[str] = None,
             output: Optional['outputs.JobOutputResponse'] = None,
             parameters: Optional[Any] = None,
             provisioning_state: Optional[str] = None,
             status: Optional[str] = None,
             code_id: Optional[str] = None,
             description: Optional[str] = None,
             distribution: Optional[Any] = None,
             environment_id: Optional[str] = None,
             environment_variables: Optional[Mapping[str, str]] = None,
             experiment_name: Optional[str] = None,
             identity: Optional[Any] = None,
             input_data_bindings: Optional[Mapping[str, 'outputs.InputDataBindingResponse']] = None,
             output_data_bindings: Optional[Mapping[str, 'outputs.OutputDataBindingResponse']] = None,
             priority: Optional[int] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             timeout: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if command is None:
            raise TypeError("Missing 'command' argument")
        if compute is None:
            raise TypeError("Missing 'compute' argument")
        if interaction_endpoints is None and 'interactionEndpoints' in kwargs:
            interaction_endpoints = kwargs['interactionEndpoints']
        if interaction_endpoints is None:
            raise TypeError("Missing 'interaction_endpoints' argument")
        if job_type is None and 'jobType' in kwargs:
            job_type = kwargs['jobType']
        if job_type is None:
            raise TypeError("Missing 'job_type' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if code_id is None and 'codeId' in kwargs:
            code_id = kwargs['codeId']
        if environment_id is None and 'environmentId' in kwargs:
            environment_id = kwargs['environmentId']
        if environment_variables is None and 'environmentVariables' in kwargs:
            environment_variables = kwargs['environmentVariables']
        if experiment_name is None and 'experimentName' in kwargs:
            experiment_name = kwargs['experimentName']
        if input_data_bindings is None and 'inputDataBindings' in kwargs:
            input_data_bindings = kwargs['inputDataBindings']
        if output_data_bindings is None and 'outputDataBindings' in kwargs:
            output_data_bindings = kwargs['outputDataBindings']

        _setter("command", command)
        _setter("compute", compute)
        _setter("interaction_endpoints", interaction_endpoints)
        _setter("job_type", 'Command')
        _setter("output", output)
        _setter("parameters", parameters)
        _setter("provisioning_state", provisioning_state)
        _setter("status", status)
        if code_id is not None:
            _setter("code_id", code_id)
        if description is not None:
            _setter("description", description)
        if distribution is not None:
            _setter("distribution", distribution)
        if environment_id is not None:
            _setter("environment_id", environment_id)
        if environment_variables is not None:
            _setter("environment_variables", environment_variables)
        if experiment_name is not None:
            _setter("experiment_name", experiment_name)
        if identity is not None:
            _setter("identity", identity)
        if input_data_bindings is not None:
            _setter("input_data_bindings", input_data_bindings)
        if output_data_bindings is not None:
            _setter("output_data_bindings", output_data_bindings)
        if priority is not None:
            _setter("priority", priority)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter
    def command(self) -> str:
        """
        [Required] The command to execute on startup of the job. eg. "python train.py"
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.ComputeConfigurationResponse':
        """
        [Required] Compute binding for the job.
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="interactionEndpoints")
    def interaction_endpoints(self) -> Mapping[str, 'outputs.JobEndpointResponse']:
        """
        List of JobEndpoints.
        For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        """
        return pulumi.get(self, "interaction_endpoints")

    @property
    @pulumi.getter(name="jobType")
    def job_type(self) -> str:
        """
        Enum to determine the type of job.
        Expected value is 'Command'.
        """
        return pulumi.get(self, "job_type")

    @property
    @pulumi.getter
    def output(self) -> 'outputs.JobOutputResponse':
        """
        Location of the job output logs and artifacts.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def parameters(self) -> Any:
        """
        Input parameters.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Specifies the job provisioning state.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the job.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="codeId")
    def code_id(self) -> Optional[str]:
        """
        ARM resource ID of the code asset.
        """
        return pulumi.get(self, "code_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def distribution(self) -> Optional[Any]:
        """
        Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, or null.
        """
        return pulumi.get(self, "distribution")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[str]:
        """
        The ARM resource ID of the Environment specification for the job.
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, str]]:
        """
        Environment variables included in the job.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="experimentName")
    def experiment_name(self) -> Optional[str]:
        """
        The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        """
        return pulumi.get(self, "experiment_name")

    @property
    @pulumi.getter
    def identity(self) -> Optional[Any]:
        """
        Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, or null.
        Defaults to AmlToken if null.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter(name="inputDataBindings")
    def input_data_bindings(self) -> Optional[Mapping[str, 'outputs.InputDataBindingResponse']]:
        """
        Mapping of input data bindings used in the job.
        """
        return pulumi.get(self, "input_data_bindings")

    @property
    @pulumi.getter(name="outputDataBindings")
    def output_data_bindings(self) -> Optional[Mapping[str, 'outputs.OutputDataBindingResponse']]:
        """
        Mapping of output data bindings used in the job.
        """
        return pulumi.get(self, "output_data_bindings")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Job priority for scheduling policy. Only applies to AMLCompute.
        Private preview feature and only available to users on the allow list.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        The max run duration in ISO 8601 format, after which the job will be cancelled. Only supports duration with precision as low as Seconds.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ComputeConfigurationResponse(dict):
    """
    Configuration for compute binding.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceCount":
            suggest = "instance_count"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "isLocal":
            suggest = "is_local"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_count: Optional[int] = None,
                 instance_type: Optional[str] = None,
                 is_local: Optional[bool] = None,
                 location: Optional[str] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 target: Optional[str] = None):
        """
        Configuration for compute binding.
        :param int instance_count: Number of instances or nodes.
        :param str instance_type: SKU type to run on.
        :param bool is_local: Set to true for jobs running on local compute.
        :param str location: Location for virtual cluster run.
        :param Mapping[str, str] properties: Additional properties.
        :param str target: ARM resource ID of the Compute you are targeting. If not provided the resource will be deployed as Managed.
        """
        ComputeConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_count=instance_count,
            instance_type=instance_type,
            is_local=is_local,
            location=location,
            properties=properties,
            target=target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_count: Optional[int] = None,
             instance_type: Optional[str] = None,
             is_local: Optional[bool] = None,
             location: Optional[str] = None,
             properties: Optional[Mapping[str, str]] = None,
             target: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if is_local is None and 'isLocal' in kwargs:
            is_local = kwargs['isLocal']

        if instance_count is not None:
            _setter("instance_count", instance_count)
        if instance_type is not None:
            _setter("instance_type", instance_type)
        if is_local is not None:
            _setter("is_local", is_local)
        if location is not None:
            _setter("location", location)
        if properties is not None:
            _setter("properties", properties)
        if target is not None:
            _setter("target", target)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[int]:
        """
        Number of instances or nodes.
        """
        return pulumi.get(self, "instance_count")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        SKU type to run on.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="isLocal")
    def is_local(self) -> Optional[bool]:
        """
        Set to true for jobs running on local compute.
        """
        return pulumi.get(self, "is_local")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Location for virtual cluster run.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        Additional properties.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        ARM resource ID of the Compute you are targeting. If not provided the resource will be deployed as Managed.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class ContainerResourceRequirementsResponse(dict):
    """
    The resource requirements for the container (cpu and memory).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuLimit":
            suggest = "cpu_limit"
        elif key == "memoryInGB":
            suggest = "memory_in_gb"
        elif key == "memoryInGBLimit":
            suggest = "memory_in_gb_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerResourceRequirementsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerResourceRequirementsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerResourceRequirementsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu: Optional[float] = None,
                 cpu_limit: Optional[float] = None,
                 fpga: Optional[int] = None,
                 gpu: Optional[int] = None,
                 memory_in_gb: Optional[float] = None,
                 memory_in_gb_limit: Optional[float] = None):
        """
        The resource requirements for the container (cpu and memory).
        :param float cpu: The minimum amount of CPU cores to be used by the container. More info:
               https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param float cpu_limit: The maximum amount of CPU cores allowed to be used by the container. More info:
               https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param int fpga: The number of FPGA PCIE devices exposed to the container. Must be multiple of 2.
        :param int gpu: The number of GPU cores in the container.
        :param float memory_in_gb: The minimum amount of memory (in GB) to be used by the container. More info:
               https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param float memory_in_gb_limit: The maximum amount of memory (in GB) allowed to be used by the container. More info:
               https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        ContainerResourceRequirementsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu=cpu,
            cpu_limit=cpu_limit,
            fpga=fpga,
            gpu=gpu,
            memory_in_gb=memory_in_gb,
            memory_in_gb_limit=memory_in_gb_limit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu: Optional[float] = None,
             cpu_limit: Optional[float] = None,
             fpga: Optional[int] = None,
             gpu: Optional[int] = None,
             memory_in_gb: Optional[float] = None,
             memory_in_gb_limit: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_limit is None and 'cpuLimit' in kwargs:
            cpu_limit = kwargs['cpuLimit']
        if memory_in_gb is None and 'memoryInGB' in kwargs:
            memory_in_gb = kwargs['memoryInGB']
        if memory_in_gb_limit is None and 'memoryInGBLimit' in kwargs:
            memory_in_gb_limit = kwargs['memoryInGBLimit']

        if cpu is not None:
            _setter("cpu", cpu)
        if cpu_limit is not None:
            _setter("cpu_limit", cpu_limit)
        if fpga is not None:
            _setter("fpga", fpga)
        if gpu is not None:
            _setter("gpu", gpu)
        if memory_in_gb is not None:
            _setter("memory_in_gb", memory_in_gb)
        if memory_in_gb_limit is not None:
            _setter("memory_in_gb_limit", memory_in_gb_limit)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[float]:
        """
        The minimum amount of CPU cores to be used by the container. More info:
        https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> Optional[float]:
        """
        The maximum amount of CPU cores allowed to be used by the container. More info:
        https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "cpu_limit")

    @property
    @pulumi.getter
    def fpga(self) -> Optional[int]:
        """
        The number of FPGA PCIE devices exposed to the container. Must be multiple of 2.
        """
        return pulumi.get(self, "fpga")

    @property
    @pulumi.getter
    def gpu(self) -> Optional[int]:
        """
        The number of GPU cores in the container.
        """
        return pulumi.get(self, "gpu")

    @property
    @pulumi.getter(name="memoryInGB")
    def memory_in_gb(self) -> Optional[float]:
        """
        The minimum amount of memory (in GB) to be used by the container. More info:
        https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "memory_in_gb")

    @property
    @pulumi.getter(name="memoryInGBLimit")
    def memory_in_gb_limit(self) -> Optional[float]:
        """
        The maximum amount of memory (in GB) allowed to be used by the container. More info:
        https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "memory_in_gb_limit")


@pulumi.output_type
class DataContainerResponse(dict):
    """
    Container for data asset versions.
    """
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Container for data asset versions.
        :param str description: The asset description text.
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        DataContainerResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if description is not None:
            _setter("description", description)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class DataPathAssetReferenceResponse(dict):
    """
    Reference to an asset via its path in a datastore.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referenceType":
            suggest = "reference_type"
        elif key == "datastoreId":
            suggest = "datastore_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataPathAssetReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataPathAssetReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataPathAssetReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reference_type: str,
                 datastore_id: Optional[str] = None,
                 path: Optional[str] = None):
        """
        Reference to an asset via its path in a datastore.
        :param str reference_type: Enum to determine which reference method to use for an asset.
               Expected value is 'DataPath'.
        :param str datastore_id: ARM resource ID of the datastore where the asset is located.
        :param str path: The path of the file/directory in the datastore.
        """
        DataPathAssetReferenceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            reference_type=reference_type,
            datastore_id=datastore_id,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             reference_type: Optional[str] = None,
             datastore_id: Optional[str] = None,
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if reference_type is None and 'referenceType' in kwargs:
            reference_type = kwargs['referenceType']
        if reference_type is None:
            raise TypeError("Missing 'reference_type' argument")
        if datastore_id is None and 'datastoreId' in kwargs:
            datastore_id = kwargs['datastoreId']

        _setter("reference_type", 'DataPath')
        if datastore_id is not None:
            _setter("datastore_id", datastore_id)
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter(name="referenceType")
    def reference_type(self) -> str:
        """
        Enum to determine which reference method to use for an asset.
        Expected value is 'DataPath'.
        """
        return pulumi.get(self, "reference_type")

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[str]:
        """
        ARM resource ID of the datastore where the asset is located.
        """
        return pulumi.get(self, "datastore_id")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path of the file/directory in the datastore.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DataVersionResponse(dict):
    """
    Data asset version details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetType":
            suggest = "dataset_type"
        elif key == "datastoreId":
            suggest = "datastore_id"
        elif key == "isAnonymous":
            suggest = "is_anonymous"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 dataset_type: Optional[str] = None,
                 datastore_id: Optional[str] = None,
                 description: Optional[str] = None,
                 is_anonymous: Optional[bool] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Data asset version details.
        :param str path: [Required] The path of the file/directory in the datastore.
        :param str dataset_type: The Format of dataset.
        :param str datastore_id: ARM resource ID of the datastore where the asset is located.
        :param str description: The asset description text.
        :param bool is_anonymous: If the name version are system generated (anonymous registration).
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        DataVersionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            dataset_type=dataset_type,
            datastore_id=datastore_id,
            description=description,
            is_anonymous=is_anonymous,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[str] = None,
             dataset_type: Optional[str] = None,
             datastore_id: Optional[str] = None,
             description: Optional[str] = None,
             is_anonymous: Optional[bool] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if path is None:
            raise TypeError("Missing 'path' argument")
        if dataset_type is None and 'datasetType' in kwargs:
            dataset_type = kwargs['datasetType']
        if datastore_id is None and 'datastoreId' in kwargs:
            datastore_id = kwargs['datastoreId']
        if is_anonymous is None and 'isAnonymous' in kwargs:
            is_anonymous = kwargs['isAnonymous']

        _setter("path", path)
        if dataset_type is not None:
            _setter("dataset_type", dataset_type)
        if datastore_id is not None:
            _setter("datastore_id", datastore_id)
        if description is not None:
            _setter("description", description)
        if is_anonymous is not None:
            _setter("is_anonymous", is_anonymous)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        [Required] The path of the file/directory in the datastore.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="datasetType")
    def dataset_type(self) -> Optional[str]:
        """
        The Format of dataset.
        """
        return pulumi.get(self, "dataset_type")

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[str]:
        """
        ARM resource ID of the datastore where the asset is located.
        """
        return pulumi.get(self, "datastore_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[bool]:
        """
        If the name version are system generated (anonymous registration).
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class DatastorePropertiesResponse(dict):
    """
    Datastore definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hasBeenValidated":
            suggest = "has_been_validated"
        elif key == "isDefault":
            suggest = "is_default"
        elif key == "linkedInfo":
            suggest = "linked_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatastorePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatastorePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatastorePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contents: Any,
                 has_been_validated: bool,
                 description: Optional[str] = None,
                 is_default: Optional[bool] = None,
                 linked_info: Optional['outputs.LinkedInfoResponse'] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Datastore definition.
        :param Union['AzureBlobContentsResponse', 'AzureDataLakeGen1ContentsResponse', 'AzureDataLakeGen2ContentsResponse', 'AzureFileContentsResponse', 'AzurePostgreSqlContentsResponse', 'AzureSqlDatabaseContentsResponse', 'GlusterFsContentsResponse'] contents: [Required] Reference to the datastore storage contents.
        :param bool has_been_validated: Whether the service has validated access to the datastore with the provided credentials.
        :param str description: The asset description text.
        :param bool is_default: Whether this datastore is the default for the workspace.
        :param 'LinkedInfoResponse' linked_info: Information about the datastore origin, if linked.
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        DatastorePropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            contents=contents,
            has_been_validated=has_been_validated,
            description=description,
            is_default=is_default,
            linked_info=linked_info,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             contents: Optional[Any] = None,
             has_been_validated: Optional[bool] = None,
             description: Optional[str] = None,
             is_default: Optional[bool] = None,
             linked_info: Optional['outputs.LinkedInfoResponse'] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if contents is None:
            raise TypeError("Missing 'contents' argument")
        if has_been_validated is None and 'hasBeenValidated' in kwargs:
            has_been_validated = kwargs['hasBeenValidated']
        if has_been_validated is None:
            raise TypeError("Missing 'has_been_validated' argument")
        if is_default is None and 'isDefault' in kwargs:
            is_default = kwargs['isDefault']
        if linked_info is None and 'linkedInfo' in kwargs:
            linked_info = kwargs['linkedInfo']

        _setter("contents", contents)
        _setter("has_been_validated", has_been_validated)
        if description is not None:
            _setter("description", description)
        if is_default is not None:
            _setter("is_default", is_default)
        if linked_info is not None:
            _setter("linked_info", linked_info)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def contents(self) -> Any:
        """
        [Required] Reference to the datastore storage contents.
        """
        return pulumi.get(self, "contents")

    @property
    @pulumi.getter(name="hasBeenValidated")
    def has_been_validated(self) -> bool:
        """
        Whether the service has validated access to the datastore with the provided credentials.
        """
        return pulumi.get(self, "has_been_validated")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[bool]:
        """
        Whether this datastore is the default for the workspace.
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter(name="linkedInfo")
    def linked_info(self) -> Optional['outputs.LinkedInfoResponse']:
        """
        Information about the datastore origin, if linked.
        """
        return pulumi.get(self, "linked_info")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class DockerBuildResponse(dict):
    """
    Class to represent configuration settings for Docker Build
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dockerSpecificationType":
            suggest = "docker_specification_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DockerBuildResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DockerBuildResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DockerBuildResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 docker_specification_type: str,
                 dockerfile: str,
                 context: Optional[str] = None,
                 platform: Optional['outputs.DockerImagePlatformResponse'] = None):
        """
        Class to represent configuration settings for Docker Build
        :param str docker_specification_type: Enum to determine docker specification type. Must be either Build or Image.
               Expected value is 'Build'.
        :param str dockerfile: [Required] Docker command line instructions to assemble an image.
               <seealso href="https://repo2docker.readthedocs.io/en/latest/config_files.html#dockerfile-advanced-environments" />
        :param str context: Path to a snapshot of the Docker Context. This property is only valid if Dockerfile is specified.
               The path is relative to the asset path which must contain a single Blob URI value.
               <seealso href="https://docs.docker.com/engine/context/working-with-contexts/" />
        :param 'DockerImagePlatformResponse' platform: The platform information of the docker image.
        """
        DockerBuildResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            docker_specification_type=docker_specification_type,
            dockerfile=dockerfile,
            context=context,
            platform=platform,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             docker_specification_type: Optional[str] = None,
             dockerfile: Optional[str] = None,
             context: Optional[str] = None,
             platform: Optional['outputs.DockerImagePlatformResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if docker_specification_type is None and 'dockerSpecificationType' in kwargs:
            docker_specification_type = kwargs['dockerSpecificationType']
        if docker_specification_type is None:
            raise TypeError("Missing 'docker_specification_type' argument")
        if dockerfile is None:
            raise TypeError("Missing 'dockerfile' argument")

        _setter("docker_specification_type", 'Build')
        _setter("dockerfile", dockerfile)
        if context is not None:
            _setter("context", context)
        if platform is not None:
            _setter("platform", platform)

    @property
    @pulumi.getter(name="dockerSpecificationType")
    def docker_specification_type(self) -> str:
        """
        Enum to determine docker specification type. Must be either Build or Image.
        Expected value is 'Build'.
        """
        return pulumi.get(self, "docker_specification_type")

    @property
    @pulumi.getter
    def dockerfile(self) -> str:
        """
        [Required] Docker command line instructions to assemble an image.
        <seealso href="https://repo2docker.readthedocs.io/en/latest/config_files.html#dockerfile-advanced-environments" />
        """
        return pulumi.get(self, "dockerfile")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        """
        Path to a snapshot of the Docker Context. This property is only valid if Dockerfile is specified.
        The path is relative to the asset path which must contain a single Blob URI value.
        <seealso href="https://docs.docker.com/engine/context/working-with-contexts/" />
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def platform(self) -> Optional['outputs.DockerImagePlatformResponse']:
        """
        The platform information of the docker image.
        """
        return pulumi.get(self, "platform")


@pulumi.output_type
class DockerImagePlatformResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatingSystemType":
            suggest = "operating_system_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DockerImagePlatformResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DockerImagePlatformResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DockerImagePlatformResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operating_system_type: Optional[str] = None):
        """
        :param str operating_system_type: The OS type the Environment.
        """
        DockerImagePlatformResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operating_system_type=operating_system_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operating_system_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operating_system_type is None and 'operatingSystemType' in kwargs:
            operating_system_type = kwargs['operatingSystemType']

        if operating_system_type is not None:
            _setter("operating_system_type", operating_system_type)

    @property
    @pulumi.getter(name="operatingSystemType")
    def operating_system_type(self) -> Optional[str]:
        """
        The OS type the Environment.
        """
        return pulumi.get(self, "operating_system_type")


@pulumi.output_type
class DockerImageResponse(dict):
    """
    Class to represent configuration settings for Docker Build
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dockerImageUri":
            suggest = "docker_image_uri"
        elif key == "dockerSpecificationType":
            suggest = "docker_specification_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DockerImageResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DockerImageResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DockerImageResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 docker_image_uri: str,
                 docker_specification_type: str,
                 platform: Optional['outputs.DockerImagePlatformResponse'] = None):
        """
        Class to represent configuration settings for Docker Build
        :param str docker_image_uri: [Required] Image name of a custom base image.
               <seealso href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-image#use-a-custom-base-image" />
        :param str docker_specification_type: Enum to determine docker specification type. Must be either Build or Image.
               Expected value is 'Image'.
        :param 'DockerImagePlatformResponse' platform: The platform information of the docker image.
        """
        DockerImageResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            docker_image_uri=docker_image_uri,
            docker_specification_type=docker_specification_type,
            platform=platform,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             docker_image_uri: Optional[str] = None,
             docker_specification_type: Optional[str] = None,
             platform: Optional['outputs.DockerImagePlatformResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if docker_image_uri is None and 'dockerImageUri' in kwargs:
            docker_image_uri = kwargs['dockerImageUri']
        if docker_image_uri is None:
            raise TypeError("Missing 'docker_image_uri' argument")
        if docker_specification_type is None and 'dockerSpecificationType' in kwargs:
            docker_specification_type = kwargs['dockerSpecificationType']
        if docker_specification_type is None:
            raise TypeError("Missing 'docker_specification_type' argument")

        _setter("docker_image_uri", docker_image_uri)
        _setter("docker_specification_type", 'Image')
        if platform is not None:
            _setter("platform", platform)

    @property
    @pulumi.getter(name="dockerImageUri")
    def docker_image_uri(self) -> str:
        """
        [Required] Image name of a custom base image.
        <seealso href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-image#use-a-custom-base-image" />
        """
        return pulumi.get(self, "docker_image_uri")

    @property
    @pulumi.getter(name="dockerSpecificationType")
    def docker_specification_type(self) -> str:
        """
        Enum to determine docker specification type. Must be either Build or Image.
        Expected value is 'Image'.
        """
        return pulumi.get(self, "docker_specification_type")

    @property
    @pulumi.getter
    def platform(self) -> Optional['outputs.DockerImagePlatformResponse']:
        """
        The platform information of the docker image.
        """
        return pulumi.get(self, "platform")


@pulumi.output_type
class EnvironmentContainerResponse(dict):
    """
    Container for environment specification versions.
    """
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Container for environment specification versions.
        :param str description: The asset description text.
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        EnvironmentContainerResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if description is not None:
            _setter("description", description)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class EnvironmentSpecificationVersionResponse(dict):
    """
    Environment specification version details.
    <see href="https://repo2docker.readthedocs.io/en/latest/specification.html" />
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentSpecificationType":
            suggest = "environment_specification_type"
        elif key == "condaFile":
            suggest = "conda_file"
        elif key == "inferenceContainerProperties":
            suggest = "inference_container_properties"
        elif key == "isAnonymous":
            suggest = "is_anonymous"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentSpecificationVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentSpecificationVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentSpecificationVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 environment_specification_type: str,
                 conda_file: Optional[str] = None,
                 description: Optional[str] = None,
                 docker: Optional[Any] = None,
                 inference_container_properties: Optional['outputs.InferenceContainerPropertiesResponse'] = None,
                 is_anonymous: Optional[bool] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Environment specification version details.
        <see href="https://repo2docker.readthedocs.io/en/latest/specification.html" />
        :param str environment_specification_type: Environment specification is either user managed or curated by the Azure ML service
               <see href="https://docs.microsoft.com/en-us/azure/machine-learning/resource-curated-environments" />
        :param str conda_file: Standard configuration file used by Conda that lets you install any kind of package, including Python, R, and C/C++ packages.
               <see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-install-a-conda-environment" />
        :param str description: The asset description text.
        :param Union['DockerBuildResponse', 'DockerImageResponse'] docker: Configuration settings for Docker.
        :param 'InferenceContainerPropertiesResponse' inference_container_properties: Defines configuration specific to inference.
        :param bool is_anonymous: If the name version are system generated (anonymous registration).
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        EnvironmentSpecificationVersionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            environment_specification_type=environment_specification_type,
            conda_file=conda_file,
            description=description,
            docker=docker,
            inference_container_properties=inference_container_properties,
            is_anonymous=is_anonymous,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             environment_specification_type: Optional[str] = None,
             conda_file: Optional[str] = None,
             description: Optional[str] = None,
             docker: Optional[Any] = None,
             inference_container_properties: Optional['outputs.InferenceContainerPropertiesResponse'] = None,
             is_anonymous: Optional[bool] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if environment_specification_type is None and 'environmentSpecificationType' in kwargs:
            environment_specification_type = kwargs['environmentSpecificationType']
        if environment_specification_type is None:
            raise TypeError("Missing 'environment_specification_type' argument")
        if conda_file is None and 'condaFile' in kwargs:
            conda_file = kwargs['condaFile']
        if inference_container_properties is None and 'inferenceContainerProperties' in kwargs:
            inference_container_properties = kwargs['inferenceContainerProperties']
        if is_anonymous is None and 'isAnonymous' in kwargs:
            is_anonymous = kwargs['isAnonymous']

        _setter("environment_specification_type", environment_specification_type)
        if conda_file is not None:
            _setter("conda_file", conda_file)
        if description is not None:
            _setter("description", description)
        if docker is not None:
            _setter("docker", docker)
        if inference_container_properties is not None:
            _setter("inference_container_properties", inference_container_properties)
        if is_anonymous is not None:
            _setter("is_anonymous", is_anonymous)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="environmentSpecificationType")
    def environment_specification_type(self) -> str:
        """
        Environment specification is either user managed or curated by the Azure ML service
        <see href="https://docs.microsoft.com/en-us/azure/machine-learning/resource-curated-environments" />
        """
        return pulumi.get(self, "environment_specification_type")

    @property
    @pulumi.getter(name="condaFile")
    def conda_file(self) -> Optional[str]:
        """
        Standard configuration file used by Conda that lets you install any kind of package, including Python, R, and C/C++ packages.
        <see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-install-a-conda-environment" />
        """
        return pulumi.get(self, "conda_file")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def docker(self) -> Optional[Any]:
        """
        Configuration settings for Docker.
        """
        return pulumi.get(self, "docker")

    @property
    @pulumi.getter(name="inferenceContainerProperties")
    def inference_container_properties(self) -> Optional['outputs.InferenceContainerPropertiesResponse']:
        """
        Defines configuration specific to inference.
        """
        return pulumi.get(self, "inference_container_properties")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[bool]:
        """
        If the name version are system generated (anonymous registration).
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class FlavorDataResponse(dict):
    def __init__(__self__, *,
                 data: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] data: Model flavor-specific data.
        """
        FlavorDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data=data,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if data is not None:
            _setter("data", data)

    @property
    @pulumi.getter
    def data(self) -> Optional[Mapping[str, str]]:
        """
        Model flavor-specific data.
        """
        return pulumi.get(self, "data")


@pulumi.output_type
class GlusterFsContentsResponse(dict):
    """
    GlusterFs datastore configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentsType":
            suggest = "contents_type"
        elif key == "serverAddress":
            suggest = "server_address"
        elif key == "volumeName":
            suggest = "volume_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlusterFsContentsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlusterFsContentsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlusterFsContentsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contents_type: str,
                 server_address: str,
                 volume_name: str):
        """
        GlusterFs datastore configuration.
        :param str contents_type: Enum to determine the datastore contents type.
               Expected value is 'GlusterFs'.
        :param str server_address: [Required] GlusterFS server address (can be the IP address or server name).
        :param str volume_name: [Required] GlusterFS volume name.
        """
        GlusterFsContentsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            contents_type=contents_type,
            server_address=server_address,
            volume_name=volume_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             contents_type: Optional[str] = None,
             server_address: Optional[str] = None,
             volume_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if contents_type is None and 'contentsType' in kwargs:
            contents_type = kwargs['contentsType']
        if contents_type is None:
            raise TypeError("Missing 'contents_type' argument")
        if server_address is None and 'serverAddress' in kwargs:
            server_address = kwargs['serverAddress']
        if server_address is None:
            raise TypeError("Missing 'server_address' argument")
        if volume_name is None and 'volumeName' in kwargs:
            volume_name = kwargs['volumeName']
        if volume_name is None:
            raise TypeError("Missing 'volume_name' argument")

        _setter("contents_type", 'GlusterFs')
        _setter("server_address", server_address)
        _setter("volume_name", volume_name)

    @property
    @pulumi.getter(name="contentsType")
    def contents_type(self) -> str:
        """
        Enum to determine the datastore contents type.
        Expected value is 'GlusterFs'.
        """
        return pulumi.get(self, "contents_type")

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        """
        [Required] GlusterFS server address (can be the IP address or server name).
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> str:
        """
        [Required] GlusterFS volume name.
        """
        return pulumi.get(self, "volume_name")


@pulumi.output_type
class IdAssetReferenceResponse(dict):
    """
    Reference to an asset via its ARM resource ID.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assetId":
            suggest = "asset_id"
        elif key == "referenceType":
            suggest = "reference_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdAssetReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdAssetReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdAssetReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asset_id: str,
                 reference_type: str):
        """
        Reference to an asset via its ARM resource ID.
        :param str asset_id: [Required] ARM resource ID of the asset.
        :param str reference_type: Enum to determine which reference method to use for an asset.
               Expected value is 'Id'.
        """
        IdAssetReferenceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            asset_id=asset_id,
            reference_type=reference_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             asset_id: Optional[str] = None,
             reference_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if asset_id is None and 'assetId' in kwargs:
            asset_id = kwargs['assetId']
        if asset_id is None:
            raise TypeError("Missing 'asset_id' argument")
        if reference_type is None and 'referenceType' in kwargs:
            reference_type = kwargs['referenceType']
        if reference_type is None:
            raise TypeError("Missing 'reference_type' argument")

        _setter("asset_id", asset_id)
        _setter("reference_type", 'Id')

    @property
    @pulumi.getter(name="assetId")
    def asset_id(self) -> str:
        """
        [Required] ARM resource ID of the asset.
        """
        return pulumi.get(self, "asset_id")

    @property
    @pulumi.getter(name="referenceType")
    def reference_type(self) -> str:
        """
        Enum to determine which reference method to use for an asset.
        Expected value is 'Id'.
        """
        return pulumi.get(self, "reference_type")


@pulumi.output_type
class InferenceContainerPropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "livenessRoute":
            suggest = "liveness_route"
        elif key == "readinessRoute":
            suggest = "readiness_route"
        elif key == "scoringRoute":
            suggest = "scoring_route"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InferenceContainerPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InferenceContainerPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InferenceContainerPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 liveness_route: Optional['outputs.RouteResponse'] = None,
                 readiness_route: Optional['outputs.RouteResponse'] = None,
                 scoring_route: Optional['outputs.RouteResponse'] = None):
        """
        :param 'RouteResponse' liveness_route: The route to check the liveness of the inference server container.
        :param 'RouteResponse' readiness_route: The route to check the readiness of the inference server container.
        :param 'RouteResponse' scoring_route: The port to send the scoring requests to, within the inference server container.
        """
        InferenceContainerPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            liveness_route=liveness_route,
            readiness_route=readiness_route,
            scoring_route=scoring_route,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             liveness_route: Optional['outputs.RouteResponse'] = None,
             readiness_route: Optional['outputs.RouteResponse'] = None,
             scoring_route: Optional['outputs.RouteResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if liveness_route is None and 'livenessRoute' in kwargs:
            liveness_route = kwargs['livenessRoute']
        if readiness_route is None and 'readinessRoute' in kwargs:
            readiness_route = kwargs['readinessRoute']
        if scoring_route is None and 'scoringRoute' in kwargs:
            scoring_route = kwargs['scoringRoute']

        if liveness_route is not None:
            _setter("liveness_route", liveness_route)
        if readiness_route is not None:
            _setter("readiness_route", readiness_route)
        if scoring_route is not None:
            _setter("scoring_route", scoring_route)

    @property
    @pulumi.getter(name="livenessRoute")
    def liveness_route(self) -> Optional['outputs.RouteResponse']:
        """
        The route to check the liveness of the inference server container.
        """
        return pulumi.get(self, "liveness_route")

    @property
    @pulumi.getter(name="readinessRoute")
    def readiness_route(self) -> Optional['outputs.RouteResponse']:
        """
        The route to check the readiness of the inference server container.
        """
        return pulumi.get(self, "readiness_route")

    @property
    @pulumi.getter(name="scoringRoute")
    def scoring_route(self) -> Optional['outputs.RouteResponse']:
        """
        The port to send the scoring requests to, within the inference server container.
        """
        return pulumi.get(self, "scoring_route")


@pulumi.output_type
class InputDataBindingResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataId":
            suggest = "data_id"
        elif key == "pathOnCompute":
            suggest = "path_on_compute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InputDataBindingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InputDataBindingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InputDataBindingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_id: Optional[str] = None,
                 mode: Optional[str] = None,
                 path_on_compute: Optional[str] = None):
        """
        :param str data_id: ARM resource ID of the registered dataVersion.
        :param str mode: Mechanism for accessing the data artifact.
        :param str path_on_compute: Location of data inside the container process.
        """
        InputDataBindingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_id=data_id,
            mode=mode,
            path_on_compute=path_on_compute,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_id: Optional[str] = None,
             mode: Optional[str] = None,
             path_on_compute: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_id is None and 'dataId' in kwargs:
            data_id = kwargs['dataId']
        if path_on_compute is None and 'pathOnCompute' in kwargs:
            path_on_compute = kwargs['pathOnCompute']

        if data_id is not None:
            _setter("data_id", data_id)
        if mode is not None:
            _setter("mode", mode)
        if path_on_compute is not None:
            _setter("path_on_compute", path_on_compute)

    @property
    @pulumi.getter(name="dataId")
    def data_id(self) -> Optional[str]:
        """
        ARM resource ID of the registered dataVersion.
        """
        return pulumi.get(self, "data_id")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Mechanism for accessing the data artifact.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="pathOnCompute")
    def path_on_compute(self) -> Optional[str]:
        """
        Location of data inside the container process.
        """
        return pulumi.get(self, "path_on_compute")


@pulumi.output_type
class JobEndpointResponse(dict):
    """
    Job endpoint definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobEndpointType":
            suggest = "job_endpoint_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: Optional[str] = None,
                 job_endpoint_type: Optional[str] = None,
                 port: Optional[int] = None,
                 properties: Optional[Mapping[str, str]] = None):
        """
        Job endpoint definition
        :param str endpoint: Url for endpoint.
        :param str job_endpoint_type: Endpoint type.
        :param int port: Port for endpoint.
        :param Mapping[str, str] properties: Additional properties to set on the endpoint.
        """
        JobEndpointResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint=endpoint,
            job_endpoint_type=job_endpoint_type,
            port=port,
            properties=properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint: Optional[str] = None,
             job_endpoint_type: Optional[str] = None,
             port: Optional[int] = None,
             properties: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if job_endpoint_type is None and 'jobEndpointType' in kwargs:
            job_endpoint_type = kwargs['jobEndpointType']

        if endpoint is not None:
            _setter("endpoint", endpoint)
        if job_endpoint_type is not None:
            _setter("job_endpoint_type", job_endpoint_type)
        if port is not None:
            _setter("port", port)
        if properties is not None:
            _setter("properties", properties)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        Url for endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="jobEndpointType")
    def job_endpoint_type(self) -> Optional[str]:
        """
        Endpoint type.
        """
        return pulumi.get(self, "job_endpoint_type")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port for endpoint.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        Additional properties to set on the endpoint.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class JobOutputResponse(dict):
    """
    Job output definition container information on where to find job output/logs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datastoreId":
            suggest = "datastore_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datastore_id: str,
                 path: str):
        """
        Job output definition container information on where to find job output/logs.
        :param str datastore_id: ARM ID of the datastore where the job logs and artifacts are stored, or null for the default container ("azureml") in the workspace's storage account.
        :param str path: Path within the datastore to the job logs and artifacts.
        """
        JobOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            datastore_id=datastore_id,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             datastore_id: Optional[str] = None,
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if datastore_id is None and 'datastoreId' in kwargs:
            datastore_id = kwargs['datastoreId']
        if datastore_id is None:
            raise TypeError("Missing 'datastore_id' argument")
        if path is None:
            raise TypeError("Missing 'path' argument")

        _setter("datastore_id", datastore_id)
        _setter("path", path)

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> str:
        """
        ARM ID of the datastore where the job logs and artifacts are stored, or null for the default container ("azureml") in the workspace's storage account.
        """
        return pulumi.get(self, "datastore_id")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path within the datastore to the job logs and artifacts.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class K8sOnlineDeploymentResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointComputeType":
            suggest = "endpoint_compute_type"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "appInsightsEnabled":
            suggest = "app_insights_enabled"
        elif key == "codeConfiguration":
            suggest = "code_configuration"
        elif key == "containerResourceRequirements":
            suggest = "container_resource_requirements"
        elif key == "environmentId":
            suggest = "environment_id"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "livenessProbe":
            suggest = "liveness_probe"
        elif key == "requestSettings":
            suggest = "request_settings"
        elif key == "scaleSettings":
            suggest = "scale_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sOnlineDeploymentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sOnlineDeploymentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sOnlineDeploymentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_compute_type: str,
                 provisioning_state: str,
                 app_insights_enabled: Optional[bool] = None,
                 code_configuration: Optional['outputs.CodeConfigurationResponse'] = None,
                 container_resource_requirements: Optional['outputs.ContainerResourceRequirementsResponse'] = None,
                 description: Optional[str] = None,
                 environment_id: Optional[str] = None,
                 environment_variables: Optional[Mapping[str, str]] = None,
                 liveness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
                 model: Optional[Any] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 request_settings: Optional['outputs.OnlineRequestSettingsResponse'] = None,
                 scale_settings: Optional[Any] = None):
        """
        :param str endpoint_compute_type: Enum to determine endpoint compute type.
               Expected value is 'K8S'.
        :param str provisioning_state: Provisioning state for the endpoint deployment.
        :param bool app_insights_enabled: If true, enables Application Insights logging.
        :param 'CodeConfigurationResponse' code_configuration: Code configuration for the endpoint deployment.
        :param 'ContainerResourceRequirementsResponse' container_resource_requirements: Resource requirements for each container instance within an online deployment.
        :param str description: Description of the endpoint deployment.
        :param str environment_id: ARM resource ID of the environment specification for the endpoint deployment.
        :param Mapping[str, str] environment_variables: Environment variables configuration for the deployment.
        :param 'ProbeSettingsResponse' liveness_probe: Deployment container liveness/readiness probe configuration.
        :param Union['DataPathAssetReferenceResponse', 'IdAssetReferenceResponse', 'OutputPathAssetReferenceResponse'] model: Reference to the model asset for the endpoint deployment.
        :param Mapping[str, str] properties: Property dictionary. Properties can be added, but not removed or altered.
        :param 'OnlineRequestSettingsResponse' request_settings: Online deployment scoring requests configuration.
        :param Union['AutoScaleSettingsResponse', 'ManualScaleSettingsResponse'] scale_settings: Online deployment scaling configuration.
        """
        K8sOnlineDeploymentResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_compute_type=endpoint_compute_type,
            provisioning_state=provisioning_state,
            app_insights_enabled=app_insights_enabled,
            code_configuration=code_configuration,
            container_resource_requirements=container_resource_requirements,
            description=description,
            environment_id=environment_id,
            environment_variables=environment_variables,
            liveness_probe=liveness_probe,
            model=model,
            properties=properties,
            request_settings=request_settings,
            scale_settings=scale_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_compute_type: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             app_insights_enabled: Optional[bool] = None,
             code_configuration: Optional['outputs.CodeConfigurationResponse'] = None,
             container_resource_requirements: Optional['outputs.ContainerResourceRequirementsResponse'] = None,
             description: Optional[str] = None,
             environment_id: Optional[str] = None,
             environment_variables: Optional[Mapping[str, str]] = None,
             liveness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
             model: Optional[Any] = None,
             properties: Optional[Mapping[str, str]] = None,
             request_settings: Optional['outputs.OnlineRequestSettingsResponse'] = None,
             scale_settings: Optional[Any] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if endpoint_compute_type is None and 'endpointComputeType' in kwargs:
            endpoint_compute_type = kwargs['endpointComputeType']
        if endpoint_compute_type is None:
            raise TypeError("Missing 'endpoint_compute_type' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if app_insights_enabled is None and 'appInsightsEnabled' in kwargs:
            app_insights_enabled = kwargs['appInsightsEnabled']
        if code_configuration is None and 'codeConfiguration' in kwargs:
            code_configuration = kwargs['codeConfiguration']
        if container_resource_requirements is None and 'containerResourceRequirements' in kwargs:
            container_resource_requirements = kwargs['containerResourceRequirements']
        if environment_id is None and 'environmentId' in kwargs:
            environment_id = kwargs['environmentId']
        if environment_variables is None and 'environmentVariables' in kwargs:
            environment_variables = kwargs['environmentVariables']
        if liveness_probe is None and 'livenessProbe' in kwargs:
            liveness_probe = kwargs['livenessProbe']
        if request_settings is None and 'requestSettings' in kwargs:
            request_settings = kwargs['requestSettings']
        if scale_settings is None and 'scaleSettings' in kwargs:
            scale_settings = kwargs['scaleSettings']

        _setter("endpoint_compute_type", 'K8S')
        _setter("provisioning_state", provisioning_state)
        if app_insights_enabled is not None:
            _setter("app_insights_enabled", app_insights_enabled)
        if code_configuration is not None:
            _setter("code_configuration", code_configuration)
        if container_resource_requirements is not None:
            _setter("container_resource_requirements", container_resource_requirements)
        if description is not None:
            _setter("description", description)
        if environment_id is not None:
            _setter("environment_id", environment_id)
        if environment_variables is not None:
            _setter("environment_variables", environment_variables)
        if liveness_probe is not None:
            _setter("liveness_probe", liveness_probe)
        if model is not None:
            _setter("model", model)
        if properties is not None:
            _setter("properties", properties)
        if request_settings is not None:
            _setter("request_settings", request_settings)
        if scale_settings is not None:
            _setter("scale_settings", scale_settings)

    @property
    @pulumi.getter(name="endpointComputeType")
    def endpoint_compute_type(self) -> str:
        """
        Enum to determine endpoint compute type.
        Expected value is 'K8S'.
        """
        return pulumi.get(self, "endpoint_compute_type")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning state for the endpoint deployment.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="appInsightsEnabled")
    def app_insights_enabled(self) -> Optional[bool]:
        """
        If true, enables Application Insights logging.
        """
        return pulumi.get(self, "app_insights_enabled")

    @property
    @pulumi.getter(name="codeConfiguration")
    def code_configuration(self) -> Optional['outputs.CodeConfigurationResponse']:
        """
        Code configuration for the endpoint deployment.
        """
        return pulumi.get(self, "code_configuration")

    @property
    @pulumi.getter(name="containerResourceRequirements")
    def container_resource_requirements(self) -> Optional['outputs.ContainerResourceRequirementsResponse']:
        """
        Resource requirements for each container instance within an online deployment.
        """
        return pulumi.get(self, "container_resource_requirements")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the endpoint deployment.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[str]:
        """
        ARM resource ID of the environment specification for the endpoint deployment.
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, str]]:
        """
        Environment variables configuration for the deployment.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.ProbeSettingsResponse']:
        """
        Deployment container liveness/readiness probe configuration.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def model(self) -> Optional[Any]:
        """
        Reference to the model asset for the endpoint deployment.
        """
        return pulumi.get(self, "model")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="requestSettings")
    def request_settings(self) -> Optional['outputs.OnlineRequestSettingsResponse']:
        """
        Online deployment scoring requests configuration.
        """
        return pulumi.get(self, "request_settings")

    @property
    @pulumi.getter(name="scaleSettings")
    def scale_settings(self) -> Optional[Any]:
        """
        Online deployment scaling configuration.
        """
        return pulumi.get(self, "scale_settings")


@pulumi.output_type
class LabelCategoryResponse(dict):
    """
    Label category definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowMultiSelect":
            suggest = "allow_multi_select"
        elif key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LabelCategoryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LabelCategoryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LabelCategoryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_multi_select: Optional[bool] = None,
                 classes: Optional[Mapping[str, 'outputs.LabelClassResponse']] = None,
                 display_name: Optional[str] = None):
        """
        Label category definition
        :param bool allow_multi_select: Indicates whether it is allowed to select multiple classes in this category.
        :param Mapping[str, 'LabelClassResponse'] classes: Dictionary of label classes in this category.
        :param str display_name: Display name of the label category.
        """
        LabelCategoryResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_multi_select=allow_multi_select,
            classes=classes,
            display_name=display_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_multi_select: Optional[bool] = None,
             classes: Optional[Mapping[str, 'outputs.LabelClassResponse']] = None,
             display_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allow_multi_select is None and 'allowMultiSelect' in kwargs:
            allow_multi_select = kwargs['allowMultiSelect']
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']

        if allow_multi_select is not None:
            _setter("allow_multi_select", allow_multi_select)
        if classes is not None:
            _setter("classes", classes)
        if display_name is not None:
            _setter("display_name", display_name)

    @property
    @pulumi.getter(name="allowMultiSelect")
    def allow_multi_select(self) -> Optional[bool]:
        """
        Indicates whether it is allowed to select multiple classes in this category.
        """
        return pulumi.get(self, "allow_multi_select")

    @property
    @pulumi.getter
    def classes(self) -> Optional[Mapping[str, 'outputs.LabelClassResponse']]:
        """
        Dictionary of label classes in this category.
        """
        return pulumi.get(self, "classes")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Display name of the label category.
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class LabelClassResponse(dict):
    """
    Label class definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LabelClassResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LabelClassResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LabelClassResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 subclasses: Optional[Mapping[str, 'outputs.LabelClassResponse']] = None):
        """
        Label class definition
        :param str display_name: Display name of the label class.
        :param Mapping[str, 'LabelClassResponse'] subclasses: Dictionary of subclasses of the label class.
        """
        LabelClassResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            subclasses=subclasses,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: Optional[str] = None,
             subclasses: Optional[Mapping[str, 'outputs.LabelClassResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']

        if display_name is not None:
            _setter("display_name", display_name)
        if subclasses is not None:
            _setter("subclasses", subclasses)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Display name of the label class.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def subclasses(self) -> Optional[Mapping[str, 'outputs.LabelClassResponse']]:
        """
        Dictionary of subclasses of the label class.
        """
        return pulumi.get(self, "subclasses")


@pulumi.output_type
class LabelingDatasetConfigurationResponse(dict):
    """
    Labeling dataset configuration definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assetName":
            suggest = "asset_name"
        elif key == "datasetVersion":
            suggest = "dataset_version"
        elif key == "incrementalDatasetRefreshEnabled":
            suggest = "incremental_dataset_refresh_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LabelingDatasetConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LabelingDatasetConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LabelingDatasetConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asset_name: Optional[str] = None,
                 dataset_version: Optional[str] = None,
                 incremental_dataset_refresh_enabled: Optional[bool] = None):
        """
        Labeling dataset configuration definition
        :param str asset_name: Name of the data asset to perform labeling.
        :param str dataset_version: AML dataset version.
        :param bool incremental_dataset_refresh_enabled: Indicates whether to enable incremental dataset refresh.
        """
        LabelingDatasetConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            asset_name=asset_name,
            dataset_version=dataset_version,
            incremental_dataset_refresh_enabled=incremental_dataset_refresh_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             asset_name: Optional[str] = None,
             dataset_version: Optional[str] = None,
             incremental_dataset_refresh_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if asset_name is None and 'assetName' in kwargs:
            asset_name = kwargs['assetName']
        if dataset_version is None and 'datasetVersion' in kwargs:
            dataset_version = kwargs['datasetVersion']
        if incremental_dataset_refresh_enabled is None and 'incrementalDatasetRefreshEnabled' in kwargs:
            incremental_dataset_refresh_enabled = kwargs['incrementalDatasetRefreshEnabled']

        if asset_name is not None:
            _setter("asset_name", asset_name)
        if dataset_version is not None:
            _setter("dataset_version", dataset_version)
        if incremental_dataset_refresh_enabled is not None:
            _setter("incremental_dataset_refresh_enabled", incremental_dataset_refresh_enabled)

    @property
    @pulumi.getter(name="assetName")
    def asset_name(self) -> Optional[str]:
        """
        Name of the data asset to perform labeling.
        """
        return pulumi.get(self, "asset_name")

    @property
    @pulumi.getter(name="datasetVersion")
    def dataset_version(self) -> Optional[str]:
        """
        AML dataset version.
        """
        return pulumi.get(self, "dataset_version")

    @property
    @pulumi.getter(name="incrementalDatasetRefreshEnabled")
    def incremental_dataset_refresh_enabled(self) -> Optional[bool]:
        """
        Indicates whether to enable incremental dataset refresh.
        """
        return pulumi.get(self, "incremental_dataset_refresh_enabled")


@pulumi.output_type
class LabelingJobImagePropertiesResponse(dict):
    """
    Properties of a labeling job for image data
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mediaType":
            suggest = "media_type"
        elif key == "annotationType":
            suggest = "annotation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LabelingJobImagePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LabelingJobImagePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LabelingJobImagePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 media_type: str,
                 annotation_type: Optional[str] = None):
        """
        Properties of a labeling job for image data
        :param str media_type: Media type of data asset.
               Expected value is 'Image'.
        :param str annotation_type: Annotation type of image labeling job.
        """
        LabelingJobImagePropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            media_type=media_type,
            annotation_type=annotation_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             media_type: Optional[str] = None,
             annotation_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if media_type is None and 'mediaType' in kwargs:
            media_type = kwargs['mediaType']
        if media_type is None:
            raise TypeError("Missing 'media_type' argument")
        if annotation_type is None and 'annotationType' in kwargs:
            annotation_type = kwargs['annotationType']

        _setter("media_type", 'Image')
        if annotation_type is not None:
            _setter("annotation_type", annotation_type)

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> str:
        """
        Media type of data asset.
        Expected value is 'Image'.
        """
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter(name="annotationType")
    def annotation_type(self) -> Optional[str]:
        """
        Annotation type of image labeling job.
        """
        return pulumi.get(self, "annotation_type")


@pulumi.output_type
class LabelingJobInstructionsResponse(dict):
    """
    Instructions for labeling job
    """
    def __init__(__self__, *,
                 uri: Optional[str] = None):
        """
        Instructions for labeling job
        :param str uri: The link to a page with detailed labeling instructions for labelers.
        """
        LabelingJobInstructionsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if uri is not None:
            _setter("uri", uri)

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        The link to a page with detailed labeling instructions for labelers.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class LabelingJobResponse(dict):
    """
    Labeling job definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdTimeUtc":
            suggest = "created_time_utc"
        elif key == "interactionEndpoints":
            suggest = "interaction_endpoints"
        elif key == "jobType":
            suggest = "job_type"
        elif key == "progressMetrics":
            suggest = "progress_metrics"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "statusMessages":
            suggest = "status_messages"
        elif key == "datasetConfiguration":
            suggest = "dataset_configuration"
        elif key == "jobInstructions":
            suggest = "job_instructions"
        elif key == "labelCategories":
            suggest = "label_categories"
        elif key == "labelingJobMediaProperties":
            suggest = "labeling_job_media_properties"
        elif key == "mlAssistConfiguration":
            suggest = "ml_assist_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LabelingJobResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LabelingJobResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LabelingJobResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_time_utc: str,
                 interaction_endpoints: Mapping[str, 'outputs.JobEndpointResponse'],
                 job_type: str,
                 progress_metrics: 'outputs.ProgressMetricsResponse',
                 project_id: str,
                 provisioning_state: str,
                 status: str,
                 status_messages: Sequence['outputs.StatusMessageResponse'],
                 dataset_configuration: Optional['outputs.LabelingDatasetConfigurationResponse'] = None,
                 description: Optional[str] = None,
                 job_instructions: Optional['outputs.LabelingJobInstructionsResponse'] = None,
                 label_categories: Optional[Mapping[str, 'outputs.LabelCategoryResponse']] = None,
                 labeling_job_media_properties: Optional[Any] = None,
                 ml_assist_configuration: Optional['outputs.MLAssistConfigurationResponse'] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Labeling job definition
        :param str created_time_utc: Created time of the job in UTC timezone.
        :param Mapping[str, 'JobEndpointResponse'] interaction_endpoints: List of JobEndpoints.
               For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        :param str job_type: [Required] Specifies the type of job. This field should always be set to "Labeling".
        :param 'ProgressMetricsResponse' progress_metrics: Progress metrics of the job.
        :param str project_id: Internal id of the job(Previously called project).
        :param str provisioning_state: Specifies the labeling job provisioning state.
        :param str status: Status of the job.
        :param Sequence['StatusMessageResponse'] status_messages: Status messages of the job.
        :param 'LabelingDatasetConfigurationResponse' dataset_configuration: Configuration of dataset used in the job.
        :param str description: The asset description text.
        :param 'LabelingJobInstructionsResponse' job_instructions: Labeling instructions of the job.
        :param Mapping[str, 'LabelCategoryResponse'] label_categories: Label categories of the job.
        :param Union['LabelingJobImagePropertiesResponse', 'LabelingJobTextPropertiesResponse'] labeling_job_media_properties: Media type specific properties in the job.
        :param 'MLAssistConfigurationResponse' ml_assist_configuration: Configuration of MLAssist feature in the job.
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        LabelingJobResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_time_utc=created_time_utc,
            interaction_endpoints=interaction_endpoints,
            job_type=job_type,
            progress_metrics=progress_metrics,
            project_id=project_id,
            provisioning_state=provisioning_state,
            status=status,
            status_messages=status_messages,
            dataset_configuration=dataset_configuration,
            description=description,
            job_instructions=job_instructions,
            label_categories=label_categories,
            labeling_job_media_properties=labeling_job_media_properties,
            ml_assist_configuration=ml_assist_configuration,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_time_utc: Optional[str] = None,
             interaction_endpoints: Optional[Mapping[str, 'outputs.JobEndpointResponse']] = None,
             job_type: Optional[str] = None,
             progress_metrics: Optional['outputs.ProgressMetricsResponse'] = None,
             project_id: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             status: Optional[str] = None,
             status_messages: Optional[Sequence['outputs.StatusMessageResponse']] = None,
             dataset_configuration: Optional['outputs.LabelingDatasetConfigurationResponse'] = None,
             description: Optional[str] = None,
             job_instructions: Optional['outputs.LabelingJobInstructionsResponse'] = None,
             label_categories: Optional[Mapping[str, 'outputs.LabelCategoryResponse']] = None,
             labeling_job_media_properties: Optional[Any] = None,
             ml_assist_configuration: Optional['outputs.MLAssistConfigurationResponse'] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if created_time_utc is None and 'createdTimeUtc' in kwargs:
            created_time_utc = kwargs['createdTimeUtc']
        if created_time_utc is None:
            raise TypeError("Missing 'created_time_utc' argument")
        if interaction_endpoints is None and 'interactionEndpoints' in kwargs:
            interaction_endpoints = kwargs['interactionEndpoints']
        if interaction_endpoints is None:
            raise TypeError("Missing 'interaction_endpoints' argument")
        if job_type is None and 'jobType' in kwargs:
            job_type = kwargs['jobType']
        if job_type is None:
            raise TypeError("Missing 'job_type' argument")
        if progress_metrics is None and 'progressMetrics' in kwargs:
            progress_metrics = kwargs['progressMetrics']
        if progress_metrics is None:
            raise TypeError("Missing 'progress_metrics' argument")
        if project_id is None and 'projectId' in kwargs:
            project_id = kwargs['projectId']
        if project_id is None:
            raise TypeError("Missing 'project_id' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if status_messages is None and 'statusMessages' in kwargs:
            status_messages = kwargs['statusMessages']
        if status_messages is None:
            raise TypeError("Missing 'status_messages' argument")
        if dataset_configuration is None and 'datasetConfiguration' in kwargs:
            dataset_configuration = kwargs['datasetConfiguration']
        if job_instructions is None and 'jobInstructions' in kwargs:
            job_instructions = kwargs['jobInstructions']
        if label_categories is None and 'labelCategories' in kwargs:
            label_categories = kwargs['labelCategories']
        if labeling_job_media_properties is None and 'labelingJobMediaProperties' in kwargs:
            labeling_job_media_properties = kwargs['labelingJobMediaProperties']
        if ml_assist_configuration is None and 'mlAssistConfiguration' in kwargs:
            ml_assist_configuration = kwargs['mlAssistConfiguration']

        _setter("created_time_utc", created_time_utc)
        _setter("interaction_endpoints", interaction_endpoints)
        _setter("job_type", job_type)
        _setter("progress_metrics", progress_metrics)
        _setter("project_id", project_id)
        _setter("provisioning_state", provisioning_state)
        _setter("status", status)
        _setter("status_messages", status_messages)
        if dataset_configuration is not None:
            _setter("dataset_configuration", dataset_configuration)
        if description is not None:
            _setter("description", description)
        if job_instructions is not None:
            _setter("job_instructions", job_instructions)
        if label_categories is not None:
            _setter("label_categories", label_categories)
        if labeling_job_media_properties is not None:
            _setter("labeling_job_media_properties", labeling_job_media_properties)
        if ml_assist_configuration is not None:
            _setter("ml_assist_configuration", ml_assist_configuration)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="createdTimeUtc")
    def created_time_utc(self) -> str:
        """
        Created time of the job in UTC timezone.
        """
        return pulumi.get(self, "created_time_utc")

    @property
    @pulumi.getter(name="interactionEndpoints")
    def interaction_endpoints(self) -> Mapping[str, 'outputs.JobEndpointResponse']:
        """
        List of JobEndpoints.
        For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        """
        return pulumi.get(self, "interaction_endpoints")

    @property
    @pulumi.getter(name="jobType")
    def job_type(self) -> str:
        """
        [Required] Specifies the type of job. This field should always be set to "Labeling".
        """
        return pulumi.get(self, "job_type")

    @property
    @pulumi.getter(name="progressMetrics")
    def progress_metrics(self) -> 'outputs.ProgressMetricsResponse':
        """
        Progress metrics of the job.
        """
        return pulumi.get(self, "progress_metrics")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Internal id of the job(Previously called project).
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Specifies the labeling job provisioning state.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the job.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusMessages")
    def status_messages(self) -> Sequence['outputs.StatusMessageResponse']:
        """
        Status messages of the job.
        """
        return pulumi.get(self, "status_messages")

    @property
    @pulumi.getter(name="datasetConfiguration")
    def dataset_configuration(self) -> Optional['outputs.LabelingDatasetConfigurationResponse']:
        """
        Configuration of dataset used in the job.
        """
        return pulumi.get(self, "dataset_configuration")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="jobInstructions")
    def job_instructions(self) -> Optional['outputs.LabelingJobInstructionsResponse']:
        """
        Labeling instructions of the job.
        """
        return pulumi.get(self, "job_instructions")

    @property
    @pulumi.getter(name="labelCategories")
    def label_categories(self) -> Optional[Mapping[str, 'outputs.LabelCategoryResponse']]:
        """
        Label categories of the job.
        """
        return pulumi.get(self, "label_categories")

    @property
    @pulumi.getter(name="labelingJobMediaProperties")
    def labeling_job_media_properties(self) -> Optional[Any]:
        """
        Media type specific properties in the job.
        """
        return pulumi.get(self, "labeling_job_media_properties")

    @property
    @pulumi.getter(name="mlAssistConfiguration")
    def ml_assist_configuration(self) -> Optional['outputs.MLAssistConfigurationResponse']:
        """
        Configuration of MLAssist feature in the job.
        """
        return pulumi.get(self, "ml_assist_configuration")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class LabelingJobTextPropertiesResponse(dict):
    """
    Properties of a labeling job for text data
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mediaType":
            suggest = "media_type"
        elif key == "annotationType":
            suggest = "annotation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LabelingJobTextPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LabelingJobTextPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LabelingJobTextPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 media_type: str,
                 annotation_type: Optional[str] = None):
        """
        Properties of a labeling job for text data
        :param str media_type: Media type of data asset.
               Expected value is 'Text'.
        :param str annotation_type: Annotation type of text labeling job.
        """
        LabelingJobTextPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            media_type=media_type,
            annotation_type=annotation_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             media_type: Optional[str] = None,
             annotation_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if media_type is None and 'mediaType' in kwargs:
            media_type = kwargs['mediaType']
        if media_type is None:
            raise TypeError("Missing 'media_type' argument")
        if annotation_type is None and 'annotationType' in kwargs:
            annotation_type = kwargs['annotationType']

        _setter("media_type", 'Text')
        if annotation_type is not None:
            _setter("annotation_type", annotation_type)

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> str:
        """
        Media type of data asset.
        Expected value is 'Text'.
        """
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter(name="annotationType")
    def annotation_type(self) -> Optional[str]:
        """
        Annotation type of text labeling job.
        """
        return pulumi.get(self, "annotation_type")


@pulumi.output_type
class LinkedInfoResponse(dict):
    """
    Information about a datastore origin, if linked.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedId":
            suggest = "linked_id"
        elif key == "linkedResourceName":
            suggest = "linked_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_id: Optional[str] = None,
                 linked_resource_name: Optional[str] = None,
                 origin: Optional[str] = None):
        """
        Information about a datastore origin, if linked.
        :param str linked_id: Linked service ID.
        :param str linked_resource_name: Linked service resource name.
        :param str origin: Type of the linked service.
        """
        LinkedInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            linked_id=linked_id,
            linked_resource_name=linked_resource_name,
            origin=origin,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             linked_id: Optional[str] = None,
             linked_resource_name: Optional[str] = None,
             origin: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if linked_id is None and 'linkedId' in kwargs:
            linked_id = kwargs['linkedId']
        if linked_resource_name is None and 'linkedResourceName' in kwargs:
            linked_resource_name = kwargs['linkedResourceName']

        if linked_id is not None:
            _setter("linked_id", linked_id)
        if linked_resource_name is not None:
            _setter("linked_resource_name", linked_resource_name)
        if origin is not None:
            _setter("origin", origin)

    @property
    @pulumi.getter(name="linkedId")
    def linked_id(self) -> Optional[str]:
        """
        Linked service ID.
        """
        return pulumi.get(self, "linked_id")

    @property
    @pulumi.getter(name="linkedResourceName")
    def linked_resource_name(self) -> Optional[str]:
        """
        Linked service resource name.
        """
        return pulumi.get(self, "linked_resource_name")

    @property
    @pulumi.getter
    def origin(self) -> Optional[str]:
        """
        Type of the linked service.
        """
        return pulumi.get(self, "origin")


@pulumi.output_type
class MLAssistConfigurationResponse(dict):
    """
    Labeling MLAssist configuration definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inferencingComputeBinding":
            suggest = "inferencing_compute_binding"
        elif key == "mlAssistEnabled":
            suggest = "ml_assist_enabled"
        elif key == "trainingComputeBinding":
            suggest = "training_compute_binding"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLAssistConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLAssistConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLAssistConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inferencing_compute_binding: Optional['outputs.ComputeConfigurationResponse'] = None,
                 ml_assist_enabled: Optional[bool] = None,
                 training_compute_binding: Optional['outputs.ComputeConfigurationResponse'] = None):
        """
        Labeling MLAssist configuration definition
        :param 'ComputeConfigurationResponse' inferencing_compute_binding: AML compute binding used in inferencing.
        :param bool ml_assist_enabled: Indicates whether MLAssist feature is enabled.
        :param 'ComputeConfigurationResponse' training_compute_binding: AML compute binding used in training.
        """
        MLAssistConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            inferencing_compute_binding=inferencing_compute_binding,
            ml_assist_enabled=ml_assist_enabled,
            training_compute_binding=training_compute_binding,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             inferencing_compute_binding: Optional['outputs.ComputeConfigurationResponse'] = None,
             ml_assist_enabled: Optional[bool] = None,
             training_compute_binding: Optional['outputs.ComputeConfigurationResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if inferencing_compute_binding is None and 'inferencingComputeBinding' in kwargs:
            inferencing_compute_binding = kwargs['inferencingComputeBinding']
        if ml_assist_enabled is None and 'mlAssistEnabled' in kwargs:
            ml_assist_enabled = kwargs['mlAssistEnabled']
        if training_compute_binding is None and 'trainingComputeBinding' in kwargs:
            training_compute_binding = kwargs['trainingComputeBinding']

        if inferencing_compute_binding is not None:
            _setter("inferencing_compute_binding", inferencing_compute_binding)
        if ml_assist_enabled is not None:
            _setter("ml_assist_enabled", ml_assist_enabled)
        if training_compute_binding is not None:
            _setter("training_compute_binding", training_compute_binding)

    @property
    @pulumi.getter(name="inferencingComputeBinding")
    def inferencing_compute_binding(self) -> Optional['outputs.ComputeConfigurationResponse']:
        """
        AML compute binding used in inferencing.
        """
        return pulumi.get(self, "inferencing_compute_binding")

    @property
    @pulumi.getter(name="mlAssistEnabled")
    def ml_assist_enabled(self) -> Optional[bool]:
        """
        Indicates whether MLAssist feature is enabled.
        """
        return pulumi.get(self, "ml_assist_enabled")

    @property
    @pulumi.getter(name="trainingComputeBinding")
    def training_compute_binding(self) -> Optional['outputs.ComputeConfigurationResponse']:
        """
        AML compute binding used in training.
        """
        return pulumi.get(self, "training_compute_binding")


@pulumi.output_type
class ManagedIdentityResponse(dict):
    """
    Managed identity configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityType":
            suggest = "identity_type"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_type: str,
                 client_id: Optional[str] = None,
                 object_id: Optional[str] = None,
                 resource_id: Optional[str] = None):
        """
        Managed identity configuration.
        :param str identity_type: Enum to determine identity framework.
               Expected value is 'Managed'.
        :param str client_id: Specifies a user-assigned identity by client ID. For system-assigned, do not set this field.
        :param str object_id: Specifies a user-assigned identity by object ID. For system-assigned, do not set this field.
        :param str resource_id: Specifies a user-assigned identity by ARM resource ID. For system-assigned, do not set this field.
        """
        ManagedIdentityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_type=identity_type,
            client_id=client_id,
            object_id=object_id,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_type: Optional[str] = None,
             client_id: Optional[str] = None,
             object_id: Optional[str] = None,
             resource_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if identity_type is None and 'identityType' in kwargs:
            identity_type = kwargs['identityType']
        if identity_type is None:
            raise TypeError("Missing 'identity_type' argument")
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if object_id is None and 'objectId' in kwargs:
            object_id = kwargs['objectId']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        _setter("identity_type", 'Managed')
        if client_id is not None:
            _setter("client_id", client_id)
        if object_id is not None:
            _setter("object_id", object_id)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="identityType")
    def identity_type(self) -> str:
        """
        Enum to determine identity framework.
        Expected value is 'Managed'.
        """
        return pulumi.get(self, "identity_type")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        Specifies a user-assigned identity by client ID. For system-assigned, do not set this field.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[str]:
        """
        Specifies a user-assigned identity by object ID. For system-assigned, do not set this field.
        """
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        Specifies a user-assigned identity by ARM resource ID. For system-assigned, do not set this field.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class ManagedOnlineDeploymentResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointComputeType":
            suggest = "endpoint_compute_type"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "appInsightsEnabled":
            suggest = "app_insights_enabled"
        elif key == "codeConfiguration":
            suggest = "code_configuration"
        elif key == "environmentId":
            suggest = "environment_id"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "livenessProbe":
            suggest = "liveness_probe"
        elif key == "readinessProbe":
            suggest = "readiness_probe"
        elif key == "requestSettings":
            suggest = "request_settings"
        elif key == "scaleSettings":
            suggest = "scale_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedOnlineDeploymentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedOnlineDeploymentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedOnlineDeploymentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_compute_type: str,
                 provisioning_state: str,
                 app_insights_enabled: Optional[bool] = None,
                 code_configuration: Optional['outputs.CodeConfigurationResponse'] = None,
                 description: Optional[str] = None,
                 environment_id: Optional[str] = None,
                 environment_variables: Optional[Mapping[str, str]] = None,
                 instance_type: Optional[str] = None,
                 liveness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
                 model: Optional[Any] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 readiness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
                 request_settings: Optional['outputs.OnlineRequestSettingsResponse'] = None,
                 scale_settings: Optional[Any] = None):
        """
        :param str endpoint_compute_type: Enum to determine endpoint compute type.
               Expected value is 'Managed'.
        :param str provisioning_state: Provisioning state for the endpoint deployment.
        :param bool app_insights_enabled: If true, enables Application Insights logging.
        :param 'CodeConfigurationResponse' code_configuration: Code configuration for the endpoint deployment.
        :param str description: Description of the endpoint deployment.
        :param str environment_id: ARM resource ID of the environment specification for the endpoint deployment.
        :param Mapping[str, str] environment_variables: Environment variables configuration for the deployment.
        :param str instance_type: Compute instance type.
        :param 'ProbeSettingsResponse' liveness_probe: Deployment container liveness/readiness probe configuration.
        :param Union['DataPathAssetReferenceResponse', 'IdAssetReferenceResponse', 'OutputPathAssetReferenceResponse'] model: Reference to the model asset for the endpoint deployment.
        :param Mapping[str, str] properties: Property dictionary. Properties can be added, but not removed or altered.
        :param 'ProbeSettingsResponse' readiness_probe: Deployment container liveness/readiness probe configuration.
        :param 'OnlineRequestSettingsResponse' request_settings: Online deployment scoring requests configuration.
        :param Union['AutoScaleSettingsResponse', 'ManualScaleSettingsResponse'] scale_settings: Online deployment scaling configuration.
        """
        ManagedOnlineDeploymentResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_compute_type=endpoint_compute_type,
            provisioning_state=provisioning_state,
            app_insights_enabled=app_insights_enabled,
            code_configuration=code_configuration,
            description=description,
            environment_id=environment_id,
            environment_variables=environment_variables,
            instance_type=instance_type,
            liveness_probe=liveness_probe,
            model=model,
            properties=properties,
            readiness_probe=readiness_probe,
            request_settings=request_settings,
            scale_settings=scale_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_compute_type: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             app_insights_enabled: Optional[bool] = None,
             code_configuration: Optional['outputs.CodeConfigurationResponse'] = None,
             description: Optional[str] = None,
             environment_id: Optional[str] = None,
             environment_variables: Optional[Mapping[str, str]] = None,
             instance_type: Optional[str] = None,
             liveness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
             model: Optional[Any] = None,
             properties: Optional[Mapping[str, str]] = None,
             readiness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
             request_settings: Optional['outputs.OnlineRequestSettingsResponse'] = None,
             scale_settings: Optional[Any] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if endpoint_compute_type is None and 'endpointComputeType' in kwargs:
            endpoint_compute_type = kwargs['endpointComputeType']
        if endpoint_compute_type is None:
            raise TypeError("Missing 'endpoint_compute_type' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if app_insights_enabled is None and 'appInsightsEnabled' in kwargs:
            app_insights_enabled = kwargs['appInsightsEnabled']
        if code_configuration is None and 'codeConfiguration' in kwargs:
            code_configuration = kwargs['codeConfiguration']
        if environment_id is None and 'environmentId' in kwargs:
            environment_id = kwargs['environmentId']
        if environment_variables is None and 'environmentVariables' in kwargs:
            environment_variables = kwargs['environmentVariables']
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if liveness_probe is None and 'livenessProbe' in kwargs:
            liveness_probe = kwargs['livenessProbe']
        if readiness_probe is None and 'readinessProbe' in kwargs:
            readiness_probe = kwargs['readinessProbe']
        if request_settings is None and 'requestSettings' in kwargs:
            request_settings = kwargs['requestSettings']
        if scale_settings is None and 'scaleSettings' in kwargs:
            scale_settings = kwargs['scaleSettings']

        _setter("endpoint_compute_type", 'Managed')
        _setter("provisioning_state", provisioning_state)
        if app_insights_enabled is not None:
            _setter("app_insights_enabled", app_insights_enabled)
        if code_configuration is not None:
            _setter("code_configuration", code_configuration)
        if description is not None:
            _setter("description", description)
        if environment_id is not None:
            _setter("environment_id", environment_id)
        if environment_variables is not None:
            _setter("environment_variables", environment_variables)
        if instance_type is not None:
            _setter("instance_type", instance_type)
        if liveness_probe is not None:
            _setter("liveness_probe", liveness_probe)
        if model is not None:
            _setter("model", model)
        if properties is not None:
            _setter("properties", properties)
        if readiness_probe is not None:
            _setter("readiness_probe", readiness_probe)
        if request_settings is not None:
            _setter("request_settings", request_settings)
        if scale_settings is not None:
            _setter("scale_settings", scale_settings)

    @property
    @pulumi.getter(name="endpointComputeType")
    def endpoint_compute_type(self) -> str:
        """
        Enum to determine endpoint compute type.
        Expected value is 'Managed'.
        """
        return pulumi.get(self, "endpoint_compute_type")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning state for the endpoint deployment.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="appInsightsEnabled")
    def app_insights_enabled(self) -> Optional[bool]:
        """
        If true, enables Application Insights logging.
        """
        return pulumi.get(self, "app_insights_enabled")

    @property
    @pulumi.getter(name="codeConfiguration")
    def code_configuration(self) -> Optional['outputs.CodeConfigurationResponse']:
        """
        Code configuration for the endpoint deployment.
        """
        return pulumi.get(self, "code_configuration")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the endpoint deployment.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[str]:
        """
        ARM resource ID of the environment specification for the endpoint deployment.
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, str]]:
        """
        Environment variables configuration for the deployment.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        Compute instance type.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.ProbeSettingsResponse']:
        """
        Deployment container liveness/readiness probe configuration.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def model(self) -> Optional[Any]:
        """
        Reference to the model asset for the endpoint deployment.
        """
        return pulumi.get(self, "model")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.ProbeSettingsResponse']:
        """
        Deployment container liveness/readiness probe configuration.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter(name="requestSettings")
    def request_settings(self) -> Optional['outputs.OnlineRequestSettingsResponse']:
        """
        Online deployment scoring requests configuration.
        """
        return pulumi.get(self, "request_settings")

    @property
    @pulumi.getter(name="scaleSettings")
    def scale_settings(self) -> Optional[Any]:
        """
        Online deployment scaling configuration.
        """
        return pulumi.get(self, "scale_settings")


@pulumi.output_type
class ManualScaleSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleType":
            suggest = "scale_type"
        elif key == "instanceCount":
            suggest = "instance_count"
        elif key == "maxInstances":
            suggest = "max_instances"
        elif key == "minInstances":
            suggest = "min_instances"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManualScaleSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManualScaleSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManualScaleSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scale_type: str,
                 instance_count: Optional[int] = None,
                 max_instances: Optional[int] = None,
                 min_instances: Optional[int] = None):
        """
        :param str scale_type: 
               Expected value is 'Manual'.
        :param int instance_count: Fixed number of instances for this deployment.
        :param int max_instances: Maximum number of instances for this deployment.
        :param int min_instances: Minimum number of instances for this deployment.
        """
        ManualScaleSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scale_type=scale_type,
            instance_count=instance_count,
            max_instances=max_instances,
            min_instances=min_instances,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scale_type: Optional[str] = None,
             instance_count: Optional[int] = None,
             max_instances: Optional[int] = None,
             min_instances: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if scale_type is None and 'scaleType' in kwargs:
            scale_type = kwargs['scaleType']
        if scale_type is None:
            raise TypeError("Missing 'scale_type' argument")
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if max_instances is None and 'maxInstances' in kwargs:
            max_instances = kwargs['maxInstances']
        if min_instances is None and 'minInstances' in kwargs:
            min_instances = kwargs['minInstances']

        _setter("scale_type", 'Manual')
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if max_instances is not None:
            _setter("max_instances", max_instances)
        if min_instances is not None:
            _setter("min_instances", min_instances)

    @property
    @pulumi.getter(name="scaleType")
    def scale_type(self) -> str:
        """

        Expected value is 'Manual'.
        """
        return pulumi.get(self, "scale_type")

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[int]:
        """
        Fixed number of instances for this deployment.
        """
        return pulumi.get(self, "instance_count")

    @property
    @pulumi.getter(name="maxInstances")
    def max_instances(self) -> Optional[int]:
        """
        Maximum number of instances for this deployment.
        """
        return pulumi.get(self, "max_instances")

    @property
    @pulumi.getter(name="minInstances")
    def min_instances(self) -> Optional[int]:
        """
        Minimum number of instances for this deployment.
        """
        return pulumi.get(self, "min_instances")


@pulumi.output_type
class MedianStoppingPolicyResponse(dict):
    """
    Defines an early termination policy based on running averages of the primary metric of all runs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyType":
            suggest = "policy_type"
        elif key == "delayEvaluation":
            suggest = "delay_evaluation"
        elif key == "evaluationInterval":
            suggest = "evaluation_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MedianStoppingPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MedianStoppingPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MedianStoppingPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_type: str,
                 delay_evaluation: Optional[int] = None,
                 evaluation_interval: Optional[int] = None):
        """
        Defines an early termination policy based on running averages of the primary metric of all runs.
        :param str policy_type: 
               Expected value is 'MedianStopping'.
        :param int delay_evaluation: Number of intervals by which to delay the first evaluation.
        :param int evaluation_interval: Interval (number of runs) between policy evaluations.
        """
        MedianStoppingPolicyResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy_type=policy_type,
            delay_evaluation=delay_evaluation,
            evaluation_interval=evaluation_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy_type: Optional[str] = None,
             delay_evaluation: Optional[int] = None,
             evaluation_interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if policy_type is None and 'policyType' in kwargs:
            policy_type = kwargs['policyType']
        if policy_type is None:
            raise TypeError("Missing 'policy_type' argument")
        if delay_evaluation is None and 'delayEvaluation' in kwargs:
            delay_evaluation = kwargs['delayEvaluation']
        if evaluation_interval is None and 'evaluationInterval' in kwargs:
            evaluation_interval = kwargs['evaluationInterval']

        _setter("policy_type", 'MedianStopping')
        if delay_evaluation is not None:
            _setter("delay_evaluation", delay_evaluation)
        if evaluation_interval is not None:
            _setter("evaluation_interval", evaluation_interval)

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> str:
        """

        Expected value is 'MedianStopping'.
        """
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="delayEvaluation")
    def delay_evaluation(self) -> Optional[int]:
        """
        Number of intervals by which to delay the first evaluation.
        """
        return pulumi.get(self, "delay_evaluation")

    @property
    @pulumi.getter(name="evaluationInterval")
    def evaluation_interval(self) -> Optional[int]:
        """
        Interval (number of runs) between policy evaluations.
        """
        return pulumi.get(self, "evaluation_interval")


@pulumi.output_type
class ModelContainerResponse(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str description: The asset description text.
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        ModelContainerResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if description is not None:
            _setter("description", description)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ModelVersionResponse(dict):
    """
    Model asset version details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datastoreId":
            suggest = "datastore_id"
        elif key == "isAnonymous":
            suggest = "is_anonymous"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 datastore_id: Optional[str] = None,
                 description: Optional[str] = None,
                 flavors: Optional[Mapping[str, 'outputs.FlavorDataResponse']] = None,
                 is_anonymous: Optional[bool] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Model asset version details.
        :param str path: [Required] The path of the file/directory in the datastore.
        :param str datastore_id: ARM resource ID of the datastore where the asset is located.
        :param str description: The asset description text.
        :param Mapping[str, 'FlavorDataResponse'] flavors: Mapping of model flavors to their properties.
        :param bool is_anonymous: If the name version are system generated (anonymous registration).
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        ModelVersionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            datastore_id=datastore_id,
            description=description,
            flavors=flavors,
            is_anonymous=is_anonymous,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[str] = None,
             datastore_id: Optional[str] = None,
             description: Optional[str] = None,
             flavors: Optional[Mapping[str, 'outputs.FlavorDataResponse']] = None,
             is_anonymous: Optional[bool] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if path is None:
            raise TypeError("Missing 'path' argument")
        if datastore_id is None and 'datastoreId' in kwargs:
            datastore_id = kwargs['datastoreId']
        if is_anonymous is None and 'isAnonymous' in kwargs:
            is_anonymous = kwargs['isAnonymous']

        _setter("path", path)
        if datastore_id is not None:
            _setter("datastore_id", datastore_id)
        if description is not None:
            _setter("description", description)
        if flavors is not None:
            _setter("flavors", flavors)
        if is_anonymous is not None:
            _setter("is_anonymous", is_anonymous)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        [Required] The path of the file/directory in the datastore.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[str]:
        """
        ARM resource ID of the datastore where the asset is located.
        """
        return pulumi.get(self, "datastore_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def flavors(self) -> Optional[Mapping[str, 'outputs.FlavorDataResponse']]:
        """
        Mapping of model flavors to their properties.
        """
        return pulumi.get(self, "flavors")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[bool]:
        """
        If the name version are system generated (anonymous registration).
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class MpiResponse(dict):
    """
    MPI distribution configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "distributionType":
            suggest = "distribution_type"
        elif key == "processCountPerInstance":
            suggest = "process_count_per_instance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MpiResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MpiResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MpiResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 distribution_type: str,
                 process_count_per_instance: Optional[int] = None):
        """
        MPI distribution configuration.
        :param str distribution_type: Enum to determine the job distribution type.
               Expected value is 'Mpi'.
        :param int process_count_per_instance: Number of processes per MPI node.
        """
        MpiResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            distribution_type=distribution_type,
            process_count_per_instance=process_count_per_instance,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             distribution_type: Optional[str] = None,
             process_count_per_instance: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if distribution_type is None and 'distributionType' in kwargs:
            distribution_type = kwargs['distributionType']
        if distribution_type is None:
            raise TypeError("Missing 'distribution_type' argument")
        if process_count_per_instance is None and 'processCountPerInstance' in kwargs:
            process_count_per_instance = kwargs['processCountPerInstance']

        _setter("distribution_type", 'Mpi')
        if process_count_per_instance is not None:
            _setter("process_count_per_instance", process_count_per_instance)

    @property
    @pulumi.getter(name="distributionType")
    def distribution_type(self) -> str:
        """
        Enum to determine the job distribution type.
        Expected value is 'Mpi'.
        """
        return pulumi.get(self, "distribution_type")

    @property
    @pulumi.getter(name="processCountPerInstance")
    def process_count_per_instance(self) -> Optional[int]:
        """
        Number of processes per MPI node.
        """
        return pulumi.get(self, "process_count_per_instance")


@pulumi.output_type
class NoneDatastoreCredentialsResponse(dict):
    """
    Empty/none datastore credentials.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsType":
            suggest = "credentials_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NoneDatastoreCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NoneDatastoreCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NoneDatastoreCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_type: str):
        """
        Empty/none datastore credentials.
        :param str credentials_type: Enum to determine the datastore credentials type.
               Expected value is 'None'.
        """
        NoneDatastoreCredentialsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials_type=credentials_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if credentials_type is None and 'credentialsType' in kwargs:
            credentials_type = kwargs['credentialsType']
        if credentials_type is None:
            raise TypeError("Missing 'credentials_type' argument")

        _setter("credentials_type", 'None')

    @property
    @pulumi.getter(name="credentialsType")
    def credentials_type(self) -> str:
        """
        Enum to determine the datastore credentials type.
        Expected value is 'None'.
        """
        return pulumi.get(self, "credentials_type")


@pulumi.output_type
class ObjectiveResponse(dict):
    """
    Optimization objective.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryMetric":
            suggest = "primary_metric"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectiveResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectiveResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectiveResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 goal: str,
                 primary_metric: str):
        """
        Optimization objective.
        :param str goal: [Required] Defines supported metric goals for hyperparameter tuning
        :param str primary_metric: [Required] Name of the metric to optimize.
        """
        ObjectiveResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            goal=goal,
            primary_metric=primary_metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             goal: Optional[str] = None,
             primary_metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if goal is None:
            raise TypeError("Missing 'goal' argument")
        if primary_metric is None and 'primaryMetric' in kwargs:
            primary_metric = kwargs['primaryMetric']
        if primary_metric is None:
            raise TypeError("Missing 'primary_metric' argument")

        _setter("goal", goal)
        _setter("primary_metric", primary_metric)

    @property
    @pulumi.getter
    def goal(self) -> str:
        """
        [Required] Defines supported metric goals for hyperparameter tuning
        """
        return pulumi.get(self, "goal")

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> str:
        """
        [Required] Name of the metric to optimize.
        """
        return pulumi.get(self, "primary_metric")


@pulumi.output_type
class OnlineEndpointResponse(dict):
    """
    Online endpoint configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authMode":
            suggest = "auth_mode"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "scoringUri":
            suggest = "scoring_uri"
        elif key == "swaggerUri":
            suggest = "swagger_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_mode: str,
                 provisioning_state: str,
                 scoring_uri: str,
                 swagger_uri: str,
                 description: Optional[str] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 target: Optional[str] = None,
                 traffic: Optional[Mapping[str, int]] = None):
        """
        Online endpoint configuration
        :param str auth_mode: [Required] Inference endpoint authentication mode type
        :param str provisioning_state: State of endpoint provisioning.
        :param str scoring_uri: Endpoint URI.
        :param str swagger_uri: Endpoint Swagger URI.
        :param str description: Description of the inference endpoint.
        :param Mapping[str, str] properties: Property dictionary. Properties can be added, but not removed or altered.
        :param str target: ARM resource ID of the compute if it exists.
               optional
        :param Mapping[str, int] traffic: Traffic rules on how the traffic will be routed across deployments.
        """
        OnlineEndpointResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_mode=auth_mode,
            provisioning_state=provisioning_state,
            scoring_uri=scoring_uri,
            swagger_uri=swagger_uri,
            description=description,
            properties=properties,
            target=target,
            traffic=traffic,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_mode: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             scoring_uri: Optional[str] = None,
             swagger_uri: Optional[str] = None,
             description: Optional[str] = None,
             properties: Optional[Mapping[str, str]] = None,
             target: Optional[str] = None,
             traffic: Optional[Mapping[str, int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auth_mode is None and 'authMode' in kwargs:
            auth_mode = kwargs['authMode']
        if auth_mode is None:
            raise TypeError("Missing 'auth_mode' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if scoring_uri is None and 'scoringUri' in kwargs:
            scoring_uri = kwargs['scoringUri']
        if scoring_uri is None:
            raise TypeError("Missing 'scoring_uri' argument")
        if swagger_uri is None and 'swaggerUri' in kwargs:
            swagger_uri = kwargs['swaggerUri']
        if swagger_uri is None:
            raise TypeError("Missing 'swagger_uri' argument")

        _setter("auth_mode", auth_mode)
        _setter("provisioning_state", provisioning_state)
        _setter("scoring_uri", scoring_uri)
        _setter("swagger_uri", swagger_uri)
        if description is not None:
            _setter("description", description)
        if properties is not None:
            _setter("properties", properties)
        if target is not None:
            _setter("target", target)
        if traffic is not None:
            _setter("traffic", traffic)

    @property
    @pulumi.getter(name="authMode")
    def auth_mode(self) -> str:
        """
        [Required] Inference endpoint authentication mode type
        """
        return pulumi.get(self, "auth_mode")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        State of endpoint provisioning.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="scoringUri")
    def scoring_uri(self) -> str:
        """
        Endpoint URI.
        """
        return pulumi.get(self, "scoring_uri")

    @property
    @pulumi.getter(name="swaggerUri")
    def swagger_uri(self) -> str:
        """
        Endpoint Swagger URI.
        """
        return pulumi.get(self, "swagger_uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the inference endpoint.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        ARM resource ID of the compute if it exists.
        optional
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def traffic(self) -> Optional[Mapping[str, int]]:
        """
        Traffic rules on how the traffic will be routed across deployments.
        """
        return pulumi.get(self, "traffic")


@pulumi.output_type
class OnlineRequestSettingsResponse(dict):
    """
    Online deployment scoring requests configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentRequestsPerInstance":
            suggest = "max_concurrent_requests_per_instance"
        elif key == "maxQueueWait":
            suggest = "max_queue_wait"
        elif key == "requestTimeout":
            suggest = "request_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineRequestSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineRequestSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineRequestSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_requests_per_instance: Optional[int] = None,
                 max_queue_wait: Optional[str] = None,
                 request_timeout: Optional[str] = None):
        """
        Online deployment scoring requests configuration.
        :param int max_concurrent_requests_per_instance: The number of requests allowed to queue at once for this deployment.
        :param str max_queue_wait: The maximum queue wait time in ISO 8601 format. Supports millisecond precision.
        :param str request_timeout: The request timeout in ISO 8601 format. Supports millisecond precision.
        """
        OnlineRequestSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_concurrent_requests_per_instance=max_concurrent_requests_per_instance,
            max_queue_wait=max_queue_wait,
            request_timeout=request_timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_concurrent_requests_per_instance: Optional[int] = None,
             max_queue_wait: Optional[str] = None,
             request_timeout: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_concurrent_requests_per_instance is None and 'maxConcurrentRequestsPerInstance' in kwargs:
            max_concurrent_requests_per_instance = kwargs['maxConcurrentRequestsPerInstance']
        if max_queue_wait is None and 'maxQueueWait' in kwargs:
            max_queue_wait = kwargs['maxQueueWait']
        if request_timeout is None and 'requestTimeout' in kwargs:
            request_timeout = kwargs['requestTimeout']

        if max_concurrent_requests_per_instance is not None:
            _setter("max_concurrent_requests_per_instance", max_concurrent_requests_per_instance)
        if max_queue_wait is not None:
            _setter("max_queue_wait", max_queue_wait)
        if request_timeout is not None:
            _setter("request_timeout", request_timeout)

    @property
    @pulumi.getter(name="maxConcurrentRequestsPerInstance")
    def max_concurrent_requests_per_instance(self) -> Optional[int]:
        """
        The number of requests allowed to queue at once for this deployment.
        """
        return pulumi.get(self, "max_concurrent_requests_per_instance")

    @property
    @pulumi.getter(name="maxQueueWait")
    def max_queue_wait(self) -> Optional[str]:
        """
        The maximum queue wait time in ISO 8601 format. Supports millisecond precision.
        """
        return pulumi.get(self, "max_queue_wait")

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[str]:
        """
        The request timeout in ISO 8601 format. Supports millisecond precision.
        """
        return pulumi.get(self, "request_timeout")


@pulumi.output_type
class OutputDataBindingResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datastoreId":
            suggest = "datastore_id"
        elif key == "pathOnCompute":
            suggest = "path_on_compute"
        elif key == "pathOnDatastore":
            suggest = "path_on_datastore"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OutputDataBindingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OutputDataBindingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OutputDataBindingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datastore_id: Optional[str] = None,
                 mode: Optional[str] = None,
                 path_on_compute: Optional[str] = None,
                 path_on_datastore: Optional[str] = None):
        """
        :param str datastore_id: ARM resource ID of the datastore where the data output will be stored.
        :param str mode: Mechanism for data movement to datastore.
        :param str path_on_compute: Location of data inside the container process.
        :param str path_on_datastore: Path within the datastore to the data.
        """
        OutputDataBindingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            datastore_id=datastore_id,
            mode=mode,
            path_on_compute=path_on_compute,
            path_on_datastore=path_on_datastore,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             datastore_id: Optional[str] = None,
             mode: Optional[str] = None,
             path_on_compute: Optional[str] = None,
             path_on_datastore: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if datastore_id is None and 'datastoreId' in kwargs:
            datastore_id = kwargs['datastoreId']
        if path_on_compute is None and 'pathOnCompute' in kwargs:
            path_on_compute = kwargs['pathOnCompute']
        if path_on_datastore is None and 'pathOnDatastore' in kwargs:
            path_on_datastore = kwargs['pathOnDatastore']

        if datastore_id is not None:
            _setter("datastore_id", datastore_id)
        if mode is not None:
            _setter("mode", mode)
        if path_on_compute is not None:
            _setter("path_on_compute", path_on_compute)
        if path_on_datastore is not None:
            _setter("path_on_datastore", path_on_datastore)

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[str]:
        """
        ARM resource ID of the datastore where the data output will be stored.
        """
        return pulumi.get(self, "datastore_id")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Mechanism for data movement to datastore.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="pathOnCompute")
    def path_on_compute(self) -> Optional[str]:
        """
        Location of data inside the container process.
        """
        return pulumi.get(self, "path_on_compute")

    @property
    @pulumi.getter(name="pathOnDatastore")
    def path_on_datastore(self) -> Optional[str]:
        """
        Path within the datastore to the data.
        """
        return pulumi.get(self, "path_on_datastore")


@pulumi.output_type
class OutputPathAssetReferenceResponse(dict):
    """
    Reference to an asset via its path in a job output.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referenceType":
            suggest = "reference_type"
        elif key == "jobId":
            suggest = "job_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OutputPathAssetReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OutputPathAssetReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OutputPathAssetReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reference_type: str,
                 job_id: Optional[str] = None,
                 path: Optional[str] = None):
        """
        Reference to an asset via its path in a job output.
        :param str reference_type: Enum to determine which reference method to use for an asset.
               Expected value is 'OutputPath'.
        :param str job_id: ARM resource ID of the job.
        :param str path: The path of the file/directory in the job output.
        """
        OutputPathAssetReferenceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            reference_type=reference_type,
            job_id=job_id,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             reference_type: Optional[str] = None,
             job_id: Optional[str] = None,
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if reference_type is None and 'referenceType' in kwargs:
            reference_type = kwargs['referenceType']
        if reference_type is None:
            raise TypeError("Missing 'reference_type' argument")
        if job_id is None and 'jobId' in kwargs:
            job_id = kwargs['jobId']

        _setter("reference_type", 'OutputPath')
        if job_id is not None:
            _setter("job_id", job_id)
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter(name="referenceType")
    def reference_type(self) -> str:
        """
        Enum to determine which reference method to use for an asset.
        Expected value is 'OutputPath'.
        """
        return pulumi.get(self, "reference_type")

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> Optional[str]:
        """
        ARM resource ID of the job.
        """
        return pulumi.get(self, "job_id")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path of the file/directory in the job output.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class ProbeSettingsResponse(dict):
    """
    Deployment container liveness/readiness probe configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "initialDelay":
            suggest = "initial_delay"
        elif key == "successThreshold":
            suggest = "success_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProbeSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProbeSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProbeSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay: Optional[str] = None,
                 period: Optional[str] = None,
                 success_threshold: Optional[int] = None,
                 timeout: Optional[str] = None):
        """
        Deployment container liveness/readiness probe configuration.
        :param int failure_threshold: The number of failures to allow before returning an unhealthy status.
        :param str initial_delay: The delay before the first probe in ISO 8601 format.
        :param str period: The length of time between probes in ISO 8601 format.
        :param int success_threshold: The number of successful probes before returning a healthy status.
        :param str timeout: The probe timeout in ISO 8601 format.
        """
        ProbeSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failure_threshold=failure_threshold,
            initial_delay=initial_delay,
            period=period,
            success_threshold=success_threshold,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failure_threshold: Optional[int] = None,
             initial_delay: Optional[str] = None,
             period: Optional[str] = None,
             success_threshold: Optional[int] = None,
             timeout: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if failure_threshold is None and 'failureThreshold' in kwargs:
            failure_threshold = kwargs['failureThreshold']
        if initial_delay is None and 'initialDelay' in kwargs:
            initial_delay = kwargs['initialDelay']
        if success_threshold is None and 'successThreshold' in kwargs:
            success_threshold = kwargs['successThreshold']

        if failure_threshold is not None:
            _setter("failure_threshold", failure_threshold)
        if initial_delay is not None:
            _setter("initial_delay", initial_delay)
        if period is not None:
            _setter("period", period)
        if success_threshold is not None:
            _setter("success_threshold", success_threshold)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        The number of failures to allow before returning an unhealthy status.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelay")
    def initial_delay(self) -> Optional[str]:
        """
        The delay before the first probe in ISO 8601 format.
        """
        return pulumi.get(self, "initial_delay")

    @property
    @pulumi.getter
    def period(self) -> Optional[str]:
        """
        The length of time between probes in ISO 8601 format.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        The number of successful probes before returning a healthy status.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        The probe timeout in ISO 8601 format.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ProgressMetricsResponse(dict):
    """
    Progress metrics definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "completedDatapointCount":
            suggest = "completed_datapoint_count"
        elif key == "incrementalDatasetLastRefreshTime":
            suggest = "incremental_dataset_last_refresh_time"
        elif key == "skippedDatapointCount":
            suggest = "skipped_datapoint_count"
        elif key == "totalDatapointCount":
            suggest = "total_datapoint_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProgressMetricsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProgressMetricsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProgressMetricsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 completed_datapoint_count: float,
                 incremental_dataset_last_refresh_time: str,
                 skipped_datapoint_count: float,
                 total_datapoint_count: float):
        """
        Progress metrics definition
        :param float completed_datapoint_count: The completed datapoint count.
        :param str incremental_dataset_last_refresh_time: The time of last successful incremental dataset refresh in UTC.
        :param float skipped_datapoint_count: The skipped datapoint count.
        :param float total_datapoint_count: The total datapoint count.
        """
        ProgressMetricsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            completed_datapoint_count=completed_datapoint_count,
            incremental_dataset_last_refresh_time=incremental_dataset_last_refresh_time,
            skipped_datapoint_count=skipped_datapoint_count,
            total_datapoint_count=total_datapoint_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             completed_datapoint_count: Optional[float] = None,
             incremental_dataset_last_refresh_time: Optional[str] = None,
             skipped_datapoint_count: Optional[float] = None,
             total_datapoint_count: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if completed_datapoint_count is None and 'completedDatapointCount' in kwargs:
            completed_datapoint_count = kwargs['completedDatapointCount']
        if completed_datapoint_count is None:
            raise TypeError("Missing 'completed_datapoint_count' argument")
        if incremental_dataset_last_refresh_time is None and 'incrementalDatasetLastRefreshTime' in kwargs:
            incremental_dataset_last_refresh_time = kwargs['incrementalDatasetLastRefreshTime']
        if incremental_dataset_last_refresh_time is None:
            raise TypeError("Missing 'incremental_dataset_last_refresh_time' argument")
        if skipped_datapoint_count is None and 'skippedDatapointCount' in kwargs:
            skipped_datapoint_count = kwargs['skippedDatapointCount']
        if skipped_datapoint_count is None:
            raise TypeError("Missing 'skipped_datapoint_count' argument")
        if total_datapoint_count is None and 'totalDatapointCount' in kwargs:
            total_datapoint_count = kwargs['totalDatapointCount']
        if total_datapoint_count is None:
            raise TypeError("Missing 'total_datapoint_count' argument")

        _setter("completed_datapoint_count", completed_datapoint_count)
        _setter("incremental_dataset_last_refresh_time", incremental_dataset_last_refresh_time)
        _setter("skipped_datapoint_count", skipped_datapoint_count)
        _setter("total_datapoint_count", total_datapoint_count)

    @property
    @pulumi.getter(name="completedDatapointCount")
    def completed_datapoint_count(self) -> float:
        """
        The completed datapoint count.
        """
        return pulumi.get(self, "completed_datapoint_count")

    @property
    @pulumi.getter(name="incrementalDatasetLastRefreshTime")
    def incremental_dataset_last_refresh_time(self) -> str:
        """
        The time of last successful incremental dataset refresh in UTC.
        """
        return pulumi.get(self, "incremental_dataset_last_refresh_time")

    @property
    @pulumi.getter(name="skippedDatapointCount")
    def skipped_datapoint_count(self) -> float:
        """
        The skipped datapoint count.
        """
        return pulumi.get(self, "skipped_datapoint_count")

    @property
    @pulumi.getter(name="totalDatapointCount")
    def total_datapoint_count(self) -> float:
        """
        The total datapoint count.
        """
        return pulumi.get(self, "total_datapoint_count")


@pulumi.output_type
class PyTorchResponse(dict):
    """
    PyTorch distribution configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "distributionType":
            suggest = "distribution_type"
        elif key == "processCount":
            suggest = "process_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PyTorchResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PyTorchResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PyTorchResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 distribution_type: str,
                 process_count: Optional[int] = None):
        """
        PyTorch distribution configuration.
        :param str distribution_type: Enum to determine the job distribution type.
               Expected value is 'PyTorch'.
        :param int process_count: Total process count for the distributed job.
        """
        PyTorchResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            distribution_type=distribution_type,
            process_count=process_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             distribution_type: Optional[str] = None,
             process_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if distribution_type is None and 'distributionType' in kwargs:
            distribution_type = kwargs['distributionType']
        if distribution_type is None:
            raise TypeError("Missing 'distribution_type' argument")
        if process_count is None and 'processCount' in kwargs:
            process_count = kwargs['processCount']

        _setter("distribution_type", 'PyTorch')
        if process_count is not None:
            _setter("process_count", process_count)

    @property
    @pulumi.getter(name="distributionType")
    def distribution_type(self) -> str:
        """
        Enum to determine the job distribution type.
        Expected value is 'PyTorch'.
        """
        return pulumi.get(self, "distribution_type")

    @property
    @pulumi.getter(name="processCount")
    def process_count(self) -> Optional[int]:
        """
        Total process count for the distributed job.
        """
        return pulumi.get(self, "process_count")


@pulumi.output_type
class ResourceIdentityResponse(dict):
    """
    Service identity associated with a resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: Optional[str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityMetaResponse']] = None):
        """
        Service identity associated with a resource.
        :param str principal_id: Client ID that is used when authenticating.
        :param str tenant_id: AAD Tenant where this identity lives.
        :param str type: Defines values for a ResourceIdentity's type.
        :param Mapping[str, 'UserAssignedIdentityMetaResponse'] user_assigned_identities: Dictionary of the user assigned identities, key is ARM resource ID of the UAI.
        """
        ResourceIdentityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            principal_id=principal_id,
            tenant_id=tenant_id,
            type=type,
            user_assigned_identities=user_assigned_identities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             principal_id: Optional[str] = None,
             tenant_id: Optional[str] = None,
             type: Optional[str] = None,
             user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityMetaResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if principal_id is None and 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if principal_id is None:
            raise TypeError("Missing 'principal_id' argument")
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_id is None:
            raise TypeError("Missing 'tenant_id' argument")
        if user_assigned_identities is None and 'userAssignedIdentities' in kwargs:
            user_assigned_identities = kwargs['userAssignedIdentities']

        _setter("principal_id", principal_id)
        _setter("tenant_id", tenant_id)
        if type is not None:
            _setter("type", type)
        if user_assigned_identities is not None:
            _setter("user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        Client ID that is used when authenticating.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        AAD Tenant where this identity lives.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Defines values for a ResourceIdentity's type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityMetaResponse']]:
        """
        Dictionary of the user assigned identities, key is ARM resource ID of the UAI.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class RouteResponse(dict):
    def __init__(__self__, *,
                 path: str,
                 port: int):
        """
        :param str path: [Required] The path for the route.
        :param int port: [Required] The port for the route.
        """
        RouteResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[str] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if path is None:
            raise TypeError("Missing 'path' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")

        _setter("path", path)
        _setter("port", port)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        [Required] The path for the route.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        [Required] The port for the route.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class SasDatastoreCredentialsResponse(dict):
    """
    SAS datastore credentials configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsType":
            suggest = "credentials_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SasDatastoreCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SasDatastoreCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SasDatastoreCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_type: str):
        """
        SAS datastore credentials configuration.
        :param str credentials_type: Enum to determine the datastore credentials type.
               Expected value is 'Sas'.
        """
        SasDatastoreCredentialsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials_type=credentials_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if credentials_type is None and 'credentialsType' in kwargs:
            credentials_type = kwargs['credentialsType']
        if credentials_type is None:
            raise TypeError("Missing 'credentials_type' argument")

        _setter("credentials_type", 'Sas')

    @property
    @pulumi.getter(name="credentialsType")
    def credentials_type(self) -> str:
        """
        Enum to determine the datastore credentials type.
        Expected value is 'Sas'.
        """
        return pulumi.get(self, "credentials_type")


@pulumi.output_type
class ServicePrincipalDatastoreCredentialsResponse(dict):
    """
    Service Principal datastore credentials configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "credentialsType":
            suggest = "credentials_type"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "authorityUrl":
            suggest = "authority_url"
        elif key == "resourceUri":
            suggest = "resource_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicePrincipalDatastoreCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicePrincipalDatastoreCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicePrincipalDatastoreCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 credentials_type: str,
                 tenant_id: str,
                 authority_url: Optional[str] = None,
                 resource_uri: Optional[str] = None):
        """
        Service Principal datastore credentials configuration.
        :param str client_id: [Required] Service principal client ID.
        :param str credentials_type: Enum to determine the datastore credentials type.
               Expected value is 'ServicePrincipal'.
        :param str tenant_id: [Required] ID of the tenant to which the service principal belongs.
        :param str authority_url: Authority URL used for authentication.
        :param str resource_uri: Resource the service principal has access to.
        """
        ServicePrincipalDatastoreCredentialsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            credentials_type=credentials_type,
            tenant_id=tenant_id,
            authority_url=authority_url,
            resource_uri=resource_uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[str] = None,
             credentials_type: Optional[str] = None,
             tenant_id: Optional[str] = None,
             authority_url: Optional[str] = None,
             resource_uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_id is None:
            raise TypeError("Missing 'client_id' argument")
        if credentials_type is None and 'credentialsType' in kwargs:
            credentials_type = kwargs['credentialsType']
        if credentials_type is None:
            raise TypeError("Missing 'credentials_type' argument")
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_id is None:
            raise TypeError("Missing 'tenant_id' argument")
        if authority_url is None and 'authorityUrl' in kwargs:
            authority_url = kwargs['authorityUrl']
        if resource_uri is None and 'resourceUri' in kwargs:
            resource_uri = kwargs['resourceUri']

        _setter("client_id", client_id)
        _setter("credentials_type", 'ServicePrincipal')
        _setter("tenant_id", tenant_id)
        if authority_url is not None:
            _setter("authority_url", authority_url)
        if resource_uri is not None:
            _setter("resource_uri", resource_uri)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        [Required] Service principal client ID.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="credentialsType")
    def credentials_type(self) -> str:
        """
        Enum to determine the datastore credentials type.
        Expected value is 'ServicePrincipal'.
        """
        return pulumi.get(self, "credentials_type")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        [Required] ID of the tenant to which the service principal belongs.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="authorityUrl")
    def authority_url(self) -> Optional[str]:
        """
        Authority URL used for authentication.
        """
        return pulumi.get(self, "authority_url")

    @property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[str]:
        """
        Resource the service principal has access to.
        """
        return pulumi.get(self, "resource_uri")


@pulumi.output_type
class SqlAdminDatastoreCredentialsResponse(dict):
    """
    SQL Admin datastore credentials configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsType":
            suggest = "credentials_type"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlAdminDatastoreCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlAdminDatastoreCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlAdminDatastoreCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_type: str,
                 user_id: str):
        """
        SQL Admin datastore credentials configuration.
        :param str credentials_type: Enum to determine the datastore credentials type.
               Expected value is 'SqlAdmin'.
        :param str user_id: [Required] SQL database user name.
        """
        SqlAdminDatastoreCredentialsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials_type=credentials_type,
            user_id=user_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials_type: Optional[str] = None,
             user_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if credentials_type is None and 'credentialsType' in kwargs:
            credentials_type = kwargs['credentialsType']
        if credentials_type is None:
            raise TypeError("Missing 'credentials_type' argument")
        if user_id is None and 'userId' in kwargs:
            user_id = kwargs['userId']
        if user_id is None:
            raise TypeError("Missing 'user_id' argument")

        _setter("credentials_type", 'SqlAdmin')
        _setter("user_id", user_id)

    @property
    @pulumi.getter(name="credentialsType")
    def credentials_type(self) -> str:
        """
        Enum to determine the datastore credentials type.
        Expected value is 'SqlAdmin'.
        """
        return pulumi.get(self, "credentials_type")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        [Required] SQL database user name.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class StatusMessageResponse(dict):
    """
    Active message associated with project
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdTimeUtc":
            suggest = "created_time_utc"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatusMessageResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatusMessageResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatusMessageResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code: str,
                 created_time_utc: str,
                 level: str,
                 message: str):
        """
        Active message associated with project
        :param str code: Service-defined message code.
        :param str created_time_utc: Time in UTC at which the message was created.
        :param str level: Severity level of message.
        :param str message: A human-readable representation of the message code.
        """
        StatusMessageResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            created_time_utc=created_time_utc,
            level=level,
            message=message,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: Optional[str] = None,
             created_time_utc: Optional[str] = None,
             level: Optional[str] = None,
             message: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if code is None:
            raise TypeError("Missing 'code' argument")
        if created_time_utc is None and 'createdTimeUtc' in kwargs:
            created_time_utc = kwargs['createdTimeUtc']
        if created_time_utc is None:
            raise TypeError("Missing 'created_time_utc' argument")
        if level is None:
            raise TypeError("Missing 'level' argument")
        if message is None:
            raise TypeError("Missing 'message' argument")

        _setter("code", code)
        _setter("created_time_utc", created_time_utc)
        _setter("level", level)
        _setter("message", message)

    @property
    @pulumi.getter
    def code(self) -> str:
        """
        Service-defined message code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="createdTimeUtc")
    def created_time_utc(self) -> str:
        """
        Time in UTC at which the message was created.
        """
        return pulumi.get(self, "created_time_utc")

    @property
    @pulumi.getter
    def level(self) -> str:
        """
        Severity level of message.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        A human-readable representation of the message code.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class SweepJobResponse(dict):
    """
    Sweep job definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interactionEndpoints":
            suggest = "interaction_endpoints"
        elif key == "jobType":
            suggest = "job_type"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "searchSpace":
            suggest = "search_space"
        elif key == "earlyTermination":
            suggest = "early_termination"
        elif key == "experimentName":
            suggest = "experiment_name"
        elif key == "maxConcurrentTrials":
            suggest = "max_concurrent_trials"
        elif key == "maxTotalTrials":
            suggest = "max_total_trials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SweepJobResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SweepJobResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SweepJobResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: str,
                 compute: 'outputs.ComputeConfigurationResponse',
                 interaction_endpoints: Mapping[str, 'outputs.JobEndpointResponse'],
                 job_type: str,
                 objective: 'outputs.ObjectiveResponse',
                 output: 'outputs.JobOutputResponse',
                 provisioning_state: str,
                 search_space: Mapping[str, Any],
                 status: str,
                 description: Optional[str] = None,
                 early_termination: Optional[Any] = None,
                 experiment_name: Optional[str] = None,
                 identity: Optional[Any] = None,
                 max_concurrent_trials: Optional[int] = None,
                 max_total_trials: Optional[int] = None,
                 priority: Optional[int] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 timeout: Optional[str] = None,
                 trial: Optional['outputs.TrialComponentResponse'] = None):
        """
        Sweep job definition.
        :param str algorithm: [Required] Type of the hyperparameter sampling algorithms
        :param 'ComputeConfigurationResponse' compute: [Required] Compute binding for the job.
        :param Mapping[str, 'JobEndpointResponse'] interaction_endpoints: List of JobEndpoints.
               For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        :param str job_type: Enum to determine the type of job.
               Expected value is 'Sweep'.
        :param 'ObjectiveResponse' objective: [Required] Optimization objective.
        :param 'JobOutputResponse' output: Location of the job output logs and artifacts.
        :param str provisioning_state: Specifies the job provisioning state.
        :param Mapping[str, Any] search_space: [Required] A dictionary containing each parameter and its distribution. The dictionary key is the name of the parameter
        :param str status: The status of a job.
        :param str description: The asset description text.
        :param Union['BanditPolicyResponse', 'MedianStoppingPolicyResponse', 'TruncationSelectionPolicyResponse'] early_termination: Early termination policies enable canceling poor-performing runs before they complete.
        :param str experiment_name: The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        :param Union['AmlTokenResponse', 'ManagedIdentityResponse'] identity: Identity configuration. If set, this should be one of AmlToken, ManagedIdentity or null.
               Defaults to AmlToken if null.
        :param int max_concurrent_trials: An upper bound on the number of trials performed in parallel.
        :param int max_total_trials: An upper bound on the number of trials to perform.
        :param int priority: Job priority for scheduling policy. Only applies to AMLCompute.
               Private preview feature and only available to users on the allow list.
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        :param str timeout: The total timeout in ISO 8601 format. Only supports duration with precision as low as Minutes.
        :param 'TrialComponentResponse' trial: Trial component definition.
        """
        SweepJobResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            algorithm=algorithm,
            compute=compute,
            interaction_endpoints=interaction_endpoints,
            job_type=job_type,
            objective=objective,
            output=output,
            provisioning_state=provisioning_state,
            search_space=search_space,
            status=status,
            description=description,
            early_termination=early_termination,
            experiment_name=experiment_name,
            identity=identity,
            max_concurrent_trials=max_concurrent_trials,
            max_total_trials=max_total_trials,
            priority=priority,
            properties=properties,
            tags=tags,
            timeout=timeout,
            trial=trial,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             algorithm: Optional[str] = None,
             compute: Optional['outputs.ComputeConfigurationResponse'] = None,
             interaction_endpoints: Optional[Mapping[str, 'outputs.JobEndpointResponse']] = None,
             job_type: Optional[str] = None,
             objective: Optional['outputs.ObjectiveResponse'] = None,
             output: Optional['outputs.JobOutputResponse'] = None,
             provisioning_state: Optional[str] = None,
             search_space: Optional[Mapping[str, Any]] = None,
             status: Optional[str] = None,
             description: Optional[str] = None,
             early_termination: Optional[Any] = None,
             experiment_name: Optional[str] = None,
             identity: Optional[Any] = None,
             max_concurrent_trials: Optional[int] = None,
             max_total_trials: Optional[int] = None,
             priority: Optional[int] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             timeout: Optional[str] = None,
             trial: Optional['outputs.TrialComponentResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if algorithm is None:
            raise TypeError("Missing 'algorithm' argument")
        if compute is None:
            raise TypeError("Missing 'compute' argument")
        if interaction_endpoints is None and 'interactionEndpoints' in kwargs:
            interaction_endpoints = kwargs['interactionEndpoints']
        if interaction_endpoints is None:
            raise TypeError("Missing 'interaction_endpoints' argument")
        if job_type is None and 'jobType' in kwargs:
            job_type = kwargs['jobType']
        if job_type is None:
            raise TypeError("Missing 'job_type' argument")
        if objective is None:
            raise TypeError("Missing 'objective' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if search_space is None and 'searchSpace' in kwargs:
            search_space = kwargs['searchSpace']
        if search_space is None:
            raise TypeError("Missing 'search_space' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if early_termination is None and 'earlyTermination' in kwargs:
            early_termination = kwargs['earlyTermination']
        if experiment_name is None and 'experimentName' in kwargs:
            experiment_name = kwargs['experimentName']
        if max_concurrent_trials is None and 'maxConcurrentTrials' in kwargs:
            max_concurrent_trials = kwargs['maxConcurrentTrials']
        if max_total_trials is None and 'maxTotalTrials' in kwargs:
            max_total_trials = kwargs['maxTotalTrials']

        _setter("algorithm", algorithm)
        _setter("compute", compute)
        _setter("interaction_endpoints", interaction_endpoints)
        _setter("job_type", 'Sweep')
        _setter("objective", objective)
        _setter("output", output)
        _setter("provisioning_state", provisioning_state)
        _setter("search_space", search_space)
        _setter("status", status)
        if description is not None:
            _setter("description", description)
        if early_termination is not None:
            _setter("early_termination", early_termination)
        if experiment_name is not None:
            _setter("experiment_name", experiment_name)
        if identity is not None:
            _setter("identity", identity)
        if max_concurrent_trials is not None:
            _setter("max_concurrent_trials", max_concurrent_trials)
        if max_total_trials is not None:
            _setter("max_total_trials", max_total_trials)
        if priority is not None:
            _setter("priority", priority)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)
        if timeout is not None:
            _setter("timeout", timeout)
        if trial is not None:
            _setter("trial", trial)

    @property
    @pulumi.getter
    def algorithm(self) -> str:
        """
        [Required] Type of the hyperparameter sampling algorithms
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.ComputeConfigurationResponse':
        """
        [Required] Compute binding for the job.
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="interactionEndpoints")
    def interaction_endpoints(self) -> Mapping[str, 'outputs.JobEndpointResponse']:
        """
        List of JobEndpoints.
        For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        """
        return pulumi.get(self, "interaction_endpoints")

    @property
    @pulumi.getter(name="jobType")
    def job_type(self) -> str:
        """
        Enum to determine the type of job.
        Expected value is 'Sweep'.
        """
        return pulumi.get(self, "job_type")

    @property
    @pulumi.getter
    def objective(self) -> 'outputs.ObjectiveResponse':
        """
        [Required] Optimization objective.
        """
        return pulumi.get(self, "objective")

    @property
    @pulumi.getter
    def output(self) -> 'outputs.JobOutputResponse':
        """
        Location of the job output logs and artifacts.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Specifies the job provisioning state.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="searchSpace")
    def search_space(self) -> Mapping[str, Any]:
        """
        [Required] A dictionary containing each parameter and its distribution. The dictionary key is the name of the parameter
        """
        return pulumi.get(self, "search_space")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of a job.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="earlyTermination")
    def early_termination(self) -> Optional[Any]:
        """
        Early termination policies enable canceling poor-performing runs before they complete.
        """
        return pulumi.get(self, "early_termination")

    @property
    @pulumi.getter(name="experimentName")
    def experiment_name(self) -> Optional[str]:
        """
        The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        """
        return pulumi.get(self, "experiment_name")

    @property
    @pulumi.getter
    def identity(self) -> Optional[Any]:
        """
        Identity configuration. If set, this should be one of AmlToken, ManagedIdentity or null.
        Defaults to AmlToken if null.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter(name="maxConcurrentTrials")
    def max_concurrent_trials(self) -> Optional[int]:
        """
        An upper bound on the number of trials performed in parallel.
        """
        return pulumi.get(self, "max_concurrent_trials")

    @property
    @pulumi.getter(name="maxTotalTrials")
    def max_total_trials(self) -> Optional[int]:
        """
        An upper bound on the number of trials to perform.
        """
        return pulumi.get(self, "max_total_trials")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Job priority for scheduling policy. Only applies to AMLCompute.
        Private preview feature and only available to users on the allow list.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        The total timeout in ISO 8601 format. Only supports duration with precision as low as Minutes.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def trial(self) -> Optional['outputs.TrialComponentResponse']:
        """
        Trial component definition.
        """
        return pulumi.get(self, "trial")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        SystemDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            created_by=created_by,
            created_by_type=created_by_type,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            last_modified_by_type=last_modified_by_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: Optional[str] = None,
             created_by: Optional[str] = None,
             created_by_type: Optional[str] = None,
             last_modified_at: Optional[str] = None,
             last_modified_by: Optional[str] = None,
             last_modified_by_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if created_at is None and 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if created_by_type is None and 'createdByType' in kwargs:
            created_by_type = kwargs['createdByType']
        if last_modified_at is None and 'lastModifiedAt' in kwargs:
            last_modified_at = kwargs['lastModifiedAt']
        if last_modified_by is None and 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if last_modified_by_type is None and 'lastModifiedByType' in kwargs:
            last_modified_by_type = kwargs['lastModifiedByType']

        if created_at is not None:
            _setter("created_at", created_at)
        if created_by is not None:
            _setter("created_by", created_by)
        if created_by_type is not None:
            _setter("created_by_type", created_by_type)
        if last_modified_at is not None:
            _setter("last_modified_at", last_modified_at)
        if last_modified_by is not None:
            _setter("last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            _setter("last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TensorFlowResponse(dict):
    """
    TensorFlow distribution configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "distributionType":
            suggest = "distribution_type"
        elif key == "parameterServerCount":
            suggest = "parameter_server_count"
        elif key == "workerCount":
            suggest = "worker_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TensorFlowResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TensorFlowResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TensorFlowResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 distribution_type: str,
                 parameter_server_count: Optional[int] = None,
                 worker_count: Optional[int] = None):
        """
        TensorFlow distribution configuration.
        :param str distribution_type: Enum to determine the job distribution type.
               Expected value is 'TensorFlow'.
        :param int parameter_server_count: Number of parameter server tasks.
        :param int worker_count: Number of workers. Overwrites the node count in compute binding.
        """
        TensorFlowResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            distribution_type=distribution_type,
            parameter_server_count=parameter_server_count,
            worker_count=worker_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             distribution_type: Optional[str] = None,
             parameter_server_count: Optional[int] = None,
             worker_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if distribution_type is None and 'distributionType' in kwargs:
            distribution_type = kwargs['distributionType']
        if distribution_type is None:
            raise TypeError("Missing 'distribution_type' argument")
        if parameter_server_count is None and 'parameterServerCount' in kwargs:
            parameter_server_count = kwargs['parameterServerCount']
        if worker_count is None and 'workerCount' in kwargs:
            worker_count = kwargs['workerCount']

        _setter("distribution_type", 'TensorFlow')
        if parameter_server_count is not None:
            _setter("parameter_server_count", parameter_server_count)
        if worker_count is not None:
            _setter("worker_count", worker_count)

    @property
    @pulumi.getter(name="distributionType")
    def distribution_type(self) -> str:
        """
        Enum to determine the job distribution type.
        Expected value is 'TensorFlow'.
        """
        return pulumi.get(self, "distribution_type")

    @property
    @pulumi.getter(name="parameterServerCount")
    def parameter_server_count(self) -> Optional[int]:
        """
        Number of parameter server tasks.
        """
        return pulumi.get(self, "parameter_server_count")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[int]:
        """
        Number of workers. Overwrites the node count in compute binding.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class TrialComponentResponse(dict):
    """
    Trial component definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codeId":
            suggest = "code_id"
        elif key == "environmentId":
            suggest = "environment_id"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "inputDataBindings":
            suggest = "input_data_bindings"
        elif key == "outputDataBindings":
            suggest = "output_data_bindings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrialComponentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrialComponentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrialComponentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command: str,
                 code_id: Optional[str] = None,
                 distribution: Optional[Any] = None,
                 environment_id: Optional[str] = None,
                 environment_variables: Optional[Mapping[str, str]] = None,
                 input_data_bindings: Optional[Mapping[str, 'outputs.InputDataBindingResponse']] = None,
                 output_data_bindings: Optional[Mapping[str, 'outputs.OutputDataBindingResponse']] = None,
                 timeout: Optional[str] = None):
        """
        Trial component definition.
        :param str command: [Required] The command to execute on startup of the job. eg. "python train.py"
        :param str code_id: ARM resource ID of the code asset.
        :param Union['MpiResponse', 'PyTorchResponse', 'TensorFlowResponse'] distribution: Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, or null.
        :param str environment_id: The ARM resource ID of the Environment specification for the job.
        :param Mapping[str, str] environment_variables: Environment variables included in the job.
        :param Mapping[str, 'InputDataBindingResponse'] input_data_bindings: Mapping of input data bindings used in the job.
        :param Mapping[str, 'OutputDataBindingResponse'] output_data_bindings: Mapping of output data bindings used in the job.
        :param str timeout: The max run duration in ISO 8601 format, after which the trial component will be cancelled.
               Only supports duration with precision as low as Seconds.
        """
        TrialComponentResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            command=command,
            code_id=code_id,
            distribution=distribution,
            environment_id=environment_id,
            environment_variables=environment_variables,
            input_data_bindings=input_data_bindings,
            output_data_bindings=output_data_bindings,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             command: Optional[str] = None,
             code_id: Optional[str] = None,
             distribution: Optional[Any] = None,
             environment_id: Optional[str] = None,
             environment_variables: Optional[Mapping[str, str]] = None,
             input_data_bindings: Optional[Mapping[str, 'outputs.InputDataBindingResponse']] = None,
             output_data_bindings: Optional[Mapping[str, 'outputs.OutputDataBindingResponse']] = None,
             timeout: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if command is None:
            raise TypeError("Missing 'command' argument")
        if code_id is None and 'codeId' in kwargs:
            code_id = kwargs['codeId']
        if environment_id is None and 'environmentId' in kwargs:
            environment_id = kwargs['environmentId']
        if environment_variables is None and 'environmentVariables' in kwargs:
            environment_variables = kwargs['environmentVariables']
        if input_data_bindings is None and 'inputDataBindings' in kwargs:
            input_data_bindings = kwargs['inputDataBindings']
        if output_data_bindings is None and 'outputDataBindings' in kwargs:
            output_data_bindings = kwargs['outputDataBindings']

        _setter("command", command)
        if code_id is not None:
            _setter("code_id", code_id)
        if distribution is not None:
            _setter("distribution", distribution)
        if environment_id is not None:
            _setter("environment_id", environment_id)
        if environment_variables is not None:
            _setter("environment_variables", environment_variables)
        if input_data_bindings is not None:
            _setter("input_data_bindings", input_data_bindings)
        if output_data_bindings is not None:
            _setter("output_data_bindings", output_data_bindings)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter
    def command(self) -> str:
        """
        [Required] The command to execute on startup of the job. eg. "python train.py"
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter(name="codeId")
    def code_id(self) -> Optional[str]:
        """
        ARM resource ID of the code asset.
        """
        return pulumi.get(self, "code_id")

    @property
    @pulumi.getter
    def distribution(self) -> Optional[Any]:
        """
        Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, or null.
        """
        return pulumi.get(self, "distribution")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[str]:
        """
        The ARM resource ID of the Environment specification for the job.
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, str]]:
        """
        Environment variables included in the job.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="inputDataBindings")
    def input_data_bindings(self) -> Optional[Mapping[str, 'outputs.InputDataBindingResponse']]:
        """
        Mapping of input data bindings used in the job.
        """
        return pulumi.get(self, "input_data_bindings")

    @property
    @pulumi.getter(name="outputDataBindings")
    def output_data_bindings(self) -> Optional[Mapping[str, 'outputs.OutputDataBindingResponse']]:
        """
        Mapping of output data bindings used in the job.
        """
        return pulumi.get(self, "output_data_bindings")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        The max run duration in ISO 8601 format, after which the trial component will be cancelled.
        Only supports duration with precision as low as Seconds.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class TruncationSelectionPolicyResponse(dict):
    """
    Defines an early termination policy that cancels a given percentage of runs at each evaluation interval.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyType":
            suggest = "policy_type"
        elif key == "delayEvaluation":
            suggest = "delay_evaluation"
        elif key == "evaluationInterval":
            suggest = "evaluation_interval"
        elif key == "truncationPercentage":
            suggest = "truncation_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TruncationSelectionPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TruncationSelectionPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TruncationSelectionPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_type: str,
                 delay_evaluation: Optional[int] = None,
                 evaluation_interval: Optional[int] = None,
                 truncation_percentage: Optional[int] = None):
        """
        Defines an early termination policy that cancels a given percentage of runs at each evaluation interval.
        :param str policy_type: 
               Expected value is 'TruncationSelection'.
        :param int delay_evaluation: Number of intervals by which to delay the first evaluation.
        :param int evaluation_interval: Interval (number of runs) between policy evaluations.
        :param int truncation_percentage: The percentage of runs to cancel at each evaluation interval.
        """
        TruncationSelectionPolicyResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy_type=policy_type,
            delay_evaluation=delay_evaluation,
            evaluation_interval=evaluation_interval,
            truncation_percentage=truncation_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy_type: Optional[str] = None,
             delay_evaluation: Optional[int] = None,
             evaluation_interval: Optional[int] = None,
             truncation_percentage: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if policy_type is None and 'policyType' in kwargs:
            policy_type = kwargs['policyType']
        if policy_type is None:
            raise TypeError("Missing 'policy_type' argument")
        if delay_evaluation is None and 'delayEvaluation' in kwargs:
            delay_evaluation = kwargs['delayEvaluation']
        if evaluation_interval is None and 'evaluationInterval' in kwargs:
            evaluation_interval = kwargs['evaluationInterval']
        if truncation_percentage is None and 'truncationPercentage' in kwargs:
            truncation_percentage = kwargs['truncationPercentage']

        _setter("policy_type", 'TruncationSelection')
        if delay_evaluation is not None:
            _setter("delay_evaluation", delay_evaluation)
        if evaluation_interval is not None:
            _setter("evaluation_interval", evaluation_interval)
        if truncation_percentage is not None:
            _setter("truncation_percentage", truncation_percentage)

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> str:
        """

        Expected value is 'TruncationSelection'.
        """
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="delayEvaluation")
    def delay_evaluation(self) -> Optional[int]:
        """
        Number of intervals by which to delay the first evaluation.
        """
        return pulumi.get(self, "delay_evaluation")

    @property
    @pulumi.getter(name="evaluationInterval")
    def evaluation_interval(self) -> Optional[int]:
        """
        Interval (number of runs) between policy evaluations.
        """
        return pulumi.get(self, "evaluation_interval")

    @property
    @pulumi.getter(name="truncationPercentage")
    def truncation_percentage(self) -> Optional[int]:
        """
        The percentage of runs to cancel at each evaluation interval.
        """
        return pulumi.get(self, "truncation_percentage")


@pulumi.output_type
class UserAssignedIdentityMetaResponse(dict):
    """
    User assigned identities associated with a resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityMetaResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityMetaResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityMetaResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[str] = None,
                 principal_id: Optional[str] = None):
        """
        User assigned identities associated with a resource.
        :param str client_id: Aka application ID, a unique identifier generated by Azure AD that is tied to an application and service principal during its initial provisioning.
        :param str principal_id: The object ID of the service principal object for your managed identity that is used to grant role-based access to an Azure resource.
        """
        UserAssignedIdentityMetaResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            principal_id=principal_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[str] = None,
             principal_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if principal_id is None and 'principalId' in kwargs:
            principal_id = kwargs['principalId']

        if client_id is not None:
            _setter("client_id", client_id)
        if principal_id is not None:
            _setter("principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        Aka application ID, a unique identifier generated by Azure AD that is tied to an application and service principal during its initial provisioning.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The object ID of the service principal object for your managed identity that is used to grant role-based access to an Azure resource.
        """
        return pulumi.get(self, "principal_id")


