# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ActualCapacityInfoResponse',
    'CapacityReservationGroupResponse',
    'CodeConfigurationResponse',
    'EstimatedVMPriceResponse',
    'EstimatedVMPricesResponse',
    'InferenceEndpointResponse',
    'InferenceGroupResponse',
    'InferencePoolResponse',
    'ManagedServiceIdentityResponse',
    'PoolEnvironmentConfigurationResponse',
    'PoolModelConfigurationResponse',
    'ProbeSettingsResponse',
    'RequestConfigurationResponse',
    'ServerlessEndpointCapacityReservationResponse',
    'ServerlessEndpointResponse',
    'ServerlessInferenceEndpointResponse',
    'ServerlessOfferResponse',
    'SkuResponse',
    'SystemDataResponse',
    'UserAssignedIdentityResponse',
    'VirtualMachineSizeResponse',
]

@pulumi.output_type
class ActualCapacityInfoResponse(dict):
    def __init__(__self__, *,
                 allocated: Optional[int] = None,
                 assignment_failed: Optional[int] = None,
                 assignment_success: Optional[int] = None):
        """
        :param int allocated: Gets or sets the total number of instances for the group.
        :param int assignment_failed: Gets or sets the number of instances which failed to successfully complete assignment.
        :param int assignment_success: Gets or sets the number of instances which successfully completed assignment.
        """
        if allocated is None:
            allocated = 0
        if allocated is not None:
            pulumi.set(__self__, "allocated", allocated)
        if assignment_failed is None:
            assignment_failed = 0
        if assignment_failed is not None:
            pulumi.set(__self__, "assignment_failed", assignment_failed)
        if assignment_success is None:
            assignment_success = 0
        if assignment_success is not None:
            pulumi.set(__self__, "assignment_success", assignment_success)

    @property
    @pulumi.getter
    def allocated(self) -> Optional[int]:
        """
        Gets or sets the total number of instances for the group.
        """
        return pulumi.get(self, "allocated")

    @property
    @pulumi.getter(name="assignmentFailed")
    def assignment_failed(self) -> Optional[int]:
        """
        Gets or sets the number of instances which failed to successfully complete assignment.
        """
        return pulumi.get(self, "assignment_failed")

    @property
    @pulumi.getter(name="assignmentSuccess")
    def assignment_success(self) -> Optional[int]:
        """
        Gets or sets the number of instances which successfully completed assignment.
        """
        return pulumi.get(self, "assignment_success")


@pulumi.output_type
class CapacityReservationGroupResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reservedCapacity":
            suggest = "reserved_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityReservationGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityReservationGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityReservationGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reserved_capacity: int,
                 offer: Optional['outputs.ServerlessOfferResponse'] = None):
        """
        :param int reserved_capacity: [Required] Specifies the amount of capacity to reserve.
        :param 'ServerlessOfferResponse' offer: Offer used by this capacity reservation group.
        """
        pulumi.set(__self__, "reserved_capacity", reserved_capacity)
        if offer is not None:
            pulumi.set(__self__, "offer", offer)

    @property
    @pulumi.getter(name="reservedCapacity")
    def reserved_capacity(self) -> int:
        """
        [Required] Specifies the amount of capacity to reserve.
        """
        return pulumi.get(self, "reserved_capacity")

    @property
    @pulumi.getter
    def offer(self) -> Optional['outputs.ServerlessOfferResponse']:
        """
        Offer used by this capacity reservation group.
        """
        return pulumi.get(self, "offer")


@pulumi.output_type
class CodeConfigurationResponse(dict):
    """
    Configuration for a scoring code asset.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scoringScript":
            suggest = "scoring_script"
        elif key == "codeId":
            suggest = "code_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scoring_script: str,
                 code_id: Optional[str] = None):
        """
        Configuration for a scoring code asset.
        :param str scoring_script: [Required] The script to execute on startup. eg. "score.py"
        :param str code_id: ARM resource ID of the code asset.
        """
        pulumi.set(__self__, "scoring_script", scoring_script)
        if code_id is not None:
            pulumi.set(__self__, "code_id", code_id)

    @property
    @pulumi.getter(name="scoringScript")
    def scoring_script(self) -> str:
        """
        [Required] The script to execute on startup. eg. "score.py"
        """
        return pulumi.get(self, "scoring_script")

    @property
    @pulumi.getter(name="codeId")
    def code_id(self) -> Optional[str]:
        """
        ARM resource ID of the code asset.
        """
        return pulumi.get(self, "code_id")


@pulumi.output_type
class EstimatedVMPriceResponse(dict):
    """
    The estimated price info for using a VM of a particular OS type, tier, etc.
    """
    def __init__(__self__, *,
                 os_type: str,
                 retail_price: float,
                 vm_tier: str):
        """
        The estimated price info for using a VM of a particular OS type, tier, etc.
        :param str os_type: Operating system type used by the VM.
        :param float retail_price: The price charged for using the VM.
        :param str vm_tier: The type of the VM.
        """
        pulumi.set(__self__, "os_type", os_type)
        pulumi.set(__self__, "retail_price", retail_price)
        pulumi.set(__self__, "vm_tier", vm_tier)

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> str:
        """
        Operating system type used by the VM.
        """
        return pulumi.get(self, "os_type")

    @property
    @pulumi.getter(name="retailPrice")
    def retail_price(self) -> float:
        """
        The price charged for using the VM.
        """
        return pulumi.get(self, "retail_price")

    @property
    @pulumi.getter(name="vmTier")
    def vm_tier(self) -> str:
        """
        The type of the VM.
        """
        return pulumi.get(self, "vm_tier")


@pulumi.output_type
class EstimatedVMPricesResponse(dict):
    """
    The estimated price info for using a VM.
    """
    def __init__(__self__, *,
                 billing_currency: str,
                 unit_of_measure: str,
                 values: Sequence['outputs.EstimatedVMPriceResponse']):
        """
        The estimated price info for using a VM.
        :param str billing_currency: Three lettered code specifying the currency of the VM price. Example: USD
        :param str unit_of_measure: The unit of time measurement for the specified VM price. Example: OneHour
        :param Sequence['EstimatedVMPriceResponse'] values: The list of estimated prices for using a VM of a particular OS type, tier, etc.
        """
        pulumi.set(__self__, "billing_currency", billing_currency)
        pulumi.set(__self__, "unit_of_measure", unit_of_measure)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="billingCurrency")
    def billing_currency(self) -> str:
        """
        Three lettered code specifying the currency of the VM price. Example: USD
        """
        return pulumi.get(self, "billing_currency")

    @property
    @pulumi.getter(name="unitOfMeasure")
    def unit_of_measure(self) -> str:
        """
        The unit of time measurement for the specified VM price. Example: OneHour
        """
        return pulumi.get(self, "unit_of_measure")

    @property
    @pulumi.getter
    def values(self) -> Sequence['outputs.EstimatedVMPriceResponse']:
        """
        The list of estimated prices for using a VM of a particular OS type, tier, etc.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class InferenceEndpointResponse(dict):
    """
    InferenceEndpoint configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authMode":
            suggest = "auth_mode"
        elif key == "endpointUri":
            suggest = "endpoint_uri"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InferenceEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InferenceEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InferenceEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_mode: str,
                 endpoint_uri: str,
                 group_id: str,
                 provisioning_state: str,
                 description: Optional[str] = None,
                 properties: Optional[Mapping[str, str]] = None):
        """
        InferenceEndpoint configuration
        :param str auth_mode: [Required] Authentication mode for the endpoint.
        :param str endpoint_uri: Endpoint URI for the inference endpoint.
        :param str group_id: [Required] Group within the same pool with which this endpoint needs to be associated with.
        :param str provisioning_state: Provisioning state for the endpoint.
        :param str description: Description of the resource.
        :param Mapping[str, str] properties: Property dictionary. Properties can be added, but not removed or altered.
        """
        pulumi.set(__self__, "auth_mode", auth_mode)
        pulumi.set(__self__, "endpoint_uri", endpoint_uri)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter(name="authMode")
    def auth_mode(self) -> str:
        """
        [Required] Authentication mode for the endpoint.
        """
        return pulumi.get(self, "auth_mode")

    @property
    @pulumi.getter(name="endpointUri")
    def endpoint_uri(self) -> str:
        """
        Endpoint URI for the inference endpoint.
        """
        return pulumi.get(self, "endpoint_uri")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        [Required] Group within the same pool with which this endpoint needs to be associated with.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning state for the endpoint.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the resource.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class InferenceGroupResponse(dict):
    """
    Inference group configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "bonusExtraCapacity":
            suggest = "bonus_extra_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InferenceGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InferenceGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InferenceGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 bonus_extra_capacity: Optional[int] = None,
                 description: Optional[str] = None,
                 metadata: Optional[str] = None,
                 priority: Optional[int] = None,
                 properties: Optional[Mapping[str, str]] = None):
        """
        Inference group configuration
        :param str provisioning_state: Provisioning state for the inference group.
        :param int bonus_extra_capacity: Capacity to be used from the pool's reserved capacity.
               optional
        :param str description: Description of the resource.
        :param str metadata: Metadata for the inference group.
        :param int priority: Priority of the group within the N:Microsoft.MachineLearning.ManagementFrontEnd.Contracts.V20230801Preview.Pools.InferencePools.
        :param Mapping[str, str] properties: Property dictionary. Properties can be added, but not removed or altered.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if bonus_extra_capacity is None:
            bonus_extra_capacity = 0
        if bonus_extra_capacity is not None:
            pulumi.set(__self__, "bonus_extra_capacity", bonus_extra_capacity)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if priority is None:
            priority = 0
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning state for the inference group.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="bonusExtraCapacity")
    def bonus_extra_capacity(self) -> Optional[int]:
        """
        Capacity to be used from the pool's reserved capacity.
        optional
        """
        return pulumi.get(self, "bonus_extra_capacity")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the resource.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[str]:
        """
        Metadata for the inference group.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Priority of the group within the N:Microsoft.MachineLearning.ManagementFrontEnd.Contracts.V20230801Preview.Pools.InferencePools.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class InferencePoolResponse(dict):
    """
    Inference pool configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeSkuType":
            suggest = "node_sku_type"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "codeConfiguration":
            suggest = "code_configuration"
        elif key == "environmentConfiguration":
            suggest = "environment_configuration"
        elif key == "modelConfiguration":
            suggest = "model_configuration"
        elif key == "requestConfiguration":
            suggest = "request_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InferencePoolResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InferencePoolResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InferencePoolResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_sku_type: str,
                 provisioning_state: str,
                 code_configuration: Optional['outputs.CodeConfigurationResponse'] = None,
                 description: Optional[str] = None,
                 environment_configuration: Optional['outputs.PoolEnvironmentConfigurationResponse'] = None,
                 model_configuration: Optional['outputs.PoolModelConfigurationResponse'] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 request_configuration: Optional['outputs.RequestConfigurationResponse'] = None):
        """
        Inference pool configuration
        :param str node_sku_type: [Required] Compute instance type.
        :param str provisioning_state: Provisioning state for the pool.
        :param 'CodeConfigurationResponse' code_configuration: Code configuration for the inference pool.
        :param str description: Description of the resource.
        :param 'PoolEnvironmentConfigurationResponse' environment_configuration: EnvironmentConfiguration for the inference pool.
        :param 'PoolModelConfigurationResponse' model_configuration: ModelConfiguration for the inference pool.
        :param Mapping[str, str] properties: Property dictionary. Properties can be added, but not removed or altered.
        :param 'RequestConfigurationResponse' request_configuration: Request configuration for the inference pool.
        """
        pulumi.set(__self__, "node_sku_type", node_sku_type)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if code_configuration is not None:
            pulumi.set(__self__, "code_configuration", code_configuration)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if environment_configuration is not None:
            pulumi.set(__self__, "environment_configuration", environment_configuration)
        if model_configuration is not None:
            pulumi.set(__self__, "model_configuration", model_configuration)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if request_configuration is not None:
            pulumi.set(__self__, "request_configuration", request_configuration)

    @property
    @pulumi.getter(name="nodeSkuType")
    def node_sku_type(self) -> str:
        """
        [Required] Compute instance type.
        """
        return pulumi.get(self, "node_sku_type")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning state for the pool.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="codeConfiguration")
    def code_configuration(self) -> Optional['outputs.CodeConfigurationResponse']:
        """
        Code configuration for the inference pool.
        """
        return pulumi.get(self, "code_configuration")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the resource.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="environmentConfiguration")
    def environment_configuration(self) -> Optional['outputs.PoolEnvironmentConfigurationResponse']:
        """
        EnvironmentConfiguration for the inference pool.
        """
        return pulumi.get(self, "environment_configuration")

    @property
    @pulumi.getter(name="modelConfiguration")
    def model_configuration(self) -> Optional['outputs.PoolModelConfigurationResponse']:
        """
        ModelConfiguration for the inference pool.
        """
        return pulumi.get(self, "model_configuration")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="requestConfiguration")
    def request_configuration(self) -> Optional['outputs.RequestConfigurationResponse']:
        """
        Request configuration for the inference pool.
        """
        return pulumi.get(self, "request_configuration")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity (system assigned and/or user assigned identities)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class PoolEnvironmentConfigurationResponse(dict):
    """
    Environment configuration options.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentId":
            suggest = "environment_id"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "livenessProbe":
            suggest = "liveness_probe"
        elif key == "readinessProbe":
            suggest = "readiness_probe"
        elif key == "startupProbe":
            suggest = "startup_probe"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PoolEnvironmentConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PoolEnvironmentConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PoolEnvironmentConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 environment_id: Optional[str] = None,
                 environment_variables: Optional[Mapping[str, str]] = None,
                 liveness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
                 readiness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
                 startup_probe: Optional['outputs.ProbeSettingsResponse'] = None):
        """
        Environment configuration options.
        :param str environment_id: ARM resource ID of the environment specification for the inference pool.
        :param Mapping[str, str] environment_variables: Environment variables configuration for the inference pool.
        :param 'ProbeSettingsResponse' liveness_probe: Liveness probe monitors the health of the container regularly.
        :param 'ProbeSettingsResponse' readiness_probe: Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
        :param 'ProbeSettingsResponse' startup_probe: This verifies whether the application within a container is started. Startup probes run before any other probe, and, unless it finishes successfully, disables other probes.
        """
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if startup_probe is not None:
            pulumi.set(__self__, "startup_probe", startup_probe)

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[str]:
        """
        ARM resource ID of the environment specification for the inference pool.
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, str]]:
        """
        Environment variables configuration for the inference pool.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.ProbeSettingsResponse']:
        """
        Liveness probe monitors the health of the container regularly.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.ProbeSettingsResponse']:
        """
        Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter(name="startupProbe")
    def startup_probe(self) -> Optional['outputs.ProbeSettingsResponse']:
        """
        This verifies whether the application within a container is started. Startup probes run before any other probe, and, unless it finishes successfully, disables other probes.
        """
        return pulumi.get(self, "startup_probe")


@pulumi.output_type
class PoolModelConfigurationResponse(dict):
    """
    Model configuration options.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelId":
            suggest = "model_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PoolModelConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PoolModelConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PoolModelConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model_id: Optional[str] = None):
        """
        Model configuration options.
        :param str model_id: The URI path to the model.
        """
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)

    @property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[str]:
        """
        The URI path to the model.
        """
        return pulumi.get(self, "model_id")


@pulumi.output_type
class ProbeSettingsResponse(dict):
    """
    Deployment container liveness/readiness probe configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "initialDelay":
            suggest = "initial_delay"
        elif key == "successThreshold":
            suggest = "success_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProbeSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProbeSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProbeSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay: Optional[str] = None,
                 period: Optional[str] = None,
                 success_threshold: Optional[int] = None,
                 timeout: Optional[str] = None):
        """
        Deployment container liveness/readiness probe configuration.
        :param int failure_threshold: The number of failures to allow before returning an unhealthy status.
        :param str initial_delay: The delay before the first probe in ISO 8601 format.
        :param str period: The length of time between probes in ISO 8601 format.
        :param int success_threshold: The number of successful probes before returning a healthy status.
        :param str timeout: The probe timeout in ISO 8601 format.
        """
        if failure_threshold is None:
            failure_threshold = 30
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay is not None:
            pulumi.set(__self__, "initial_delay", initial_delay)
        if period is None:
            period = 'PT10S'
        if period is not None:
            pulumi.set(__self__, "period", period)
        if success_threshold is None:
            success_threshold = 1
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout is None:
            timeout = 'PT2S'
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        The number of failures to allow before returning an unhealthy status.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelay")
    def initial_delay(self) -> Optional[str]:
        """
        The delay before the first probe in ISO 8601 format.
        """
        return pulumi.get(self, "initial_delay")

    @property
    @pulumi.getter
    def period(self) -> Optional[str]:
        """
        The length of time between probes in ISO 8601 format.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        The number of successful probes before returning a healthy status.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        The probe timeout in ISO 8601 format.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class RequestConfigurationResponse(dict):
    """
    Scoring requests configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentRequestsPerInstance":
            suggest = "max_concurrent_requests_per_instance"
        elif key == "requestTimeout":
            suggest = "request_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_requests_per_instance: Optional[int] = None,
                 request_timeout: Optional[str] = None):
        """
        Scoring requests configuration.
        :param int max_concurrent_requests_per_instance: The number of maximum concurrent requests per node allowed per deployment. Defaults to 1.
        :param str request_timeout: The scoring timeout in ISO 8601 format.
               Defaults to 5000ms.
        """
        if max_concurrent_requests_per_instance is None:
            max_concurrent_requests_per_instance = 1
        if max_concurrent_requests_per_instance is not None:
            pulumi.set(__self__, "max_concurrent_requests_per_instance", max_concurrent_requests_per_instance)
        if request_timeout is None:
            request_timeout = 'PT5S'
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)

    @property
    @pulumi.getter(name="maxConcurrentRequestsPerInstance")
    def max_concurrent_requests_per_instance(self) -> Optional[int]:
        """
        The number of maximum concurrent requests per node allowed per deployment. Defaults to 1.
        """
        return pulumi.get(self, "max_concurrent_requests_per_instance")

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[str]:
        """
        The scoring timeout in ISO 8601 format.
        Defaults to 5000ms.
        """
        return pulumi.get(self, "request_timeout")


@pulumi.output_type
class ServerlessEndpointCapacityReservationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationGroupId":
            suggest = "capacity_reservation_group_id"
        elif key == "endpointReservedCapacity":
            suggest = "endpoint_reserved_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessEndpointCapacityReservationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessEndpointCapacityReservationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessEndpointCapacityReservationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_group_id: str,
                 endpoint_reserved_capacity: Optional[int] = None):
        """
        :param str capacity_reservation_group_id: [Required] Specifies a capacity reservation group ID to allocate capacity from.
        :param int endpoint_reserved_capacity: Specifies a capacity amount to reserve for this endpoint within the parent capacity reservation group.
        """
        pulumi.set(__self__, "capacity_reservation_group_id", capacity_reservation_group_id)
        if endpoint_reserved_capacity is not None:
            pulumi.set(__self__, "endpoint_reserved_capacity", endpoint_reserved_capacity)

    @property
    @pulumi.getter(name="capacityReservationGroupId")
    def capacity_reservation_group_id(self) -> str:
        """
        [Required] Specifies a capacity reservation group ID to allocate capacity from.
        """
        return pulumi.get(self, "capacity_reservation_group_id")

    @property
    @pulumi.getter(name="endpointReservedCapacity")
    def endpoint_reserved_capacity(self) -> Optional[int]:
        """
        Specifies a capacity amount to reserve for this endpoint within the parent capacity reservation group.
        """
        return pulumi.get(self, "endpoint_reserved_capacity")


@pulumi.output_type
class ServerlessEndpointResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inferenceEndpoint":
            suggest = "inference_endpoint"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "authMode":
            suggest = "auth_mode"
        elif key == "capacityReservation":
            suggest = "capacity_reservation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inference_endpoint: 'outputs.ServerlessInferenceEndpointResponse',
                 offer: 'outputs.ServerlessOfferResponse',
                 provisioning_state: str,
                 auth_mode: Optional[str] = None,
                 capacity_reservation: Optional['outputs.ServerlessEndpointCapacityReservationResponse'] = None):
        """
        :param 'ServerlessInferenceEndpointResponse' inference_endpoint: The inference uri to target when making requests against the serverless endpoint
        :param 'ServerlessOfferResponse' offer: [Required] The publisher-defined Serverless Offer to provision the endpoint with.
        :param str provisioning_state: Provisioning state for the endpoint.
        :param str auth_mode: Specifies the authentication mode for the Serverless endpoint.
        :param 'ServerlessEndpointCapacityReservationResponse' capacity_reservation: Optional capacity reservation information for the endpoint. When specified, the Serverless Endpoint
               will be allocated capacity from the specified capacity reservation group.
        """
        pulumi.set(__self__, "inference_endpoint", inference_endpoint)
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if auth_mode is not None:
            pulumi.set(__self__, "auth_mode", auth_mode)
        if capacity_reservation is not None:
            pulumi.set(__self__, "capacity_reservation", capacity_reservation)

    @property
    @pulumi.getter(name="inferenceEndpoint")
    def inference_endpoint(self) -> 'outputs.ServerlessInferenceEndpointResponse':
        """
        The inference uri to target when making requests against the serverless endpoint
        """
        return pulumi.get(self, "inference_endpoint")

    @property
    @pulumi.getter
    def offer(self) -> 'outputs.ServerlessOfferResponse':
        """
        [Required] The publisher-defined Serverless Offer to provision the endpoint with.
        """
        return pulumi.get(self, "offer")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning state for the endpoint.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="authMode")
    def auth_mode(self) -> Optional[str]:
        """
        Specifies the authentication mode for the Serverless endpoint.
        """
        return pulumi.get(self, "auth_mode")

    @property
    @pulumi.getter(name="capacityReservation")
    def capacity_reservation(self) -> Optional['outputs.ServerlessEndpointCapacityReservationResponse']:
        """
        Optional capacity reservation information for the endpoint. When specified, the Serverless Endpoint
        will be allocated capacity from the specified capacity reservation group.
        """
        return pulumi.get(self, "capacity_reservation")


@pulumi.output_type
class ServerlessInferenceEndpointResponse(dict):
    def __init__(__self__, *,
                 headers: Mapping[str, str],
                 uri: str):
        """
        :param Mapping[str, str] headers: Specifies any required headers to target this serverless endpoint.
        :param str uri: [Required] The inference uri to target when making requests against the Serverless Endpoint.
        """
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def headers(self) -> Mapping[str, str]:
        """
        Specifies any required headers to target this serverless endpoint.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        [Required] The inference uri to target when making requests against the Serverless Endpoint.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class ServerlessOfferResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offerName":
            suggest = "offer_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessOfferResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessOfferResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessOfferResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 offer_name: str,
                 publisher: str):
        """
        :param str offer_name: [Required] The name of the Serverless Offer
        :param str publisher: [Required] Publisher name of the Serverless Offer
        """
        pulumi.set(__self__, "offer_name", offer_name)
        pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter(name="offerName")
    def offer_name(self) -> str:
        """
        [Required] The name of the Serverless Offer
        """
        return pulumi.get(self, "offer_name")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        [Required] Publisher name of the Serverless Offer
        """
        return pulumi.get(self, "publisher")


@pulumi.output_type
class SkuResponse(dict):
    """
    The resource model definition representing SKU
    """
    def __init__(__self__, *,
                 name: str,
                 capacity: Optional[int] = None,
                 family: Optional[str] = None,
                 size: Optional[str] = None,
                 tier: Optional[str] = None):
        """
        The resource model definition representing SKU
        :param str name: The name of the SKU. Ex - P3. It is typically a letter+number code
        :param int capacity: If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        :param str family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
        :param str size: The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        :param str tier: This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the SKU. Ex - P3. It is typically a letter+number code
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def capacity(self) -> Optional[int]:
        """
        If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def family(self) -> Optional[str]:
        """
        If the service has different generations of hardware, for the same SKU, then that can be captured here.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        """
        The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        """
        This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str):
        """
        User assigned identity properties
        :param str client_id: The client ID of the assigned identity.
        :param str principal_id: The principal ID of the assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class VirtualMachineSizeResponse(dict):
    """
    Describes the properties of a VM size.
    """
    def __init__(__self__, *,
                 family: str,
                 gpus: int,
                 low_priority_capable: bool,
                 max_resource_volume_mb: int,
                 memory_gb: float,
                 name: str,
                 os_vhd_size_mb: int,
                 premium_io: bool,
                 v_cpus: int,
                 estimated_vm_prices: Optional['outputs.EstimatedVMPricesResponse'] = None,
                 supported_compute_types: Optional[Sequence[str]] = None):
        """
        Describes the properties of a VM size.
        :param str family: The family name of the virtual machine size.
        :param int gpus: The number of gPUs supported by the virtual machine size.
        :param bool low_priority_capable: Specifies if the virtual machine size supports low priority VMs.
        :param int max_resource_volume_mb: The resource volume size, in MB, allowed by the virtual machine size.
        :param float memory_gb: The amount of memory, in GB, supported by the virtual machine size.
        :param str name: The name of the virtual machine size.
        :param int os_vhd_size_mb: The OS VHD disk size, in MB, allowed by the virtual machine size.
        :param bool premium_io: Specifies if the virtual machine size supports premium IO.
        :param int v_cpus: The number of vCPUs supported by the virtual machine size.
        :param 'EstimatedVMPricesResponse' estimated_vm_prices: The estimated price information for using a VM.
        :param Sequence[str] supported_compute_types: Specifies the compute types supported by the virtual machine size.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "gpus", gpus)
        pulumi.set(__self__, "low_priority_capable", low_priority_capable)
        pulumi.set(__self__, "max_resource_volume_mb", max_resource_volume_mb)
        pulumi.set(__self__, "memory_gb", memory_gb)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "os_vhd_size_mb", os_vhd_size_mb)
        pulumi.set(__self__, "premium_io", premium_io)
        pulumi.set(__self__, "v_cpus", v_cpus)
        if estimated_vm_prices is not None:
            pulumi.set(__self__, "estimated_vm_prices", estimated_vm_prices)
        if supported_compute_types is not None:
            pulumi.set(__self__, "supported_compute_types", supported_compute_types)

    @property
    @pulumi.getter
    def family(self) -> str:
        """
        The family name of the virtual machine size.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def gpus(self) -> int:
        """
        The number of gPUs supported by the virtual machine size.
        """
        return pulumi.get(self, "gpus")

    @property
    @pulumi.getter(name="lowPriorityCapable")
    def low_priority_capable(self) -> bool:
        """
        Specifies if the virtual machine size supports low priority VMs.
        """
        return pulumi.get(self, "low_priority_capable")

    @property
    @pulumi.getter(name="maxResourceVolumeMB")
    def max_resource_volume_mb(self) -> int:
        """
        The resource volume size, in MB, allowed by the virtual machine size.
        """
        return pulumi.get(self, "max_resource_volume_mb")

    @property
    @pulumi.getter(name="memoryGB")
    def memory_gb(self) -> float:
        """
        The amount of memory, in GB, supported by the virtual machine size.
        """
        return pulumi.get(self, "memory_gb")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the virtual machine size.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="osVhdSizeMB")
    def os_vhd_size_mb(self) -> int:
        """
        The OS VHD disk size, in MB, allowed by the virtual machine size.
        """
        return pulumi.get(self, "os_vhd_size_mb")

    @property
    @pulumi.getter(name="premiumIO")
    def premium_io(self) -> bool:
        """
        Specifies if the virtual machine size supports premium IO.
        """
        return pulumi.get(self, "premium_io")

    @property
    @pulumi.getter(name="vCPUs")
    def v_cpus(self) -> int:
        """
        The number of vCPUs supported by the virtual machine size.
        """
        return pulumi.get(self, "v_cpus")

    @property
    @pulumi.getter(name="estimatedVMPrices")
    def estimated_vm_prices(self) -> Optional['outputs.EstimatedVMPricesResponse']:
        """
        The estimated price information for using a VM.
        """
        return pulumi.get(self, "estimated_vm_prices")

    @property
    @pulumi.getter(name="supportedComputeTypes")
    def supported_compute_types(self) -> Optional[Sequence[str]]:
        """
        Specifies the compute types supported by the virtual machine size.
        """
        return pulumi.get(self, "supported_compute_types")


