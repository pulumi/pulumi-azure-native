# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AccountKeyDatastoreCredentialsResponse',
    'AmlTokenResponse',
    'AutoForecastHorizonResponse',
    'AutoMLJobResponse',
    'AutoNCrossValidationsResponse',
    'AutoSeasonalityResponse',
    'AutoTargetLagsResponse',
    'AutoTargetRollingWindowSizeResponse',
    'AzureBlobDatastoreResponse',
    'AzureDataLakeGen1DatastoreResponse',
    'AzureDataLakeGen2DatastoreResponse',
    'AzureFileDatastoreResponse',
    'BanditPolicyResponse',
    'BatchDeploymentResponse',
    'BatchEndpointDefaultsResponse',
    'BatchEndpointResponse',
    'BatchRetrySettingsResponse',
    'BayesianSamplingAlgorithmResponse',
    'BuildContextResponse',
    'CertificateDatastoreCredentialsResponse',
    'ClassificationResponse',
    'CodeConfigurationResponse',
    'CodeContainerResponse',
    'CodeVersionResponse',
    'ColumnTransformerResponse',
    'CommandJobLimitsResponse',
    'CommandJobResponse',
    'ComponentContainerResponse',
    'ComponentVersionResponse',
    'ContainerResourceRequirementsResponse',
    'ContainerResourceSettingsResponse',
    'CronScheduleResponse',
    'CustomForecastHorizonResponse',
    'CustomModelJobInputResponse',
    'CustomModelJobOutputResponse',
    'CustomNCrossValidationsResponse',
    'CustomSeasonalityResponse',
    'CustomTargetLagsResponse',
    'CustomTargetRollingWindowSizeResponse',
    'DataContainerResponse',
    'DataPathAssetReferenceResponse',
    'DefaultScaleSettingsResponse',
    'EnvironmentContainerResponse',
    'EnvironmentVersionResponse',
    'FlavorDataResponse',
    'ForecastingResponse',
    'ForecastingSettingsResponse',
    'GridSamplingAlgorithmResponse',
    'HdfsDatastoreResponse',
    'IdAssetReferenceResponse',
    'ImageClassificationMultilabelResponse',
    'ImageClassificationResponse',
    'ImageInstanceSegmentationResponse',
    'ImageLimitSettingsResponse',
    'ImageModelDistributionSettingsClassificationResponse',
    'ImageModelDistributionSettingsObjectDetectionResponse',
    'ImageModelSettingsClassificationResponse',
    'ImageModelSettingsObjectDetectionResponse',
    'ImageObjectDetectionResponse',
    'ImageSweepLimitSettingsResponse',
    'ImageSweepSettingsResponse',
    'ImageVerticalDataSettingsResponse',
    'ImageVerticalValidationDataSettingsResponse',
    'InferenceContainerPropertiesResponse',
    'JobServiceResponse',
    'KerberosKeytabCredentialsResponse',
    'KerberosPasswordCredentialsResponse',
    'KubernetesOnlineDeploymentResponse',
    'LiteralJobInputResponse',
    'MLFlowModelJobInputResponse',
    'MLFlowModelJobOutputResponse',
    'MLTableDataResponse',
    'MLTableJobInputResponse',
    'MLTableJobOutputResponse',
    'ManagedIdentityResponse',
    'ManagedOnlineDeploymentResponse',
    'ManagedServiceIdentityResponse',
    'MedianStoppingPolicyResponse',
    'ModelContainerResponse',
    'ModelVersionResponse',
    'MpiResponse',
    'NlpVerticalDataSettingsResponse',
    'NlpVerticalFeaturizationSettingsResponse',
    'NlpVerticalLimitSettingsResponse',
    'NlpVerticalValidationDataSettingsResponse',
    'NoneDatastoreCredentialsResponse',
    'ObjectiveResponse',
    'OnlineEndpointResponse',
    'OnlineRequestSettingsResponse',
    'OutputPathAssetReferenceResponse',
    'PipelineJobResponse',
    'ProbeSettingsResponse',
    'PyTorchResponse',
    'RandomSamplingAlgorithmResponse',
    'RecurrencePatternResponse',
    'RecurrenceScheduleResponse',
    'RegressionResponse',
    'ResourceConfigurationResponse',
    'RouteResponse',
    'SasDatastoreCredentialsResponse',
    'ServicePrincipalDatastoreCredentialsResponse',
    'SkuResponse',
    'StackEnsembleSettingsResponse',
    'SweepJobLimitsResponse',
    'SweepJobResponse',
    'SystemDataResponse',
    'TableVerticalDataSettingsResponse',
    'TableVerticalFeaturizationSettingsResponse',
    'TableVerticalLimitSettingsResponse',
    'TableVerticalValidationDataSettingsResponse',
    'TargetUtilizationScaleSettingsResponse',
    'TensorFlowResponse',
    'TestDataSettingsResponse',
    'TextClassificationMultilabelResponse',
    'TextClassificationResponse',
    'TextNerResponse',
    'TrainingDataSettingsResponse',
    'TrainingSettingsResponse',
    'TrialComponentResponse',
    'TritonModelJobInputResponse',
    'TritonModelJobOutputResponse',
    'TruncationSelectionPolicyResponse',
    'UriFileDataVersionResponse',
    'UriFileJobInputResponse',
    'UriFileJobOutputResponse',
    'UriFolderDataVersionResponse',
    'UriFolderJobInputResponse',
    'UriFolderJobOutputResponse',
    'UserAssignedIdentityResponse',
    'UserIdentityResponse',
]

@pulumi.output_type
class AccountKeyDatastoreCredentialsResponse(dict):
    """
    Account key datastore credentials configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsType":
            suggest = "credentials_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountKeyDatastoreCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountKeyDatastoreCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountKeyDatastoreCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_type: str):
        """
        Account key datastore credentials configuration.
        :param str credentials_type: Enum to determine the datastore credentials type.
               Expected value is 'AccountKey'.
        """
        AccountKeyDatastoreCredentialsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials_type=credentials_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if credentials_type is None and 'credentialsType' in kwargs:
            credentials_type = kwargs['credentialsType']
        if credentials_type is None:
            raise TypeError("Missing 'credentials_type' argument")

        _setter("credentials_type", 'AccountKey')

    @property
    @pulumi.getter(name="credentialsType")
    def credentials_type(self) -> str:
        """
        Enum to determine the datastore credentials type.
        Expected value is 'AccountKey'.
        """
        return pulumi.get(self, "credentials_type")


@pulumi.output_type
class AmlTokenResponse(dict):
    """
    AML Token identity configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityType":
            suggest = "identity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmlTokenResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmlTokenResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmlTokenResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_type: str):
        """
        AML Token identity configuration.
        :param str identity_type: Enum to determine identity framework.
               Expected value is 'AMLToken'.
        """
        AmlTokenResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_type=identity_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if identity_type is None and 'identityType' in kwargs:
            identity_type = kwargs['identityType']
        if identity_type is None:
            raise TypeError("Missing 'identity_type' argument")

        _setter("identity_type", 'AMLToken')

    @property
    @pulumi.getter(name="identityType")
    def identity_type(self) -> str:
        """
        Enum to determine identity framework.
        Expected value is 'AMLToken'.
        """
        return pulumi.get(self, "identity_type")


@pulumi.output_type
class AutoForecastHorizonResponse(dict):
    """
    Forecast horizon determined automatically by system.
    """
    def __init__(__self__, *,
                 mode: str):
        """
        Forecast horizon determined automatically by system.
        :param str mode: Enum to determine forecast horizon selection mode.
               Expected value is 'Auto'.
        """
        AutoForecastHorizonResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mode is None:
            raise TypeError("Missing 'mode' argument")

        _setter("mode", 'Auto')

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Enum to determine forecast horizon selection mode.
        Expected value is 'Auto'.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class AutoMLJobResponse(dict):
    """
    AutoMLJob class.
    Use this class for executing AutoML tasks like Classification/Regression etc.
    See TaskType enum for all the tasks supported.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobType":
            suggest = "job_type"
        elif key == "taskDetails":
            suggest = "task_details"
        elif key == "computeId":
            suggest = "compute_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "environmentId":
            suggest = "environment_id"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "experimentName":
            suggest = "experiment_name"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoMLJobResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoMLJobResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoMLJobResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_type: str,
                 status: str,
                 task_details: Any,
                 compute_id: Optional[str] = None,
                 description: Optional[str] = None,
                 display_name: Optional[str] = None,
                 environment_id: Optional[str] = None,
                 environment_variables: Optional[Mapping[str, str]] = None,
                 experiment_name: Optional[str] = None,
                 identity: Optional[Any] = None,
                 is_archived: Optional[bool] = None,
                 outputs: Optional[Mapping[str, Any]] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 resources: Optional['outputs.ResourceConfigurationResponse'] = None,
                 schedule: Optional[Any] = None,
                 services: Optional[Mapping[str, 'outputs.JobServiceResponse']] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        AutoMLJob class.
        Use this class for executing AutoML tasks like Classification/Regression etc.
        See TaskType enum for all the tasks supported.
        :param str job_type: Enum to determine the type of job.
               Expected value is 'AutoML'.
        :param str status: Status of the job.
        :param Union['ClassificationResponse', 'ForecastingResponse', 'ImageClassificationResponse', 'ImageClassificationMultilabelResponse', 'ImageInstanceSegmentationResponse', 'ImageObjectDetectionResponse', 'RegressionResponse', 'TextClassificationResponse', 'TextClassificationMultilabelResponse', 'TextNerResponse'] task_details: [Required] This represents scenario which can be one of Tables/NLP/Image
        :param str compute_id: ARM resource ID of the compute resource.
        :param str description: The asset description text.
        :param str display_name: Display name of job.
        :param str environment_id: The ARM resource ID of the Environment specification for the job.
               This is optional value to provide, if not provided, AutoML will default this to Production AutoML curated environment version when running the job.
        :param Mapping[str, str] environment_variables: Environment variables included in the job.
        :param str experiment_name: The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        :param Union['AmlTokenResponse', 'ManagedIdentityResponse', 'UserIdentityResponse'] identity: Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
               Defaults to AmlToken if null.
        :param bool is_archived: Is the asset archived?
        :param Mapping[str, Union['CustomModelJobOutputResponse', 'MLFlowModelJobOutputResponse', 'MLTableJobOutputResponse', 'TritonModelJobOutputResponse', 'UriFileJobOutputResponse', 'UriFolderJobOutputResponse']] outputs: Mapping of output data bindings used in the job.
        :param Mapping[str, str] properties: The asset property dictionary.
        :param 'ResourceConfigurationResponse' resources: Compute Resource configuration for the job.
        :param Union['CronScheduleResponse', 'RecurrenceScheduleResponse'] schedule: Schedule definition of job.
               If no schedule is provided, the job is run once and immediately after submission.
        :param Mapping[str, 'JobServiceResponse'] services: List of JobEndpoints.
               For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        AutoMLJobResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_type=job_type,
            status=status,
            task_details=task_details,
            compute_id=compute_id,
            description=description,
            display_name=display_name,
            environment_id=environment_id,
            environment_variables=environment_variables,
            experiment_name=experiment_name,
            identity=identity,
            is_archived=is_archived,
            outputs=outputs,
            properties=properties,
            resources=resources,
            schedule=schedule,
            services=services,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_type: Optional[str] = None,
             status: Optional[str] = None,
             task_details: Optional[Any] = None,
             compute_id: Optional[str] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             environment_id: Optional[str] = None,
             environment_variables: Optional[Mapping[str, str]] = None,
             experiment_name: Optional[str] = None,
             identity: Optional[Any] = None,
             is_archived: Optional[bool] = None,
             outputs: Optional[Mapping[str, Any]] = None,
             properties: Optional[Mapping[str, str]] = None,
             resources: Optional['outputs.ResourceConfigurationResponse'] = None,
             schedule: Optional[Any] = None,
             services: Optional[Mapping[str, 'outputs.JobServiceResponse']] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if job_type is None and 'jobType' in kwargs:
            job_type = kwargs['jobType']
        if job_type is None:
            raise TypeError("Missing 'job_type' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if task_details is None and 'taskDetails' in kwargs:
            task_details = kwargs['taskDetails']
        if task_details is None:
            raise TypeError("Missing 'task_details' argument")
        if compute_id is None and 'computeId' in kwargs:
            compute_id = kwargs['computeId']
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if environment_id is None and 'environmentId' in kwargs:
            environment_id = kwargs['environmentId']
        if environment_variables is None and 'environmentVariables' in kwargs:
            environment_variables = kwargs['environmentVariables']
        if experiment_name is None and 'experimentName' in kwargs:
            experiment_name = kwargs['experimentName']
        if is_archived is None and 'isArchived' in kwargs:
            is_archived = kwargs['isArchived']

        _setter("job_type", 'AutoML')
        _setter("status", status)
        _setter("task_details", task_details)
        if compute_id is not None:
            _setter("compute_id", compute_id)
        if description is not None:
            _setter("description", description)
        if display_name is not None:
            _setter("display_name", display_name)
        if environment_id is not None:
            _setter("environment_id", environment_id)
        if environment_variables is not None:
            _setter("environment_variables", environment_variables)
        if experiment_name is None:
            experiment_name = 'Default'
        if experiment_name is not None:
            _setter("experiment_name", experiment_name)
        if identity is not None:
            _setter("identity", identity)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            _setter("is_archived", is_archived)
        if outputs is not None:
            _setter("outputs", outputs)
        if properties is not None:
            _setter("properties", properties)
        if resources is not None:
            _setter("resources", resources)
        if schedule is not None:
            _setter("schedule", schedule)
        if services is not None:
            _setter("services", services)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="jobType")
    def job_type(self) -> str:
        """
        Enum to determine the type of job.
        Expected value is 'AutoML'.
        """
        return pulumi.get(self, "job_type")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the job.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="taskDetails")
    def task_details(self) -> Any:
        """
        [Required] This represents scenario which can be one of Tables/NLP/Image
        """
        return pulumi.get(self, "task_details")

    @property
    @pulumi.getter(name="computeId")
    def compute_id(self) -> Optional[str]:
        """
        ARM resource ID of the compute resource.
        """
        return pulumi.get(self, "compute_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Display name of job.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[str]:
        """
        The ARM resource ID of the Environment specification for the job.
        This is optional value to provide, if not provided, AutoML will default this to Production AutoML curated environment version when running the job.
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, str]]:
        """
        Environment variables included in the job.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="experimentName")
    def experiment_name(self) -> Optional[str]:
        """
        The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        """
        return pulumi.get(self, "experiment_name")

    @property
    @pulumi.getter
    def identity(self) -> Optional[Any]:
        """
        Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
        Defaults to AmlToken if null.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def outputs(self) -> Optional[Mapping[str, Any]]:
        """
        Mapping of output data bindings used in the job.
        """
        return pulumi.get(self, "outputs")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.ResourceConfigurationResponse']:
        """
        Compute Resource configuration for the job.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def schedule(self) -> Optional[Any]:
        """
        Schedule definition of job.
        If no schedule is provided, the job is run once and immediately after submission.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter
    def services(self) -> Optional[Mapping[str, 'outputs.JobServiceResponse']]:
        """
        List of JobEndpoints.
        For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AutoNCrossValidationsResponse(dict):
    """
    N-Cross validations determined automatically.
    """
    def __init__(__self__, *,
                 mode: str):
        """
        N-Cross validations determined automatically.
        :param str mode: Determines how N-Cross validations value is determined.
               Expected value is 'Auto'.
        """
        AutoNCrossValidationsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mode is None:
            raise TypeError("Missing 'mode' argument")

        _setter("mode", 'Auto')

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Determines how N-Cross validations value is determined.
        Expected value is 'Auto'.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class AutoSeasonalityResponse(dict):
    def __init__(__self__, *,
                 mode: str):
        """
        :param str mode: Forecasting seasonality mode.
               Expected value is 'Auto'.
        """
        AutoSeasonalityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mode is None:
            raise TypeError("Missing 'mode' argument")

        _setter("mode", 'Auto')

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Forecasting seasonality mode.
        Expected value is 'Auto'.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class AutoTargetLagsResponse(dict):
    def __init__(__self__, *,
                 mode: str):
        """
        :param str mode: Target lags selection modes.
               Expected value is 'Auto'.
        """
        AutoTargetLagsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mode is None:
            raise TypeError("Missing 'mode' argument")

        _setter("mode", 'Auto')

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Target lags selection modes.
        Expected value is 'Auto'.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class AutoTargetRollingWindowSizeResponse(dict):
    """
    Target lags rolling window determined automatically.
    """
    def __init__(__self__, *,
                 mode: str):
        """
        Target lags rolling window determined automatically.
        :param str mode: Target rolling windows size mode.
               Expected value is 'Auto'.
        """
        AutoTargetRollingWindowSizeResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mode is None:
            raise TypeError("Missing 'mode' argument")

        _setter("mode", 'Auto')

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Target rolling windows size mode.
        Expected value is 'Auto'.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class AzureBlobDatastoreResponse(dict):
    """
    Azure Blob datastore configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datastoreType":
            suggest = "datastore_type"
        elif key == "isDefault":
            suggest = "is_default"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "containerName":
            suggest = "container_name"
        elif key == "serviceDataAccessAuthIdentity":
            suggest = "service_data_access_auth_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureBlobDatastoreResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureBlobDatastoreResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureBlobDatastoreResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: Any,
                 datastore_type: str,
                 is_default: bool,
                 account_name: Optional[str] = None,
                 container_name: Optional[str] = None,
                 description: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 protocol: Optional[str] = None,
                 service_data_access_auth_identity: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Azure Blob datastore configuration.
        :param Union['AccountKeyDatastoreCredentialsResponse', 'CertificateDatastoreCredentialsResponse', 'KerberosKeytabCredentialsResponse', 'KerberosPasswordCredentialsResponse', 'NoneDatastoreCredentialsResponse', 'SasDatastoreCredentialsResponse', 'ServicePrincipalDatastoreCredentialsResponse'] credentials: [Required] Account credentials.
        :param str datastore_type: Enum to determine the datastore contents type.
               Expected value is 'AzureBlob'.
        :param bool is_default: Readonly property to indicate if datastore is the workspace default datastore
        :param str account_name: Storage account name.
        :param str container_name: Storage account container name.
        :param str description: The asset description text.
        :param str endpoint: Azure cloud endpoint for the storage account.
        :param Mapping[str, str] properties: The asset property dictionary.
        :param str protocol: Protocol used to communicate with the storage account.
        :param str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        AzureBlobDatastoreResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials=credentials,
            datastore_type=datastore_type,
            is_default=is_default,
            account_name=account_name,
            container_name=container_name,
            description=description,
            endpoint=endpoint,
            properties=properties,
            protocol=protocol,
            service_data_access_auth_identity=service_data_access_auth_identity,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials: Optional[Any] = None,
             datastore_type: Optional[str] = None,
             is_default: Optional[bool] = None,
             account_name: Optional[str] = None,
             container_name: Optional[str] = None,
             description: Optional[str] = None,
             endpoint: Optional[str] = None,
             properties: Optional[Mapping[str, str]] = None,
             protocol: Optional[str] = None,
             service_data_access_auth_identity: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if credentials is None:
            raise TypeError("Missing 'credentials' argument")
        if datastore_type is None and 'datastoreType' in kwargs:
            datastore_type = kwargs['datastoreType']
        if datastore_type is None:
            raise TypeError("Missing 'datastore_type' argument")
        if is_default is None and 'isDefault' in kwargs:
            is_default = kwargs['isDefault']
        if is_default is None:
            raise TypeError("Missing 'is_default' argument")
        if account_name is None and 'accountName' in kwargs:
            account_name = kwargs['accountName']
        if container_name is None and 'containerName' in kwargs:
            container_name = kwargs['containerName']
        if service_data_access_auth_identity is None and 'serviceDataAccessAuthIdentity' in kwargs:
            service_data_access_auth_identity = kwargs['serviceDataAccessAuthIdentity']

        _setter("credentials", credentials)
        _setter("datastore_type", 'AzureBlob')
        _setter("is_default", is_default)
        if account_name is not None:
            _setter("account_name", account_name)
        if container_name is not None:
            _setter("container_name", container_name)
        if description is not None:
            _setter("description", description)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if properties is not None:
            _setter("properties", properties)
        if protocol is not None:
            _setter("protocol", protocol)
        if service_data_access_auth_identity is None:
            service_data_access_auth_identity = 'None'
        if service_data_access_auth_identity is not None:
            _setter("service_data_access_auth_identity", service_data_access_auth_identity)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def credentials(self) -> Any:
        """
        [Required] Account credentials.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="datastoreType")
    def datastore_type(self) -> str:
        """
        Enum to determine the datastore contents type.
        Expected value is 'AzureBlob'.
        """
        return pulumi.get(self, "datastore_type")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Readonly property to indicate if datastore is the workspace default datastore
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[str]:
        """
        Storage account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        """
        Storage account container name.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        Azure cloud endpoint for the storage account.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol used to communicate with the storage account.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AzureDataLakeGen1DatastoreResponse(dict):
    """
    Azure Data Lake Gen1 datastore configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datastoreType":
            suggest = "datastore_type"
        elif key == "isDefault":
            suggest = "is_default"
        elif key == "storeName":
            suggest = "store_name"
        elif key == "serviceDataAccessAuthIdentity":
            suggest = "service_data_access_auth_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureDataLakeGen1DatastoreResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureDataLakeGen1DatastoreResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureDataLakeGen1DatastoreResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: Any,
                 datastore_type: str,
                 is_default: bool,
                 store_name: str,
                 description: Optional[str] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 service_data_access_auth_identity: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Azure Data Lake Gen1 datastore configuration.
        :param Union['AccountKeyDatastoreCredentialsResponse', 'CertificateDatastoreCredentialsResponse', 'KerberosKeytabCredentialsResponse', 'KerberosPasswordCredentialsResponse', 'NoneDatastoreCredentialsResponse', 'SasDatastoreCredentialsResponse', 'ServicePrincipalDatastoreCredentialsResponse'] credentials: [Required] Account credentials.
        :param str datastore_type: Enum to determine the datastore contents type.
               Expected value is 'AzureDataLakeGen1'.
        :param bool is_default: Readonly property to indicate if datastore is the workspace default datastore
        :param str store_name: [Required] Azure Data Lake store name.
        :param str description: The asset description text.
        :param Mapping[str, str] properties: The asset property dictionary.
        :param str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        AzureDataLakeGen1DatastoreResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials=credentials,
            datastore_type=datastore_type,
            is_default=is_default,
            store_name=store_name,
            description=description,
            properties=properties,
            service_data_access_auth_identity=service_data_access_auth_identity,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials: Optional[Any] = None,
             datastore_type: Optional[str] = None,
             is_default: Optional[bool] = None,
             store_name: Optional[str] = None,
             description: Optional[str] = None,
             properties: Optional[Mapping[str, str]] = None,
             service_data_access_auth_identity: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if credentials is None:
            raise TypeError("Missing 'credentials' argument")
        if datastore_type is None and 'datastoreType' in kwargs:
            datastore_type = kwargs['datastoreType']
        if datastore_type is None:
            raise TypeError("Missing 'datastore_type' argument")
        if is_default is None and 'isDefault' in kwargs:
            is_default = kwargs['isDefault']
        if is_default is None:
            raise TypeError("Missing 'is_default' argument")
        if store_name is None and 'storeName' in kwargs:
            store_name = kwargs['storeName']
        if store_name is None:
            raise TypeError("Missing 'store_name' argument")
        if service_data_access_auth_identity is None and 'serviceDataAccessAuthIdentity' in kwargs:
            service_data_access_auth_identity = kwargs['serviceDataAccessAuthIdentity']

        _setter("credentials", credentials)
        _setter("datastore_type", 'AzureDataLakeGen1')
        _setter("is_default", is_default)
        _setter("store_name", store_name)
        if description is not None:
            _setter("description", description)
        if properties is not None:
            _setter("properties", properties)
        if service_data_access_auth_identity is None:
            service_data_access_auth_identity = 'None'
        if service_data_access_auth_identity is not None:
            _setter("service_data_access_auth_identity", service_data_access_auth_identity)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def credentials(self) -> Any:
        """
        [Required] Account credentials.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="datastoreType")
    def datastore_type(self) -> str:
        """
        Enum to determine the datastore contents type.
        Expected value is 'AzureDataLakeGen1'.
        """
        return pulumi.get(self, "datastore_type")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Readonly property to indicate if datastore is the workspace default datastore
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> str:
        """
        [Required] Azure Data Lake store name.
        """
        return pulumi.get(self, "store_name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AzureDataLakeGen2DatastoreResponse(dict):
    """
    Azure Data Lake Gen2 datastore configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountName":
            suggest = "account_name"
        elif key == "datastoreType":
            suggest = "datastore_type"
        elif key == "isDefault":
            suggest = "is_default"
        elif key == "serviceDataAccessAuthIdentity":
            suggest = "service_data_access_auth_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureDataLakeGen2DatastoreResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureDataLakeGen2DatastoreResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureDataLakeGen2DatastoreResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_name: str,
                 credentials: Any,
                 datastore_type: str,
                 filesystem: str,
                 is_default: bool,
                 description: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 protocol: Optional[str] = None,
                 service_data_access_auth_identity: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Azure Data Lake Gen2 datastore configuration.
        :param str account_name: [Required] Storage account name.
        :param Union['AccountKeyDatastoreCredentialsResponse', 'CertificateDatastoreCredentialsResponse', 'KerberosKeytabCredentialsResponse', 'KerberosPasswordCredentialsResponse', 'NoneDatastoreCredentialsResponse', 'SasDatastoreCredentialsResponse', 'ServicePrincipalDatastoreCredentialsResponse'] credentials: [Required] Account credentials.
        :param str datastore_type: Enum to determine the datastore contents type.
               Expected value is 'AzureDataLakeGen2'.
        :param str filesystem: [Required] The name of the Data Lake Gen2 filesystem.
        :param bool is_default: Readonly property to indicate if datastore is the workspace default datastore
        :param str description: The asset description text.
        :param str endpoint: Azure cloud endpoint for the storage account.
        :param Mapping[str, str] properties: The asset property dictionary.
        :param str protocol: Protocol used to communicate with the storage account.
        :param str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        AzureDataLakeGen2DatastoreResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_name=account_name,
            credentials=credentials,
            datastore_type=datastore_type,
            filesystem=filesystem,
            is_default=is_default,
            description=description,
            endpoint=endpoint,
            properties=properties,
            protocol=protocol,
            service_data_access_auth_identity=service_data_access_auth_identity,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_name: Optional[str] = None,
             credentials: Optional[Any] = None,
             datastore_type: Optional[str] = None,
             filesystem: Optional[str] = None,
             is_default: Optional[bool] = None,
             description: Optional[str] = None,
             endpoint: Optional[str] = None,
             properties: Optional[Mapping[str, str]] = None,
             protocol: Optional[str] = None,
             service_data_access_auth_identity: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if account_name is None and 'accountName' in kwargs:
            account_name = kwargs['accountName']
        if account_name is None:
            raise TypeError("Missing 'account_name' argument")
        if credentials is None:
            raise TypeError("Missing 'credentials' argument")
        if datastore_type is None and 'datastoreType' in kwargs:
            datastore_type = kwargs['datastoreType']
        if datastore_type is None:
            raise TypeError("Missing 'datastore_type' argument")
        if filesystem is None:
            raise TypeError("Missing 'filesystem' argument")
        if is_default is None and 'isDefault' in kwargs:
            is_default = kwargs['isDefault']
        if is_default is None:
            raise TypeError("Missing 'is_default' argument")
        if service_data_access_auth_identity is None and 'serviceDataAccessAuthIdentity' in kwargs:
            service_data_access_auth_identity = kwargs['serviceDataAccessAuthIdentity']

        _setter("account_name", account_name)
        _setter("credentials", credentials)
        _setter("datastore_type", 'AzureDataLakeGen2')
        _setter("filesystem", filesystem)
        _setter("is_default", is_default)
        if description is not None:
            _setter("description", description)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if properties is not None:
            _setter("properties", properties)
        if protocol is not None:
            _setter("protocol", protocol)
        if service_data_access_auth_identity is None:
            service_data_access_auth_identity = 'None'
        if service_data_access_auth_identity is not None:
            _setter("service_data_access_auth_identity", service_data_access_auth_identity)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        [Required] Storage account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def credentials(self) -> Any:
        """
        [Required] Account credentials.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="datastoreType")
    def datastore_type(self) -> str:
        """
        Enum to determine the datastore contents type.
        Expected value is 'AzureDataLakeGen2'.
        """
        return pulumi.get(self, "datastore_type")

    @property
    @pulumi.getter
    def filesystem(self) -> str:
        """
        [Required] The name of the Data Lake Gen2 filesystem.
        """
        return pulumi.get(self, "filesystem")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Readonly property to indicate if datastore is the workspace default datastore
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        Azure cloud endpoint for the storage account.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol used to communicate with the storage account.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AzureFileDatastoreResponse(dict):
    """
    Azure File datastore configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountName":
            suggest = "account_name"
        elif key == "datastoreType":
            suggest = "datastore_type"
        elif key == "fileShareName":
            suggest = "file_share_name"
        elif key == "isDefault":
            suggest = "is_default"
        elif key == "serviceDataAccessAuthIdentity":
            suggest = "service_data_access_auth_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureFileDatastoreResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureFileDatastoreResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureFileDatastoreResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_name: str,
                 credentials: Any,
                 datastore_type: str,
                 file_share_name: str,
                 is_default: bool,
                 description: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 protocol: Optional[str] = None,
                 service_data_access_auth_identity: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Azure File datastore configuration.
        :param str account_name: [Required] Storage account name.
        :param Union['AccountKeyDatastoreCredentialsResponse', 'CertificateDatastoreCredentialsResponse', 'KerberosKeytabCredentialsResponse', 'KerberosPasswordCredentialsResponse', 'NoneDatastoreCredentialsResponse', 'SasDatastoreCredentialsResponse', 'ServicePrincipalDatastoreCredentialsResponse'] credentials: [Required] Account credentials.
        :param str datastore_type: Enum to determine the datastore contents type.
               Expected value is 'AzureFile'.
        :param str file_share_name: [Required] The name of the Azure file share that the datastore points to.
        :param bool is_default: Readonly property to indicate if datastore is the workspace default datastore
        :param str description: The asset description text.
        :param str endpoint: Azure cloud endpoint for the storage account.
        :param Mapping[str, str] properties: The asset property dictionary.
        :param str protocol: Protocol used to communicate with the storage account.
        :param str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        AzureFileDatastoreResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_name=account_name,
            credentials=credentials,
            datastore_type=datastore_type,
            file_share_name=file_share_name,
            is_default=is_default,
            description=description,
            endpoint=endpoint,
            properties=properties,
            protocol=protocol,
            service_data_access_auth_identity=service_data_access_auth_identity,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_name: Optional[str] = None,
             credentials: Optional[Any] = None,
             datastore_type: Optional[str] = None,
             file_share_name: Optional[str] = None,
             is_default: Optional[bool] = None,
             description: Optional[str] = None,
             endpoint: Optional[str] = None,
             properties: Optional[Mapping[str, str]] = None,
             protocol: Optional[str] = None,
             service_data_access_auth_identity: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if account_name is None and 'accountName' in kwargs:
            account_name = kwargs['accountName']
        if account_name is None:
            raise TypeError("Missing 'account_name' argument")
        if credentials is None:
            raise TypeError("Missing 'credentials' argument")
        if datastore_type is None and 'datastoreType' in kwargs:
            datastore_type = kwargs['datastoreType']
        if datastore_type is None:
            raise TypeError("Missing 'datastore_type' argument")
        if file_share_name is None and 'fileShareName' in kwargs:
            file_share_name = kwargs['fileShareName']
        if file_share_name is None:
            raise TypeError("Missing 'file_share_name' argument")
        if is_default is None and 'isDefault' in kwargs:
            is_default = kwargs['isDefault']
        if is_default is None:
            raise TypeError("Missing 'is_default' argument")
        if service_data_access_auth_identity is None and 'serviceDataAccessAuthIdentity' in kwargs:
            service_data_access_auth_identity = kwargs['serviceDataAccessAuthIdentity']

        _setter("account_name", account_name)
        _setter("credentials", credentials)
        _setter("datastore_type", 'AzureFile')
        _setter("file_share_name", file_share_name)
        _setter("is_default", is_default)
        if description is not None:
            _setter("description", description)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if properties is not None:
            _setter("properties", properties)
        if protocol is not None:
            _setter("protocol", protocol)
        if service_data_access_auth_identity is None:
            service_data_access_auth_identity = 'None'
        if service_data_access_auth_identity is not None:
            _setter("service_data_access_auth_identity", service_data_access_auth_identity)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        """
        [Required] Storage account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def credentials(self) -> Any:
        """
        [Required] Account credentials.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="datastoreType")
    def datastore_type(self) -> str:
        """
        Enum to determine the datastore contents type.
        Expected value is 'AzureFile'.
        """
        return pulumi.get(self, "datastore_type")

    @property
    @pulumi.getter(name="fileShareName")
    def file_share_name(self) -> str:
        """
        [Required] The name of the Azure file share that the datastore points to.
        """
        return pulumi.get(self, "file_share_name")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Readonly property to indicate if datastore is the workspace default datastore
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        Azure cloud endpoint for the storage account.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol used to communicate with the storage account.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class BanditPolicyResponse(dict):
    """
    Defines an early termination policy based on slack criteria, and a frequency and delay interval for evaluation
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyType":
            suggest = "policy_type"
        elif key == "delayEvaluation":
            suggest = "delay_evaluation"
        elif key == "evaluationInterval":
            suggest = "evaluation_interval"
        elif key == "slackAmount":
            suggest = "slack_amount"
        elif key == "slackFactor":
            suggest = "slack_factor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BanditPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BanditPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BanditPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_type: str,
                 delay_evaluation: Optional[int] = None,
                 evaluation_interval: Optional[int] = None,
                 slack_amount: Optional[float] = None,
                 slack_factor: Optional[float] = None):
        """
        Defines an early termination policy based on slack criteria, and a frequency and delay interval for evaluation
        :param str policy_type: 
               Expected value is 'Bandit'.
        :param int delay_evaluation: Number of intervals by which to delay the first evaluation.
        :param int evaluation_interval: Interval (number of runs) between policy evaluations.
        :param float slack_amount: Absolute distance allowed from the best performing run.
        :param float slack_factor: Ratio of the allowed distance from the best performing run.
        """
        BanditPolicyResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy_type=policy_type,
            delay_evaluation=delay_evaluation,
            evaluation_interval=evaluation_interval,
            slack_amount=slack_amount,
            slack_factor=slack_factor,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy_type: Optional[str] = None,
             delay_evaluation: Optional[int] = None,
             evaluation_interval: Optional[int] = None,
             slack_amount: Optional[float] = None,
             slack_factor: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if policy_type is None and 'policyType' in kwargs:
            policy_type = kwargs['policyType']
        if policy_type is None:
            raise TypeError("Missing 'policy_type' argument")
        if delay_evaluation is None and 'delayEvaluation' in kwargs:
            delay_evaluation = kwargs['delayEvaluation']
        if evaluation_interval is None and 'evaluationInterval' in kwargs:
            evaluation_interval = kwargs['evaluationInterval']
        if slack_amount is None and 'slackAmount' in kwargs:
            slack_amount = kwargs['slackAmount']
        if slack_factor is None and 'slackFactor' in kwargs:
            slack_factor = kwargs['slackFactor']

        _setter("policy_type", 'Bandit')
        if delay_evaluation is None:
            delay_evaluation = 0
        if delay_evaluation is not None:
            _setter("delay_evaluation", delay_evaluation)
        if evaluation_interval is None:
            evaluation_interval = 0
        if evaluation_interval is not None:
            _setter("evaluation_interval", evaluation_interval)
        if slack_amount is None:
            slack_amount = 0
        if slack_amount is not None:
            _setter("slack_amount", slack_amount)
        if slack_factor is None:
            slack_factor = 0
        if slack_factor is not None:
            _setter("slack_factor", slack_factor)

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> str:
        """

        Expected value is 'Bandit'.
        """
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="delayEvaluation")
    def delay_evaluation(self) -> Optional[int]:
        """
        Number of intervals by which to delay the first evaluation.
        """
        return pulumi.get(self, "delay_evaluation")

    @property
    @pulumi.getter(name="evaluationInterval")
    def evaluation_interval(self) -> Optional[int]:
        """
        Interval (number of runs) between policy evaluations.
        """
        return pulumi.get(self, "evaluation_interval")

    @property
    @pulumi.getter(name="slackAmount")
    def slack_amount(self) -> Optional[float]:
        """
        Absolute distance allowed from the best performing run.
        """
        return pulumi.get(self, "slack_amount")

    @property
    @pulumi.getter(name="slackFactor")
    def slack_factor(self) -> Optional[float]:
        """
        Ratio of the allowed distance from the best performing run.
        """
        return pulumi.get(self, "slack_factor")


@pulumi.output_type
class BatchDeploymentResponse(dict):
    """
    Batch inference settings per deployment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "codeConfiguration":
            suggest = "code_configuration"
        elif key == "environmentId":
            suggest = "environment_id"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "errorThreshold":
            suggest = "error_threshold"
        elif key == "loggingLevel":
            suggest = "logging_level"
        elif key == "maxConcurrencyPerInstance":
            suggest = "max_concurrency_per_instance"
        elif key == "miniBatchSize":
            suggest = "mini_batch_size"
        elif key == "outputAction":
            suggest = "output_action"
        elif key == "outputFileName":
            suggest = "output_file_name"
        elif key == "retrySettings":
            suggest = "retry_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BatchDeploymentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BatchDeploymentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BatchDeploymentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 code_configuration: Optional['outputs.CodeConfigurationResponse'] = None,
                 compute: Optional[str] = None,
                 description: Optional[str] = None,
                 environment_id: Optional[str] = None,
                 environment_variables: Optional[Mapping[str, str]] = None,
                 error_threshold: Optional[int] = None,
                 logging_level: Optional[str] = None,
                 max_concurrency_per_instance: Optional[int] = None,
                 mini_batch_size: Optional[float] = None,
                 model: Optional[Any] = None,
                 output_action: Optional[str] = None,
                 output_file_name: Optional[str] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 resources: Optional['outputs.ResourceConfigurationResponse'] = None,
                 retry_settings: Optional['outputs.BatchRetrySettingsResponse'] = None):
        """
        Batch inference settings per deployment.
        :param str provisioning_state: Provisioning state for the endpoint deployment.
        :param 'CodeConfigurationResponse' code_configuration: Code configuration for the endpoint deployment.
        :param str compute: Compute target for batch inference operation.
        :param str description: Description of the endpoint deployment.
        :param str environment_id: ARM resource ID of the environment specification for the endpoint deployment.
        :param Mapping[str, str] environment_variables: Environment variables configuration for the deployment.
        :param int error_threshold: Error threshold, if the error count for the entire input goes above this value,
               the batch inference will be aborted. Range is [-1, int.MaxValue].
               For FileDataset, this value is the count of file failures.
               For TabularDataset, this value is the count of record failures.
               If set to -1 (the lower bound), all failures during batch inference will be ignored.
        :param str logging_level: Logging level for batch inference operation.
        :param int max_concurrency_per_instance: Indicates maximum number of parallelism per instance.
        :param float mini_batch_size: Size of the mini-batch passed to each batch invocation.
               For FileDataset, this is the number of files per mini-batch.
               For TabularDataset, this is the size of the records in bytes, per mini-batch.
        :param Union['DataPathAssetReferenceResponse', 'IdAssetReferenceResponse', 'OutputPathAssetReferenceResponse'] model: Reference to the model asset for the endpoint deployment.
        :param str output_action: Indicates how the output will be organized.
        :param str output_file_name: Customized output file name for append_row output action.
        :param Mapping[str, str] properties: Property dictionary. Properties can be added, but not removed or altered.
        :param 'ResourceConfigurationResponse' resources: Indicates compute configuration for the job.
               If not provided, will default to the defaults defined in ResourceConfiguration.
        :param 'BatchRetrySettingsResponse' retry_settings: Retry Settings for the batch inference operation.
               If not provided, will default to the defaults defined in BatchRetrySettings.
        """
        BatchDeploymentResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            provisioning_state=provisioning_state,
            code_configuration=code_configuration,
            compute=compute,
            description=description,
            environment_id=environment_id,
            environment_variables=environment_variables,
            error_threshold=error_threshold,
            logging_level=logging_level,
            max_concurrency_per_instance=max_concurrency_per_instance,
            mini_batch_size=mini_batch_size,
            model=model,
            output_action=output_action,
            output_file_name=output_file_name,
            properties=properties,
            resources=resources,
            retry_settings=retry_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             provisioning_state: Optional[str] = None,
             code_configuration: Optional['outputs.CodeConfigurationResponse'] = None,
             compute: Optional[str] = None,
             description: Optional[str] = None,
             environment_id: Optional[str] = None,
             environment_variables: Optional[Mapping[str, str]] = None,
             error_threshold: Optional[int] = None,
             logging_level: Optional[str] = None,
             max_concurrency_per_instance: Optional[int] = None,
             mini_batch_size: Optional[float] = None,
             model: Optional[Any] = None,
             output_action: Optional[str] = None,
             output_file_name: Optional[str] = None,
             properties: Optional[Mapping[str, str]] = None,
             resources: Optional['outputs.ResourceConfigurationResponse'] = None,
             retry_settings: Optional['outputs.BatchRetrySettingsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if code_configuration is None and 'codeConfiguration' in kwargs:
            code_configuration = kwargs['codeConfiguration']
        if environment_id is None and 'environmentId' in kwargs:
            environment_id = kwargs['environmentId']
        if environment_variables is None and 'environmentVariables' in kwargs:
            environment_variables = kwargs['environmentVariables']
        if error_threshold is None and 'errorThreshold' in kwargs:
            error_threshold = kwargs['errorThreshold']
        if logging_level is None and 'loggingLevel' in kwargs:
            logging_level = kwargs['loggingLevel']
        if max_concurrency_per_instance is None and 'maxConcurrencyPerInstance' in kwargs:
            max_concurrency_per_instance = kwargs['maxConcurrencyPerInstance']
        if mini_batch_size is None and 'miniBatchSize' in kwargs:
            mini_batch_size = kwargs['miniBatchSize']
        if output_action is None and 'outputAction' in kwargs:
            output_action = kwargs['outputAction']
        if output_file_name is None and 'outputFileName' in kwargs:
            output_file_name = kwargs['outputFileName']
        if retry_settings is None and 'retrySettings' in kwargs:
            retry_settings = kwargs['retrySettings']

        _setter("provisioning_state", provisioning_state)
        if code_configuration is not None:
            _setter("code_configuration", code_configuration)
        if compute is not None:
            _setter("compute", compute)
        if description is not None:
            _setter("description", description)
        if environment_id is not None:
            _setter("environment_id", environment_id)
        if environment_variables is not None:
            _setter("environment_variables", environment_variables)
        if error_threshold is None:
            error_threshold = -1
        if error_threshold is not None:
            _setter("error_threshold", error_threshold)
        if logging_level is None:
            logging_level = 'Info'
        if logging_level is not None:
            _setter("logging_level", logging_level)
        if max_concurrency_per_instance is None:
            max_concurrency_per_instance = 1
        if max_concurrency_per_instance is not None:
            _setter("max_concurrency_per_instance", max_concurrency_per_instance)
        if mini_batch_size is None:
            mini_batch_size = 10
        if mini_batch_size is not None:
            _setter("mini_batch_size", mini_batch_size)
        if model is not None:
            _setter("model", model)
        if output_action is None:
            output_action = 'AppendRow'
        if output_action is not None:
            _setter("output_action", output_action)
        if output_file_name is None:
            output_file_name = 'predictions.csv'
        if output_file_name is not None:
            _setter("output_file_name", output_file_name)
        if properties is not None:
            _setter("properties", properties)
        if resources is not None:
            _setter("resources", resources)
        if retry_settings is not None:
            _setter("retry_settings", retry_settings)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning state for the endpoint deployment.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="codeConfiguration")
    def code_configuration(self) -> Optional['outputs.CodeConfigurationResponse']:
        """
        Code configuration for the endpoint deployment.
        """
        return pulumi.get(self, "code_configuration")

    @property
    @pulumi.getter
    def compute(self) -> Optional[str]:
        """
        Compute target for batch inference operation.
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the endpoint deployment.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[str]:
        """
        ARM resource ID of the environment specification for the endpoint deployment.
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, str]]:
        """
        Environment variables configuration for the deployment.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="errorThreshold")
    def error_threshold(self) -> Optional[int]:
        """
        Error threshold, if the error count for the entire input goes above this value,
        the batch inference will be aborted. Range is [-1, int.MaxValue].
        For FileDataset, this value is the count of file failures.
        For TabularDataset, this value is the count of record failures.
        If set to -1 (the lower bound), all failures during batch inference will be ignored.
        """
        return pulumi.get(self, "error_threshold")

    @property
    @pulumi.getter(name="loggingLevel")
    def logging_level(self) -> Optional[str]:
        """
        Logging level for batch inference operation.
        """
        return pulumi.get(self, "logging_level")

    @property
    @pulumi.getter(name="maxConcurrencyPerInstance")
    def max_concurrency_per_instance(self) -> Optional[int]:
        """
        Indicates maximum number of parallelism per instance.
        """
        return pulumi.get(self, "max_concurrency_per_instance")

    @property
    @pulumi.getter(name="miniBatchSize")
    def mini_batch_size(self) -> Optional[float]:
        """
        Size of the mini-batch passed to each batch invocation.
        For FileDataset, this is the number of files per mini-batch.
        For TabularDataset, this is the size of the records in bytes, per mini-batch.
        """
        return pulumi.get(self, "mini_batch_size")

    @property
    @pulumi.getter
    def model(self) -> Optional[Any]:
        """
        Reference to the model asset for the endpoint deployment.
        """
        return pulumi.get(self, "model")

    @property
    @pulumi.getter(name="outputAction")
    def output_action(self) -> Optional[str]:
        """
        Indicates how the output will be organized.
        """
        return pulumi.get(self, "output_action")

    @property
    @pulumi.getter(name="outputFileName")
    def output_file_name(self) -> Optional[str]:
        """
        Customized output file name for append_row output action.
        """
        return pulumi.get(self, "output_file_name")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.ResourceConfigurationResponse']:
        """
        Indicates compute configuration for the job.
        If not provided, will default to the defaults defined in ResourceConfiguration.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="retrySettings")
    def retry_settings(self) -> Optional['outputs.BatchRetrySettingsResponse']:
        """
        Retry Settings for the batch inference operation.
        If not provided, will default to the defaults defined in BatchRetrySettings.
        """
        return pulumi.get(self, "retry_settings")


@pulumi.output_type
class BatchEndpointDefaultsResponse(dict):
    """
    Batch endpoint default values
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentName":
            suggest = "deployment_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BatchEndpointDefaultsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BatchEndpointDefaultsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BatchEndpointDefaultsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment_name: Optional[str] = None):
        """
        Batch endpoint default values
        :param str deployment_name: Name of the deployment that will be default for the endpoint.
               This deployment will end up getting 100% traffic when the endpoint scoring URL is invoked.
        """
        BatchEndpointDefaultsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            deployment_name=deployment_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             deployment_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if deployment_name is None and 'deploymentName' in kwargs:
            deployment_name = kwargs['deploymentName']

        if deployment_name is not None:
            _setter("deployment_name", deployment_name)

    @property
    @pulumi.getter(name="deploymentName")
    def deployment_name(self) -> Optional[str]:
        """
        Name of the deployment that will be default for the endpoint.
        This deployment will end up getting 100% traffic when the endpoint scoring URL is invoked.
        """
        return pulumi.get(self, "deployment_name")


@pulumi.output_type
class BatchEndpointResponse(dict):
    """
    Batch endpoint configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authMode":
            suggest = "auth_mode"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "scoringUri":
            suggest = "scoring_uri"
        elif key == "swaggerUri":
            suggest = "swagger_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BatchEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BatchEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BatchEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_mode: str,
                 provisioning_state: str,
                 scoring_uri: str,
                 swagger_uri: str,
                 defaults: Optional['outputs.BatchEndpointDefaultsResponse'] = None,
                 description: Optional[str] = None,
                 properties: Optional[Mapping[str, str]] = None):
        """
        Batch endpoint configuration.
        :param str auth_mode: [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
        :param str provisioning_state: Provisioning state for the endpoint.
        :param str scoring_uri: Endpoint URI.
        :param str swagger_uri: Endpoint Swagger URI.
        :param 'BatchEndpointDefaultsResponse' defaults: Default values for Batch Endpoint
        :param str description: Description of the inference endpoint.
        :param Mapping[str, str] properties: Property dictionary. Properties can be added, but not removed or altered.
        """
        BatchEndpointResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_mode=auth_mode,
            provisioning_state=provisioning_state,
            scoring_uri=scoring_uri,
            swagger_uri=swagger_uri,
            defaults=defaults,
            description=description,
            properties=properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_mode: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             scoring_uri: Optional[str] = None,
             swagger_uri: Optional[str] = None,
             defaults: Optional['outputs.BatchEndpointDefaultsResponse'] = None,
             description: Optional[str] = None,
             properties: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auth_mode is None and 'authMode' in kwargs:
            auth_mode = kwargs['authMode']
        if auth_mode is None:
            raise TypeError("Missing 'auth_mode' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if scoring_uri is None and 'scoringUri' in kwargs:
            scoring_uri = kwargs['scoringUri']
        if scoring_uri is None:
            raise TypeError("Missing 'scoring_uri' argument")
        if swagger_uri is None and 'swaggerUri' in kwargs:
            swagger_uri = kwargs['swaggerUri']
        if swagger_uri is None:
            raise TypeError("Missing 'swagger_uri' argument")

        _setter("auth_mode", auth_mode)
        _setter("provisioning_state", provisioning_state)
        _setter("scoring_uri", scoring_uri)
        _setter("swagger_uri", swagger_uri)
        if defaults is not None:
            _setter("defaults", defaults)
        if description is not None:
            _setter("description", description)
        if properties is not None:
            _setter("properties", properties)

    @property
    @pulumi.getter(name="authMode")
    def auth_mode(self) -> str:
        """
        [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
        """
        return pulumi.get(self, "auth_mode")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning state for the endpoint.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="scoringUri")
    def scoring_uri(self) -> str:
        """
        Endpoint URI.
        """
        return pulumi.get(self, "scoring_uri")

    @property
    @pulumi.getter(name="swaggerUri")
    def swagger_uri(self) -> str:
        """
        Endpoint Swagger URI.
        """
        return pulumi.get(self, "swagger_uri")

    @property
    @pulumi.getter
    def defaults(self) -> Optional['outputs.BatchEndpointDefaultsResponse']:
        """
        Default values for Batch Endpoint
        """
        return pulumi.get(self, "defaults")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the inference endpoint.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class BatchRetrySettingsResponse(dict):
    """
    Retry settings for a batch inference operation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxRetries":
            suggest = "max_retries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BatchRetrySettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BatchRetrySettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BatchRetrySettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_retries: Optional[int] = None,
                 timeout: Optional[str] = None):
        """
        Retry settings for a batch inference operation.
        :param int max_retries: Maximum retry count for a mini-batch
        :param str timeout: Invocation timeout for a mini-batch, in ISO 8601 format.
        """
        BatchRetrySettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_retries=max_retries,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_retries: Optional[int] = None,
             timeout: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_retries is None and 'maxRetries' in kwargs:
            max_retries = kwargs['maxRetries']

        if max_retries is None:
            max_retries = 3
        if max_retries is not None:
            _setter("max_retries", max_retries)
        if timeout is None:
            timeout = 'PT30S'
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[int]:
        """
        Maximum retry count for a mini-batch
        """
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        Invocation timeout for a mini-batch, in ISO 8601 format.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class BayesianSamplingAlgorithmResponse(dict):
    """
    Defines a Sampling Algorithm that generates values based on previous values
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "samplingAlgorithmType":
            suggest = "sampling_algorithm_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BayesianSamplingAlgorithmResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BayesianSamplingAlgorithmResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BayesianSamplingAlgorithmResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sampling_algorithm_type: str):
        """
        Defines a Sampling Algorithm that generates values based on previous values
        :param str sampling_algorithm_type: 
               Expected value is 'Bayesian'.
        """
        BayesianSamplingAlgorithmResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sampling_algorithm_type=sampling_algorithm_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sampling_algorithm_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if sampling_algorithm_type is None and 'samplingAlgorithmType' in kwargs:
            sampling_algorithm_type = kwargs['samplingAlgorithmType']
        if sampling_algorithm_type is None:
            raise TypeError("Missing 'sampling_algorithm_type' argument")

        _setter("sampling_algorithm_type", 'Bayesian')

    @property
    @pulumi.getter(name="samplingAlgorithmType")
    def sampling_algorithm_type(self) -> str:
        """

        Expected value is 'Bayesian'.
        """
        return pulumi.get(self, "sampling_algorithm_type")


@pulumi.output_type
class BuildContextResponse(dict):
    """
    Configuration settings for Docker build context
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contextUri":
            suggest = "context_uri"
        elif key == "dockerfilePath":
            suggest = "dockerfile_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildContextResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildContextResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildContextResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 context_uri: str,
                 dockerfile_path: Optional[str] = None):
        """
        Configuration settings for Docker build context
        :param str context_uri: [Required] URI of the Docker build context used to build the image. Supports blob URIs on environment creation and may return blob or Git URIs.
               <seealso href="https://docs.docker.com/engine/reference/commandline/build/#extended-description" />
        :param str dockerfile_path: Path to the Dockerfile in the build context.
               <seealso href="https://docs.docker.com/engine/reference/builder/" />
        """
        BuildContextResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            context_uri=context_uri,
            dockerfile_path=dockerfile_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             context_uri: Optional[str] = None,
             dockerfile_path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if context_uri is None and 'contextUri' in kwargs:
            context_uri = kwargs['contextUri']
        if context_uri is None:
            raise TypeError("Missing 'context_uri' argument")
        if dockerfile_path is None and 'dockerfilePath' in kwargs:
            dockerfile_path = kwargs['dockerfilePath']

        _setter("context_uri", context_uri)
        if dockerfile_path is None:
            dockerfile_path = 'Dockerfile'
        if dockerfile_path is not None:
            _setter("dockerfile_path", dockerfile_path)

    @property
    @pulumi.getter(name="contextUri")
    def context_uri(self) -> str:
        """
        [Required] URI of the Docker build context used to build the image. Supports blob URIs on environment creation and may return blob or Git URIs.
        <seealso href="https://docs.docker.com/engine/reference/commandline/build/#extended-description" />
        """
        return pulumi.get(self, "context_uri")

    @property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[str]:
        """
        Path to the Dockerfile in the build context.
        <seealso href="https://docs.docker.com/engine/reference/builder/" />
        """
        return pulumi.get(self, "dockerfile_path")


@pulumi.output_type
class CertificateDatastoreCredentialsResponse(dict):
    """
    Certificate datastore credentials configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "credentialsType":
            suggest = "credentials_type"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "authorityUrl":
            suggest = "authority_url"
        elif key == "resourceUrl":
            suggest = "resource_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificateDatastoreCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificateDatastoreCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificateDatastoreCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 credentials_type: str,
                 tenant_id: str,
                 thumbprint: str,
                 authority_url: Optional[str] = None,
                 resource_url: Optional[str] = None):
        """
        Certificate datastore credentials configuration.
        :param str client_id: [Required] Service principal client ID.
        :param str credentials_type: Enum to determine the datastore credentials type.
               Expected value is 'Certificate'.
        :param str tenant_id: [Required] ID of the tenant to which the service principal belongs.
        :param str thumbprint: [Required] Thumbprint of the certificate used for authentication.
        :param str authority_url: Authority URL used for authentication.
        :param str resource_url: Resource the service principal has access to.
        """
        CertificateDatastoreCredentialsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            credentials_type=credentials_type,
            tenant_id=tenant_id,
            thumbprint=thumbprint,
            authority_url=authority_url,
            resource_url=resource_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[str] = None,
             credentials_type: Optional[str] = None,
             tenant_id: Optional[str] = None,
             thumbprint: Optional[str] = None,
             authority_url: Optional[str] = None,
             resource_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_id is None:
            raise TypeError("Missing 'client_id' argument")
        if credentials_type is None and 'credentialsType' in kwargs:
            credentials_type = kwargs['credentialsType']
        if credentials_type is None:
            raise TypeError("Missing 'credentials_type' argument")
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_id is None:
            raise TypeError("Missing 'tenant_id' argument")
        if thumbprint is None:
            raise TypeError("Missing 'thumbprint' argument")
        if authority_url is None and 'authorityUrl' in kwargs:
            authority_url = kwargs['authorityUrl']
        if resource_url is None and 'resourceUrl' in kwargs:
            resource_url = kwargs['resourceUrl']

        _setter("client_id", client_id)
        _setter("credentials_type", 'Certificate')
        _setter("tenant_id", tenant_id)
        _setter("thumbprint", thumbprint)
        if authority_url is not None:
            _setter("authority_url", authority_url)
        if resource_url is not None:
            _setter("resource_url", resource_url)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        [Required] Service principal client ID.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="credentialsType")
    def credentials_type(self) -> str:
        """
        Enum to determine the datastore credentials type.
        Expected value is 'Certificate'.
        """
        return pulumi.get(self, "credentials_type")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        [Required] ID of the tenant to which the service principal belongs.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def thumbprint(self) -> str:
        """
        [Required] Thumbprint of the certificate used for authentication.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter(name="authorityUrl")
    def authority_url(self) -> Optional[str]:
        """
        Authority URL used for authentication.
        """
        return pulumi.get(self, "authority_url")

    @property
    @pulumi.getter(name="resourceUrl")
    def resource_url(self) -> Optional[str]:
        """
        Resource the service principal has access to.
        """
        return pulumi.get(self, "resource_url")


@pulumi.output_type
class ClassificationResponse(dict):
    """
    Classification task in AutoML Table vertical.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "allowedModels":
            suggest = "allowed_models"
        elif key == "blockedModels":
            suggest = "blocked_models"
        elif key == "dataSettings":
            suggest = "data_settings"
        elif key == "featurizationSettings":
            suggest = "featurization_settings"
        elif key == "limitSettings":
            suggest = "limit_settings"
        elif key == "logVerbosity":
            suggest = "log_verbosity"
        elif key == "primaryMetric":
            suggest = "primary_metric"
        elif key == "trainingSettings":
            suggest = "training_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClassificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClassificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClassificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 task_type: str,
                 allowed_models: Optional[Sequence[str]] = None,
                 blocked_models: Optional[Sequence[str]] = None,
                 data_settings: Optional['outputs.TableVerticalDataSettingsResponse'] = None,
                 featurization_settings: Optional['outputs.TableVerticalFeaturizationSettingsResponse'] = None,
                 limit_settings: Optional['outputs.TableVerticalLimitSettingsResponse'] = None,
                 log_verbosity: Optional[str] = None,
                 primary_metric: Optional[str] = None,
                 training_settings: Optional['outputs.TrainingSettingsResponse'] = None):
        """
        Classification task in AutoML Table vertical.
        :param str task_type: AutoMLJob Task type.
               Expected value is 'Classification'.
        :param Sequence[str] allowed_models: Allowed models for classification task.
        :param Sequence[str] blocked_models: Blocked models for classification task.
        :param 'TableVerticalDataSettingsResponse' data_settings: Data inputs for AutoMLJob.
        :param 'TableVerticalFeaturizationSettingsResponse' featurization_settings: Featurization inputs needed for AutoML job.
        :param 'TableVerticalLimitSettingsResponse' limit_settings: Execution constraints for AutoMLJob.
        :param str log_verbosity: Log verbosity for the job.
        :param str primary_metric: Primary metric for the task.
        :param 'TrainingSettingsResponse' training_settings: Inputs for training phase for an AutoML Job.
        """
        ClassificationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            task_type=task_type,
            allowed_models=allowed_models,
            blocked_models=blocked_models,
            data_settings=data_settings,
            featurization_settings=featurization_settings,
            limit_settings=limit_settings,
            log_verbosity=log_verbosity,
            primary_metric=primary_metric,
            training_settings=training_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             task_type: Optional[str] = None,
             allowed_models: Optional[Sequence[str]] = None,
             blocked_models: Optional[Sequence[str]] = None,
             data_settings: Optional['outputs.TableVerticalDataSettingsResponse'] = None,
             featurization_settings: Optional['outputs.TableVerticalFeaturizationSettingsResponse'] = None,
             limit_settings: Optional['outputs.TableVerticalLimitSettingsResponse'] = None,
             log_verbosity: Optional[str] = None,
             primary_metric: Optional[str] = None,
             training_settings: Optional['outputs.TrainingSettingsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if allowed_models is None and 'allowedModels' in kwargs:
            allowed_models = kwargs['allowedModels']
        if blocked_models is None and 'blockedModels' in kwargs:
            blocked_models = kwargs['blockedModels']
        if data_settings is None and 'dataSettings' in kwargs:
            data_settings = kwargs['dataSettings']
        if featurization_settings is None and 'featurizationSettings' in kwargs:
            featurization_settings = kwargs['featurizationSettings']
        if limit_settings is None and 'limitSettings' in kwargs:
            limit_settings = kwargs['limitSettings']
        if log_verbosity is None and 'logVerbosity' in kwargs:
            log_verbosity = kwargs['logVerbosity']
        if primary_metric is None and 'primaryMetric' in kwargs:
            primary_metric = kwargs['primaryMetric']
        if training_settings is None and 'trainingSettings' in kwargs:
            training_settings = kwargs['trainingSettings']

        _setter("task_type", 'Classification')
        if allowed_models is not None:
            _setter("allowed_models", allowed_models)
        if blocked_models is not None:
            _setter("blocked_models", blocked_models)
        if data_settings is not None:
            _setter("data_settings", data_settings)
        if featurization_settings is not None:
            _setter("featurization_settings", featurization_settings)
        if limit_settings is not None:
            _setter("limit_settings", limit_settings)
        if log_verbosity is None:
            log_verbosity = 'Info'
        if log_verbosity is not None:
            _setter("log_verbosity", log_verbosity)
        if primary_metric is None:
            primary_metric = 'AUCWeighted'
        if primary_metric is not None:
            _setter("primary_metric", primary_metric)
        if training_settings is not None:
            _setter("training_settings", training_settings)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        AutoMLJob Task type.
        Expected value is 'Classification'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="allowedModels")
    def allowed_models(self) -> Optional[Sequence[str]]:
        """
        Allowed models for classification task.
        """
        return pulumi.get(self, "allowed_models")

    @property
    @pulumi.getter(name="blockedModels")
    def blocked_models(self) -> Optional[Sequence[str]]:
        """
        Blocked models for classification task.
        """
        return pulumi.get(self, "blocked_models")

    @property
    @pulumi.getter(name="dataSettings")
    def data_settings(self) -> Optional['outputs.TableVerticalDataSettingsResponse']:
        """
        Data inputs for AutoMLJob.
        """
        return pulumi.get(self, "data_settings")

    @property
    @pulumi.getter(name="featurizationSettings")
    def featurization_settings(self) -> Optional['outputs.TableVerticalFeaturizationSettingsResponse']:
        """
        Featurization inputs needed for AutoML job.
        """
        return pulumi.get(self, "featurization_settings")

    @property
    @pulumi.getter(name="limitSettings")
    def limit_settings(self) -> Optional['outputs.TableVerticalLimitSettingsResponse']:
        """
        Execution constraints for AutoMLJob.
        """
        return pulumi.get(self, "limit_settings")

    @property
    @pulumi.getter(name="logVerbosity")
    def log_verbosity(self) -> Optional[str]:
        """
        Log verbosity for the job.
        """
        return pulumi.get(self, "log_verbosity")

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> Optional[str]:
        """
        Primary metric for the task.
        """
        return pulumi.get(self, "primary_metric")

    @property
    @pulumi.getter(name="trainingSettings")
    def training_settings(self) -> Optional['outputs.TrainingSettingsResponse']:
        """
        Inputs for training phase for an AutoML Job.
        """
        return pulumi.get(self, "training_settings")


@pulumi.output_type
class CodeConfigurationResponse(dict):
    """
    Configuration for a scoring code asset.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scoringScript":
            suggest = "scoring_script"
        elif key == "codeId":
            suggest = "code_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scoring_script: str,
                 code_id: Optional[str] = None):
        """
        Configuration for a scoring code asset.
        :param str scoring_script: [Required] The script to execute on startup. eg. "score.py"
        :param str code_id: ARM resource ID of the code asset.
        """
        CodeConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scoring_script=scoring_script,
            code_id=code_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scoring_script: Optional[str] = None,
             code_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if scoring_script is None and 'scoringScript' in kwargs:
            scoring_script = kwargs['scoringScript']
        if scoring_script is None:
            raise TypeError("Missing 'scoring_script' argument")
        if code_id is None and 'codeId' in kwargs:
            code_id = kwargs['codeId']

        _setter("scoring_script", scoring_script)
        if code_id is not None:
            _setter("code_id", code_id)

    @property
    @pulumi.getter(name="scoringScript")
    def scoring_script(self) -> str:
        """
        [Required] The script to execute on startup. eg. "score.py"
        """
        return pulumi.get(self, "scoring_script")

    @property
    @pulumi.getter(name="codeId")
    def code_id(self) -> Optional[str]:
        """
        ARM resource ID of the code asset.
        """
        return pulumi.get(self, "code_id")


@pulumi.output_type
class CodeContainerResponse(dict):
    """
    Container for code asset versions.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latestVersion":
            suggest = "latest_version"
        elif key == "nextVersion":
            suggest = "next_version"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeContainerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeContainerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeContainerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latest_version: str,
                 next_version: str,
                 description: Optional[str] = None,
                 is_archived: Optional[bool] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Container for code asset versions.
        :param str latest_version: The latest version inside this container.
        :param str next_version: The next auto incremental version
        :param str description: The asset description text.
        :param bool is_archived: Is the asset archived?
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        CodeContainerResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            latest_version=latest_version,
            next_version=next_version,
            description=description,
            is_archived=is_archived,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             latest_version: Optional[str] = None,
             next_version: Optional[str] = None,
             description: Optional[str] = None,
             is_archived: Optional[bool] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if latest_version is None and 'latestVersion' in kwargs:
            latest_version = kwargs['latestVersion']
        if latest_version is None:
            raise TypeError("Missing 'latest_version' argument")
        if next_version is None and 'nextVersion' in kwargs:
            next_version = kwargs['nextVersion']
        if next_version is None:
            raise TypeError("Missing 'next_version' argument")
        if is_archived is None and 'isArchived' in kwargs:
            is_archived = kwargs['isArchived']

        _setter("latest_version", latest_version)
        _setter("next_version", next_version)
        if description is not None:
            _setter("description", description)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            _setter("is_archived", is_archived)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> str:
        """
        The latest version inside this container.
        """
        return pulumi.get(self, "latest_version")

    @property
    @pulumi.getter(name="nextVersion")
    def next_version(self) -> str:
        """
        The next auto incremental version
        """
        return pulumi.get(self, "next_version")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CodeVersionResponse(dict):
    """
    Code asset version details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codeUri":
            suggest = "code_uri"
        elif key == "isAnonymous":
            suggest = "is_anonymous"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code_uri: Optional[str] = None,
                 description: Optional[str] = None,
                 is_anonymous: Optional[bool] = None,
                 is_archived: Optional[bool] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Code asset version details.
        :param str code_uri: Uri where code is located
        :param str description: The asset description text.
        :param bool is_anonymous: If the name version are system generated (anonymous registration).
        :param bool is_archived: Is the asset archived?
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        CodeVersionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code_uri=code_uri,
            description=description,
            is_anonymous=is_anonymous,
            is_archived=is_archived,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code_uri: Optional[str] = None,
             description: Optional[str] = None,
             is_anonymous: Optional[bool] = None,
             is_archived: Optional[bool] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if code_uri is None and 'codeUri' in kwargs:
            code_uri = kwargs['codeUri']
        if is_anonymous is None and 'isAnonymous' in kwargs:
            is_anonymous = kwargs['isAnonymous']
        if is_archived is None and 'isArchived' in kwargs:
            is_archived = kwargs['isArchived']

        if code_uri is not None:
            _setter("code_uri", code_uri)
        if description is not None:
            _setter("description", description)
        if is_anonymous is None:
            is_anonymous = False
        if is_anonymous is not None:
            _setter("is_anonymous", is_anonymous)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            _setter("is_archived", is_archived)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="codeUri")
    def code_uri(self) -> Optional[str]:
        """
        Uri where code is located
        """
        return pulumi.get(self, "code_uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[bool]:
        """
        If the name version are system generated (anonymous registration).
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ColumnTransformerResponse(dict):
    """
    Column transformer parameters.
    """
    def __init__(__self__, *,
                 fields: Optional[Sequence[str]] = None,
                 parameters: Optional[Any] = None):
        """
        Column transformer parameters.
        :param Sequence[str] fields: Fields to apply transformer logic on.
        :param Any parameters: Different properties to be passed to transformer.
               Input expected is dictionary of key,value pairs in JSON format.
        """
        ColumnTransformerResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fields=fields,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fields: Optional[Sequence[str]] = None,
             parameters: Optional[Any] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if fields is not None:
            _setter("fields", fields)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def fields(self) -> Optional[Sequence[str]]:
        """
        Fields to apply transformer logic on.
        """
        return pulumi.get(self, "fields")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Any]:
        """
        Different properties to be passed to transformer.
        Input expected is dictionary of key,value pairs in JSON format.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class CommandJobLimitsResponse(dict):
    """
    Command Job limit class.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobLimitsType":
            suggest = "job_limits_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CommandJobLimitsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CommandJobLimitsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CommandJobLimitsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_limits_type: str,
                 timeout: Optional[str] = None):
        """
        Command Job limit class.
        :param str job_limits_type: 
               Expected value is 'Command'.
        :param str timeout: The max run duration in ISO 8601 format, after which the job will be cancelled. Only supports duration with precision as low as Seconds.
        """
        CommandJobLimitsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_limits_type=job_limits_type,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_limits_type: Optional[str] = None,
             timeout: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if job_limits_type is None and 'jobLimitsType' in kwargs:
            job_limits_type = kwargs['jobLimitsType']
        if job_limits_type is None:
            raise TypeError("Missing 'job_limits_type' argument")

        _setter("job_limits_type", 'Command')
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter(name="jobLimitsType")
    def job_limits_type(self) -> str:
        """

        Expected value is 'Command'.
        """
        return pulumi.get(self, "job_limits_type")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        The max run duration in ISO 8601 format, after which the job will be cancelled. Only supports duration with precision as low as Seconds.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class CommandJobResponse(dict):
    """
    Command job definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentId":
            suggest = "environment_id"
        elif key == "jobType":
            suggest = "job_type"
        elif key == "codeId":
            suggest = "code_id"
        elif key == "computeId":
            suggest = "compute_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "experimentName":
            suggest = "experiment_name"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CommandJobResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CommandJobResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CommandJobResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command: str,
                 environment_id: str,
                 job_type: str,
                 parameters: Any,
                 status: str,
                 code_id: Optional[str] = None,
                 compute_id: Optional[str] = None,
                 description: Optional[str] = None,
                 display_name: Optional[str] = None,
                 distribution: Optional[Any] = None,
                 environment_variables: Optional[Mapping[str, str]] = None,
                 experiment_name: Optional[str] = None,
                 identity: Optional[Any] = None,
                 inputs: Optional[Mapping[str, Any]] = None,
                 is_archived: Optional[bool] = None,
                 limits: Optional['outputs.CommandJobLimitsResponse'] = None,
                 outputs: Optional[Mapping[str, Any]] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 resources: Optional['outputs.ResourceConfigurationResponse'] = None,
                 schedule: Optional[Any] = None,
                 services: Optional[Mapping[str, 'outputs.JobServiceResponse']] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Command job definition.
        :param str command: [Required] The command to execute on startup of the job. eg. "python train.py"
        :param str environment_id: [Required] The ARM resource ID of the Environment specification for the job.
        :param str job_type: Enum to determine the type of job.
               Expected value is 'Command'.
        :param Any parameters: Input parameters.
        :param str status: Status of the job.
        :param str code_id: ARM resource ID of the code asset.
        :param str compute_id: ARM resource ID of the compute resource.
        :param str description: The asset description text.
        :param str display_name: Display name of job.
        :param Union['MpiResponse', 'PyTorchResponse', 'TensorFlowResponse'] distribution: Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, or null.
        :param Mapping[str, str] environment_variables: Environment variables included in the job.
        :param str experiment_name: The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        :param Union['AmlTokenResponse', 'ManagedIdentityResponse', 'UserIdentityResponse'] identity: Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
               Defaults to AmlToken if null.
        :param Mapping[str, Union['CustomModelJobInputResponse', 'LiteralJobInputResponse', 'MLFlowModelJobInputResponse', 'MLTableJobInputResponse', 'TritonModelJobInputResponse', 'UriFileJobInputResponse', 'UriFolderJobInputResponse']] inputs: Mapping of input data bindings used in the job.
        :param bool is_archived: Is the asset archived?
        :param 'CommandJobLimitsResponse' limits: Command Job limit.
        :param Mapping[str, Union['CustomModelJobOutputResponse', 'MLFlowModelJobOutputResponse', 'MLTableJobOutputResponse', 'TritonModelJobOutputResponse', 'UriFileJobOutputResponse', 'UriFolderJobOutputResponse']] outputs: Mapping of output data bindings used in the job.
        :param Mapping[str, str] properties: The asset property dictionary.
        :param 'ResourceConfigurationResponse' resources: Compute Resource configuration for the job.
        :param Union['CronScheduleResponse', 'RecurrenceScheduleResponse'] schedule: Schedule definition of job.
               If no schedule is provided, the job is run once and immediately after submission.
        :param Mapping[str, 'JobServiceResponse'] services: List of JobEndpoints.
               For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        CommandJobResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            command=command,
            environment_id=environment_id,
            job_type=job_type,
            parameters=parameters,
            status=status,
            code_id=code_id,
            compute_id=compute_id,
            description=description,
            display_name=display_name,
            distribution=distribution,
            environment_variables=environment_variables,
            experiment_name=experiment_name,
            identity=identity,
            inputs=inputs,
            is_archived=is_archived,
            limits=limits,
            outputs=outputs,
            properties=properties,
            resources=resources,
            schedule=schedule,
            services=services,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             command: Optional[str] = None,
             environment_id: Optional[str] = None,
             job_type: Optional[str] = None,
             parameters: Optional[Any] = None,
             status: Optional[str] = None,
             code_id: Optional[str] = None,
             compute_id: Optional[str] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             distribution: Optional[Any] = None,
             environment_variables: Optional[Mapping[str, str]] = None,
             experiment_name: Optional[str] = None,
             identity: Optional[Any] = None,
             inputs: Optional[Mapping[str, Any]] = None,
             is_archived: Optional[bool] = None,
             limits: Optional['outputs.CommandJobLimitsResponse'] = None,
             outputs: Optional[Mapping[str, Any]] = None,
             properties: Optional[Mapping[str, str]] = None,
             resources: Optional['outputs.ResourceConfigurationResponse'] = None,
             schedule: Optional[Any] = None,
             services: Optional[Mapping[str, 'outputs.JobServiceResponse']] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if command is None:
            raise TypeError("Missing 'command' argument")
        if environment_id is None and 'environmentId' in kwargs:
            environment_id = kwargs['environmentId']
        if environment_id is None:
            raise TypeError("Missing 'environment_id' argument")
        if job_type is None and 'jobType' in kwargs:
            job_type = kwargs['jobType']
        if job_type is None:
            raise TypeError("Missing 'job_type' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if code_id is None and 'codeId' in kwargs:
            code_id = kwargs['codeId']
        if compute_id is None and 'computeId' in kwargs:
            compute_id = kwargs['computeId']
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if environment_variables is None and 'environmentVariables' in kwargs:
            environment_variables = kwargs['environmentVariables']
        if experiment_name is None and 'experimentName' in kwargs:
            experiment_name = kwargs['experimentName']
        if is_archived is None and 'isArchived' in kwargs:
            is_archived = kwargs['isArchived']

        _setter("command", command)
        _setter("environment_id", environment_id)
        _setter("job_type", 'Command')
        _setter("parameters", parameters)
        _setter("status", status)
        if code_id is not None:
            _setter("code_id", code_id)
        if compute_id is not None:
            _setter("compute_id", compute_id)
        if description is not None:
            _setter("description", description)
        if display_name is not None:
            _setter("display_name", display_name)
        if distribution is not None:
            _setter("distribution", distribution)
        if environment_variables is not None:
            _setter("environment_variables", environment_variables)
        if experiment_name is None:
            experiment_name = 'Default'
        if experiment_name is not None:
            _setter("experiment_name", experiment_name)
        if identity is not None:
            _setter("identity", identity)
        if inputs is not None:
            _setter("inputs", inputs)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            _setter("is_archived", is_archived)
        if limits is not None:
            _setter("limits", limits)
        if outputs is not None:
            _setter("outputs", outputs)
        if properties is not None:
            _setter("properties", properties)
        if resources is not None:
            _setter("resources", resources)
        if schedule is not None:
            _setter("schedule", schedule)
        if services is not None:
            _setter("services", services)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def command(self) -> str:
        """
        [Required] The command to execute on startup of the job. eg. "python train.py"
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> str:
        """
        [Required] The ARM resource ID of the Environment specification for the job.
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="jobType")
    def job_type(self) -> str:
        """
        Enum to determine the type of job.
        Expected value is 'Command'.
        """
        return pulumi.get(self, "job_type")

    @property
    @pulumi.getter
    def parameters(self) -> Any:
        """
        Input parameters.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the job.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="codeId")
    def code_id(self) -> Optional[str]:
        """
        ARM resource ID of the code asset.
        """
        return pulumi.get(self, "code_id")

    @property
    @pulumi.getter(name="computeId")
    def compute_id(self) -> Optional[str]:
        """
        ARM resource ID of the compute resource.
        """
        return pulumi.get(self, "compute_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Display name of job.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def distribution(self) -> Optional[Any]:
        """
        Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, or null.
        """
        return pulumi.get(self, "distribution")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, str]]:
        """
        Environment variables included in the job.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="experimentName")
    def experiment_name(self) -> Optional[str]:
        """
        The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        """
        return pulumi.get(self, "experiment_name")

    @property
    @pulumi.getter
    def identity(self) -> Optional[Any]:
        """
        Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
        Defaults to AmlToken if null.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter
    def inputs(self) -> Optional[Mapping[str, Any]]:
        """
        Mapping of input data bindings used in the job.
        """
        return pulumi.get(self, "inputs")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def limits(self) -> Optional['outputs.CommandJobLimitsResponse']:
        """
        Command Job limit.
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def outputs(self) -> Optional[Mapping[str, Any]]:
        """
        Mapping of output data bindings used in the job.
        """
        return pulumi.get(self, "outputs")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.ResourceConfigurationResponse']:
        """
        Compute Resource configuration for the job.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def schedule(self) -> Optional[Any]:
        """
        Schedule definition of job.
        If no schedule is provided, the job is run once and immediately after submission.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter
    def services(self) -> Optional[Mapping[str, 'outputs.JobServiceResponse']]:
        """
        List of JobEndpoints.
        For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ComponentContainerResponse(dict):
    """
    Component container definition.
    <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latestVersion":
            suggest = "latest_version"
        elif key == "nextVersion":
            suggest = "next_version"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComponentContainerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComponentContainerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComponentContainerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latest_version: str,
                 next_version: str,
                 description: Optional[str] = None,
                 is_archived: Optional[bool] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Component container definition.
        <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
        :param str latest_version: The latest version inside this container.
        :param str next_version: The next auto incremental version
        :param str description: The asset description text.
        :param bool is_archived: Is the asset archived?
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        ComponentContainerResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            latest_version=latest_version,
            next_version=next_version,
            description=description,
            is_archived=is_archived,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             latest_version: Optional[str] = None,
             next_version: Optional[str] = None,
             description: Optional[str] = None,
             is_archived: Optional[bool] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if latest_version is None and 'latestVersion' in kwargs:
            latest_version = kwargs['latestVersion']
        if latest_version is None:
            raise TypeError("Missing 'latest_version' argument")
        if next_version is None and 'nextVersion' in kwargs:
            next_version = kwargs['nextVersion']
        if next_version is None:
            raise TypeError("Missing 'next_version' argument")
        if is_archived is None and 'isArchived' in kwargs:
            is_archived = kwargs['isArchived']

        _setter("latest_version", latest_version)
        _setter("next_version", next_version)
        if description is not None:
            _setter("description", description)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            _setter("is_archived", is_archived)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> str:
        """
        The latest version inside this container.
        """
        return pulumi.get(self, "latest_version")

    @property
    @pulumi.getter(name="nextVersion")
    def next_version(self) -> str:
        """
        The next auto incremental version
        """
        return pulumi.get(self, "next_version")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ComponentVersionResponse(dict):
    """
    Definition of a component version: defines resources that span component types.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "componentSpec":
            suggest = "component_spec"
        elif key == "isAnonymous":
            suggest = "is_anonymous"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComponentVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComponentVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComponentVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component_spec: Optional[Any] = None,
                 description: Optional[str] = None,
                 is_anonymous: Optional[bool] = None,
                 is_archived: Optional[bool] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Definition of a component version: defines resources that span component types.
        :param Any component_spec: Defines Component definition details.
               <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
        :param str description: The asset description text.
        :param bool is_anonymous: If the name version are system generated (anonymous registration).
        :param bool is_archived: Is the asset archived?
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        ComponentVersionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            component_spec=component_spec,
            description=description,
            is_anonymous=is_anonymous,
            is_archived=is_archived,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             component_spec: Optional[Any] = None,
             description: Optional[str] = None,
             is_anonymous: Optional[bool] = None,
             is_archived: Optional[bool] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if component_spec is None and 'componentSpec' in kwargs:
            component_spec = kwargs['componentSpec']
        if is_anonymous is None and 'isAnonymous' in kwargs:
            is_anonymous = kwargs['isAnonymous']
        if is_archived is None and 'isArchived' in kwargs:
            is_archived = kwargs['isArchived']

        if component_spec is not None:
            _setter("component_spec", component_spec)
        if description is not None:
            _setter("description", description)
        if is_anonymous is None:
            is_anonymous = False
        if is_anonymous is not None:
            _setter("is_anonymous", is_anonymous)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            _setter("is_archived", is_archived)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="componentSpec")
    def component_spec(self) -> Optional[Any]:
        """
        Defines Component definition details.
        <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
        """
        return pulumi.get(self, "component_spec")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[bool]:
        """
        If the name version are system generated (anonymous registration).
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ContainerResourceRequirementsResponse(dict):
    """
    Resource requirements for each container instance within an online deployment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerResourceLimits":
            suggest = "container_resource_limits"
        elif key == "containerResourceRequests":
            suggest = "container_resource_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerResourceRequirementsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerResourceRequirementsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerResourceRequirementsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_resource_limits: Optional['outputs.ContainerResourceSettingsResponse'] = None,
                 container_resource_requests: Optional['outputs.ContainerResourceSettingsResponse'] = None):
        """
        Resource requirements for each container instance within an online deployment.
        :param 'ContainerResourceSettingsResponse' container_resource_limits: Container resource limit info:
        :param 'ContainerResourceSettingsResponse' container_resource_requests: Container resource request info:
        """
        ContainerResourceRequirementsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            container_resource_limits=container_resource_limits,
            container_resource_requests=container_resource_requests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             container_resource_limits: Optional['outputs.ContainerResourceSettingsResponse'] = None,
             container_resource_requests: Optional['outputs.ContainerResourceSettingsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if container_resource_limits is None and 'containerResourceLimits' in kwargs:
            container_resource_limits = kwargs['containerResourceLimits']
        if container_resource_requests is None and 'containerResourceRequests' in kwargs:
            container_resource_requests = kwargs['containerResourceRequests']

        if container_resource_limits is not None:
            _setter("container_resource_limits", container_resource_limits)
        if container_resource_requests is not None:
            _setter("container_resource_requests", container_resource_requests)

    @property
    @pulumi.getter(name="containerResourceLimits")
    def container_resource_limits(self) -> Optional['outputs.ContainerResourceSettingsResponse']:
        """
        Container resource limit info:
        """
        return pulumi.get(self, "container_resource_limits")

    @property
    @pulumi.getter(name="containerResourceRequests")
    def container_resource_requests(self) -> Optional['outputs.ContainerResourceSettingsResponse']:
        """
        Container resource request info:
        """
        return pulumi.get(self, "container_resource_requests")


@pulumi.output_type
class ContainerResourceSettingsResponse(dict):
    def __init__(__self__, *,
                 cpu: Optional[str] = None,
                 gpu: Optional[str] = None,
                 memory: Optional[str] = None):
        """
        :param str cpu: Number of vCPUs request/limit for container. More info:
               https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param str gpu: Number of Nvidia GPU cards request/limit for container. More info:
               https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param str memory: Memory size request/limit for container. More info:
               https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        ContainerResourceSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu=cpu,
            gpu=gpu,
            memory=memory,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu: Optional[str] = None,
             gpu: Optional[str] = None,
             memory: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if cpu is not None:
            _setter("cpu", cpu)
        if gpu is not None:
            _setter("gpu", gpu)
        if memory is not None:
            _setter("memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[str]:
        """
        Number of vCPUs request/limit for container. More info:
        https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def gpu(self) -> Optional[str]:
        """
        Number of Nvidia GPU cards request/limit for container. More info:
        https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "gpu")

    @property
    @pulumi.getter
    def memory(self) -> Optional[str]:
        """
        Memory size request/limit for container. More info:
        https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class CronScheduleResponse(dict):
    """
    Cron schedule definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scheduleType":
            suggest = "schedule_type"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "scheduleStatus":
            suggest = "schedule_status"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CronScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CronScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CronScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 schedule_type: str,
                 end_time: Optional[str] = None,
                 schedule_status: Optional[str] = None,
                 start_time: Optional[str] = None,
                 time_zone: Optional[str] = None):
        """
        Cron schedule definition
        :param str expression: [Required] Specifies cron expression of schedule.
               The expression should follow NCronTab format.
        :param str schedule_type: Enum to describe type of schedule
               Expected value is 'Cron'.
        :param str end_time: Specifies end time of schedule in ISO 8601 format.
               If not present, the schedule will run indefinitely
        :param str schedule_status: Specifies the schedule's status
        :param str start_time: Specifies start time of schedule in ISO 8601 format.
        :param str time_zone: Specifies time zone in which the schedule runs.
               TimeZone should follow Windows time zone format.
        """
        CronScheduleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            schedule_type=schedule_type,
            end_time=end_time,
            schedule_status=schedule_status,
            start_time=start_time,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: Optional[str] = None,
             schedule_type: Optional[str] = None,
             end_time: Optional[str] = None,
             schedule_status: Optional[str] = None,
             start_time: Optional[str] = None,
             time_zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if expression is None:
            raise TypeError("Missing 'expression' argument")
        if schedule_type is None and 'scheduleType' in kwargs:
            schedule_type = kwargs['scheduleType']
        if schedule_type is None:
            raise TypeError("Missing 'schedule_type' argument")
        if end_time is None and 'endTime' in kwargs:
            end_time = kwargs['endTime']
        if schedule_status is None and 'scheduleStatus' in kwargs:
            schedule_status = kwargs['scheduleStatus']
        if start_time is None and 'startTime' in kwargs:
            start_time = kwargs['startTime']
        if time_zone is None and 'timeZone' in kwargs:
            time_zone = kwargs['timeZone']

        _setter("expression", expression)
        _setter("schedule_type", 'Cron')
        if end_time is not None:
            _setter("end_time", end_time)
        if schedule_status is None:
            schedule_status = 'Enabled'
        if schedule_status is not None:
            _setter("schedule_status", schedule_status)
        if start_time is not None:
            _setter("start_time", start_time)
        if time_zone is None:
            time_zone = 'UTC'
        if time_zone is not None:
            _setter("time_zone", time_zone)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        [Required] Specifies cron expression of schedule.
        The expression should follow NCronTab format.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="scheduleType")
    def schedule_type(self) -> str:
        """
        Enum to describe type of schedule
        Expected value is 'Cron'.
        """
        return pulumi.get(self, "schedule_type")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        Specifies end time of schedule in ISO 8601 format.
        If not present, the schedule will run indefinitely
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="scheduleStatus")
    def schedule_status(self) -> Optional[str]:
        """
        Specifies the schedule's status
        """
        return pulumi.get(self, "schedule_status")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        Specifies start time of schedule in ISO 8601 format.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        Specifies time zone in which the schedule runs.
        TimeZone should follow Windows time zone format.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class CustomForecastHorizonResponse(dict):
    """
    The desired maximum forecast horizon in units of time-series frequency.
    """
    def __init__(__self__, *,
                 mode: str,
                 value: int):
        """
        The desired maximum forecast horizon in units of time-series frequency.
        :param str mode: Enum to determine forecast horizon selection mode.
               Expected value is 'Custom'.
        :param int value: [Required] Forecast horizon value.
        """
        CustomForecastHorizonResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mode is None:
            raise TypeError("Missing 'mode' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("mode", 'Custom')
        _setter("value", value)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Enum to determine forecast horizon selection mode.
        Expected value is 'Custom'.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        [Required] Forecast horizon value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomModelJobInputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobInputType":
            suggest = "job_input_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomModelJobInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomModelJobInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomModelJobInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_input_type: str,
                 uri: str,
                 description: Optional[str] = None,
                 mode: Optional[str] = None):
        """
        :param str job_input_type: Enum to determine the Job Input Type.
               Expected value is 'CustomModel'.
        :param str uri: [Required] Input Asset URI.
        :param str description: Description for the input.
        :param str mode: Input Asset Delivery Mode.
        """
        CustomModelJobInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_input_type=job_input_type,
            uri=uri,
            description=description,
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_input_type: Optional[str] = None,
             uri: Optional[str] = None,
             description: Optional[str] = None,
             mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if job_input_type is None and 'jobInputType' in kwargs:
            job_input_type = kwargs['jobInputType']
        if job_input_type is None:
            raise TypeError("Missing 'job_input_type' argument")
        if uri is None:
            raise TypeError("Missing 'uri' argument")

        _setter("job_input_type", 'CustomModel')
        _setter("uri", uri)
        if description is not None:
            _setter("description", description)
        if mode is None:
            mode = 'ReadOnlyMount'
        if mode is not None:
            _setter("mode", mode)

    @property
    @pulumi.getter(name="jobInputType")
    def job_input_type(self) -> str:
        """
        Enum to determine the Job Input Type.
        Expected value is 'CustomModel'.
        """
        return pulumi.get(self, "job_input_type")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        [Required] Input Asset URI.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for the input.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Input Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class CustomModelJobOutputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobOutputType":
            suggest = "job_output_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomModelJobOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomModelJobOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomModelJobOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_output_type: str,
                 description: Optional[str] = None,
                 mode: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        :param str job_output_type: Enum to determine the Job Output Type.
               Expected value is 'CustomModel'.
        :param str description: Description for the output.
        :param str mode: Output Asset Delivery Mode.
        :param str uri: Output Asset URI.
        """
        CustomModelJobOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_output_type=job_output_type,
            description=description,
            mode=mode,
            uri=uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_output_type: Optional[str] = None,
             description: Optional[str] = None,
             mode: Optional[str] = None,
             uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if job_output_type is None and 'jobOutputType' in kwargs:
            job_output_type = kwargs['jobOutputType']
        if job_output_type is None:
            raise TypeError("Missing 'job_output_type' argument")

        _setter("job_output_type", 'CustomModel')
        if description is not None:
            _setter("description", description)
        if mode is None:
            mode = 'ReadWriteMount'
        if mode is not None:
            _setter("mode", mode)
        if uri is not None:
            _setter("uri", uri)

    @property
    @pulumi.getter(name="jobOutputType")
    def job_output_type(self) -> str:
        """
        Enum to determine the Job Output Type.
        Expected value is 'CustomModel'.
        """
        return pulumi.get(self, "job_output_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for the output.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Output Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        Output Asset URI.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class CustomNCrossValidationsResponse(dict):
    """
    N-Cross validations are specified by user.
    """
    def __init__(__self__, *,
                 mode: str,
                 value: int):
        """
        N-Cross validations are specified by user.
        :param str mode: Determines how N-Cross validations value is determined.
               Expected value is 'Custom'.
        :param int value: [Required] N-Cross validations value.
        """
        CustomNCrossValidationsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mode is None:
            raise TypeError("Missing 'mode' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("mode", 'Custom')
        _setter("value", value)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Determines how N-Cross validations value is determined.
        Expected value is 'Custom'.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        [Required] N-Cross validations value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomSeasonalityResponse(dict):
    def __init__(__self__, *,
                 mode: str,
                 value: int):
        """
        :param str mode: Forecasting seasonality mode.
               Expected value is 'Custom'.
        :param int value: [Required] Seasonality value.
        """
        CustomSeasonalityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mode is None:
            raise TypeError("Missing 'mode' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("mode", 'Custom')
        _setter("value", value)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Forecasting seasonality mode.
        Expected value is 'Custom'.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        [Required] Seasonality value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomTargetLagsResponse(dict):
    def __init__(__self__, *,
                 mode: str,
                 values: Sequence[int]):
        """
        :param str mode: Target lags selection modes.
               Expected value is 'Custom'.
        :param Sequence[int] values: [Required] Set target lags values.
        """
        CustomTargetLagsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: Optional[str] = None,
             values: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mode is None:
            raise TypeError("Missing 'mode' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("mode", 'Custom')
        _setter("values", values)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Target lags selection modes.
        Expected value is 'Custom'.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def values(self) -> Sequence[int]:
        """
        [Required] Set target lags values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CustomTargetRollingWindowSizeResponse(dict):
    def __init__(__self__, *,
                 mode: str,
                 value: int):
        """
        :param str mode: Target rolling windows size mode.
               Expected value is 'Custom'.
        :param int value: [Required] TargetRollingWindowSize value.
        """
        CustomTargetRollingWindowSizeResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mode is None:
            raise TypeError("Missing 'mode' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("mode", 'Custom')
        _setter("value", value)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Target rolling windows size mode.
        Expected value is 'Custom'.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        [Required] TargetRollingWindowSize value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DataContainerResponse(dict):
    """
    Container for data asset versions.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "latestVersion":
            suggest = "latest_version"
        elif key == "nextVersion":
            suggest = "next_version"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataContainerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataContainerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataContainerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: str,
                 latest_version: str,
                 next_version: str,
                 description: Optional[str] = None,
                 is_archived: Optional[bool] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Container for data asset versions.
        :param str data_type: [Required] Specifies the type of data.
        :param str latest_version: The latest version inside this container.
        :param str next_version: The next auto incremental version
        :param str description: The asset description text.
        :param bool is_archived: Is the asset archived?
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        DataContainerResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_type=data_type,
            latest_version=latest_version,
            next_version=next_version,
            description=description,
            is_archived=is_archived,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_type: Optional[str] = None,
             latest_version: Optional[str] = None,
             next_version: Optional[str] = None,
             description: Optional[str] = None,
             is_archived: Optional[bool] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_type is None and 'dataType' in kwargs:
            data_type = kwargs['dataType']
        if data_type is None:
            raise TypeError("Missing 'data_type' argument")
        if latest_version is None and 'latestVersion' in kwargs:
            latest_version = kwargs['latestVersion']
        if latest_version is None:
            raise TypeError("Missing 'latest_version' argument")
        if next_version is None and 'nextVersion' in kwargs:
            next_version = kwargs['nextVersion']
        if next_version is None:
            raise TypeError("Missing 'next_version' argument")
        if is_archived is None and 'isArchived' in kwargs:
            is_archived = kwargs['isArchived']

        _setter("data_type", data_type)
        _setter("latest_version", latest_version)
        _setter("next_version", next_version)
        if description is not None:
            _setter("description", description)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            _setter("is_archived", is_archived)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        [Required] Specifies the type of data.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> str:
        """
        The latest version inside this container.
        """
        return pulumi.get(self, "latest_version")

    @property
    @pulumi.getter(name="nextVersion")
    def next_version(self) -> str:
        """
        The next auto incremental version
        """
        return pulumi.get(self, "next_version")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class DataPathAssetReferenceResponse(dict):
    """
    Reference to an asset via its path in a datastore.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referenceType":
            suggest = "reference_type"
        elif key == "datastoreId":
            suggest = "datastore_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataPathAssetReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataPathAssetReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataPathAssetReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reference_type: str,
                 datastore_id: Optional[str] = None,
                 path: Optional[str] = None):
        """
        Reference to an asset via its path in a datastore.
        :param str reference_type: Enum to determine which reference method to use for an asset.
               Expected value is 'DataPath'.
        :param str datastore_id: ARM resource ID of the datastore where the asset is located.
        :param str path: The path of the file/directory in the datastore.
        """
        DataPathAssetReferenceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            reference_type=reference_type,
            datastore_id=datastore_id,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             reference_type: Optional[str] = None,
             datastore_id: Optional[str] = None,
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if reference_type is None and 'referenceType' in kwargs:
            reference_type = kwargs['referenceType']
        if reference_type is None:
            raise TypeError("Missing 'reference_type' argument")
        if datastore_id is None and 'datastoreId' in kwargs:
            datastore_id = kwargs['datastoreId']

        _setter("reference_type", 'DataPath')
        if datastore_id is not None:
            _setter("datastore_id", datastore_id)
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter(name="referenceType")
    def reference_type(self) -> str:
        """
        Enum to determine which reference method to use for an asset.
        Expected value is 'DataPath'.
        """
        return pulumi.get(self, "reference_type")

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[str]:
        """
        ARM resource ID of the datastore where the asset is located.
        """
        return pulumi.get(self, "datastore_id")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path of the file/directory in the datastore.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DefaultScaleSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleType":
            suggest = "scale_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultScaleSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultScaleSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultScaleSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scale_type: str):
        """
        :param str scale_type: 
               Expected value is 'Default'.
        """
        DefaultScaleSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scale_type=scale_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scale_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if scale_type is None and 'scaleType' in kwargs:
            scale_type = kwargs['scaleType']
        if scale_type is None:
            raise TypeError("Missing 'scale_type' argument")

        _setter("scale_type", 'Default')

    @property
    @pulumi.getter(name="scaleType")
    def scale_type(self) -> str:
        """

        Expected value is 'Default'.
        """
        return pulumi.get(self, "scale_type")


@pulumi.output_type
class EnvironmentContainerResponse(dict):
    """
    Container for environment specification versions.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latestVersion":
            suggest = "latest_version"
        elif key == "nextVersion":
            suggest = "next_version"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentContainerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentContainerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentContainerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latest_version: str,
                 next_version: str,
                 description: Optional[str] = None,
                 is_archived: Optional[bool] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Container for environment specification versions.
        :param str latest_version: The latest version inside this container.
        :param str next_version: The next auto incremental version
        :param str description: The asset description text.
        :param bool is_archived: Is the asset archived?
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        EnvironmentContainerResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            latest_version=latest_version,
            next_version=next_version,
            description=description,
            is_archived=is_archived,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             latest_version: Optional[str] = None,
             next_version: Optional[str] = None,
             description: Optional[str] = None,
             is_archived: Optional[bool] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if latest_version is None and 'latestVersion' in kwargs:
            latest_version = kwargs['latestVersion']
        if latest_version is None:
            raise TypeError("Missing 'latest_version' argument")
        if next_version is None and 'nextVersion' in kwargs:
            next_version = kwargs['nextVersion']
        if next_version is None:
            raise TypeError("Missing 'next_version' argument")
        if is_archived is None and 'isArchived' in kwargs:
            is_archived = kwargs['isArchived']

        _setter("latest_version", latest_version)
        _setter("next_version", next_version)
        if description is not None:
            _setter("description", description)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            _setter("is_archived", is_archived)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> str:
        """
        The latest version inside this container.
        """
        return pulumi.get(self, "latest_version")

    @property
    @pulumi.getter(name="nextVersion")
    def next_version(self) -> str:
        """
        The next auto incremental version
        """
        return pulumi.get(self, "next_version")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class EnvironmentVersionResponse(dict):
    """
    Environment version details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentType":
            suggest = "environment_type"
        elif key == "condaFile":
            suggest = "conda_file"
        elif key == "inferenceConfig":
            suggest = "inference_config"
        elif key == "isAnonymous":
            suggest = "is_anonymous"
        elif key == "isArchived":
            suggest = "is_archived"
        elif key == "osType":
            suggest = "os_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 environment_type: str,
                 build: Optional['outputs.BuildContextResponse'] = None,
                 conda_file: Optional[str] = None,
                 description: Optional[str] = None,
                 image: Optional[str] = None,
                 inference_config: Optional['outputs.InferenceContainerPropertiesResponse'] = None,
                 is_anonymous: Optional[bool] = None,
                 is_archived: Optional[bool] = None,
                 os_type: Optional[str] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Environment version details.
        :param str environment_type: Environment type is either user managed or curated by the Azure ML service
               <see href="https://docs.microsoft.com/en-us/azure/machine-learning/resource-curated-environments" />
        :param 'BuildContextResponse' build: Configuration settings for Docker build context.
        :param str conda_file: Standard configuration file used by Conda that lets you install any kind of package, including Python, R, and C/C++ packages.
               <see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-install-a-conda-environment" />
        :param str description: The asset description text.
        :param str image: Name of the image that will be used for the environment.
               <seealso href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-image#use-a-custom-base-image" />
        :param 'InferenceContainerPropertiesResponse' inference_config: Defines configuration specific to inference.
        :param bool is_anonymous: If the name version are system generated (anonymous registration).
        :param bool is_archived: Is the asset archived?
        :param str os_type: The OS type of the environment.
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        EnvironmentVersionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            environment_type=environment_type,
            build=build,
            conda_file=conda_file,
            description=description,
            image=image,
            inference_config=inference_config,
            is_anonymous=is_anonymous,
            is_archived=is_archived,
            os_type=os_type,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             environment_type: Optional[str] = None,
             build: Optional['outputs.BuildContextResponse'] = None,
             conda_file: Optional[str] = None,
             description: Optional[str] = None,
             image: Optional[str] = None,
             inference_config: Optional['outputs.InferenceContainerPropertiesResponse'] = None,
             is_anonymous: Optional[bool] = None,
             is_archived: Optional[bool] = None,
             os_type: Optional[str] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if environment_type is None and 'environmentType' in kwargs:
            environment_type = kwargs['environmentType']
        if environment_type is None:
            raise TypeError("Missing 'environment_type' argument")
        if conda_file is None and 'condaFile' in kwargs:
            conda_file = kwargs['condaFile']
        if inference_config is None and 'inferenceConfig' in kwargs:
            inference_config = kwargs['inferenceConfig']
        if is_anonymous is None and 'isAnonymous' in kwargs:
            is_anonymous = kwargs['isAnonymous']
        if is_archived is None and 'isArchived' in kwargs:
            is_archived = kwargs['isArchived']
        if os_type is None and 'osType' in kwargs:
            os_type = kwargs['osType']

        _setter("environment_type", environment_type)
        if build is not None:
            _setter("build", build)
        if conda_file is not None:
            _setter("conda_file", conda_file)
        if description is not None:
            _setter("description", description)
        if image is not None:
            _setter("image", image)
        if inference_config is not None:
            _setter("inference_config", inference_config)
        if is_anonymous is None:
            is_anonymous = False
        if is_anonymous is not None:
            _setter("is_anonymous", is_anonymous)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            _setter("is_archived", is_archived)
        if os_type is None:
            os_type = 'Linux'
        if os_type is not None:
            _setter("os_type", os_type)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="environmentType")
    def environment_type(self) -> str:
        """
        Environment type is either user managed or curated by the Azure ML service
        <see href="https://docs.microsoft.com/en-us/azure/machine-learning/resource-curated-environments" />
        """
        return pulumi.get(self, "environment_type")

    @property
    @pulumi.getter
    def build(self) -> Optional['outputs.BuildContextResponse']:
        """
        Configuration settings for Docker build context.
        """
        return pulumi.get(self, "build")

    @property
    @pulumi.getter(name="condaFile")
    def conda_file(self) -> Optional[str]:
        """
        Standard configuration file used by Conda that lets you install any kind of package, including Python, R, and C/C++ packages.
        <see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-install-a-conda-environment" />
        """
        return pulumi.get(self, "conda_file")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Name of the image that will be used for the environment.
        <seealso href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-image#use-a-custom-base-image" />
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="inferenceConfig")
    def inference_config(self) -> Optional['outputs.InferenceContainerPropertiesResponse']:
        """
        Defines configuration specific to inference.
        """
        return pulumi.get(self, "inference_config")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[bool]:
        """
        If the name version are system generated (anonymous registration).
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[str]:
        """
        The OS type of the environment.
        """
        return pulumi.get(self, "os_type")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class FlavorDataResponse(dict):
    def __init__(__self__, *,
                 data: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] data: Model flavor-specific data.
        """
        FlavorDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data=data,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if data is not None:
            _setter("data", data)

    @property
    @pulumi.getter
    def data(self) -> Optional[Mapping[str, str]]:
        """
        Model flavor-specific data.
        """
        return pulumi.get(self, "data")


@pulumi.output_type
class ForecastingResponse(dict):
    """
    Forecasting task in AutoML Table vertical.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "allowedModels":
            suggest = "allowed_models"
        elif key == "blockedModels":
            suggest = "blocked_models"
        elif key == "dataSettings":
            suggest = "data_settings"
        elif key == "featurizationSettings":
            suggest = "featurization_settings"
        elif key == "forecastingSettings":
            suggest = "forecasting_settings"
        elif key == "limitSettings":
            suggest = "limit_settings"
        elif key == "logVerbosity":
            suggest = "log_verbosity"
        elif key == "primaryMetric":
            suggest = "primary_metric"
        elif key == "trainingSettings":
            suggest = "training_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ForecastingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ForecastingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ForecastingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 task_type: str,
                 allowed_models: Optional[Sequence[str]] = None,
                 blocked_models: Optional[Sequence[str]] = None,
                 data_settings: Optional['outputs.TableVerticalDataSettingsResponse'] = None,
                 featurization_settings: Optional['outputs.TableVerticalFeaturizationSettingsResponse'] = None,
                 forecasting_settings: Optional['outputs.ForecastingSettingsResponse'] = None,
                 limit_settings: Optional['outputs.TableVerticalLimitSettingsResponse'] = None,
                 log_verbosity: Optional[str] = None,
                 primary_metric: Optional[str] = None,
                 training_settings: Optional['outputs.TrainingSettingsResponse'] = None):
        """
        Forecasting task in AutoML Table vertical.
        :param str task_type: AutoMLJob Task type.
               Expected value is 'Forecasting'.
        :param Sequence[str] allowed_models: Allowed models for forecasting task.
        :param Sequence[str] blocked_models: Blocked models for forecasting task.
        :param 'TableVerticalDataSettingsResponse' data_settings: Data inputs for AutoMLJob.
        :param 'TableVerticalFeaturizationSettingsResponse' featurization_settings: Featurization inputs needed for AutoML job.
        :param 'ForecastingSettingsResponse' forecasting_settings: Forecasting task specific inputs.
        :param 'TableVerticalLimitSettingsResponse' limit_settings: Execution constraints for AutoMLJob.
        :param str log_verbosity: Log verbosity for the job.
        :param str primary_metric: Primary metric for forecasting task.
        :param 'TrainingSettingsResponse' training_settings: Inputs for training phase for an AutoML Job.
        """
        ForecastingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            task_type=task_type,
            allowed_models=allowed_models,
            blocked_models=blocked_models,
            data_settings=data_settings,
            featurization_settings=featurization_settings,
            forecasting_settings=forecasting_settings,
            limit_settings=limit_settings,
            log_verbosity=log_verbosity,
            primary_metric=primary_metric,
            training_settings=training_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             task_type: Optional[str] = None,
             allowed_models: Optional[Sequence[str]] = None,
             blocked_models: Optional[Sequence[str]] = None,
             data_settings: Optional['outputs.TableVerticalDataSettingsResponse'] = None,
             featurization_settings: Optional['outputs.TableVerticalFeaturizationSettingsResponse'] = None,
             forecasting_settings: Optional['outputs.ForecastingSettingsResponse'] = None,
             limit_settings: Optional['outputs.TableVerticalLimitSettingsResponse'] = None,
             log_verbosity: Optional[str] = None,
             primary_metric: Optional[str] = None,
             training_settings: Optional['outputs.TrainingSettingsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if allowed_models is None and 'allowedModels' in kwargs:
            allowed_models = kwargs['allowedModels']
        if blocked_models is None and 'blockedModels' in kwargs:
            blocked_models = kwargs['blockedModels']
        if data_settings is None and 'dataSettings' in kwargs:
            data_settings = kwargs['dataSettings']
        if featurization_settings is None and 'featurizationSettings' in kwargs:
            featurization_settings = kwargs['featurizationSettings']
        if forecasting_settings is None and 'forecastingSettings' in kwargs:
            forecasting_settings = kwargs['forecastingSettings']
        if limit_settings is None and 'limitSettings' in kwargs:
            limit_settings = kwargs['limitSettings']
        if log_verbosity is None and 'logVerbosity' in kwargs:
            log_verbosity = kwargs['logVerbosity']
        if primary_metric is None and 'primaryMetric' in kwargs:
            primary_metric = kwargs['primaryMetric']
        if training_settings is None and 'trainingSettings' in kwargs:
            training_settings = kwargs['trainingSettings']

        _setter("task_type", 'Forecasting')
        if allowed_models is not None:
            _setter("allowed_models", allowed_models)
        if blocked_models is not None:
            _setter("blocked_models", blocked_models)
        if data_settings is not None:
            _setter("data_settings", data_settings)
        if featurization_settings is not None:
            _setter("featurization_settings", featurization_settings)
        if forecasting_settings is not None:
            _setter("forecasting_settings", forecasting_settings)
        if limit_settings is not None:
            _setter("limit_settings", limit_settings)
        if log_verbosity is None:
            log_verbosity = 'Info'
        if log_verbosity is not None:
            _setter("log_verbosity", log_verbosity)
        if primary_metric is None:
            primary_metric = 'NormalizedRootMeanSquaredError'
        if primary_metric is not None:
            _setter("primary_metric", primary_metric)
        if training_settings is not None:
            _setter("training_settings", training_settings)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        AutoMLJob Task type.
        Expected value is 'Forecasting'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="allowedModels")
    def allowed_models(self) -> Optional[Sequence[str]]:
        """
        Allowed models for forecasting task.
        """
        return pulumi.get(self, "allowed_models")

    @property
    @pulumi.getter(name="blockedModels")
    def blocked_models(self) -> Optional[Sequence[str]]:
        """
        Blocked models for forecasting task.
        """
        return pulumi.get(self, "blocked_models")

    @property
    @pulumi.getter(name="dataSettings")
    def data_settings(self) -> Optional['outputs.TableVerticalDataSettingsResponse']:
        """
        Data inputs for AutoMLJob.
        """
        return pulumi.get(self, "data_settings")

    @property
    @pulumi.getter(name="featurizationSettings")
    def featurization_settings(self) -> Optional['outputs.TableVerticalFeaturizationSettingsResponse']:
        """
        Featurization inputs needed for AutoML job.
        """
        return pulumi.get(self, "featurization_settings")

    @property
    @pulumi.getter(name="forecastingSettings")
    def forecasting_settings(self) -> Optional['outputs.ForecastingSettingsResponse']:
        """
        Forecasting task specific inputs.
        """
        return pulumi.get(self, "forecasting_settings")

    @property
    @pulumi.getter(name="limitSettings")
    def limit_settings(self) -> Optional['outputs.TableVerticalLimitSettingsResponse']:
        """
        Execution constraints for AutoMLJob.
        """
        return pulumi.get(self, "limit_settings")

    @property
    @pulumi.getter(name="logVerbosity")
    def log_verbosity(self) -> Optional[str]:
        """
        Log verbosity for the job.
        """
        return pulumi.get(self, "log_verbosity")

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> Optional[str]:
        """
        Primary metric for forecasting task.
        """
        return pulumi.get(self, "primary_metric")

    @property
    @pulumi.getter(name="trainingSettings")
    def training_settings(self) -> Optional['outputs.TrainingSettingsResponse']:
        """
        Inputs for training phase for an AutoML Job.
        """
        return pulumi.get(self, "training_settings")


@pulumi.output_type
class ForecastingSettingsResponse(dict):
    """
    Forecasting specific parameters.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryOrRegionForHolidays":
            suggest = "country_or_region_for_holidays"
        elif key == "cvStepSize":
            suggest = "cv_step_size"
        elif key == "featureLags":
            suggest = "feature_lags"
        elif key == "forecastHorizon":
            suggest = "forecast_horizon"
        elif key == "shortSeriesHandlingConfig":
            suggest = "short_series_handling_config"
        elif key == "targetAggregateFunction":
            suggest = "target_aggregate_function"
        elif key == "targetLags":
            suggest = "target_lags"
        elif key == "targetRollingWindowSize":
            suggest = "target_rolling_window_size"
        elif key == "timeColumnName":
            suggest = "time_column_name"
        elif key == "timeSeriesIdColumnNames":
            suggest = "time_series_id_column_names"
        elif key == "useStl":
            suggest = "use_stl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ForecastingSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ForecastingSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ForecastingSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_or_region_for_holidays: Optional[str] = None,
                 cv_step_size: Optional[int] = None,
                 feature_lags: Optional[str] = None,
                 forecast_horizon: Optional[Any] = None,
                 frequency: Optional[str] = None,
                 seasonality: Optional[Any] = None,
                 short_series_handling_config: Optional[str] = None,
                 target_aggregate_function: Optional[str] = None,
                 target_lags: Optional[Any] = None,
                 target_rolling_window_size: Optional[Any] = None,
                 time_column_name: Optional[str] = None,
                 time_series_id_column_names: Optional[Sequence[str]] = None,
                 use_stl: Optional[str] = None):
        """
        Forecasting specific parameters.
        :param str country_or_region_for_holidays: Country or region for holidays for forecasting tasks.
               These should be ISO 3166 two-letter country/region codes, for example 'US' or 'GB'.
        :param int cv_step_size: Number of periods between the origin time of one CV fold and the next fold. For
               example, if `CVStepSize` = 3 for daily data, the origin time for each fold will be
               three days apart.
        :param str feature_lags: Flag for generating lags for the numeric features with 'auto' or null.
        :param Union['AutoForecastHorizonResponse', 'CustomForecastHorizonResponse'] forecast_horizon: The desired maximum forecast horizon in units of time-series frequency.
        :param str frequency: When forecasting, this parameter represents the period with which the forecast is desired, for example daily, weekly, yearly, etc. The forecast frequency is dataset frequency by default.
        :param Union['AutoSeasonalityResponse', 'CustomSeasonalityResponse'] seasonality: Set time series seasonality as an integer multiple of the series frequency.
               If seasonality is set to 'auto', it will be inferred.
        :param str short_series_handling_config: The parameter defining how if AutoML should handle short time series.
        :param str target_aggregate_function: The function to be used to aggregate the time series target column to conform to a user specified frequency.
               If the TargetAggregateFunction is set i.e. not 'None', but the freq parameter is not set, the error is raised. The possible target aggregation functions are: "sum", "max", "min" and "mean".
        :param Union['AutoTargetLagsResponse', 'CustomTargetLagsResponse'] target_lags: The number of past periods to lag from the target column.
        :param Union['AutoTargetRollingWindowSizeResponse', 'CustomTargetRollingWindowSizeResponse'] target_rolling_window_size: The number of past periods used to create a rolling window average of the target column.
        :param str time_column_name: The name of the time column. This parameter is required when forecasting to specify the datetime column in the input data used for building the time series and inferring its frequency.
        :param Sequence[str] time_series_id_column_names: The names of columns used to group a timeseries. It can be used to create multiple series.
               If grain is not defined, the data set is assumed to be one time-series. This parameter is used with task type forecasting.
        :param str use_stl: Configure STL Decomposition of the time-series target column.
        """
        ForecastingSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            country_or_region_for_holidays=country_or_region_for_holidays,
            cv_step_size=cv_step_size,
            feature_lags=feature_lags,
            forecast_horizon=forecast_horizon,
            frequency=frequency,
            seasonality=seasonality,
            short_series_handling_config=short_series_handling_config,
            target_aggregate_function=target_aggregate_function,
            target_lags=target_lags,
            target_rolling_window_size=target_rolling_window_size,
            time_column_name=time_column_name,
            time_series_id_column_names=time_series_id_column_names,
            use_stl=use_stl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             country_or_region_for_holidays: Optional[str] = None,
             cv_step_size: Optional[int] = None,
             feature_lags: Optional[str] = None,
             forecast_horizon: Optional[Any] = None,
             frequency: Optional[str] = None,
             seasonality: Optional[Any] = None,
             short_series_handling_config: Optional[str] = None,
             target_aggregate_function: Optional[str] = None,
             target_lags: Optional[Any] = None,
             target_rolling_window_size: Optional[Any] = None,
             time_column_name: Optional[str] = None,
             time_series_id_column_names: Optional[Sequence[str]] = None,
             use_stl: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if country_or_region_for_holidays is None and 'countryOrRegionForHolidays' in kwargs:
            country_or_region_for_holidays = kwargs['countryOrRegionForHolidays']
        if cv_step_size is None and 'cvStepSize' in kwargs:
            cv_step_size = kwargs['cvStepSize']
        if feature_lags is None and 'featureLags' in kwargs:
            feature_lags = kwargs['featureLags']
        if forecast_horizon is None and 'forecastHorizon' in kwargs:
            forecast_horizon = kwargs['forecastHorizon']
        if short_series_handling_config is None and 'shortSeriesHandlingConfig' in kwargs:
            short_series_handling_config = kwargs['shortSeriesHandlingConfig']
        if target_aggregate_function is None and 'targetAggregateFunction' in kwargs:
            target_aggregate_function = kwargs['targetAggregateFunction']
        if target_lags is None and 'targetLags' in kwargs:
            target_lags = kwargs['targetLags']
        if target_rolling_window_size is None and 'targetRollingWindowSize' in kwargs:
            target_rolling_window_size = kwargs['targetRollingWindowSize']
        if time_column_name is None and 'timeColumnName' in kwargs:
            time_column_name = kwargs['timeColumnName']
        if time_series_id_column_names is None and 'timeSeriesIdColumnNames' in kwargs:
            time_series_id_column_names = kwargs['timeSeriesIdColumnNames']
        if use_stl is None and 'useStl' in kwargs:
            use_stl = kwargs['useStl']

        if country_or_region_for_holidays is not None:
            _setter("country_or_region_for_holidays", country_or_region_for_holidays)
        if cv_step_size is not None:
            _setter("cv_step_size", cv_step_size)
        if feature_lags is None:
            feature_lags = 'None'
        if feature_lags is not None:
            _setter("feature_lags", feature_lags)
        if forecast_horizon is not None:
            _setter("forecast_horizon", forecast_horizon)
        if frequency is not None:
            _setter("frequency", frequency)
        if seasonality is not None:
            _setter("seasonality", seasonality)
        if short_series_handling_config is None:
            short_series_handling_config = 'Auto'
        if short_series_handling_config is not None:
            _setter("short_series_handling_config", short_series_handling_config)
        if target_aggregate_function is None:
            target_aggregate_function = 'None'
        if target_aggregate_function is not None:
            _setter("target_aggregate_function", target_aggregate_function)
        if target_lags is not None:
            _setter("target_lags", target_lags)
        if target_rolling_window_size is not None:
            _setter("target_rolling_window_size", target_rolling_window_size)
        if time_column_name is not None:
            _setter("time_column_name", time_column_name)
        if time_series_id_column_names is not None:
            _setter("time_series_id_column_names", time_series_id_column_names)
        if use_stl is None:
            use_stl = 'None'
        if use_stl is not None:
            _setter("use_stl", use_stl)

    @property
    @pulumi.getter(name="countryOrRegionForHolidays")
    def country_or_region_for_holidays(self) -> Optional[str]:
        """
        Country or region for holidays for forecasting tasks.
        These should be ISO 3166 two-letter country/region codes, for example 'US' or 'GB'.
        """
        return pulumi.get(self, "country_or_region_for_holidays")

    @property
    @pulumi.getter(name="cvStepSize")
    def cv_step_size(self) -> Optional[int]:
        """
        Number of periods between the origin time of one CV fold and the next fold. For
        example, if `CVStepSize` = 3 for daily data, the origin time for each fold will be
        three days apart.
        """
        return pulumi.get(self, "cv_step_size")

    @property
    @pulumi.getter(name="featureLags")
    def feature_lags(self) -> Optional[str]:
        """
        Flag for generating lags for the numeric features with 'auto' or null.
        """
        return pulumi.get(self, "feature_lags")

    @property
    @pulumi.getter(name="forecastHorizon")
    def forecast_horizon(self) -> Optional[Any]:
        """
        The desired maximum forecast horizon in units of time-series frequency.
        """
        return pulumi.get(self, "forecast_horizon")

    @property
    @pulumi.getter
    def frequency(self) -> Optional[str]:
        """
        When forecasting, this parameter represents the period with which the forecast is desired, for example daily, weekly, yearly, etc. The forecast frequency is dataset frequency by default.
        """
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter
    def seasonality(self) -> Optional[Any]:
        """
        Set time series seasonality as an integer multiple of the series frequency.
        If seasonality is set to 'auto', it will be inferred.
        """
        return pulumi.get(self, "seasonality")

    @property
    @pulumi.getter(name="shortSeriesHandlingConfig")
    def short_series_handling_config(self) -> Optional[str]:
        """
        The parameter defining how if AutoML should handle short time series.
        """
        return pulumi.get(self, "short_series_handling_config")

    @property
    @pulumi.getter(name="targetAggregateFunction")
    def target_aggregate_function(self) -> Optional[str]:
        """
        The function to be used to aggregate the time series target column to conform to a user specified frequency.
        If the TargetAggregateFunction is set i.e. not 'None', but the freq parameter is not set, the error is raised. The possible target aggregation functions are: "sum", "max", "min" and "mean".
        """
        return pulumi.get(self, "target_aggregate_function")

    @property
    @pulumi.getter(name="targetLags")
    def target_lags(self) -> Optional[Any]:
        """
        The number of past periods to lag from the target column.
        """
        return pulumi.get(self, "target_lags")

    @property
    @pulumi.getter(name="targetRollingWindowSize")
    def target_rolling_window_size(self) -> Optional[Any]:
        """
        The number of past periods used to create a rolling window average of the target column.
        """
        return pulumi.get(self, "target_rolling_window_size")

    @property
    @pulumi.getter(name="timeColumnName")
    def time_column_name(self) -> Optional[str]:
        """
        The name of the time column. This parameter is required when forecasting to specify the datetime column in the input data used for building the time series and inferring its frequency.
        """
        return pulumi.get(self, "time_column_name")

    @property
    @pulumi.getter(name="timeSeriesIdColumnNames")
    def time_series_id_column_names(self) -> Optional[Sequence[str]]:
        """
        The names of columns used to group a timeseries. It can be used to create multiple series.
        If grain is not defined, the data set is assumed to be one time-series. This parameter is used with task type forecasting.
        """
        return pulumi.get(self, "time_series_id_column_names")

    @property
    @pulumi.getter(name="useStl")
    def use_stl(self) -> Optional[str]:
        """
        Configure STL Decomposition of the time-series target column.
        """
        return pulumi.get(self, "use_stl")


@pulumi.output_type
class GridSamplingAlgorithmResponse(dict):
    """
    Defines a Sampling Algorithm that exhaustively generates every value combination in the space
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "samplingAlgorithmType":
            suggest = "sampling_algorithm_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GridSamplingAlgorithmResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GridSamplingAlgorithmResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GridSamplingAlgorithmResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sampling_algorithm_type: str):
        """
        Defines a Sampling Algorithm that exhaustively generates every value combination in the space
        :param str sampling_algorithm_type: 
               Expected value is 'Grid'.
        """
        GridSamplingAlgorithmResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sampling_algorithm_type=sampling_algorithm_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sampling_algorithm_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if sampling_algorithm_type is None and 'samplingAlgorithmType' in kwargs:
            sampling_algorithm_type = kwargs['samplingAlgorithmType']
        if sampling_algorithm_type is None:
            raise TypeError("Missing 'sampling_algorithm_type' argument")

        _setter("sampling_algorithm_type", 'Grid')

    @property
    @pulumi.getter(name="samplingAlgorithmType")
    def sampling_algorithm_type(self) -> str:
        """

        Expected value is 'Grid'.
        """
        return pulumi.get(self, "sampling_algorithm_type")


@pulumi.output_type
class HdfsDatastoreResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datastoreType":
            suggest = "datastore_type"
        elif key == "isDefault":
            suggest = "is_default"
        elif key == "nameNodeAddress":
            suggest = "name_node_address"
        elif key == "hdfsServerCertificate":
            suggest = "hdfs_server_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HdfsDatastoreResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HdfsDatastoreResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HdfsDatastoreResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: Any,
                 datastore_type: str,
                 is_default: bool,
                 name_node_address: str,
                 description: Optional[str] = None,
                 hdfs_server_certificate: Optional[str] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 protocol: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param Union['AccountKeyDatastoreCredentialsResponse', 'CertificateDatastoreCredentialsResponse', 'KerberosKeytabCredentialsResponse', 'KerberosPasswordCredentialsResponse', 'NoneDatastoreCredentialsResponse', 'SasDatastoreCredentialsResponse', 'ServicePrincipalDatastoreCredentialsResponse'] credentials: [Required] Account credentials.
        :param str datastore_type: Enum to determine the datastore contents type.
               Expected value is 'Hdfs'.
        :param bool is_default: Readonly property to indicate if datastore is the workspace default datastore
        :param str name_node_address: [Required] IP Address or DNS HostName.
        :param str description: The asset description text.
        :param str hdfs_server_certificate: The TLS cert of the HDFS server. Needs to be a base64 encoded string. Required if "Https" protocol is selected.
        :param Mapping[str, str] properties: The asset property dictionary.
        :param str protocol: Protocol used to communicate with the storage account (Https/Http).
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        HdfsDatastoreResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials=credentials,
            datastore_type=datastore_type,
            is_default=is_default,
            name_node_address=name_node_address,
            description=description,
            hdfs_server_certificate=hdfs_server_certificate,
            properties=properties,
            protocol=protocol,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials: Optional[Any] = None,
             datastore_type: Optional[str] = None,
             is_default: Optional[bool] = None,
             name_node_address: Optional[str] = None,
             description: Optional[str] = None,
             hdfs_server_certificate: Optional[str] = None,
             properties: Optional[Mapping[str, str]] = None,
             protocol: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if credentials is None:
            raise TypeError("Missing 'credentials' argument")
        if datastore_type is None and 'datastoreType' in kwargs:
            datastore_type = kwargs['datastoreType']
        if datastore_type is None:
            raise TypeError("Missing 'datastore_type' argument")
        if is_default is None and 'isDefault' in kwargs:
            is_default = kwargs['isDefault']
        if is_default is None:
            raise TypeError("Missing 'is_default' argument")
        if name_node_address is None and 'nameNodeAddress' in kwargs:
            name_node_address = kwargs['nameNodeAddress']
        if name_node_address is None:
            raise TypeError("Missing 'name_node_address' argument")
        if hdfs_server_certificate is None and 'hdfsServerCertificate' in kwargs:
            hdfs_server_certificate = kwargs['hdfsServerCertificate']

        _setter("credentials", credentials)
        _setter("datastore_type", 'Hdfs')
        _setter("is_default", is_default)
        _setter("name_node_address", name_node_address)
        if description is not None:
            _setter("description", description)
        if hdfs_server_certificate is not None:
            _setter("hdfs_server_certificate", hdfs_server_certificate)
        if properties is not None:
            _setter("properties", properties)
        if protocol is None:
            protocol = 'http'
        if protocol is not None:
            _setter("protocol", protocol)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def credentials(self) -> Any:
        """
        [Required] Account credentials.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="datastoreType")
    def datastore_type(self) -> str:
        """
        Enum to determine the datastore contents type.
        Expected value is 'Hdfs'.
        """
        return pulumi.get(self, "datastore_type")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Readonly property to indicate if datastore is the workspace default datastore
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter(name="nameNodeAddress")
    def name_node_address(self) -> str:
        """
        [Required] IP Address or DNS HostName.
        """
        return pulumi.get(self, "name_node_address")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="hdfsServerCertificate")
    def hdfs_server_certificate(self) -> Optional[str]:
        """
        The TLS cert of the HDFS server. Needs to be a base64 encoded string. Required if "Https" protocol is selected.
        """
        return pulumi.get(self, "hdfs_server_certificate")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol used to communicate with the storage account (Https/Http).
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class IdAssetReferenceResponse(dict):
    """
    Reference to an asset via its ARM resource ID.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assetId":
            suggest = "asset_id"
        elif key == "referenceType":
            suggest = "reference_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdAssetReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdAssetReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdAssetReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asset_id: str,
                 reference_type: str):
        """
        Reference to an asset via its ARM resource ID.
        :param str asset_id: [Required] ARM resource ID of the asset.
        :param str reference_type: Enum to determine which reference method to use for an asset.
               Expected value is 'Id'.
        """
        IdAssetReferenceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            asset_id=asset_id,
            reference_type=reference_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             asset_id: Optional[str] = None,
             reference_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if asset_id is None and 'assetId' in kwargs:
            asset_id = kwargs['assetId']
        if asset_id is None:
            raise TypeError("Missing 'asset_id' argument")
        if reference_type is None and 'referenceType' in kwargs:
            reference_type = kwargs['referenceType']
        if reference_type is None:
            raise TypeError("Missing 'reference_type' argument")

        _setter("asset_id", asset_id)
        _setter("reference_type", 'Id')

    @property
    @pulumi.getter(name="assetId")
    def asset_id(self) -> str:
        """
        [Required] ARM resource ID of the asset.
        """
        return pulumi.get(self, "asset_id")

    @property
    @pulumi.getter(name="referenceType")
    def reference_type(self) -> str:
        """
        Enum to determine which reference method to use for an asset.
        Expected value is 'Id'.
        """
        return pulumi.get(self, "reference_type")


@pulumi.output_type
class ImageClassificationMultilabelResponse(dict):
    """
    Image Classification Multilabel. Multi-label image classification is used when an image could have one or more labels
    from a set of labels - e.g. an image could be labeled with both 'cat' and 'dog'.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSettings":
            suggest = "data_settings"
        elif key == "limitSettings":
            suggest = "limit_settings"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "logVerbosity":
            suggest = "log_verbosity"
        elif key == "modelSettings":
            suggest = "model_settings"
        elif key == "primaryMetric":
            suggest = "primary_metric"
        elif key == "searchSpace":
            suggest = "search_space"
        elif key == "sweepSettings":
            suggest = "sweep_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageClassificationMultilabelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageClassificationMultilabelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageClassificationMultilabelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_settings: 'outputs.ImageVerticalDataSettingsResponse',
                 limit_settings: 'outputs.ImageLimitSettingsResponse',
                 task_type: str,
                 log_verbosity: Optional[str] = None,
                 model_settings: Optional['outputs.ImageModelSettingsClassificationResponse'] = None,
                 primary_metric: Optional[str] = None,
                 search_space: Optional[Sequence['outputs.ImageModelDistributionSettingsClassificationResponse']] = None,
                 sweep_settings: Optional['outputs.ImageSweepSettingsResponse'] = None):
        """
        Image Classification Multilabel. Multi-label image classification is used when an image could have one or more labels
        from a set of labels - e.g. an image could be labeled with both 'cat' and 'dog'.
        :param 'ImageVerticalDataSettingsResponse' data_settings: [Required] Collection of registered Tabular Dataset Ids and other data settings required for training and validating models.
        :param 'ImageLimitSettingsResponse' limit_settings: [Required] Limit settings for the AutoML job.
        :param str task_type: AutoMLJob Task type.
               Expected value is 'ImageClassificationMultilabel'.
        :param str log_verbosity: Log verbosity for the job.
        :param 'ImageModelSettingsClassificationResponse' model_settings: Settings used for training the model.
        :param str primary_metric: Primary metric to optimize for this task.
        :param Sequence['ImageModelDistributionSettingsClassificationResponse'] search_space: Search space for sampling different combinations of models and their hyperparameters.
        :param 'ImageSweepSettingsResponse' sweep_settings: Model sweeping and hyperparameter sweeping related settings.
        """
        ImageClassificationMultilabelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_settings=data_settings,
            limit_settings=limit_settings,
            task_type=task_type,
            log_verbosity=log_verbosity,
            model_settings=model_settings,
            primary_metric=primary_metric,
            search_space=search_space,
            sweep_settings=sweep_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_settings: Optional['outputs.ImageVerticalDataSettingsResponse'] = None,
             limit_settings: Optional['outputs.ImageLimitSettingsResponse'] = None,
             task_type: Optional[str] = None,
             log_verbosity: Optional[str] = None,
             model_settings: Optional['outputs.ImageModelSettingsClassificationResponse'] = None,
             primary_metric: Optional[str] = None,
             search_space: Optional[Sequence['outputs.ImageModelDistributionSettingsClassificationResponse']] = None,
             sweep_settings: Optional['outputs.ImageSweepSettingsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_settings is None and 'dataSettings' in kwargs:
            data_settings = kwargs['dataSettings']
        if data_settings is None:
            raise TypeError("Missing 'data_settings' argument")
        if limit_settings is None and 'limitSettings' in kwargs:
            limit_settings = kwargs['limitSettings']
        if limit_settings is None:
            raise TypeError("Missing 'limit_settings' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if log_verbosity is None and 'logVerbosity' in kwargs:
            log_verbosity = kwargs['logVerbosity']
        if model_settings is None and 'modelSettings' in kwargs:
            model_settings = kwargs['modelSettings']
        if primary_metric is None and 'primaryMetric' in kwargs:
            primary_metric = kwargs['primaryMetric']
        if search_space is None and 'searchSpace' in kwargs:
            search_space = kwargs['searchSpace']
        if sweep_settings is None and 'sweepSettings' in kwargs:
            sweep_settings = kwargs['sweepSettings']

        _setter("data_settings", data_settings)
        _setter("limit_settings", limit_settings)
        _setter("task_type", 'ImageClassificationMultilabel')
        if log_verbosity is None:
            log_verbosity = 'Info'
        if log_verbosity is not None:
            _setter("log_verbosity", log_verbosity)
        if model_settings is not None:
            _setter("model_settings", model_settings)
        if primary_metric is None:
            primary_metric = 'IOU'
        if primary_metric is not None:
            _setter("primary_metric", primary_metric)
        if search_space is not None:
            _setter("search_space", search_space)
        if sweep_settings is not None:
            _setter("sweep_settings", sweep_settings)

    @property
    @pulumi.getter(name="dataSettings")
    def data_settings(self) -> 'outputs.ImageVerticalDataSettingsResponse':
        """
        [Required] Collection of registered Tabular Dataset Ids and other data settings required for training and validating models.
        """
        return pulumi.get(self, "data_settings")

    @property
    @pulumi.getter(name="limitSettings")
    def limit_settings(self) -> 'outputs.ImageLimitSettingsResponse':
        """
        [Required] Limit settings for the AutoML job.
        """
        return pulumi.get(self, "limit_settings")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        AutoMLJob Task type.
        Expected value is 'ImageClassificationMultilabel'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="logVerbosity")
    def log_verbosity(self) -> Optional[str]:
        """
        Log verbosity for the job.
        """
        return pulumi.get(self, "log_verbosity")

    @property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional['outputs.ImageModelSettingsClassificationResponse']:
        """
        Settings used for training the model.
        """
        return pulumi.get(self, "model_settings")

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> Optional[str]:
        """
        Primary metric to optimize for this task.
        """
        return pulumi.get(self, "primary_metric")

    @property
    @pulumi.getter(name="searchSpace")
    def search_space(self) -> Optional[Sequence['outputs.ImageModelDistributionSettingsClassificationResponse']]:
        """
        Search space for sampling different combinations of models and their hyperparameters.
        """
        return pulumi.get(self, "search_space")

    @property
    @pulumi.getter(name="sweepSettings")
    def sweep_settings(self) -> Optional['outputs.ImageSweepSettingsResponse']:
        """
        Model sweeping and hyperparameter sweeping related settings.
        """
        return pulumi.get(self, "sweep_settings")


@pulumi.output_type
class ImageClassificationResponse(dict):
    """
    Image Classification. Multi-class image classification is used when an image is classified with only a single label
    from a set of classes - e.g. each image is classified as either an image of a 'cat' or a 'dog' or a 'duck'.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSettings":
            suggest = "data_settings"
        elif key == "limitSettings":
            suggest = "limit_settings"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "logVerbosity":
            suggest = "log_verbosity"
        elif key == "modelSettings":
            suggest = "model_settings"
        elif key == "primaryMetric":
            suggest = "primary_metric"
        elif key == "searchSpace":
            suggest = "search_space"
        elif key == "sweepSettings":
            suggest = "sweep_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageClassificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageClassificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageClassificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_settings: 'outputs.ImageVerticalDataSettingsResponse',
                 limit_settings: 'outputs.ImageLimitSettingsResponse',
                 task_type: str,
                 log_verbosity: Optional[str] = None,
                 model_settings: Optional['outputs.ImageModelSettingsClassificationResponse'] = None,
                 primary_metric: Optional[str] = None,
                 search_space: Optional[Sequence['outputs.ImageModelDistributionSettingsClassificationResponse']] = None,
                 sweep_settings: Optional['outputs.ImageSweepSettingsResponse'] = None):
        """
        Image Classification. Multi-class image classification is used when an image is classified with only a single label
        from a set of classes - e.g. each image is classified as either an image of a 'cat' or a 'dog' or a 'duck'.
        :param 'ImageVerticalDataSettingsResponse' data_settings: [Required] Collection of registered Tabular Dataset Ids and other data settings required for training and validating models.
        :param 'ImageLimitSettingsResponse' limit_settings: [Required] Limit settings for the AutoML job.
        :param str task_type: AutoMLJob Task type.
               Expected value is 'ImageClassification'.
        :param str log_verbosity: Log verbosity for the job.
        :param 'ImageModelSettingsClassificationResponse' model_settings: Settings used for training the model.
        :param str primary_metric: Primary metric to optimize for this task.
        :param Sequence['ImageModelDistributionSettingsClassificationResponse'] search_space: Search space for sampling different combinations of models and their hyperparameters.
        :param 'ImageSweepSettingsResponse' sweep_settings: Model sweeping and hyperparameter sweeping related settings.
        """
        ImageClassificationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_settings=data_settings,
            limit_settings=limit_settings,
            task_type=task_type,
            log_verbosity=log_verbosity,
            model_settings=model_settings,
            primary_metric=primary_metric,
            search_space=search_space,
            sweep_settings=sweep_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_settings: Optional['outputs.ImageVerticalDataSettingsResponse'] = None,
             limit_settings: Optional['outputs.ImageLimitSettingsResponse'] = None,
             task_type: Optional[str] = None,
             log_verbosity: Optional[str] = None,
             model_settings: Optional['outputs.ImageModelSettingsClassificationResponse'] = None,
             primary_metric: Optional[str] = None,
             search_space: Optional[Sequence['outputs.ImageModelDistributionSettingsClassificationResponse']] = None,
             sweep_settings: Optional['outputs.ImageSweepSettingsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_settings is None and 'dataSettings' in kwargs:
            data_settings = kwargs['dataSettings']
        if data_settings is None:
            raise TypeError("Missing 'data_settings' argument")
        if limit_settings is None and 'limitSettings' in kwargs:
            limit_settings = kwargs['limitSettings']
        if limit_settings is None:
            raise TypeError("Missing 'limit_settings' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if log_verbosity is None and 'logVerbosity' in kwargs:
            log_verbosity = kwargs['logVerbosity']
        if model_settings is None and 'modelSettings' in kwargs:
            model_settings = kwargs['modelSettings']
        if primary_metric is None and 'primaryMetric' in kwargs:
            primary_metric = kwargs['primaryMetric']
        if search_space is None and 'searchSpace' in kwargs:
            search_space = kwargs['searchSpace']
        if sweep_settings is None and 'sweepSettings' in kwargs:
            sweep_settings = kwargs['sweepSettings']

        _setter("data_settings", data_settings)
        _setter("limit_settings", limit_settings)
        _setter("task_type", 'ImageClassification')
        if log_verbosity is None:
            log_verbosity = 'Info'
        if log_verbosity is not None:
            _setter("log_verbosity", log_verbosity)
        if model_settings is not None:
            _setter("model_settings", model_settings)
        if primary_metric is None:
            primary_metric = 'Accuracy'
        if primary_metric is not None:
            _setter("primary_metric", primary_metric)
        if search_space is not None:
            _setter("search_space", search_space)
        if sweep_settings is not None:
            _setter("sweep_settings", sweep_settings)

    @property
    @pulumi.getter(name="dataSettings")
    def data_settings(self) -> 'outputs.ImageVerticalDataSettingsResponse':
        """
        [Required] Collection of registered Tabular Dataset Ids and other data settings required for training and validating models.
        """
        return pulumi.get(self, "data_settings")

    @property
    @pulumi.getter(name="limitSettings")
    def limit_settings(self) -> 'outputs.ImageLimitSettingsResponse':
        """
        [Required] Limit settings for the AutoML job.
        """
        return pulumi.get(self, "limit_settings")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        AutoMLJob Task type.
        Expected value is 'ImageClassification'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="logVerbosity")
    def log_verbosity(self) -> Optional[str]:
        """
        Log verbosity for the job.
        """
        return pulumi.get(self, "log_verbosity")

    @property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional['outputs.ImageModelSettingsClassificationResponse']:
        """
        Settings used for training the model.
        """
        return pulumi.get(self, "model_settings")

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> Optional[str]:
        """
        Primary metric to optimize for this task.
        """
        return pulumi.get(self, "primary_metric")

    @property
    @pulumi.getter(name="searchSpace")
    def search_space(self) -> Optional[Sequence['outputs.ImageModelDistributionSettingsClassificationResponse']]:
        """
        Search space for sampling different combinations of models and their hyperparameters.
        """
        return pulumi.get(self, "search_space")

    @property
    @pulumi.getter(name="sweepSettings")
    def sweep_settings(self) -> Optional['outputs.ImageSweepSettingsResponse']:
        """
        Model sweeping and hyperparameter sweeping related settings.
        """
        return pulumi.get(self, "sweep_settings")


@pulumi.output_type
class ImageInstanceSegmentationResponse(dict):
    """
    Image Instance Segmentation. Instance segmentation is used to identify objects in an image at the pixel level,
    drawing a polygon around each object in the image.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSettings":
            suggest = "data_settings"
        elif key == "limitSettings":
            suggest = "limit_settings"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "logVerbosity":
            suggest = "log_verbosity"
        elif key == "modelSettings":
            suggest = "model_settings"
        elif key == "primaryMetric":
            suggest = "primary_metric"
        elif key == "searchSpace":
            suggest = "search_space"
        elif key == "sweepSettings":
            suggest = "sweep_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageInstanceSegmentationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageInstanceSegmentationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageInstanceSegmentationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_settings: 'outputs.ImageVerticalDataSettingsResponse',
                 limit_settings: 'outputs.ImageLimitSettingsResponse',
                 task_type: str,
                 log_verbosity: Optional[str] = None,
                 model_settings: Optional['outputs.ImageModelSettingsObjectDetectionResponse'] = None,
                 primary_metric: Optional[str] = None,
                 search_space: Optional[Sequence['outputs.ImageModelDistributionSettingsObjectDetectionResponse']] = None,
                 sweep_settings: Optional['outputs.ImageSweepSettingsResponse'] = None):
        """
        Image Instance Segmentation. Instance segmentation is used to identify objects in an image at the pixel level,
        drawing a polygon around each object in the image.
        :param 'ImageVerticalDataSettingsResponse' data_settings: [Required] Collection of registered Tabular Dataset Ids and other data settings required for training and validating models.
        :param 'ImageLimitSettingsResponse' limit_settings: [Required] Limit settings for the AutoML job.
        :param str task_type: AutoMLJob Task type.
               Expected value is 'ImageInstanceSegmentation'.
        :param str log_verbosity: Log verbosity for the job.
        :param 'ImageModelSettingsObjectDetectionResponse' model_settings: Settings used for training the model.
        :param str primary_metric: Primary metric to optimize for this task.
        :param Sequence['ImageModelDistributionSettingsObjectDetectionResponse'] search_space: Search space for sampling different combinations of models and their hyperparameters.
        :param 'ImageSweepSettingsResponse' sweep_settings: Model sweeping and hyperparameter sweeping related settings.
        """
        ImageInstanceSegmentationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_settings=data_settings,
            limit_settings=limit_settings,
            task_type=task_type,
            log_verbosity=log_verbosity,
            model_settings=model_settings,
            primary_metric=primary_metric,
            search_space=search_space,
            sweep_settings=sweep_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_settings: Optional['outputs.ImageVerticalDataSettingsResponse'] = None,
             limit_settings: Optional['outputs.ImageLimitSettingsResponse'] = None,
             task_type: Optional[str] = None,
             log_verbosity: Optional[str] = None,
             model_settings: Optional['outputs.ImageModelSettingsObjectDetectionResponse'] = None,
             primary_metric: Optional[str] = None,
             search_space: Optional[Sequence['outputs.ImageModelDistributionSettingsObjectDetectionResponse']] = None,
             sweep_settings: Optional['outputs.ImageSweepSettingsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_settings is None and 'dataSettings' in kwargs:
            data_settings = kwargs['dataSettings']
        if data_settings is None:
            raise TypeError("Missing 'data_settings' argument")
        if limit_settings is None and 'limitSettings' in kwargs:
            limit_settings = kwargs['limitSettings']
        if limit_settings is None:
            raise TypeError("Missing 'limit_settings' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if log_verbosity is None and 'logVerbosity' in kwargs:
            log_verbosity = kwargs['logVerbosity']
        if model_settings is None and 'modelSettings' in kwargs:
            model_settings = kwargs['modelSettings']
        if primary_metric is None and 'primaryMetric' in kwargs:
            primary_metric = kwargs['primaryMetric']
        if search_space is None and 'searchSpace' in kwargs:
            search_space = kwargs['searchSpace']
        if sweep_settings is None and 'sweepSettings' in kwargs:
            sweep_settings = kwargs['sweepSettings']

        _setter("data_settings", data_settings)
        _setter("limit_settings", limit_settings)
        _setter("task_type", 'ImageInstanceSegmentation')
        if log_verbosity is None:
            log_verbosity = 'Info'
        if log_verbosity is not None:
            _setter("log_verbosity", log_verbosity)
        if model_settings is not None:
            _setter("model_settings", model_settings)
        if primary_metric is None:
            primary_metric = 'MeanAveragePrecision'
        if primary_metric is not None:
            _setter("primary_metric", primary_metric)
        if search_space is not None:
            _setter("search_space", search_space)
        if sweep_settings is not None:
            _setter("sweep_settings", sweep_settings)

    @property
    @pulumi.getter(name="dataSettings")
    def data_settings(self) -> 'outputs.ImageVerticalDataSettingsResponse':
        """
        [Required] Collection of registered Tabular Dataset Ids and other data settings required for training and validating models.
        """
        return pulumi.get(self, "data_settings")

    @property
    @pulumi.getter(name="limitSettings")
    def limit_settings(self) -> 'outputs.ImageLimitSettingsResponse':
        """
        [Required] Limit settings for the AutoML job.
        """
        return pulumi.get(self, "limit_settings")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        AutoMLJob Task type.
        Expected value is 'ImageInstanceSegmentation'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="logVerbosity")
    def log_verbosity(self) -> Optional[str]:
        """
        Log verbosity for the job.
        """
        return pulumi.get(self, "log_verbosity")

    @property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional['outputs.ImageModelSettingsObjectDetectionResponse']:
        """
        Settings used for training the model.
        """
        return pulumi.get(self, "model_settings")

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> Optional[str]:
        """
        Primary metric to optimize for this task.
        """
        return pulumi.get(self, "primary_metric")

    @property
    @pulumi.getter(name="searchSpace")
    def search_space(self) -> Optional[Sequence['outputs.ImageModelDistributionSettingsObjectDetectionResponse']]:
        """
        Search space for sampling different combinations of models and their hyperparameters.
        """
        return pulumi.get(self, "search_space")

    @property
    @pulumi.getter(name="sweepSettings")
    def sweep_settings(self) -> Optional['outputs.ImageSweepSettingsResponse']:
        """
        Model sweeping and hyperparameter sweeping related settings.
        """
        return pulumi.get(self, "sweep_settings")


@pulumi.output_type
class ImageLimitSettingsResponse(dict):
    """
    Limit settings for the AutoML job.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentTrials":
            suggest = "max_concurrent_trials"
        elif key == "maxTrials":
            suggest = "max_trials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageLimitSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageLimitSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageLimitSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_trials: Optional[int] = None,
                 max_trials: Optional[int] = None,
                 timeout: Optional[str] = None):
        """
        Limit settings for the AutoML job.
        :param int max_concurrent_trials: Maximum number of concurrent AutoML iterations.
        :param int max_trials: Maximum number of AutoML iterations.
        :param str timeout: AutoML job timeout.
        """
        ImageLimitSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_concurrent_trials=max_concurrent_trials,
            max_trials=max_trials,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_concurrent_trials: Optional[int] = None,
             max_trials: Optional[int] = None,
             timeout: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_concurrent_trials is None and 'maxConcurrentTrials' in kwargs:
            max_concurrent_trials = kwargs['maxConcurrentTrials']
        if max_trials is None and 'maxTrials' in kwargs:
            max_trials = kwargs['maxTrials']

        if max_concurrent_trials is None:
            max_concurrent_trials = 1
        if max_concurrent_trials is not None:
            _setter("max_concurrent_trials", max_concurrent_trials)
        if max_trials is None:
            max_trials = 1
        if max_trials is not None:
            _setter("max_trials", max_trials)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter(name="maxConcurrentTrials")
    def max_concurrent_trials(self) -> Optional[int]:
        """
        Maximum number of concurrent AutoML iterations.
        """
        return pulumi.get(self, "max_concurrent_trials")

    @property
    @pulumi.getter(name="maxTrials")
    def max_trials(self) -> Optional[int]:
        """
        Maximum number of AutoML iterations.
        """
        return pulumi.get(self, "max_trials")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        AutoML job timeout.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ImageModelDistributionSettingsClassificationResponse(dict):
    """
    Distribution expressions to sweep over values of model settings.
    <example>
    Some examples are:
    <code>
    ModelName = "choice('seresnext', 'resnest50')";
    LearningRate = "uniform(0.001, 0.01)";
    LayersToFreeze = "choice(0, 2)";
    </code></example>
    For more details on how to compose distribution expressions please check the documentation:
    https://docs.microsoft.com/en-us/azure/machine-learning/how-to-tune-hyperparameters
    For more information on the available settings please visit the official documentation:
    https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amsGradient":
            suggest = "ams_gradient"
        elif key == "earlyStopping":
            suggest = "early_stopping"
        elif key == "earlyStoppingDelay":
            suggest = "early_stopping_delay"
        elif key == "earlyStoppingPatience":
            suggest = "early_stopping_patience"
        elif key == "enableOnnxNormalization":
            suggest = "enable_onnx_normalization"
        elif key == "evaluationFrequency":
            suggest = "evaluation_frequency"
        elif key == "gradientAccumulationStep":
            suggest = "gradient_accumulation_step"
        elif key == "layersToFreeze":
            suggest = "layers_to_freeze"
        elif key == "learningRate":
            suggest = "learning_rate"
        elif key == "learningRateScheduler":
            suggest = "learning_rate_scheduler"
        elif key == "modelName":
            suggest = "model_name"
        elif key == "numberOfEpochs":
            suggest = "number_of_epochs"
        elif key == "numberOfWorkers":
            suggest = "number_of_workers"
        elif key == "randomSeed":
            suggest = "random_seed"
        elif key == "splitRatio":
            suggest = "split_ratio"
        elif key == "stepLRGamma":
            suggest = "step_lr_gamma"
        elif key == "stepLRStepSize":
            suggest = "step_lr_step_size"
        elif key == "trainingBatchSize":
            suggest = "training_batch_size"
        elif key == "trainingCropSize":
            suggest = "training_crop_size"
        elif key == "validationBatchSize":
            suggest = "validation_batch_size"
        elif key == "validationCropSize":
            suggest = "validation_crop_size"
        elif key == "validationResizeSize":
            suggest = "validation_resize_size"
        elif key == "warmupCosineLRCycles":
            suggest = "warmup_cosine_lr_cycles"
        elif key == "warmupCosineLRWarmupEpochs":
            suggest = "warmup_cosine_lr_warmup_epochs"
        elif key == "weightDecay":
            suggest = "weight_decay"
        elif key == "weightedLoss":
            suggest = "weighted_loss"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageModelDistributionSettingsClassificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageModelDistributionSettingsClassificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageModelDistributionSettingsClassificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ams_gradient: Optional[str] = None,
                 augmentations: Optional[str] = None,
                 beta1: Optional[str] = None,
                 beta2: Optional[str] = None,
                 distributed: Optional[str] = None,
                 early_stopping: Optional[str] = None,
                 early_stopping_delay: Optional[str] = None,
                 early_stopping_patience: Optional[str] = None,
                 enable_onnx_normalization: Optional[str] = None,
                 evaluation_frequency: Optional[str] = None,
                 gradient_accumulation_step: Optional[str] = None,
                 layers_to_freeze: Optional[str] = None,
                 learning_rate: Optional[str] = None,
                 learning_rate_scheduler: Optional[str] = None,
                 model_name: Optional[str] = None,
                 momentum: Optional[str] = None,
                 nesterov: Optional[str] = None,
                 number_of_epochs: Optional[str] = None,
                 number_of_workers: Optional[str] = None,
                 optimizer: Optional[str] = None,
                 random_seed: Optional[str] = None,
                 split_ratio: Optional[str] = None,
                 step_lr_gamma: Optional[str] = None,
                 step_lr_step_size: Optional[str] = None,
                 training_batch_size: Optional[str] = None,
                 training_crop_size: Optional[str] = None,
                 validation_batch_size: Optional[str] = None,
                 validation_crop_size: Optional[str] = None,
                 validation_resize_size: Optional[str] = None,
                 warmup_cosine_lr_cycles: Optional[str] = None,
                 warmup_cosine_lr_warmup_epochs: Optional[str] = None,
                 weight_decay: Optional[str] = None,
                 weighted_loss: Optional[str] = None):
        """
        Distribution expressions to sweep over values of model settings.
        <example>
        Some examples are:
        <code>
        ModelName = "choice('seresnext', 'resnest50')";
        LearningRate = "uniform(0.001, 0.01)";
        LayersToFreeze = "choice(0, 2)";
        </code></example>
        For more details on how to compose distribution expressions please check the documentation:
        https://docs.microsoft.com/en-us/azure/machine-learning/how-to-tune-hyperparameters
        For more information on the available settings please visit the official documentation:
        https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param str ams_gradient: Enable AMSGrad when optimizer is 'adam' or 'adamw'.
        :param str augmentations: Settings for using Augmentations.
        :param str beta1: Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        :param str beta2: Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        :param str distributed: Whether to use distributer training.
        :param str early_stopping: Enable early stopping logic during training.
        :param str early_stopping_delay: Minimum number of epochs or validation evaluations to wait before primary metric improvement
               is tracked for early stopping. Must be a positive integer.
        :param str early_stopping_patience: Minimum number of epochs or validation evaluations with no primary metric improvement before
               the run is stopped. Must be a positive integer.
        :param str enable_onnx_normalization: Enable normalization when exporting ONNX model.
        :param str evaluation_frequency: Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
        :param str gradient_accumulation_step: Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
               updating the model weights while accumulating the gradients of those steps, and then using
               the accumulated gradients to compute the weight updates. Must be a positive integer.
        :param str layers_to_freeze: Number of layers to freeze for the model. Must be a positive integer.
               For instance, passing 2 as value for 'seresnext' means
               freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
               see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param str learning_rate: Initial learning rate. Must be a float in the range [0, 1].
        :param str learning_rate_scheduler: Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
        :param str model_name: Name of the model to use for training.
               For more information on the available models please visit the official documentation:
               https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param str momentum: Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
        :param str nesterov: Enable nesterov when optimizer is 'sgd'.
        :param str number_of_epochs: Number of training epochs. Must be a positive integer.
        :param str number_of_workers: Number of data loader workers. Must be a non-negative integer.
        :param str optimizer: Type of optimizer. Must be either 'sgd', 'adam', or 'adamw'.
        :param str random_seed: Random seed to be used when using deterministic training.
        :param str split_ratio: If validation data is not defined, this specifies the split ratio for splitting
               train data into random train and validation subsets. Must be a float in the range [0, 1].
        :param str step_lr_gamma: Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
        :param str step_lr_step_size: Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
        :param str training_batch_size: Training batch size. Must be a positive integer.
        :param str training_crop_size: Image crop size that is input to the neural network for the training dataset. Must be a positive integer.
        :param str validation_batch_size: Validation batch size. Must be a positive integer.
        :param str validation_crop_size: Image crop size that is input to the neural network for the validation dataset. Must be a positive integer.
        :param str validation_resize_size: Image size to which to resize before cropping for validation dataset. Must be a positive integer.
        :param str warmup_cosine_lr_cycles: Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
        :param str warmup_cosine_lr_warmup_epochs: Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
        :param str weight_decay: Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
        :param str weighted_loss: Weighted loss. The accepted values are 0 for no weighted loss.
               1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be 0 or 1 or 2.
        """
        ImageModelDistributionSettingsClassificationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ams_gradient=ams_gradient,
            augmentations=augmentations,
            beta1=beta1,
            beta2=beta2,
            distributed=distributed,
            early_stopping=early_stopping,
            early_stopping_delay=early_stopping_delay,
            early_stopping_patience=early_stopping_patience,
            enable_onnx_normalization=enable_onnx_normalization,
            evaluation_frequency=evaluation_frequency,
            gradient_accumulation_step=gradient_accumulation_step,
            layers_to_freeze=layers_to_freeze,
            learning_rate=learning_rate,
            learning_rate_scheduler=learning_rate_scheduler,
            model_name=model_name,
            momentum=momentum,
            nesterov=nesterov,
            number_of_epochs=number_of_epochs,
            number_of_workers=number_of_workers,
            optimizer=optimizer,
            random_seed=random_seed,
            split_ratio=split_ratio,
            step_lr_gamma=step_lr_gamma,
            step_lr_step_size=step_lr_step_size,
            training_batch_size=training_batch_size,
            training_crop_size=training_crop_size,
            validation_batch_size=validation_batch_size,
            validation_crop_size=validation_crop_size,
            validation_resize_size=validation_resize_size,
            warmup_cosine_lr_cycles=warmup_cosine_lr_cycles,
            warmup_cosine_lr_warmup_epochs=warmup_cosine_lr_warmup_epochs,
            weight_decay=weight_decay,
            weighted_loss=weighted_loss,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ams_gradient: Optional[str] = None,
             augmentations: Optional[str] = None,
             beta1: Optional[str] = None,
             beta2: Optional[str] = None,
             distributed: Optional[str] = None,
             early_stopping: Optional[str] = None,
             early_stopping_delay: Optional[str] = None,
             early_stopping_patience: Optional[str] = None,
             enable_onnx_normalization: Optional[str] = None,
             evaluation_frequency: Optional[str] = None,
             gradient_accumulation_step: Optional[str] = None,
             layers_to_freeze: Optional[str] = None,
             learning_rate: Optional[str] = None,
             learning_rate_scheduler: Optional[str] = None,
             model_name: Optional[str] = None,
             momentum: Optional[str] = None,
             nesterov: Optional[str] = None,
             number_of_epochs: Optional[str] = None,
             number_of_workers: Optional[str] = None,
             optimizer: Optional[str] = None,
             random_seed: Optional[str] = None,
             split_ratio: Optional[str] = None,
             step_lr_gamma: Optional[str] = None,
             step_lr_step_size: Optional[str] = None,
             training_batch_size: Optional[str] = None,
             training_crop_size: Optional[str] = None,
             validation_batch_size: Optional[str] = None,
             validation_crop_size: Optional[str] = None,
             validation_resize_size: Optional[str] = None,
             warmup_cosine_lr_cycles: Optional[str] = None,
             warmup_cosine_lr_warmup_epochs: Optional[str] = None,
             weight_decay: Optional[str] = None,
             weighted_loss: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ams_gradient is None and 'amsGradient' in kwargs:
            ams_gradient = kwargs['amsGradient']
        if early_stopping is None and 'earlyStopping' in kwargs:
            early_stopping = kwargs['earlyStopping']
        if early_stopping_delay is None and 'earlyStoppingDelay' in kwargs:
            early_stopping_delay = kwargs['earlyStoppingDelay']
        if early_stopping_patience is None and 'earlyStoppingPatience' in kwargs:
            early_stopping_patience = kwargs['earlyStoppingPatience']
        if enable_onnx_normalization is None and 'enableOnnxNormalization' in kwargs:
            enable_onnx_normalization = kwargs['enableOnnxNormalization']
        if evaluation_frequency is None and 'evaluationFrequency' in kwargs:
            evaluation_frequency = kwargs['evaluationFrequency']
        if gradient_accumulation_step is None and 'gradientAccumulationStep' in kwargs:
            gradient_accumulation_step = kwargs['gradientAccumulationStep']
        if layers_to_freeze is None and 'layersToFreeze' in kwargs:
            layers_to_freeze = kwargs['layersToFreeze']
        if learning_rate is None and 'learningRate' in kwargs:
            learning_rate = kwargs['learningRate']
        if learning_rate_scheduler is None and 'learningRateScheduler' in kwargs:
            learning_rate_scheduler = kwargs['learningRateScheduler']
        if model_name is None and 'modelName' in kwargs:
            model_name = kwargs['modelName']
        if number_of_epochs is None and 'numberOfEpochs' in kwargs:
            number_of_epochs = kwargs['numberOfEpochs']
        if number_of_workers is None and 'numberOfWorkers' in kwargs:
            number_of_workers = kwargs['numberOfWorkers']
        if random_seed is None and 'randomSeed' in kwargs:
            random_seed = kwargs['randomSeed']
        if split_ratio is None and 'splitRatio' in kwargs:
            split_ratio = kwargs['splitRatio']
        if step_lr_gamma is None and 'stepLRGamma' in kwargs:
            step_lr_gamma = kwargs['stepLRGamma']
        if step_lr_step_size is None and 'stepLRStepSize' in kwargs:
            step_lr_step_size = kwargs['stepLRStepSize']
        if training_batch_size is None and 'trainingBatchSize' in kwargs:
            training_batch_size = kwargs['trainingBatchSize']
        if training_crop_size is None and 'trainingCropSize' in kwargs:
            training_crop_size = kwargs['trainingCropSize']
        if validation_batch_size is None and 'validationBatchSize' in kwargs:
            validation_batch_size = kwargs['validationBatchSize']
        if validation_crop_size is None and 'validationCropSize' in kwargs:
            validation_crop_size = kwargs['validationCropSize']
        if validation_resize_size is None and 'validationResizeSize' in kwargs:
            validation_resize_size = kwargs['validationResizeSize']
        if warmup_cosine_lr_cycles is None and 'warmupCosineLRCycles' in kwargs:
            warmup_cosine_lr_cycles = kwargs['warmupCosineLRCycles']
        if warmup_cosine_lr_warmup_epochs is None and 'warmupCosineLRWarmupEpochs' in kwargs:
            warmup_cosine_lr_warmup_epochs = kwargs['warmupCosineLRWarmupEpochs']
        if weight_decay is None and 'weightDecay' in kwargs:
            weight_decay = kwargs['weightDecay']
        if weighted_loss is None and 'weightedLoss' in kwargs:
            weighted_loss = kwargs['weightedLoss']

        if ams_gradient is not None:
            _setter("ams_gradient", ams_gradient)
        if augmentations is not None:
            _setter("augmentations", augmentations)
        if beta1 is not None:
            _setter("beta1", beta1)
        if beta2 is not None:
            _setter("beta2", beta2)
        if distributed is not None:
            _setter("distributed", distributed)
        if early_stopping is not None:
            _setter("early_stopping", early_stopping)
        if early_stopping_delay is not None:
            _setter("early_stopping_delay", early_stopping_delay)
        if early_stopping_patience is not None:
            _setter("early_stopping_patience", early_stopping_patience)
        if enable_onnx_normalization is not None:
            _setter("enable_onnx_normalization", enable_onnx_normalization)
        if evaluation_frequency is not None:
            _setter("evaluation_frequency", evaluation_frequency)
        if gradient_accumulation_step is not None:
            _setter("gradient_accumulation_step", gradient_accumulation_step)
        if layers_to_freeze is not None:
            _setter("layers_to_freeze", layers_to_freeze)
        if learning_rate is not None:
            _setter("learning_rate", learning_rate)
        if learning_rate_scheduler is not None:
            _setter("learning_rate_scheduler", learning_rate_scheduler)
        if model_name is not None:
            _setter("model_name", model_name)
        if momentum is not None:
            _setter("momentum", momentum)
        if nesterov is not None:
            _setter("nesterov", nesterov)
        if number_of_epochs is not None:
            _setter("number_of_epochs", number_of_epochs)
        if number_of_workers is not None:
            _setter("number_of_workers", number_of_workers)
        if optimizer is not None:
            _setter("optimizer", optimizer)
        if random_seed is not None:
            _setter("random_seed", random_seed)
        if split_ratio is not None:
            _setter("split_ratio", split_ratio)
        if step_lr_gamma is not None:
            _setter("step_lr_gamma", step_lr_gamma)
        if step_lr_step_size is not None:
            _setter("step_lr_step_size", step_lr_step_size)
        if training_batch_size is not None:
            _setter("training_batch_size", training_batch_size)
        if training_crop_size is not None:
            _setter("training_crop_size", training_crop_size)
        if validation_batch_size is not None:
            _setter("validation_batch_size", validation_batch_size)
        if validation_crop_size is not None:
            _setter("validation_crop_size", validation_crop_size)
        if validation_resize_size is not None:
            _setter("validation_resize_size", validation_resize_size)
        if warmup_cosine_lr_cycles is not None:
            _setter("warmup_cosine_lr_cycles", warmup_cosine_lr_cycles)
        if warmup_cosine_lr_warmup_epochs is not None:
            _setter("warmup_cosine_lr_warmup_epochs", warmup_cosine_lr_warmup_epochs)
        if weight_decay is not None:
            _setter("weight_decay", weight_decay)
        if weighted_loss is not None:
            _setter("weighted_loss", weighted_loss)

    @property
    @pulumi.getter(name="amsGradient")
    def ams_gradient(self) -> Optional[str]:
        """
        Enable AMSGrad when optimizer is 'adam' or 'adamw'.
        """
        return pulumi.get(self, "ams_gradient")

    @property
    @pulumi.getter
    def augmentations(self) -> Optional[str]:
        """
        Settings for using Augmentations.
        """
        return pulumi.get(self, "augmentations")

    @property
    @pulumi.getter
    def beta1(self) -> Optional[str]:
        """
        Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "beta1")

    @property
    @pulumi.getter
    def beta2(self) -> Optional[str]:
        """
        Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "beta2")

    @property
    @pulumi.getter
    def distributed(self) -> Optional[str]:
        """
        Whether to use distributer training.
        """
        return pulumi.get(self, "distributed")

    @property
    @pulumi.getter(name="earlyStopping")
    def early_stopping(self) -> Optional[str]:
        """
        Enable early stopping logic during training.
        """
        return pulumi.get(self, "early_stopping")

    @property
    @pulumi.getter(name="earlyStoppingDelay")
    def early_stopping_delay(self) -> Optional[str]:
        """
        Minimum number of epochs or validation evaluations to wait before primary metric improvement
        is tracked for early stopping. Must be a positive integer.
        """
        return pulumi.get(self, "early_stopping_delay")

    @property
    @pulumi.getter(name="earlyStoppingPatience")
    def early_stopping_patience(self) -> Optional[str]:
        """
        Minimum number of epochs or validation evaluations with no primary metric improvement before
        the run is stopped. Must be a positive integer.
        """
        return pulumi.get(self, "early_stopping_patience")

    @property
    @pulumi.getter(name="enableOnnxNormalization")
    def enable_onnx_normalization(self) -> Optional[str]:
        """
        Enable normalization when exporting ONNX model.
        """
        return pulumi.get(self, "enable_onnx_normalization")

    @property
    @pulumi.getter(name="evaluationFrequency")
    def evaluation_frequency(self) -> Optional[str]:
        """
        Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
        """
        return pulumi.get(self, "evaluation_frequency")

    @property
    @pulumi.getter(name="gradientAccumulationStep")
    def gradient_accumulation_step(self) -> Optional[str]:
        """
        Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
        updating the model weights while accumulating the gradients of those steps, and then using
        the accumulated gradients to compute the weight updates. Must be a positive integer.
        """
        return pulumi.get(self, "gradient_accumulation_step")

    @property
    @pulumi.getter(name="layersToFreeze")
    def layers_to_freeze(self) -> Optional[str]:
        """
        Number of layers to freeze for the model. Must be a positive integer.
        For instance, passing 2 as value for 'seresnext' means
        freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
        see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        """
        return pulumi.get(self, "layers_to_freeze")

    @property
    @pulumi.getter(name="learningRate")
    def learning_rate(self) -> Optional[str]:
        """
        Initial learning rate. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "learning_rate")

    @property
    @pulumi.getter(name="learningRateScheduler")
    def learning_rate_scheduler(self) -> Optional[str]:
        """
        Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
        """
        return pulumi.get(self, "learning_rate_scheduler")

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[str]:
        """
        Name of the model to use for training.
        For more information on the available models please visit the official documentation:
        https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        """
        return pulumi.get(self, "model_name")

    @property
    @pulumi.getter
    def momentum(self) -> Optional[str]:
        """
        Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "momentum")

    @property
    @pulumi.getter
    def nesterov(self) -> Optional[str]:
        """
        Enable nesterov when optimizer is 'sgd'.
        """
        return pulumi.get(self, "nesterov")

    @property
    @pulumi.getter(name="numberOfEpochs")
    def number_of_epochs(self) -> Optional[str]:
        """
        Number of training epochs. Must be a positive integer.
        """
        return pulumi.get(self, "number_of_epochs")

    @property
    @pulumi.getter(name="numberOfWorkers")
    def number_of_workers(self) -> Optional[str]:
        """
        Number of data loader workers. Must be a non-negative integer.
        """
        return pulumi.get(self, "number_of_workers")

    @property
    @pulumi.getter
    def optimizer(self) -> Optional[str]:
        """
        Type of optimizer. Must be either 'sgd', 'adam', or 'adamw'.
        """
        return pulumi.get(self, "optimizer")

    @property
    @pulumi.getter(name="randomSeed")
    def random_seed(self) -> Optional[str]:
        """
        Random seed to be used when using deterministic training.
        """
        return pulumi.get(self, "random_seed")

    @property
    @pulumi.getter(name="splitRatio")
    def split_ratio(self) -> Optional[str]:
        """
        If validation data is not defined, this specifies the split ratio for splitting
        train data into random train and validation subsets. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "split_ratio")

    @property
    @pulumi.getter(name="stepLRGamma")
    def step_lr_gamma(self) -> Optional[str]:
        """
        Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "step_lr_gamma")

    @property
    @pulumi.getter(name="stepLRStepSize")
    def step_lr_step_size(self) -> Optional[str]:
        """
        Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
        """
        return pulumi.get(self, "step_lr_step_size")

    @property
    @pulumi.getter(name="trainingBatchSize")
    def training_batch_size(self) -> Optional[str]:
        """
        Training batch size. Must be a positive integer.
        """
        return pulumi.get(self, "training_batch_size")

    @property
    @pulumi.getter(name="trainingCropSize")
    def training_crop_size(self) -> Optional[str]:
        """
        Image crop size that is input to the neural network for the training dataset. Must be a positive integer.
        """
        return pulumi.get(self, "training_crop_size")

    @property
    @pulumi.getter(name="validationBatchSize")
    def validation_batch_size(self) -> Optional[str]:
        """
        Validation batch size. Must be a positive integer.
        """
        return pulumi.get(self, "validation_batch_size")

    @property
    @pulumi.getter(name="validationCropSize")
    def validation_crop_size(self) -> Optional[str]:
        """
        Image crop size that is input to the neural network for the validation dataset. Must be a positive integer.
        """
        return pulumi.get(self, "validation_crop_size")

    @property
    @pulumi.getter(name="validationResizeSize")
    def validation_resize_size(self) -> Optional[str]:
        """
        Image size to which to resize before cropping for validation dataset. Must be a positive integer.
        """
        return pulumi.get(self, "validation_resize_size")

    @property
    @pulumi.getter(name="warmupCosineLRCycles")
    def warmup_cosine_lr_cycles(self) -> Optional[str]:
        """
        Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "warmup_cosine_lr_cycles")

    @property
    @pulumi.getter(name="warmupCosineLRWarmupEpochs")
    def warmup_cosine_lr_warmup_epochs(self) -> Optional[str]:
        """
        Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
        """
        return pulumi.get(self, "warmup_cosine_lr_warmup_epochs")

    @property
    @pulumi.getter(name="weightDecay")
    def weight_decay(self) -> Optional[str]:
        """
        Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
        """
        return pulumi.get(self, "weight_decay")

    @property
    @pulumi.getter(name="weightedLoss")
    def weighted_loss(self) -> Optional[str]:
        """
        Weighted loss. The accepted values are 0 for no weighted loss.
        1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be 0 or 1 or 2.
        """
        return pulumi.get(self, "weighted_loss")


@pulumi.output_type
class ImageModelDistributionSettingsObjectDetectionResponse(dict):
    """
    Distribution expressions to sweep over values of model settings.
    <example>
    Some examples are:
    <code>
    ModelName = "choice('seresnext', 'resnest50')";
    LearningRate = "uniform(0.001, 0.01)";
    LayersToFreeze = "choice(0, 2)";
    </code></example>
    For more details on how to compose distribution expressions please check the documentation:
    https://docs.microsoft.com/en-us/azure/machine-learning/how-to-tune-hyperparameters
    For more information on the available settings please visit the official documentation:
    https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amsGradient":
            suggest = "ams_gradient"
        elif key == "boxDetectionsPerImage":
            suggest = "box_detections_per_image"
        elif key == "boxScoreThreshold":
            suggest = "box_score_threshold"
        elif key == "earlyStopping":
            suggest = "early_stopping"
        elif key == "earlyStoppingDelay":
            suggest = "early_stopping_delay"
        elif key == "earlyStoppingPatience":
            suggest = "early_stopping_patience"
        elif key == "enableOnnxNormalization":
            suggest = "enable_onnx_normalization"
        elif key == "evaluationFrequency":
            suggest = "evaluation_frequency"
        elif key == "gradientAccumulationStep":
            suggest = "gradient_accumulation_step"
        elif key == "imageSize":
            suggest = "image_size"
        elif key == "layersToFreeze":
            suggest = "layers_to_freeze"
        elif key == "learningRate":
            suggest = "learning_rate"
        elif key == "learningRateScheduler":
            suggest = "learning_rate_scheduler"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "modelName":
            suggest = "model_name"
        elif key == "modelSize":
            suggest = "model_size"
        elif key == "multiScale":
            suggest = "multi_scale"
        elif key == "nmsIouThreshold":
            suggest = "nms_iou_threshold"
        elif key == "numberOfEpochs":
            suggest = "number_of_epochs"
        elif key == "numberOfWorkers":
            suggest = "number_of_workers"
        elif key == "randomSeed":
            suggest = "random_seed"
        elif key == "splitRatio":
            suggest = "split_ratio"
        elif key == "stepLRGamma":
            suggest = "step_lr_gamma"
        elif key == "stepLRStepSize":
            suggest = "step_lr_step_size"
        elif key == "tileGridSize":
            suggest = "tile_grid_size"
        elif key == "tileOverlapRatio":
            suggest = "tile_overlap_ratio"
        elif key == "tilePredictionsNmsThreshold":
            suggest = "tile_predictions_nms_threshold"
        elif key == "trainingBatchSize":
            suggest = "training_batch_size"
        elif key == "validationBatchSize":
            suggest = "validation_batch_size"
        elif key == "validationIouThreshold":
            suggest = "validation_iou_threshold"
        elif key == "validationMetricType":
            suggest = "validation_metric_type"
        elif key == "warmupCosineLRCycles":
            suggest = "warmup_cosine_lr_cycles"
        elif key == "warmupCosineLRWarmupEpochs":
            suggest = "warmup_cosine_lr_warmup_epochs"
        elif key == "weightDecay":
            suggest = "weight_decay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageModelDistributionSettingsObjectDetectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageModelDistributionSettingsObjectDetectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageModelDistributionSettingsObjectDetectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ams_gradient: Optional[str] = None,
                 augmentations: Optional[str] = None,
                 beta1: Optional[str] = None,
                 beta2: Optional[str] = None,
                 box_detections_per_image: Optional[str] = None,
                 box_score_threshold: Optional[str] = None,
                 distributed: Optional[str] = None,
                 early_stopping: Optional[str] = None,
                 early_stopping_delay: Optional[str] = None,
                 early_stopping_patience: Optional[str] = None,
                 enable_onnx_normalization: Optional[str] = None,
                 evaluation_frequency: Optional[str] = None,
                 gradient_accumulation_step: Optional[str] = None,
                 image_size: Optional[str] = None,
                 layers_to_freeze: Optional[str] = None,
                 learning_rate: Optional[str] = None,
                 learning_rate_scheduler: Optional[str] = None,
                 max_size: Optional[str] = None,
                 min_size: Optional[str] = None,
                 model_name: Optional[str] = None,
                 model_size: Optional[str] = None,
                 momentum: Optional[str] = None,
                 multi_scale: Optional[str] = None,
                 nesterov: Optional[str] = None,
                 nms_iou_threshold: Optional[str] = None,
                 number_of_epochs: Optional[str] = None,
                 number_of_workers: Optional[str] = None,
                 optimizer: Optional[str] = None,
                 random_seed: Optional[str] = None,
                 split_ratio: Optional[str] = None,
                 step_lr_gamma: Optional[str] = None,
                 step_lr_step_size: Optional[str] = None,
                 tile_grid_size: Optional[str] = None,
                 tile_overlap_ratio: Optional[str] = None,
                 tile_predictions_nms_threshold: Optional[str] = None,
                 training_batch_size: Optional[str] = None,
                 validation_batch_size: Optional[str] = None,
                 validation_iou_threshold: Optional[str] = None,
                 validation_metric_type: Optional[str] = None,
                 warmup_cosine_lr_cycles: Optional[str] = None,
                 warmup_cosine_lr_warmup_epochs: Optional[str] = None,
                 weight_decay: Optional[str] = None):
        """
        Distribution expressions to sweep over values of model settings.
        <example>
        Some examples are:
        <code>
        ModelName = "choice('seresnext', 'resnest50')";
        LearningRate = "uniform(0.001, 0.01)";
        LayersToFreeze = "choice(0, 2)";
        </code></example>
        For more details on how to compose distribution expressions please check the documentation:
        https://docs.microsoft.com/en-us/azure/machine-learning/how-to-tune-hyperparameters
        For more information on the available settings please visit the official documentation:
        https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param str ams_gradient: Enable AMSGrad when optimizer is 'adam' or 'adamw'.
        :param str augmentations: Settings for using Augmentations.
        :param str beta1: Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        :param str beta2: Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        :param str box_detections_per_image: Maximum number of detections per image, for all classes. Must be a positive integer.
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param str box_score_threshold: During inference, only return proposals with a classification score greater than
               BoxScoreThreshold. Must be a float in the range[0, 1].
        :param str distributed: Whether to use distributer training.
        :param str early_stopping: Enable early stopping logic during training.
        :param str early_stopping_delay: Minimum number of epochs or validation evaluations to wait before primary metric improvement
               is tracked for early stopping. Must be a positive integer.
        :param str early_stopping_patience: Minimum number of epochs or validation evaluations with no primary metric improvement before
               the run is stopped. Must be a positive integer.
        :param str enable_onnx_normalization: Enable normalization when exporting ONNX model.
        :param str evaluation_frequency: Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
        :param str gradient_accumulation_step: Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
               updating the model weights while accumulating the gradients of those steps, and then using
               the accumulated gradients to compute the weight updates. Must be a positive integer.
        :param str image_size: Image size for train and validation. Must be a positive integer.
               Note: The training run may get into CUDA OOM if the size is too big.
               Note: This settings is only supported for the 'yolov5' algorithm.
        :param str layers_to_freeze: Number of layers to freeze for the model. Must be a positive integer.
               For instance, passing 2 as value for 'seresnext' means
               freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
               see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param str learning_rate: Initial learning rate. Must be a float in the range [0, 1].
        :param str learning_rate_scheduler: Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
        :param str max_size: Maximum size of the image to be rescaled before feeding it to the backbone.
               Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param str min_size: Minimum size of the image to be rescaled before feeding it to the backbone.
               Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param str model_name: Name of the model to use for training.
               For more information on the available models please visit the official documentation:
               https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param str model_size: Model size. Must be 'small', 'medium', 'large', or 'xlarge'.
               Note: training run may get into CUDA OOM if the model size is too big.
               Note: This settings is only supported for the 'yolov5' algorithm.
        :param str momentum: Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
        :param str multi_scale: Enable multi-scale image by varying image size by +/- 50%.
               Note: training run may get into CUDA OOM if no sufficient GPU memory.
               Note: This settings is only supported for the 'yolov5' algorithm.
        :param str nesterov: Enable nesterov when optimizer is 'sgd'.
        :param str nms_iou_threshold: IOU threshold used during inference in NMS post processing. Must be float in the range [0, 1].
        :param str number_of_epochs: Number of training epochs. Must be a positive integer.
        :param str number_of_workers: Number of data loader workers. Must be a non-negative integer.
        :param str optimizer: Type of optimizer. Must be either 'sgd', 'adam', or 'adamw'.
        :param str random_seed: Random seed to be used when using deterministic training.
        :param str split_ratio: If validation data is not defined, this specifies the split ratio for splitting
               train data into random train and validation subsets. Must be a float in the range [0, 1].
        :param str step_lr_gamma: Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
        :param str step_lr_step_size: Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
        :param str tile_grid_size: The grid size to use for tiling each image. Note: TileGridSize must not be
               None to enable small object detection logic. A string containing two integers in mxn format.
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param str tile_overlap_ratio: Overlap ratio between adjacent tiles in each dimension. Must be float in the range [0, 1).
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param str tile_predictions_nms_threshold: The IOU threshold to use to perform NMS while merging predictions from tiles and image.
               Used in validation/ inference. Must be float in the range [0, 1].
               Note: This settings is not supported for the 'yolov5' algorithm.
               NMS: Non-maximum suppression
        :param str training_batch_size: Training batch size. Must be a positive integer.
        :param str validation_batch_size: Validation batch size. Must be a positive integer.
        :param str validation_iou_threshold: IOU threshold to use when computing validation metric. Must be float in the range [0, 1].
        :param str validation_metric_type: Metric computation method to use for validation metrics. Must be 'none', 'coco', 'voc', or 'coco_voc'.
        :param str warmup_cosine_lr_cycles: Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
        :param str warmup_cosine_lr_warmup_epochs: Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
        :param str weight_decay: Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
        """
        ImageModelDistributionSettingsObjectDetectionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ams_gradient=ams_gradient,
            augmentations=augmentations,
            beta1=beta1,
            beta2=beta2,
            box_detections_per_image=box_detections_per_image,
            box_score_threshold=box_score_threshold,
            distributed=distributed,
            early_stopping=early_stopping,
            early_stopping_delay=early_stopping_delay,
            early_stopping_patience=early_stopping_patience,
            enable_onnx_normalization=enable_onnx_normalization,
            evaluation_frequency=evaluation_frequency,
            gradient_accumulation_step=gradient_accumulation_step,
            image_size=image_size,
            layers_to_freeze=layers_to_freeze,
            learning_rate=learning_rate,
            learning_rate_scheduler=learning_rate_scheduler,
            max_size=max_size,
            min_size=min_size,
            model_name=model_name,
            model_size=model_size,
            momentum=momentum,
            multi_scale=multi_scale,
            nesterov=nesterov,
            nms_iou_threshold=nms_iou_threshold,
            number_of_epochs=number_of_epochs,
            number_of_workers=number_of_workers,
            optimizer=optimizer,
            random_seed=random_seed,
            split_ratio=split_ratio,
            step_lr_gamma=step_lr_gamma,
            step_lr_step_size=step_lr_step_size,
            tile_grid_size=tile_grid_size,
            tile_overlap_ratio=tile_overlap_ratio,
            tile_predictions_nms_threshold=tile_predictions_nms_threshold,
            training_batch_size=training_batch_size,
            validation_batch_size=validation_batch_size,
            validation_iou_threshold=validation_iou_threshold,
            validation_metric_type=validation_metric_type,
            warmup_cosine_lr_cycles=warmup_cosine_lr_cycles,
            warmup_cosine_lr_warmup_epochs=warmup_cosine_lr_warmup_epochs,
            weight_decay=weight_decay,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ams_gradient: Optional[str] = None,
             augmentations: Optional[str] = None,
             beta1: Optional[str] = None,
             beta2: Optional[str] = None,
             box_detections_per_image: Optional[str] = None,
             box_score_threshold: Optional[str] = None,
             distributed: Optional[str] = None,
             early_stopping: Optional[str] = None,
             early_stopping_delay: Optional[str] = None,
             early_stopping_patience: Optional[str] = None,
             enable_onnx_normalization: Optional[str] = None,
             evaluation_frequency: Optional[str] = None,
             gradient_accumulation_step: Optional[str] = None,
             image_size: Optional[str] = None,
             layers_to_freeze: Optional[str] = None,
             learning_rate: Optional[str] = None,
             learning_rate_scheduler: Optional[str] = None,
             max_size: Optional[str] = None,
             min_size: Optional[str] = None,
             model_name: Optional[str] = None,
             model_size: Optional[str] = None,
             momentum: Optional[str] = None,
             multi_scale: Optional[str] = None,
             nesterov: Optional[str] = None,
             nms_iou_threshold: Optional[str] = None,
             number_of_epochs: Optional[str] = None,
             number_of_workers: Optional[str] = None,
             optimizer: Optional[str] = None,
             random_seed: Optional[str] = None,
             split_ratio: Optional[str] = None,
             step_lr_gamma: Optional[str] = None,
             step_lr_step_size: Optional[str] = None,
             tile_grid_size: Optional[str] = None,
             tile_overlap_ratio: Optional[str] = None,
             tile_predictions_nms_threshold: Optional[str] = None,
             training_batch_size: Optional[str] = None,
             validation_batch_size: Optional[str] = None,
             validation_iou_threshold: Optional[str] = None,
             validation_metric_type: Optional[str] = None,
             warmup_cosine_lr_cycles: Optional[str] = None,
             warmup_cosine_lr_warmup_epochs: Optional[str] = None,
             weight_decay: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ams_gradient is None and 'amsGradient' in kwargs:
            ams_gradient = kwargs['amsGradient']
        if box_detections_per_image is None and 'boxDetectionsPerImage' in kwargs:
            box_detections_per_image = kwargs['boxDetectionsPerImage']
        if box_score_threshold is None and 'boxScoreThreshold' in kwargs:
            box_score_threshold = kwargs['boxScoreThreshold']
        if early_stopping is None and 'earlyStopping' in kwargs:
            early_stopping = kwargs['earlyStopping']
        if early_stopping_delay is None and 'earlyStoppingDelay' in kwargs:
            early_stopping_delay = kwargs['earlyStoppingDelay']
        if early_stopping_patience is None and 'earlyStoppingPatience' in kwargs:
            early_stopping_patience = kwargs['earlyStoppingPatience']
        if enable_onnx_normalization is None and 'enableOnnxNormalization' in kwargs:
            enable_onnx_normalization = kwargs['enableOnnxNormalization']
        if evaluation_frequency is None and 'evaluationFrequency' in kwargs:
            evaluation_frequency = kwargs['evaluationFrequency']
        if gradient_accumulation_step is None and 'gradientAccumulationStep' in kwargs:
            gradient_accumulation_step = kwargs['gradientAccumulationStep']
        if image_size is None and 'imageSize' in kwargs:
            image_size = kwargs['imageSize']
        if layers_to_freeze is None and 'layersToFreeze' in kwargs:
            layers_to_freeze = kwargs['layersToFreeze']
        if learning_rate is None and 'learningRate' in kwargs:
            learning_rate = kwargs['learningRate']
        if learning_rate_scheduler is None and 'learningRateScheduler' in kwargs:
            learning_rate_scheduler = kwargs['learningRateScheduler']
        if max_size is None and 'maxSize' in kwargs:
            max_size = kwargs['maxSize']
        if min_size is None and 'minSize' in kwargs:
            min_size = kwargs['minSize']
        if model_name is None and 'modelName' in kwargs:
            model_name = kwargs['modelName']
        if model_size is None and 'modelSize' in kwargs:
            model_size = kwargs['modelSize']
        if multi_scale is None and 'multiScale' in kwargs:
            multi_scale = kwargs['multiScale']
        if nms_iou_threshold is None and 'nmsIouThreshold' in kwargs:
            nms_iou_threshold = kwargs['nmsIouThreshold']
        if number_of_epochs is None and 'numberOfEpochs' in kwargs:
            number_of_epochs = kwargs['numberOfEpochs']
        if number_of_workers is None and 'numberOfWorkers' in kwargs:
            number_of_workers = kwargs['numberOfWorkers']
        if random_seed is None and 'randomSeed' in kwargs:
            random_seed = kwargs['randomSeed']
        if split_ratio is None and 'splitRatio' in kwargs:
            split_ratio = kwargs['splitRatio']
        if step_lr_gamma is None and 'stepLRGamma' in kwargs:
            step_lr_gamma = kwargs['stepLRGamma']
        if step_lr_step_size is None and 'stepLRStepSize' in kwargs:
            step_lr_step_size = kwargs['stepLRStepSize']
        if tile_grid_size is None and 'tileGridSize' in kwargs:
            tile_grid_size = kwargs['tileGridSize']
        if tile_overlap_ratio is None and 'tileOverlapRatio' in kwargs:
            tile_overlap_ratio = kwargs['tileOverlapRatio']
        if tile_predictions_nms_threshold is None and 'tilePredictionsNmsThreshold' in kwargs:
            tile_predictions_nms_threshold = kwargs['tilePredictionsNmsThreshold']
        if training_batch_size is None and 'trainingBatchSize' in kwargs:
            training_batch_size = kwargs['trainingBatchSize']
        if validation_batch_size is None and 'validationBatchSize' in kwargs:
            validation_batch_size = kwargs['validationBatchSize']
        if validation_iou_threshold is None and 'validationIouThreshold' in kwargs:
            validation_iou_threshold = kwargs['validationIouThreshold']
        if validation_metric_type is None and 'validationMetricType' in kwargs:
            validation_metric_type = kwargs['validationMetricType']
        if warmup_cosine_lr_cycles is None and 'warmupCosineLRCycles' in kwargs:
            warmup_cosine_lr_cycles = kwargs['warmupCosineLRCycles']
        if warmup_cosine_lr_warmup_epochs is None and 'warmupCosineLRWarmupEpochs' in kwargs:
            warmup_cosine_lr_warmup_epochs = kwargs['warmupCosineLRWarmupEpochs']
        if weight_decay is None and 'weightDecay' in kwargs:
            weight_decay = kwargs['weightDecay']

        if ams_gradient is not None:
            _setter("ams_gradient", ams_gradient)
        if augmentations is not None:
            _setter("augmentations", augmentations)
        if beta1 is not None:
            _setter("beta1", beta1)
        if beta2 is not None:
            _setter("beta2", beta2)
        if box_detections_per_image is not None:
            _setter("box_detections_per_image", box_detections_per_image)
        if box_score_threshold is not None:
            _setter("box_score_threshold", box_score_threshold)
        if distributed is not None:
            _setter("distributed", distributed)
        if early_stopping is not None:
            _setter("early_stopping", early_stopping)
        if early_stopping_delay is not None:
            _setter("early_stopping_delay", early_stopping_delay)
        if early_stopping_patience is not None:
            _setter("early_stopping_patience", early_stopping_patience)
        if enable_onnx_normalization is not None:
            _setter("enable_onnx_normalization", enable_onnx_normalization)
        if evaluation_frequency is not None:
            _setter("evaluation_frequency", evaluation_frequency)
        if gradient_accumulation_step is not None:
            _setter("gradient_accumulation_step", gradient_accumulation_step)
        if image_size is not None:
            _setter("image_size", image_size)
        if layers_to_freeze is not None:
            _setter("layers_to_freeze", layers_to_freeze)
        if learning_rate is not None:
            _setter("learning_rate", learning_rate)
        if learning_rate_scheduler is not None:
            _setter("learning_rate_scheduler", learning_rate_scheduler)
        if max_size is not None:
            _setter("max_size", max_size)
        if min_size is not None:
            _setter("min_size", min_size)
        if model_name is not None:
            _setter("model_name", model_name)
        if model_size is not None:
            _setter("model_size", model_size)
        if momentum is not None:
            _setter("momentum", momentum)
        if multi_scale is not None:
            _setter("multi_scale", multi_scale)
        if nesterov is not None:
            _setter("nesterov", nesterov)
        if nms_iou_threshold is not None:
            _setter("nms_iou_threshold", nms_iou_threshold)
        if number_of_epochs is not None:
            _setter("number_of_epochs", number_of_epochs)
        if number_of_workers is not None:
            _setter("number_of_workers", number_of_workers)
        if optimizer is not None:
            _setter("optimizer", optimizer)
        if random_seed is not None:
            _setter("random_seed", random_seed)
        if split_ratio is not None:
            _setter("split_ratio", split_ratio)
        if step_lr_gamma is not None:
            _setter("step_lr_gamma", step_lr_gamma)
        if step_lr_step_size is not None:
            _setter("step_lr_step_size", step_lr_step_size)
        if tile_grid_size is not None:
            _setter("tile_grid_size", tile_grid_size)
        if tile_overlap_ratio is not None:
            _setter("tile_overlap_ratio", tile_overlap_ratio)
        if tile_predictions_nms_threshold is not None:
            _setter("tile_predictions_nms_threshold", tile_predictions_nms_threshold)
        if training_batch_size is not None:
            _setter("training_batch_size", training_batch_size)
        if validation_batch_size is not None:
            _setter("validation_batch_size", validation_batch_size)
        if validation_iou_threshold is not None:
            _setter("validation_iou_threshold", validation_iou_threshold)
        if validation_metric_type is not None:
            _setter("validation_metric_type", validation_metric_type)
        if warmup_cosine_lr_cycles is not None:
            _setter("warmup_cosine_lr_cycles", warmup_cosine_lr_cycles)
        if warmup_cosine_lr_warmup_epochs is not None:
            _setter("warmup_cosine_lr_warmup_epochs", warmup_cosine_lr_warmup_epochs)
        if weight_decay is not None:
            _setter("weight_decay", weight_decay)

    @property
    @pulumi.getter(name="amsGradient")
    def ams_gradient(self) -> Optional[str]:
        """
        Enable AMSGrad when optimizer is 'adam' or 'adamw'.
        """
        return pulumi.get(self, "ams_gradient")

    @property
    @pulumi.getter
    def augmentations(self) -> Optional[str]:
        """
        Settings for using Augmentations.
        """
        return pulumi.get(self, "augmentations")

    @property
    @pulumi.getter
    def beta1(self) -> Optional[str]:
        """
        Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "beta1")

    @property
    @pulumi.getter
    def beta2(self) -> Optional[str]:
        """
        Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "beta2")

    @property
    @pulumi.getter(name="boxDetectionsPerImage")
    def box_detections_per_image(self) -> Optional[str]:
        """
        Maximum number of detections per image, for all classes. Must be a positive integer.
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "box_detections_per_image")

    @property
    @pulumi.getter(name="boxScoreThreshold")
    def box_score_threshold(self) -> Optional[str]:
        """
        During inference, only return proposals with a classification score greater than
        BoxScoreThreshold. Must be a float in the range[0, 1].
        """
        return pulumi.get(self, "box_score_threshold")

    @property
    @pulumi.getter
    def distributed(self) -> Optional[str]:
        """
        Whether to use distributer training.
        """
        return pulumi.get(self, "distributed")

    @property
    @pulumi.getter(name="earlyStopping")
    def early_stopping(self) -> Optional[str]:
        """
        Enable early stopping logic during training.
        """
        return pulumi.get(self, "early_stopping")

    @property
    @pulumi.getter(name="earlyStoppingDelay")
    def early_stopping_delay(self) -> Optional[str]:
        """
        Minimum number of epochs or validation evaluations to wait before primary metric improvement
        is tracked for early stopping. Must be a positive integer.
        """
        return pulumi.get(self, "early_stopping_delay")

    @property
    @pulumi.getter(name="earlyStoppingPatience")
    def early_stopping_patience(self) -> Optional[str]:
        """
        Minimum number of epochs or validation evaluations with no primary metric improvement before
        the run is stopped. Must be a positive integer.
        """
        return pulumi.get(self, "early_stopping_patience")

    @property
    @pulumi.getter(name="enableOnnxNormalization")
    def enable_onnx_normalization(self) -> Optional[str]:
        """
        Enable normalization when exporting ONNX model.
        """
        return pulumi.get(self, "enable_onnx_normalization")

    @property
    @pulumi.getter(name="evaluationFrequency")
    def evaluation_frequency(self) -> Optional[str]:
        """
        Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
        """
        return pulumi.get(self, "evaluation_frequency")

    @property
    @pulumi.getter(name="gradientAccumulationStep")
    def gradient_accumulation_step(self) -> Optional[str]:
        """
        Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
        updating the model weights while accumulating the gradients of those steps, and then using
        the accumulated gradients to compute the weight updates. Must be a positive integer.
        """
        return pulumi.get(self, "gradient_accumulation_step")

    @property
    @pulumi.getter(name="imageSize")
    def image_size(self) -> Optional[str]:
        """
        Image size for train and validation. Must be a positive integer.
        Note: The training run may get into CUDA OOM if the size is too big.
        Note: This settings is only supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "image_size")

    @property
    @pulumi.getter(name="layersToFreeze")
    def layers_to_freeze(self) -> Optional[str]:
        """
        Number of layers to freeze for the model. Must be a positive integer.
        For instance, passing 2 as value for 'seresnext' means
        freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
        see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        """
        return pulumi.get(self, "layers_to_freeze")

    @property
    @pulumi.getter(name="learningRate")
    def learning_rate(self) -> Optional[str]:
        """
        Initial learning rate. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "learning_rate")

    @property
    @pulumi.getter(name="learningRateScheduler")
    def learning_rate_scheduler(self) -> Optional[str]:
        """
        Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
        """
        return pulumi.get(self, "learning_rate_scheduler")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[str]:
        """
        Maximum size of the image to be rescaled before feeding it to the backbone.
        Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[str]:
        """
        Minimum size of the image to be rescaled before feeding it to the backbone.
        Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[str]:
        """
        Name of the model to use for training.
        For more information on the available models please visit the official documentation:
        https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        """
        return pulumi.get(self, "model_name")

    @property
    @pulumi.getter(name="modelSize")
    def model_size(self) -> Optional[str]:
        """
        Model size. Must be 'small', 'medium', 'large', or 'xlarge'.
        Note: training run may get into CUDA OOM if the model size is too big.
        Note: This settings is only supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "model_size")

    @property
    @pulumi.getter
    def momentum(self) -> Optional[str]:
        """
        Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "momentum")

    @property
    @pulumi.getter(name="multiScale")
    def multi_scale(self) -> Optional[str]:
        """
        Enable multi-scale image by varying image size by +/- 50%.
        Note: training run may get into CUDA OOM if no sufficient GPU memory.
        Note: This settings is only supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "multi_scale")

    @property
    @pulumi.getter
    def nesterov(self) -> Optional[str]:
        """
        Enable nesterov when optimizer is 'sgd'.
        """
        return pulumi.get(self, "nesterov")

    @property
    @pulumi.getter(name="nmsIouThreshold")
    def nms_iou_threshold(self) -> Optional[str]:
        """
        IOU threshold used during inference in NMS post processing. Must be float in the range [0, 1].
        """
        return pulumi.get(self, "nms_iou_threshold")

    @property
    @pulumi.getter(name="numberOfEpochs")
    def number_of_epochs(self) -> Optional[str]:
        """
        Number of training epochs. Must be a positive integer.
        """
        return pulumi.get(self, "number_of_epochs")

    @property
    @pulumi.getter(name="numberOfWorkers")
    def number_of_workers(self) -> Optional[str]:
        """
        Number of data loader workers. Must be a non-negative integer.
        """
        return pulumi.get(self, "number_of_workers")

    @property
    @pulumi.getter
    def optimizer(self) -> Optional[str]:
        """
        Type of optimizer. Must be either 'sgd', 'adam', or 'adamw'.
        """
        return pulumi.get(self, "optimizer")

    @property
    @pulumi.getter(name="randomSeed")
    def random_seed(self) -> Optional[str]:
        """
        Random seed to be used when using deterministic training.
        """
        return pulumi.get(self, "random_seed")

    @property
    @pulumi.getter(name="splitRatio")
    def split_ratio(self) -> Optional[str]:
        """
        If validation data is not defined, this specifies the split ratio for splitting
        train data into random train and validation subsets. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "split_ratio")

    @property
    @pulumi.getter(name="stepLRGamma")
    def step_lr_gamma(self) -> Optional[str]:
        """
        Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "step_lr_gamma")

    @property
    @pulumi.getter(name="stepLRStepSize")
    def step_lr_step_size(self) -> Optional[str]:
        """
        Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
        """
        return pulumi.get(self, "step_lr_step_size")

    @property
    @pulumi.getter(name="tileGridSize")
    def tile_grid_size(self) -> Optional[str]:
        """
        The grid size to use for tiling each image. Note: TileGridSize must not be
        None to enable small object detection logic. A string containing two integers in mxn format.
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "tile_grid_size")

    @property
    @pulumi.getter(name="tileOverlapRatio")
    def tile_overlap_ratio(self) -> Optional[str]:
        """
        Overlap ratio between adjacent tiles in each dimension. Must be float in the range [0, 1).
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "tile_overlap_ratio")

    @property
    @pulumi.getter(name="tilePredictionsNmsThreshold")
    def tile_predictions_nms_threshold(self) -> Optional[str]:
        """
        The IOU threshold to use to perform NMS while merging predictions from tiles and image.
        Used in validation/ inference. Must be float in the range [0, 1].
        Note: This settings is not supported for the 'yolov5' algorithm.
        NMS: Non-maximum suppression
        """
        return pulumi.get(self, "tile_predictions_nms_threshold")

    @property
    @pulumi.getter(name="trainingBatchSize")
    def training_batch_size(self) -> Optional[str]:
        """
        Training batch size. Must be a positive integer.
        """
        return pulumi.get(self, "training_batch_size")

    @property
    @pulumi.getter(name="validationBatchSize")
    def validation_batch_size(self) -> Optional[str]:
        """
        Validation batch size. Must be a positive integer.
        """
        return pulumi.get(self, "validation_batch_size")

    @property
    @pulumi.getter(name="validationIouThreshold")
    def validation_iou_threshold(self) -> Optional[str]:
        """
        IOU threshold to use when computing validation metric. Must be float in the range [0, 1].
        """
        return pulumi.get(self, "validation_iou_threshold")

    @property
    @pulumi.getter(name="validationMetricType")
    def validation_metric_type(self) -> Optional[str]:
        """
        Metric computation method to use for validation metrics. Must be 'none', 'coco', 'voc', or 'coco_voc'.
        """
        return pulumi.get(self, "validation_metric_type")

    @property
    @pulumi.getter(name="warmupCosineLRCycles")
    def warmup_cosine_lr_cycles(self) -> Optional[str]:
        """
        Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "warmup_cosine_lr_cycles")

    @property
    @pulumi.getter(name="warmupCosineLRWarmupEpochs")
    def warmup_cosine_lr_warmup_epochs(self) -> Optional[str]:
        """
        Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
        """
        return pulumi.get(self, "warmup_cosine_lr_warmup_epochs")

    @property
    @pulumi.getter(name="weightDecay")
    def weight_decay(self) -> Optional[str]:
        """
        Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
        """
        return pulumi.get(self, "weight_decay")


@pulumi.output_type
class ImageModelSettingsClassificationResponse(dict):
    """
    Settings used for training the model.
    For more information on the available settings please visit the official documentation:
    https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advancedSettings":
            suggest = "advanced_settings"
        elif key == "amsGradient":
            suggest = "ams_gradient"
        elif key == "checkpointDatasetId":
            suggest = "checkpoint_dataset_id"
        elif key == "checkpointFilename":
            suggest = "checkpoint_filename"
        elif key == "checkpointFrequency":
            suggest = "checkpoint_frequency"
        elif key == "checkpointRunId":
            suggest = "checkpoint_run_id"
        elif key == "earlyStopping":
            suggest = "early_stopping"
        elif key == "earlyStoppingDelay":
            suggest = "early_stopping_delay"
        elif key == "earlyStoppingPatience":
            suggest = "early_stopping_patience"
        elif key == "enableOnnxNormalization":
            suggest = "enable_onnx_normalization"
        elif key == "evaluationFrequency":
            suggest = "evaluation_frequency"
        elif key == "gradientAccumulationStep":
            suggest = "gradient_accumulation_step"
        elif key == "layersToFreeze":
            suggest = "layers_to_freeze"
        elif key == "learningRate":
            suggest = "learning_rate"
        elif key == "learningRateScheduler":
            suggest = "learning_rate_scheduler"
        elif key == "modelName":
            suggest = "model_name"
        elif key == "numberOfEpochs":
            suggest = "number_of_epochs"
        elif key == "numberOfWorkers":
            suggest = "number_of_workers"
        elif key == "randomSeed":
            suggest = "random_seed"
        elif key == "splitRatio":
            suggest = "split_ratio"
        elif key == "stepLRGamma":
            suggest = "step_lr_gamma"
        elif key == "stepLRStepSize":
            suggest = "step_lr_step_size"
        elif key == "trainingBatchSize":
            suggest = "training_batch_size"
        elif key == "trainingCropSize":
            suggest = "training_crop_size"
        elif key == "validationBatchSize":
            suggest = "validation_batch_size"
        elif key == "validationCropSize":
            suggest = "validation_crop_size"
        elif key == "validationResizeSize":
            suggest = "validation_resize_size"
        elif key == "warmupCosineLRCycles":
            suggest = "warmup_cosine_lr_cycles"
        elif key == "warmupCosineLRWarmupEpochs":
            suggest = "warmup_cosine_lr_warmup_epochs"
        elif key == "weightDecay":
            suggest = "weight_decay"
        elif key == "weightedLoss":
            suggest = "weighted_loss"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageModelSettingsClassificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageModelSettingsClassificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageModelSettingsClassificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advanced_settings: Optional[str] = None,
                 ams_gradient: Optional[bool] = None,
                 augmentations: Optional[str] = None,
                 beta1: Optional[float] = None,
                 beta2: Optional[float] = None,
                 checkpoint_dataset_id: Optional[str] = None,
                 checkpoint_filename: Optional[str] = None,
                 checkpoint_frequency: Optional[int] = None,
                 checkpoint_run_id: Optional[str] = None,
                 distributed: Optional[bool] = None,
                 early_stopping: Optional[bool] = None,
                 early_stopping_delay: Optional[int] = None,
                 early_stopping_patience: Optional[int] = None,
                 enable_onnx_normalization: Optional[bool] = None,
                 evaluation_frequency: Optional[int] = None,
                 gradient_accumulation_step: Optional[int] = None,
                 layers_to_freeze: Optional[int] = None,
                 learning_rate: Optional[float] = None,
                 learning_rate_scheduler: Optional[str] = None,
                 model_name: Optional[str] = None,
                 momentum: Optional[float] = None,
                 nesterov: Optional[bool] = None,
                 number_of_epochs: Optional[int] = None,
                 number_of_workers: Optional[int] = None,
                 optimizer: Optional[str] = None,
                 random_seed: Optional[int] = None,
                 split_ratio: Optional[float] = None,
                 step_lr_gamma: Optional[float] = None,
                 step_lr_step_size: Optional[int] = None,
                 training_batch_size: Optional[int] = None,
                 training_crop_size: Optional[int] = None,
                 validation_batch_size: Optional[int] = None,
                 validation_crop_size: Optional[int] = None,
                 validation_resize_size: Optional[int] = None,
                 warmup_cosine_lr_cycles: Optional[float] = None,
                 warmup_cosine_lr_warmup_epochs: Optional[int] = None,
                 weight_decay: Optional[float] = None,
                 weighted_loss: Optional[int] = None):
        """
        Settings used for training the model.
        For more information on the available settings please visit the official documentation:
        https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param str advanced_settings: Settings for advanced scenarios.
        :param bool ams_gradient: Enable AMSGrad when optimizer is 'adam' or 'adamw'.
        :param str augmentations: Settings for using Augmentations.
        :param float beta1: Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        :param float beta2: Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        :param str checkpoint_dataset_id: FileDataset id for pretrained checkpoint(s) for incremental training.
               Make sure to pass CheckpointFilename along with CheckpointDatasetId.
        :param str checkpoint_filename: The pretrained checkpoint filename in FileDataset for incremental training.
               Make sure to pass CheckpointDatasetId along with CheckpointFilename.
        :param int checkpoint_frequency: Frequency to store model checkpoints. Must be a positive integer.
        :param str checkpoint_run_id: The id of a previous run that has a pretrained checkpoint for incremental training.
        :param bool distributed: Whether to use distributed training.
        :param bool early_stopping: Enable early stopping logic during training.
        :param int early_stopping_delay: Minimum number of epochs or validation evaluations to wait before primary metric improvement
               is tracked for early stopping. Must be a positive integer.
        :param int early_stopping_patience: Minimum number of epochs or validation evaluations with no primary metric improvement before
               the run is stopped. Must be a positive integer.
        :param bool enable_onnx_normalization: Enable normalization when exporting ONNX model.
        :param int evaluation_frequency: Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
        :param int gradient_accumulation_step: Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
               updating the model weights while accumulating the gradients of those steps, and then using
               the accumulated gradients to compute the weight updates. Must be a positive integer.
        :param int layers_to_freeze: Number of layers to freeze for the model. Must be a positive integer.
               For instance, passing 2 as value for 'seresnext' means
               freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
               see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param float learning_rate: Initial learning rate. Must be a float in the range [0, 1].
        :param str learning_rate_scheduler: Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
        :param str model_name: Name of the model to use for training.
               For more information on the available models please visit the official documentation:
               https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param float momentum: Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
        :param bool nesterov: Enable nesterov when optimizer is 'sgd'.
        :param int number_of_epochs: Number of training epochs. Must be a positive integer.
        :param int number_of_workers: Number of data loader workers. Must be a non-negative integer.
        :param str optimizer: Type of optimizer.
        :param int random_seed: Random seed to be used when using deterministic training.
        :param float split_ratio: If validation data is not defined, this specifies the split ratio for splitting
               train data into random train and validation subsets. Must be a float in the range [0, 1].
        :param float step_lr_gamma: Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
        :param int step_lr_step_size: Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
        :param int training_batch_size: Training batch size. Must be a positive integer.
        :param int training_crop_size: Image crop size that is input to the neural network for the training dataset. Must be a positive integer.
        :param int validation_batch_size: Validation batch size. Must be a positive integer.
        :param int validation_crop_size: Image crop size that is input to the neural network for the validation dataset. Must be a positive integer.
        :param int validation_resize_size: Image size to which to resize before cropping for validation dataset. Must be a positive integer.
        :param float warmup_cosine_lr_cycles: Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
        :param int warmup_cosine_lr_warmup_epochs: Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
        :param float weight_decay: Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
        :param int weighted_loss: Weighted loss. The accepted values are 0 for no weighted loss.
               1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be 0 or 1 or 2.
        """
        ImageModelSettingsClassificationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            advanced_settings=advanced_settings,
            ams_gradient=ams_gradient,
            augmentations=augmentations,
            beta1=beta1,
            beta2=beta2,
            checkpoint_dataset_id=checkpoint_dataset_id,
            checkpoint_filename=checkpoint_filename,
            checkpoint_frequency=checkpoint_frequency,
            checkpoint_run_id=checkpoint_run_id,
            distributed=distributed,
            early_stopping=early_stopping,
            early_stopping_delay=early_stopping_delay,
            early_stopping_patience=early_stopping_patience,
            enable_onnx_normalization=enable_onnx_normalization,
            evaluation_frequency=evaluation_frequency,
            gradient_accumulation_step=gradient_accumulation_step,
            layers_to_freeze=layers_to_freeze,
            learning_rate=learning_rate,
            learning_rate_scheduler=learning_rate_scheduler,
            model_name=model_name,
            momentum=momentum,
            nesterov=nesterov,
            number_of_epochs=number_of_epochs,
            number_of_workers=number_of_workers,
            optimizer=optimizer,
            random_seed=random_seed,
            split_ratio=split_ratio,
            step_lr_gamma=step_lr_gamma,
            step_lr_step_size=step_lr_step_size,
            training_batch_size=training_batch_size,
            training_crop_size=training_crop_size,
            validation_batch_size=validation_batch_size,
            validation_crop_size=validation_crop_size,
            validation_resize_size=validation_resize_size,
            warmup_cosine_lr_cycles=warmup_cosine_lr_cycles,
            warmup_cosine_lr_warmup_epochs=warmup_cosine_lr_warmup_epochs,
            weight_decay=weight_decay,
            weighted_loss=weighted_loss,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             advanced_settings: Optional[str] = None,
             ams_gradient: Optional[bool] = None,
             augmentations: Optional[str] = None,
             beta1: Optional[float] = None,
             beta2: Optional[float] = None,
             checkpoint_dataset_id: Optional[str] = None,
             checkpoint_filename: Optional[str] = None,
             checkpoint_frequency: Optional[int] = None,
             checkpoint_run_id: Optional[str] = None,
             distributed: Optional[bool] = None,
             early_stopping: Optional[bool] = None,
             early_stopping_delay: Optional[int] = None,
             early_stopping_patience: Optional[int] = None,
             enable_onnx_normalization: Optional[bool] = None,
             evaluation_frequency: Optional[int] = None,
             gradient_accumulation_step: Optional[int] = None,
             layers_to_freeze: Optional[int] = None,
             learning_rate: Optional[float] = None,
             learning_rate_scheduler: Optional[str] = None,
             model_name: Optional[str] = None,
             momentum: Optional[float] = None,
             nesterov: Optional[bool] = None,
             number_of_epochs: Optional[int] = None,
             number_of_workers: Optional[int] = None,
             optimizer: Optional[str] = None,
             random_seed: Optional[int] = None,
             split_ratio: Optional[float] = None,
             step_lr_gamma: Optional[float] = None,
             step_lr_step_size: Optional[int] = None,
             training_batch_size: Optional[int] = None,
             training_crop_size: Optional[int] = None,
             validation_batch_size: Optional[int] = None,
             validation_crop_size: Optional[int] = None,
             validation_resize_size: Optional[int] = None,
             warmup_cosine_lr_cycles: Optional[float] = None,
             warmup_cosine_lr_warmup_epochs: Optional[int] = None,
             weight_decay: Optional[float] = None,
             weighted_loss: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if advanced_settings is None and 'advancedSettings' in kwargs:
            advanced_settings = kwargs['advancedSettings']
        if ams_gradient is None and 'amsGradient' in kwargs:
            ams_gradient = kwargs['amsGradient']
        if checkpoint_dataset_id is None and 'checkpointDatasetId' in kwargs:
            checkpoint_dataset_id = kwargs['checkpointDatasetId']
        if checkpoint_filename is None and 'checkpointFilename' in kwargs:
            checkpoint_filename = kwargs['checkpointFilename']
        if checkpoint_frequency is None and 'checkpointFrequency' in kwargs:
            checkpoint_frequency = kwargs['checkpointFrequency']
        if checkpoint_run_id is None and 'checkpointRunId' in kwargs:
            checkpoint_run_id = kwargs['checkpointRunId']
        if early_stopping is None and 'earlyStopping' in kwargs:
            early_stopping = kwargs['earlyStopping']
        if early_stopping_delay is None and 'earlyStoppingDelay' in kwargs:
            early_stopping_delay = kwargs['earlyStoppingDelay']
        if early_stopping_patience is None and 'earlyStoppingPatience' in kwargs:
            early_stopping_patience = kwargs['earlyStoppingPatience']
        if enable_onnx_normalization is None and 'enableOnnxNormalization' in kwargs:
            enable_onnx_normalization = kwargs['enableOnnxNormalization']
        if evaluation_frequency is None and 'evaluationFrequency' in kwargs:
            evaluation_frequency = kwargs['evaluationFrequency']
        if gradient_accumulation_step is None and 'gradientAccumulationStep' in kwargs:
            gradient_accumulation_step = kwargs['gradientAccumulationStep']
        if layers_to_freeze is None and 'layersToFreeze' in kwargs:
            layers_to_freeze = kwargs['layersToFreeze']
        if learning_rate is None and 'learningRate' in kwargs:
            learning_rate = kwargs['learningRate']
        if learning_rate_scheduler is None and 'learningRateScheduler' in kwargs:
            learning_rate_scheduler = kwargs['learningRateScheduler']
        if model_name is None and 'modelName' in kwargs:
            model_name = kwargs['modelName']
        if number_of_epochs is None and 'numberOfEpochs' in kwargs:
            number_of_epochs = kwargs['numberOfEpochs']
        if number_of_workers is None and 'numberOfWorkers' in kwargs:
            number_of_workers = kwargs['numberOfWorkers']
        if random_seed is None and 'randomSeed' in kwargs:
            random_seed = kwargs['randomSeed']
        if split_ratio is None and 'splitRatio' in kwargs:
            split_ratio = kwargs['splitRatio']
        if step_lr_gamma is None and 'stepLRGamma' in kwargs:
            step_lr_gamma = kwargs['stepLRGamma']
        if step_lr_step_size is None and 'stepLRStepSize' in kwargs:
            step_lr_step_size = kwargs['stepLRStepSize']
        if training_batch_size is None and 'trainingBatchSize' in kwargs:
            training_batch_size = kwargs['trainingBatchSize']
        if training_crop_size is None and 'trainingCropSize' in kwargs:
            training_crop_size = kwargs['trainingCropSize']
        if validation_batch_size is None and 'validationBatchSize' in kwargs:
            validation_batch_size = kwargs['validationBatchSize']
        if validation_crop_size is None and 'validationCropSize' in kwargs:
            validation_crop_size = kwargs['validationCropSize']
        if validation_resize_size is None and 'validationResizeSize' in kwargs:
            validation_resize_size = kwargs['validationResizeSize']
        if warmup_cosine_lr_cycles is None and 'warmupCosineLRCycles' in kwargs:
            warmup_cosine_lr_cycles = kwargs['warmupCosineLRCycles']
        if warmup_cosine_lr_warmup_epochs is None and 'warmupCosineLRWarmupEpochs' in kwargs:
            warmup_cosine_lr_warmup_epochs = kwargs['warmupCosineLRWarmupEpochs']
        if weight_decay is None and 'weightDecay' in kwargs:
            weight_decay = kwargs['weightDecay']
        if weighted_loss is None and 'weightedLoss' in kwargs:
            weighted_loss = kwargs['weightedLoss']

        if advanced_settings is not None:
            _setter("advanced_settings", advanced_settings)
        if ams_gradient is not None:
            _setter("ams_gradient", ams_gradient)
        if augmentations is not None:
            _setter("augmentations", augmentations)
        if beta1 is not None:
            _setter("beta1", beta1)
        if beta2 is not None:
            _setter("beta2", beta2)
        if checkpoint_dataset_id is not None:
            _setter("checkpoint_dataset_id", checkpoint_dataset_id)
        if checkpoint_filename is not None:
            _setter("checkpoint_filename", checkpoint_filename)
        if checkpoint_frequency is not None:
            _setter("checkpoint_frequency", checkpoint_frequency)
        if checkpoint_run_id is not None:
            _setter("checkpoint_run_id", checkpoint_run_id)
        if distributed is not None:
            _setter("distributed", distributed)
        if early_stopping is not None:
            _setter("early_stopping", early_stopping)
        if early_stopping_delay is not None:
            _setter("early_stopping_delay", early_stopping_delay)
        if early_stopping_patience is not None:
            _setter("early_stopping_patience", early_stopping_patience)
        if enable_onnx_normalization is not None:
            _setter("enable_onnx_normalization", enable_onnx_normalization)
        if evaluation_frequency is not None:
            _setter("evaluation_frequency", evaluation_frequency)
        if gradient_accumulation_step is not None:
            _setter("gradient_accumulation_step", gradient_accumulation_step)
        if layers_to_freeze is not None:
            _setter("layers_to_freeze", layers_to_freeze)
        if learning_rate is not None:
            _setter("learning_rate", learning_rate)
        if learning_rate_scheduler is None:
            learning_rate_scheduler = 'None'
        if learning_rate_scheduler is not None:
            _setter("learning_rate_scheduler", learning_rate_scheduler)
        if model_name is not None:
            _setter("model_name", model_name)
        if momentum is not None:
            _setter("momentum", momentum)
        if nesterov is not None:
            _setter("nesterov", nesterov)
        if number_of_epochs is not None:
            _setter("number_of_epochs", number_of_epochs)
        if number_of_workers is not None:
            _setter("number_of_workers", number_of_workers)
        if optimizer is None:
            optimizer = 'None'
        if optimizer is not None:
            _setter("optimizer", optimizer)
        if random_seed is not None:
            _setter("random_seed", random_seed)
        if split_ratio is not None:
            _setter("split_ratio", split_ratio)
        if step_lr_gamma is not None:
            _setter("step_lr_gamma", step_lr_gamma)
        if step_lr_step_size is not None:
            _setter("step_lr_step_size", step_lr_step_size)
        if training_batch_size is not None:
            _setter("training_batch_size", training_batch_size)
        if training_crop_size is not None:
            _setter("training_crop_size", training_crop_size)
        if validation_batch_size is not None:
            _setter("validation_batch_size", validation_batch_size)
        if validation_crop_size is not None:
            _setter("validation_crop_size", validation_crop_size)
        if validation_resize_size is not None:
            _setter("validation_resize_size", validation_resize_size)
        if warmup_cosine_lr_cycles is not None:
            _setter("warmup_cosine_lr_cycles", warmup_cosine_lr_cycles)
        if warmup_cosine_lr_warmup_epochs is not None:
            _setter("warmup_cosine_lr_warmup_epochs", warmup_cosine_lr_warmup_epochs)
        if weight_decay is not None:
            _setter("weight_decay", weight_decay)
        if weighted_loss is not None:
            _setter("weighted_loss", weighted_loss)

    @property
    @pulumi.getter(name="advancedSettings")
    def advanced_settings(self) -> Optional[str]:
        """
        Settings for advanced scenarios.
        """
        return pulumi.get(self, "advanced_settings")

    @property
    @pulumi.getter(name="amsGradient")
    def ams_gradient(self) -> Optional[bool]:
        """
        Enable AMSGrad when optimizer is 'adam' or 'adamw'.
        """
        return pulumi.get(self, "ams_gradient")

    @property
    @pulumi.getter
    def augmentations(self) -> Optional[str]:
        """
        Settings for using Augmentations.
        """
        return pulumi.get(self, "augmentations")

    @property
    @pulumi.getter
    def beta1(self) -> Optional[float]:
        """
        Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "beta1")

    @property
    @pulumi.getter
    def beta2(self) -> Optional[float]:
        """
        Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "beta2")

    @property
    @pulumi.getter(name="checkpointDatasetId")
    def checkpoint_dataset_id(self) -> Optional[str]:
        """
        FileDataset id for pretrained checkpoint(s) for incremental training.
        Make sure to pass CheckpointFilename along with CheckpointDatasetId.
        """
        return pulumi.get(self, "checkpoint_dataset_id")

    @property
    @pulumi.getter(name="checkpointFilename")
    def checkpoint_filename(self) -> Optional[str]:
        """
        The pretrained checkpoint filename in FileDataset for incremental training.
        Make sure to pass CheckpointDatasetId along with CheckpointFilename.
        """
        return pulumi.get(self, "checkpoint_filename")

    @property
    @pulumi.getter(name="checkpointFrequency")
    def checkpoint_frequency(self) -> Optional[int]:
        """
        Frequency to store model checkpoints. Must be a positive integer.
        """
        return pulumi.get(self, "checkpoint_frequency")

    @property
    @pulumi.getter(name="checkpointRunId")
    def checkpoint_run_id(self) -> Optional[str]:
        """
        The id of a previous run that has a pretrained checkpoint for incremental training.
        """
        return pulumi.get(self, "checkpoint_run_id")

    @property
    @pulumi.getter
    def distributed(self) -> Optional[bool]:
        """
        Whether to use distributed training.
        """
        return pulumi.get(self, "distributed")

    @property
    @pulumi.getter(name="earlyStopping")
    def early_stopping(self) -> Optional[bool]:
        """
        Enable early stopping logic during training.
        """
        return pulumi.get(self, "early_stopping")

    @property
    @pulumi.getter(name="earlyStoppingDelay")
    def early_stopping_delay(self) -> Optional[int]:
        """
        Minimum number of epochs or validation evaluations to wait before primary metric improvement
        is tracked for early stopping. Must be a positive integer.
        """
        return pulumi.get(self, "early_stopping_delay")

    @property
    @pulumi.getter(name="earlyStoppingPatience")
    def early_stopping_patience(self) -> Optional[int]:
        """
        Minimum number of epochs or validation evaluations with no primary metric improvement before
        the run is stopped. Must be a positive integer.
        """
        return pulumi.get(self, "early_stopping_patience")

    @property
    @pulumi.getter(name="enableOnnxNormalization")
    def enable_onnx_normalization(self) -> Optional[bool]:
        """
        Enable normalization when exporting ONNX model.
        """
        return pulumi.get(self, "enable_onnx_normalization")

    @property
    @pulumi.getter(name="evaluationFrequency")
    def evaluation_frequency(self) -> Optional[int]:
        """
        Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
        """
        return pulumi.get(self, "evaluation_frequency")

    @property
    @pulumi.getter(name="gradientAccumulationStep")
    def gradient_accumulation_step(self) -> Optional[int]:
        """
        Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
        updating the model weights while accumulating the gradients of those steps, and then using
        the accumulated gradients to compute the weight updates. Must be a positive integer.
        """
        return pulumi.get(self, "gradient_accumulation_step")

    @property
    @pulumi.getter(name="layersToFreeze")
    def layers_to_freeze(self) -> Optional[int]:
        """
        Number of layers to freeze for the model. Must be a positive integer.
        For instance, passing 2 as value for 'seresnext' means
        freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
        see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        """
        return pulumi.get(self, "layers_to_freeze")

    @property
    @pulumi.getter(name="learningRate")
    def learning_rate(self) -> Optional[float]:
        """
        Initial learning rate. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "learning_rate")

    @property
    @pulumi.getter(name="learningRateScheduler")
    def learning_rate_scheduler(self) -> Optional[str]:
        """
        Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
        """
        return pulumi.get(self, "learning_rate_scheduler")

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[str]:
        """
        Name of the model to use for training.
        For more information on the available models please visit the official documentation:
        https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        """
        return pulumi.get(self, "model_name")

    @property
    @pulumi.getter
    def momentum(self) -> Optional[float]:
        """
        Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "momentum")

    @property
    @pulumi.getter
    def nesterov(self) -> Optional[bool]:
        """
        Enable nesterov when optimizer is 'sgd'.
        """
        return pulumi.get(self, "nesterov")

    @property
    @pulumi.getter(name="numberOfEpochs")
    def number_of_epochs(self) -> Optional[int]:
        """
        Number of training epochs. Must be a positive integer.
        """
        return pulumi.get(self, "number_of_epochs")

    @property
    @pulumi.getter(name="numberOfWorkers")
    def number_of_workers(self) -> Optional[int]:
        """
        Number of data loader workers. Must be a non-negative integer.
        """
        return pulumi.get(self, "number_of_workers")

    @property
    @pulumi.getter
    def optimizer(self) -> Optional[str]:
        """
        Type of optimizer.
        """
        return pulumi.get(self, "optimizer")

    @property
    @pulumi.getter(name="randomSeed")
    def random_seed(self) -> Optional[int]:
        """
        Random seed to be used when using deterministic training.
        """
        return pulumi.get(self, "random_seed")

    @property
    @pulumi.getter(name="splitRatio")
    def split_ratio(self) -> Optional[float]:
        """
        If validation data is not defined, this specifies the split ratio for splitting
        train data into random train and validation subsets. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "split_ratio")

    @property
    @pulumi.getter(name="stepLRGamma")
    def step_lr_gamma(self) -> Optional[float]:
        """
        Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "step_lr_gamma")

    @property
    @pulumi.getter(name="stepLRStepSize")
    def step_lr_step_size(self) -> Optional[int]:
        """
        Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
        """
        return pulumi.get(self, "step_lr_step_size")

    @property
    @pulumi.getter(name="trainingBatchSize")
    def training_batch_size(self) -> Optional[int]:
        """
        Training batch size. Must be a positive integer.
        """
        return pulumi.get(self, "training_batch_size")

    @property
    @pulumi.getter(name="trainingCropSize")
    def training_crop_size(self) -> Optional[int]:
        """
        Image crop size that is input to the neural network for the training dataset. Must be a positive integer.
        """
        return pulumi.get(self, "training_crop_size")

    @property
    @pulumi.getter(name="validationBatchSize")
    def validation_batch_size(self) -> Optional[int]:
        """
        Validation batch size. Must be a positive integer.
        """
        return pulumi.get(self, "validation_batch_size")

    @property
    @pulumi.getter(name="validationCropSize")
    def validation_crop_size(self) -> Optional[int]:
        """
        Image crop size that is input to the neural network for the validation dataset. Must be a positive integer.
        """
        return pulumi.get(self, "validation_crop_size")

    @property
    @pulumi.getter(name="validationResizeSize")
    def validation_resize_size(self) -> Optional[int]:
        """
        Image size to which to resize before cropping for validation dataset. Must be a positive integer.
        """
        return pulumi.get(self, "validation_resize_size")

    @property
    @pulumi.getter(name="warmupCosineLRCycles")
    def warmup_cosine_lr_cycles(self) -> Optional[float]:
        """
        Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "warmup_cosine_lr_cycles")

    @property
    @pulumi.getter(name="warmupCosineLRWarmupEpochs")
    def warmup_cosine_lr_warmup_epochs(self) -> Optional[int]:
        """
        Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
        """
        return pulumi.get(self, "warmup_cosine_lr_warmup_epochs")

    @property
    @pulumi.getter(name="weightDecay")
    def weight_decay(self) -> Optional[float]:
        """
        Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
        """
        return pulumi.get(self, "weight_decay")

    @property
    @pulumi.getter(name="weightedLoss")
    def weighted_loss(self) -> Optional[int]:
        """
        Weighted loss. The accepted values are 0 for no weighted loss.
        1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be 0 or 1 or 2.
        """
        return pulumi.get(self, "weighted_loss")


@pulumi.output_type
class ImageModelSettingsObjectDetectionResponse(dict):
    """
    Settings used for training the model.
    For more information on the available settings please visit the official documentation:
    https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advancedSettings":
            suggest = "advanced_settings"
        elif key == "amsGradient":
            suggest = "ams_gradient"
        elif key == "boxDetectionsPerImage":
            suggest = "box_detections_per_image"
        elif key == "boxScoreThreshold":
            suggest = "box_score_threshold"
        elif key == "checkpointDatasetId":
            suggest = "checkpoint_dataset_id"
        elif key == "checkpointFilename":
            suggest = "checkpoint_filename"
        elif key == "checkpointFrequency":
            suggest = "checkpoint_frequency"
        elif key == "checkpointRunId":
            suggest = "checkpoint_run_id"
        elif key == "earlyStopping":
            suggest = "early_stopping"
        elif key == "earlyStoppingDelay":
            suggest = "early_stopping_delay"
        elif key == "earlyStoppingPatience":
            suggest = "early_stopping_patience"
        elif key == "enableOnnxNormalization":
            suggest = "enable_onnx_normalization"
        elif key == "evaluationFrequency":
            suggest = "evaluation_frequency"
        elif key == "gradientAccumulationStep":
            suggest = "gradient_accumulation_step"
        elif key == "imageSize":
            suggest = "image_size"
        elif key == "layersToFreeze":
            suggest = "layers_to_freeze"
        elif key == "learningRate":
            suggest = "learning_rate"
        elif key == "learningRateScheduler":
            suggest = "learning_rate_scheduler"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "modelName":
            suggest = "model_name"
        elif key == "modelSize":
            suggest = "model_size"
        elif key == "multiScale":
            suggest = "multi_scale"
        elif key == "nmsIouThreshold":
            suggest = "nms_iou_threshold"
        elif key == "numberOfEpochs":
            suggest = "number_of_epochs"
        elif key == "numberOfWorkers":
            suggest = "number_of_workers"
        elif key == "randomSeed":
            suggest = "random_seed"
        elif key == "splitRatio":
            suggest = "split_ratio"
        elif key == "stepLRGamma":
            suggest = "step_lr_gamma"
        elif key == "stepLRStepSize":
            suggest = "step_lr_step_size"
        elif key == "tileGridSize":
            suggest = "tile_grid_size"
        elif key == "tileOverlapRatio":
            suggest = "tile_overlap_ratio"
        elif key == "tilePredictionsNmsThreshold":
            suggest = "tile_predictions_nms_threshold"
        elif key == "trainingBatchSize":
            suggest = "training_batch_size"
        elif key == "validationBatchSize":
            suggest = "validation_batch_size"
        elif key == "validationIouThreshold":
            suggest = "validation_iou_threshold"
        elif key == "validationMetricType":
            suggest = "validation_metric_type"
        elif key == "warmupCosineLRCycles":
            suggest = "warmup_cosine_lr_cycles"
        elif key == "warmupCosineLRWarmupEpochs":
            suggest = "warmup_cosine_lr_warmup_epochs"
        elif key == "weightDecay":
            suggest = "weight_decay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageModelSettingsObjectDetectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageModelSettingsObjectDetectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageModelSettingsObjectDetectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advanced_settings: Optional[str] = None,
                 ams_gradient: Optional[bool] = None,
                 augmentations: Optional[str] = None,
                 beta1: Optional[float] = None,
                 beta2: Optional[float] = None,
                 box_detections_per_image: Optional[int] = None,
                 box_score_threshold: Optional[float] = None,
                 checkpoint_dataset_id: Optional[str] = None,
                 checkpoint_filename: Optional[str] = None,
                 checkpoint_frequency: Optional[int] = None,
                 checkpoint_run_id: Optional[str] = None,
                 distributed: Optional[bool] = None,
                 early_stopping: Optional[bool] = None,
                 early_stopping_delay: Optional[int] = None,
                 early_stopping_patience: Optional[int] = None,
                 enable_onnx_normalization: Optional[bool] = None,
                 evaluation_frequency: Optional[int] = None,
                 gradient_accumulation_step: Optional[int] = None,
                 image_size: Optional[int] = None,
                 layers_to_freeze: Optional[int] = None,
                 learning_rate: Optional[float] = None,
                 learning_rate_scheduler: Optional[str] = None,
                 max_size: Optional[int] = None,
                 min_size: Optional[int] = None,
                 model_name: Optional[str] = None,
                 model_size: Optional[str] = None,
                 momentum: Optional[float] = None,
                 multi_scale: Optional[bool] = None,
                 nesterov: Optional[bool] = None,
                 nms_iou_threshold: Optional[float] = None,
                 number_of_epochs: Optional[int] = None,
                 number_of_workers: Optional[int] = None,
                 optimizer: Optional[str] = None,
                 random_seed: Optional[int] = None,
                 split_ratio: Optional[float] = None,
                 step_lr_gamma: Optional[float] = None,
                 step_lr_step_size: Optional[int] = None,
                 tile_grid_size: Optional[str] = None,
                 tile_overlap_ratio: Optional[float] = None,
                 tile_predictions_nms_threshold: Optional[float] = None,
                 training_batch_size: Optional[int] = None,
                 validation_batch_size: Optional[int] = None,
                 validation_iou_threshold: Optional[float] = None,
                 validation_metric_type: Optional[str] = None,
                 warmup_cosine_lr_cycles: Optional[float] = None,
                 warmup_cosine_lr_warmup_epochs: Optional[int] = None,
                 weight_decay: Optional[float] = None):
        """
        Settings used for training the model.
        For more information on the available settings please visit the official documentation:
        https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param str advanced_settings: Settings for advanced scenarios.
        :param bool ams_gradient: Enable AMSGrad when optimizer is 'adam' or 'adamw'.
        :param str augmentations: Settings for using Augmentations.
        :param float beta1: Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        :param float beta2: Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        :param int box_detections_per_image: Maximum number of detections per image, for all classes. Must be a positive integer.
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param float box_score_threshold: During inference, only return proposals with a classification score greater than
               BoxScoreThreshold. Must be a float in the range[0, 1].
        :param str checkpoint_dataset_id: FileDataset id for pretrained checkpoint(s) for incremental training.
               Make sure to pass CheckpointFilename along with CheckpointDatasetId.
        :param str checkpoint_filename: The pretrained checkpoint filename in FileDataset for incremental training.
               Make sure to pass CheckpointDatasetId along with CheckpointFilename.
        :param int checkpoint_frequency: Frequency to store model checkpoints. Must be a positive integer.
        :param str checkpoint_run_id: The id of a previous run that has a pretrained checkpoint for incremental training.
        :param bool distributed: Whether to use distributed training.
        :param bool early_stopping: Enable early stopping logic during training.
        :param int early_stopping_delay: Minimum number of epochs or validation evaluations to wait before primary metric improvement
               is tracked for early stopping. Must be a positive integer.
        :param int early_stopping_patience: Minimum number of epochs or validation evaluations with no primary metric improvement before
               the run is stopped. Must be a positive integer.
        :param bool enable_onnx_normalization: Enable normalization when exporting ONNX model.
        :param int evaluation_frequency: Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
        :param int gradient_accumulation_step: Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
               updating the model weights while accumulating the gradients of those steps, and then using
               the accumulated gradients to compute the weight updates. Must be a positive integer.
        :param int image_size: Image size for train and validation. Must be a positive integer.
               Note: The training run may get into CUDA OOM if the size is too big.
               Note: This settings is only supported for the 'yolov5' algorithm.
        :param int layers_to_freeze: Number of layers to freeze for the model. Must be a positive integer.
               For instance, passing 2 as value for 'seresnext' means
               freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
               see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param float learning_rate: Initial learning rate. Must be a float in the range [0, 1].
        :param str learning_rate_scheduler: Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
        :param int max_size: Maximum size of the image to be rescaled before feeding it to the backbone.
               Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param int min_size: Minimum size of the image to be rescaled before feeding it to the backbone.
               Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param str model_name: Name of the model to use for training.
               For more information on the available models please visit the official documentation:
               https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param str model_size: Model size. Must be 'small', 'medium', 'large', or 'xlarge'.
               Note: training run may get into CUDA OOM if the model size is too big.
               Note: This settings is only supported for the 'yolov5' algorithm.
        :param float momentum: Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
        :param bool multi_scale: Enable multi-scale image by varying image size by +/- 50%.
               Note: training run may get into CUDA OOM if no sufficient GPU memory.
               Note: This settings is only supported for the 'yolov5' algorithm.
        :param bool nesterov: Enable nesterov when optimizer is 'sgd'.
        :param float nms_iou_threshold: IOU threshold used during inference in NMS post processing. Must be a float in the range [0, 1].
        :param int number_of_epochs: Number of training epochs. Must be a positive integer.
        :param int number_of_workers: Number of data loader workers. Must be a non-negative integer.
        :param str optimizer: Type of optimizer.
        :param int random_seed: Random seed to be used when using deterministic training.
        :param float split_ratio: If validation data is not defined, this specifies the split ratio for splitting
               train data into random train and validation subsets. Must be a float in the range [0, 1].
        :param float step_lr_gamma: Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
        :param int step_lr_step_size: Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
        :param str tile_grid_size: The grid size to use for tiling each image. Note: TileGridSize must not be
               None to enable small object detection logic. A string containing two integers in mxn format.
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param float tile_overlap_ratio: Overlap ratio between adjacent tiles in each dimension. Must be float in the range [0, 1).
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param float tile_predictions_nms_threshold: The IOU threshold to use to perform NMS while merging predictions from tiles and image.
               Used in validation/ inference. Must be float in the range [0, 1].
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param int training_batch_size: Training batch size. Must be a positive integer.
        :param int validation_batch_size: Validation batch size. Must be a positive integer.
        :param float validation_iou_threshold: IOU threshold to use when computing validation metric. Must be float in the range [0, 1].
        :param str validation_metric_type: Metric computation method to use for validation metrics.
        :param float warmup_cosine_lr_cycles: Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
        :param int warmup_cosine_lr_warmup_epochs: Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
        :param float weight_decay: Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
        """
        ImageModelSettingsObjectDetectionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            advanced_settings=advanced_settings,
            ams_gradient=ams_gradient,
            augmentations=augmentations,
            beta1=beta1,
            beta2=beta2,
            box_detections_per_image=box_detections_per_image,
            box_score_threshold=box_score_threshold,
            checkpoint_dataset_id=checkpoint_dataset_id,
            checkpoint_filename=checkpoint_filename,
            checkpoint_frequency=checkpoint_frequency,
            checkpoint_run_id=checkpoint_run_id,
            distributed=distributed,
            early_stopping=early_stopping,
            early_stopping_delay=early_stopping_delay,
            early_stopping_patience=early_stopping_patience,
            enable_onnx_normalization=enable_onnx_normalization,
            evaluation_frequency=evaluation_frequency,
            gradient_accumulation_step=gradient_accumulation_step,
            image_size=image_size,
            layers_to_freeze=layers_to_freeze,
            learning_rate=learning_rate,
            learning_rate_scheduler=learning_rate_scheduler,
            max_size=max_size,
            min_size=min_size,
            model_name=model_name,
            model_size=model_size,
            momentum=momentum,
            multi_scale=multi_scale,
            nesterov=nesterov,
            nms_iou_threshold=nms_iou_threshold,
            number_of_epochs=number_of_epochs,
            number_of_workers=number_of_workers,
            optimizer=optimizer,
            random_seed=random_seed,
            split_ratio=split_ratio,
            step_lr_gamma=step_lr_gamma,
            step_lr_step_size=step_lr_step_size,
            tile_grid_size=tile_grid_size,
            tile_overlap_ratio=tile_overlap_ratio,
            tile_predictions_nms_threshold=tile_predictions_nms_threshold,
            training_batch_size=training_batch_size,
            validation_batch_size=validation_batch_size,
            validation_iou_threshold=validation_iou_threshold,
            validation_metric_type=validation_metric_type,
            warmup_cosine_lr_cycles=warmup_cosine_lr_cycles,
            warmup_cosine_lr_warmup_epochs=warmup_cosine_lr_warmup_epochs,
            weight_decay=weight_decay,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             advanced_settings: Optional[str] = None,
             ams_gradient: Optional[bool] = None,
             augmentations: Optional[str] = None,
             beta1: Optional[float] = None,
             beta2: Optional[float] = None,
             box_detections_per_image: Optional[int] = None,
             box_score_threshold: Optional[float] = None,
             checkpoint_dataset_id: Optional[str] = None,
             checkpoint_filename: Optional[str] = None,
             checkpoint_frequency: Optional[int] = None,
             checkpoint_run_id: Optional[str] = None,
             distributed: Optional[bool] = None,
             early_stopping: Optional[bool] = None,
             early_stopping_delay: Optional[int] = None,
             early_stopping_patience: Optional[int] = None,
             enable_onnx_normalization: Optional[bool] = None,
             evaluation_frequency: Optional[int] = None,
             gradient_accumulation_step: Optional[int] = None,
             image_size: Optional[int] = None,
             layers_to_freeze: Optional[int] = None,
             learning_rate: Optional[float] = None,
             learning_rate_scheduler: Optional[str] = None,
             max_size: Optional[int] = None,
             min_size: Optional[int] = None,
             model_name: Optional[str] = None,
             model_size: Optional[str] = None,
             momentum: Optional[float] = None,
             multi_scale: Optional[bool] = None,
             nesterov: Optional[bool] = None,
             nms_iou_threshold: Optional[float] = None,
             number_of_epochs: Optional[int] = None,
             number_of_workers: Optional[int] = None,
             optimizer: Optional[str] = None,
             random_seed: Optional[int] = None,
             split_ratio: Optional[float] = None,
             step_lr_gamma: Optional[float] = None,
             step_lr_step_size: Optional[int] = None,
             tile_grid_size: Optional[str] = None,
             tile_overlap_ratio: Optional[float] = None,
             tile_predictions_nms_threshold: Optional[float] = None,
             training_batch_size: Optional[int] = None,
             validation_batch_size: Optional[int] = None,
             validation_iou_threshold: Optional[float] = None,
             validation_metric_type: Optional[str] = None,
             warmup_cosine_lr_cycles: Optional[float] = None,
             warmup_cosine_lr_warmup_epochs: Optional[int] = None,
             weight_decay: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if advanced_settings is None and 'advancedSettings' in kwargs:
            advanced_settings = kwargs['advancedSettings']
        if ams_gradient is None and 'amsGradient' in kwargs:
            ams_gradient = kwargs['amsGradient']
        if box_detections_per_image is None and 'boxDetectionsPerImage' in kwargs:
            box_detections_per_image = kwargs['boxDetectionsPerImage']
        if box_score_threshold is None and 'boxScoreThreshold' in kwargs:
            box_score_threshold = kwargs['boxScoreThreshold']
        if checkpoint_dataset_id is None and 'checkpointDatasetId' in kwargs:
            checkpoint_dataset_id = kwargs['checkpointDatasetId']
        if checkpoint_filename is None and 'checkpointFilename' in kwargs:
            checkpoint_filename = kwargs['checkpointFilename']
        if checkpoint_frequency is None and 'checkpointFrequency' in kwargs:
            checkpoint_frequency = kwargs['checkpointFrequency']
        if checkpoint_run_id is None and 'checkpointRunId' in kwargs:
            checkpoint_run_id = kwargs['checkpointRunId']
        if early_stopping is None and 'earlyStopping' in kwargs:
            early_stopping = kwargs['earlyStopping']
        if early_stopping_delay is None and 'earlyStoppingDelay' in kwargs:
            early_stopping_delay = kwargs['earlyStoppingDelay']
        if early_stopping_patience is None and 'earlyStoppingPatience' in kwargs:
            early_stopping_patience = kwargs['earlyStoppingPatience']
        if enable_onnx_normalization is None and 'enableOnnxNormalization' in kwargs:
            enable_onnx_normalization = kwargs['enableOnnxNormalization']
        if evaluation_frequency is None and 'evaluationFrequency' in kwargs:
            evaluation_frequency = kwargs['evaluationFrequency']
        if gradient_accumulation_step is None and 'gradientAccumulationStep' in kwargs:
            gradient_accumulation_step = kwargs['gradientAccumulationStep']
        if image_size is None and 'imageSize' in kwargs:
            image_size = kwargs['imageSize']
        if layers_to_freeze is None and 'layersToFreeze' in kwargs:
            layers_to_freeze = kwargs['layersToFreeze']
        if learning_rate is None and 'learningRate' in kwargs:
            learning_rate = kwargs['learningRate']
        if learning_rate_scheduler is None and 'learningRateScheduler' in kwargs:
            learning_rate_scheduler = kwargs['learningRateScheduler']
        if max_size is None and 'maxSize' in kwargs:
            max_size = kwargs['maxSize']
        if min_size is None and 'minSize' in kwargs:
            min_size = kwargs['minSize']
        if model_name is None and 'modelName' in kwargs:
            model_name = kwargs['modelName']
        if model_size is None and 'modelSize' in kwargs:
            model_size = kwargs['modelSize']
        if multi_scale is None and 'multiScale' in kwargs:
            multi_scale = kwargs['multiScale']
        if nms_iou_threshold is None and 'nmsIouThreshold' in kwargs:
            nms_iou_threshold = kwargs['nmsIouThreshold']
        if number_of_epochs is None and 'numberOfEpochs' in kwargs:
            number_of_epochs = kwargs['numberOfEpochs']
        if number_of_workers is None and 'numberOfWorkers' in kwargs:
            number_of_workers = kwargs['numberOfWorkers']
        if random_seed is None and 'randomSeed' in kwargs:
            random_seed = kwargs['randomSeed']
        if split_ratio is None and 'splitRatio' in kwargs:
            split_ratio = kwargs['splitRatio']
        if step_lr_gamma is None and 'stepLRGamma' in kwargs:
            step_lr_gamma = kwargs['stepLRGamma']
        if step_lr_step_size is None and 'stepLRStepSize' in kwargs:
            step_lr_step_size = kwargs['stepLRStepSize']
        if tile_grid_size is None and 'tileGridSize' in kwargs:
            tile_grid_size = kwargs['tileGridSize']
        if tile_overlap_ratio is None and 'tileOverlapRatio' in kwargs:
            tile_overlap_ratio = kwargs['tileOverlapRatio']
        if tile_predictions_nms_threshold is None and 'tilePredictionsNmsThreshold' in kwargs:
            tile_predictions_nms_threshold = kwargs['tilePredictionsNmsThreshold']
        if training_batch_size is None and 'trainingBatchSize' in kwargs:
            training_batch_size = kwargs['trainingBatchSize']
        if validation_batch_size is None and 'validationBatchSize' in kwargs:
            validation_batch_size = kwargs['validationBatchSize']
        if validation_iou_threshold is None and 'validationIouThreshold' in kwargs:
            validation_iou_threshold = kwargs['validationIouThreshold']
        if validation_metric_type is None and 'validationMetricType' in kwargs:
            validation_metric_type = kwargs['validationMetricType']
        if warmup_cosine_lr_cycles is None and 'warmupCosineLRCycles' in kwargs:
            warmup_cosine_lr_cycles = kwargs['warmupCosineLRCycles']
        if warmup_cosine_lr_warmup_epochs is None and 'warmupCosineLRWarmupEpochs' in kwargs:
            warmup_cosine_lr_warmup_epochs = kwargs['warmupCosineLRWarmupEpochs']
        if weight_decay is None and 'weightDecay' in kwargs:
            weight_decay = kwargs['weightDecay']

        if advanced_settings is not None:
            _setter("advanced_settings", advanced_settings)
        if ams_gradient is not None:
            _setter("ams_gradient", ams_gradient)
        if augmentations is not None:
            _setter("augmentations", augmentations)
        if beta1 is not None:
            _setter("beta1", beta1)
        if beta2 is not None:
            _setter("beta2", beta2)
        if box_detections_per_image is not None:
            _setter("box_detections_per_image", box_detections_per_image)
        if box_score_threshold is not None:
            _setter("box_score_threshold", box_score_threshold)
        if checkpoint_dataset_id is not None:
            _setter("checkpoint_dataset_id", checkpoint_dataset_id)
        if checkpoint_filename is not None:
            _setter("checkpoint_filename", checkpoint_filename)
        if checkpoint_frequency is not None:
            _setter("checkpoint_frequency", checkpoint_frequency)
        if checkpoint_run_id is not None:
            _setter("checkpoint_run_id", checkpoint_run_id)
        if distributed is not None:
            _setter("distributed", distributed)
        if early_stopping is not None:
            _setter("early_stopping", early_stopping)
        if early_stopping_delay is not None:
            _setter("early_stopping_delay", early_stopping_delay)
        if early_stopping_patience is not None:
            _setter("early_stopping_patience", early_stopping_patience)
        if enable_onnx_normalization is not None:
            _setter("enable_onnx_normalization", enable_onnx_normalization)
        if evaluation_frequency is not None:
            _setter("evaluation_frequency", evaluation_frequency)
        if gradient_accumulation_step is not None:
            _setter("gradient_accumulation_step", gradient_accumulation_step)
        if image_size is not None:
            _setter("image_size", image_size)
        if layers_to_freeze is not None:
            _setter("layers_to_freeze", layers_to_freeze)
        if learning_rate is not None:
            _setter("learning_rate", learning_rate)
        if learning_rate_scheduler is None:
            learning_rate_scheduler = 'None'
        if learning_rate_scheduler is not None:
            _setter("learning_rate_scheduler", learning_rate_scheduler)
        if max_size is not None:
            _setter("max_size", max_size)
        if min_size is not None:
            _setter("min_size", min_size)
        if model_name is not None:
            _setter("model_name", model_name)
        if model_size is None:
            model_size = 'None'
        if model_size is not None:
            _setter("model_size", model_size)
        if momentum is not None:
            _setter("momentum", momentum)
        if multi_scale is not None:
            _setter("multi_scale", multi_scale)
        if nesterov is not None:
            _setter("nesterov", nesterov)
        if nms_iou_threshold is not None:
            _setter("nms_iou_threshold", nms_iou_threshold)
        if number_of_epochs is not None:
            _setter("number_of_epochs", number_of_epochs)
        if number_of_workers is not None:
            _setter("number_of_workers", number_of_workers)
        if optimizer is None:
            optimizer = 'None'
        if optimizer is not None:
            _setter("optimizer", optimizer)
        if random_seed is not None:
            _setter("random_seed", random_seed)
        if split_ratio is not None:
            _setter("split_ratio", split_ratio)
        if step_lr_gamma is not None:
            _setter("step_lr_gamma", step_lr_gamma)
        if step_lr_step_size is not None:
            _setter("step_lr_step_size", step_lr_step_size)
        if tile_grid_size is not None:
            _setter("tile_grid_size", tile_grid_size)
        if tile_overlap_ratio is not None:
            _setter("tile_overlap_ratio", tile_overlap_ratio)
        if tile_predictions_nms_threshold is not None:
            _setter("tile_predictions_nms_threshold", tile_predictions_nms_threshold)
        if training_batch_size is not None:
            _setter("training_batch_size", training_batch_size)
        if validation_batch_size is not None:
            _setter("validation_batch_size", validation_batch_size)
        if validation_iou_threshold is not None:
            _setter("validation_iou_threshold", validation_iou_threshold)
        if validation_metric_type is None:
            validation_metric_type = 'None'
        if validation_metric_type is not None:
            _setter("validation_metric_type", validation_metric_type)
        if warmup_cosine_lr_cycles is not None:
            _setter("warmup_cosine_lr_cycles", warmup_cosine_lr_cycles)
        if warmup_cosine_lr_warmup_epochs is not None:
            _setter("warmup_cosine_lr_warmup_epochs", warmup_cosine_lr_warmup_epochs)
        if weight_decay is not None:
            _setter("weight_decay", weight_decay)

    @property
    @pulumi.getter(name="advancedSettings")
    def advanced_settings(self) -> Optional[str]:
        """
        Settings for advanced scenarios.
        """
        return pulumi.get(self, "advanced_settings")

    @property
    @pulumi.getter(name="amsGradient")
    def ams_gradient(self) -> Optional[bool]:
        """
        Enable AMSGrad when optimizer is 'adam' or 'adamw'.
        """
        return pulumi.get(self, "ams_gradient")

    @property
    @pulumi.getter
    def augmentations(self) -> Optional[str]:
        """
        Settings for using Augmentations.
        """
        return pulumi.get(self, "augmentations")

    @property
    @pulumi.getter
    def beta1(self) -> Optional[float]:
        """
        Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "beta1")

    @property
    @pulumi.getter
    def beta2(self) -> Optional[float]:
        """
        Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "beta2")

    @property
    @pulumi.getter(name="boxDetectionsPerImage")
    def box_detections_per_image(self) -> Optional[int]:
        """
        Maximum number of detections per image, for all classes. Must be a positive integer.
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "box_detections_per_image")

    @property
    @pulumi.getter(name="boxScoreThreshold")
    def box_score_threshold(self) -> Optional[float]:
        """
        During inference, only return proposals with a classification score greater than
        BoxScoreThreshold. Must be a float in the range[0, 1].
        """
        return pulumi.get(self, "box_score_threshold")

    @property
    @pulumi.getter(name="checkpointDatasetId")
    def checkpoint_dataset_id(self) -> Optional[str]:
        """
        FileDataset id for pretrained checkpoint(s) for incremental training.
        Make sure to pass CheckpointFilename along with CheckpointDatasetId.
        """
        return pulumi.get(self, "checkpoint_dataset_id")

    @property
    @pulumi.getter(name="checkpointFilename")
    def checkpoint_filename(self) -> Optional[str]:
        """
        The pretrained checkpoint filename in FileDataset for incremental training.
        Make sure to pass CheckpointDatasetId along with CheckpointFilename.
        """
        return pulumi.get(self, "checkpoint_filename")

    @property
    @pulumi.getter(name="checkpointFrequency")
    def checkpoint_frequency(self) -> Optional[int]:
        """
        Frequency to store model checkpoints. Must be a positive integer.
        """
        return pulumi.get(self, "checkpoint_frequency")

    @property
    @pulumi.getter(name="checkpointRunId")
    def checkpoint_run_id(self) -> Optional[str]:
        """
        The id of a previous run that has a pretrained checkpoint for incremental training.
        """
        return pulumi.get(self, "checkpoint_run_id")

    @property
    @pulumi.getter
    def distributed(self) -> Optional[bool]:
        """
        Whether to use distributed training.
        """
        return pulumi.get(self, "distributed")

    @property
    @pulumi.getter(name="earlyStopping")
    def early_stopping(self) -> Optional[bool]:
        """
        Enable early stopping logic during training.
        """
        return pulumi.get(self, "early_stopping")

    @property
    @pulumi.getter(name="earlyStoppingDelay")
    def early_stopping_delay(self) -> Optional[int]:
        """
        Minimum number of epochs or validation evaluations to wait before primary metric improvement
        is tracked for early stopping. Must be a positive integer.
        """
        return pulumi.get(self, "early_stopping_delay")

    @property
    @pulumi.getter(name="earlyStoppingPatience")
    def early_stopping_patience(self) -> Optional[int]:
        """
        Minimum number of epochs or validation evaluations with no primary metric improvement before
        the run is stopped. Must be a positive integer.
        """
        return pulumi.get(self, "early_stopping_patience")

    @property
    @pulumi.getter(name="enableOnnxNormalization")
    def enable_onnx_normalization(self) -> Optional[bool]:
        """
        Enable normalization when exporting ONNX model.
        """
        return pulumi.get(self, "enable_onnx_normalization")

    @property
    @pulumi.getter(name="evaluationFrequency")
    def evaluation_frequency(self) -> Optional[int]:
        """
        Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
        """
        return pulumi.get(self, "evaluation_frequency")

    @property
    @pulumi.getter(name="gradientAccumulationStep")
    def gradient_accumulation_step(self) -> Optional[int]:
        """
        Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
        updating the model weights while accumulating the gradients of those steps, and then using
        the accumulated gradients to compute the weight updates. Must be a positive integer.
        """
        return pulumi.get(self, "gradient_accumulation_step")

    @property
    @pulumi.getter(name="imageSize")
    def image_size(self) -> Optional[int]:
        """
        Image size for train and validation. Must be a positive integer.
        Note: The training run may get into CUDA OOM if the size is too big.
        Note: This settings is only supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "image_size")

    @property
    @pulumi.getter(name="layersToFreeze")
    def layers_to_freeze(self) -> Optional[int]:
        """
        Number of layers to freeze for the model. Must be a positive integer.
        For instance, passing 2 as value for 'seresnext' means
        freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
        see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        """
        return pulumi.get(self, "layers_to_freeze")

    @property
    @pulumi.getter(name="learningRate")
    def learning_rate(self) -> Optional[float]:
        """
        Initial learning rate. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "learning_rate")

    @property
    @pulumi.getter(name="learningRateScheduler")
    def learning_rate_scheduler(self) -> Optional[str]:
        """
        Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
        """
        return pulumi.get(self, "learning_rate_scheduler")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        """
        Maximum size of the image to be rescaled before feeding it to the backbone.
        Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[int]:
        """
        Minimum size of the image to be rescaled before feeding it to the backbone.
        Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[str]:
        """
        Name of the model to use for training.
        For more information on the available models please visit the official documentation:
        https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        """
        return pulumi.get(self, "model_name")

    @property
    @pulumi.getter(name="modelSize")
    def model_size(self) -> Optional[str]:
        """
        Model size. Must be 'small', 'medium', 'large', or 'xlarge'.
        Note: training run may get into CUDA OOM if the model size is too big.
        Note: This settings is only supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "model_size")

    @property
    @pulumi.getter
    def momentum(self) -> Optional[float]:
        """
        Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "momentum")

    @property
    @pulumi.getter(name="multiScale")
    def multi_scale(self) -> Optional[bool]:
        """
        Enable multi-scale image by varying image size by +/- 50%.
        Note: training run may get into CUDA OOM if no sufficient GPU memory.
        Note: This settings is only supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "multi_scale")

    @property
    @pulumi.getter
    def nesterov(self) -> Optional[bool]:
        """
        Enable nesterov when optimizer is 'sgd'.
        """
        return pulumi.get(self, "nesterov")

    @property
    @pulumi.getter(name="nmsIouThreshold")
    def nms_iou_threshold(self) -> Optional[float]:
        """
        IOU threshold used during inference in NMS post processing. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "nms_iou_threshold")

    @property
    @pulumi.getter(name="numberOfEpochs")
    def number_of_epochs(self) -> Optional[int]:
        """
        Number of training epochs. Must be a positive integer.
        """
        return pulumi.get(self, "number_of_epochs")

    @property
    @pulumi.getter(name="numberOfWorkers")
    def number_of_workers(self) -> Optional[int]:
        """
        Number of data loader workers. Must be a non-negative integer.
        """
        return pulumi.get(self, "number_of_workers")

    @property
    @pulumi.getter
    def optimizer(self) -> Optional[str]:
        """
        Type of optimizer.
        """
        return pulumi.get(self, "optimizer")

    @property
    @pulumi.getter(name="randomSeed")
    def random_seed(self) -> Optional[int]:
        """
        Random seed to be used when using deterministic training.
        """
        return pulumi.get(self, "random_seed")

    @property
    @pulumi.getter(name="splitRatio")
    def split_ratio(self) -> Optional[float]:
        """
        If validation data is not defined, this specifies the split ratio for splitting
        train data into random train and validation subsets. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "split_ratio")

    @property
    @pulumi.getter(name="stepLRGamma")
    def step_lr_gamma(self) -> Optional[float]:
        """
        Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "step_lr_gamma")

    @property
    @pulumi.getter(name="stepLRStepSize")
    def step_lr_step_size(self) -> Optional[int]:
        """
        Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
        """
        return pulumi.get(self, "step_lr_step_size")

    @property
    @pulumi.getter(name="tileGridSize")
    def tile_grid_size(self) -> Optional[str]:
        """
        The grid size to use for tiling each image. Note: TileGridSize must not be
        None to enable small object detection logic. A string containing two integers in mxn format.
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "tile_grid_size")

    @property
    @pulumi.getter(name="tileOverlapRatio")
    def tile_overlap_ratio(self) -> Optional[float]:
        """
        Overlap ratio between adjacent tiles in each dimension. Must be float in the range [0, 1).
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "tile_overlap_ratio")

    @property
    @pulumi.getter(name="tilePredictionsNmsThreshold")
    def tile_predictions_nms_threshold(self) -> Optional[float]:
        """
        The IOU threshold to use to perform NMS while merging predictions from tiles and image.
        Used in validation/ inference. Must be float in the range [0, 1].
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "tile_predictions_nms_threshold")

    @property
    @pulumi.getter(name="trainingBatchSize")
    def training_batch_size(self) -> Optional[int]:
        """
        Training batch size. Must be a positive integer.
        """
        return pulumi.get(self, "training_batch_size")

    @property
    @pulumi.getter(name="validationBatchSize")
    def validation_batch_size(self) -> Optional[int]:
        """
        Validation batch size. Must be a positive integer.
        """
        return pulumi.get(self, "validation_batch_size")

    @property
    @pulumi.getter(name="validationIouThreshold")
    def validation_iou_threshold(self) -> Optional[float]:
        """
        IOU threshold to use when computing validation metric. Must be float in the range [0, 1].
        """
        return pulumi.get(self, "validation_iou_threshold")

    @property
    @pulumi.getter(name="validationMetricType")
    def validation_metric_type(self) -> Optional[str]:
        """
        Metric computation method to use for validation metrics.
        """
        return pulumi.get(self, "validation_metric_type")

    @property
    @pulumi.getter(name="warmupCosineLRCycles")
    def warmup_cosine_lr_cycles(self) -> Optional[float]:
        """
        Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "warmup_cosine_lr_cycles")

    @property
    @pulumi.getter(name="warmupCosineLRWarmupEpochs")
    def warmup_cosine_lr_warmup_epochs(self) -> Optional[int]:
        """
        Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
        """
        return pulumi.get(self, "warmup_cosine_lr_warmup_epochs")

    @property
    @pulumi.getter(name="weightDecay")
    def weight_decay(self) -> Optional[float]:
        """
        Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
        """
        return pulumi.get(self, "weight_decay")


@pulumi.output_type
class ImageObjectDetectionResponse(dict):
    """
    Image Object Detection. Object detection is used to identify objects in an image and locate each object with a
    bounding box e.g. locate all dogs and cats in an image and draw a bounding box around each.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSettings":
            suggest = "data_settings"
        elif key == "limitSettings":
            suggest = "limit_settings"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "logVerbosity":
            suggest = "log_verbosity"
        elif key == "modelSettings":
            suggest = "model_settings"
        elif key == "primaryMetric":
            suggest = "primary_metric"
        elif key == "searchSpace":
            suggest = "search_space"
        elif key == "sweepSettings":
            suggest = "sweep_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageObjectDetectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageObjectDetectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageObjectDetectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_settings: 'outputs.ImageVerticalDataSettingsResponse',
                 limit_settings: 'outputs.ImageLimitSettingsResponse',
                 task_type: str,
                 log_verbosity: Optional[str] = None,
                 model_settings: Optional['outputs.ImageModelSettingsObjectDetectionResponse'] = None,
                 primary_metric: Optional[str] = None,
                 search_space: Optional[Sequence['outputs.ImageModelDistributionSettingsObjectDetectionResponse']] = None,
                 sweep_settings: Optional['outputs.ImageSweepSettingsResponse'] = None):
        """
        Image Object Detection. Object detection is used to identify objects in an image and locate each object with a
        bounding box e.g. locate all dogs and cats in an image and draw a bounding box around each.
        :param 'ImageVerticalDataSettingsResponse' data_settings: [Required] Collection of registered Tabular Dataset Ids and other data settings required for training and validating models.
        :param 'ImageLimitSettingsResponse' limit_settings: [Required] Limit settings for the AutoML job.
        :param str task_type: AutoMLJob Task type.
               Expected value is 'ImageObjectDetection'.
        :param str log_verbosity: Log verbosity for the job.
        :param 'ImageModelSettingsObjectDetectionResponse' model_settings: Settings used for training the model.
        :param str primary_metric: Primary metric to optimize for this task.
        :param Sequence['ImageModelDistributionSettingsObjectDetectionResponse'] search_space: Search space for sampling different combinations of models and their hyperparameters.
        :param 'ImageSweepSettingsResponse' sweep_settings: Model sweeping and hyperparameter sweeping related settings.
        """
        ImageObjectDetectionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_settings=data_settings,
            limit_settings=limit_settings,
            task_type=task_type,
            log_verbosity=log_verbosity,
            model_settings=model_settings,
            primary_metric=primary_metric,
            search_space=search_space,
            sweep_settings=sweep_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_settings: Optional['outputs.ImageVerticalDataSettingsResponse'] = None,
             limit_settings: Optional['outputs.ImageLimitSettingsResponse'] = None,
             task_type: Optional[str] = None,
             log_verbosity: Optional[str] = None,
             model_settings: Optional['outputs.ImageModelSettingsObjectDetectionResponse'] = None,
             primary_metric: Optional[str] = None,
             search_space: Optional[Sequence['outputs.ImageModelDistributionSettingsObjectDetectionResponse']] = None,
             sweep_settings: Optional['outputs.ImageSweepSettingsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_settings is None and 'dataSettings' in kwargs:
            data_settings = kwargs['dataSettings']
        if data_settings is None:
            raise TypeError("Missing 'data_settings' argument")
        if limit_settings is None and 'limitSettings' in kwargs:
            limit_settings = kwargs['limitSettings']
        if limit_settings is None:
            raise TypeError("Missing 'limit_settings' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if log_verbosity is None and 'logVerbosity' in kwargs:
            log_verbosity = kwargs['logVerbosity']
        if model_settings is None and 'modelSettings' in kwargs:
            model_settings = kwargs['modelSettings']
        if primary_metric is None and 'primaryMetric' in kwargs:
            primary_metric = kwargs['primaryMetric']
        if search_space is None and 'searchSpace' in kwargs:
            search_space = kwargs['searchSpace']
        if sweep_settings is None and 'sweepSettings' in kwargs:
            sweep_settings = kwargs['sweepSettings']

        _setter("data_settings", data_settings)
        _setter("limit_settings", limit_settings)
        _setter("task_type", 'ImageObjectDetection')
        if log_verbosity is None:
            log_verbosity = 'Info'
        if log_verbosity is not None:
            _setter("log_verbosity", log_verbosity)
        if model_settings is not None:
            _setter("model_settings", model_settings)
        if primary_metric is None:
            primary_metric = 'MeanAveragePrecision'
        if primary_metric is not None:
            _setter("primary_metric", primary_metric)
        if search_space is not None:
            _setter("search_space", search_space)
        if sweep_settings is not None:
            _setter("sweep_settings", sweep_settings)

    @property
    @pulumi.getter(name="dataSettings")
    def data_settings(self) -> 'outputs.ImageVerticalDataSettingsResponse':
        """
        [Required] Collection of registered Tabular Dataset Ids and other data settings required for training and validating models.
        """
        return pulumi.get(self, "data_settings")

    @property
    @pulumi.getter(name="limitSettings")
    def limit_settings(self) -> 'outputs.ImageLimitSettingsResponse':
        """
        [Required] Limit settings for the AutoML job.
        """
        return pulumi.get(self, "limit_settings")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        AutoMLJob Task type.
        Expected value is 'ImageObjectDetection'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="logVerbosity")
    def log_verbosity(self) -> Optional[str]:
        """
        Log verbosity for the job.
        """
        return pulumi.get(self, "log_verbosity")

    @property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional['outputs.ImageModelSettingsObjectDetectionResponse']:
        """
        Settings used for training the model.
        """
        return pulumi.get(self, "model_settings")

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> Optional[str]:
        """
        Primary metric to optimize for this task.
        """
        return pulumi.get(self, "primary_metric")

    @property
    @pulumi.getter(name="searchSpace")
    def search_space(self) -> Optional[Sequence['outputs.ImageModelDistributionSettingsObjectDetectionResponse']]:
        """
        Search space for sampling different combinations of models and their hyperparameters.
        """
        return pulumi.get(self, "search_space")

    @property
    @pulumi.getter(name="sweepSettings")
    def sweep_settings(self) -> Optional['outputs.ImageSweepSettingsResponse']:
        """
        Model sweeping and hyperparameter sweeping related settings.
        """
        return pulumi.get(self, "sweep_settings")


@pulumi.output_type
class ImageSweepLimitSettingsResponse(dict):
    """
    Limit settings for model sweeping and hyperparameter sweeping.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentTrials":
            suggest = "max_concurrent_trials"
        elif key == "maxTrials":
            suggest = "max_trials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageSweepLimitSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageSweepLimitSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageSweepLimitSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_trials: Optional[int] = None,
                 max_trials: Optional[int] = None):
        """
        Limit settings for model sweeping and hyperparameter sweeping.
        :param int max_concurrent_trials: Maximum number of concurrent iterations for the underlying Sweep job.
        :param int max_trials: Maximum number of iterations for the underlying Sweep job.
        """
        ImageSweepLimitSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_concurrent_trials=max_concurrent_trials,
            max_trials=max_trials,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_concurrent_trials: Optional[int] = None,
             max_trials: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_concurrent_trials is None and 'maxConcurrentTrials' in kwargs:
            max_concurrent_trials = kwargs['maxConcurrentTrials']
        if max_trials is None and 'maxTrials' in kwargs:
            max_trials = kwargs['maxTrials']

        if max_concurrent_trials is not None:
            _setter("max_concurrent_trials", max_concurrent_trials)
        if max_trials is not None:
            _setter("max_trials", max_trials)

    @property
    @pulumi.getter(name="maxConcurrentTrials")
    def max_concurrent_trials(self) -> Optional[int]:
        """
        Maximum number of concurrent iterations for the underlying Sweep job.
        """
        return pulumi.get(self, "max_concurrent_trials")

    @property
    @pulumi.getter(name="maxTrials")
    def max_trials(self) -> Optional[int]:
        """
        Maximum number of iterations for the underlying Sweep job.
        """
        return pulumi.get(self, "max_trials")


@pulumi.output_type
class ImageSweepSettingsResponse(dict):
    """
    Model sweeping and hyperparameter sweeping related settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "samplingAlgorithm":
            suggest = "sampling_algorithm"
        elif key == "earlyTermination":
            suggest = "early_termination"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageSweepSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageSweepSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageSweepSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limits: 'outputs.ImageSweepLimitSettingsResponse',
                 sampling_algorithm: str,
                 early_termination: Optional[Any] = None):
        """
        Model sweeping and hyperparameter sweeping related settings.
        :param 'ImageSweepLimitSettingsResponse' limits: [Required] Limit settings for model sweeping and hyperparameter sweeping.
        :param str sampling_algorithm: [Required] Type of the hyperparameter sampling algorithms.
        :param Union['BanditPolicyResponse', 'MedianStoppingPolicyResponse', 'TruncationSelectionPolicyResponse'] early_termination: Type of early termination policy.
        """
        ImageSweepSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            limits=limits,
            sampling_algorithm=sampling_algorithm,
            early_termination=early_termination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             limits: Optional['outputs.ImageSweepLimitSettingsResponse'] = None,
             sampling_algorithm: Optional[str] = None,
             early_termination: Optional[Any] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if limits is None:
            raise TypeError("Missing 'limits' argument")
        if sampling_algorithm is None and 'samplingAlgorithm' in kwargs:
            sampling_algorithm = kwargs['samplingAlgorithm']
        if sampling_algorithm is None:
            raise TypeError("Missing 'sampling_algorithm' argument")
        if early_termination is None and 'earlyTermination' in kwargs:
            early_termination = kwargs['earlyTermination']

        _setter("limits", limits)
        _setter("sampling_algorithm", sampling_algorithm)
        if early_termination is not None:
            _setter("early_termination", early_termination)

    @property
    @pulumi.getter
    def limits(self) -> 'outputs.ImageSweepLimitSettingsResponse':
        """
        [Required] Limit settings for model sweeping and hyperparameter sweeping.
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter(name="samplingAlgorithm")
    def sampling_algorithm(self) -> str:
        """
        [Required] Type of the hyperparameter sampling algorithms.
        """
        return pulumi.get(self, "sampling_algorithm")

    @property
    @pulumi.getter(name="earlyTermination")
    def early_termination(self) -> Optional[Any]:
        """
        Type of early termination policy.
        """
        return pulumi.get(self, "early_termination")


@pulumi.output_type
class ImageVerticalDataSettingsResponse(dict):
    """
    Collection of registered Tabular Dataset Ids and other data settings required for training and validating models.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetColumnName":
            suggest = "target_column_name"
        elif key == "trainingData":
            suggest = "training_data"
        elif key == "testData":
            suggest = "test_data"
        elif key == "validationData":
            suggest = "validation_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageVerticalDataSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageVerticalDataSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageVerticalDataSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_column_name: str,
                 training_data: 'outputs.TrainingDataSettingsResponse',
                 test_data: Optional['outputs.TestDataSettingsResponse'] = None,
                 validation_data: Optional['outputs.ImageVerticalValidationDataSettingsResponse'] = None):
        """
        Collection of registered Tabular Dataset Ids and other data settings required for training and validating models.
        :param str target_column_name: [Required] Target column name: This is prediction values column.
               Also known as label column name in context of classification tasks.
        :param 'TrainingDataSettingsResponse' training_data: [Required] Training data input.
        :param 'TestDataSettingsResponse' test_data: Test data input.
        :param 'ImageVerticalValidationDataSettingsResponse' validation_data: Settings for the validation dataset.
        """
        ImageVerticalDataSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_column_name=target_column_name,
            training_data=training_data,
            test_data=test_data,
            validation_data=validation_data,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_column_name: Optional[str] = None,
             training_data: Optional['outputs.TrainingDataSettingsResponse'] = None,
             test_data: Optional['outputs.TestDataSettingsResponse'] = None,
             validation_data: Optional['outputs.ImageVerticalValidationDataSettingsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if target_column_name is None and 'targetColumnName' in kwargs:
            target_column_name = kwargs['targetColumnName']
        if target_column_name is None:
            raise TypeError("Missing 'target_column_name' argument")
        if training_data is None and 'trainingData' in kwargs:
            training_data = kwargs['trainingData']
        if training_data is None:
            raise TypeError("Missing 'training_data' argument")
        if test_data is None and 'testData' in kwargs:
            test_data = kwargs['testData']
        if validation_data is None and 'validationData' in kwargs:
            validation_data = kwargs['validationData']

        _setter("target_column_name", target_column_name)
        _setter("training_data", training_data)
        if test_data is not None:
            _setter("test_data", test_data)
        if validation_data is not None:
            _setter("validation_data", validation_data)

    @property
    @pulumi.getter(name="targetColumnName")
    def target_column_name(self) -> str:
        """
        [Required] Target column name: This is prediction values column.
        Also known as label column name in context of classification tasks.
        """
        return pulumi.get(self, "target_column_name")

    @property
    @pulumi.getter(name="trainingData")
    def training_data(self) -> 'outputs.TrainingDataSettingsResponse':
        """
        [Required] Training data input.
        """
        return pulumi.get(self, "training_data")

    @property
    @pulumi.getter(name="testData")
    def test_data(self) -> Optional['outputs.TestDataSettingsResponse']:
        """
        Test data input.
        """
        return pulumi.get(self, "test_data")

    @property
    @pulumi.getter(name="validationData")
    def validation_data(self) -> Optional['outputs.ImageVerticalValidationDataSettingsResponse']:
        """
        Settings for the validation dataset.
        """
        return pulumi.get(self, "validation_data")


@pulumi.output_type
class ImageVerticalValidationDataSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validationDataSize":
            suggest = "validation_data_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageVerticalValidationDataSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageVerticalValidationDataSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageVerticalValidationDataSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data: Optional['outputs.MLTableJobInputResponse'] = None,
                 validation_data_size: Optional[float] = None):
        """
        :param 'MLTableJobInputResponse' data: Validation data MLTable.
        :param float validation_data_size: The fraction of training dataset that needs to be set aside for validation purpose.
               Values between (0.0 , 1.0)
               Applied when validation dataset is not provided.
        """
        ImageVerticalValidationDataSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data=data,
            validation_data_size=validation_data_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data: Optional['outputs.MLTableJobInputResponse'] = None,
             validation_data_size: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if validation_data_size is None and 'validationDataSize' in kwargs:
            validation_data_size = kwargs['validationDataSize']

        if data is not None:
            _setter("data", data)
        if validation_data_size is not None:
            _setter("validation_data_size", validation_data_size)

    @property
    @pulumi.getter
    def data(self) -> Optional['outputs.MLTableJobInputResponse']:
        """
        Validation data MLTable.
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter(name="validationDataSize")
    def validation_data_size(self) -> Optional[float]:
        """
        The fraction of training dataset that needs to be set aside for validation purpose.
        Values between (0.0 , 1.0)
        Applied when validation dataset is not provided.
        """
        return pulumi.get(self, "validation_data_size")


@pulumi.output_type
class InferenceContainerPropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "livenessRoute":
            suggest = "liveness_route"
        elif key == "readinessRoute":
            suggest = "readiness_route"
        elif key == "scoringRoute":
            suggest = "scoring_route"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InferenceContainerPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InferenceContainerPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InferenceContainerPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 liveness_route: Optional['outputs.RouteResponse'] = None,
                 readiness_route: Optional['outputs.RouteResponse'] = None,
                 scoring_route: Optional['outputs.RouteResponse'] = None):
        """
        :param 'RouteResponse' liveness_route: The route to check the liveness of the inference server container.
        :param 'RouteResponse' readiness_route: The route to check the readiness of the inference server container.
        :param 'RouteResponse' scoring_route: The port to send the scoring requests to, within the inference server container.
        """
        InferenceContainerPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            liveness_route=liveness_route,
            readiness_route=readiness_route,
            scoring_route=scoring_route,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             liveness_route: Optional['outputs.RouteResponse'] = None,
             readiness_route: Optional['outputs.RouteResponse'] = None,
             scoring_route: Optional['outputs.RouteResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if liveness_route is None and 'livenessRoute' in kwargs:
            liveness_route = kwargs['livenessRoute']
        if readiness_route is None and 'readinessRoute' in kwargs:
            readiness_route = kwargs['readinessRoute']
        if scoring_route is None and 'scoringRoute' in kwargs:
            scoring_route = kwargs['scoringRoute']

        if liveness_route is not None:
            _setter("liveness_route", liveness_route)
        if readiness_route is not None:
            _setter("readiness_route", readiness_route)
        if scoring_route is not None:
            _setter("scoring_route", scoring_route)

    @property
    @pulumi.getter(name="livenessRoute")
    def liveness_route(self) -> Optional['outputs.RouteResponse']:
        """
        The route to check the liveness of the inference server container.
        """
        return pulumi.get(self, "liveness_route")

    @property
    @pulumi.getter(name="readinessRoute")
    def readiness_route(self) -> Optional['outputs.RouteResponse']:
        """
        The route to check the readiness of the inference server container.
        """
        return pulumi.get(self, "readiness_route")

    @property
    @pulumi.getter(name="scoringRoute")
    def scoring_route(self) -> Optional['outputs.RouteResponse']:
        """
        The port to send the scoring requests to, within the inference server container.
        """
        return pulumi.get(self, "scoring_route")


@pulumi.output_type
class JobServiceResponse(dict):
    """
    Job endpoint definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"
        elif key == "jobServiceType":
            suggest = "job_service_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobServiceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobServiceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobServiceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_message: str,
                 status: str,
                 endpoint: Optional[str] = None,
                 job_service_type: Optional[str] = None,
                 port: Optional[int] = None,
                 properties: Optional[Mapping[str, str]] = None):
        """
        Job endpoint definition
        :param str error_message: Any error in the service.
        :param str status: Status of endpoint.
        :param str endpoint: Url for endpoint.
        :param str job_service_type: Endpoint type.
        :param int port: Port for endpoint.
        :param Mapping[str, str] properties: Additional properties to set on the endpoint.
        """
        JobServiceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error_message=error_message,
            status=status,
            endpoint=endpoint,
            job_service_type=job_service_type,
            port=port,
            properties=properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error_message: Optional[str] = None,
             status: Optional[str] = None,
             endpoint: Optional[str] = None,
             job_service_type: Optional[str] = None,
             port: Optional[int] = None,
             properties: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if error_message is None and 'errorMessage' in kwargs:
            error_message = kwargs['errorMessage']
        if error_message is None:
            raise TypeError("Missing 'error_message' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if job_service_type is None and 'jobServiceType' in kwargs:
            job_service_type = kwargs['jobServiceType']

        _setter("error_message", error_message)
        _setter("status", status)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if job_service_type is not None:
            _setter("job_service_type", job_service_type)
        if port is not None:
            _setter("port", port)
        if properties is not None:
            _setter("properties", properties)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        """
        Any error in the service.
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of endpoint.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        Url for endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="jobServiceType")
    def job_service_type(self) -> Optional[str]:
        """
        Endpoint type.
        """
        return pulumi.get(self, "job_service_type")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port for endpoint.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        Additional properties to set on the endpoint.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class KerberosKeytabCredentialsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsType":
            suggest = "credentials_type"
        elif key == "kerberosKdcAddress":
            suggest = "kerberos_kdc_address"
        elif key == "kerberosPrincipal":
            suggest = "kerberos_principal"
        elif key == "kerberosRealm":
            suggest = "kerberos_realm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KerberosKeytabCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KerberosKeytabCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KerberosKeytabCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_type: str,
                 kerberos_kdc_address: str,
                 kerberos_principal: str,
                 kerberos_realm: str):
        """
        :param str credentials_type: Enum to determine the datastore credentials type.
               Expected value is 'KerberosKeytab'.
        :param str kerberos_kdc_address: [Required] IP Address or DNS HostName.
        :param str kerberos_principal: [Required] Kerberos Username
        :param str kerberos_realm: [Required] Domain over which a Kerberos authentication server has the authority to authenticate a user, host or service.
        """
        KerberosKeytabCredentialsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials_type=credentials_type,
            kerberos_kdc_address=kerberos_kdc_address,
            kerberos_principal=kerberos_principal,
            kerberos_realm=kerberos_realm,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials_type: Optional[str] = None,
             kerberos_kdc_address: Optional[str] = None,
             kerberos_principal: Optional[str] = None,
             kerberos_realm: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if credentials_type is None and 'credentialsType' in kwargs:
            credentials_type = kwargs['credentialsType']
        if credentials_type is None:
            raise TypeError("Missing 'credentials_type' argument")
        if kerberos_kdc_address is None and 'kerberosKdcAddress' in kwargs:
            kerberos_kdc_address = kwargs['kerberosKdcAddress']
        if kerberos_kdc_address is None:
            raise TypeError("Missing 'kerberos_kdc_address' argument")
        if kerberos_principal is None and 'kerberosPrincipal' in kwargs:
            kerberos_principal = kwargs['kerberosPrincipal']
        if kerberos_principal is None:
            raise TypeError("Missing 'kerberos_principal' argument")
        if kerberos_realm is None and 'kerberosRealm' in kwargs:
            kerberos_realm = kwargs['kerberosRealm']
        if kerberos_realm is None:
            raise TypeError("Missing 'kerberos_realm' argument")

        _setter("credentials_type", 'KerberosKeytab')
        _setter("kerberos_kdc_address", kerberos_kdc_address)
        _setter("kerberos_principal", kerberos_principal)
        _setter("kerberos_realm", kerberos_realm)

    @property
    @pulumi.getter(name="credentialsType")
    def credentials_type(self) -> str:
        """
        Enum to determine the datastore credentials type.
        Expected value is 'KerberosKeytab'.
        """
        return pulumi.get(self, "credentials_type")

    @property
    @pulumi.getter(name="kerberosKdcAddress")
    def kerberos_kdc_address(self) -> str:
        """
        [Required] IP Address or DNS HostName.
        """
        return pulumi.get(self, "kerberos_kdc_address")

    @property
    @pulumi.getter(name="kerberosPrincipal")
    def kerberos_principal(self) -> str:
        """
        [Required] Kerberos Username
        """
        return pulumi.get(self, "kerberos_principal")

    @property
    @pulumi.getter(name="kerberosRealm")
    def kerberos_realm(self) -> str:
        """
        [Required] Domain over which a Kerberos authentication server has the authority to authenticate a user, host or service.
        """
        return pulumi.get(self, "kerberos_realm")


@pulumi.output_type
class KerberosPasswordCredentialsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsType":
            suggest = "credentials_type"
        elif key == "kerberosKdcAddress":
            suggest = "kerberos_kdc_address"
        elif key == "kerberosPrincipal":
            suggest = "kerberos_principal"
        elif key == "kerberosRealm":
            suggest = "kerberos_realm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KerberosPasswordCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KerberosPasswordCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KerberosPasswordCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_type: str,
                 kerberos_kdc_address: str,
                 kerberos_principal: str,
                 kerberos_realm: str):
        """
        :param str credentials_type: Enum to determine the datastore credentials type.
               Expected value is 'KerberosPassword'.
        :param str kerberos_kdc_address: [Required] IP Address or DNS HostName.
        :param str kerberos_principal: [Required] Kerberos Username
        :param str kerberos_realm: [Required] Domain over which a Kerberos authentication server has the authority to authenticate a user, host or service.
        """
        KerberosPasswordCredentialsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials_type=credentials_type,
            kerberos_kdc_address=kerberos_kdc_address,
            kerberos_principal=kerberos_principal,
            kerberos_realm=kerberos_realm,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials_type: Optional[str] = None,
             kerberos_kdc_address: Optional[str] = None,
             kerberos_principal: Optional[str] = None,
             kerberos_realm: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if credentials_type is None and 'credentialsType' in kwargs:
            credentials_type = kwargs['credentialsType']
        if credentials_type is None:
            raise TypeError("Missing 'credentials_type' argument")
        if kerberos_kdc_address is None and 'kerberosKdcAddress' in kwargs:
            kerberos_kdc_address = kwargs['kerberosKdcAddress']
        if kerberos_kdc_address is None:
            raise TypeError("Missing 'kerberos_kdc_address' argument")
        if kerberos_principal is None and 'kerberosPrincipal' in kwargs:
            kerberos_principal = kwargs['kerberosPrincipal']
        if kerberos_principal is None:
            raise TypeError("Missing 'kerberos_principal' argument")
        if kerberos_realm is None and 'kerberosRealm' in kwargs:
            kerberos_realm = kwargs['kerberosRealm']
        if kerberos_realm is None:
            raise TypeError("Missing 'kerberos_realm' argument")

        _setter("credentials_type", 'KerberosPassword')
        _setter("kerberos_kdc_address", kerberos_kdc_address)
        _setter("kerberos_principal", kerberos_principal)
        _setter("kerberos_realm", kerberos_realm)

    @property
    @pulumi.getter(name="credentialsType")
    def credentials_type(self) -> str:
        """
        Enum to determine the datastore credentials type.
        Expected value is 'KerberosPassword'.
        """
        return pulumi.get(self, "credentials_type")

    @property
    @pulumi.getter(name="kerberosKdcAddress")
    def kerberos_kdc_address(self) -> str:
        """
        [Required] IP Address or DNS HostName.
        """
        return pulumi.get(self, "kerberos_kdc_address")

    @property
    @pulumi.getter(name="kerberosPrincipal")
    def kerberos_principal(self) -> str:
        """
        [Required] Kerberos Username
        """
        return pulumi.get(self, "kerberos_principal")

    @property
    @pulumi.getter(name="kerberosRealm")
    def kerberos_realm(self) -> str:
        """
        [Required] Domain over which a Kerberos authentication server has the authority to authenticate a user, host or service.
        """
        return pulumi.get(self, "kerberos_realm")


@pulumi.output_type
class KubernetesOnlineDeploymentResponse(dict):
    """
    Properties specific to a KubernetesOnlineDeployment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointComputeType":
            suggest = "endpoint_compute_type"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "appInsightsEnabled":
            suggest = "app_insights_enabled"
        elif key == "codeConfiguration":
            suggest = "code_configuration"
        elif key == "containerResourceRequirements":
            suggest = "container_resource_requirements"
        elif key == "egressPublicNetworkAccess":
            suggest = "egress_public_network_access"
        elif key == "environmentId":
            suggest = "environment_id"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "livenessProbe":
            suggest = "liveness_probe"
        elif key == "modelMountPath":
            suggest = "model_mount_path"
        elif key == "privateNetworkConnection":
            suggest = "private_network_connection"
        elif key == "readinessProbe":
            suggest = "readiness_probe"
        elif key == "requestSettings":
            suggest = "request_settings"
        elif key == "scaleSettings":
            suggest = "scale_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesOnlineDeploymentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesOnlineDeploymentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesOnlineDeploymentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_compute_type: str,
                 provisioning_state: str,
                 app_insights_enabled: Optional[bool] = None,
                 code_configuration: Optional['outputs.CodeConfigurationResponse'] = None,
                 container_resource_requirements: Optional['outputs.ContainerResourceRequirementsResponse'] = None,
                 description: Optional[str] = None,
                 egress_public_network_access: Optional[str] = None,
                 environment_id: Optional[str] = None,
                 environment_variables: Optional[Mapping[str, str]] = None,
                 instance_type: Optional[str] = None,
                 liveness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
                 model: Optional[str] = None,
                 model_mount_path: Optional[str] = None,
                 private_network_connection: Optional[bool] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 readiness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
                 request_settings: Optional['outputs.OnlineRequestSettingsResponse'] = None,
                 scale_settings: Optional[Any] = None):
        """
        Properties specific to a KubernetesOnlineDeployment.
        :param str endpoint_compute_type: Enum to determine endpoint compute type.
               Expected value is 'Kubernetes'.
        :param str provisioning_state: Provisioning state for the endpoint deployment.
        :param bool app_insights_enabled: If true, enables Application Insights logging.
        :param 'CodeConfigurationResponse' code_configuration: Code configuration for the endpoint deployment.
        :param 'ContainerResourceRequirementsResponse' container_resource_requirements: The resource requirements for the container (cpu and memory).
        :param str description: Description of the endpoint deployment.
        :param str egress_public_network_access: If Enabled, allow egress public network access. If Disabled, this will create secure egress. Default: Enabled.
        :param str environment_id: ARM resource ID of the environment specification for the endpoint deployment.
        :param Mapping[str, str] environment_variables: Environment variables configuration for the deployment.
        :param str instance_type: Compute instance type.
        :param 'ProbeSettingsResponse' liveness_probe: Liveness probe monitors the health of the container regularly.
        :param str model: The URI path to the model.
        :param str model_mount_path: The path to mount the model in custom container.
        :param bool private_network_connection: If true, enable private network connection.
               DEPRECATED for future API versions. Use EgressPublicNetworkAccess.
        :param Mapping[str, str] properties: Property dictionary. Properties can be added, but not removed or altered.
        :param 'ProbeSettingsResponse' readiness_probe: Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
        :param 'OnlineRequestSettingsResponse' request_settings: Request settings for the deployment.
        :param Union['DefaultScaleSettingsResponse', 'TargetUtilizationScaleSettingsResponse'] scale_settings: Scale settings for the deployment.
               If it is null or not provided,
               it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
               and to DefaultScaleSettings for ManagedOnlineDeployment.
        """
        KubernetesOnlineDeploymentResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_compute_type=endpoint_compute_type,
            provisioning_state=provisioning_state,
            app_insights_enabled=app_insights_enabled,
            code_configuration=code_configuration,
            container_resource_requirements=container_resource_requirements,
            description=description,
            egress_public_network_access=egress_public_network_access,
            environment_id=environment_id,
            environment_variables=environment_variables,
            instance_type=instance_type,
            liveness_probe=liveness_probe,
            model=model,
            model_mount_path=model_mount_path,
            private_network_connection=private_network_connection,
            properties=properties,
            readiness_probe=readiness_probe,
            request_settings=request_settings,
            scale_settings=scale_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_compute_type: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             app_insights_enabled: Optional[bool] = None,
             code_configuration: Optional['outputs.CodeConfigurationResponse'] = None,
             container_resource_requirements: Optional['outputs.ContainerResourceRequirementsResponse'] = None,
             description: Optional[str] = None,
             egress_public_network_access: Optional[str] = None,
             environment_id: Optional[str] = None,
             environment_variables: Optional[Mapping[str, str]] = None,
             instance_type: Optional[str] = None,
             liveness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
             model: Optional[str] = None,
             model_mount_path: Optional[str] = None,
             private_network_connection: Optional[bool] = None,
             properties: Optional[Mapping[str, str]] = None,
             readiness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
             request_settings: Optional['outputs.OnlineRequestSettingsResponse'] = None,
             scale_settings: Optional[Any] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if endpoint_compute_type is None and 'endpointComputeType' in kwargs:
            endpoint_compute_type = kwargs['endpointComputeType']
        if endpoint_compute_type is None:
            raise TypeError("Missing 'endpoint_compute_type' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if app_insights_enabled is None and 'appInsightsEnabled' in kwargs:
            app_insights_enabled = kwargs['appInsightsEnabled']
        if code_configuration is None and 'codeConfiguration' in kwargs:
            code_configuration = kwargs['codeConfiguration']
        if container_resource_requirements is None and 'containerResourceRequirements' in kwargs:
            container_resource_requirements = kwargs['containerResourceRequirements']
        if egress_public_network_access is None and 'egressPublicNetworkAccess' in kwargs:
            egress_public_network_access = kwargs['egressPublicNetworkAccess']
        if environment_id is None and 'environmentId' in kwargs:
            environment_id = kwargs['environmentId']
        if environment_variables is None and 'environmentVariables' in kwargs:
            environment_variables = kwargs['environmentVariables']
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if liveness_probe is None and 'livenessProbe' in kwargs:
            liveness_probe = kwargs['livenessProbe']
        if model_mount_path is None and 'modelMountPath' in kwargs:
            model_mount_path = kwargs['modelMountPath']
        if private_network_connection is None and 'privateNetworkConnection' in kwargs:
            private_network_connection = kwargs['privateNetworkConnection']
        if readiness_probe is None and 'readinessProbe' in kwargs:
            readiness_probe = kwargs['readinessProbe']
        if request_settings is None and 'requestSettings' in kwargs:
            request_settings = kwargs['requestSettings']
        if scale_settings is None and 'scaleSettings' in kwargs:
            scale_settings = kwargs['scaleSettings']

        _setter("endpoint_compute_type", 'Kubernetes')
        _setter("provisioning_state", provisioning_state)
        if app_insights_enabled is None:
            app_insights_enabled = False
        if app_insights_enabled is not None:
            _setter("app_insights_enabled", app_insights_enabled)
        if code_configuration is not None:
            _setter("code_configuration", code_configuration)
        if container_resource_requirements is not None:
            _setter("container_resource_requirements", container_resource_requirements)
        if description is not None:
            _setter("description", description)
        if egress_public_network_access is None:
            egress_public_network_access = 'Enabled'
        if egress_public_network_access is not None:
            _setter("egress_public_network_access", egress_public_network_access)
        if environment_id is not None:
            _setter("environment_id", environment_id)
        if environment_variables is not None:
            _setter("environment_variables", environment_variables)
        if instance_type is not None:
            _setter("instance_type", instance_type)
        if liveness_probe is not None:
            _setter("liveness_probe", liveness_probe)
        if model is not None:
            _setter("model", model)
        if model_mount_path is not None:
            _setter("model_mount_path", model_mount_path)
        if private_network_connection is None:
            private_network_connection = False
        if private_network_connection is not None:
            _setter("private_network_connection", private_network_connection)
        if properties is not None:
            _setter("properties", properties)
        if readiness_probe is not None:
            _setter("readiness_probe", readiness_probe)
        if request_settings is not None:
            _setter("request_settings", request_settings)
        if scale_settings is not None:
            _setter("scale_settings", scale_settings)

    @property
    @pulumi.getter(name="endpointComputeType")
    def endpoint_compute_type(self) -> str:
        """
        Enum to determine endpoint compute type.
        Expected value is 'Kubernetes'.
        """
        return pulumi.get(self, "endpoint_compute_type")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning state for the endpoint deployment.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="appInsightsEnabled")
    def app_insights_enabled(self) -> Optional[bool]:
        """
        If true, enables Application Insights logging.
        """
        return pulumi.get(self, "app_insights_enabled")

    @property
    @pulumi.getter(name="codeConfiguration")
    def code_configuration(self) -> Optional['outputs.CodeConfigurationResponse']:
        """
        Code configuration for the endpoint deployment.
        """
        return pulumi.get(self, "code_configuration")

    @property
    @pulumi.getter(name="containerResourceRequirements")
    def container_resource_requirements(self) -> Optional['outputs.ContainerResourceRequirementsResponse']:
        """
        The resource requirements for the container (cpu and memory).
        """
        return pulumi.get(self, "container_resource_requirements")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the endpoint deployment.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="egressPublicNetworkAccess")
    def egress_public_network_access(self) -> Optional[str]:
        """
        If Enabled, allow egress public network access. If Disabled, this will create secure egress. Default: Enabled.
        """
        return pulumi.get(self, "egress_public_network_access")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[str]:
        """
        ARM resource ID of the environment specification for the endpoint deployment.
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, str]]:
        """
        Environment variables configuration for the deployment.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        Compute instance type.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.ProbeSettingsResponse']:
        """
        Liveness probe monitors the health of the container regularly.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def model(self) -> Optional[str]:
        """
        The URI path to the model.
        """
        return pulumi.get(self, "model")

    @property
    @pulumi.getter(name="modelMountPath")
    def model_mount_path(self) -> Optional[str]:
        """
        The path to mount the model in custom container.
        """
        return pulumi.get(self, "model_mount_path")

    @property
    @pulumi.getter(name="privateNetworkConnection")
    def private_network_connection(self) -> Optional[bool]:
        """
        If true, enable private network connection.
        DEPRECATED for future API versions. Use EgressPublicNetworkAccess.
        """
        return pulumi.get(self, "private_network_connection")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.ProbeSettingsResponse']:
        """
        Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter(name="requestSettings")
    def request_settings(self) -> Optional['outputs.OnlineRequestSettingsResponse']:
        """
        Request settings for the deployment.
        """
        return pulumi.get(self, "request_settings")

    @property
    @pulumi.getter(name="scaleSettings")
    def scale_settings(self) -> Optional[Any]:
        """
        Scale settings for the deployment.
        If it is null or not provided,
        it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
        and to DefaultScaleSettings for ManagedOnlineDeployment.
        """
        return pulumi.get(self, "scale_settings")


@pulumi.output_type
class LiteralJobInputResponse(dict):
    """
    Literal input type.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobInputType":
            suggest = "job_input_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LiteralJobInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LiteralJobInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LiteralJobInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_input_type: str,
                 value: str,
                 description: Optional[str] = None):
        """
        Literal input type.
        :param str job_input_type: Enum to determine the Job Input Type.
               Expected value is 'Literal'.
        :param str value: [Required] Literal value for the input.
        :param str description: Description for the input.
        """
        LiteralJobInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_input_type=job_input_type,
            value=value,
            description=description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_input_type: Optional[str] = None,
             value: Optional[str] = None,
             description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if job_input_type is None and 'jobInputType' in kwargs:
            job_input_type = kwargs['jobInputType']
        if job_input_type is None:
            raise TypeError("Missing 'job_input_type' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("job_input_type", 'Literal')
        _setter("value", value)
        if description is not None:
            _setter("description", description)

    @property
    @pulumi.getter(name="jobInputType")
    def job_input_type(self) -> str:
        """
        Enum to determine the Job Input Type.
        Expected value is 'Literal'.
        """
        return pulumi.get(self, "job_input_type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        [Required] Literal value for the input.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for the input.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class MLFlowModelJobInputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobInputType":
            suggest = "job_input_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLFlowModelJobInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLFlowModelJobInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLFlowModelJobInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_input_type: str,
                 uri: str,
                 description: Optional[str] = None,
                 mode: Optional[str] = None):
        """
        :param str job_input_type: Enum to determine the Job Input Type.
               Expected value is 'MLFlowModel'.
        :param str uri: [Required] Input Asset URI.
        :param str description: Description for the input.
        :param str mode: Input Asset Delivery Mode.
        """
        MLFlowModelJobInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_input_type=job_input_type,
            uri=uri,
            description=description,
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_input_type: Optional[str] = None,
             uri: Optional[str] = None,
             description: Optional[str] = None,
             mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if job_input_type is None and 'jobInputType' in kwargs:
            job_input_type = kwargs['jobInputType']
        if job_input_type is None:
            raise TypeError("Missing 'job_input_type' argument")
        if uri is None:
            raise TypeError("Missing 'uri' argument")

        _setter("job_input_type", 'MLFlowModel')
        _setter("uri", uri)
        if description is not None:
            _setter("description", description)
        if mode is None:
            mode = 'ReadOnlyMount'
        if mode is not None:
            _setter("mode", mode)

    @property
    @pulumi.getter(name="jobInputType")
    def job_input_type(self) -> str:
        """
        Enum to determine the Job Input Type.
        Expected value is 'MLFlowModel'.
        """
        return pulumi.get(self, "job_input_type")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        [Required] Input Asset URI.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for the input.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Input Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class MLFlowModelJobOutputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobOutputType":
            suggest = "job_output_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLFlowModelJobOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLFlowModelJobOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLFlowModelJobOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_output_type: str,
                 description: Optional[str] = None,
                 mode: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        :param str job_output_type: Enum to determine the Job Output Type.
               Expected value is 'MLFlowModel'.
        :param str description: Description for the output.
        :param str mode: Output Asset Delivery Mode.
        :param str uri: Output Asset URI.
        """
        MLFlowModelJobOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_output_type=job_output_type,
            description=description,
            mode=mode,
            uri=uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_output_type: Optional[str] = None,
             description: Optional[str] = None,
             mode: Optional[str] = None,
             uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if job_output_type is None and 'jobOutputType' in kwargs:
            job_output_type = kwargs['jobOutputType']
        if job_output_type is None:
            raise TypeError("Missing 'job_output_type' argument")

        _setter("job_output_type", 'MLFlowModel')
        if description is not None:
            _setter("description", description)
        if mode is None:
            mode = 'ReadWriteMount'
        if mode is not None:
            _setter("mode", mode)
        if uri is not None:
            _setter("uri", uri)

    @property
    @pulumi.getter(name="jobOutputType")
    def job_output_type(self) -> str:
        """
        Enum to determine the Job Output Type.
        Expected value is 'MLFlowModel'.
        """
        return pulumi.get(self, "job_output_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for the output.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Output Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        Output Asset URI.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class MLTableDataResponse(dict):
    """
    MLTable data definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "dataUri":
            suggest = "data_uri"
        elif key == "isAnonymous":
            suggest = "is_anonymous"
        elif key == "isArchived":
            suggest = "is_archived"
        elif key == "referencedUris":
            suggest = "referenced_uris"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLTableDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLTableDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLTableDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: str,
                 data_uri: str,
                 description: Optional[str] = None,
                 is_anonymous: Optional[bool] = None,
                 is_archived: Optional[bool] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 referenced_uris: Optional[Sequence[str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        MLTable data definition
        :param str data_type: Enum to determine the type of data.
               Expected value is 'MLTable'.
        :param str data_uri: [Required] Uri of the data. Usage/meaning depends on Microsoft.MachineLearning.ManagementFrontEnd.Contracts.V20220201Preview.Assets.DataVersionBase.DataType
        :param str description: The asset description text.
        :param bool is_anonymous: If the name version are system generated (anonymous registration).
        :param bool is_archived: Is the asset archived?
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Sequence[str] referenced_uris: Uris referenced in the MLTable definition (required for lineage)
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        MLTableDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_type=data_type,
            data_uri=data_uri,
            description=description,
            is_anonymous=is_anonymous,
            is_archived=is_archived,
            properties=properties,
            referenced_uris=referenced_uris,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_type: Optional[str] = None,
             data_uri: Optional[str] = None,
             description: Optional[str] = None,
             is_anonymous: Optional[bool] = None,
             is_archived: Optional[bool] = None,
             properties: Optional[Mapping[str, str]] = None,
             referenced_uris: Optional[Sequence[str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_type is None and 'dataType' in kwargs:
            data_type = kwargs['dataType']
        if data_type is None:
            raise TypeError("Missing 'data_type' argument")
        if data_uri is None and 'dataUri' in kwargs:
            data_uri = kwargs['dataUri']
        if data_uri is None:
            raise TypeError("Missing 'data_uri' argument")
        if is_anonymous is None and 'isAnonymous' in kwargs:
            is_anonymous = kwargs['isAnonymous']
        if is_archived is None and 'isArchived' in kwargs:
            is_archived = kwargs['isArchived']
        if referenced_uris is None and 'referencedUris' in kwargs:
            referenced_uris = kwargs['referencedUris']

        _setter("data_type", 'MLTable')
        _setter("data_uri", data_uri)
        if description is not None:
            _setter("description", description)
        if is_anonymous is None:
            is_anonymous = False
        if is_anonymous is not None:
            _setter("is_anonymous", is_anonymous)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            _setter("is_archived", is_archived)
        if properties is not None:
            _setter("properties", properties)
        if referenced_uris is not None:
            _setter("referenced_uris", referenced_uris)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        Enum to determine the type of data.
        Expected value is 'MLTable'.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="dataUri")
    def data_uri(self) -> str:
        """
        [Required] Uri of the data. Usage/meaning depends on Microsoft.MachineLearning.ManagementFrontEnd.Contracts.V20220201Preview.Assets.DataVersionBase.DataType
        """
        return pulumi.get(self, "data_uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[bool]:
        """
        If the name version are system generated (anonymous registration).
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="referencedUris")
    def referenced_uris(self) -> Optional[Sequence[str]]:
        """
        Uris referenced in the MLTable definition (required for lineage)
        """
        return pulumi.get(self, "referenced_uris")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class MLTableJobInputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobInputType":
            suggest = "job_input_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLTableJobInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLTableJobInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLTableJobInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_input_type: str,
                 uri: str,
                 description: Optional[str] = None,
                 mode: Optional[str] = None):
        """
        :param str job_input_type: Enum to determine the Job Input Type.
               Expected value is 'MLTable'.
        :param str uri: [Required] Input Asset URI.
        :param str description: Description for the input.
        :param str mode: Input Asset Delivery Mode.
        """
        MLTableJobInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_input_type=job_input_type,
            uri=uri,
            description=description,
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_input_type: Optional[str] = None,
             uri: Optional[str] = None,
             description: Optional[str] = None,
             mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if job_input_type is None and 'jobInputType' in kwargs:
            job_input_type = kwargs['jobInputType']
        if job_input_type is None:
            raise TypeError("Missing 'job_input_type' argument")
        if uri is None:
            raise TypeError("Missing 'uri' argument")

        _setter("job_input_type", 'MLTable')
        _setter("uri", uri)
        if description is not None:
            _setter("description", description)
        if mode is None:
            mode = 'ReadOnlyMount'
        if mode is not None:
            _setter("mode", mode)

    @property
    @pulumi.getter(name="jobInputType")
    def job_input_type(self) -> str:
        """
        Enum to determine the Job Input Type.
        Expected value is 'MLTable'.
        """
        return pulumi.get(self, "job_input_type")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        [Required] Input Asset URI.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for the input.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Input Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class MLTableJobOutputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobOutputType":
            suggest = "job_output_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLTableJobOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLTableJobOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLTableJobOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_output_type: str,
                 description: Optional[str] = None,
                 mode: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        :param str job_output_type: Enum to determine the Job Output Type.
               Expected value is 'MLTable'.
        :param str description: Description for the output.
        :param str mode: Output Asset Delivery Mode.
        :param str uri: Output Asset URI.
        """
        MLTableJobOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_output_type=job_output_type,
            description=description,
            mode=mode,
            uri=uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_output_type: Optional[str] = None,
             description: Optional[str] = None,
             mode: Optional[str] = None,
             uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if job_output_type is None and 'jobOutputType' in kwargs:
            job_output_type = kwargs['jobOutputType']
        if job_output_type is None:
            raise TypeError("Missing 'job_output_type' argument")

        _setter("job_output_type", 'MLTable')
        if description is not None:
            _setter("description", description)
        if mode is None:
            mode = 'ReadWriteMount'
        if mode is not None:
            _setter("mode", mode)
        if uri is not None:
            _setter("uri", uri)

    @property
    @pulumi.getter(name="jobOutputType")
    def job_output_type(self) -> str:
        """
        Enum to determine the Job Output Type.
        Expected value is 'MLTable'.
        """
        return pulumi.get(self, "job_output_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for the output.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Output Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        Output Asset URI.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class ManagedIdentityResponse(dict):
    """
    Managed identity configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityType":
            suggest = "identity_type"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_type: str,
                 client_id: Optional[str] = None,
                 object_id: Optional[str] = None,
                 resource_id: Optional[str] = None):
        """
        Managed identity configuration.
        :param str identity_type: Enum to determine identity framework.
               Expected value is 'Managed'.
        :param str client_id: Specifies a user-assigned identity by client ID. For system-assigned, do not set this field.
        :param str object_id: Specifies a user-assigned identity by object ID. For system-assigned, do not set this field.
        :param str resource_id: Specifies a user-assigned identity by ARM resource ID. For system-assigned, do not set this field.
        """
        ManagedIdentityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_type=identity_type,
            client_id=client_id,
            object_id=object_id,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_type: Optional[str] = None,
             client_id: Optional[str] = None,
             object_id: Optional[str] = None,
             resource_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if identity_type is None and 'identityType' in kwargs:
            identity_type = kwargs['identityType']
        if identity_type is None:
            raise TypeError("Missing 'identity_type' argument")
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if object_id is None and 'objectId' in kwargs:
            object_id = kwargs['objectId']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        _setter("identity_type", 'Managed')
        if client_id is not None:
            _setter("client_id", client_id)
        if object_id is not None:
            _setter("object_id", object_id)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="identityType")
    def identity_type(self) -> str:
        """
        Enum to determine identity framework.
        Expected value is 'Managed'.
        """
        return pulumi.get(self, "identity_type")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        Specifies a user-assigned identity by client ID. For system-assigned, do not set this field.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[str]:
        """
        Specifies a user-assigned identity by object ID. For system-assigned, do not set this field.
        """
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        Specifies a user-assigned identity by ARM resource ID. For system-assigned, do not set this field.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class ManagedOnlineDeploymentResponse(dict):
    """
    Properties specific to a ManagedOnlineDeployment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointComputeType":
            suggest = "endpoint_compute_type"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "appInsightsEnabled":
            suggest = "app_insights_enabled"
        elif key == "codeConfiguration":
            suggest = "code_configuration"
        elif key == "egressPublicNetworkAccess":
            suggest = "egress_public_network_access"
        elif key == "environmentId":
            suggest = "environment_id"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "livenessProbe":
            suggest = "liveness_probe"
        elif key == "modelMountPath":
            suggest = "model_mount_path"
        elif key == "privateNetworkConnection":
            suggest = "private_network_connection"
        elif key == "readinessProbe":
            suggest = "readiness_probe"
        elif key == "requestSettings":
            suggest = "request_settings"
        elif key == "scaleSettings":
            suggest = "scale_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedOnlineDeploymentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedOnlineDeploymentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedOnlineDeploymentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_compute_type: str,
                 provisioning_state: str,
                 app_insights_enabled: Optional[bool] = None,
                 code_configuration: Optional['outputs.CodeConfigurationResponse'] = None,
                 description: Optional[str] = None,
                 egress_public_network_access: Optional[str] = None,
                 environment_id: Optional[str] = None,
                 environment_variables: Optional[Mapping[str, str]] = None,
                 instance_type: Optional[str] = None,
                 liveness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
                 model: Optional[str] = None,
                 model_mount_path: Optional[str] = None,
                 private_network_connection: Optional[bool] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 readiness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
                 request_settings: Optional['outputs.OnlineRequestSettingsResponse'] = None,
                 scale_settings: Optional[Any] = None):
        """
        Properties specific to a ManagedOnlineDeployment.
        :param str endpoint_compute_type: Enum to determine endpoint compute type.
               Expected value is 'Managed'.
        :param str provisioning_state: Provisioning state for the endpoint deployment.
        :param bool app_insights_enabled: If true, enables Application Insights logging.
        :param 'CodeConfigurationResponse' code_configuration: Code configuration for the endpoint deployment.
        :param str description: Description of the endpoint deployment.
        :param str egress_public_network_access: If Enabled, allow egress public network access. If Disabled, this will create secure egress. Default: Enabled.
        :param str environment_id: ARM resource ID of the environment specification for the endpoint deployment.
        :param Mapping[str, str] environment_variables: Environment variables configuration for the deployment.
        :param str instance_type: Compute instance type.
        :param 'ProbeSettingsResponse' liveness_probe: Liveness probe monitors the health of the container regularly.
        :param str model: The URI path to the model.
        :param str model_mount_path: The path to mount the model in custom container.
        :param bool private_network_connection: If true, enable private network connection.
               DEPRECATED for future API versions. Use EgressPublicNetworkAccess.
        :param Mapping[str, str] properties: Property dictionary. Properties can be added, but not removed or altered.
        :param 'ProbeSettingsResponse' readiness_probe: Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
        :param 'OnlineRequestSettingsResponse' request_settings: Request settings for the deployment.
        :param Union['DefaultScaleSettingsResponse', 'TargetUtilizationScaleSettingsResponse'] scale_settings: Scale settings for the deployment.
               If it is null or not provided,
               it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
               and to DefaultScaleSettings for ManagedOnlineDeployment.
        """
        ManagedOnlineDeploymentResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_compute_type=endpoint_compute_type,
            provisioning_state=provisioning_state,
            app_insights_enabled=app_insights_enabled,
            code_configuration=code_configuration,
            description=description,
            egress_public_network_access=egress_public_network_access,
            environment_id=environment_id,
            environment_variables=environment_variables,
            instance_type=instance_type,
            liveness_probe=liveness_probe,
            model=model,
            model_mount_path=model_mount_path,
            private_network_connection=private_network_connection,
            properties=properties,
            readiness_probe=readiness_probe,
            request_settings=request_settings,
            scale_settings=scale_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_compute_type: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             app_insights_enabled: Optional[bool] = None,
             code_configuration: Optional['outputs.CodeConfigurationResponse'] = None,
             description: Optional[str] = None,
             egress_public_network_access: Optional[str] = None,
             environment_id: Optional[str] = None,
             environment_variables: Optional[Mapping[str, str]] = None,
             instance_type: Optional[str] = None,
             liveness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
             model: Optional[str] = None,
             model_mount_path: Optional[str] = None,
             private_network_connection: Optional[bool] = None,
             properties: Optional[Mapping[str, str]] = None,
             readiness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
             request_settings: Optional['outputs.OnlineRequestSettingsResponse'] = None,
             scale_settings: Optional[Any] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if endpoint_compute_type is None and 'endpointComputeType' in kwargs:
            endpoint_compute_type = kwargs['endpointComputeType']
        if endpoint_compute_type is None:
            raise TypeError("Missing 'endpoint_compute_type' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if app_insights_enabled is None and 'appInsightsEnabled' in kwargs:
            app_insights_enabled = kwargs['appInsightsEnabled']
        if code_configuration is None and 'codeConfiguration' in kwargs:
            code_configuration = kwargs['codeConfiguration']
        if egress_public_network_access is None and 'egressPublicNetworkAccess' in kwargs:
            egress_public_network_access = kwargs['egressPublicNetworkAccess']
        if environment_id is None and 'environmentId' in kwargs:
            environment_id = kwargs['environmentId']
        if environment_variables is None and 'environmentVariables' in kwargs:
            environment_variables = kwargs['environmentVariables']
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if liveness_probe is None and 'livenessProbe' in kwargs:
            liveness_probe = kwargs['livenessProbe']
        if model_mount_path is None and 'modelMountPath' in kwargs:
            model_mount_path = kwargs['modelMountPath']
        if private_network_connection is None and 'privateNetworkConnection' in kwargs:
            private_network_connection = kwargs['privateNetworkConnection']
        if readiness_probe is None and 'readinessProbe' in kwargs:
            readiness_probe = kwargs['readinessProbe']
        if request_settings is None and 'requestSettings' in kwargs:
            request_settings = kwargs['requestSettings']
        if scale_settings is None and 'scaleSettings' in kwargs:
            scale_settings = kwargs['scaleSettings']

        _setter("endpoint_compute_type", 'Managed')
        _setter("provisioning_state", provisioning_state)
        if app_insights_enabled is None:
            app_insights_enabled = False
        if app_insights_enabled is not None:
            _setter("app_insights_enabled", app_insights_enabled)
        if code_configuration is not None:
            _setter("code_configuration", code_configuration)
        if description is not None:
            _setter("description", description)
        if egress_public_network_access is None:
            egress_public_network_access = 'Enabled'
        if egress_public_network_access is not None:
            _setter("egress_public_network_access", egress_public_network_access)
        if environment_id is not None:
            _setter("environment_id", environment_id)
        if environment_variables is not None:
            _setter("environment_variables", environment_variables)
        if instance_type is not None:
            _setter("instance_type", instance_type)
        if liveness_probe is not None:
            _setter("liveness_probe", liveness_probe)
        if model is not None:
            _setter("model", model)
        if model_mount_path is not None:
            _setter("model_mount_path", model_mount_path)
        if private_network_connection is None:
            private_network_connection = False
        if private_network_connection is not None:
            _setter("private_network_connection", private_network_connection)
        if properties is not None:
            _setter("properties", properties)
        if readiness_probe is not None:
            _setter("readiness_probe", readiness_probe)
        if request_settings is not None:
            _setter("request_settings", request_settings)
        if scale_settings is not None:
            _setter("scale_settings", scale_settings)

    @property
    @pulumi.getter(name="endpointComputeType")
    def endpoint_compute_type(self) -> str:
        """
        Enum to determine endpoint compute type.
        Expected value is 'Managed'.
        """
        return pulumi.get(self, "endpoint_compute_type")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning state for the endpoint deployment.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="appInsightsEnabled")
    def app_insights_enabled(self) -> Optional[bool]:
        """
        If true, enables Application Insights logging.
        """
        return pulumi.get(self, "app_insights_enabled")

    @property
    @pulumi.getter(name="codeConfiguration")
    def code_configuration(self) -> Optional['outputs.CodeConfigurationResponse']:
        """
        Code configuration for the endpoint deployment.
        """
        return pulumi.get(self, "code_configuration")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the endpoint deployment.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="egressPublicNetworkAccess")
    def egress_public_network_access(self) -> Optional[str]:
        """
        If Enabled, allow egress public network access. If Disabled, this will create secure egress. Default: Enabled.
        """
        return pulumi.get(self, "egress_public_network_access")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[str]:
        """
        ARM resource ID of the environment specification for the endpoint deployment.
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, str]]:
        """
        Environment variables configuration for the deployment.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        Compute instance type.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.ProbeSettingsResponse']:
        """
        Liveness probe monitors the health of the container regularly.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def model(self) -> Optional[str]:
        """
        The URI path to the model.
        """
        return pulumi.get(self, "model")

    @property
    @pulumi.getter(name="modelMountPath")
    def model_mount_path(self) -> Optional[str]:
        """
        The path to mount the model in custom container.
        """
        return pulumi.get(self, "model_mount_path")

    @property
    @pulumi.getter(name="privateNetworkConnection")
    def private_network_connection(self) -> Optional[bool]:
        """
        If true, enable private network connection.
        DEPRECATED for future API versions. Use EgressPublicNetworkAccess.
        """
        return pulumi.get(self, "private_network_connection")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.ProbeSettingsResponse']:
        """
        Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter(name="requestSettings")
    def request_settings(self) -> Optional['outputs.OnlineRequestSettingsResponse']:
        """
        Request settings for the deployment.
        """
        return pulumi.get(self, "request_settings")

    @property
    @pulumi.getter(name="scaleSettings")
    def scale_settings(self) -> Optional[Any]:
        """
        Scale settings for the deployment.
        If it is null or not provided,
        it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
        and to DefaultScaleSettings for ManagedOnlineDeployment.
        """
        return pulumi.get(self, "scale_settings")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity (system assigned and/or user assigned identities)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        ManagedServiceIdentityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            principal_id=principal_id,
            tenant_id=tenant_id,
            type=type,
            user_assigned_identities=user_assigned_identities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             principal_id: Optional[str] = None,
             tenant_id: Optional[str] = None,
             type: Optional[str] = None,
             user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if principal_id is None and 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if principal_id is None:
            raise TypeError("Missing 'principal_id' argument")
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_id is None:
            raise TypeError("Missing 'tenant_id' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if user_assigned_identities is None and 'userAssignedIdentities' in kwargs:
            user_assigned_identities = kwargs['userAssignedIdentities']

        _setter("principal_id", principal_id)
        _setter("tenant_id", tenant_id)
        _setter("type", type)
        if user_assigned_identities is not None:
            _setter("user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class MedianStoppingPolicyResponse(dict):
    """
    Defines an early termination policy based on running averages of the primary metric of all runs
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyType":
            suggest = "policy_type"
        elif key == "delayEvaluation":
            suggest = "delay_evaluation"
        elif key == "evaluationInterval":
            suggest = "evaluation_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MedianStoppingPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MedianStoppingPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MedianStoppingPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_type: str,
                 delay_evaluation: Optional[int] = None,
                 evaluation_interval: Optional[int] = None):
        """
        Defines an early termination policy based on running averages of the primary metric of all runs
        :param str policy_type: 
               Expected value is 'MedianStopping'.
        :param int delay_evaluation: Number of intervals by which to delay the first evaluation.
        :param int evaluation_interval: Interval (number of runs) between policy evaluations.
        """
        MedianStoppingPolicyResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy_type=policy_type,
            delay_evaluation=delay_evaluation,
            evaluation_interval=evaluation_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy_type: Optional[str] = None,
             delay_evaluation: Optional[int] = None,
             evaluation_interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if policy_type is None and 'policyType' in kwargs:
            policy_type = kwargs['policyType']
        if policy_type is None:
            raise TypeError("Missing 'policy_type' argument")
        if delay_evaluation is None and 'delayEvaluation' in kwargs:
            delay_evaluation = kwargs['delayEvaluation']
        if evaluation_interval is None and 'evaluationInterval' in kwargs:
            evaluation_interval = kwargs['evaluationInterval']

        _setter("policy_type", 'MedianStopping')
        if delay_evaluation is None:
            delay_evaluation = 0
        if delay_evaluation is not None:
            _setter("delay_evaluation", delay_evaluation)
        if evaluation_interval is None:
            evaluation_interval = 0
        if evaluation_interval is not None:
            _setter("evaluation_interval", evaluation_interval)

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> str:
        """

        Expected value is 'MedianStopping'.
        """
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="delayEvaluation")
    def delay_evaluation(self) -> Optional[int]:
        """
        Number of intervals by which to delay the first evaluation.
        """
        return pulumi.get(self, "delay_evaluation")

    @property
    @pulumi.getter(name="evaluationInterval")
    def evaluation_interval(self) -> Optional[int]:
        """
        Interval (number of runs) between policy evaluations.
        """
        return pulumi.get(self, "evaluation_interval")


@pulumi.output_type
class ModelContainerResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latestVersion":
            suggest = "latest_version"
        elif key == "nextVersion":
            suggest = "next_version"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelContainerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelContainerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelContainerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latest_version: str,
                 next_version: str,
                 description: Optional[str] = None,
                 is_archived: Optional[bool] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str latest_version: The latest version inside this container.
        :param str next_version: The next auto incremental version
        :param str description: The asset description text.
        :param bool is_archived: Is the asset archived?
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        ModelContainerResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            latest_version=latest_version,
            next_version=next_version,
            description=description,
            is_archived=is_archived,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             latest_version: Optional[str] = None,
             next_version: Optional[str] = None,
             description: Optional[str] = None,
             is_archived: Optional[bool] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if latest_version is None and 'latestVersion' in kwargs:
            latest_version = kwargs['latestVersion']
        if latest_version is None:
            raise TypeError("Missing 'latest_version' argument")
        if next_version is None and 'nextVersion' in kwargs:
            next_version = kwargs['nextVersion']
        if next_version is None:
            raise TypeError("Missing 'next_version' argument")
        if is_archived is None and 'isArchived' in kwargs:
            is_archived = kwargs['isArchived']

        _setter("latest_version", latest_version)
        _setter("next_version", next_version)
        if description is not None:
            _setter("description", description)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            _setter("is_archived", is_archived)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> str:
        """
        The latest version inside this container.
        """
        return pulumi.get(self, "latest_version")

    @property
    @pulumi.getter(name="nextVersion")
    def next_version(self) -> str:
        """
        The next auto incremental version
        """
        return pulumi.get(self, "next_version")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ModelVersionResponse(dict):
    """
    Model asset version details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isAnonymous":
            suggest = "is_anonymous"
        elif key == "isArchived":
            suggest = "is_archived"
        elif key == "jobName":
            suggest = "job_name"
        elif key == "modelType":
            suggest = "model_type"
        elif key == "modelUri":
            suggest = "model_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 flavors: Optional[Mapping[str, 'outputs.FlavorDataResponse']] = None,
                 is_anonymous: Optional[bool] = None,
                 is_archived: Optional[bool] = None,
                 job_name: Optional[str] = None,
                 model_type: Optional[str] = None,
                 model_uri: Optional[str] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Model asset version details.
        :param str description: The asset description text.
        :param Mapping[str, 'FlavorDataResponse'] flavors: Mapping of model flavors to their properties.
        :param bool is_anonymous: If the name version are system generated (anonymous registration).
        :param bool is_archived: Is the asset archived?
        :param str job_name: Name of the training job which produced this model
        :param str model_type: The storage format for this entity. Used for NCD.
        :param str model_uri: The URI path to the model contents.
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        ModelVersionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            flavors=flavors,
            is_anonymous=is_anonymous,
            is_archived=is_archived,
            job_name=job_name,
            model_type=model_type,
            model_uri=model_uri,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             flavors: Optional[Mapping[str, 'outputs.FlavorDataResponse']] = None,
             is_anonymous: Optional[bool] = None,
             is_archived: Optional[bool] = None,
             job_name: Optional[str] = None,
             model_type: Optional[str] = None,
             model_uri: Optional[str] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if is_anonymous is None and 'isAnonymous' in kwargs:
            is_anonymous = kwargs['isAnonymous']
        if is_archived is None and 'isArchived' in kwargs:
            is_archived = kwargs['isArchived']
        if job_name is None and 'jobName' in kwargs:
            job_name = kwargs['jobName']
        if model_type is None and 'modelType' in kwargs:
            model_type = kwargs['modelType']
        if model_uri is None and 'modelUri' in kwargs:
            model_uri = kwargs['modelUri']

        if description is not None:
            _setter("description", description)
        if flavors is not None:
            _setter("flavors", flavors)
        if is_anonymous is None:
            is_anonymous = False
        if is_anonymous is not None:
            _setter("is_anonymous", is_anonymous)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            _setter("is_archived", is_archived)
        if job_name is not None:
            _setter("job_name", job_name)
        if model_type is None:
            model_type = 'CustomModel'
        if model_type is not None:
            _setter("model_type", model_type)
        if model_uri is not None:
            _setter("model_uri", model_uri)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def flavors(self) -> Optional[Mapping[str, 'outputs.FlavorDataResponse']]:
        """
        Mapping of model flavors to their properties.
        """
        return pulumi.get(self, "flavors")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[bool]:
        """
        If the name version are system generated (anonymous registration).
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter(name="jobName")
    def job_name(self) -> Optional[str]:
        """
        Name of the training job which produced this model
        """
        return pulumi.get(self, "job_name")

    @property
    @pulumi.getter(name="modelType")
    def model_type(self) -> Optional[str]:
        """
        The storage format for this entity. Used for NCD.
        """
        return pulumi.get(self, "model_type")

    @property
    @pulumi.getter(name="modelUri")
    def model_uri(self) -> Optional[str]:
        """
        The URI path to the model contents.
        """
        return pulumi.get(self, "model_uri")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class MpiResponse(dict):
    """
    MPI distribution configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "distributionType":
            suggest = "distribution_type"
        elif key == "processCountPerInstance":
            suggest = "process_count_per_instance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MpiResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MpiResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MpiResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 distribution_type: str,
                 process_count_per_instance: Optional[int] = None):
        """
        MPI distribution configuration.
        :param str distribution_type: Enum to determine the job distribution type.
               Expected value is 'Mpi'.
        :param int process_count_per_instance: Number of processes per MPI node.
        """
        MpiResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            distribution_type=distribution_type,
            process_count_per_instance=process_count_per_instance,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             distribution_type: Optional[str] = None,
             process_count_per_instance: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if distribution_type is None and 'distributionType' in kwargs:
            distribution_type = kwargs['distributionType']
        if distribution_type is None:
            raise TypeError("Missing 'distribution_type' argument")
        if process_count_per_instance is None and 'processCountPerInstance' in kwargs:
            process_count_per_instance = kwargs['processCountPerInstance']

        _setter("distribution_type", 'Mpi')
        if process_count_per_instance is not None:
            _setter("process_count_per_instance", process_count_per_instance)

    @property
    @pulumi.getter(name="distributionType")
    def distribution_type(self) -> str:
        """
        Enum to determine the job distribution type.
        Expected value is 'Mpi'.
        """
        return pulumi.get(self, "distribution_type")

    @property
    @pulumi.getter(name="processCountPerInstance")
    def process_count_per_instance(self) -> Optional[int]:
        """
        Number of processes per MPI node.
        """
        return pulumi.get(self, "process_count_per_instance")


@pulumi.output_type
class NlpVerticalDataSettingsResponse(dict):
    """
    Class for data inputs.
    NLP - Natural Language Processing.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetColumnName":
            suggest = "target_column_name"
        elif key == "trainingData":
            suggest = "training_data"
        elif key == "testData":
            suggest = "test_data"
        elif key == "validationData":
            suggest = "validation_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NlpVerticalDataSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NlpVerticalDataSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NlpVerticalDataSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_column_name: str,
                 training_data: 'outputs.TrainingDataSettingsResponse',
                 test_data: Optional['outputs.TestDataSettingsResponse'] = None,
                 validation_data: Optional['outputs.NlpVerticalValidationDataSettingsResponse'] = None):
        """
        Class for data inputs.
        NLP - Natural Language Processing.
        :param str target_column_name: [Required] Target column name: This is prediction values column.
               Also known as label column name in context of classification tasks.
        :param 'TrainingDataSettingsResponse' training_data: [Required] Training data input.
        :param 'TestDataSettingsResponse' test_data: Test data input.
        :param 'NlpVerticalValidationDataSettingsResponse' validation_data: Validation data inputs.
        """
        NlpVerticalDataSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_column_name=target_column_name,
            training_data=training_data,
            test_data=test_data,
            validation_data=validation_data,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_column_name: Optional[str] = None,
             training_data: Optional['outputs.TrainingDataSettingsResponse'] = None,
             test_data: Optional['outputs.TestDataSettingsResponse'] = None,
             validation_data: Optional['outputs.NlpVerticalValidationDataSettingsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if target_column_name is None and 'targetColumnName' in kwargs:
            target_column_name = kwargs['targetColumnName']
        if target_column_name is None:
            raise TypeError("Missing 'target_column_name' argument")
        if training_data is None and 'trainingData' in kwargs:
            training_data = kwargs['trainingData']
        if training_data is None:
            raise TypeError("Missing 'training_data' argument")
        if test_data is None and 'testData' in kwargs:
            test_data = kwargs['testData']
        if validation_data is None and 'validationData' in kwargs:
            validation_data = kwargs['validationData']

        _setter("target_column_name", target_column_name)
        _setter("training_data", training_data)
        if test_data is not None:
            _setter("test_data", test_data)
        if validation_data is not None:
            _setter("validation_data", validation_data)

    @property
    @pulumi.getter(name="targetColumnName")
    def target_column_name(self) -> str:
        """
        [Required] Target column name: This is prediction values column.
        Also known as label column name in context of classification tasks.
        """
        return pulumi.get(self, "target_column_name")

    @property
    @pulumi.getter(name="trainingData")
    def training_data(self) -> 'outputs.TrainingDataSettingsResponse':
        """
        [Required] Training data input.
        """
        return pulumi.get(self, "training_data")

    @property
    @pulumi.getter(name="testData")
    def test_data(self) -> Optional['outputs.TestDataSettingsResponse']:
        """
        Test data input.
        """
        return pulumi.get(self, "test_data")

    @property
    @pulumi.getter(name="validationData")
    def validation_data(self) -> Optional['outputs.NlpVerticalValidationDataSettingsResponse']:
        """
        Validation data inputs.
        """
        return pulumi.get(self, "validation_data")


@pulumi.output_type
class NlpVerticalFeaturizationSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetLanguage":
            suggest = "dataset_language"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NlpVerticalFeaturizationSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NlpVerticalFeaturizationSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NlpVerticalFeaturizationSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_language: Optional[str] = None):
        """
        :param str dataset_language: Dataset language, useful for the text data.
        """
        NlpVerticalFeaturizationSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dataset_language=dataset_language,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dataset_language: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if dataset_language is None and 'datasetLanguage' in kwargs:
            dataset_language = kwargs['datasetLanguage']

        if dataset_language is not None:
            _setter("dataset_language", dataset_language)

    @property
    @pulumi.getter(name="datasetLanguage")
    def dataset_language(self) -> Optional[str]:
        """
        Dataset language, useful for the text data.
        """
        return pulumi.get(self, "dataset_language")


@pulumi.output_type
class NlpVerticalLimitSettingsResponse(dict):
    """
    Job execution constraints.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentTrials":
            suggest = "max_concurrent_trials"
        elif key == "maxTrials":
            suggest = "max_trials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NlpVerticalLimitSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NlpVerticalLimitSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NlpVerticalLimitSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_trials: Optional[int] = None,
                 max_trials: Optional[int] = None,
                 timeout: Optional[str] = None):
        """
        Job execution constraints.
        :param int max_concurrent_trials: Maximum Concurrent AutoML iterations.
        :param int max_trials: Number of AutoML iterations.
        :param str timeout: AutoML job timeout.
        """
        NlpVerticalLimitSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_concurrent_trials=max_concurrent_trials,
            max_trials=max_trials,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_concurrent_trials: Optional[int] = None,
             max_trials: Optional[int] = None,
             timeout: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_concurrent_trials is None and 'maxConcurrentTrials' in kwargs:
            max_concurrent_trials = kwargs['maxConcurrentTrials']
        if max_trials is None and 'maxTrials' in kwargs:
            max_trials = kwargs['maxTrials']

        if max_concurrent_trials is None:
            max_concurrent_trials = 1
        if max_concurrent_trials is not None:
            _setter("max_concurrent_trials", max_concurrent_trials)
        if max_trials is None:
            max_trials = 1
        if max_trials is not None:
            _setter("max_trials", max_trials)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter(name="maxConcurrentTrials")
    def max_concurrent_trials(self) -> Optional[int]:
        """
        Maximum Concurrent AutoML iterations.
        """
        return pulumi.get(self, "max_concurrent_trials")

    @property
    @pulumi.getter(name="maxTrials")
    def max_trials(self) -> Optional[int]:
        """
        Number of AutoML iterations.
        """
        return pulumi.get(self, "max_trials")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        AutoML job timeout.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class NlpVerticalValidationDataSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validationDataSize":
            suggest = "validation_data_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NlpVerticalValidationDataSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NlpVerticalValidationDataSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NlpVerticalValidationDataSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data: Optional['outputs.MLTableJobInputResponse'] = None,
                 validation_data_size: Optional[float] = None):
        """
        :param 'MLTableJobInputResponse' data: Validation data MLTable.
        :param float validation_data_size: The fraction of training dataset that needs to be set aside for validation purpose.
               Values between (0.0 , 1.0)
               Applied when validation dataset is not provided.
        """
        NlpVerticalValidationDataSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data=data,
            validation_data_size=validation_data_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data: Optional['outputs.MLTableJobInputResponse'] = None,
             validation_data_size: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if validation_data_size is None and 'validationDataSize' in kwargs:
            validation_data_size = kwargs['validationDataSize']

        if data is not None:
            _setter("data", data)
        if validation_data_size is not None:
            _setter("validation_data_size", validation_data_size)

    @property
    @pulumi.getter
    def data(self) -> Optional['outputs.MLTableJobInputResponse']:
        """
        Validation data MLTable.
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter(name="validationDataSize")
    def validation_data_size(self) -> Optional[float]:
        """
        The fraction of training dataset that needs to be set aside for validation purpose.
        Values between (0.0 , 1.0)
        Applied when validation dataset is not provided.
        """
        return pulumi.get(self, "validation_data_size")


@pulumi.output_type
class NoneDatastoreCredentialsResponse(dict):
    """
    Empty/none datastore credentials.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsType":
            suggest = "credentials_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NoneDatastoreCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NoneDatastoreCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NoneDatastoreCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_type: str):
        """
        Empty/none datastore credentials.
        :param str credentials_type: Enum to determine the datastore credentials type.
               Expected value is 'None'.
        """
        NoneDatastoreCredentialsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials_type=credentials_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if credentials_type is None and 'credentialsType' in kwargs:
            credentials_type = kwargs['credentialsType']
        if credentials_type is None:
            raise TypeError("Missing 'credentials_type' argument")

        _setter("credentials_type", 'None')

    @property
    @pulumi.getter(name="credentialsType")
    def credentials_type(self) -> str:
        """
        Enum to determine the datastore credentials type.
        Expected value is 'None'.
        """
        return pulumi.get(self, "credentials_type")


@pulumi.output_type
class ObjectiveResponse(dict):
    """
    Optimization objective.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryMetric":
            suggest = "primary_metric"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectiveResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectiveResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectiveResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 goal: str,
                 primary_metric: str):
        """
        Optimization objective.
        :param str goal: [Required] Defines supported metric goals for hyperparameter tuning
        :param str primary_metric: [Required] Name of the metric to optimize.
        """
        ObjectiveResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            goal=goal,
            primary_metric=primary_metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             goal: Optional[str] = None,
             primary_metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if goal is None:
            raise TypeError("Missing 'goal' argument")
        if primary_metric is None and 'primaryMetric' in kwargs:
            primary_metric = kwargs['primaryMetric']
        if primary_metric is None:
            raise TypeError("Missing 'primary_metric' argument")

        _setter("goal", goal)
        _setter("primary_metric", primary_metric)

    @property
    @pulumi.getter
    def goal(self) -> str:
        """
        [Required] Defines supported metric goals for hyperparameter tuning
        """
        return pulumi.get(self, "goal")

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> str:
        """
        [Required] Name of the metric to optimize.
        """
        return pulumi.get(self, "primary_metric")


@pulumi.output_type
class OnlineEndpointResponse(dict):
    """
    Online endpoint configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authMode":
            suggest = "auth_mode"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "scoringUri":
            suggest = "scoring_uri"
        elif key == "swaggerUri":
            suggest = "swagger_uri"
        elif key == "mirrorTraffic":
            suggest = "mirror_traffic"
        elif key == "publicNetworkAccess":
            suggest = "public_network_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_mode: str,
                 provisioning_state: str,
                 scoring_uri: str,
                 swagger_uri: str,
                 compute: Optional[str] = None,
                 description: Optional[str] = None,
                 mirror_traffic: Optional[Mapping[str, int]] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 public_network_access: Optional[str] = None,
                 traffic: Optional[Mapping[str, int]] = None):
        """
        Online endpoint configuration
        :param str auth_mode: [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
        :param str provisioning_state: Provisioning state for the endpoint.
        :param str scoring_uri: Endpoint URI.
        :param str swagger_uri: Endpoint Swagger URI.
        :param str compute: ARM resource ID of the compute if it exists.
               optional
        :param str description: Description of the inference endpoint.
        :param Mapping[str, int] mirror_traffic: Percentage of traffic to be mirrored to each deployment without using returned scoring. Traffic values need to sum to utmost 50.
        :param Mapping[str, str] properties: Property dictionary. Properties can be added, but not removed or altered.
        :param str public_network_access: Set to "Enabled" for endpoints that should allow public access when Private Link is enabled.
        :param Mapping[str, int] traffic: Percentage of traffic from endpoint to divert to each deployment. Traffic values need to sum to 100.
        """
        OnlineEndpointResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_mode=auth_mode,
            provisioning_state=provisioning_state,
            scoring_uri=scoring_uri,
            swagger_uri=swagger_uri,
            compute=compute,
            description=description,
            mirror_traffic=mirror_traffic,
            properties=properties,
            public_network_access=public_network_access,
            traffic=traffic,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_mode: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             scoring_uri: Optional[str] = None,
             swagger_uri: Optional[str] = None,
             compute: Optional[str] = None,
             description: Optional[str] = None,
             mirror_traffic: Optional[Mapping[str, int]] = None,
             properties: Optional[Mapping[str, str]] = None,
             public_network_access: Optional[str] = None,
             traffic: Optional[Mapping[str, int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auth_mode is None and 'authMode' in kwargs:
            auth_mode = kwargs['authMode']
        if auth_mode is None:
            raise TypeError("Missing 'auth_mode' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if scoring_uri is None and 'scoringUri' in kwargs:
            scoring_uri = kwargs['scoringUri']
        if scoring_uri is None:
            raise TypeError("Missing 'scoring_uri' argument")
        if swagger_uri is None and 'swaggerUri' in kwargs:
            swagger_uri = kwargs['swaggerUri']
        if swagger_uri is None:
            raise TypeError("Missing 'swagger_uri' argument")
        if mirror_traffic is None and 'mirrorTraffic' in kwargs:
            mirror_traffic = kwargs['mirrorTraffic']
        if public_network_access is None and 'publicNetworkAccess' in kwargs:
            public_network_access = kwargs['publicNetworkAccess']

        _setter("auth_mode", auth_mode)
        _setter("provisioning_state", provisioning_state)
        _setter("scoring_uri", scoring_uri)
        _setter("swagger_uri", swagger_uri)
        if compute is not None:
            _setter("compute", compute)
        if description is not None:
            _setter("description", description)
        if mirror_traffic is not None:
            _setter("mirror_traffic", mirror_traffic)
        if properties is not None:
            _setter("properties", properties)
        if public_network_access is None:
            public_network_access = 'Enabled'
        if public_network_access is not None:
            _setter("public_network_access", public_network_access)
        if traffic is not None:
            _setter("traffic", traffic)

    @property
    @pulumi.getter(name="authMode")
    def auth_mode(self) -> str:
        """
        [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does.
        """
        return pulumi.get(self, "auth_mode")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning state for the endpoint.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="scoringUri")
    def scoring_uri(self) -> str:
        """
        Endpoint URI.
        """
        return pulumi.get(self, "scoring_uri")

    @property
    @pulumi.getter(name="swaggerUri")
    def swagger_uri(self) -> str:
        """
        Endpoint Swagger URI.
        """
        return pulumi.get(self, "swagger_uri")

    @property
    @pulumi.getter
    def compute(self) -> Optional[str]:
        """
        ARM resource ID of the compute if it exists.
        optional
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the inference endpoint.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="mirrorTraffic")
    def mirror_traffic(self) -> Optional[Mapping[str, int]]:
        """
        Percentage of traffic to be mirrored to each deployment without using returned scoring. Traffic values need to sum to utmost 50.
        """
        return pulumi.get(self, "mirror_traffic")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[str]:
        """
        Set to "Enabled" for endpoints that should allow public access when Private Link is enabled.
        """
        return pulumi.get(self, "public_network_access")

    @property
    @pulumi.getter
    def traffic(self) -> Optional[Mapping[str, int]]:
        """
        Percentage of traffic from endpoint to divert to each deployment. Traffic values need to sum to 100.
        """
        return pulumi.get(self, "traffic")


@pulumi.output_type
class OnlineRequestSettingsResponse(dict):
    """
    Online deployment scoring requests configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentRequestsPerInstance":
            suggest = "max_concurrent_requests_per_instance"
        elif key == "maxQueueWait":
            suggest = "max_queue_wait"
        elif key == "requestTimeout":
            suggest = "request_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineRequestSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineRequestSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineRequestSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_requests_per_instance: Optional[int] = None,
                 max_queue_wait: Optional[str] = None,
                 request_timeout: Optional[str] = None):
        """
        Online deployment scoring requests configuration.
        :param int max_concurrent_requests_per_instance: The number of maximum concurrent requests per node allowed per deployment. Defaults to 1.
        :param str max_queue_wait: The maximum amount of time a request will stay in the queue in ISO 8601 format.
               Defaults to 500ms.
        :param str request_timeout: The scoring timeout in ISO 8601 format.
               Defaults to 5000ms.
        """
        OnlineRequestSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_concurrent_requests_per_instance=max_concurrent_requests_per_instance,
            max_queue_wait=max_queue_wait,
            request_timeout=request_timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_concurrent_requests_per_instance: Optional[int] = None,
             max_queue_wait: Optional[str] = None,
             request_timeout: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_concurrent_requests_per_instance is None and 'maxConcurrentRequestsPerInstance' in kwargs:
            max_concurrent_requests_per_instance = kwargs['maxConcurrentRequestsPerInstance']
        if max_queue_wait is None and 'maxQueueWait' in kwargs:
            max_queue_wait = kwargs['maxQueueWait']
        if request_timeout is None and 'requestTimeout' in kwargs:
            request_timeout = kwargs['requestTimeout']

        if max_concurrent_requests_per_instance is None:
            max_concurrent_requests_per_instance = 1
        if max_concurrent_requests_per_instance is not None:
            _setter("max_concurrent_requests_per_instance", max_concurrent_requests_per_instance)
        if max_queue_wait is None:
            max_queue_wait = 'PT0.5S'
        if max_queue_wait is not None:
            _setter("max_queue_wait", max_queue_wait)
        if request_timeout is None:
            request_timeout = 'PT5S'
        if request_timeout is not None:
            _setter("request_timeout", request_timeout)

    @property
    @pulumi.getter(name="maxConcurrentRequestsPerInstance")
    def max_concurrent_requests_per_instance(self) -> Optional[int]:
        """
        The number of maximum concurrent requests per node allowed per deployment. Defaults to 1.
        """
        return pulumi.get(self, "max_concurrent_requests_per_instance")

    @property
    @pulumi.getter(name="maxQueueWait")
    def max_queue_wait(self) -> Optional[str]:
        """
        The maximum amount of time a request will stay in the queue in ISO 8601 format.
        Defaults to 500ms.
        """
        return pulumi.get(self, "max_queue_wait")

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[str]:
        """
        The scoring timeout in ISO 8601 format.
        Defaults to 5000ms.
        """
        return pulumi.get(self, "request_timeout")


@pulumi.output_type
class OutputPathAssetReferenceResponse(dict):
    """
    Reference to an asset via its path in a job output.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referenceType":
            suggest = "reference_type"
        elif key == "jobId":
            suggest = "job_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OutputPathAssetReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OutputPathAssetReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OutputPathAssetReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reference_type: str,
                 job_id: Optional[str] = None,
                 path: Optional[str] = None):
        """
        Reference to an asset via its path in a job output.
        :param str reference_type: Enum to determine which reference method to use for an asset.
               Expected value is 'OutputPath'.
        :param str job_id: ARM resource ID of the job.
        :param str path: The path of the file/directory in the job output.
        """
        OutputPathAssetReferenceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            reference_type=reference_type,
            job_id=job_id,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             reference_type: Optional[str] = None,
             job_id: Optional[str] = None,
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if reference_type is None and 'referenceType' in kwargs:
            reference_type = kwargs['referenceType']
        if reference_type is None:
            raise TypeError("Missing 'reference_type' argument")
        if job_id is None and 'jobId' in kwargs:
            job_id = kwargs['jobId']

        _setter("reference_type", 'OutputPath')
        if job_id is not None:
            _setter("job_id", job_id)
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter(name="referenceType")
    def reference_type(self) -> str:
        """
        Enum to determine which reference method to use for an asset.
        Expected value is 'OutputPath'.
        """
        return pulumi.get(self, "reference_type")

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> Optional[str]:
        """
        ARM resource ID of the job.
        """
        return pulumi.get(self, "job_id")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path of the file/directory in the job output.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class PipelineJobResponse(dict):
    """
    Pipeline Job definition: defines generic to MFE attributes.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobType":
            suggest = "job_type"
        elif key == "computeId":
            suggest = "compute_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "experimentName":
            suggest = "experiment_name"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineJobResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineJobResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineJobResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_type: str,
                 status: str,
                 compute_id: Optional[str] = None,
                 description: Optional[str] = None,
                 display_name: Optional[str] = None,
                 experiment_name: Optional[str] = None,
                 identity: Optional[Any] = None,
                 inputs: Optional[Mapping[str, Any]] = None,
                 is_archived: Optional[bool] = None,
                 jobs: Optional[Mapping[str, Any]] = None,
                 outputs: Optional[Mapping[str, Any]] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 schedule: Optional[Any] = None,
                 services: Optional[Mapping[str, 'outputs.JobServiceResponse']] = None,
                 settings: Optional[Any] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Pipeline Job definition: defines generic to MFE attributes.
        :param str job_type: Enum to determine the type of job.
               Expected value is 'Pipeline'.
        :param str status: Status of the job.
        :param str compute_id: ARM resource ID of the compute resource.
        :param str description: The asset description text.
        :param str display_name: Display name of job.
        :param str experiment_name: The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        :param Union['AmlTokenResponse', 'ManagedIdentityResponse', 'UserIdentityResponse'] identity: Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
               Defaults to AmlToken if null.
        :param Mapping[str, Union['CustomModelJobInputResponse', 'LiteralJobInputResponse', 'MLFlowModelJobInputResponse', 'MLTableJobInputResponse', 'TritonModelJobInputResponse', 'UriFileJobInputResponse', 'UriFolderJobInputResponse']] inputs: Inputs for the pipeline job.
        :param bool is_archived: Is the asset archived?
        :param Mapping[str, Any] jobs: Jobs construct the Pipeline Job.
        :param Mapping[str, Union['CustomModelJobOutputResponse', 'MLFlowModelJobOutputResponse', 'MLTableJobOutputResponse', 'TritonModelJobOutputResponse', 'UriFileJobOutputResponse', 'UriFolderJobOutputResponse']] outputs: Outputs for the pipeline job
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Union['CronScheduleResponse', 'RecurrenceScheduleResponse'] schedule: Schedule definition of job.
               If no schedule is provided, the job is run once and immediately after submission.
        :param Mapping[str, 'JobServiceResponse'] services: List of JobEndpoints.
               For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        :param Any settings: Pipeline settings, for things like ContinueRunOnStepFailure etc.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        PipelineJobResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_type=job_type,
            status=status,
            compute_id=compute_id,
            description=description,
            display_name=display_name,
            experiment_name=experiment_name,
            identity=identity,
            inputs=inputs,
            is_archived=is_archived,
            jobs=jobs,
            outputs=outputs,
            properties=properties,
            schedule=schedule,
            services=services,
            settings=settings,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_type: Optional[str] = None,
             status: Optional[str] = None,
             compute_id: Optional[str] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             experiment_name: Optional[str] = None,
             identity: Optional[Any] = None,
             inputs: Optional[Mapping[str, Any]] = None,
             is_archived: Optional[bool] = None,
             jobs: Optional[Mapping[str, Any]] = None,
             outputs: Optional[Mapping[str, Any]] = None,
             properties: Optional[Mapping[str, str]] = None,
             schedule: Optional[Any] = None,
             services: Optional[Mapping[str, 'outputs.JobServiceResponse']] = None,
             settings: Optional[Any] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if job_type is None and 'jobType' in kwargs:
            job_type = kwargs['jobType']
        if job_type is None:
            raise TypeError("Missing 'job_type' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if compute_id is None and 'computeId' in kwargs:
            compute_id = kwargs['computeId']
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if experiment_name is None and 'experimentName' in kwargs:
            experiment_name = kwargs['experimentName']
        if is_archived is None and 'isArchived' in kwargs:
            is_archived = kwargs['isArchived']

        _setter("job_type", 'Pipeline')
        _setter("status", status)
        if compute_id is not None:
            _setter("compute_id", compute_id)
        if description is not None:
            _setter("description", description)
        if display_name is not None:
            _setter("display_name", display_name)
        if experiment_name is None:
            experiment_name = 'Default'
        if experiment_name is not None:
            _setter("experiment_name", experiment_name)
        if identity is not None:
            _setter("identity", identity)
        if inputs is not None:
            _setter("inputs", inputs)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            _setter("is_archived", is_archived)
        if jobs is not None:
            _setter("jobs", jobs)
        if outputs is not None:
            _setter("outputs", outputs)
        if properties is not None:
            _setter("properties", properties)
        if schedule is not None:
            _setter("schedule", schedule)
        if services is not None:
            _setter("services", services)
        if settings is not None:
            _setter("settings", settings)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="jobType")
    def job_type(self) -> str:
        """
        Enum to determine the type of job.
        Expected value is 'Pipeline'.
        """
        return pulumi.get(self, "job_type")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the job.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="computeId")
    def compute_id(self) -> Optional[str]:
        """
        ARM resource ID of the compute resource.
        """
        return pulumi.get(self, "compute_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Display name of job.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="experimentName")
    def experiment_name(self) -> Optional[str]:
        """
        The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        """
        return pulumi.get(self, "experiment_name")

    @property
    @pulumi.getter
    def identity(self) -> Optional[Any]:
        """
        Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
        Defaults to AmlToken if null.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter
    def inputs(self) -> Optional[Mapping[str, Any]]:
        """
        Inputs for the pipeline job.
        """
        return pulumi.get(self, "inputs")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def jobs(self) -> Optional[Mapping[str, Any]]:
        """
        Jobs construct the Pipeline Job.
        """
        return pulumi.get(self, "jobs")

    @property
    @pulumi.getter
    def outputs(self) -> Optional[Mapping[str, Any]]:
        """
        Outputs for the pipeline job
        """
        return pulumi.get(self, "outputs")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def schedule(self) -> Optional[Any]:
        """
        Schedule definition of job.
        If no schedule is provided, the job is run once and immediately after submission.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter
    def services(self) -> Optional[Mapping[str, 'outputs.JobServiceResponse']]:
        """
        List of JobEndpoints.
        For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Any]:
        """
        Pipeline settings, for things like ContinueRunOnStepFailure etc.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ProbeSettingsResponse(dict):
    """
    Deployment container liveness/readiness probe configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "initialDelay":
            suggest = "initial_delay"
        elif key == "successThreshold":
            suggest = "success_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProbeSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProbeSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProbeSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay: Optional[str] = None,
                 period: Optional[str] = None,
                 success_threshold: Optional[int] = None,
                 timeout: Optional[str] = None):
        """
        Deployment container liveness/readiness probe configuration.
        :param int failure_threshold: The number of failures to allow before returning an unhealthy status.
        :param str initial_delay: The delay before the first probe in ISO 8601 format.
        :param str period: The length of time between probes in ISO 8601 format.
        :param int success_threshold: The number of successful probes before returning a healthy status.
        :param str timeout: The probe timeout in ISO 8601 format.
        """
        ProbeSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failure_threshold=failure_threshold,
            initial_delay=initial_delay,
            period=period,
            success_threshold=success_threshold,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failure_threshold: Optional[int] = None,
             initial_delay: Optional[str] = None,
             period: Optional[str] = None,
             success_threshold: Optional[int] = None,
             timeout: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if failure_threshold is None and 'failureThreshold' in kwargs:
            failure_threshold = kwargs['failureThreshold']
        if initial_delay is None and 'initialDelay' in kwargs:
            initial_delay = kwargs['initialDelay']
        if success_threshold is None and 'successThreshold' in kwargs:
            success_threshold = kwargs['successThreshold']

        if failure_threshold is None:
            failure_threshold = 30
        if failure_threshold is not None:
            _setter("failure_threshold", failure_threshold)
        if initial_delay is not None:
            _setter("initial_delay", initial_delay)
        if period is None:
            period = 'PT10S'
        if period is not None:
            _setter("period", period)
        if success_threshold is None:
            success_threshold = 1
        if success_threshold is not None:
            _setter("success_threshold", success_threshold)
        if timeout is None:
            timeout = 'PT2S'
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        The number of failures to allow before returning an unhealthy status.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelay")
    def initial_delay(self) -> Optional[str]:
        """
        The delay before the first probe in ISO 8601 format.
        """
        return pulumi.get(self, "initial_delay")

    @property
    @pulumi.getter
    def period(self) -> Optional[str]:
        """
        The length of time between probes in ISO 8601 format.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        The number of successful probes before returning a healthy status.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        The probe timeout in ISO 8601 format.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class PyTorchResponse(dict):
    """
    PyTorch distribution configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "distributionType":
            suggest = "distribution_type"
        elif key == "processCountPerInstance":
            suggest = "process_count_per_instance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PyTorchResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PyTorchResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PyTorchResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 distribution_type: str,
                 process_count_per_instance: Optional[int] = None):
        """
        PyTorch distribution configuration.
        :param str distribution_type: Enum to determine the job distribution type.
               Expected value is 'PyTorch'.
        :param int process_count_per_instance: Number of processes per node.
        """
        PyTorchResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            distribution_type=distribution_type,
            process_count_per_instance=process_count_per_instance,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             distribution_type: Optional[str] = None,
             process_count_per_instance: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if distribution_type is None and 'distributionType' in kwargs:
            distribution_type = kwargs['distributionType']
        if distribution_type is None:
            raise TypeError("Missing 'distribution_type' argument")
        if process_count_per_instance is None and 'processCountPerInstance' in kwargs:
            process_count_per_instance = kwargs['processCountPerInstance']

        _setter("distribution_type", 'PyTorch')
        if process_count_per_instance is not None:
            _setter("process_count_per_instance", process_count_per_instance)

    @property
    @pulumi.getter(name="distributionType")
    def distribution_type(self) -> str:
        """
        Enum to determine the job distribution type.
        Expected value is 'PyTorch'.
        """
        return pulumi.get(self, "distribution_type")

    @property
    @pulumi.getter(name="processCountPerInstance")
    def process_count_per_instance(self) -> Optional[int]:
        """
        Number of processes per node.
        """
        return pulumi.get(self, "process_count_per_instance")


@pulumi.output_type
class RandomSamplingAlgorithmResponse(dict):
    """
    Defines a Sampling Algorithm that generates values randomly
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "samplingAlgorithmType":
            suggest = "sampling_algorithm_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RandomSamplingAlgorithmResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RandomSamplingAlgorithmResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RandomSamplingAlgorithmResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sampling_algorithm_type: str,
                 rule: Optional[str] = None,
                 seed: Optional[int] = None):
        """
        Defines a Sampling Algorithm that generates values randomly
        :param str sampling_algorithm_type: 
               Expected value is 'Random'.
        :param str rule: The specific type of random algorithm
        :param int seed: An optional integer to use as the seed for random number generation
        """
        RandomSamplingAlgorithmResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sampling_algorithm_type=sampling_algorithm_type,
            rule=rule,
            seed=seed,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sampling_algorithm_type: Optional[str] = None,
             rule: Optional[str] = None,
             seed: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if sampling_algorithm_type is None and 'samplingAlgorithmType' in kwargs:
            sampling_algorithm_type = kwargs['samplingAlgorithmType']
        if sampling_algorithm_type is None:
            raise TypeError("Missing 'sampling_algorithm_type' argument")

        _setter("sampling_algorithm_type", 'Random')
        if rule is None:
            rule = 'Random'
        if rule is not None:
            _setter("rule", rule)
        if seed is not None:
            _setter("seed", seed)

    @property
    @pulumi.getter(name="samplingAlgorithmType")
    def sampling_algorithm_type(self) -> str:
        """

        Expected value is 'Random'.
        """
        return pulumi.get(self, "sampling_algorithm_type")

    @property
    @pulumi.getter
    def rule(self) -> Optional[str]:
        """
        The specific type of random algorithm
        """
        return pulumi.get(self, "rule")

    @property
    @pulumi.getter
    def seed(self) -> Optional[int]:
        """
        An optional integer to use as the seed for random number generation
        """
        return pulumi.get(self, "seed")


@pulumi.output_type
class RecurrencePatternResponse(dict):
    """
    Recurrence schedule pattern definition
    """
    def __init__(__self__, *,
                 hours: Sequence[int],
                 minutes: Sequence[int],
                 weekdays: Optional[Sequence[str]] = None):
        """
        Recurrence schedule pattern definition
        :param Sequence[int] hours: [Required] List of hours for recurrence schedule pattern
        :param Sequence[int] minutes: [Required] List of minutes for recurrence schedule pattern
        :param Sequence[str] weekdays: List of weekdays for recurrence schedule pattern
        """
        RecurrencePatternResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hours=hours,
            minutes=minutes,
            weekdays=weekdays,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hours: Optional[Sequence[int]] = None,
             minutes: Optional[Sequence[int]] = None,
             weekdays: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if hours is None:
            raise TypeError("Missing 'hours' argument")
        if minutes is None:
            raise TypeError("Missing 'minutes' argument")

        _setter("hours", hours)
        _setter("minutes", minutes)
        if weekdays is not None:
            _setter("weekdays", weekdays)

    @property
    @pulumi.getter
    def hours(self) -> Sequence[int]:
        """
        [Required] List of hours for recurrence schedule pattern
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Sequence[int]:
        """
        [Required] List of minutes for recurrence schedule pattern
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def weekdays(self) -> Optional[Sequence[str]]:
        """
        List of weekdays for recurrence schedule pattern
        """
        return pulumi.get(self, "weekdays")


@pulumi.output_type
class RecurrenceScheduleResponse(dict):
    """
    Recurrence schedule definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scheduleType":
            suggest = "schedule_type"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "scheduleStatus":
            suggest = "schedule_status"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecurrenceScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecurrenceScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecurrenceScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency: str,
                 interval: int,
                 schedule_type: str,
                 end_time: Optional[str] = None,
                 pattern: Optional['outputs.RecurrencePatternResponse'] = None,
                 schedule_status: Optional[str] = None,
                 start_time: Optional[str] = None,
                 time_zone: Optional[str] = None):
        """
        Recurrence schedule definition
        :param str frequency: [Required] Specifies frequency with with which to trigger schedule
        :param int interval: [Required] Specifies schedule interval in conjunction with frequency
        :param str schedule_type: Enum to describe type of schedule
               Expected value is 'Recurrence'.
        :param str end_time: Specifies end time of schedule in ISO 8601 format.
               If not present, the schedule will run indefinitely
        :param 'RecurrencePatternResponse' pattern: Specifies the recurrence schedule pattern
        :param str schedule_status: Specifies the schedule's status
        :param str start_time: Specifies start time of schedule in ISO 8601 format.
        :param str time_zone: Specifies time zone in which the schedule runs.
               TimeZone should follow Windows time zone format.
        """
        RecurrenceScheduleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency=frequency,
            interval=interval,
            schedule_type=schedule_type,
            end_time=end_time,
            pattern=pattern,
            schedule_status=schedule_status,
            start_time=start_time,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency: Optional[str] = None,
             interval: Optional[int] = None,
             schedule_type: Optional[str] = None,
             end_time: Optional[str] = None,
             pattern: Optional['outputs.RecurrencePatternResponse'] = None,
             schedule_status: Optional[str] = None,
             start_time: Optional[str] = None,
             time_zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if frequency is None:
            raise TypeError("Missing 'frequency' argument")
        if interval is None:
            raise TypeError("Missing 'interval' argument")
        if schedule_type is None and 'scheduleType' in kwargs:
            schedule_type = kwargs['scheduleType']
        if schedule_type is None:
            raise TypeError("Missing 'schedule_type' argument")
        if end_time is None and 'endTime' in kwargs:
            end_time = kwargs['endTime']
        if schedule_status is None and 'scheduleStatus' in kwargs:
            schedule_status = kwargs['scheduleStatus']
        if start_time is None and 'startTime' in kwargs:
            start_time = kwargs['startTime']
        if time_zone is None and 'timeZone' in kwargs:
            time_zone = kwargs['timeZone']

        _setter("frequency", frequency)
        _setter("interval", interval)
        _setter("schedule_type", 'Recurrence')
        if end_time is not None:
            _setter("end_time", end_time)
        if pattern is not None:
            _setter("pattern", pattern)
        if schedule_status is None:
            schedule_status = 'Enabled'
        if schedule_status is not None:
            _setter("schedule_status", schedule_status)
        if start_time is not None:
            _setter("start_time", start_time)
        if time_zone is None:
            time_zone = 'UTC'
        if time_zone is not None:
            _setter("time_zone", time_zone)

    @property
    @pulumi.getter
    def frequency(self) -> str:
        """
        [Required] Specifies frequency with with which to trigger schedule
        """
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter
    def interval(self) -> int:
        """
        [Required] Specifies schedule interval in conjunction with frequency
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="scheduleType")
    def schedule_type(self) -> str:
        """
        Enum to describe type of schedule
        Expected value is 'Recurrence'.
        """
        return pulumi.get(self, "schedule_type")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        Specifies end time of schedule in ISO 8601 format.
        If not present, the schedule will run indefinitely
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter
    def pattern(self) -> Optional['outputs.RecurrencePatternResponse']:
        """
        Specifies the recurrence schedule pattern
        """
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter(name="scheduleStatus")
    def schedule_status(self) -> Optional[str]:
        """
        Specifies the schedule's status
        """
        return pulumi.get(self, "schedule_status")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        Specifies start time of schedule in ISO 8601 format.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        Specifies time zone in which the schedule runs.
        TimeZone should follow Windows time zone format.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class RegressionResponse(dict):
    """
    Regression task in AutoML Table vertical.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "allowedModels":
            suggest = "allowed_models"
        elif key == "blockedModels":
            suggest = "blocked_models"
        elif key == "dataSettings":
            suggest = "data_settings"
        elif key == "featurizationSettings":
            suggest = "featurization_settings"
        elif key == "limitSettings":
            suggest = "limit_settings"
        elif key == "logVerbosity":
            suggest = "log_verbosity"
        elif key == "primaryMetric":
            suggest = "primary_metric"
        elif key == "trainingSettings":
            suggest = "training_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegressionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegressionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegressionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 task_type: str,
                 allowed_models: Optional[Sequence[str]] = None,
                 blocked_models: Optional[Sequence[str]] = None,
                 data_settings: Optional['outputs.TableVerticalDataSettingsResponse'] = None,
                 featurization_settings: Optional['outputs.TableVerticalFeaturizationSettingsResponse'] = None,
                 limit_settings: Optional['outputs.TableVerticalLimitSettingsResponse'] = None,
                 log_verbosity: Optional[str] = None,
                 primary_metric: Optional[str] = None,
                 training_settings: Optional['outputs.TrainingSettingsResponse'] = None):
        """
        Regression task in AutoML Table vertical.
        :param str task_type: AutoMLJob Task type.
               Expected value is 'Regression'.
        :param Sequence[str] allowed_models: Allowed models for regression task.
        :param Sequence[str] blocked_models: Blocked models for regression task.
        :param 'TableVerticalDataSettingsResponse' data_settings: Data inputs for AutoMLJob.
        :param 'TableVerticalFeaturizationSettingsResponse' featurization_settings: Featurization inputs needed for AutoML job.
        :param 'TableVerticalLimitSettingsResponse' limit_settings: Execution constraints for AutoMLJob.
        :param str log_verbosity: Log verbosity for the job.
        :param str primary_metric: Primary metric for regression task.
        :param 'TrainingSettingsResponse' training_settings: Inputs for training phase for an AutoML Job.
        """
        RegressionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            task_type=task_type,
            allowed_models=allowed_models,
            blocked_models=blocked_models,
            data_settings=data_settings,
            featurization_settings=featurization_settings,
            limit_settings=limit_settings,
            log_verbosity=log_verbosity,
            primary_metric=primary_metric,
            training_settings=training_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             task_type: Optional[str] = None,
             allowed_models: Optional[Sequence[str]] = None,
             blocked_models: Optional[Sequence[str]] = None,
             data_settings: Optional['outputs.TableVerticalDataSettingsResponse'] = None,
             featurization_settings: Optional['outputs.TableVerticalFeaturizationSettingsResponse'] = None,
             limit_settings: Optional['outputs.TableVerticalLimitSettingsResponse'] = None,
             log_verbosity: Optional[str] = None,
             primary_metric: Optional[str] = None,
             training_settings: Optional['outputs.TrainingSettingsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if allowed_models is None and 'allowedModels' in kwargs:
            allowed_models = kwargs['allowedModels']
        if blocked_models is None and 'blockedModels' in kwargs:
            blocked_models = kwargs['blockedModels']
        if data_settings is None and 'dataSettings' in kwargs:
            data_settings = kwargs['dataSettings']
        if featurization_settings is None and 'featurizationSettings' in kwargs:
            featurization_settings = kwargs['featurizationSettings']
        if limit_settings is None and 'limitSettings' in kwargs:
            limit_settings = kwargs['limitSettings']
        if log_verbosity is None and 'logVerbosity' in kwargs:
            log_verbosity = kwargs['logVerbosity']
        if primary_metric is None and 'primaryMetric' in kwargs:
            primary_metric = kwargs['primaryMetric']
        if training_settings is None and 'trainingSettings' in kwargs:
            training_settings = kwargs['trainingSettings']

        _setter("task_type", 'Regression')
        if allowed_models is not None:
            _setter("allowed_models", allowed_models)
        if blocked_models is not None:
            _setter("blocked_models", blocked_models)
        if data_settings is not None:
            _setter("data_settings", data_settings)
        if featurization_settings is not None:
            _setter("featurization_settings", featurization_settings)
        if limit_settings is not None:
            _setter("limit_settings", limit_settings)
        if log_verbosity is None:
            log_verbosity = 'Info'
        if log_verbosity is not None:
            _setter("log_verbosity", log_verbosity)
        if primary_metric is None:
            primary_metric = 'NormalizedRootMeanSquaredError'
        if primary_metric is not None:
            _setter("primary_metric", primary_metric)
        if training_settings is not None:
            _setter("training_settings", training_settings)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        AutoMLJob Task type.
        Expected value is 'Regression'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="allowedModels")
    def allowed_models(self) -> Optional[Sequence[str]]:
        """
        Allowed models for regression task.
        """
        return pulumi.get(self, "allowed_models")

    @property
    @pulumi.getter(name="blockedModels")
    def blocked_models(self) -> Optional[Sequence[str]]:
        """
        Blocked models for regression task.
        """
        return pulumi.get(self, "blocked_models")

    @property
    @pulumi.getter(name="dataSettings")
    def data_settings(self) -> Optional['outputs.TableVerticalDataSettingsResponse']:
        """
        Data inputs for AutoMLJob.
        """
        return pulumi.get(self, "data_settings")

    @property
    @pulumi.getter(name="featurizationSettings")
    def featurization_settings(self) -> Optional['outputs.TableVerticalFeaturizationSettingsResponse']:
        """
        Featurization inputs needed for AutoML job.
        """
        return pulumi.get(self, "featurization_settings")

    @property
    @pulumi.getter(name="limitSettings")
    def limit_settings(self) -> Optional['outputs.TableVerticalLimitSettingsResponse']:
        """
        Execution constraints for AutoMLJob.
        """
        return pulumi.get(self, "limit_settings")

    @property
    @pulumi.getter(name="logVerbosity")
    def log_verbosity(self) -> Optional[str]:
        """
        Log verbosity for the job.
        """
        return pulumi.get(self, "log_verbosity")

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> Optional[str]:
        """
        Primary metric for regression task.
        """
        return pulumi.get(self, "primary_metric")

    @property
    @pulumi.getter(name="trainingSettings")
    def training_settings(self) -> Optional['outputs.TrainingSettingsResponse']:
        """
        Inputs for training phase for an AutoML Job.
        """
        return pulumi.get(self, "training_settings")


@pulumi.output_type
class ResourceConfigurationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceCount":
            suggest = "instance_count"
        elif key == "instanceType":
            suggest = "instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_count: Optional[int] = None,
                 instance_type: Optional[str] = None,
                 properties: Optional[Mapping[str, Any]] = None):
        """
        :param int instance_count: Optional number of instances or nodes used by the compute target.
        :param str instance_type: Optional type of VM used as supported by the compute target.
        :param Mapping[str, Any] properties: Additional properties bag.
        """
        ResourceConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_count=instance_count,
            instance_type=instance_type,
            properties=properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_count: Optional[int] = None,
             instance_type: Optional[str] = None,
             properties: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if instance_count is None and 'instanceCount' in kwargs:
            instance_count = kwargs['instanceCount']
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']

        if instance_count is None:
            instance_count = 1
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if instance_type is not None:
            _setter("instance_type", instance_type)
        if properties is not None:
            _setter("properties", properties)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[int]:
        """
        Optional number of instances or nodes used by the compute target.
        """
        return pulumi.get(self, "instance_count")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        Optional type of VM used as supported by the compute target.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, Any]]:
        """
        Additional properties bag.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class RouteResponse(dict):
    def __init__(__self__, *,
                 path: str,
                 port: int):
        """
        :param str path: [Required] The path for the route.
        :param int port: [Required] The port for the route.
        """
        RouteResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[str] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if path is None:
            raise TypeError("Missing 'path' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")

        _setter("path", path)
        _setter("port", port)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        [Required] The path for the route.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        [Required] The port for the route.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class SasDatastoreCredentialsResponse(dict):
    """
    SAS datastore credentials configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsType":
            suggest = "credentials_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SasDatastoreCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SasDatastoreCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SasDatastoreCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_type: str):
        """
        SAS datastore credentials configuration.
        :param str credentials_type: Enum to determine the datastore credentials type.
               Expected value is 'Sas'.
        """
        SasDatastoreCredentialsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials_type=credentials_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if credentials_type is None and 'credentialsType' in kwargs:
            credentials_type = kwargs['credentialsType']
        if credentials_type is None:
            raise TypeError("Missing 'credentials_type' argument")

        _setter("credentials_type", 'Sas')

    @property
    @pulumi.getter(name="credentialsType")
    def credentials_type(self) -> str:
        """
        Enum to determine the datastore credentials type.
        Expected value is 'Sas'.
        """
        return pulumi.get(self, "credentials_type")


@pulumi.output_type
class ServicePrincipalDatastoreCredentialsResponse(dict):
    """
    Service Principal datastore credentials configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "credentialsType":
            suggest = "credentials_type"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "authorityUrl":
            suggest = "authority_url"
        elif key == "resourceUrl":
            suggest = "resource_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicePrincipalDatastoreCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicePrincipalDatastoreCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicePrincipalDatastoreCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 credentials_type: str,
                 tenant_id: str,
                 authority_url: Optional[str] = None,
                 resource_url: Optional[str] = None):
        """
        Service Principal datastore credentials configuration.
        :param str client_id: [Required] Service principal client ID.
        :param str credentials_type: Enum to determine the datastore credentials type.
               Expected value is 'ServicePrincipal'.
        :param str tenant_id: [Required] ID of the tenant to which the service principal belongs.
        :param str authority_url: Authority URL used for authentication.
        :param str resource_url: Resource the service principal has access to.
        """
        ServicePrincipalDatastoreCredentialsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            credentials_type=credentials_type,
            tenant_id=tenant_id,
            authority_url=authority_url,
            resource_url=resource_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[str] = None,
             credentials_type: Optional[str] = None,
             tenant_id: Optional[str] = None,
             authority_url: Optional[str] = None,
             resource_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_id is None:
            raise TypeError("Missing 'client_id' argument")
        if credentials_type is None and 'credentialsType' in kwargs:
            credentials_type = kwargs['credentialsType']
        if credentials_type is None:
            raise TypeError("Missing 'credentials_type' argument")
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_id is None:
            raise TypeError("Missing 'tenant_id' argument")
        if authority_url is None and 'authorityUrl' in kwargs:
            authority_url = kwargs['authorityUrl']
        if resource_url is None and 'resourceUrl' in kwargs:
            resource_url = kwargs['resourceUrl']

        _setter("client_id", client_id)
        _setter("credentials_type", 'ServicePrincipal')
        _setter("tenant_id", tenant_id)
        if authority_url is not None:
            _setter("authority_url", authority_url)
        if resource_url is not None:
            _setter("resource_url", resource_url)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        [Required] Service principal client ID.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="credentialsType")
    def credentials_type(self) -> str:
        """
        Enum to determine the datastore credentials type.
        Expected value is 'ServicePrincipal'.
        """
        return pulumi.get(self, "credentials_type")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        [Required] ID of the tenant to which the service principal belongs.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="authorityUrl")
    def authority_url(self) -> Optional[str]:
        """
        Authority URL used for authentication.
        """
        return pulumi.get(self, "authority_url")

    @property
    @pulumi.getter(name="resourceUrl")
    def resource_url(self) -> Optional[str]:
        """
        Resource the service principal has access to.
        """
        return pulumi.get(self, "resource_url")


@pulumi.output_type
class SkuResponse(dict):
    """
    The resource model definition representing SKU
    """
    def __init__(__self__, *,
                 name: str,
                 capacity: Optional[int] = None,
                 family: Optional[str] = None,
                 size: Optional[str] = None,
                 tier: Optional[str] = None):
        """
        The resource model definition representing SKU
        :param str name: The name of the SKU. Ex - P3. It is typically a letter+number code
        :param int capacity: If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        :param str family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
        :param str size: The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        :param str tier: This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        SkuResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            capacity=capacity,
            family=family,
            size=size,
            tier=tier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             capacity: Optional[int] = None,
             family: Optional[str] = None,
             size: Optional[str] = None,
             tier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)
        if capacity is not None:
            _setter("capacity", capacity)
        if family is not None:
            _setter("family", family)
        if size is not None:
            _setter("size", size)
        if tier is not None:
            _setter("tier", tier)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the SKU. Ex - P3. It is typically a letter+number code
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def capacity(self) -> Optional[int]:
        """
        If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def family(self) -> Optional[str]:
        """
        If the service has different generations of hardware, for the same SKU, then that can be captured here.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        """
        The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        """
        This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class StackEnsembleSettingsResponse(dict):
    """
    Advances setting to customize StackEnsemble run.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stackMetaLearnerKWargs":
            suggest = "stack_meta_learner_k_wargs"
        elif key == "stackMetaLearnerTrainPercentage":
            suggest = "stack_meta_learner_train_percentage"
        elif key == "stackMetaLearnerType":
            suggest = "stack_meta_learner_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StackEnsembleSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StackEnsembleSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StackEnsembleSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 stack_meta_learner_k_wargs: Optional[Any] = None,
                 stack_meta_learner_train_percentage: Optional[float] = None,
                 stack_meta_learner_type: Optional[str] = None):
        """
        Advances setting to customize StackEnsemble run.
        :param Any stack_meta_learner_k_wargs: Optional parameters to pass to the initializer of the meta-learner.
        :param float stack_meta_learner_train_percentage: Specifies the proportion of the training set (when choosing train and validation type of training) to be reserved for training the meta-learner. Default value is 0.2.
        :param str stack_meta_learner_type: The meta-learner is a model trained on the output of the individual heterogeneous models.
        """
        StackEnsembleSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            stack_meta_learner_k_wargs=stack_meta_learner_k_wargs,
            stack_meta_learner_train_percentage=stack_meta_learner_train_percentage,
            stack_meta_learner_type=stack_meta_learner_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             stack_meta_learner_k_wargs: Optional[Any] = None,
             stack_meta_learner_train_percentage: Optional[float] = None,
             stack_meta_learner_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if stack_meta_learner_k_wargs is None and 'stackMetaLearnerKWargs' in kwargs:
            stack_meta_learner_k_wargs = kwargs['stackMetaLearnerKWargs']
        if stack_meta_learner_train_percentage is None and 'stackMetaLearnerTrainPercentage' in kwargs:
            stack_meta_learner_train_percentage = kwargs['stackMetaLearnerTrainPercentage']
        if stack_meta_learner_type is None and 'stackMetaLearnerType' in kwargs:
            stack_meta_learner_type = kwargs['stackMetaLearnerType']

        if stack_meta_learner_k_wargs is not None:
            _setter("stack_meta_learner_k_wargs", stack_meta_learner_k_wargs)
        if stack_meta_learner_train_percentage is None:
            stack_meta_learner_train_percentage = 0.2
        if stack_meta_learner_train_percentage is not None:
            _setter("stack_meta_learner_train_percentage", stack_meta_learner_train_percentage)
        if stack_meta_learner_type is None:
            stack_meta_learner_type = 'None'
        if stack_meta_learner_type is not None:
            _setter("stack_meta_learner_type", stack_meta_learner_type)

    @property
    @pulumi.getter(name="stackMetaLearnerKWargs")
    def stack_meta_learner_k_wargs(self) -> Optional[Any]:
        """
        Optional parameters to pass to the initializer of the meta-learner.
        """
        return pulumi.get(self, "stack_meta_learner_k_wargs")

    @property
    @pulumi.getter(name="stackMetaLearnerTrainPercentage")
    def stack_meta_learner_train_percentage(self) -> Optional[float]:
        """
        Specifies the proportion of the training set (when choosing train and validation type of training) to be reserved for training the meta-learner. Default value is 0.2.
        """
        return pulumi.get(self, "stack_meta_learner_train_percentage")

    @property
    @pulumi.getter(name="stackMetaLearnerType")
    def stack_meta_learner_type(self) -> Optional[str]:
        """
        The meta-learner is a model trained on the output of the individual heterogeneous models.
        """
        return pulumi.get(self, "stack_meta_learner_type")


@pulumi.output_type
class SweepJobLimitsResponse(dict):
    """
    Sweep Job limit class.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobLimitsType":
            suggest = "job_limits_type"
        elif key == "maxConcurrentTrials":
            suggest = "max_concurrent_trials"
        elif key == "maxTotalTrials":
            suggest = "max_total_trials"
        elif key == "trialTimeout":
            suggest = "trial_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SweepJobLimitsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SweepJobLimitsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SweepJobLimitsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_limits_type: str,
                 max_concurrent_trials: Optional[int] = None,
                 max_total_trials: Optional[int] = None,
                 timeout: Optional[str] = None,
                 trial_timeout: Optional[str] = None):
        """
        Sweep Job limit class.
        :param str job_limits_type: 
               Expected value is 'Sweep'.
        :param int max_concurrent_trials: Sweep Job max concurrent trials.
        :param int max_total_trials: Sweep Job max total trials.
        :param str timeout: The max run duration in ISO 8601 format, after which the job will be cancelled. Only supports duration with precision as low as Seconds.
        :param str trial_timeout: Sweep Job Trial timeout value.
        """
        SweepJobLimitsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_limits_type=job_limits_type,
            max_concurrent_trials=max_concurrent_trials,
            max_total_trials=max_total_trials,
            timeout=timeout,
            trial_timeout=trial_timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_limits_type: Optional[str] = None,
             max_concurrent_trials: Optional[int] = None,
             max_total_trials: Optional[int] = None,
             timeout: Optional[str] = None,
             trial_timeout: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if job_limits_type is None and 'jobLimitsType' in kwargs:
            job_limits_type = kwargs['jobLimitsType']
        if job_limits_type is None:
            raise TypeError("Missing 'job_limits_type' argument")
        if max_concurrent_trials is None and 'maxConcurrentTrials' in kwargs:
            max_concurrent_trials = kwargs['maxConcurrentTrials']
        if max_total_trials is None and 'maxTotalTrials' in kwargs:
            max_total_trials = kwargs['maxTotalTrials']
        if trial_timeout is None and 'trialTimeout' in kwargs:
            trial_timeout = kwargs['trialTimeout']

        _setter("job_limits_type", 'Sweep')
        if max_concurrent_trials is not None:
            _setter("max_concurrent_trials", max_concurrent_trials)
        if max_total_trials is not None:
            _setter("max_total_trials", max_total_trials)
        if timeout is not None:
            _setter("timeout", timeout)
        if trial_timeout is not None:
            _setter("trial_timeout", trial_timeout)

    @property
    @pulumi.getter(name="jobLimitsType")
    def job_limits_type(self) -> str:
        """

        Expected value is 'Sweep'.
        """
        return pulumi.get(self, "job_limits_type")

    @property
    @pulumi.getter(name="maxConcurrentTrials")
    def max_concurrent_trials(self) -> Optional[int]:
        """
        Sweep Job max concurrent trials.
        """
        return pulumi.get(self, "max_concurrent_trials")

    @property
    @pulumi.getter(name="maxTotalTrials")
    def max_total_trials(self) -> Optional[int]:
        """
        Sweep Job max total trials.
        """
        return pulumi.get(self, "max_total_trials")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        The max run duration in ISO 8601 format, after which the job will be cancelled. Only supports duration with precision as low as Seconds.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="trialTimeout")
    def trial_timeout(self) -> Optional[str]:
        """
        Sweep Job Trial timeout value.
        """
        return pulumi.get(self, "trial_timeout")


@pulumi.output_type
class SweepJobResponse(dict):
    """
    Sweep job definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobType":
            suggest = "job_type"
        elif key == "samplingAlgorithm":
            suggest = "sampling_algorithm"
        elif key == "searchSpace":
            suggest = "search_space"
        elif key == "computeId":
            suggest = "compute_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "earlyTermination":
            suggest = "early_termination"
        elif key == "experimentName":
            suggest = "experiment_name"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SweepJobResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SweepJobResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SweepJobResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_type: str,
                 objective: 'outputs.ObjectiveResponse',
                 sampling_algorithm: Any,
                 search_space: Any,
                 status: str,
                 trial: 'outputs.TrialComponentResponse',
                 compute_id: Optional[str] = None,
                 description: Optional[str] = None,
                 display_name: Optional[str] = None,
                 early_termination: Optional[Any] = None,
                 experiment_name: Optional[str] = None,
                 identity: Optional[Any] = None,
                 inputs: Optional[Mapping[str, Any]] = None,
                 is_archived: Optional[bool] = None,
                 limits: Optional['outputs.SweepJobLimitsResponse'] = None,
                 outputs: Optional[Mapping[str, Any]] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 schedule: Optional[Any] = None,
                 services: Optional[Mapping[str, 'outputs.JobServiceResponse']] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Sweep job definition.
        :param str job_type: Enum to determine the type of job.
               Expected value is 'Sweep'.
        :param 'ObjectiveResponse' objective: [Required] Optimization objective.
        :param Union['BayesianSamplingAlgorithmResponse', 'GridSamplingAlgorithmResponse', 'RandomSamplingAlgorithmResponse'] sampling_algorithm: [Required] The hyperparameter sampling algorithm
        :param Any search_space: [Required] A dictionary containing each parameter and its distribution. The dictionary key is the name of the parameter
        :param str status: Status of the job.
        :param 'TrialComponentResponse' trial: [Required] Trial component definition.
        :param str compute_id: ARM resource ID of the compute resource.
        :param str description: The asset description text.
        :param str display_name: Display name of job.
        :param Union['BanditPolicyResponse', 'MedianStoppingPolicyResponse', 'TruncationSelectionPolicyResponse'] early_termination: Early termination policies enable canceling poor-performing runs before they complete
        :param str experiment_name: The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        :param Union['AmlTokenResponse', 'ManagedIdentityResponse', 'UserIdentityResponse'] identity: Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
               Defaults to AmlToken if null.
        :param Mapping[str, Union['CustomModelJobInputResponse', 'LiteralJobInputResponse', 'MLFlowModelJobInputResponse', 'MLTableJobInputResponse', 'TritonModelJobInputResponse', 'UriFileJobInputResponse', 'UriFolderJobInputResponse']] inputs: Mapping of input data bindings used in the job.
        :param bool is_archived: Is the asset archived?
        :param 'SweepJobLimitsResponse' limits: Sweep Job limit.
        :param Mapping[str, Union['CustomModelJobOutputResponse', 'MLFlowModelJobOutputResponse', 'MLTableJobOutputResponse', 'TritonModelJobOutputResponse', 'UriFileJobOutputResponse', 'UriFolderJobOutputResponse']] outputs: Mapping of output data bindings used in the job.
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Union['CronScheduleResponse', 'RecurrenceScheduleResponse'] schedule: Schedule definition of job.
               If no schedule is provided, the job is run once and immediately after submission.
        :param Mapping[str, 'JobServiceResponse'] services: List of JobEndpoints.
               For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        SweepJobResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_type=job_type,
            objective=objective,
            sampling_algorithm=sampling_algorithm,
            search_space=search_space,
            status=status,
            trial=trial,
            compute_id=compute_id,
            description=description,
            display_name=display_name,
            early_termination=early_termination,
            experiment_name=experiment_name,
            identity=identity,
            inputs=inputs,
            is_archived=is_archived,
            limits=limits,
            outputs=outputs,
            properties=properties,
            schedule=schedule,
            services=services,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_type: Optional[str] = None,
             objective: Optional['outputs.ObjectiveResponse'] = None,
             sampling_algorithm: Optional[Any] = None,
             search_space: Optional[Any] = None,
             status: Optional[str] = None,
             trial: Optional['outputs.TrialComponentResponse'] = None,
             compute_id: Optional[str] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             early_termination: Optional[Any] = None,
             experiment_name: Optional[str] = None,
             identity: Optional[Any] = None,
             inputs: Optional[Mapping[str, Any]] = None,
             is_archived: Optional[bool] = None,
             limits: Optional['outputs.SweepJobLimitsResponse'] = None,
             outputs: Optional[Mapping[str, Any]] = None,
             properties: Optional[Mapping[str, str]] = None,
             schedule: Optional[Any] = None,
             services: Optional[Mapping[str, 'outputs.JobServiceResponse']] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if job_type is None and 'jobType' in kwargs:
            job_type = kwargs['jobType']
        if job_type is None:
            raise TypeError("Missing 'job_type' argument")
        if objective is None:
            raise TypeError("Missing 'objective' argument")
        if sampling_algorithm is None and 'samplingAlgorithm' in kwargs:
            sampling_algorithm = kwargs['samplingAlgorithm']
        if sampling_algorithm is None:
            raise TypeError("Missing 'sampling_algorithm' argument")
        if search_space is None and 'searchSpace' in kwargs:
            search_space = kwargs['searchSpace']
        if search_space is None:
            raise TypeError("Missing 'search_space' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if trial is None:
            raise TypeError("Missing 'trial' argument")
        if compute_id is None and 'computeId' in kwargs:
            compute_id = kwargs['computeId']
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if early_termination is None and 'earlyTermination' in kwargs:
            early_termination = kwargs['earlyTermination']
        if experiment_name is None and 'experimentName' in kwargs:
            experiment_name = kwargs['experimentName']
        if is_archived is None and 'isArchived' in kwargs:
            is_archived = kwargs['isArchived']

        _setter("job_type", 'Sweep')
        _setter("objective", objective)
        _setter("sampling_algorithm", sampling_algorithm)
        _setter("search_space", search_space)
        _setter("status", status)
        _setter("trial", trial)
        if compute_id is not None:
            _setter("compute_id", compute_id)
        if description is not None:
            _setter("description", description)
        if display_name is not None:
            _setter("display_name", display_name)
        if early_termination is not None:
            _setter("early_termination", early_termination)
        if experiment_name is None:
            experiment_name = 'Default'
        if experiment_name is not None:
            _setter("experiment_name", experiment_name)
        if identity is not None:
            _setter("identity", identity)
        if inputs is not None:
            _setter("inputs", inputs)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            _setter("is_archived", is_archived)
        if limits is not None:
            _setter("limits", limits)
        if outputs is not None:
            _setter("outputs", outputs)
        if properties is not None:
            _setter("properties", properties)
        if schedule is not None:
            _setter("schedule", schedule)
        if services is not None:
            _setter("services", services)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="jobType")
    def job_type(self) -> str:
        """
        Enum to determine the type of job.
        Expected value is 'Sweep'.
        """
        return pulumi.get(self, "job_type")

    @property
    @pulumi.getter
    def objective(self) -> 'outputs.ObjectiveResponse':
        """
        [Required] Optimization objective.
        """
        return pulumi.get(self, "objective")

    @property
    @pulumi.getter(name="samplingAlgorithm")
    def sampling_algorithm(self) -> Any:
        """
        [Required] The hyperparameter sampling algorithm
        """
        return pulumi.get(self, "sampling_algorithm")

    @property
    @pulumi.getter(name="searchSpace")
    def search_space(self) -> Any:
        """
        [Required] A dictionary containing each parameter and its distribution. The dictionary key is the name of the parameter
        """
        return pulumi.get(self, "search_space")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the job.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def trial(self) -> 'outputs.TrialComponentResponse':
        """
        [Required] Trial component definition.
        """
        return pulumi.get(self, "trial")

    @property
    @pulumi.getter(name="computeId")
    def compute_id(self) -> Optional[str]:
        """
        ARM resource ID of the compute resource.
        """
        return pulumi.get(self, "compute_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Display name of job.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="earlyTermination")
    def early_termination(self) -> Optional[Any]:
        """
        Early termination policies enable canceling poor-performing runs before they complete
        """
        return pulumi.get(self, "early_termination")

    @property
    @pulumi.getter(name="experimentName")
    def experiment_name(self) -> Optional[str]:
        """
        The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        """
        return pulumi.get(self, "experiment_name")

    @property
    @pulumi.getter
    def identity(self) -> Optional[Any]:
        """
        Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
        Defaults to AmlToken if null.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter
    def inputs(self) -> Optional[Mapping[str, Any]]:
        """
        Mapping of input data bindings used in the job.
        """
        return pulumi.get(self, "inputs")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def limits(self) -> Optional['outputs.SweepJobLimitsResponse']:
        """
        Sweep Job limit.
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def outputs(self) -> Optional[Mapping[str, Any]]:
        """
        Mapping of output data bindings used in the job.
        """
        return pulumi.get(self, "outputs")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def schedule(self) -> Optional[Any]:
        """
        Schedule definition of job.
        If no schedule is provided, the job is run once and immediately after submission.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter
    def services(self) -> Optional[Mapping[str, 'outputs.JobServiceResponse']]:
        """
        List of JobEndpoints.
        For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        SystemDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            created_by=created_by,
            created_by_type=created_by_type,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            last_modified_by_type=last_modified_by_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: Optional[str] = None,
             created_by: Optional[str] = None,
             created_by_type: Optional[str] = None,
             last_modified_at: Optional[str] = None,
             last_modified_by: Optional[str] = None,
             last_modified_by_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if created_at is None and 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if created_by_type is None and 'createdByType' in kwargs:
            created_by_type = kwargs['createdByType']
        if last_modified_at is None and 'lastModifiedAt' in kwargs:
            last_modified_at = kwargs['lastModifiedAt']
        if last_modified_by is None and 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if last_modified_by_type is None and 'lastModifiedByType' in kwargs:
            last_modified_by_type = kwargs['lastModifiedByType']

        if created_at is not None:
            _setter("created_at", created_at)
        if created_by is not None:
            _setter("created_by", created_by)
        if created_by_type is not None:
            _setter("created_by_type", created_by_type)
        if last_modified_at is not None:
            _setter("last_modified_at", last_modified_at)
        if last_modified_by is not None:
            _setter("last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            _setter("last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TableVerticalDataSettingsResponse(dict):
    """
    Class for data inputs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetColumnName":
            suggest = "target_column_name"
        elif key == "trainingData":
            suggest = "training_data"
        elif key == "testData":
            suggest = "test_data"
        elif key == "validationData":
            suggest = "validation_data"
        elif key == "weightColumnName":
            suggest = "weight_column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableVerticalDataSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableVerticalDataSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableVerticalDataSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_column_name: str,
                 training_data: 'outputs.TrainingDataSettingsResponse',
                 test_data: Optional['outputs.TestDataSettingsResponse'] = None,
                 validation_data: Optional['outputs.TableVerticalValidationDataSettingsResponse'] = None,
                 weight_column_name: Optional[str] = None):
        """
        Class for data inputs.
        :param str target_column_name: [Required] Target column name: This is prediction values column.
               Also known as label column name in context of classification tasks.
        :param 'TrainingDataSettingsResponse' training_data: [Required] Training data input.
        :param 'TestDataSettingsResponse' test_data: Test data input.
        :param 'TableVerticalValidationDataSettingsResponse' validation_data: Validation data inputs.
        :param str weight_column_name: The name of the sample weight column. Automated ML supports a weighted column as an input, causing rows in the data to be weighted up or down.
        """
        TableVerticalDataSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_column_name=target_column_name,
            training_data=training_data,
            test_data=test_data,
            validation_data=validation_data,
            weight_column_name=weight_column_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_column_name: Optional[str] = None,
             training_data: Optional['outputs.TrainingDataSettingsResponse'] = None,
             test_data: Optional['outputs.TestDataSettingsResponse'] = None,
             validation_data: Optional['outputs.TableVerticalValidationDataSettingsResponse'] = None,
             weight_column_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if target_column_name is None and 'targetColumnName' in kwargs:
            target_column_name = kwargs['targetColumnName']
        if target_column_name is None:
            raise TypeError("Missing 'target_column_name' argument")
        if training_data is None and 'trainingData' in kwargs:
            training_data = kwargs['trainingData']
        if training_data is None:
            raise TypeError("Missing 'training_data' argument")
        if test_data is None and 'testData' in kwargs:
            test_data = kwargs['testData']
        if validation_data is None and 'validationData' in kwargs:
            validation_data = kwargs['validationData']
        if weight_column_name is None and 'weightColumnName' in kwargs:
            weight_column_name = kwargs['weightColumnName']

        _setter("target_column_name", target_column_name)
        _setter("training_data", training_data)
        if test_data is not None:
            _setter("test_data", test_data)
        if validation_data is not None:
            _setter("validation_data", validation_data)
        if weight_column_name is not None:
            _setter("weight_column_name", weight_column_name)

    @property
    @pulumi.getter(name="targetColumnName")
    def target_column_name(self) -> str:
        """
        [Required] Target column name: This is prediction values column.
        Also known as label column name in context of classification tasks.
        """
        return pulumi.get(self, "target_column_name")

    @property
    @pulumi.getter(name="trainingData")
    def training_data(self) -> 'outputs.TrainingDataSettingsResponse':
        """
        [Required] Training data input.
        """
        return pulumi.get(self, "training_data")

    @property
    @pulumi.getter(name="testData")
    def test_data(self) -> Optional['outputs.TestDataSettingsResponse']:
        """
        Test data input.
        """
        return pulumi.get(self, "test_data")

    @property
    @pulumi.getter(name="validationData")
    def validation_data(self) -> Optional['outputs.TableVerticalValidationDataSettingsResponse']:
        """
        Validation data inputs.
        """
        return pulumi.get(self, "validation_data")

    @property
    @pulumi.getter(name="weightColumnName")
    def weight_column_name(self) -> Optional[str]:
        """
        The name of the sample weight column. Automated ML supports a weighted column as an input, causing rows in the data to be weighted up or down.
        """
        return pulumi.get(self, "weight_column_name")


@pulumi.output_type
class TableVerticalFeaturizationSettingsResponse(dict):
    """
    Featurization Configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockedTransformers":
            suggest = "blocked_transformers"
        elif key == "columnNameAndTypes":
            suggest = "column_name_and_types"
        elif key == "datasetLanguage":
            suggest = "dataset_language"
        elif key == "dropColumns":
            suggest = "drop_columns"
        elif key == "enableDnnFeaturization":
            suggest = "enable_dnn_featurization"
        elif key == "transformerParams":
            suggest = "transformer_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableVerticalFeaturizationSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableVerticalFeaturizationSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableVerticalFeaturizationSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blocked_transformers: Optional[Sequence[str]] = None,
                 column_name_and_types: Optional[Mapping[str, str]] = None,
                 dataset_language: Optional[str] = None,
                 drop_columns: Optional[Sequence[str]] = None,
                 enable_dnn_featurization: Optional[bool] = None,
                 mode: Optional[str] = None,
                 transformer_params: Optional[Mapping[str, Sequence['outputs.ColumnTransformerResponse']]] = None):
        """
        Featurization Configuration.
        :param Sequence[str] blocked_transformers: These transformers shall not be used in featurization.
        :param Mapping[str, str] column_name_and_types: Dictionary of column name and its type (int, float, string, datetime etc).
        :param str dataset_language: Dataset language, useful for the text data.
        :param Sequence[str] drop_columns: Columns to be dropped from data during featurization.
        :param bool enable_dnn_featurization: Determines whether to use Dnn based featurizers for data featurization.
        :param str mode: Featurization mode - User can keep the default 'Auto' mode and AutoML will take care of necessary transformation of the data in featurization phase.
               If 'Off' is selected then no featurization is done.
               If 'Custom' is selected then user can specify additional inputs to customize how featurization is done.
        :param Mapping[str, Sequence['ColumnTransformerResponse']] transformer_params: User can specify additional transformers to be used along with the columns to which it would be applied and parameters for the transformer constructor.
        """
        TableVerticalFeaturizationSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            blocked_transformers=blocked_transformers,
            column_name_and_types=column_name_and_types,
            dataset_language=dataset_language,
            drop_columns=drop_columns,
            enable_dnn_featurization=enable_dnn_featurization,
            mode=mode,
            transformer_params=transformer_params,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             blocked_transformers: Optional[Sequence[str]] = None,
             column_name_and_types: Optional[Mapping[str, str]] = None,
             dataset_language: Optional[str] = None,
             drop_columns: Optional[Sequence[str]] = None,
             enable_dnn_featurization: Optional[bool] = None,
             mode: Optional[str] = None,
             transformer_params: Optional[Mapping[str, Sequence['outputs.ColumnTransformerResponse']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if blocked_transformers is None and 'blockedTransformers' in kwargs:
            blocked_transformers = kwargs['blockedTransformers']
        if column_name_and_types is None and 'columnNameAndTypes' in kwargs:
            column_name_and_types = kwargs['columnNameAndTypes']
        if dataset_language is None and 'datasetLanguage' in kwargs:
            dataset_language = kwargs['datasetLanguage']
        if drop_columns is None and 'dropColumns' in kwargs:
            drop_columns = kwargs['dropColumns']
        if enable_dnn_featurization is None and 'enableDnnFeaturization' in kwargs:
            enable_dnn_featurization = kwargs['enableDnnFeaturization']
        if transformer_params is None and 'transformerParams' in kwargs:
            transformer_params = kwargs['transformerParams']

        if blocked_transformers is not None:
            _setter("blocked_transformers", blocked_transformers)
        if column_name_and_types is not None:
            _setter("column_name_and_types", column_name_and_types)
        if dataset_language is not None:
            _setter("dataset_language", dataset_language)
        if drop_columns is not None:
            _setter("drop_columns", drop_columns)
        if enable_dnn_featurization is None:
            enable_dnn_featurization = False
        if enable_dnn_featurization is not None:
            _setter("enable_dnn_featurization", enable_dnn_featurization)
        if mode is None:
            mode = 'Auto'
        if mode is not None:
            _setter("mode", mode)
        if transformer_params is not None:
            _setter("transformer_params", transformer_params)

    @property
    @pulumi.getter(name="blockedTransformers")
    def blocked_transformers(self) -> Optional[Sequence[str]]:
        """
        These transformers shall not be used in featurization.
        """
        return pulumi.get(self, "blocked_transformers")

    @property
    @pulumi.getter(name="columnNameAndTypes")
    def column_name_and_types(self) -> Optional[Mapping[str, str]]:
        """
        Dictionary of column name and its type (int, float, string, datetime etc).
        """
        return pulumi.get(self, "column_name_and_types")

    @property
    @pulumi.getter(name="datasetLanguage")
    def dataset_language(self) -> Optional[str]:
        """
        Dataset language, useful for the text data.
        """
        return pulumi.get(self, "dataset_language")

    @property
    @pulumi.getter(name="dropColumns")
    def drop_columns(self) -> Optional[Sequence[str]]:
        """
        Columns to be dropped from data during featurization.
        """
        return pulumi.get(self, "drop_columns")

    @property
    @pulumi.getter(name="enableDnnFeaturization")
    def enable_dnn_featurization(self) -> Optional[bool]:
        """
        Determines whether to use Dnn based featurizers for data featurization.
        """
        return pulumi.get(self, "enable_dnn_featurization")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Featurization mode - User can keep the default 'Auto' mode and AutoML will take care of necessary transformation of the data in featurization phase.
        If 'Off' is selected then no featurization is done.
        If 'Custom' is selected then user can specify additional inputs to customize how featurization is done.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="transformerParams")
    def transformer_params(self) -> Optional[Mapping[str, Sequence['outputs.ColumnTransformerResponse']]]:
        """
        User can specify additional transformers to be used along with the columns to which it would be applied and parameters for the transformer constructor.
        """
        return pulumi.get(self, "transformer_params")


@pulumi.output_type
class TableVerticalLimitSettingsResponse(dict):
    """
    Job execution constraints.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableEarlyTermination":
            suggest = "enable_early_termination"
        elif key == "exitScore":
            suggest = "exit_score"
        elif key == "maxConcurrentTrials":
            suggest = "max_concurrent_trials"
        elif key == "maxCoresPerTrial":
            suggest = "max_cores_per_trial"
        elif key == "maxTrials":
            suggest = "max_trials"
        elif key == "trialTimeout":
            suggest = "trial_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableVerticalLimitSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableVerticalLimitSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableVerticalLimitSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_early_termination: Optional[bool] = None,
                 exit_score: Optional[float] = None,
                 max_concurrent_trials: Optional[int] = None,
                 max_cores_per_trial: Optional[int] = None,
                 max_trials: Optional[int] = None,
                 timeout: Optional[str] = None,
                 trial_timeout: Optional[str] = None):
        """
        Job execution constraints.
        :param bool enable_early_termination: Enable early termination, determines whether or not if AutoMLJob will terminate early if there is no score improvement in last 20 iterations.
        :param float exit_score: Exit score for the AutoML job.
        :param int max_concurrent_trials: Maximum Concurrent iterations.
        :param int max_cores_per_trial: Max cores per iteration.
        :param int max_trials: Number of iterations.
        :param str timeout: AutoML job timeout.
        :param str trial_timeout: Iteration timeout.
        """
        TableVerticalLimitSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable_early_termination=enable_early_termination,
            exit_score=exit_score,
            max_concurrent_trials=max_concurrent_trials,
            max_cores_per_trial=max_cores_per_trial,
            max_trials=max_trials,
            timeout=timeout,
            trial_timeout=trial_timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable_early_termination: Optional[bool] = None,
             exit_score: Optional[float] = None,
             max_concurrent_trials: Optional[int] = None,
             max_cores_per_trial: Optional[int] = None,
             max_trials: Optional[int] = None,
             timeout: Optional[str] = None,
             trial_timeout: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enable_early_termination is None and 'enableEarlyTermination' in kwargs:
            enable_early_termination = kwargs['enableEarlyTermination']
        if exit_score is None and 'exitScore' in kwargs:
            exit_score = kwargs['exitScore']
        if max_concurrent_trials is None and 'maxConcurrentTrials' in kwargs:
            max_concurrent_trials = kwargs['maxConcurrentTrials']
        if max_cores_per_trial is None and 'maxCoresPerTrial' in kwargs:
            max_cores_per_trial = kwargs['maxCoresPerTrial']
        if max_trials is None and 'maxTrials' in kwargs:
            max_trials = kwargs['maxTrials']
        if trial_timeout is None and 'trialTimeout' in kwargs:
            trial_timeout = kwargs['trialTimeout']

        if enable_early_termination is None:
            enable_early_termination = True
        if enable_early_termination is not None:
            _setter("enable_early_termination", enable_early_termination)
        if exit_score is not None:
            _setter("exit_score", exit_score)
        if max_concurrent_trials is None:
            max_concurrent_trials = 1
        if max_concurrent_trials is not None:
            _setter("max_concurrent_trials", max_concurrent_trials)
        if max_cores_per_trial is None:
            max_cores_per_trial = -1
        if max_cores_per_trial is not None:
            _setter("max_cores_per_trial", max_cores_per_trial)
        if max_trials is None:
            max_trials = 1000
        if max_trials is not None:
            _setter("max_trials", max_trials)
        if timeout is None:
            timeout = 'PT6H'
        if timeout is not None:
            _setter("timeout", timeout)
        if trial_timeout is None:
            trial_timeout = 'PT30M'
        if trial_timeout is not None:
            _setter("trial_timeout", trial_timeout)

    @property
    @pulumi.getter(name="enableEarlyTermination")
    def enable_early_termination(self) -> Optional[bool]:
        """
        Enable early termination, determines whether or not if AutoMLJob will terminate early if there is no score improvement in last 20 iterations.
        """
        return pulumi.get(self, "enable_early_termination")

    @property
    @pulumi.getter(name="exitScore")
    def exit_score(self) -> Optional[float]:
        """
        Exit score for the AutoML job.
        """
        return pulumi.get(self, "exit_score")

    @property
    @pulumi.getter(name="maxConcurrentTrials")
    def max_concurrent_trials(self) -> Optional[int]:
        """
        Maximum Concurrent iterations.
        """
        return pulumi.get(self, "max_concurrent_trials")

    @property
    @pulumi.getter(name="maxCoresPerTrial")
    def max_cores_per_trial(self) -> Optional[int]:
        """
        Max cores per iteration.
        """
        return pulumi.get(self, "max_cores_per_trial")

    @property
    @pulumi.getter(name="maxTrials")
    def max_trials(self) -> Optional[int]:
        """
        Number of iterations.
        """
        return pulumi.get(self, "max_trials")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        AutoML job timeout.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="trialTimeout")
    def trial_timeout(self) -> Optional[str]:
        """
        Iteration timeout.
        """
        return pulumi.get(self, "trial_timeout")


@pulumi.output_type
class TableVerticalValidationDataSettingsResponse(dict):
    """
    Validation settings for AutoML Table vertical tasks - Classification/Regression/Forecasting.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cvSplitColumnNames":
            suggest = "cv_split_column_names"
        elif key == "nCrossValidations":
            suggest = "n_cross_validations"
        elif key == "validationDataSize":
            suggest = "validation_data_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableVerticalValidationDataSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableVerticalValidationDataSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableVerticalValidationDataSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cv_split_column_names: Optional[Sequence[str]] = None,
                 data: Optional['outputs.MLTableJobInputResponse'] = None,
                 n_cross_validations: Optional[Any] = None,
                 validation_data_size: Optional[float] = None):
        """
        Validation settings for AutoML Table vertical tasks - Classification/Regression/Forecasting.
        :param Sequence[str] cv_split_column_names: Columns to use for CVSplit data.
        :param 'MLTableJobInputResponse' data: Validation data MLTable.
        :param Union['AutoNCrossValidationsResponse', 'CustomNCrossValidationsResponse'] n_cross_validations: Number of cross validation folds to be applied on training dataset
               when validation dataset is not provided.
        :param float validation_data_size: The fraction of training dataset that needs to be set aside for validation purpose.
               Values between (0.0 , 1.0)
               Applied when validation dataset is not provided.
        """
        TableVerticalValidationDataSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cv_split_column_names=cv_split_column_names,
            data=data,
            n_cross_validations=n_cross_validations,
            validation_data_size=validation_data_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cv_split_column_names: Optional[Sequence[str]] = None,
             data: Optional['outputs.MLTableJobInputResponse'] = None,
             n_cross_validations: Optional[Any] = None,
             validation_data_size: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cv_split_column_names is None and 'cvSplitColumnNames' in kwargs:
            cv_split_column_names = kwargs['cvSplitColumnNames']
        if n_cross_validations is None and 'nCrossValidations' in kwargs:
            n_cross_validations = kwargs['nCrossValidations']
        if validation_data_size is None and 'validationDataSize' in kwargs:
            validation_data_size = kwargs['validationDataSize']

        if cv_split_column_names is not None:
            _setter("cv_split_column_names", cv_split_column_names)
        if data is not None:
            _setter("data", data)
        if n_cross_validations is not None:
            _setter("n_cross_validations", n_cross_validations)
        if validation_data_size is not None:
            _setter("validation_data_size", validation_data_size)

    @property
    @pulumi.getter(name="cvSplitColumnNames")
    def cv_split_column_names(self) -> Optional[Sequence[str]]:
        """
        Columns to use for CVSplit data.
        """
        return pulumi.get(self, "cv_split_column_names")

    @property
    @pulumi.getter
    def data(self) -> Optional['outputs.MLTableJobInputResponse']:
        """
        Validation data MLTable.
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter(name="nCrossValidations")
    def n_cross_validations(self) -> Optional[Any]:
        """
        Number of cross validation folds to be applied on training dataset
        when validation dataset is not provided.
        """
        return pulumi.get(self, "n_cross_validations")

    @property
    @pulumi.getter(name="validationDataSize")
    def validation_data_size(self) -> Optional[float]:
        """
        The fraction of training dataset that needs to be set aside for validation purpose.
        Values between (0.0 , 1.0)
        Applied when validation dataset is not provided.
        """
        return pulumi.get(self, "validation_data_size")


@pulumi.output_type
class TargetUtilizationScaleSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleType":
            suggest = "scale_type"
        elif key == "maxInstances":
            suggest = "max_instances"
        elif key == "minInstances":
            suggest = "min_instances"
        elif key == "pollingInterval":
            suggest = "polling_interval"
        elif key == "targetUtilizationPercentage":
            suggest = "target_utilization_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetUtilizationScaleSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetUtilizationScaleSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetUtilizationScaleSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scale_type: str,
                 max_instances: Optional[int] = None,
                 min_instances: Optional[int] = None,
                 polling_interval: Optional[str] = None,
                 target_utilization_percentage: Optional[int] = None):
        """
        :param str scale_type: 
               Expected value is 'TargetUtilization'.
        :param int max_instances: The maximum number of instances that the deployment can scale to. The quota will be reserved for max_instances.
        :param int min_instances: The minimum number of instances to always be present.
        :param str polling_interval: The polling interval in ISO 8691 format. Only supports duration with precision as low as Seconds.
        :param int target_utilization_percentage: Target CPU usage for the autoscaler.
        """
        TargetUtilizationScaleSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scale_type=scale_type,
            max_instances=max_instances,
            min_instances=min_instances,
            polling_interval=polling_interval,
            target_utilization_percentage=target_utilization_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scale_type: Optional[str] = None,
             max_instances: Optional[int] = None,
             min_instances: Optional[int] = None,
             polling_interval: Optional[str] = None,
             target_utilization_percentage: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if scale_type is None and 'scaleType' in kwargs:
            scale_type = kwargs['scaleType']
        if scale_type is None:
            raise TypeError("Missing 'scale_type' argument")
        if max_instances is None and 'maxInstances' in kwargs:
            max_instances = kwargs['maxInstances']
        if min_instances is None and 'minInstances' in kwargs:
            min_instances = kwargs['minInstances']
        if polling_interval is None and 'pollingInterval' in kwargs:
            polling_interval = kwargs['pollingInterval']
        if target_utilization_percentage is None and 'targetUtilizationPercentage' in kwargs:
            target_utilization_percentage = kwargs['targetUtilizationPercentage']

        _setter("scale_type", 'TargetUtilization')
        if max_instances is None:
            max_instances = 1
        if max_instances is not None:
            _setter("max_instances", max_instances)
        if min_instances is None:
            min_instances = 1
        if min_instances is not None:
            _setter("min_instances", min_instances)
        if polling_interval is None:
            polling_interval = 'PT1S'
        if polling_interval is not None:
            _setter("polling_interval", polling_interval)
        if target_utilization_percentage is None:
            target_utilization_percentage = 70
        if target_utilization_percentage is not None:
            _setter("target_utilization_percentage", target_utilization_percentage)

    @property
    @pulumi.getter(name="scaleType")
    def scale_type(self) -> str:
        """

        Expected value is 'TargetUtilization'.
        """
        return pulumi.get(self, "scale_type")

    @property
    @pulumi.getter(name="maxInstances")
    def max_instances(self) -> Optional[int]:
        """
        The maximum number of instances that the deployment can scale to. The quota will be reserved for max_instances.
        """
        return pulumi.get(self, "max_instances")

    @property
    @pulumi.getter(name="minInstances")
    def min_instances(self) -> Optional[int]:
        """
        The minimum number of instances to always be present.
        """
        return pulumi.get(self, "min_instances")

    @property
    @pulumi.getter(name="pollingInterval")
    def polling_interval(self) -> Optional[str]:
        """
        The polling interval in ISO 8691 format. Only supports duration with precision as low as Seconds.
        """
        return pulumi.get(self, "polling_interval")

    @property
    @pulumi.getter(name="targetUtilizationPercentage")
    def target_utilization_percentage(self) -> Optional[int]:
        """
        Target CPU usage for the autoscaler.
        """
        return pulumi.get(self, "target_utilization_percentage")


@pulumi.output_type
class TensorFlowResponse(dict):
    """
    TensorFlow distribution configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "distributionType":
            suggest = "distribution_type"
        elif key == "parameterServerCount":
            suggest = "parameter_server_count"
        elif key == "workerCount":
            suggest = "worker_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TensorFlowResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TensorFlowResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TensorFlowResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 distribution_type: str,
                 parameter_server_count: Optional[int] = None,
                 worker_count: Optional[int] = None):
        """
        TensorFlow distribution configuration.
        :param str distribution_type: Enum to determine the job distribution type.
               Expected value is 'TensorFlow'.
        :param int parameter_server_count: Number of parameter server tasks.
        :param int worker_count: Number of workers. If not specified, will default to the instance count.
        """
        TensorFlowResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            distribution_type=distribution_type,
            parameter_server_count=parameter_server_count,
            worker_count=worker_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             distribution_type: Optional[str] = None,
             parameter_server_count: Optional[int] = None,
             worker_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if distribution_type is None and 'distributionType' in kwargs:
            distribution_type = kwargs['distributionType']
        if distribution_type is None:
            raise TypeError("Missing 'distribution_type' argument")
        if parameter_server_count is None and 'parameterServerCount' in kwargs:
            parameter_server_count = kwargs['parameterServerCount']
        if worker_count is None and 'workerCount' in kwargs:
            worker_count = kwargs['workerCount']

        _setter("distribution_type", 'TensorFlow')
        if parameter_server_count is None:
            parameter_server_count = 0
        if parameter_server_count is not None:
            _setter("parameter_server_count", parameter_server_count)
        if worker_count is not None:
            _setter("worker_count", worker_count)

    @property
    @pulumi.getter(name="distributionType")
    def distribution_type(self) -> str:
        """
        Enum to determine the job distribution type.
        Expected value is 'TensorFlow'.
        """
        return pulumi.get(self, "distribution_type")

    @property
    @pulumi.getter(name="parameterServerCount")
    def parameter_server_count(self) -> Optional[int]:
        """
        Number of parameter server tasks.
        """
        return pulumi.get(self, "parameter_server_count")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[int]:
        """
        Number of workers. If not specified, will default to the instance count.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class TestDataSettingsResponse(dict):
    """
    Test data inputs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "testDataSize":
            suggest = "test_data_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TestDataSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TestDataSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TestDataSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data: Optional['outputs.MLTableJobInputResponse'] = None,
                 test_data_size: Optional[float] = None):
        """
        Test data inputs.
        :param 'MLTableJobInputResponse' data: Test data MLTable.
        :param float test_data_size: The fraction of test dataset that needs to be set aside for validation purpose.
               Values between (0.0 , 1.0)
               Applied when validation dataset is not provided.
        """
        TestDataSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data=data,
            test_data_size=test_data_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data: Optional['outputs.MLTableJobInputResponse'] = None,
             test_data_size: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if test_data_size is None and 'testDataSize' in kwargs:
            test_data_size = kwargs['testDataSize']

        if data is not None:
            _setter("data", data)
        if test_data_size is not None:
            _setter("test_data_size", test_data_size)

    @property
    @pulumi.getter
    def data(self) -> Optional['outputs.MLTableJobInputResponse']:
        """
        Test data MLTable.
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter(name="testDataSize")
    def test_data_size(self) -> Optional[float]:
        """
        The fraction of test dataset that needs to be set aside for validation purpose.
        Values between (0.0 , 1.0)
        Applied when validation dataset is not provided.
        """
        return pulumi.get(self, "test_data_size")


@pulumi.output_type
class TextClassificationMultilabelResponse(dict):
    """
    Text Classification Multilabel task in AutoML NLP vertical.
    NLP - Natural Language Processing.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryMetric":
            suggest = "primary_metric"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "dataSettings":
            suggest = "data_settings"
        elif key == "featurizationSettings":
            suggest = "featurization_settings"
        elif key == "limitSettings":
            suggest = "limit_settings"
        elif key == "logVerbosity":
            suggest = "log_verbosity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TextClassificationMultilabelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TextClassificationMultilabelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TextClassificationMultilabelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary_metric: str,
                 task_type: str,
                 data_settings: Optional['outputs.NlpVerticalDataSettingsResponse'] = None,
                 featurization_settings: Optional['outputs.NlpVerticalFeaturizationSettingsResponse'] = None,
                 limit_settings: Optional['outputs.NlpVerticalLimitSettingsResponse'] = None,
                 log_verbosity: Optional[str] = None):
        """
        Text Classification Multilabel task in AutoML NLP vertical.
        NLP - Natural Language Processing.
        :param str primary_metric: Primary metric for Text-Classification-Multilabel task.
               Currently only Accuracy is supported as primary metric, hence user need not set it explicitly.
        :param str task_type: AutoMLJob Task type.
               Expected value is 'TextClassificationMultilabel'.
        :param 'NlpVerticalDataSettingsResponse' data_settings: Data inputs for AutoMLJob.
        :param 'NlpVerticalFeaturizationSettingsResponse' featurization_settings: Featurization inputs needed for AutoML job.
        :param 'NlpVerticalLimitSettingsResponse' limit_settings: Execution constraints for AutoMLJob.
        :param str log_verbosity: Log verbosity for the job.
        """
        TextClassificationMultilabelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            primary_metric=primary_metric,
            task_type=task_type,
            data_settings=data_settings,
            featurization_settings=featurization_settings,
            limit_settings=limit_settings,
            log_verbosity=log_verbosity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             primary_metric: Optional[str] = None,
             task_type: Optional[str] = None,
             data_settings: Optional['outputs.NlpVerticalDataSettingsResponse'] = None,
             featurization_settings: Optional['outputs.NlpVerticalFeaturizationSettingsResponse'] = None,
             limit_settings: Optional['outputs.NlpVerticalLimitSettingsResponse'] = None,
             log_verbosity: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if primary_metric is None and 'primaryMetric' in kwargs:
            primary_metric = kwargs['primaryMetric']
        if primary_metric is None:
            raise TypeError("Missing 'primary_metric' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if data_settings is None and 'dataSettings' in kwargs:
            data_settings = kwargs['dataSettings']
        if featurization_settings is None and 'featurizationSettings' in kwargs:
            featurization_settings = kwargs['featurizationSettings']
        if limit_settings is None and 'limitSettings' in kwargs:
            limit_settings = kwargs['limitSettings']
        if log_verbosity is None and 'logVerbosity' in kwargs:
            log_verbosity = kwargs['logVerbosity']

        _setter("primary_metric", primary_metric)
        _setter("task_type", 'TextClassificationMultilabel')
        if data_settings is not None:
            _setter("data_settings", data_settings)
        if featurization_settings is not None:
            _setter("featurization_settings", featurization_settings)
        if limit_settings is not None:
            _setter("limit_settings", limit_settings)
        if log_verbosity is None:
            log_verbosity = 'Info'
        if log_verbosity is not None:
            _setter("log_verbosity", log_verbosity)

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> str:
        """
        Primary metric for Text-Classification-Multilabel task.
        Currently only Accuracy is supported as primary metric, hence user need not set it explicitly.
        """
        return pulumi.get(self, "primary_metric")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        AutoMLJob Task type.
        Expected value is 'TextClassificationMultilabel'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="dataSettings")
    def data_settings(self) -> Optional['outputs.NlpVerticalDataSettingsResponse']:
        """
        Data inputs for AutoMLJob.
        """
        return pulumi.get(self, "data_settings")

    @property
    @pulumi.getter(name="featurizationSettings")
    def featurization_settings(self) -> Optional['outputs.NlpVerticalFeaturizationSettingsResponse']:
        """
        Featurization inputs needed for AutoML job.
        """
        return pulumi.get(self, "featurization_settings")

    @property
    @pulumi.getter(name="limitSettings")
    def limit_settings(self) -> Optional['outputs.NlpVerticalLimitSettingsResponse']:
        """
        Execution constraints for AutoMLJob.
        """
        return pulumi.get(self, "limit_settings")

    @property
    @pulumi.getter(name="logVerbosity")
    def log_verbosity(self) -> Optional[str]:
        """
        Log verbosity for the job.
        """
        return pulumi.get(self, "log_verbosity")


@pulumi.output_type
class TextClassificationResponse(dict):
    """
    Text Classification task in AutoML NLP vertical.
    NLP - Natural Language Processing.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "dataSettings":
            suggest = "data_settings"
        elif key == "featurizationSettings":
            suggest = "featurization_settings"
        elif key == "limitSettings":
            suggest = "limit_settings"
        elif key == "logVerbosity":
            suggest = "log_verbosity"
        elif key == "primaryMetric":
            suggest = "primary_metric"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TextClassificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TextClassificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TextClassificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 task_type: str,
                 data_settings: Optional['outputs.NlpVerticalDataSettingsResponse'] = None,
                 featurization_settings: Optional['outputs.NlpVerticalFeaturizationSettingsResponse'] = None,
                 limit_settings: Optional['outputs.NlpVerticalLimitSettingsResponse'] = None,
                 log_verbosity: Optional[str] = None,
                 primary_metric: Optional[str] = None):
        """
        Text Classification task in AutoML NLP vertical.
        NLP - Natural Language Processing.
        :param str task_type: AutoMLJob Task type.
               Expected value is 'TextClassification'.
        :param 'NlpVerticalDataSettingsResponse' data_settings: Data inputs for AutoMLJob.
        :param 'NlpVerticalFeaturizationSettingsResponse' featurization_settings: Featurization inputs needed for AutoML job.
        :param 'NlpVerticalLimitSettingsResponse' limit_settings: Execution constraints for AutoMLJob.
        :param str log_verbosity: Log verbosity for the job.
        :param str primary_metric: Primary metric for Text-Classification task.
        """
        TextClassificationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            task_type=task_type,
            data_settings=data_settings,
            featurization_settings=featurization_settings,
            limit_settings=limit_settings,
            log_verbosity=log_verbosity,
            primary_metric=primary_metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             task_type: Optional[str] = None,
             data_settings: Optional['outputs.NlpVerticalDataSettingsResponse'] = None,
             featurization_settings: Optional['outputs.NlpVerticalFeaturizationSettingsResponse'] = None,
             limit_settings: Optional['outputs.NlpVerticalLimitSettingsResponse'] = None,
             log_verbosity: Optional[str] = None,
             primary_metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if data_settings is None and 'dataSettings' in kwargs:
            data_settings = kwargs['dataSettings']
        if featurization_settings is None and 'featurizationSettings' in kwargs:
            featurization_settings = kwargs['featurizationSettings']
        if limit_settings is None and 'limitSettings' in kwargs:
            limit_settings = kwargs['limitSettings']
        if log_verbosity is None and 'logVerbosity' in kwargs:
            log_verbosity = kwargs['logVerbosity']
        if primary_metric is None and 'primaryMetric' in kwargs:
            primary_metric = kwargs['primaryMetric']

        _setter("task_type", 'TextClassification')
        if data_settings is not None:
            _setter("data_settings", data_settings)
        if featurization_settings is not None:
            _setter("featurization_settings", featurization_settings)
        if limit_settings is not None:
            _setter("limit_settings", limit_settings)
        if log_verbosity is None:
            log_verbosity = 'Info'
        if log_verbosity is not None:
            _setter("log_verbosity", log_verbosity)
        if primary_metric is None:
            primary_metric = 'Accuracy'
        if primary_metric is not None:
            _setter("primary_metric", primary_metric)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        AutoMLJob Task type.
        Expected value is 'TextClassification'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="dataSettings")
    def data_settings(self) -> Optional['outputs.NlpVerticalDataSettingsResponse']:
        """
        Data inputs for AutoMLJob.
        """
        return pulumi.get(self, "data_settings")

    @property
    @pulumi.getter(name="featurizationSettings")
    def featurization_settings(self) -> Optional['outputs.NlpVerticalFeaturizationSettingsResponse']:
        """
        Featurization inputs needed for AutoML job.
        """
        return pulumi.get(self, "featurization_settings")

    @property
    @pulumi.getter(name="limitSettings")
    def limit_settings(self) -> Optional['outputs.NlpVerticalLimitSettingsResponse']:
        """
        Execution constraints for AutoMLJob.
        """
        return pulumi.get(self, "limit_settings")

    @property
    @pulumi.getter(name="logVerbosity")
    def log_verbosity(self) -> Optional[str]:
        """
        Log verbosity for the job.
        """
        return pulumi.get(self, "log_verbosity")

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> Optional[str]:
        """
        Primary metric for Text-Classification task.
        """
        return pulumi.get(self, "primary_metric")


@pulumi.output_type
class TextNerResponse(dict):
    """
    Text-NER task in AutoML NLP vertical.
    NER - Named Entity Recognition.
    NLP - Natural Language Processing.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryMetric":
            suggest = "primary_metric"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "dataSettings":
            suggest = "data_settings"
        elif key == "featurizationSettings":
            suggest = "featurization_settings"
        elif key == "limitSettings":
            suggest = "limit_settings"
        elif key == "logVerbosity":
            suggest = "log_verbosity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TextNerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TextNerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TextNerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary_metric: str,
                 task_type: str,
                 data_settings: Optional['outputs.NlpVerticalDataSettingsResponse'] = None,
                 featurization_settings: Optional['outputs.NlpVerticalFeaturizationSettingsResponse'] = None,
                 limit_settings: Optional['outputs.NlpVerticalLimitSettingsResponse'] = None,
                 log_verbosity: Optional[str] = None):
        """
        Text-NER task in AutoML NLP vertical.
        NER - Named Entity Recognition.
        NLP - Natural Language Processing.
        :param str primary_metric: Primary metric for Text-NER task.
               Only 'Accuracy' is supported for Text-NER, so user need not set this explicitly.
        :param str task_type: AutoMLJob Task type.
               Expected value is 'TextNER'.
        :param 'NlpVerticalDataSettingsResponse' data_settings: Data inputs for AutoMLJob.
        :param 'NlpVerticalFeaturizationSettingsResponse' featurization_settings: Featurization inputs needed for AutoML job.
        :param 'NlpVerticalLimitSettingsResponse' limit_settings: Execution constraints for AutoMLJob.
        :param str log_verbosity: Log verbosity for the job.
        """
        TextNerResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            primary_metric=primary_metric,
            task_type=task_type,
            data_settings=data_settings,
            featurization_settings=featurization_settings,
            limit_settings=limit_settings,
            log_verbosity=log_verbosity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             primary_metric: Optional[str] = None,
             task_type: Optional[str] = None,
             data_settings: Optional['outputs.NlpVerticalDataSettingsResponse'] = None,
             featurization_settings: Optional['outputs.NlpVerticalFeaturizationSettingsResponse'] = None,
             limit_settings: Optional['outputs.NlpVerticalLimitSettingsResponse'] = None,
             log_verbosity: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if primary_metric is None and 'primaryMetric' in kwargs:
            primary_metric = kwargs['primaryMetric']
        if primary_metric is None:
            raise TypeError("Missing 'primary_metric' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if data_settings is None and 'dataSettings' in kwargs:
            data_settings = kwargs['dataSettings']
        if featurization_settings is None and 'featurizationSettings' in kwargs:
            featurization_settings = kwargs['featurizationSettings']
        if limit_settings is None and 'limitSettings' in kwargs:
            limit_settings = kwargs['limitSettings']
        if log_verbosity is None and 'logVerbosity' in kwargs:
            log_verbosity = kwargs['logVerbosity']

        _setter("primary_metric", primary_metric)
        _setter("task_type", 'TextNER')
        if data_settings is not None:
            _setter("data_settings", data_settings)
        if featurization_settings is not None:
            _setter("featurization_settings", featurization_settings)
        if limit_settings is not None:
            _setter("limit_settings", limit_settings)
        if log_verbosity is None:
            log_verbosity = 'Info'
        if log_verbosity is not None:
            _setter("log_verbosity", log_verbosity)

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> str:
        """
        Primary metric for Text-NER task.
        Only 'Accuracy' is supported for Text-NER, so user need not set this explicitly.
        """
        return pulumi.get(self, "primary_metric")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        AutoMLJob Task type.
        Expected value is 'TextNER'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="dataSettings")
    def data_settings(self) -> Optional['outputs.NlpVerticalDataSettingsResponse']:
        """
        Data inputs for AutoMLJob.
        """
        return pulumi.get(self, "data_settings")

    @property
    @pulumi.getter(name="featurizationSettings")
    def featurization_settings(self) -> Optional['outputs.NlpVerticalFeaturizationSettingsResponse']:
        """
        Featurization inputs needed for AutoML job.
        """
        return pulumi.get(self, "featurization_settings")

    @property
    @pulumi.getter(name="limitSettings")
    def limit_settings(self) -> Optional['outputs.NlpVerticalLimitSettingsResponse']:
        """
        Execution constraints for AutoMLJob.
        """
        return pulumi.get(self, "limit_settings")

    @property
    @pulumi.getter(name="logVerbosity")
    def log_verbosity(self) -> Optional[str]:
        """
        Log verbosity for the job.
        """
        return pulumi.get(self, "log_verbosity")


@pulumi.output_type
class TrainingDataSettingsResponse(dict):
    """
    Training data input.
    """
    def __init__(__self__, *,
                 data: 'outputs.MLTableJobInputResponse'):
        """
        Training data input.
        :param 'MLTableJobInputResponse' data: [Required] Training data MLTable.
        """
        TrainingDataSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data=data,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data: Optional['outputs.MLTableJobInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data is None:
            raise TypeError("Missing 'data' argument")

        _setter("data", data)

    @property
    @pulumi.getter
    def data(self) -> 'outputs.MLTableJobInputResponse':
        """
        [Required] Training data MLTable.
        """
        return pulumi.get(self, "data")


@pulumi.output_type
class TrainingSettingsResponse(dict):
    """
    Training related configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableDnnTraining":
            suggest = "enable_dnn_training"
        elif key == "enableModelExplainability":
            suggest = "enable_model_explainability"
        elif key == "enableOnnxCompatibleModels":
            suggest = "enable_onnx_compatible_models"
        elif key == "enableStackEnsemble":
            suggest = "enable_stack_ensemble"
        elif key == "enableVoteEnsemble":
            suggest = "enable_vote_ensemble"
        elif key == "ensembleModelDownloadTimeout":
            suggest = "ensemble_model_download_timeout"
        elif key == "stackEnsembleSettings":
            suggest = "stack_ensemble_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrainingSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrainingSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrainingSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_dnn_training: Optional[bool] = None,
                 enable_model_explainability: Optional[bool] = None,
                 enable_onnx_compatible_models: Optional[bool] = None,
                 enable_stack_ensemble: Optional[bool] = None,
                 enable_vote_ensemble: Optional[bool] = None,
                 ensemble_model_download_timeout: Optional[str] = None,
                 stack_ensemble_settings: Optional['outputs.StackEnsembleSettingsResponse'] = None):
        """
        Training related configuration.
        :param bool enable_dnn_training: Enable recommendation of DNN models.
        :param bool enable_model_explainability: Flag to turn on explainability on best model.
        :param bool enable_onnx_compatible_models: Flag for enabling onnx compatible models.
        :param bool enable_stack_ensemble: Enable stack ensemble run.
        :param bool enable_vote_ensemble: Enable voting ensemble run.
        :param str ensemble_model_download_timeout: During VotingEnsemble and StackEnsemble model generation, multiple fitted models from the previous child runs are downloaded.
               Configure this parameter with a higher value than 300 secs, if more time is needed.
        :param 'StackEnsembleSettingsResponse' stack_ensemble_settings: Stack ensemble settings for stack ensemble run.
        """
        TrainingSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable_dnn_training=enable_dnn_training,
            enable_model_explainability=enable_model_explainability,
            enable_onnx_compatible_models=enable_onnx_compatible_models,
            enable_stack_ensemble=enable_stack_ensemble,
            enable_vote_ensemble=enable_vote_ensemble,
            ensemble_model_download_timeout=ensemble_model_download_timeout,
            stack_ensemble_settings=stack_ensemble_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable_dnn_training: Optional[bool] = None,
             enable_model_explainability: Optional[bool] = None,
             enable_onnx_compatible_models: Optional[bool] = None,
             enable_stack_ensemble: Optional[bool] = None,
             enable_vote_ensemble: Optional[bool] = None,
             ensemble_model_download_timeout: Optional[str] = None,
             stack_ensemble_settings: Optional['outputs.StackEnsembleSettingsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enable_dnn_training is None and 'enableDnnTraining' in kwargs:
            enable_dnn_training = kwargs['enableDnnTraining']
        if enable_model_explainability is None and 'enableModelExplainability' in kwargs:
            enable_model_explainability = kwargs['enableModelExplainability']
        if enable_onnx_compatible_models is None and 'enableOnnxCompatibleModels' in kwargs:
            enable_onnx_compatible_models = kwargs['enableOnnxCompatibleModels']
        if enable_stack_ensemble is None and 'enableStackEnsemble' in kwargs:
            enable_stack_ensemble = kwargs['enableStackEnsemble']
        if enable_vote_ensemble is None and 'enableVoteEnsemble' in kwargs:
            enable_vote_ensemble = kwargs['enableVoteEnsemble']
        if ensemble_model_download_timeout is None and 'ensembleModelDownloadTimeout' in kwargs:
            ensemble_model_download_timeout = kwargs['ensembleModelDownloadTimeout']
        if stack_ensemble_settings is None and 'stackEnsembleSettings' in kwargs:
            stack_ensemble_settings = kwargs['stackEnsembleSettings']

        if enable_dnn_training is None:
            enable_dnn_training = False
        if enable_dnn_training is not None:
            _setter("enable_dnn_training", enable_dnn_training)
        if enable_model_explainability is None:
            enable_model_explainability = False
        if enable_model_explainability is not None:
            _setter("enable_model_explainability", enable_model_explainability)
        if enable_onnx_compatible_models is None:
            enable_onnx_compatible_models = False
        if enable_onnx_compatible_models is not None:
            _setter("enable_onnx_compatible_models", enable_onnx_compatible_models)
        if enable_stack_ensemble is None:
            enable_stack_ensemble = True
        if enable_stack_ensemble is not None:
            _setter("enable_stack_ensemble", enable_stack_ensemble)
        if enable_vote_ensemble is None:
            enable_vote_ensemble = True
        if enable_vote_ensemble is not None:
            _setter("enable_vote_ensemble", enable_vote_ensemble)
        if ensemble_model_download_timeout is None:
            ensemble_model_download_timeout = 'PT5M'
        if ensemble_model_download_timeout is not None:
            _setter("ensemble_model_download_timeout", ensemble_model_download_timeout)
        if stack_ensemble_settings is not None:
            _setter("stack_ensemble_settings", stack_ensemble_settings)

    @property
    @pulumi.getter(name="enableDnnTraining")
    def enable_dnn_training(self) -> Optional[bool]:
        """
        Enable recommendation of DNN models.
        """
        return pulumi.get(self, "enable_dnn_training")

    @property
    @pulumi.getter(name="enableModelExplainability")
    def enable_model_explainability(self) -> Optional[bool]:
        """
        Flag to turn on explainability on best model.
        """
        return pulumi.get(self, "enable_model_explainability")

    @property
    @pulumi.getter(name="enableOnnxCompatibleModels")
    def enable_onnx_compatible_models(self) -> Optional[bool]:
        """
        Flag for enabling onnx compatible models.
        """
        return pulumi.get(self, "enable_onnx_compatible_models")

    @property
    @pulumi.getter(name="enableStackEnsemble")
    def enable_stack_ensemble(self) -> Optional[bool]:
        """
        Enable stack ensemble run.
        """
        return pulumi.get(self, "enable_stack_ensemble")

    @property
    @pulumi.getter(name="enableVoteEnsemble")
    def enable_vote_ensemble(self) -> Optional[bool]:
        """
        Enable voting ensemble run.
        """
        return pulumi.get(self, "enable_vote_ensemble")

    @property
    @pulumi.getter(name="ensembleModelDownloadTimeout")
    def ensemble_model_download_timeout(self) -> Optional[str]:
        """
        During VotingEnsemble and StackEnsemble model generation, multiple fitted models from the previous child runs are downloaded.
        Configure this parameter with a higher value than 300 secs, if more time is needed.
        """
        return pulumi.get(self, "ensemble_model_download_timeout")

    @property
    @pulumi.getter(name="stackEnsembleSettings")
    def stack_ensemble_settings(self) -> Optional['outputs.StackEnsembleSettingsResponse']:
        """
        Stack ensemble settings for stack ensemble run.
        """
        return pulumi.get(self, "stack_ensemble_settings")


@pulumi.output_type
class TrialComponentResponse(dict):
    """
    Trial component definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentId":
            suggest = "environment_id"
        elif key == "codeId":
            suggest = "code_id"
        elif key == "environmentVariables":
            suggest = "environment_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrialComponentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrialComponentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrialComponentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command: str,
                 environment_id: str,
                 code_id: Optional[str] = None,
                 distribution: Optional[Any] = None,
                 environment_variables: Optional[Mapping[str, str]] = None,
                 resources: Optional['outputs.ResourceConfigurationResponse'] = None):
        """
        Trial component definition.
        :param str command: [Required] The command to execute on startup of the job. eg. "python train.py"
        :param str environment_id: [Required] The ARM resource ID of the Environment specification for the job.
        :param str code_id: ARM resource ID of the code asset.
        :param Union['MpiResponse', 'PyTorchResponse', 'TensorFlowResponse'] distribution: Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, or null.
        :param Mapping[str, str] environment_variables: Environment variables included in the job.
        :param 'ResourceConfigurationResponse' resources: Compute Resource configuration for the job.
        """
        TrialComponentResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            command=command,
            environment_id=environment_id,
            code_id=code_id,
            distribution=distribution,
            environment_variables=environment_variables,
            resources=resources,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             command: Optional[str] = None,
             environment_id: Optional[str] = None,
             code_id: Optional[str] = None,
             distribution: Optional[Any] = None,
             environment_variables: Optional[Mapping[str, str]] = None,
             resources: Optional['outputs.ResourceConfigurationResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if command is None:
            raise TypeError("Missing 'command' argument")
        if environment_id is None and 'environmentId' in kwargs:
            environment_id = kwargs['environmentId']
        if environment_id is None:
            raise TypeError("Missing 'environment_id' argument")
        if code_id is None and 'codeId' in kwargs:
            code_id = kwargs['codeId']
        if environment_variables is None and 'environmentVariables' in kwargs:
            environment_variables = kwargs['environmentVariables']

        _setter("command", command)
        _setter("environment_id", environment_id)
        if code_id is not None:
            _setter("code_id", code_id)
        if distribution is not None:
            _setter("distribution", distribution)
        if environment_variables is not None:
            _setter("environment_variables", environment_variables)
        if resources is not None:
            _setter("resources", resources)

    @property
    @pulumi.getter
    def command(self) -> str:
        """
        [Required] The command to execute on startup of the job. eg. "python train.py"
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> str:
        """
        [Required] The ARM resource ID of the Environment specification for the job.
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="codeId")
    def code_id(self) -> Optional[str]:
        """
        ARM resource ID of the code asset.
        """
        return pulumi.get(self, "code_id")

    @property
    @pulumi.getter
    def distribution(self) -> Optional[Any]:
        """
        Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, or null.
        """
        return pulumi.get(self, "distribution")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, str]]:
        """
        Environment variables included in the job.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.ResourceConfigurationResponse']:
        """
        Compute Resource configuration for the job.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class TritonModelJobInputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobInputType":
            suggest = "job_input_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TritonModelJobInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TritonModelJobInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TritonModelJobInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_input_type: str,
                 uri: str,
                 description: Optional[str] = None,
                 mode: Optional[str] = None):
        """
        :param str job_input_type: Enum to determine the Job Input Type.
               Expected value is 'TritonModel'.
        :param str uri: [Required] Input Asset URI.
        :param str description: Description for the input.
        :param str mode: Input Asset Delivery Mode.
        """
        TritonModelJobInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_input_type=job_input_type,
            uri=uri,
            description=description,
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_input_type: Optional[str] = None,
             uri: Optional[str] = None,
             description: Optional[str] = None,
             mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if job_input_type is None and 'jobInputType' in kwargs:
            job_input_type = kwargs['jobInputType']
        if job_input_type is None:
            raise TypeError("Missing 'job_input_type' argument")
        if uri is None:
            raise TypeError("Missing 'uri' argument")

        _setter("job_input_type", 'TritonModel')
        _setter("uri", uri)
        if description is not None:
            _setter("description", description)
        if mode is None:
            mode = 'ReadOnlyMount'
        if mode is not None:
            _setter("mode", mode)

    @property
    @pulumi.getter(name="jobInputType")
    def job_input_type(self) -> str:
        """
        Enum to determine the Job Input Type.
        Expected value is 'TritonModel'.
        """
        return pulumi.get(self, "job_input_type")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        [Required] Input Asset URI.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for the input.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Input Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class TritonModelJobOutputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobOutputType":
            suggest = "job_output_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TritonModelJobOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TritonModelJobOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TritonModelJobOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_output_type: str,
                 description: Optional[str] = None,
                 mode: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        :param str job_output_type: Enum to determine the Job Output Type.
               Expected value is 'TritonModel'.
        :param str description: Description for the output.
        :param str mode: Output Asset Delivery Mode.
        :param str uri: Output Asset URI.
        """
        TritonModelJobOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_output_type=job_output_type,
            description=description,
            mode=mode,
            uri=uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_output_type: Optional[str] = None,
             description: Optional[str] = None,
             mode: Optional[str] = None,
             uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if job_output_type is None and 'jobOutputType' in kwargs:
            job_output_type = kwargs['jobOutputType']
        if job_output_type is None:
            raise TypeError("Missing 'job_output_type' argument")

        _setter("job_output_type", 'TritonModel')
        if description is not None:
            _setter("description", description)
        if mode is None:
            mode = 'ReadWriteMount'
        if mode is not None:
            _setter("mode", mode)
        if uri is not None:
            _setter("uri", uri)

    @property
    @pulumi.getter(name="jobOutputType")
    def job_output_type(self) -> str:
        """
        Enum to determine the Job Output Type.
        Expected value is 'TritonModel'.
        """
        return pulumi.get(self, "job_output_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for the output.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Output Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        Output Asset URI.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class TruncationSelectionPolicyResponse(dict):
    """
    Defines an early termination policy that cancels a given percentage of runs at each evaluation interval.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyType":
            suggest = "policy_type"
        elif key == "delayEvaluation":
            suggest = "delay_evaluation"
        elif key == "evaluationInterval":
            suggest = "evaluation_interval"
        elif key == "truncationPercentage":
            suggest = "truncation_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TruncationSelectionPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TruncationSelectionPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TruncationSelectionPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_type: str,
                 delay_evaluation: Optional[int] = None,
                 evaluation_interval: Optional[int] = None,
                 truncation_percentage: Optional[int] = None):
        """
        Defines an early termination policy that cancels a given percentage of runs at each evaluation interval.
        :param str policy_type: 
               Expected value is 'TruncationSelection'.
        :param int delay_evaluation: Number of intervals by which to delay the first evaluation.
        :param int evaluation_interval: Interval (number of runs) between policy evaluations.
        :param int truncation_percentage: The percentage of runs to cancel at each evaluation interval.
        """
        TruncationSelectionPolicyResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy_type=policy_type,
            delay_evaluation=delay_evaluation,
            evaluation_interval=evaluation_interval,
            truncation_percentage=truncation_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy_type: Optional[str] = None,
             delay_evaluation: Optional[int] = None,
             evaluation_interval: Optional[int] = None,
             truncation_percentage: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if policy_type is None and 'policyType' in kwargs:
            policy_type = kwargs['policyType']
        if policy_type is None:
            raise TypeError("Missing 'policy_type' argument")
        if delay_evaluation is None and 'delayEvaluation' in kwargs:
            delay_evaluation = kwargs['delayEvaluation']
        if evaluation_interval is None and 'evaluationInterval' in kwargs:
            evaluation_interval = kwargs['evaluationInterval']
        if truncation_percentage is None and 'truncationPercentage' in kwargs:
            truncation_percentage = kwargs['truncationPercentage']

        _setter("policy_type", 'TruncationSelection')
        if delay_evaluation is None:
            delay_evaluation = 0
        if delay_evaluation is not None:
            _setter("delay_evaluation", delay_evaluation)
        if evaluation_interval is None:
            evaluation_interval = 0
        if evaluation_interval is not None:
            _setter("evaluation_interval", evaluation_interval)
        if truncation_percentage is None:
            truncation_percentage = 0
        if truncation_percentage is not None:
            _setter("truncation_percentage", truncation_percentage)

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> str:
        """

        Expected value is 'TruncationSelection'.
        """
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="delayEvaluation")
    def delay_evaluation(self) -> Optional[int]:
        """
        Number of intervals by which to delay the first evaluation.
        """
        return pulumi.get(self, "delay_evaluation")

    @property
    @pulumi.getter(name="evaluationInterval")
    def evaluation_interval(self) -> Optional[int]:
        """
        Interval (number of runs) between policy evaluations.
        """
        return pulumi.get(self, "evaluation_interval")

    @property
    @pulumi.getter(name="truncationPercentage")
    def truncation_percentage(self) -> Optional[int]:
        """
        The percentage of runs to cancel at each evaluation interval.
        """
        return pulumi.get(self, "truncation_percentage")


@pulumi.output_type
class UriFileDataVersionResponse(dict):
    """
    uri-file data version entity
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "dataUri":
            suggest = "data_uri"
        elif key == "isAnonymous":
            suggest = "is_anonymous"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UriFileDataVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UriFileDataVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UriFileDataVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: str,
                 data_uri: str,
                 description: Optional[str] = None,
                 is_anonymous: Optional[bool] = None,
                 is_archived: Optional[bool] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        uri-file data version entity
        :param str data_type: Enum to determine the type of data.
               Expected value is 'UriFile'.
        :param str data_uri: [Required] Uri of the data. Usage/meaning depends on Microsoft.MachineLearning.ManagementFrontEnd.Contracts.V20220201Preview.Assets.DataVersionBase.DataType
        :param str description: The asset description text.
        :param bool is_anonymous: If the name version are system generated (anonymous registration).
        :param bool is_archived: Is the asset archived?
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        UriFileDataVersionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_type=data_type,
            data_uri=data_uri,
            description=description,
            is_anonymous=is_anonymous,
            is_archived=is_archived,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_type: Optional[str] = None,
             data_uri: Optional[str] = None,
             description: Optional[str] = None,
             is_anonymous: Optional[bool] = None,
             is_archived: Optional[bool] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_type is None and 'dataType' in kwargs:
            data_type = kwargs['dataType']
        if data_type is None:
            raise TypeError("Missing 'data_type' argument")
        if data_uri is None and 'dataUri' in kwargs:
            data_uri = kwargs['dataUri']
        if data_uri is None:
            raise TypeError("Missing 'data_uri' argument")
        if is_anonymous is None and 'isAnonymous' in kwargs:
            is_anonymous = kwargs['isAnonymous']
        if is_archived is None and 'isArchived' in kwargs:
            is_archived = kwargs['isArchived']

        _setter("data_type", 'UriFile')
        _setter("data_uri", data_uri)
        if description is not None:
            _setter("description", description)
        if is_anonymous is None:
            is_anonymous = False
        if is_anonymous is not None:
            _setter("is_anonymous", is_anonymous)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            _setter("is_archived", is_archived)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        Enum to determine the type of data.
        Expected value is 'UriFile'.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="dataUri")
    def data_uri(self) -> str:
        """
        [Required] Uri of the data. Usage/meaning depends on Microsoft.MachineLearning.ManagementFrontEnd.Contracts.V20220201Preview.Assets.DataVersionBase.DataType
        """
        return pulumi.get(self, "data_uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[bool]:
        """
        If the name version are system generated (anonymous registration).
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class UriFileJobInputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobInputType":
            suggest = "job_input_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UriFileJobInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UriFileJobInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UriFileJobInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_input_type: str,
                 uri: str,
                 description: Optional[str] = None,
                 mode: Optional[str] = None):
        """
        :param str job_input_type: Enum to determine the Job Input Type.
               Expected value is 'UriFile'.
        :param str uri: [Required] Input Asset URI.
        :param str description: Description for the input.
        :param str mode: Input Asset Delivery Mode.
        """
        UriFileJobInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_input_type=job_input_type,
            uri=uri,
            description=description,
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_input_type: Optional[str] = None,
             uri: Optional[str] = None,
             description: Optional[str] = None,
             mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if job_input_type is None and 'jobInputType' in kwargs:
            job_input_type = kwargs['jobInputType']
        if job_input_type is None:
            raise TypeError("Missing 'job_input_type' argument")
        if uri is None:
            raise TypeError("Missing 'uri' argument")

        _setter("job_input_type", 'UriFile')
        _setter("uri", uri)
        if description is not None:
            _setter("description", description)
        if mode is None:
            mode = 'ReadOnlyMount'
        if mode is not None:
            _setter("mode", mode)

    @property
    @pulumi.getter(name="jobInputType")
    def job_input_type(self) -> str:
        """
        Enum to determine the Job Input Type.
        Expected value is 'UriFile'.
        """
        return pulumi.get(self, "job_input_type")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        [Required] Input Asset URI.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for the input.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Input Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class UriFileJobOutputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobOutputType":
            suggest = "job_output_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UriFileJobOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UriFileJobOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UriFileJobOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_output_type: str,
                 description: Optional[str] = None,
                 mode: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        :param str job_output_type: Enum to determine the Job Output Type.
               Expected value is 'UriFile'.
        :param str description: Description for the output.
        :param str mode: Output Asset Delivery Mode.
        :param str uri: Output Asset URI.
        """
        UriFileJobOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_output_type=job_output_type,
            description=description,
            mode=mode,
            uri=uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_output_type: Optional[str] = None,
             description: Optional[str] = None,
             mode: Optional[str] = None,
             uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if job_output_type is None and 'jobOutputType' in kwargs:
            job_output_type = kwargs['jobOutputType']
        if job_output_type is None:
            raise TypeError("Missing 'job_output_type' argument")

        _setter("job_output_type", 'UriFile')
        if description is not None:
            _setter("description", description)
        if mode is None:
            mode = 'ReadWriteMount'
        if mode is not None:
            _setter("mode", mode)
        if uri is not None:
            _setter("uri", uri)

    @property
    @pulumi.getter(name="jobOutputType")
    def job_output_type(self) -> str:
        """
        Enum to determine the Job Output Type.
        Expected value is 'UriFile'.
        """
        return pulumi.get(self, "job_output_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for the output.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Output Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        Output Asset URI.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class UriFolderDataVersionResponse(dict):
    """
    uri-folder data version entity
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "dataUri":
            suggest = "data_uri"
        elif key == "isAnonymous":
            suggest = "is_anonymous"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UriFolderDataVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UriFolderDataVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UriFolderDataVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: str,
                 data_uri: str,
                 description: Optional[str] = None,
                 is_anonymous: Optional[bool] = None,
                 is_archived: Optional[bool] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        uri-folder data version entity
        :param str data_type: Enum to determine the type of data.
               Expected value is 'UriFolder'.
        :param str data_uri: [Required] Uri of the data. Usage/meaning depends on Microsoft.MachineLearning.ManagementFrontEnd.Contracts.V20220201Preview.Assets.DataVersionBase.DataType
        :param str description: The asset description text.
        :param bool is_anonymous: If the name version are system generated (anonymous registration).
        :param bool is_archived: Is the asset archived?
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        UriFolderDataVersionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_type=data_type,
            data_uri=data_uri,
            description=description,
            is_anonymous=is_anonymous,
            is_archived=is_archived,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_type: Optional[str] = None,
             data_uri: Optional[str] = None,
             description: Optional[str] = None,
             is_anonymous: Optional[bool] = None,
             is_archived: Optional[bool] = None,
             properties: Optional[Mapping[str, str]] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_type is None and 'dataType' in kwargs:
            data_type = kwargs['dataType']
        if data_type is None:
            raise TypeError("Missing 'data_type' argument")
        if data_uri is None and 'dataUri' in kwargs:
            data_uri = kwargs['dataUri']
        if data_uri is None:
            raise TypeError("Missing 'data_uri' argument")
        if is_anonymous is None and 'isAnonymous' in kwargs:
            is_anonymous = kwargs['isAnonymous']
        if is_archived is None and 'isArchived' in kwargs:
            is_archived = kwargs['isArchived']

        _setter("data_type", 'UriFolder')
        _setter("data_uri", data_uri)
        if description is not None:
            _setter("description", description)
        if is_anonymous is None:
            is_anonymous = False
        if is_anonymous is not None:
            _setter("is_anonymous", is_anonymous)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            _setter("is_archived", is_archived)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        Enum to determine the type of data.
        Expected value is 'UriFolder'.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="dataUri")
    def data_uri(self) -> str:
        """
        [Required] Uri of the data. Usage/meaning depends on Microsoft.MachineLearning.ManagementFrontEnd.Contracts.V20220201Preview.Assets.DataVersionBase.DataType
        """
        return pulumi.get(self, "data_uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[bool]:
        """
        If the name version are system generated (anonymous registration).
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class UriFolderJobInputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobInputType":
            suggest = "job_input_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UriFolderJobInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UriFolderJobInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UriFolderJobInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_input_type: str,
                 uri: str,
                 description: Optional[str] = None,
                 mode: Optional[str] = None):
        """
        :param str job_input_type: Enum to determine the Job Input Type.
               Expected value is 'UriFolder'.
        :param str uri: [Required] Input Asset URI.
        :param str description: Description for the input.
        :param str mode: Input Asset Delivery Mode.
        """
        UriFolderJobInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_input_type=job_input_type,
            uri=uri,
            description=description,
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_input_type: Optional[str] = None,
             uri: Optional[str] = None,
             description: Optional[str] = None,
             mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if job_input_type is None and 'jobInputType' in kwargs:
            job_input_type = kwargs['jobInputType']
        if job_input_type is None:
            raise TypeError("Missing 'job_input_type' argument")
        if uri is None:
            raise TypeError("Missing 'uri' argument")

        _setter("job_input_type", 'UriFolder')
        _setter("uri", uri)
        if description is not None:
            _setter("description", description)
        if mode is None:
            mode = 'ReadOnlyMount'
        if mode is not None:
            _setter("mode", mode)

    @property
    @pulumi.getter(name="jobInputType")
    def job_input_type(self) -> str:
        """
        Enum to determine the Job Input Type.
        Expected value is 'UriFolder'.
        """
        return pulumi.get(self, "job_input_type")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        [Required] Input Asset URI.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for the input.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Input Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class UriFolderJobOutputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobOutputType":
            suggest = "job_output_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UriFolderJobOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UriFolderJobOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UriFolderJobOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_output_type: str,
                 description: Optional[str] = None,
                 mode: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        :param str job_output_type: Enum to determine the Job Output Type.
               Expected value is 'UriFolder'.
        :param str description: Description for the output.
        :param str mode: Output Asset Delivery Mode.
        :param str uri: Output Asset URI.
        """
        UriFolderJobOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_output_type=job_output_type,
            description=description,
            mode=mode,
            uri=uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_output_type: Optional[str] = None,
             description: Optional[str] = None,
             mode: Optional[str] = None,
             uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if job_output_type is None and 'jobOutputType' in kwargs:
            job_output_type = kwargs['jobOutputType']
        if job_output_type is None:
            raise TypeError("Missing 'job_output_type' argument")

        _setter("job_output_type", 'UriFolder')
        if description is not None:
            _setter("description", description)
        if mode is None:
            mode = 'ReadWriteMount'
        if mode is not None:
            _setter("mode", mode)
        if uri is not None:
            _setter("uri", uri)

    @property
    @pulumi.getter(name="jobOutputType")
    def job_output_type(self) -> str:
        """
        Enum to determine the Job Output Type.
        Expected value is 'UriFolder'.
        """
        return pulumi.get(self, "job_output_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for the output.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Output Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        Output Asset URI.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str):
        """
        User assigned identity properties
        :param str client_id: The client ID of the assigned identity.
        :param str principal_id: The principal ID of the assigned identity.
        """
        UserAssignedIdentityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            principal_id=principal_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[str] = None,
             principal_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_id is None:
            raise TypeError("Missing 'client_id' argument")
        if principal_id is None and 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if principal_id is None:
            raise TypeError("Missing 'principal_id' argument")

        _setter("client_id", client_id)
        _setter("principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class UserIdentityResponse(dict):
    """
    User identity configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityType":
            suggest = "identity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_type: str):
        """
        User identity configuration.
        :param str identity_type: Enum to determine identity framework.
               Expected value is 'UserIdentity'.
        """
        UserIdentityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_type=identity_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if identity_type is None and 'identityType' in kwargs:
            identity_type = kwargs['identityType']
        if identity_type is None:
            raise TypeError("Missing 'identity_type' argument")

        _setter("identity_type", 'UserIdentity')

    @property
    @pulumi.getter(name="identityType")
    def identity_type(self) -> str:
        """
        Enum to determine identity framework.
        Expected value is 'UserIdentity'.
        """
        return pulumi.get(self, "identity_type")


