# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AADAuthTypeWorkspaceConnectionPropertiesResponse',
    'AKSResponse',
    'AKSSchemaResponseProperties',
    'AccessKeyAuthTypeWorkspaceConnectionPropertiesResponse',
    'AccountApiKeysResponse',
    'AccountKeyAuthTypeWorkspaceConnectionPropertiesResponse',
    'AccountKeyDatastoreCredentialsResponse',
    'AcrDetailsResponse',
    'ActualCapacityInfoResponse',
    'AksNetworkingConfigurationResponse',
    'AllFeaturesResponse',
    'AllNodesResponse',
    'AmlComputeNodeInformationResponse',
    'AmlComputePropertiesResponse',
    'AmlComputeResponse',
    'AmlTokenComputeIdentityResponse',
    'AmlTokenResponse',
    'ApiKeyAuthWorkspaceConnectionPropertiesResponse',
    'ArmResourceIdResponse',
    'AssignedUserResponse',
    'AutoForecastHorizonResponse',
    'AutoMLJobResponse',
    'AutoNCrossValidationsResponse',
    'AutoPausePropertiesResponse',
    'AutoScalePropertiesResponse',
    'AutoSeasonalityResponse',
    'AutoTargetLagsResponse',
    'AutoTargetRollingWindowSizeResponse',
    'AzureBlobDatastoreResponse',
    'AzureDataLakeGen1DatastoreResponse',
    'AzureDataLakeGen2DatastoreResponse',
    'AzureDataLakeSectionResponse',
    'AzureDevOpsWebhookResponse',
    'AzureFileDatastoreResponse',
    'AzureMySqlSectionResponse',
    'AzurePostgreSqlSectionResponse',
    'AzureSqlDatabaseSectionResponse',
    'AzureStorageSectionResponse',
    'BanditPolicyResponse',
    'BatchDeploymentResponse',
    'BatchEndpointDefaultsResponse',
    'BatchEndpointResponse',
    'BatchPipelineComponentDeploymentConfigurationResponse',
    'BatchRetrySettingsResponse',
    'BayesianSamplingAlgorithmResponse',
    'BindOptionsResponse',
    'BuildContextResponse',
    'CapabilityHostResponse',
    'CapacityReservationGroupResponse',
    'CategoricalDataDriftMetricThresholdResponse',
    'CategoricalDataQualityMetricThresholdResponse',
    'CategoricalPredictionDriftMetricThresholdResponse',
    'CertificateDatastoreCredentialsResponse',
    'ClassificationResponse',
    'ClassificationTrainingSettingsResponse',
    'ClientCredentialsResponse',
    'CodeConfigurationResponse',
    'CodeContainerResponse',
    'CodeVersionResponse',
    'CognitiveServicesSkuResponse',
    'CollectionResponse',
    'ColumnTransformerResponse',
    'CommandJobLimitsResponse',
    'CommandJobResponse',
    'ComponentContainerResponse',
    'ComponentVersionResponse',
    'ComputeInstanceApplicationResponse',
    'ComputeInstanceConnectivityEndpointsResponse',
    'ComputeInstanceContainerResponse',
    'ComputeInstanceCreatedByResponse',
    'ComputeInstanceDataDiskResponse',
    'ComputeInstanceDataMountResponse',
    'ComputeInstanceEnvironmentInfoResponse',
    'ComputeInstanceLastOperationResponse',
    'ComputeInstancePropertiesResponse',
    'ComputeInstanceResponse',
    'ComputeInstanceSshSettingsResponse',
    'ComputeInstanceVersionResponse',
    'ComputeRecurrenceScheduleResponse',
    'ComputeRuntimeDtoResponse',
    'ComputeSchedulesResponse',
    'ComputeStartStopScheduleResponse',
    'ContainerResourceRequirementsResponse',
    'ContainerResourceSettingsResponse',
    'ContentSafetyEndpointDeploymentResourcePropertiesResponse',
    'ContentSafetyResponse',
    'CosmosDbSettingsResponse',
    'CreateMonitorActionResponse',
    'CronResponse',
    'CronTriggerResponse',
    'CustomForecastHorizonResponse',
    'CustomKeysResponse',
    'CustomKeysWorkspaceConnectionPropertiesResponse',
    'CustomMetricThresholdResponse',
    'CustomModelJobInputResponse',
    'CustomModelJobOutputResponse',
    'CustomMonitoringSignalResponse',
    'CustomNCrossValidationsResponse',
    'CustomSeasonalityResponse',
    'CustomServiceResponse',
    'CustomTargetLagsResponse',
    'CustomTargetRollingWindowSizeResponse',
    'DataCollectorResponse',
    'DataContainerResponse',
    'DataDriftMonitoringSignalResponse',
    'DataFactoryResponse',
    'DataLakeAnalyticsResponse',
    'DataLakeAnalyticsSchemaResponseProperties',
    'DataPathAssetReferenceResponse',
    'DataQualityMonitoringSignalResponse',
    'DatabricksPropertiesResponse',
    'DatabricksResponse',
    'DatasetResponse',
    'DatasetResponseDataPath',
    'DatasetResponseLatest',
    'DatasetResponseSqlDataPath',
    'DatasetStateResponse',
    'DatasetStateResponseDeprecatedBy',
    'DatastoreResponse',
    'DefaultScaleSettingsResponse',
    'DeltaModelCurrentStateResponse',
    'DeploymentResourceConfigurationResponse',
    'DockerBuildResponse',
    'DockerImagePlatformResponse',
    'DockerImageResponse',
    'DockerResponse',
    'EncryptionKeyVaultPropertiesResponse',
    'EncryptionPropertyResponse',
    'EndpointDeploymentModelResponse',
    'EndpointModelDeprecationPropertiesResponse',
    'EndpointModelPropertiesResponse',
    'EndpointModelSkuCapacityPropertiesResponse',
    'EndpointModelSkuPropertiesResponse',
    'EndpointModelSkuRateLimitPropertiesResponse',
    'EndpointModelSkuRateLimitRulePatternPropertiesResponse',
    'EndpointModelSkuRateLimitRulePropertiesResponse',
    'EndpointResponse',
    'EndpointScheduleActionResponse',
    'EnvironmentContainerResponse',
    'EnvironmentSpecificationVersionResponse',
    'EnvironmentVariableResponse',
    'EnvironmentVersionResponse',
    'ErrorAdditionalInfoResponse',
    'ErrorDetailResponse',
    'ErrorResponseResponse',
    'EstimatedVMPriceResponse',
    'EstimatedVMPricesResponse',
    'FeatureAttributionDriftMonitoringSignalResponse',
    'FeatureAttributionMetricThresholdResponse',
    'FeatureImportanceSettingsResponse',
    'FeatureResponse',
    'FeatureStoreSettingsResponse',
    'FeatureSubsetResponse',
    'FeatureWindowResponse',
    'FeaturesetContainerResponse',
    'FeaturesetJobResponse',
    'FeaturesetSpecificationResponse',
    'FeaturesetVersionResponse',
    'FeaturestoreEntityContainerResponse',
    'FeaturestoreEntityVersionResponse',
    'FixedInputDataResponse',
    'FlavorDataResponse',
    'ForecastingResponse',
    'ForecastingSettingsResponse',
    'ForecastingTrainingSettingsResponse',
    'FqdnOutboundRuleResponse',
    'GlusterFsSectionResponse',
    'GridSamplingAlgorithmResponse',
    'GroupEnvironmentConfigurationResponse',
    'GroupModelConfigurationResponse',
    'HDInsightPropertiesResponse',
    'HDInsightResponse',
    'IdAssetReferenceResponse',
    'IdentityForCmkResponse',
    'IdentityResponse',
    'ImageClassificationMultilabelResponse',
    'ImageClassificationResponse',
    'ImageInstanceSegmentationResponse',
    'ImageLimitSettingsResponse',
    'ImageMetadataResponse',
    'ImageModelDistributionSettingsClassificationResponse',
    'ImageModelDistributionSettingsObjectDetectionResponse',
    'ImageModelSettingsClassificationResponse',
    'ImageModelSettingsObjectDetectionResponse',
    'ImageObjectDetectionResponse',
    'ImageResponse',
    'ImageSweepSettingsResponse',
    'IndexColumnResponse',
    'InferenceContainerPropertiesResponse',
    'InferenceEndpointResponse',
    'InferenceGroupResponse',
    'InferencePoolResponse',
    'InstanceTypeSchemaResponse',
    'InstanceTypeSchemaResponseResources',
    'JobResourceConfigurationResponse',
    'JobScheduleActionResponse',
    'JobServiceResponse',
    'KubernetesOnlineDeploymentResponse',
    'KubernetesPropertiesResponse',
    'KubernetesResponse',
    'LabelCategoryResponse',
    'LabelClassResponse',
    'LabelingDataConfigurationResponse',
    'LabelingJobImagePropertiesResponse',
    'LabelingJobInstructionsResponse',
    'LabelingJobResponse',
    'LabelingJobTextPropertiesResponse',
    'LakeHouseArtifactResponse',
    'LinkedInfoResponse',
    'LinkedServicePropsResponse',
    'LinkedWorkspacePropsResponse',
    'ListNotebookKeysResultResponse',
    'LiteralJobInputResponse',
    'MLAssistConfigurationDisabledResponse',
    'MLAssistConfigurationEnabledResponse',
    'MLFlowModelJobInputResponse',
    'MLFlowModelJobOutputResponse',
    'MLTableDataResponse',
    'MLTableJobInputResponse',
    'MLTableJobOutputResponse',
    'ManagedComputeIdentityResponse',
    'ManagedIdentityAuthTypeWorkspaceConnectionPropertiesResponse',
    'ManagedIdentityResponse',
    'ManagedNetworkProvisionStatusResponse',
    'ManagedNetworkSettingsResponse',
    'ManagedOnlineDeploymentResponse',
    'ManagedOnlineEndpointDeploymentResourcePropertiesResponse',
    'ManagedServiceIdentityResponse',
    'MarketplacePlanResponse',
    'MarketplaceSubscriptionResponse',
    'MaterializationComputeResourceResponse',
    'MaterializationSettingsResponse',
    'MedianStoppingPolicyResponse',
    'ModelContainerResponse',
    'ModelSettingsResponse',
    'ModelVersionResponse',
    'MonitorDefinitionResponse',
    'MonitorEmailNotificationSettingsResponse',
    'MonitorNotificationSettingsResponse',
    'MonitorServerlessSparkComputeResponse',
    'MonitoringTargetResponse',
    'MonitoringThresholdResponse',
    'MpiResponse',
    'NlpVerticalFeaturizationSettingsResponse',
    'NlpVerticalLimitSettingsResponse',
    'NodeStateCountsResponse',
    'NoneAuthTypeWorkspaceConnectionPropertiesResponse',
    'NoneDatastoreCredentialsResponse',
    'NotebookPreparationErrorResponse',
    'NotebookResourceInfoResponse',
    'NotificationSettingResponse',
    'NumericalDataDriftMetricThresholdResponse',
    'NumericalDataQualityMetricThresholdResponse',
    'NumericalPredictionDriftMetricThresholdResponse',
    'OAuth2AuthTypeWorkspaceConnectionPropertiesResponse',
    'ObjectiveResponse',
    'OneLakeDatastoreResponse',
    'OnlineEndpointResponse',
    'OnlineRequestSettingsResponse',
    'OpenAIEndpointDeploymentResourcePropertiesResponse',
    'OutputPathAssetReferenceResponse',
    'PATAuthTypeWorkspaceConnectionPropertiesResponse',
    'PasswordResponse',
    'PersonalComputeInstanceSettingsResponse',
    'PipelineJobResponse',
    'PredictionDriftMonitoringSignalResponse',
    'PrivateEndpointConnectionResponse',
    'PrivateEndpointDestinationResponse',
    'PrivateEndpointOutboundRuleResponse',
    'PrivateEndpointResourceResponse',
    'PrivateEndpointResponse',
    'PrivateLinkServiceConnectionStateResponse',
    'ProbeSettingsResponse',
    'ProgressMetricsResponse',
    'PyTorchResponse',
    'QueueSettingsResponse',
    'RaiBlocklistConfigResponse',
    'RaiBlocklistItemPropertiesResponse',
    'RaiBlocklistPropertiesResponse',
    'RaiPolicyContentFilterResponse',
    'RaiPolicyPropertiesResponse',
    'RandomSamplingAlgorithmResponse',
    'RecurrenceResponse',
    'RecurrenceScheduleResponse',
    'RecurrenceTriggerResponse',
    'RegistryListCredentialsResultResponse',
    'RegistryPrivateEndpointConnectionPropertiesResponse',
    'RegistryPrivateEndpointConnectionResponse',
    'RegistryPrivateLinkServiceConnectionStateResponse',
    'RegistryRegionArmDetailsResponse',
    'RegistryResponse',
    'RegressionResponse',
    'RegressionTrainingSettingsResponse',
    'RequestConfigurationResponse',
    'RequestLoggingResponse',
    'ResourceIdResponse',
    'RollingInputDataResponse',
    'RouteResponse',
    'SASAuthTypeWorkspaceConnectionPropertiesResponse',
    'SasDatastoreCredentialsResponse',
    'ScaleSettingsResponse',
    'ScaleUnitConfigurationResponse',
    'ScheduleBaseResponse',
    'ScheduleResponse',
    'ScriptReferenceResponse',
    'ScriptsToExecuteResponse',
    'SecretConfigurationResponse',
    'ServerlessComputeSettingsResponse',
    'ServerlessEndpointResponse',
    'ServerlessInferenceEndpointResponse',
    'ServerlessOfferResponse',
    'ServiceManagedResourcesSettingsResponse',
    'ServicePrincipalAuthTypeWorkspaceConnectionPropertiesResponse',
    'ServicePrincipalDatastoreCredentialsResponse',
    'ServiceTagDestinationResponse',
    'ServiceTagOutboundRuleResponse',
    'SetupScriptsResponse',
    'SharedPrivateLinkResourceResponse',
    'SkuResponse',
    'SparkJobPythonEntryResponse',
    'SparkJobResponse',
    'SparkJobScalaEntryResponse',
    'SparkResourceConfigurationResponse',
    'SpeechEndpointDeploymentResourcePropertiesResponse',
    'SslConfigurationResponse',
    'StackEnsembleSettingsResponse',
    'StaticInputDataResponse',
    'StatusMessageResponse',
    'StorageAccountDetailsResponse',
    'StringStringKeyValuePairResponse',
    'SweepJobLimitsResponse',
    'SweepJobResponse',
    'SynapseSparkResponse',
    'SynapseSparkResponseProperties',
    'SystemCreatedAcrAccountResponse',
    'SystemCreatedStorageAccountResponse',
    'SystemDataResponse',
    'SystemServiceResponse',
    'TableVerticalFeaturizationSettingsResponse',
    'TableVerticalLimitSettingsResponse',
    'TargetUtilizationScaleSettingsResponse',
    'TensorFlowResponse',
    'TextClassificationMultilabelResponse',
    'TextClassificationResponse',
    'TextNerResponse',
    'TmpfsOptionsResponse',
    'TopNFeaturesByAttributionResponse',
    'TrialComponentResponse',
    'TritonModelJobInputResponse',
    'TritonModelJobOutputResponse',
    'TruncationSelectionPolicyResponse',
    'UriFileDataVersionResponse',
    'UriFileJobInputResponse',
    'UriFileJobOutputResponse',
    'UriFolderDataVersionResponse',
    'UriFolderJobInputResponse',
    'UriFolderJobOutputResponse',
    'UserAccountCredentialsResponse',
    'UserAssignedIdentityResponse',
    'UserIdentityResponse',
    'UserInfoResponse',
    'UsernamePasswordAuthTypeWorkspaceConnectionPropertiesResponse',
    'VirtualMachineImageResponse',
    'VirtualMachineResponse',
    'VirtualMachineSchemaResponseProperties',
    'VirtualMachineSizeResponse',
    'VirtualMachineSshCredentialsResponse',
    'VolumeDefinitionResponse',
    'VolumeOptionsResponse',
    'WorkspaceConnectionAccessKeyResponse',
    'WorkspaceConnectionAccountKeyResponse',
    'WorkspaceConnectionApiKeyResponse',
    'WorkspaceConnectionManagedIdentityResponse',
    'WorkspaceConnectionOAuth2Response',
    'WorkspaceConnectionPersonalAccessTokenResponse',
    'WorkspaceConnectionServicePrincipalResponse',
    'WorkspaceConnectionSharedAccessSignatureResponse',
    'WorkspaceConnectionUsernamePasswordResponse',
    'WorkspaceHubConfigResponse',
]

@pulumi.output_type
class AADAuthTypeWorkspaceConnectionPropertiesResponse(dict):
    """
    This connection type covers the AAD auth for any applicable Azure service
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "createdByWorkspaceArmId":
            suggest = "created_by_workspace_arm_id"
        elif key == "expiryTime":
            suggest = "expiry_time"
        elif key == "isSharedToAll":
            suggest = "is_shared_to_all"
        elif key == "sharedUserList":
            suggest = "shared_user_list"
        elif key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AADAuthTypeWorkspaceConnectionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AADAuthTypeWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AADAuthTypeWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: builtins.str,
                 created_by_workspace_arm_id: builtins.str,
                 group: builtins.str,
                 category: Optional[builtins.str] = None,
                 expiry_time: Optional[builtins.str] = None,
                 is_shared_to_all: Optional[builtins.bool] = None,
                 metadata: Optional[Mapping[str, builtins.str]] = None,
                 shared_user_list: Optional[Sequence[builtins.str]] = None,
                 target: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None,
                 value_format: Optional[builtins.str] = None):
        """
        This connection type covers the AAD auth for any applicable Azure service
        :param builtins.str auth_type: Authentication type of the connection target
               Expected value is 'AAD'.
        :param builtins.str group: Group based on connection category
        :param builtins.str category: Category of the connection
        :param Mapping[str, builtins.str] metadata: Store user metadata for this connection
        :param builtins.str value: Value details of the workspace connection.
        :param builtins.str value_format: format for the workspace connection value
        """
        pulumi.set(__self__, "auth_type", 'AAD')
        pulumi.set(__self__, "created_by_workspace_arm_id", created_by_workspace_arm_id)
        pulumi.set(__self__, "group", group)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if expiry_time is not None:
            pulumi.set(__self__, "expiry_time", expiry_time)
        if is_shared_to_all is not None:
            pulumi.set(__self__, "is_shared_to_all", is_shared_to_all)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if shared_user_list is not None:
            pulumi.set(__self__, "shared_user_list", shared_user_list)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> builtins.str:
        """
        Authentication type of the connection target
        Expected value is 'AAD'.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="createdByWorkspaceArmId")
    def created_by_workspace_arm_id(self) -> builtins.str:
        return pulumi.get(self, "created_by_workspace_arm_id")

    @property
    @pulumi.getter
    def group(self) -> builtins.str:
        """
        Group based on connection category
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def category(self) -> Optional[builtins.str]:
        """
        Category of the connection
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="expiryTime")
    def expiry_time(self) -> Optional[builtins.str]:
        return pulumi.get(self, "expiry_time")

    @property
    @pulumi.getter(name="isSharedToAll")
    def is_shared_to_all(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_shared_to_all")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Store user metadata for this connection
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="sharedUserList")
    def shared_user_list(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "shared_user_list")

    @property
    @pulumi.getter
    def target(self) -> Optional[builtins.str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value details of the workspace connection.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[builtins.str]:
        """
        format for the workspace connection value
        """
        return pulumi.get(self, "value_format")


@pulumi.output_type
class AKSResponse(dict):
    """
    A Machine Learning compute based on AKS.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeType":
            suggest = "compute_type"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "isAttachedCompute":
            suggest = "is_attached_compute"
        elif key == "modifiedOn":
            suggest = "modified_on"
        elif key == "provisioningErrors":
            suggest = "provisioning_errors"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "computeLocation":
            suggest = "compute_location"
        elif key == "disableLocalAuth":
            suggest = "disable_local_auth"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AKSResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AKSResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AKSResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_type: builtins.str,
                 created_on: builtins.str,
                 is_attached_compute: builtins.bool,
                 modified_on: builtins.str,
                 provisioning_errors: Sequence['outputs.ErrorResponseResponse'],
                 provisioning_state: builtins.str,
                 compute_location: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 disable_local_auth: Optional[builtins.bool] = None,
                 properties: Optional['outputs.AKSSchemaResponseProperties'] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        A Machine Learning compute based on AKS.
        :param builtins.str compute_type: The type of compute
               Expected value is 'AKS'.
        :param builtins.str created_on: The time at which the compute was created.
        :param builtins.bool is_attached_compute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        :param builtins.str modified_on: The time at which the compute was last modified.
        :param Sequence['ErrorResponseResponse'] provisioning_errors: Errors during provisioning
        :param builtins.str provisioning_state: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        :param builtins.str compute_location: Location for the underlying compute
        :param builtins.str description: The description of the Machine Learning compute.
        :param builtins.bool disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        :param 'AKSSchemaResponseProperties' properties: AKS properties
        :param builtins.str resource_id: ARM resource id of the underlying compute
        """
        pulumi.set(__self__, "compute_type", 'AKS')
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "is_attached_compute", is_attached_compute)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "provisioning_errors", provisioning_errors)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if compute_location is not None:
            pulumi.set(__self__, "compute_location", compute_location)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_local_auth is not None:
            pulumi.set(__self__, "disable_local_auth", disable_local_auth)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> builtins.str:
        """
        The type of compute
        Expected value is 'AKS'.
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> builtins.str:
        """
        The time at which the compute was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="isAttachedCompute")
    def is_attached_compute(self) -> builtins.bool:
        """
        Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        """
        return pulumi.get(self, "is_attached_compute")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> builtins.str:
        """
        The time at which the compute was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="provisioningErrors")
    def provisioning_errors(self) -> Sequence['outputs.ErrorResponseResponse']:
        """
        Errors during provisioning
        """
        return pulumi.get(self, "provisioning_errors")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[builtins.str]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[builtins.bool]:
        """
        Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        """
        return pulumi.get(self, "disable_local_auth")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.AKSSchemaResponseProperties']:
        """
        AKS properties
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class AKSSchemaResponseProperties(dict):
    """
    AKS properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemServices":
            suggest = "system_services"
        elif key == "agentCount":
            suggest = "agent_count"
        elif key == "agentVmSize":
            suggest = "agent_vm_size"
        elif key == "aksNetworkingConfiguration":
            suggest = "aks_networking_configuration"
        elif key == "clusterFqdn":
            suggest = "cluster_fqdn"
        elif key == "clusterPurpose":
            suggest = "cluster_purpose"
        elif key == "loadBalancerSubnet":
            suggest = "load_balancer_subnet"
        elif key == "loadBalancerType":
            suggest = "load_balancer_type"
        elif key == "sslConfiguration":
            suggest = "ssl_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AKSSchemaResponseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AKSSchemaResponseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AKSSchemaResponseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 system_services: Sequence['outputs.SystemServiceResponse'],
                 agent_count: Optional[builtins.int] = None,
                 agent_vm_size: Optional[builtins.str] = None,
                 aks_networking_configuration: Optional['outputs.AksNetworkingConfigurationResponse'] = None,
                 cluster_fqdn: Optional[builtins.str] = None,
                 cluster_purpose: Optional[builtins.str] = None,
                 load_balancer_subnet: Optional[builtins.str] = None,
                 load_balancer_type: Optional[builtins.str] = None,
                 ssl_configuration: Optional['outputs.SslConfigurationResponse'] = None):
        """
        AKS properties
        :param Sequence['SystemServiceResponse'] system_services: System services
        :param builtins.int agent_count: Number of agents
        :param builtins.str agent_vm_size: Agent virtual machine size
        :param 'AksNetworkingConfigurationResponse' aks_networking_configuration: AKS networking configuration for vnet
        :param builtins.str cluster_fqdn: Cluster full qualified domain name
        :param builtins.str cluster_purpose: Intended usage of the cluster
        :param builtins.str load_balancer_subnet: Load Balancer Subnet
        :param builtins.str load_balancer_type: Load Balancer Type
        :param 'SslConfigurationResponse' ssl_configuration: SSL configuration
        """
        pulumi.set(__self__, "system_services", system_services)
        if agent_count is not None:
            pulumi.set(__self__, "agent_count", agent_count)
        if agent_vm_size is not None:
            pulumi.set(__self__, "agent_vm_size", agent_vm_size)
        if aks_networking_configuration is not None:
            pulumi.set(__self__, "aks_networking_configuration", aks_networking_configuration)
        if cluster_fqdn is not None:
            pulumi.set(__self__, "cluster_fqdn", cluster_fqdn)
        if cluster_purpose is None:
            cluster_purpose = 'FastProd'
        if cluster_purpose is not None:
            pulumi.set(__self__, "cluster_purpose", cluster_purpose)
        if load_balancer_subnet is not None:
            pulumi.set(__self__, "load_balancer_subnet", load_balancer_subnet)
        if load_balancer_type is None:
            load_balancer_type = 'PublicIp'
        if load_balancer_type is not None:
            pulumi.set(__self__, "load_balancer_type", load_balancer_type)
        if ssl_configuration is not None:
            pulumi.set(__self__, "ssl_configuration", ssl_configuration)

    @property
    @pulumi.getter(name="systemServices")
    def system_services(self) -> Sequence['outputs.SystemServiceResponse']:
        """
        System services
        """
        return pulumi.get(self, "system_services")

    @property
    @pulumi.getter(name="agentCount")
    def agent_count(self) -> Optional[builtins.int]:
        """
        Number of agents
        """
        return pulumi.get(self, "agent_count")

    @property
    @pulumi.getter(name="agentVmSize")
    def agent_vm_size(self) -> Optional[builtins.str]:
        """
        Agent virtual machine size
        """
        return pulumi.get(self, "agent_vm_size")

    @property
    @pulumi.getter(name="aksNetworkingConfiguration")
    def aks_networking_configuration(self) -> Optional['outputs.AksNetworkingConfigurationResponse']:
        """
        AKS networking configuration for vnet
        """
        return pulumi.get(self, "aks_networking_configuration")

    @property
    @pulumi.getter(name="clusterFqdn")
    def cluster_fqdn(self) -> Optional[builtins.str]:
        """
        Cluster full qualified domain name
        """
        return pulumi.get(self, "cluster_fqdn")

    @property
    @pulumi.getter(name="clusterPurpose")
    def cluster_purpose(self) -> Optional[builtins.str]:
        """
        Intended usage of the cluster
        """
        return pulumi.get(self, "cluster_purpose")

    @property
    @pulumi.getter(name="loadBalancerSubnet")
    def load_balancer_subnet(self) -> Optional[builtins.str]:
        """
        Load Balancer Subnet
        """
        return pulumi.get(self, "load_balancer_subnet")

    @property
    @pulumi.getter(name="loadBalancerType")
    def load_balancer_type(self) -> Optional[builtins.str]:
        """
        Load Balancer Type
        """
        return pulumi.get(self, "load_balancer_type")

    @property
    @pulumi.getter(name="sslConfiguration")
    def ssl_configuration(self) -> Optional['outputs.SslConfigurationResponse']:
        """
        SSL configuration
        """
        return pulumi.get(self, "ssl_configuration")


@pulumi.output_type
class AccessKeyAuthTypeWorkspaceConnectionPropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "createdByWorkspaceArmId":
            suggest = "created_by_workspace_arm_id"
        elif key == "expiryTime":
            suggest = "expiry_time"
        elif key == "isSharedToAll":
            suggest = "is_shared_to_all"
        elif key == "sharedUserList":
            suggest = "shared_user_list"
        elif key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessKeyAuthTypeWorkspaceConnectionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessKeyAuthTypeWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessKeyAuthTypeWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: builtins.str,
                 created_by_workspace_arm_id: builtins.str,
                 group: builtins.str,
                 category: Optional[builtins.str] = None,
                 credentials: Optional['outputs.WorkspaceConnectionAccessKeyResponse'] = None,
                 expiry_time: Optional[builtins.str] = None,
                 is_shared_to_all: Optional[builtins.bool] = None,
                 metadata: Optional[Mapping[str, builtins.str]] = None,
                 shared_user_list: Optional[Sequence[builtins.str]] = None,
                 target: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None,
                 value_format: Optional[builtins.str] = None):
        """
        :param builtins.str auth_type: Authentication type of the connection target
               Expected value is 'AccessKey'.
        :param builtins.str group: Group based on connection category
        :param builtins.str category: Category of the connection
        :param Mapping[str, builtins.str] metadata: Store user metadata for this connection
        :param builtins.str value: Value details of the workspace connection.
        :param builtins.str value_format: format for the workspace connection value
        """
        pulumi.set(__self__, "auth_type", 'AccessKey')
        pulumi.set(__self__, "created_by_workspace_arm_id", created_by_workspace_arm_id)
        pulumi.set(__self__, "group", group)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if expiry_time is not None:
            pulumi.set(__self__, "expiry_time", expiry_time)
        if is_shared_to_all is not None:
            pulumi.set(__self__, "is_shared_to_all", is_shared_to_all)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if shared_user_list is not None:
            pulumi.set(__self__, "shared_user_list", shared_user_list)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> builtins.str:
        """
        Authentication type of the connection target
        Expected value is 'AccessKey'.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="createdByWorkspaceArmId")
    def created_by_workspace_arm_id(self) -> builtins.str:
        return pulumi.get(self, "created_by_workspace_arm_id")

    @property
    @pulumi.getter
    def group(self) -> builtins.str:
        """
        Group based on connection category
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def category(self) -> Optional[builtins.str]:
        """
        Category of the connection
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.WorkspaceConnectionAccessKeyResponse']:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="expiryTime")
    def expiry_time(self) -> Optional[builtins.str]:
        return pulumi.get(self, "expiry_time")

    @property
    @pulumi.getter(name="isSharedToAll")
    def is_shared_to_all(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_shared_to_all")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Store user metadata for this connection
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="sharedUserList")
    def shared_user_list(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "shared_user_list")

    @property
    @pulumi.getter
    def target(self) -> Optional[builtins.str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value details of the workspace connection.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[builtins.str]:
        """
        format for the workspace connection value
        """
        return pulumi.get(self, "value_format")


@pulumi.output_type
class AccountApiKeysResponse(dict):
    def __init__(__self__, *,
                 key1: Optional[builtins.str] = None,
                 key2: Optional[builtins.str] = None):
        if key1 is not None:
            pulumi.set(__self__, "key1", key1)
        if key2 is not None:
            pulumi.set(__self__, "key2", key2)

    @property
    @pulumi.getter
    def key1(self) -> Optional[builtins.str]:
        return pulumi.get(self, "key1")

    @property
    @pulumi.getter
    def key2(self) -> Optional[builtins.str]:
        return pulumi.get(self, "key2")


@pulumi.output_type
class AccountKeyAuthTypeWorkspaceConnectionPropertiesResponse(dict):
    """
    This connection type covers the account key connection for Azure storage
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "createdByWorkspaceArmId":
            suggest = "created_by_workspace_arm_id"
        elif key == "expiryTime":
            suggest = "expiry_time"
        elif key == "isSharedToAll":
            suggest = "is_shared_to_all"
        elif key == "sharedUserList":
            suggest = "shared_user_list"
        elif key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountKeyAuthTypeWorkspaceConnectionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountKeyAuthTypeWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountKeyAuthTypeWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: builtins.str,
                 created_by_workspace_arm_id: builtins.str,
                 group: builtins.str,
                 category: Optional[builtins.str] = None,
                 credentials: Optional['outputs.WorkspaceConnectionAccountKeyResponse'] = None,
                 expiry_time: Optional[builtins.str] = None,
                 is_shared_to_all: Optional[builtins.bool] = None,
                 metadata: Optional[Mapping[str, builtins.str]] = None,
                 shared_user_list: Optional[Sequence[builtins.str]] = None,
                 target: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None,
                 value_format: Optional[builtins.str] = None):
        """
        This connection type covers the account key connection for Azure storage
        :param builtins.str auth_type: Authentication type of the connection target
               Expected value is 'AccountKey'.
        :param builtins.str group: Group based on connection category
        :param builtins.str category: Category of the connection
        :param Mapping[str, builtins.str] metadata: Store user metadata for this connection
        :param builtins.str value: Value details of the workspace connection.
        :param builtins.str value_format: format for the workspace connection value
        """
        pulumi.set(__self__, "auth_type", 'AccountKey')
        pulumi.set(__self__, "created_by_workspace_arm_id", created_by_workspace_arm_id)
        pulumi.set(__self__, "group", group)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if expiry_time is not None:
            pulumi.set(__self__, "expiry_time", expiry_time)
        if is_shared_to_all is not None:
            pulumi.set(__self__, "is_shared_to_all", is_shared_to_all)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if shared_user_list is not None:
            pulumi.set(__self__, "shared_user_list", shared_user_list)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> builtins.str:
        """
        Authentication type of the connection target
        Expected value is 'AccountKey'.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="createdByWorkspaceArmId")
    def created_by_workspace_arm_id(self) -> builtins.str:
        return pulumi.get(self, "created_by_workspace_arm_id")

    @property
    @pulumi.getter
    def group(self) -> builtins.str:
        """
        Group based on connection category
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def category(self) -> Optional[builtins.str]:
        """
        Category of the connection
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.WorkspaceConnectionAccountKeyResponse']:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="expiryTime")
    def expiry_time(self) -> Optional[builtins.str]:
        return pulumi.get(self, "expiry_time")

    @property
    @pulumi.getter(name="isSharedToAll")
    def is_shared_to_all(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_shared_to_all")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Store user metadata for this connection
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="sharedUserList")
    def shared_user_list(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "shared_user_list")

    @property
    @pulumi.getter
    def target(self) -> Optional[builtins.str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value details of the workspace connection.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[builtins.str]:
        """
        format for the workspace connection value
        """
        return pulumi.get(self, "value_format")


@pulumi.output_type
class AccountKeyDatastoreCredentialsResponse(dict):
    """
    Account key datastore credentials configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsType":
            suggest = "credentials_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountKeyDatastoreCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountKeyDatastoreCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountKeyDatastoreCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_type: builtins.str):
        """
        Account key datastore credentials configuration.
        :param builtins.str credentials_type: Enum to determine the datastore credentials type.
               Expected value is 'AccountKey'.
        """
        pulumi.set(__self__, "credentials_type", 'AccountKey')

    @property
    @pulumi.getter(name="credentialsType")
    def credentials_type(self) -> builtins.str:
        """
        Enum to determine the datastore credentials type.
        Expected value is 'AccountKey'.
        """
        return pulumi.get(self, "credentials_type")


@pulumi.output_type
class AcrDetailsResponse(dict):
    """
    Details of ACR account to be used for the Registry
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemCreatedAcrAccount":
            suggest = "system_created_acr_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AcrDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AcrDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AcrDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 system_created_acr_account: Optional['outputs.SystemCreatedAcrAccountResponse'] = None):
        """
        Details of ACR account to be used for the Registry
        :param 'SystemCreatedAcrAccountResponse' system_created_acr_account: Details of system created ACR account to be used for the Registry
        """
        if system_created_acr_account is not None:
            pulumi.set(__self__, "system_created_acr_account", system_created_acr_account)

    @property
    @pulumi.getter(name="systemCreatedAcrAccount")
    def system_created_acr_account(self) -> Optional['outputs.SystemCreatedAcrAccountResponse']:
        """
        Details of system created ACR account to be used for the Registry
        """
        return pulumi.get(self, "system_created_acr_account")


@pulumi.output_type
class ActualCapacityInfoResponse(dict):
    def __init__(__self__, *,
                 failed: Optional[builtins.int] = None,
                 outdated_failed: Optional[builtins.int] = None,
                 outdated_succeeded: Optional[builtins.int] = None,
                 succeeded: Optional[builtins.int] = None,
                 total: Optional[builtins.int] = None):
        """
        :param builtins.int failed: Gets or sets the number of instances (scale units) which have Failed provisioning state and have target group payload.
        :param builtins.int outdated_failed: Gets or sets the number of instances (scale units) which have Failed provisioning state but do not have target group payload.
        :param builtins.int outdated_succeeded: Gets or sets the number of instances (scale units) which have Succeeded provisioning state but do not have target group payload.
        :param builtins.int succeeded: Gets or sets the number of instances (scale units) which have Succeeded provisioning state and target group payload.
        :param builtins.int total: Gets or sets the total number of instances (scale units) regardless of provisioning state or whether current group payload version matches the target group payload.
        """
        if failed is None:
            failed = 0
        if failed is not None:
            pulumi.set(__self__, "failed", failed)
        if outdated_failed is None:
            outdated_failed = 0
        if outdated_failed is not None:
            pulumi.set(__self__, "outdated_failed", outdated_failed)
        if outdated_succeeded is None:
            outdated_succeeded = 0
        if outdated_succeeded is not None:
            pulumi.set(__self__, "outdated_succeeded", outdated_succeeded)
        if succeeded is None:
            succeeded = 0
        if succeeded is not None:
            pulumi.set(__self__, "succeeded", succeeded)
        if total is None:
            total = 0
        if total is not None:
            pulumi.set(__self__, "total", total)

    @property
    @pulumi.getter
    def failed(self) -> Optional[builtins.int]:
        """
        Gets or sets the number of instances (scale units) which have Failed provisioning state and have target group payload.
        """
        return pulumi.get(self, "failed")

    @property
    @pulumi.getter(name="outdatedFailed")
    def outdated_failed(self) -> Optional[builtins.int]:
        """
        Gets or sets the number of instances (scale units) which have Failed provisioning state but do not have target group payload.
        """
        return pulumi.get(self, "outdated_failed")

    @property
    @pulumi.getter(name="outdatedSucceeded")
    def outdated_succeeded(self) -> Optional[builtins.int]:
        """
        Gets or sets the number of instances (scale units) which have Succeeded provisioning state but do not have target group payload.
        """
        return pulumi.get(self, "outdated_succeeded")

    @property
    @pulumi.getter
    def succeeded(self) -> Optional[builtins.int]:
        """
        Gets or sets the number of instances (scale units) which have Succeeded provisioning state and target group payload.
        """
        return pulumi.get(self, "succeeded")

    @property
    @pulumi.getter
    def total(self) -> Optional[builtins.int]:
        """
        Gets or sets the total number of instances (scale units) regardless of provisioning state or whether current group payload version matches the target group payload.
        """
        return pulumi.get(self, "total")


@pulumi.output_type
class AksNetworkingConfigurationResponse(dict):
    """
    Advance configuration for AKS networking
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServiceIP":
            suggest = "dns_service_ip"
        elif key == "dockerBridgeCidr":
            suggest = "docker_bridge_cidr"
        elif key == "serviceCidr":
            suggest = "service_cidr"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AksNetworkingConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AksNetworkingConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AksNetworkingConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_service_ip: Optional[builtins.str] = None,
                 docker_bridge_cidr: Optional[builtins.str] = None,
                 service_cidr: Optional[builtins.str] = None,
                 subnet_id: Optional[builtins.str] = None):
        """
        Advance configuration for AKS networking
        :param builtins.str dns_service_ip: An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range specified in serviceCidr.
        :param builtins.str docker_bridge_cidr: A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes service address range.
        :param builtins.str service_cidr: A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP ranges.
        :param builtins.str subnet_id: Virtual network subnet resource ID the compute nodes belong to
        """
        if dns_service_ip is not None:
            pulumi.set(__self__, "dns_service_ip", dns_service_ip)
        if docker_bridge_cidr is not None:
            pulumi.set(__self__, "docker_bridge_cidr", docker_bridge_cidr)
        if service_cidr is not None:
            pulumi.set(__self__, "service_cidr", service_cidr)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="dnsServiceIP")
    def dns_service_ip(self) -> Optional[builtins.str]:
        """
        An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range specified in serviceCidr.
        """
        return pulumi.get(self, "dns_service_ip")

    @property
    @pulumi.getter(name="dockerBridgeCidr")
    def docker_bridge_cidr(self) -> Optional[builtins.str]:
        """
        A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes service address range.
        """
        return pulumi.get(self, "docker_bridge_cidr")

    @property
    @pulumi.getter(name="serviceCidr")
    def service_cidr(self) -> Optional[builtins.str]:
        """
        A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP ranges.
        """
        return pulumi.get(self, "service_cidr")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[builtins.str]:
        """
        Virtual network subnet resource ID the compute nodes belong to
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class AllFeaturesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AllFeaturesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AllFeaturesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AllFeaturesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str):
        """
        :param builtins.str filter_type: 
               Expected value is 'AllFeatures'.
        """
        pulumi.set(__self__, "filter_type", 'AllFeatures')

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        """

        Expected value is 'AllFeatures'.
        """
        return pulumi.get(self, "filter_type")


@pulumi.output_type
class AllNodesResponse(dict):
    """
    All nodes means the service will be running on all of the nodes of the job
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodesValueType":
            suggest = "nodes_value_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AllNodesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AllNodesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AllNodesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nodes_value_type: builtins.str):
        """
        All nodes means the service will be running on all of the nodes of the job
        :param builtins.str nodes_value_type: The enumerated types for the nodes value
               Expected value is 'All'.
        """
        pulumi.set(__self__, "nodes_value_type", 'All')

    @property
    @pulumi.getter(name="nodesValueType")
    def nodes_value_type(self) -> builtins.str:
        """
        The enumerated types for the nodes value
        Expected value is 'All'.
        """
        return pulumi.get(self, "nodes_value_type")


@pulumi.output_type
class AmlComputeNodeInformationResponse(dict):
    """
    Compute node information related to a AmlCompute.
    """
    def __init__(__self__, *,
                 node_id: builtins.str,
                 node_state: builtins.str,
                 port: builtins.float,
                 private_ip_address: builtins.str,
                 public_ip_address: builtins.str,
                 run_id: builtins.str):
        """
        Compute node information related to a AmlCompute.
        :param builtins.str node_id: ID of the compute node.
        :param builtins.str node_state: State of the compute node. Values are idle, running, preparing, unusable, leaving and preempted.
        :param builtins.float port: SSH port number of the node.
        :param builtins.str private_ip_address: Private IP address of the compute node.
        :param builtins.str public_ip_address: Public IP address of the compute node.
        :param builtins.str run_id: ID of the Experiment running on the node, if any else null.
        """
        pulumi.set(__self__, "node_id", node_id)
        pulumi.set(__self__, "node_state", node_state)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        pulumi.set(__self__, "public_ip_address", public_ip_address)
        pulumi.set(__self__, "run_id", run_id)

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> builtins.str:
        """
        ID of the compute node.
        """
        return pulumi.get(self, "node_id")

    @property
    @pulumi.getter(name="nodeState")
    def node_state(self) -> builtins.str:
        """
        State of the compute node. Values are idle, running, preparing, unusable, leaving and preempted.
        """
        return pulumi.get(self, "node_state")

    @property
    @pulumi.getter
    def port(self) -> builtins.float:
        """
        SSH port number of the node.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> builtins.str:
        """
        Private IP address of the compute node.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> builtins.str:
        """
        Public IP address of the compute node.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter(name="runId")
    def run_id(self) -> builtins.str:
        """
        ID of the Experiment running on the node, if any else null.
        """
        return pulumi.get(self, "run_id")


@pulumi.output_type
class AmlComputePropertiesResponse(dict):
    """
    AML Compute properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationState":
            suggest = "allocation_state"
        elif key == "allocationStateTransitionTime":
            suggest = "allocation_state_transition_time"
        elif key == "currentNodeCount":
            suggest = "current_node_count"
        elif key == "nodeStateCounts":
            suggest = "node_state_counts"
        elif key == "targetNodeCount":
            suggest = "target_node_count"
        elif key == "enableNodePublicIp":
            suggest = "enable_node_public_ip"
        elif key == "isolatedNetwork":
            suggest = "isolated_network"
        elif key == "osType":
            suggest = "os_type"
        elif key == "propertyBag":
            suggest = "property_bag"
        elif key == "remoteLoginPortPublicAccess":
            suggest = "remote_login_port_public_access"
        elif key == "scaleSettings":
            suggest = "scale_settings"
        elif key == "userAccountCredentials":
            suggest = "user_account_credentials"
        elif key == "virtualMachineImage":
            suggest = "virtual_machine_image"
        elif key == "vmPriority":
            suggest = "vm_priority"
        elif key == "vmSize":
            suggest = "vm_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmlComputePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmlComputePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmlComputePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_state: builtins.str,
                 allocation_state_transition_time: builtins.str,
                 current_node_count: builtins.int,
                 errors: Sequence['outputs.ErrorResponseResponse'],
                 node_state_counts: 'outputs.NodeStateCountsResponse',
                 target_node_count: builtins.int,
                 enable_node_public_ip: Optional[builtins.bool] = None,
                 isolated_network: Optional[builtins.bool] = None,
                 os_type: Optional[builtins.str] = None,
                 property_bag: Optional[Any] = None,
                 remote_login_port_public_access: Optional[builtins.str] = None,
                 scale_settings: Optional['outputs.ScaleSettingsResponse'] = None,
                 subnet: Optional['outputs.ResourceIdResponse'] = None,
                 user_account_credentials: Optional['outputs.UserAccountCredentialsResponse'] = None,
                 virtual_machine_image: Optional['outputs.VirtualMachineImageResponse'] = None,
                 vm_priority: Optional[builtins.str] = None,
                 vm_size: Optional[builtins.str] = None):
        """
        AML Compute properties
        :param builtins.str allocation_state: Allocation state of the compute. Possible values are: steady - Indicates that the compute is not resizing. There are no changes to the number of compute nodes in the compute in progress. A compute enters this state when it is created and when no operations are being performed on the compute to change the number of compute nodes. resizing - Indicates that the compute is resizing; that is, compute nodes are being added to or removed from the compute.
        :param builtins.str allocation_state_transition_time: The time at which the compute entered its current allocation state.
        :param builtins.int current_node_count: The number of compute nodes currently assigned to the compute.
        :param Sequence['ErrorResponseResponse'] errors: Collection of errors encountered by various compute nodes during node setup.
        :param 'NodeStateCountsResponse' node_state_counts: Counts of various node states on the compute.
        :param builtins.int target_node_count: The target number of compute nodes for the compute. If the allocationState is resizing, this property denotes the target node count for the ongoing resize operation. If the allocationState is steady, this property denotes the target node count for the previous resize operation.
        :param builtins.bool enable_node_public_ip: Enable or disable node public IP address provisioning. Possible values are: Possible values are: true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will have a private endpoint and no public IPs.
        :param builtins.bool isolated_network: Network is isolated or not
        :param builtins.str os_type: Compute OS Type
        :param Any property_bag: A property bag containing additional properties.
        :param builtins.str remote_login_port_public_access: State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on all nodes of the cluster. Enabled - Indicates that the public ssh port is open on all nodes of the cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined, else is open all public nodes. It can be default only during cluster creation time, after creation it will be either enabled or disabled.
        :param 'ScaleSettingsResponse' scale_settings: Scale settings for AML Compute
        :param 'ResourceIdResponse' subnet: Virtual network subnet resource ID the compute nodes belong to.
        :param 'UserAccountCredentialsResponse' user_account_credentials: Credentials for an administrator user account that will be created on each compute node.
        :param 'VirtualMachineImageResponse' virtual_machine_image: Virtual Machine image for AML Compute - windows only
        :param builtins.str vm_priority: Virtual Machine priority
        :param builtins.str vm_size: Virtual Machine Size
        """
        pulumi.set(__self__, "allocation_state", allocation_state)
        pulumi.set(__self__, "allocation_state_transition_time", allocation_state_transition_time)
        pulumi.set(__self__, "current_node_count", current_node_count)
        pulumi.set(__self__, "errors", errors)
        pulumi.set(__self__, "node_state_counts", node_state_counts)
        pulumi.set(__self__, "target_node_count", target_node_count)
        if enable_node_public_ip is None:
            enable_node_public_ip = True
        if enable_node_public_ip is not None:
            pulumi.set(__self__, "enable_node_public_ip", enable_node_public_ip)
        if isolated_network is not None:
            pulumi.set(__self__, "isolated_network", isolated_network)
        if os_type is None:
            os_type = 'Linux'
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)
        if property_bag is not None:
            pulumi.set(__self__, "property_bag", property_bag)
        if remote_login_port_public_access is None:
            remote_login_port_public_access = 'NotSpecified'
        if remote_login_port_public_access is not None:
            pulumi.set(__self__, "remote_login_port_public_access", remote_login_port_public_access)
        if scale_settings is not None:
            pulumi.set(__self__, "scale_settings", scale_settings)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if user_account_credentials is not None:
            pulumi.set(__self__, "user_account_credentials", user_account_credentials)
        if virtual_machine_image is not None:
            pulumi.set(__self__, "virtual_machine_image", virtual_machine_image)
        if vm_priority is not None:
            pulumi.set(__self__, "vm_priority", vm_priority)
        if vm_size is not None:
            pulumi.set(__self__, "vm_size", vm_size)

    @property
    @pulumi.getter(name="allocationState")
    def allocation_state(self) -> builtins.str:
        """
        Allocation state of the compute. Possible values are: steady - Indicates that the compute is not resizing. There are no changes to the number of compute nodes in the compute in progress. A compute enters this state when it is created and when no operations are being performed on the compute to change the number of compute nodes. resizing - Indicates that the compute is resizing; that is, compute nodes are being added to or removed from the compute.
        """
        return pulumi.get(self, "allocation_state")

    @property
    @pulumi.getter(name="allocationStateTransitionTime")
    def allocation_state_transition_time(self) -> builtins.str:
        """
        The time at which the compute entered its current allocation state.
        """
        return pulumi.get(self, "allocation_state_transition_time")

    @property
    @pulumi.getter(name="currentNodeCount")
    def current_node_count(self) -> builtins.int:
        """
        The number of compute nodes currently assigned to the compute.
        """
        return pulumi.get(self, "current_node_count")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ErrorResponseResponse']:
        """
        Collection of errors encountered by various compute nodes during node setup.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter(name="nodeStateCounts")
    def node_state_counts(self) -> 'outputs.NodeStateCountsResponse':
        """
        Counts of various node states on the compute.
        """
        return pulumi.get(self, "node_state_counts")

    @property
    @pulumi.getter(name="targetNodeCount")
    def target_node_count(self) -> builtins.int:
        """
        The target number of compute nodes for the compute. If the allocationState is resizing, this property denotes the target node count for the ongoing resize operation. If the allocationState is steady, this property denotes the target node count for the previous resize operation.
        """
        return pulumi.get(self, "target_node_count")

    @property
    @pulumi.getter(name="enableNodePublicIp")
    def enable_node_public_ip(self) -> Optional[builtins.bool]:
        """
        Enable or disable node public IP address provisioning. Possible values are: Possible values are: true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will have a private endpoint and no public IPs.
        """
        return pulumi.get(self, "enable_node_public_ip")

    @property
    @pulumi.getter(name="isolatedNetwork")
    def isolated_network(self) -> Optional[builtins.bool]:
        """
        Network is isolated or not
        """
        return pulumi.get(self, "isolated_network")

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[builtins.str]:
        """
        Compute OS Type
        """
        return pulumi.get(self, "os_type")

    @property
    @pulumi.getter(name="propertyBag")
    def property_bag(self) -> Optional[Any]:
        """
        A property bag containing additional properties.
        """
        return pulumi.get(self, "property_bag")

    @property
    @pulumi.getter(name="remoteLoginPortPublicAccess")
    def remote_login_port_public_access(self) -> Optional[builtins.str]:
        """
        State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on all nodes of the cluster. Enabled - Indicates that the public ssh port is open on all nodes of the cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined, else is open all public nodes. It can be default only during cluster creation time, after creation it will be either enabled or disabled.
        """
        return pulumi.get(self, "remote_login_port_public_access")

    @property
    @pulumi.getter(name="scaleSettings")
    def scale_settings(self) -> Optional['outputs.ScaleSettingsResponse']:
        """
        Scale settings for AML Compute
        """
        return pulumi.get(self, "scale_settings")

    @property
    @pulumi.getter
    def subnet(self) -> Optional['outputs.ResourceIdResponse']:
        """
        Virtual network subnet resource ID the compute nodes belong to.
        """
        return pulumi.get(self, "subnet")

    @property
    @pulumi.getter(name="userAccountCredentials")
    def user_account_credentials(self) -> Optional['outputs.UserAccountCredentialsResponse']:
        """
        Credentials for an administrator user account that will be created on each compute node.
        """
        return pulumi.get(self, "user_account_credentials")

    @property
    @pulumi.getter(name="virtualMachineImage")
    def virtual_machine_image(self) -> Optional['outputs.VirtualMachineImageResponse']:
        """
        Virtual Machine image for AML Compute - windows only
        """
        return pulumi.get(self, "virtual_machine_image")

    @property
    @pulumi.getter(name="vmPriority")
    def vm_priority(self) -> Optional[builtins.str]:
        """
        Virtual Machine priority
        """
        return pulumi.get(self, "vm_priority")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> Optional[builtins.str]:
        """
        Virtual Machine Size
        """
        return pulumi.get(self, "vm_size")


@pulumi.output_type
class AmlComputeResponse(dict):
    """
    An Azure Machine Learning compute.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeType":
            suggest = "compute_type"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "isAttachedCompute":
            suggest = "is_attached_compute"
        elif key == "modifiedOn":
            suggest = "modified_on"
        elif key == "provisioningErrors":
            suggest = "provisioning_errors"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "computeLocation":
            suggest = "compute_location"
        elif key == "disableLocalAuth":
            suggest = "disable_local_auth"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmlComputeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmlComputeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmlComputeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_type: builtins.str,
                 created_on: builtins.str,
                 is_attached_compute: builtins.bool,
                 modified_on: builtins.str,
                 provisioning_errors: Sequence['outputs.ErrorResponseResponse'],
                 provisioning_state: builtins.str,
                 compute_location: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 disable_local_auth: Optional[builtins.bool] = None,
                 properties: Optional['outputs.AmlComputePropertiesResponse'] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        An Azure Machine Learning compute.
        :param builtins.str compute_type: The type of compute
               Expected value is 'AmlCompute'.
        :param builtins.str created_on: The time at which the compute was created.
        :param builtins.bool is_attached_compute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        :param builtins.str modified_on: The time at which the compute was last modified.
        :param Sequence['ErrorResponseResponse'] provisioning_errors: Errors during provisioning
        :param builtins.str provisioning_state: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        :param builtins.str compute_location: Location for the underlying compute
        :param builtins.str description: The description of the Machine Learning compute.
        :param builtins.bool disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        :param 'AmlComputePropertiesResponse' properties: Properties of AmlCompute
        :param builtins.str resource_id: ARM resource id of the underlying compute
        """
        pulumi.set(__self__, "compute_type", 'AmlCompute')
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "is_attached_compute", is_attached_compute)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "provisioning_errors", provisioning_errors)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if compute_location is not None:
            pulumi.set(__self__, "compute_location", compute_location)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_local_auth is not None:
            pulumi.set(__self__, "disable_local_auth", disable_local_auth)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> builtins.str:
        """
        The type of compute
        Expected value is 'AmlCompute'.
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> builtins.str:
        """
        The time at which the compute was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="isAttachedCompute")
    def is_attached_compute(self) -> builtins.bool:
        """
        Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        """
        return pulumi.get(self, "is_attached_compute")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> builtins.str:
        """
        The time at which the compute was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="provisioningErrors")
    def provisioning_errors(self) -> Sequence['outputs.ErrorResponseResponse']:
        """
        Errors during provisioning
        """
        return pulumi.get(self, "provisioning_errors")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[builtins.str]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[builtins.bool]:
        """
        Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        """
        return pulumi.get(self, "disable_local_auth")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.AmlComputePropertiesResponse']:
        """
        Properties of AmlCompute
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class AmlTokenComputeIdentityResponse(dict):
    """
    AML token compute identity definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeIdentityType":
            suggest = "compute_identity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmlTokenComputeIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmlTokenComputeIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmlTokenComputeIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_identity_type: builtins.str):
        """
        AML token compute identity definition.
        :param builtins.str compute_identity_type: Monitor compute identity type enum.
               Expected value is 'AmlToken'.
        """
        pulumi.set(__self__, "compute_identity_type", 'AmlToken')

    @property
    @pulumi.getter(name="computeIdentityType")
    def compute_identity_type(self) -> builtins.str:
        """
        Monitor compute identity type enum.
        Expected value is 'AmlToken'.
        """
        return pulumi.get(self, "compute_identity_type")


@pulumi.output_type
class AmlTokenResponse(dict):
    """
    AML Token identity configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityType":
            suggest = "identity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmlTokenResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmlTokenResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmlTokenResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_type: builtins.str):
        """
        AML Token identity configuration.
        :param builtins.str identity_type: Enum to determine identity framework.
               Expected value is 'AMLToken'.
        """
        pulumi.set(__self__, "identity_type", 'AMLToken')

    @property
    @pulumi.getter(name="identityType")
    def identity_type(self) -> builtins.str:
        """
        Enum to determine identity framework.
        Expected value is 'AMLToken'.
        """
        return pulumi.get(self, "identity_type")


@pulumi.output_type
class ApiKeyAuthWorkspaceConnectionPropertiesResponse(dict):
    """
    This connection type covers the generic ApiKey auth connection categories, for examples:
    AzureOpenAI:
        Category:= AzureOpenAI
        AuthType:= ApiKey (as type discriminator)
        Credentials:= {ApiKey} as Microsoft.MachineLearning.AccountRP.Contracts.WorkspaceConnection.ApiKey
        Target:= {ApiBase}
                
    CognitiveService:
        Category:= CognitiveService
        AuthType:= ApiKey (as type discriminator)
        Credentials:= {SubscriptionKey} as Microsoft.MachineLearning.AccountRP.Contracts.WorkspaceConnection.ApiKey
        Target:= ServiceRegion={serviceRegion}
                
    CognitiveSearch:
        Category:= CognitiveSearch
        AuthType:= ApiKey (as type discriminator)
        Credentials:= {Key} as Microsoft.MachineLearning.AccountRP.Contracts.WorkspaceConnection.ApiKey
        Target:= {Endpoint}
                
    Use Metadata property bag for ApiType, ApiVersion, Kind and other metadata fields
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "createdByWorkspaceArmId":
            suggest = "created_by_workspace_arm_id"
        elif key == "expiryTime":
            suggest = "expiry_time"
        elif key == "isSharedToAll":
            suggest = "is_shared_to_all"
        elif key == "sharedUserList":
            suggest = "shared_user_list"
        elif key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiKeyAuthWorkspaceConnectionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiKeyAuthWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiKeyAuthWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: builtins.str,
                 created_by_workspace_arm_id: builtins.str,
                 group: builtins.str,
                 category: Optional[builtins.str] = None,
                 credentials: Optional['outputs.WorkspaceConnectionApiKeyResponse'] = None,
                 expiry_time: Optional[builtins.str] = None,
                 is_shared_to_all: Optional[builtins.bool] = None,
                 metadata: Optional[Mapping[str, builtins.str]] = None,
                 shared_user_list: Optional[Sequence[builtins.str]] = None,
                 target: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None,
                 value_format: Optional[builtins.str] = None):
        """
        This connection type covers the generic ApiKey auth connection categories, for examples:
        AzureOpenAI:
            Category:= AzureOpenAI
            AuthType:= ApiKey (as type discriminator)
            Credentials:= {ApiKey} as Microsoft.MachineLearning.AccountRP.Contracts.WorkspaceConnection.ApiKey
            Target:= {ApiBase}
                    
        CognitiveService:
            Category:= CognitiveService
            AuthType:= ApiKey (as type discriminator)
            Credentials:= {SubscriptionKey} as Microsoft.MachineLearning.AccountRP.Contracts.WorkspaceConnection.ApiKey
            Target:= ServiceRegion={serviceRegion}
                    
        CognitiveSearch:
            Category:= CognitiveSearch
            AuthType:= ApiKey (as type discriminator)
            Credentials:= {Key} as Microsoft.MachineLearning.AccountRP.Contracts.WorkspaceConnection.ApiKey
            Target:= {Endpoint}
                    
        Use Metadata property bag for ApiType, ApiVersion, Kind and other metadata fields
        :param builtins.str auth_type: Authentication type of the connection target
               Expected value is 'ApiKey'.
        :param builtins.str group: Group based on connection category
        :param builtins.str category: Category of the connection
        :param 'WorkspaceConnectionApiKeyResponse' credentials: Api key object for workspace connection credential.
        :param Mapping[str, builtins.str] metadata: Store user metadata for this connection
        :param builtins.str value: Value details of the workspace connection.
        :param builtins.str value_format: format for the workspace connection value
        """
        pulumi.set(__self__, "auth_type", 'ApiKey')
        pulumi.set(__self__, "created_by_workspace_arm_id", created_by_workspace_arm_id)
        pulumi.set(__self__, "group", group)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if expiry_time is not None:
            pulumi.set(__self__, "expiry_time", expiry_time)
        if is_shared_to_all is not None:
            pulumi.set(__self__, "is_shared_to_all", is_shared_to_all)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if shared_user_list is not None:
            pulumi.set(__self__, "shared_user_list", shared_user_list)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> builtins.str:
        """
        Authentication type of the connection target
        Expected value is 'ApiKey'.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="createdByWorkspaceArmId")
    def created_by_workspace_arm_id(self) -> builtins.str:
        return pulumi.get(self, "created_by_workspace_arm_id")

    @property
    @pulumi.getter
    def group(self) -> builtins.str:
        """
        Group based on connection category
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def category(self) -> Optional[builtins.str]:
        """
        Category of the connection
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.WorkspaceConnectionApiKeyResponse']:
        """
        Api key object for workspace connection credential.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="expiryTime")
    def expiry_time(self) -> Optional[builtins.str]:
        return pulumi.get(self, "expiry_time")

    @property
    @pulumi.getter(name="isSharedToAll")
    def is_shared_to_all(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_shared_to_all")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Store user metadata for this connection
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="sharedUserList")
    def shared_user_list(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "shared_user_list")

    @property
    @pulumi.getter
    def target(self) -> Optional[builtins.str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value details of the workspace connection.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[builtins.str]:
        """
        format for the workspace connection value
        """
        return pulumi.get(self, "value_format")


@pulumi.output_type
class ArmResourceIdResponse(dict):
    """
    ARM ResourceId of a resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArmResourceIdResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArmResourceIdResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArmResourceIdResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: Optional[builtins.str] = None):
        """
        ARM ResourceId of a resource
        :param builtins.str resource_id: Arm ResourceId is in the format "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Storage/storageAccounts/{StorageAccountName}"
               or "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{AcrName}"
        """
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        Arm ResourceId is in the format "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Storage/storageAccounts/{StorageAccountName}"
        or "/subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{AcrName}"
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class AssignedUserResponse(dict):
    """
    A user that can be assigned to a compute instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectId":
            suggest = "object_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssignedUserResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssignedUserResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssignedUserResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_id: builtins.str,
                 tenant_id: builtins.str):
        """
        A user that can be assigned to a compute instance.
        :param builtins.str object_id: Users AAD Object Id.
        :param builtins.str tenant_id: Users AAD Tenant Id.
        """
        pulumi.set(__self__, "object_id", object_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> builtins.str:
        """
        Users AAD Object Id.
        """
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> builtins.str:
        """
        Users AAD Tenant Id.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class AutoForecastHorizonResponse(dict):
    """
    Forecast horizon determined automatically by system.
    """
    def __init__(__self__, *,
                 mode: builtins.str):
        """
        Forecast horizon determined automatically by system.
        :param builtins.str mode: Enum to determine forecast horizon selection mode.
               Expected value is 'Auto'.
        """
        pulumi.set(__self__, "mode", 'Auto')

    @property
    @pulumi.getter
    def mode(self) -> builtins.str:
        """
        Enum to determine forecast horizon selection mode.
        Expected value is 'Auto'.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class AutoMLJobResponse(dict):
    """
    AutoMLJob class.
    Use this class for executing AutoML tasks like Classification/Regression etc.
    See TaskType enum for all the tasks supported.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobType":
            suggest = "job_type"
        elif key == "taskDetails":
            suggest = "task_details"
        elif key == "componentId":
            suggest = "component_id"
        elif key == "computeId":
            suggest = "compute_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "environmentId":
            suggest = "environment_id"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "experimentName":
            suggest = "experiment_name"
        elif key == "isArchived":
            suggest = "is_archived"
        elif key == "notificationSetting":
            suggest = "notification_setting"
        elif key == "queueSettings":
            suggest = "queue_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoMLJobResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoMLJobResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoMLJobResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_type: builtins.str,
                 status: builtins.str,
                 task_details: Any,
                 component_id: Optional[builtins.str] = None,
                 compute_id: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 display_name: Optional[builtins.str] = None,
                 environment_id: Optional[builtins.str] = None,
                 environment_variables: Optional[Mapping[str, builtins.str]] = None,
                 experiment_name: Optional[builtins.str] = None,
                 identity: Optional[Any] = None,
                 is_archived: Optional[builtins.bool] = None,
                 notification_setting: Optional['outputs.NotificationSettingResponse'] = None,
                 outputs: Optional[Mapping[str, Any]] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 queue_settings: Optional['outputs.QueueSettingsResponse'] = None,
                 resources: Optional['outputs.JobResourceConfigurationResponse'] = None,
                 services: Optional[Mapping[str, 'outputs.JobServiceResponse']] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        AutoMLJob class.
        Use this class for executing AutoML tasks like Classification/Regression etc.
        See TaskType enum for all the tasks supported.
        :param builtins.str job_type: Enum to determine the type of job.
               Expected value is 'AutoML'.
        :param builtins.str status: Status of the job.
        :param Union['ClassificationResponse', 'ForecastingResponse', 'ImageClassificationResponse', 'ImageClassificationMultilabelResponse', 'ImageInstanceSegmentationResponse', 'ImageObjectDetectionResponse', 'RegressionResponse', 'TextClassificationResponse', 'TextClassificationMultilabelResponse', 'TextNerResponse'] task_details: [Required] This represents scenario which can be one of Tables/NLP/Image
        :param builtins.str component_id: ARM resource ID of the component resource.
        :param builtins.str compute_id: ARM resource ID of the compute resource.
        :param builtins.str description: The asset description text.
        :param builtins.str display_name: Display name of job.
        :param builtins.str environment_id: The ARM resource ID of the Environment specification for the job.
               This is optional value to provide, if not provided, AutoML will default this to Production AutoML curated environment version when running the job.
        :param Mapping[str, builtins.str] environment_variables: Environment variables included in the job.
        :param builtins.str experiment_name: The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        :param Union['AmlTokenResponse', 'ManagedIdentityResponse', 'UserIdentityResponse'] identity: Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
               Defaults to AmlToken if null.
        :param builtins.bool is_archived: Is the asset archived?
        :param 'NotificationSettingResponse' notification_setting: Notification setting for the job
        :param Mapping[str, Union['CustomModelJobOutputResponse', 'MLFlowModelJobOutputResponse', 'MLTableJobOutputResponse', 'TritonModelJobOutputResponse', 'UriFileJobOutputResponse', 'UriFolderJobOutputResponse']] outputs: Mapping of output data bindings used in the job.
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param 'QueueSettingsResponse' queue_settings: Queue settings for the job
        :param 'JobResourceConfigurationResponse' resources: Compute Resource configuration for the job.
        :param Mapping[str, 'JobServiceResponse'] services: List of JobEndpoints.
               For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "job_type", 'AutoML')
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "task_details", task_details)
        if component_id is not None:
            pulumi.set(__self__, "component_id", component_id)
        if compute_id is not None:
            pulumi.set(__self__, "compute_id", compute_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if experiment_name is None:
            experiment_name = 'Default'
        if experiment_name is not None:
            pulumi.set(__self__, "experiment_name", experiment_name)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if notification_setting is not None:
            pulumi.set(__self__, "notification_setting", notification_setting)
        if outputs is not None:
            pulumi.set(__self__, "outputs", outputs)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if queue_settings is not None:
            pulumi.set(__self__, "queue_settings", queue_settings)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="jobType")
    def job_type(self) -> builtins.str:
        """
        Enum to determine the type of job.
        Expected value is 'AutoML'.
        """
        return pulumi.get(self, "job_type")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Status of the job.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="taskDetails")
    def task_details(self) -> Any:
        """
        [Required] This represents scenario which can be one of Tables/NLP/Image
        """
        return pulumi.get(self, "task_details")

    @property
    @pulumi.getter(name="componentId")
    def component_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of the component resource.
        """
        return pulumi.get(self, "component_id")

    @property
    @pulumi.getter(name="computeId")
    def compute_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of the compute resource.
        """
        return pulumi.get(self, "compute_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        Display name of job.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[builtins.str]:
        """
        The ARM resource ID of the Environment specification for the job.
        This is optional value to provide, if not provided, AutoML will default this to Production AutoML curated environment version when running the job.
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Environment variables included in the job.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="experimentName")
    def experiment_name(self) -> Optional[builtins.str]:
        """
        The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        """
        return pulumi.get(self, "experiment_name")

    @property
    @pulumi.getter
    def identity(self) -> Optional[Any]:
        """
        Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
        Defaults to AmlToken if null.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter(name="notificationSetting")
    def notification_setting(self) -> Optional['outputs.NotificationSettingResponse']:
        """
        Notification setting for the job
        """
        return pulumi.get(self, "notification_setting")

    @property
    @pulumi.getter
    def outputs(self) -> Optional[Mapping[str, Any]]:
        """
        Mapping of output data bindings used in the job.
        """
        return pulumi.get(self, "outputs")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="queueSettings")
    def queue_settings(self) -> Optional['outputs.QueueSettingsResponse']:
        """
        Queue settings for the job
        """
        return pulumi.get(self, "queue_settings")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.JobResourceConfigurationResponse']:
        """
        Compute Resource configuration for the job.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def services(self) -> Optional[Mapping[str, 'outputs.JobServiceResponse']]:
        """
        List of JobEndpoints.
        For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AutoNCrossValidationsResponse(dict):
    """
    N-Cross validations determined automatically.
    """
    def __init__(__self__, *,
                 mode: builtins.str):
        """
        N-Cross validations determined automatically.
        :param builtins.str mode: Determines how N-Cross validations value is determined.
               Expected value is 'Auto'.
        """
        pulumi.set(__self__, "mode", 'Auto')

    @property
    @pulumi.getter
    def mode(self) -> builtins.str:
        """
        Determines how N-Cross validations value is determined.
        Expected value is 'Auto'.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class AutoPausePropertiesResponse(dict):
    """
    Auto pause properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayInMinutes":
            suggest = "delay_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoPausePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoPausePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoPausePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay_in_minutes: Optional[builtins.int] = None,
                 enabled: Optional[builtins.bool] = None):
        """
        Auto pause properties
        """
        if delay_in_minutes is not None:
            pulumi.set(__self__, "delay_in_minutes", delay_in_minutes)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="delayInMinutes")
    def delay_in_minutes(self) -> Optional[builtins.int]:
        return pulumi.get(self, "delay_in_minutes")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class AutoScalePropertiesResponse(dict):
    """
    Auto scale properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxNodeCount":
            suggest = "max_node_count"
        elif key == "minNodeCount":
            suggest = "min_node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 max_node_count: Optional[builtins.int] = None,
                 min_node_count: Optional[builtins.int] = None):
        """
        Auto scale properties
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_node_count is not None:
            pulumi.set(__self__, "max_node_count", max_node_count)
        if min_node_count is not None:
            pulumi.set(__self__, "min_node_count", min_node_count)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> Optional[builtins.int]:
        return pulumi.get(self, "max_node_count")

    @property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> Optional[builtins.int]:
        return pulumi.get(self, "min_node_count")


@pulumi.output_type
class AutoSeasonalityResponse(dict):
    def __init__(__self__, *,
                 mode: builtins.str):
        """
        :param builtins.str mode: Forecasting seasonality mode.
               Expected value is 'Auto'.
        """
        pulumi.set(__self__, "mode", 'Auto')

    @property
    @pulumi.getter
    def mode(self) -> builtins.str:
        """
        Forecasting seasonality mode.
        Expected value is 'Auto'.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class AutoTargetLagsResponse(dict):
    def __init__(__self__, *,
                 mode: builtins.str):
        """
        :param builtins.str mode: Target lags selection modes.
               Expected value is 'Auto'.
        """
        pulumi.set(__self__, "mode", 'Auto')

    @property
    @pulumi.getter
    def mode(self) -> builtins.str:
        """
        Target lags selection modes.
        Expected value is 'Auto'.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class AutoTargetRollingWindowSizeResponse(dict):
    """
    Target lags rolling window determined automatically.
    """
    def __init__(__self__, *,
                 mode: builtins.str):
        """
        Target lags rolling window determined automatically.
        :param builtins.str mode: Target rolling windows size mode.
               Expected value is 'Auto'.
        """
        pulumi.set(__self__, "mode", 'Auto')

    @property
    @pulumi.getter
    def mode(self) -> builtins.str:
        """
        Target rolling windows size mode.
        Expected value is 'Auto'.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class AzureBlobDatastoreResponse(dict):
    """
    Azure Blob datastore configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datastoreType":
            suggest = "datastore_type"
        elif key == "isDefault":
            suggest = "is_default"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "containerName":
            suggest = "container_name"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "serviceDataAccessAuthIdentity":
            suggest = "service_data_access_auth_identity"
        elif key == "subscriptionId":
            suggest = "subscription_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureBlobDatastoreResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureBlobDatastoreResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureBlobDatastoreResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: Any,
                 datastore_type: builtins.str,
                 is_default: builtins.bool,
                 account_name: Optional[builtins.str] = None,
                 container_name: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 endpoint: Optional[builtins.str] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 protocol: Optional[builtins.str] = None,
                 resource_group: Optional[builtins.str] = None,
                 service_data_access_auth_identity: Optional[builtins.str] = None,
                 subscription_id: Optional[builtins.str] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Azure Blob datastore configuration.
        :param Union['AccountKeyDatastoreCredentialsResponse', 'CertificateDatastoreCredentialsResponse', 'NoneDatastoreCredentialsResponse', 'SasDatastoreCredentialsResponse', 'ServicePrincipalDatastoreCredentialsResponse'] credentials: [Required] Account credentials.
        :param builtins.str datastore_type: Enum to determine the datastore contents type.
               Expected value is 'AzureBlob'.
        :param builtins.bool is_default: Readonly property to indicate if datastore is the workspace default datastore
        :param builtins.str account_name: Storage account name.
        :param builtins.str container_name: Storage account container name.
        :param builtins.str description: The asset description text.
        :param builtins.str endpoint: Azure cloud endpoint for the storage account.
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param builtins.str protocol: Protocol used to communicate with the storage account.
        :param builtins.str resource_group: Azure Resource Group name
        :param builtins.str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param builtins.str subscription_id: Azure Subscription Id
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "datastore_type", 'AzureBlob')
        pulumi.set(__self__, "is_default", is_default)
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if service_data_access_auth_identity is None:
            service_data_access_auth_identity = 'None'
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def credentials(self) -> Any:
        """
        [Required] Account credentials.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="datastoreType")
    def datastore_type(self) -> builtins.str:
        """
        Enum to determine the datastore contents type.
        Expected value is 'AzureBlob'.
        """
        return pulumi.get(self, "datastore_type")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> builtins.bool:
        """
        Readonly property to indicate if datastore is the workspace default datastore
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[builtins.str]:
        """
        Storage account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[builtins.str]:
        """
        Storage account container name.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[builtins.str]:
        """
        Azure cloud endpoint for the storage account.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[builtins.str]:
        """
        Protocol used to communicate with the storage account.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[builtins.str]:
        """
        Azure Resource Group name
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[builtins.str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[builtins.str]:
        """
        Azure Subscription Id
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AzureDataLakeGen1DatastoreResponse(dict):
    """
    Azure Data Lake Gen1 datastore configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datastoreType":
            suggest = "datastore_type"
        elif key == "isDefault":
            suggest = "is_default"
        elif key == "storeName":
            suggest = "store_name"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "serviceDataAccessAuthIdentity":
            suggest = "service_data_access_auth_identity"
        elif key == "subscriptionId":
            suggest = "subscription_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureDataLakeGen1DatastoreResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureDataLakeGen1DatastoreResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureDataLakeGen1DatastoreResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: Any,
                 datastore_type: builtins.str,
                 is_default: builtins.bool,
                 store_name: builtins.str,
                 description: Optional[builtins.str] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 resource_group: Optional[builtins.str] = None,
                 service_data_access_auth_identity: Optional[builtins.str] = None,
                 subscription_id: Optional[builtins.str] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Azure Data Lake Gen1 datastore configuration.
        :param Union['AccountKeyDatastoreCredentialsResponse', 'CertificateDatastoreCredentialsResponse', 'NoneDatastoreCredentialsResponse', 'SasDatastoreCredentialsResponse', 'ServicePrincipalDatastoreCredentialsResponse'] credentials: [Required] Account credentials.
        :param builtins.str datastore_type: Enum to determine the datastore contents type.
               Expected value is 'AzureDataLakeGen1'.
        :param builtins.bool is_default: Readonly property to indicate if datastore is the workspace default datastore
        :param builtins.str store_name: [Required] Azure Data Lake store name.
        :param builtins.str description: The asset description text.
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param builtins.str resource_group: Azure Resource Group name
        :param builtins.str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param builtins.str subscription_id: Azure Subscription Id
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "datastore_type", 'AzureDataLakeGen1')
        pulumi.set(__self__, "is_default", is_default)
        pulumi.set(__self__, "store_name", store_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if service_data_access_auth_identity is None:
            service_data_access_auth_identity = 'None'
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def credentials(self) -> Any:
        """
        [Required] Account credentials.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="datastoreType")
    def datastore_type(self) -> builtins.str:
        """
        Enum to determine the datastore contents type.
        Expected value is 'AzureDataLakeGen1'.
        """
        return pulumi.get(self, "datastore_type")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> builtins.bool:
        """
        Readonly property to indicate if datastore is the workspace default datastore
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> builtins.str:
        """
        [Required] Azure Data Lake store name.
        """
        return pulumi.get(self, "store_name")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[builtins.str]:
        """
        Azure Resource Group name
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[builtins.str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[builtins.str]:
        """
        Azure Subscription Id
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AzureDataLakeGen2DatastoreResponse(dict):
    """
    Azure Data Lake Gen2 datastore configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountName":
            suggest = "account_name"
        elif key == "datastoreType":
            suggest = "datastore_type"
        elif key == "isDefault":
            suggest = "is_default"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "serviceDataAccessAuthIdentity":
            suggest = "service_data_access_auth_identity"
        elif key == "subscriptionId":
            suggest = "subscription_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureDataLakeGen2DatastoreResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureDataLakeGen2DatastoreResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureDataLakeGen2DatastoreResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_name: builtins.str,
                 credentials: Any,
                 datastore_type: builtins.str,
                 filesystem: builtins.str,
                 is_default: builtins.bool,
                 description: Optional[builtins.str] = None,
                 endpoint: Optional[builtins.str] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 protocol: Optional[builtins.str] = None,
                 resource_group: Optional[builtins.str] = None,
                 service_data_access_auth_identity: Optional[builtins.str] = None,
                 subscription_id: Optional[builtins.str] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Azure Data Lake Gen2 datastore configuration.
        :param builtins.str account_name: [Required] Storage account name.
        :param Union['AccountKeyDatastoreCredentialsResponse', 'CertificateDatastoreCredentialsResponse', 'NoneDatastoreCredentialsResponse', 'SasDatastoreCredentialsResponse', 'ServicePrincipalDatastoreCredentialsResponse'] credentials: [Required] Account credentials.
        :param builtins.str datastore_type: Enum to determine the datastore contents type.
               Expected value is 'AzureDataLakeGen2'.
        :param builtins.str filesystem: [Required] The name of the Data Lake Gen2 filesystem.
        :param builtins.bool is_default: Readonly property to indicate if datastore is the workspace default datastore
        :param builtins.str description: The asset description text.
        :param builtins.str endpoint: Azure cloud endpoint for the storage account.
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param builtins.str protocol: Protocol used to communicate with the storage account.
        :param builtins.str resource_group: Azure Resource Group name
        :param builtins.str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param builtins.str subscription_id: Azure Subscription Id
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "datastore_type", 'AzureDataLakeGen2')
        pulumi.set(__self__, "filesystem", filesystem)
        pulumi.set(__self__, "is_default", is_default)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if service_data_access_auth_identity is None:
            service_data_access_auth_identity = 'None'
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> builtins.str:
        """
        [Required] Storage account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def credentials(self) -> Any:
        """
        [Required] Account credentials.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="datastoreType")
    def datastore_type(self) -> builtins.str:
        """
        Enum to determine the datastore contents type.
        Expected value is 'AzureDataLakeGen2'.
        """
        return pulumi.get(self, "datastore_type")

    @property
    @pulumi.getter
    def filesystem(self) -> builtins.str:
        """
        [Required] The name of the Data Lake Gen2 filesystem.
        """
        return pulumi.get(self, "filesystem")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> builtins.bool:
        """
        Readonly property to indicate if datastore is the workspace default datastore
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[builtins.str]:
        """
        Azure cloud endpoint for the storage account.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[builtins.str]:
        """
        Protocol used to communicate with the storage account.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[builtins.str]:
        """
        Azure Resource Group name
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[builtins.str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[builtins.str]:
        """
        Azure Subscription Id
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AzureDataLakeSectionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorityUrl":
            suggest = "authority_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "credentialType":
            suggest = "credential_type"
        elif key == "isCertAuth":
            suggest = "is_cert_auth"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "resourceUri":
            suggest = "resource_uri"
        elif key == "serviceDataAccessAuthIdentity":
            suggest = "service_data_access_auth_identity"
        elif key == "storeName":
            suggest = "store_name"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureDataLakeSectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureDataLakeSectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureDataLakeSectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authority_url: Optional[builtins.str] = None,
                 certificate: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 credential_type: Optional[builtins.str] = None,
                 is_cert_auth: Optional[builtins.bool] = None,
                 resource_group: Optional[builtins.str] = None,
                 resource_uri: Optional[builtins.str] = None,
                 service_data_access_auth_identity: Optional[builtins.str] = None,
                 store_name: Optional[builtins.str] = None,
                 subscription_id: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None,
                 thumbprint: Optional[builtins.str] = None):
        """
        :param builtins.str authority_url: The authority URL used for authentication.
        :param builtins.str certificate: The content of the certificate used for authentication.
        :param builtins.str client_id: The Client ID/Application ID
        :param builtins.str client_secret: The client secret.
        :param builtins.str credential_type: The Azure Data Lake credential type.
        :param builtins.bool is_cert_auth:  Is it using certificate to authenticate. If false then use client secret.
        :param builtins.str resource_group: Resource Group.
        :param builtins.str resource_uri: The resource the service principal/app has access to.
        :param builtins.str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param builtins.str store_name: The Azure Data Lake store name.
        :param builtins.str subscription_id: Subscription ID.
        :param builtins.str tenant_id: The ID of the tenant the service principal/app belongs to.
        :param builtins.str thumbprint: The thumbprint of the certificate above.
        """
        if authority_url is not None:
            pulumi.set(__self__, "authority_url", authority_url)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if is_cert_auth is not None:
            pulumi.set(__self__, "is_cert_auth", is_cert_auth)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if resource_uri is not None:
            pulumi.set(__self__, "resource_uri", resource_uri)
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if store_name is not None:
            pulumi.set(__self__, "store_name", store_name)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)

    @property
    @pulumi.getter(name="authorityUrl")
    def authority_url(self) -> Optional[builtins.str]:
        """
        The authority URL used for authentication.
        """
        return pulumi.get(self, "authority_url")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[builtins.str]:
        """
        The content of the certificate used for authentication.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        The Client ID/Application ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[builtins.str]:
        """
        The Azure Data Lake credential type.
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter(name="isCertAuth")
    def is_cert_auth(self) -> Optional[builtins.bool]:
        """
         Is it using certificate to authenticate. If false then use client secret.
        """
        return pulumi.get(self, "is_cert_auth")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[builtins.str]:
        """
        Resource Group.
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[builtins.str]:
        """
        The resource the service principal/app has access to.
        """
        return pulumi.get(self, "resource_uri")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[builtins.str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> Optional[builtins.str]:
        """
        The Azure Data Lake store name.
        """
        return pulumi.get(self, "store_name")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[builtins.str]:
        """
        Subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        """
        The ID of the tenant the service principal/app belongs to.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[builtins.str]:
        """
        The thumbprint of the certificate above.
        """
        return pulumi.get(self, "thumbprint")


@pulumi.output_type
class AzureDevOpsWebhookResponse(dict):
    """
    Webhook details specific for Azure DevOps
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "webhookType":
            suggest = "webhook_type"
        elif key == "eventType":
            suggest = "event_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureDevOpsWebhookResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureDevOpsWebhookResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureDevOpsWebhookResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 webhook_type: builtins.str,
                 event_type: Optional[builtins.str] = None):
        """
        Webhook details specific for Azure DevOps
        :param builtins.str webhook_type: Enum to determine the webhook callback service type.
               Expected value is 'AzureDevOps'.
        :param builtins.str event_type: Send callback on a specified notification event
        """
        pulumi.set(__self__, "webhook_type", 'AzureDevOps')
        if event_type is not None:
            pulumi.set(__self__, "event_type", event_type)

    @property
    @pulumi.getter(name="webhookType")
    def webhook_type(self) -> builtins.str:
        """
        Enum to determine the webhook callback service type.
        Expected value is 'AzureDevOps'.
        """
        return pulumi.get(self, "webhook_type")

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> Optional[builtins.str]:
        """
        Send callback on a specified notification event
        """
        return pulumi.get(self, "event_type")


@pulumi.output_type
class AzureFileDatastoreResponse(dict):
    """
    Azure File datastore configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountName":
            suggest = "account_name"
        elif key == "datastoreType":
            suggest = "datastore_type"
        elif key == "fileShareName":
            suggest = "file_share_name"
        elif key == "isDefault":
            suggest = "is_default"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "serviceDataAccessAuthIdentity":
            suggest = "service_data_access_auth_identity"
        elif key == "subscriptionId":
            suggest = "subscription_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureFileDatastoreResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureFileDatastoreResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureFileDatastoreResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_name: builtins.str,
                 credentials: Any,
                 datastore_type: builtins.str,
                 file_share_name: builtins.str,
                 is_default: builtins.bool,
                 description: Optional[builtins.str] = None,
                 endpoint: Optional[builtins.str] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 protocol: Optional[builtins.str] = None,
                 resource_group: Optional[builtins.str] = None,
                 service_data_access_auth_identity: Optional[builtins.str] = None,
                 subscription_id: Optional[builtins.str] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Azure File datastore configuration.
        :param builtins.str account_name: [Required] Storage account name.
        :param Union['AccountKeyDatastoreCredentialsResponse', 'CertificateDatastoreCredentialsResponse', 'NoneDatastoreCredentialsResponse', 'SasDatastoreCredentialsResponse', 'ServicePrincipalDatastoreCredentialsResponse'] credentials: [Required] Account credentials.
        :param builtins.str datastore_type: Enum to determine the datastore contents type.
               Expected value is 'AzureFile'.
        :param builtins.str file_share_name: [Required] The name of the Azure file share that the datastore points to.
        :param builtins.bool is_default: Readonly property to indicate if datastore is the workspace default datastore
        :param builtins.str description: The asset description text.
        :param builtins.str endpoint: Azure cloud endpoint for the storage account.
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param builtins.str protocol: Protocol used to communicate with the storage account.
        :param builtins.str resource_group: Azure Resource Group name
        :param builtins.str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param builtins.str subscription_id: Azure Subscription Id
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "datastore_type", 'AzureFile')
        pulumi.set(__self__, "file_share_name", file_share_name)
        pulumi.set(__self__, "is_default", is_default)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if service_data_access_auth_identity is None:
            service_data_access_auth_identity = 'None'
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> builtins.str:
        """
        [Required] Storage account name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def credentials(self) -> Any:
        """
        [Required] Account credentials.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="datastoreType")
    def datastore_type(self) -> builtins.str:
        """
        Enum to determine the datastore contents type.
        Expected value is 'AzureFile'.
        """
        return pulumi.get(self, "datastore_type")

    @property
    @pulumi.getter(name="fileShareName")
    def file_share_name(self) -> builtins.str:
        """
        [Required] The name of the Azure file share that the datastore points to.
        """
        return pulumi.get(self, "file_share_name")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> builtins.bool:
        """
        Readonly property to indicate if datastore is the workspace default datastore
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[builtins.str]:
        """
        Azure cloud endpoint for the storage account.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[builtins.str]:
        """
        Protocol used to communicate with the storage account.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[builtins.str]:
        """
        Azure Resource Group name
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[builtins.str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[builtins.str]:
        """
        Azure Subscription Id
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AzureMySqlSectionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorityUrl":
            suggest = "authority_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "credentialType":
            suggest = "credential_type"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "isCertAuth":
            suggest = "is_cert_auth"
        elif key == "portNumber":
            suggest = "port_number"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "resourceUri":
            suggest = "resource_uri"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "serviceDataAccessAuthIdentity":
            suggest = "service_data_access_auth_identity"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userId":
            suggest = "user_id"
        elif key == "userPassword":
            suggest = "user_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureMySqlSectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureMySqlSectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureMySqlSectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authority_url: Optional[builtins.str] = None,
                 certificate: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 credential_type: Optional[builtins.str] = None,
                 database_name: Optional[builtins.str] = None,
                 endpoint: Optional[builtins.str] = None,
                 is_cert_auth: Optional[builtins.bool] = None,
                 port_number: Optional[builtins.str] = None,
                 resource_group: Optional[builtins.str] = None,
                 resource_uri: Optional[builtins.str] = None,
                 server_name: Optional[builtins.str] = None,
                 service_data_access_auth_identity: Optional[builtins.str] = None,
                 subscription_id: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None,
                 thumbprint: Optional[builtins.str] = None,
                 user_id: Optional[builtins.str] = None,
                 user_password: Optional[builtins.str] = None):
        """
        :param builtins.str authority_url: The authority URL used for authentication.
        :param builtins.str certificate: The content of the certificate used for authentication.
        :param builtins.str client_id: The Client ID/Application ID
        :param builtins.str client_secret: The client secret.
        :param builtins.str credential_type: Sql Authentication type.
        :param builtins.str database_name: The Azure SQL database name.
        :param builtins.str endpoint: The server host endpoint.
        :param builtins.bool is_cert_auth:  Is it using certificate to authenticate. If false then use client secret.
        :param builtins.str port_number: / The Azure SQL port number.
        :param builtins.str resource_group: Resource Group.
        :param builtins.str resource_uri: The resource the service principal/app has access to.
        :param builtins.str server_name: The Azure SQL server name.
        :param builtins.str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param builtins.str subscription_id: Subscription ID.
        :param builtins.str tenant_id: The ID of the tenant the service principal/app belongs to.
        :param builtins.str thumbprint: The thumbprint of the certificate above.
        :param builtins.str user_id: The Azure SQL user id.
        :param builtins.str user_password: The Azure SQL user password.
        """
        if authority_url is not None:
            pulumi.set(__self__, "authority_url", authority_url)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if is_cert_auth is not None:
            pulumi.set(__self__, "is_cert_auth", is_cert_auth)
        if port_number is not None:
            pulumi.set(__self__, "port_number", port_number)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if resource_uri is not None:
            pulumi.set(__self__, "resource_uri", resource_uri)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if user_password is not None:
            pulumi.set(__self__, "user_password", user_password)

    @property
    @pulumi.getter(name="authorityUrl")
    def authority_url(self) -> Optional[builtins.str]:
        """
        The authority URL used for authentication.
        """
        return pulumi.get(self, "authority_url")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[builtins.str]:
        """
        The content of the certificate used for authentication.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        The Client ID/Application ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[builtins.str]:
        """
        Sql Authentication type.
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[builtins.str]:
        """
        The Azure SQL database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[builtins.str]:
        """
        The server host endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="isCertAuth")
    def is_cert_auth(self) -> Optional[builtins.bool]:
        """
         Is it using certificate to authenticate. If false then use client secret.
        """
        return pulumi.get(self, "is_cert_auth")

    @property
    @pulumi.getter(name="portNumber")
    def port_number(self) -> Optional[builtins.str]:
        """
        / The Azure SQL port number.
        """
        return pulumi.get(self, "port_number")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[builtins.str]:
        """
        Resource Group.
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[builtins.str]:
        """
        The resource the service principal/app has access to.
        """
        return pulumi.get(self, "resource_uri")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[builtins.str]:
        """
        The Azure SQL server name.
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[builtins.str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[builtins.str]:
        """
        Subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        """
        The ID of the tenant the service principal/app belongs to.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[builtins.str]:
        """
        The thumbprint of the certificate above.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[builtins.str]:
        """
        The Azure SQL user id.
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter(name="userPassword")
    def user_password(self) -> Optional[builtins.str]:
        """
        The Azure SQL user password.
        """
        return pulumi.get(self, "user_password")


@pulumi.output_type
class AzurePostgreSqlSectionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorityUrl":
            suggest = "authority_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "credentialType":
            suggest = "credential_type"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "enableSsl":
            suggest = "enable_ssl"
        elif key == "isCertAuth":
            suggest = "is_cert_auth"
        elif key == "portNumber":
            suggest = "port_number"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "resourceUri":
            suggest = "resource_uri"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "serviceDataAccessAuthIdentity":
            suggest = "service_data_access_auth_identity"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userId":
            suggest = "user_id"
        elif key == "userPassword":
            suggest = "user_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzurePostgreSqlSectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzurePostgreSqlSectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzurePostgreSqlSectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authority_url: Optional[builtins.str] = None,
                 certificate: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 credential_type: Optional[builtins.str] = None,
                 database_name: Optional[builtins.str] = None,
                 enable_ssl: Optional[builtins.bool] = None,
                 endpoint: Optional[builtins.str] = None,
                 is_cert_auth: Optional[builtins.bool] = None,
                 port_number: Optional[builtins.str] = None,
                 resource_group: Optional[builtins.str] = None,
                 resource_uri: Optional[builtins.str] = None,
                 server_name: Optional[builtins.str] = None,
                 service_data_access_auth_identity: Optional[builtins.str] = None,
                 subscription_id: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None,
                 thumbprint: Optional[builtins.str] = None,
                 user_id: Optional[builtins.str] = None,
                 user_password: Optional[builtins.str] = None):
        """
        :param builtins.str authority_url: The authority URL used for authentication.
        :param builtins.str certificate: The content of the certificate used for authentication.
        :param builtins.str client_id: The Client ID/Application ID
        :param builtins.str client_secret: The client secret.
        :param builtins.str credential_type: Sql Authentication type.
        :param builtins.str database_name: The Azure SQL database name.
        :param builtins.bool enable_ssl: Indicates SSL requirement of Azure Postgresql server.
        :param builtins.str endpoint: The server host endpoint.
        :param builtins.bool is_cert_auth:  Is it using certificate to authenticate. If false then use client secret.
        :param builtins.str port_number: / The Azure SQL port number.
        :param builtins.str resource_group: Resource Group.
        :param builtins.str resource_uri: The resource the service principal/app has access to.
        :param builtins.str server_name: The Azure SQL server name.
        :param builtins.str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param builtins.str subscription_id: Subscription ID.
        :param builtins.str tenant_id: The ID of the tenant the service principal/app belongs to.
        :param builtins.str thumbprint: The thumbprint of the certificate above.
        :param builtins.str user_id: The Azure SQL user id.
        :param builtins.str user_password: The Azure SQL user password.
        """
        if authority_url is not None:
            pulumi.set(__self__, "authority_url", authority_url)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if enable_ssl is not None:
            pulumi.set(__self__, "enable_ssl", enable_ssl)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if is_cert_auth is not None:
            pulumi.set(__self__, "is_cert_auth", is_cert_auth)
        if port_number is not None:
            pulumi.set(__self__, "port_number", port_number)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if resource_uri is not None:
            pulumi.set(__self__, "resource_uri", resource_uri)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if user_password is not None:
            pulumi.set(__self__, "user_password", user_password)

    @property
    @pulumi.getter(name="authorityUrl")
    def authority_url(self) -> Optional[builtins.str]:
        """
        The authority URL used for authentication.
        """
        return pulumi.get(self, "authority_url")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[builtins.str]:
        """
        The content of the certificate used for authentication.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        The Client ID/Application ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[builtins.str]:
        """
        Sql Authentication type.
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[builtins.str]:
        """
        The Azure SQL database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="enableSsl")
    def enable_ssl(self) -> Optional[builtins.bool]:
        """
        Indicates SSL requirement of Azure Postgresql server.
        """
        return pulumi.get(self, "enable_ssl")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[builtins.str]:
        """
        The server host endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="isCertAuth")
    def is_cert_auth(self) -> Optional[builtins.bool]:
        """
         Is it using certificate to authenticate. If false then use client secret.
        """
        return pulumi.get(self, "is_cert_auth")

    @property
    @pulumi.getter(name="portNumber")
    def port_number(self) -> Optional[builtins.str]:
        """
        / The Azure SQL port number.
        """
        return pulumi.get(self, "port_number")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[builtins.str]:
        """
        Resource Group.
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[builtins.str]:
        """
        The resource the service principal/app has access to.
        """
        return pulumi.get(self, "resource_uri")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[builtins.str]:
        """
        The Azure SQL server name.
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[builtins.str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[builtins.str]:
        """
        Subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        """
        The ID of the tenant the service principal/app belongs to.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[builtins.str]:
        """
        The thumbprint of the certificate above.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[builtins.str]:
        """
        The Azure SQL user id.
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter(name="userPassword")
    def user_password(self) -> Optional[builtins.str]:
        """
        The Azure SQL user password.
        """
        return pulumi.get(self, "user_password")


@pulumi.output_type
class AzureSqlDatabaseSectionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorityUrl":
            suggest = "authority_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "credentialType":
            suggest = "credential_type"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "isCertAuth":
            suggest = "is_cert_auth"
        elif key == "portNumber":
            suggest = "port_number"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "resourceUri":
            suggest = "resource_uri"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "serviceDataAccessAuthIdentity":
            suggest = "service_data_access_auth_identity"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userId":
            suggest = "user_id"
        elif key == "userPassword":
            suggest = "user_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureSqlDatabaseSectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureSqlDatabaseSectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureSqlDatabaseSectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authority_url: Optional[builtins.str] = None,
                 certificate: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 credential_type: Optional[builtins.str] = None,
                 database_name: Optional[builtins.str] = None,
                 endpoint: Optional[builtins.str] = None,
                 is_cert_auth: Optional[builtins.bool] = None,
                 port_number: Optional[builtins.str] = None,
                 resource_group: Optional[builtins.str] = None,
                 resource_uri: Optional[builtins.str] = None,
                 server_name: Optional[builtins.str] = None,
                 service_data_access_auth_identity: Optional[builtins.str] = None,
                 subscription_id: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None,
                 thumbprint: Optional[builtins.str] = None,
                 user_id: Optional[builtins.str] = None,
                 user_password: Optional[builtins.str] = None):
        """
        :param builtins.str authority_url: The authority URL used for authentication.
        :param builtins.str certificate: The content of the certificate used for authentication.
        :param builtins.str client_id: The Client ID/Application ID
        :param builtins.str client_secret: The client secret.
        :param builtins.str credential_type: Sql Authentication type.
        :param builtins.str database_name: The Azure SQL database name.
        :param builtins.str endpoint: The server host endpoint.
        :param builtins.bool is_cert_auth:  Is it using certificate to authenticate. If false then use client secret.
        :param builtins.str port_number: / The Azure SQL port number.
        :param builtins.str resource_group: Resource Group.
        :param builtins.str resource_uri: The resource the service principal/app has access to.
        :param builtins.str server_name: The Azure SQL server name.
        :param builtins.str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param builtins.str subscription_id: Subscription ID.
        :param builtins.str tenant_id: The ID of the tenant the service principal/app belongs to.
        :param builtins.str thumbprint: The thumbprint of the certificate above.
        :param builtins.str user_id: The Azure SQL user id.
        :param builtins.str user_password: The Azure SQL user password.
        """
        if authority_url is not None:
            pulumi.set(__self__, "authority_url", authority_url)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if is_cert_auth is not None:
            pulumi.set(__self__, "is_cert_auth", is_cert_auth)
        if port_number is not None:
            pulumi.set(__self__, "port_number", port_number)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if resource_uri is not None:
            pulumi.set(__self__, "resource_uri", resource_uri)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if user_password is not None:
            pulumi.set(__self__, "user_password", user_password)

    @property
    @pulumi.getter(name="authorityUrl")
    def authority_url(self) -> Optional[builtins.str]:
        """
        The authority URL used for authentication.
        """
        return pulumi.get(self, "authority_url")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[builtins.str]:
        """
        The content of the certificate used for authentication.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        The Client ID/Application ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[builtins.str]:
        """
        Sql Authentication type.
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[builtins.str]:
        """
        The Azure SQL database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[builtins.str]:
        """
        The server host endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="isCertAuth")
    def is_cert_auth(self) -> Optional[builtins.bool]:
        """
         Is it using certificate to authenticate. If false then use client secret.
        """
        return pulumi.get(self, "is_cert_auth")

    @property
    @pulumi.getter(name="portNumber")
    def port_number(self) -> Optional[builtins.str]:
        """
        / The Azure SQL port number.
        """
        return pulumi.get(self, "port_number")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[builtins.str]:
        """
        Resource Group.
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[builtins.str]:
        """
        The resource the service principal/app has access to.
        """
        return pulumi.get(self, "resource_uri")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[builtins.str]:
        """
        The Azure SQL server name.
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[builtins.str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[builtins.str]:
        """
        Subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        """
        The ID of the tenant the service principal/app belongs to.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[builtins.str]:
        """
        The thumbprint of the certificate above.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[builtins.str]:
        """
        The Azure SQL user id.
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter(name="userPassword")
    def user_password(self) -> Optional[builtins.str]:
        """
        The Azure SQL user password.
        """
        return pulumi.get(self, "user_password")


@pulumi.output_type
class AzureStorageSectionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountKey":
            suggest = "account_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "areWorkspaceManagedIdentitiesAllowed":
            suggest = "are_workspace_managed_identities_allowed"
        elif key == "blobCacheTimeout":
            suggest = "blob_cache_timeout"
        elif key == "clientCredentials":
            suggest = "client_credentials"
        elif key == "containerName":
            suggest = "container_name"
        elif key == "credentialType":
            suggest = "credential_type"
        elif key == "isSas":
            suggest = "is_sas"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "sasToken":
            suggest = "sas_token"
        elif key == "serviceDataAccessAuthIdentity":
            suggest = "service_data_access_auth_identity"
        elif key == "subscriptionId":
            suggest = "subscription_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureStorageSectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureStorageSectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureStorageSectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_key: Optional[builtins.str] = None,
                 account_name: Optional[builtins.str] = None,
                 are_workspace_managed_identities_allowed: Optional[builtins.bool] = None,
                 blob_cache_timeout: Optional[builtins.int] = None,
                 client_credentials: Optional['outputs.ClientCredentialsResponse'] = None,
                 container_name: Optional[builtins.str] = None,
                 credential: Optional[builtins.str] = None,
                 credential_type: Optional[builtins.str] = None,
                 endpoint: Optional[builtins.str] = None,
                 is_sas: Optional[builtins.bool] = None,
                 protocol: Optional[builtins.str] = None,
                 resource_group: Optional[builtins.str] = None,
                 sas_token: Optional[builtins.str] = None,
                 service_data_access_auth_identity: Optional[builtins.str] = None,
                 subscription_id: Optional[builtins.str] = None):
        """
        :param builtins.str account_key:  Storage Account Key (Deprecated).
        :param builtins.str account_name: Storage Account Name.
        :param builtins.bool are_workspace_managed_identities_allowed: Indicate if we are using Workspace ManagedIdentities/MSI token (Deprecated).
        :param builtins.int blob_cache_timeout:  If this is an "DataStoreType.AzureBlob", the length of time (in seconds) to cache files locally after they are accessed (downloaded).
        :param builtins.str container_name: The storage container name.
        :param builtins.str credential: The credential.
        :param builtins.str credential_type:  The credential type.
        :param builtins.str endpoint: The host of the container.
        :param builtins.bool is_sas: Indicate if we are using SAS token or Account Key (Deprecated).
        :param builtins.str protocol: The protocol to use. Defaults to https.
        :param builtins.str resource_group: Resource Group.
        :param builtins.str sas_token:  SAS Token for the container (Deprecated).
        :param builtins.str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param builtins.str subscription_id: Subscription ID.
        """
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if are_workspace_managed_identities_allowed is not None:
            pulumi.set(__self__, "are_workspace_managed_identities_allowed", are_workspace_managed_identities_allowed)
        if blob_cache_timeout is not None:
            pulumi.set(__self__, "blob_cache_timeout", blob_cache_timeout)
        if client_credentials is not None:
            pulumi.set(__self__, "client_credentials", client_credentials)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if is_sas is not None:
            pulumi.set(__self__, "is_sas", is_sas)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[builtins.str]:
        """
         Storage Account Key (Deprecated).
        """
        return pulumi.get(self, "account_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[builtins.str]:
        """
        Storage Account Name.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="areWorkspaceManagedIdentitiesAllowed")
    def are_workspace_managed_identities_allowed(self) -> Optional[builtins.bool]:
        """
        Indicate if we are using Workspace ManagedIdentities/MSI token (Deprecated).
        """
        return pulumi.get(self, "are_workspace_managed_identities_allowed")

    @property
    @pulumi.getter(name="blobCacheTimeout")
    def blob_cache_timeout(self) -> Optional[builtins.int]:
        """
         If this is an "DataStoreType.AzureBlob", the length of time (in seconds) to cache files locally after they are accessed (downloaded).
        """
        return pulumi.get(self, "blob_cache_timeout")

    @property
    @pulumi.getter(name="clientCredentials")
    def client_credentials(self) -> Optional['outputs.ClientCredentialsResponse']:
        return pulumi.get(self, "client_credentials")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[builtins.str]:
        """
        The storage container name.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def credential(self) -> Optional[builtins.str]:
        """
        The credential.
        """
        return pulumi.get(self, "credential")

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[builtins.str]:
        """
         The credential type.
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[builtins.str]:
        """
        The host of the container.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="isSas")
    def is_sas(self) -> Optional[builtins.bool]:
        """
        Indicate if we are using SAS token or Account Key (Deprecated).
        """
        return pulumi.get(self, "is_sas")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[builtins.str]:
        """
        The protocol to use. Defaults to https.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[builtins.str]:
        """
        Resource Group.
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional[builtins.str]:
        """
         SAS Token for the container (Deprecated).
        """
        return pulumi.get(self, "sas_token")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[builtins.str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[builtins.str]:
        """
        Subscription ID.
        """
        return pulumi.get(self, "subscription_id")


@pulumi.output_type
class BanditPolicyResponse(dict):
    """
    Defines an early termination policy based on slack criteria, and a frequency and delay interval for evaluation
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyType":
            suggest = "policy_type"
        elif key == "delayEvaluation":
            suggest = "delay_evaluation"
        elif key == "evaluationInterval":
            suggest = "evaluation_interval"
        elif key == "slackAmount":
            suggest = "slack_amount"
        elif key == "slackFactor":
            suggest = "slack_factor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BanditPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BanditPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BanditPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_type: builtins.str,
                 delay_evaluation: Optional[builtins.int] = None,
                 evaluation_interval: Optional[builtins.int] = None,
                 slack_amount: Optional[builtins.float] = None,
                 slack_factor: Optional[builtins.float] = None):
        """
        Defines an early termination policy based on slack criteria, and a frequency and delay interval for evaluation
        :param builtins.str policy_type: 
               Expected value is 'Bandit'.
        :param builtins.int delay_evaluation: Number of intervals by which to delay the first evaluation.
        :param builtins.int evaluation_interval: Interval (number of runs) between policy evaluations.
        :param builtins.float slack_amount: Absolute distance allowed from the best performing run.
        :param builtins.float slack_factor: Ratio of the allowed distance from the best performing run.
        """
        pulumi.set(__self__, "policy_type", 'Bandit')
        if delay_evaluation is None:
            delay_evaluation = 0
        if delay_evaluation is not None:
            pulumi.set(__self__, "delay_evaluation", delay_evaluation)
        if evaluation_interval is None:
            evaluation_interval = 0
        if evaluation_interval is not None:
            pulumi.set(__self__, "evaluation_interval", evaluation_interval)
        if slack_amount is None:
            slack_amount = 0
        if slack_amount is not None:
            pulumi.set(__self__, "slack_amount", slack_amount)
        if slack_factor is None:
            slack_factor = 0
        if slack_factor is not None:
            pulumi.set(__self__, "slack_factor", slack_factor)

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> builtins.str:
        """

        Expected value is 'Bandit'.
        """
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="delayEvaluation")
    def delay_evaluation(self) -> Optional[builtins.int]:
        """
        Number of intervals by which to delay the first evaluation.
        """
        return pulumi.get(self, "delay_evaluation")

    @property
    @pulumi.getter(name="evaluationInterval")
    def evaluation_interval(self) -> Optional[builtins.int]:
        """
        Interval (number of runs) between policy evaluations.
        """
        return pulumi.get(self, "evaluation_interval")

    @property
    @pulumi.getter(name="slackAmount")
    def slack_amount(self) -> Optional[builtins.float]:
        """
        Absolute distance allowed from the best performing run.
        """
        return pulumi.get(self, "slack_amount")

    @property
    @pulumi.getter(name="slackFactor")
    def slack_factor(self) -> Optional[builtins.float]:
        """
        Ratio of the allowed distance from the best performing run.
        """
        return pulumi.get(self, "slack_factor")


@pulumi.output_type
class BatchDeploymentResponse(dict):
    """
    Batch inference settings per deployment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "codeConfiguration":
            suggest = "code_configuration"
        elif key == "deploymentConfiguration":
            suggest = "deployment_configuration"
        elif key == "environmentId":
            suggest = "environment_id"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "errorThreshold":
            suggest = "error_threshold"
        elif key == "loggingLevel":
            suggest = "logging_level"
        elif key == "maxConcurrencyPerInstance":
            suggest = "max_concurrency_per_instance"
        elif key == "miniBatchSize":
            suggest = "mini_batch_size"
        elif key == "outputAction":
            suggest = "output_action"
        elif key == "outputFileName":
            suggest = "output_file_name"
        elif key == "retrySettings":
            suggest = "retry_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BatchDeploymentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BatchDeploymentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BatchDeploymentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 code_configuration: Optional['outputs.CodeConfigurationResponse'] = None,
                 compute: Optional[builtins.str] = None,
                 deployment_configuration: Optional['outputs.BatchPipelineComponentDeploymentConfigurationResponse'] = None,
                 description: Optional[builtins.str] = None,
                 environment_id: Optional[builtins.str] = None,
                 environment_variables: Optional[Mapping[str, builtins.str]] = None,
                 error_threshold: Optional[builtins.int] = None,
                 logging_level: Optional[builtins.str] = None,
                 max_concurrency_per_instance: Optional[builtins.int] = None,
                 mini_batch_size: Optional[builtins.float] = None,
                 model: Optional[Any] = None,
                 output_action: Optional[builtins.str] = None,
                 output_file_name: Optional[builtins.str] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 resources: Optional['outputs.DeploymentResourceConfigurationResponse'] = None,
                 retry_settings: Optional['outputs.BatchRetrySettingsResponse'] = None):
        """
        Batch inference settings per deployment.
        :param builtins.str provisioning_state: Provisioning state for the endpoint deployment.
        :param 'CodeConfigurationResponse' code_configuration: Code configuration for the endpoint deployment.
        :param builtins.str compute: Compute target for batch inference operation.
        :param 'BatchPipelineComponentDeploymentConfigurationResponse' deployment_configuration: Properties relevant to different deployment types.
        :param builtins.str description: Description of the endpoint deployment.
        :param builtins.str environment_id: ARM resource ID or AssetId of the environment specification for the endpoint deployment.
        :param Mapping[str, builtins.str] environment_variables: Environment variables configuration for the deployment.
        :param builtins.int error_threshold: Error threshold, if the error count for the entire input goes above this value,
               the batch inference will be aborted. Range is [-1, int.MaxValue].
               For FileDataset, this value is the count of file failures.
               For TabularDataset, this value is the count of record failures.
               If set to -1 (the lower bound), all failures during batch inference will be ignored.
        :param builtins.str logging_level: Logging level for batch inference operation.
        :param builtins.int max_concurrency_per_instance: Indicates maximum number of parallelism per instance.
        :param builtins.float mini_batch_size: Size of the mini-batch passed to each batch invocation.
               For FileDataset, this is the number of files per mini-batch.
               For TabularDataset, this is the size of the records in bytes, per mini-batch.
        :param Union['DataPathAssetReferenceResponse', 'IdAssetReferenceResponse', 'OutputPathAssetReferenceResponse'] model: Reference to the model asset for the endpoint deployment.
        :param builtins.str output_action: Indicates how the output will be organized.
        :param builtins.str output_file_name: Customized output file name for append_row output action.
        :param Mapping[str, builtins.str] properties: Property dictionary. Properties can be added, but not removed or altered.
        :param 'DeploymentResourceConfigurationResponse' resources: Indicates compute configuration for the job.
               If not provided, will default to the defaults defined in ResourceConfiguration.
        :param 'BatchRetrySettingsResponse' retry_settings: Retry Settings for the batch inference operation.
               If not provided, will default to the defaults defined in BatchRetrySettings.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if code_configuration is not None:
            pulumi.set(__self__, "code_configuration", code_configuration)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if deployment_configuration is not None:
            pulumi.set(__self__, "deployment_configuration", deployment_configuration)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if error_threshold is None:
            error_threshold = -1
        if error_threshold is not None:
            pulumi.set(__self__, "error_threshold", error_threshold)
        if logging_level is None:
            logging_level = 'Info'
        if logging_level is not None:
            pulumi.set(__self__, "logging_level", logging_level)
        if max_concurrency_per_instance is None:
            max_concurrency_per_instance = 1
        if max_concurrency_per_instance is not None:
            pulumi.set(__self__, "max_concurrency_per_instance", max_concurrency_per_instance)
        if mini_batch_size is None:
            mini_batch_size = 10
        if mini_batch_size is not None:
            pulumi.set(__self__, "mini_batch_size", mini_batch_size)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if output_action is None:
            output_action = 'AppendRow'
        if output_action is not None:
            pulumi.set(__self__, "output_action", output_action)
        if output_file_name is None:
            output_file_name = 'predictions.csv'
        if output_file_name is not None:
            pulumi.set(__self__, "output_file_name", output_file_name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if retry_settings is not None:
            pulumi.set(__self__, "retry_settings", retry_settings)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the endpoint deployment.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="codeConfiguration")
    def code_configuration(self) -> Optional['outputs.CodeConfigurationResponse']:
        """
        Code configuration for the endpoint deployment.
        """
        return pulumi.get(self, "code_configuration")

    @property
    @pulumi.getter
    def compute(self) -> Optional[builtins.str]:
        """
        Compute target for batch inference operation.
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="deploymentConfiguration")
    def deployment_configuration(self) -> Optional['outputs.BatchPipelineComponentDeploymentConfigurationResponse']:
        """
        Properties relevant to different deployment types.
        """
        return pulumi.get(self, "deployment_configuration")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description of the endpoint deployment.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID or AssetId of the environment specification for the endpoint deployment.
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Environment variables configuration for the deployment.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="errorThreshold")
    def error_threshold(self) -> Optional[builtins.int]:
        """
        Error threshold, if the error count for the entire input goes above this value,
        the batch inference will be aborted. Range is [-1, int.MaxValue].
        For FileDataset, this value is the count of file failures.
        For TabularDataset, this value is the count of record failures.
        If set to -1 (the lower bound), all failures during batch inference will be ignored.
        """
        return pulumi.get(self, "error_threshold")

    @property
    @pulumi.getter(name="loggingLevel")
    def logging_level(self) -> Optional[builtins.str]:
        """
        Logging level for batch inference operation.
        """
        return pulumi.get(self, "logging_level")

    @property
    @pulumi.getter(name="maxConcurrencyPerInstance")
    def max_concurrency_per_instance(self) -> Optional[builtins.int]:
        """
        Indicates maximum number of parallelism per instance.
        """
        return pulumi.get(self, "max_concurrency_per_instance")

    @property
    @pulumi.getter(name="miniBatchSize")
    def mini_batch_size(self) -> Optional[builtins.float]:
        """
        Size of the mini-batch passed to each batch invocation.
        For FileDataset, this is the number of files per mini-batch.
        For TabularDataset, this is the size of the records in bytes, per mini-batch.
        """
        return pulumi.get(self, "mini_batch_size")

    @property
    @pulumi.getter
    def model(self) -> Optional[Any]:
        """
        Reference to the model asset for the endpoint deployment.
        """
        return pulumi.get(self, "model")

    @property
    @pulumi.getter(name="outputAction")
    def output_action(self) -> Optional[builtins.str]:
        """
        Indicates how the output will be organized.
        """
        return pulumi.get(self, "output_action")

    @property
    @pulumi.getter(name="outputFileName")
    def output_file_name(self) -> Optional[builtins.str]:
        """
        Customized output file name for append_row output action.
        """
        return pulumi.get(self, "output_file_name")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.DeploymentResourceConfigurationResponse']:
        """
        Indicates compute configuration for the job.
        If not provided, will default to the defaults defined in ResourceConfiguration.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="retrySettings")
    def retry_settings(self) -> Optional['outputs.BatchRetrySettingsResponse']:
        """
        Retry Settings for the batch inference operation.
        If not provided, will default to the defaults defined in BatchRetrySettings.
        """
        return pulumi.get(self, "retry_settings")


@pulumi.output_type
class BatchEndpointDefaultsResponse(dict):
    """
    Batch endpoint default values
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentName":
            suggest = "deployment_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BatchEndpointDefaultsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BatchEndpointDefaultsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BatchEndpointDefaultsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment_name: Optional[builtins.str] = None):
        """
        Batch endpoint default values
        :param builtins.str deployment_name: Name of the deployment that will be default for the endpoint.
               This deployment will end up getting 100% traffic when the endpoint scoring URL is invoked.
        """
        if deployment_name is not None:
            pulumi.set(__self__, "deployment_name", deployment_name)

    @property
    @pulumi.getter(name="deploymentName")
    def deployment_name(self) -> Optional[builtins.str]:
        """
        Name of the deployment that will be default for the endpoint.
        This deployment will end up getting 100% traffic when the endpoint scoring URL is invoked.
        """
        return pulumi.get(self, "deployment_name")


@pulumi.output_type
class BatchEndpointResponse(dict):
    """
    Batch endpoint configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authMode":
            suggest = "auth_mode"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "scoringUri":
            suggest = "scoring_uri"
        elif key == "swaggerUri":
            suggest = "swagger_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BatchEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BatchEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BatchEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_mode: builtins.str,
                 provisioning_state: builtins.str,
                 scoring_uri: builtins.str,
                 swagger_uri: builtins.str,
                 defaults: Optional['outputs.BatchEndpointDefaultsResponse'] = None,
                 description: Optional[builtins.str] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None):
        """
        Batch endpoint configuration.
        :param builtins.str auth_mode: [Required] The authentication method for invoking the endpoint (data plane operation). Use 'Key' for key-based authentication. Use 'AMLToken' for Azure Machine Learning token-based authentication. Use 'AADToken' for Microsoft Entra token-based authentication.
        :param builtins.str provisioning_state: Provisioning state for the endpoint.
        :param builtins.str scoring_uri: Endpoint URI.
        :param builtins.str swagger_uri: Endpoint Swagger URI.
        :param 'BatchEndpointDefaultsResponse' defaults: Default values for Batch Endpoint
        :param builtins.str description: Description of the inference endpoint.
        :param Mapping[str, builtins.str] properties: Property dictionary. Properties can be added, but not removed or altered.
        """
        pulumi.set(__self__, "auth_mode", auth_mode)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "scoring_uri", scoring_uri)
        pulumi.set(__self__, "swagger_uri", swagger_uri)
        if defaults is not None:
            pulumi.set(__self__, "defaults", defaults)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter(name="authMode")
    def auth_mode(self) -> builtins.str:
        """
        [Required] The authentication method for invoking the endpoint (data plane operation). Use 'Key' for key-based authentication. Use 'AMLToken' for Azure Machine Learning token-based authentication. Use 'AADToken' for Microsoft Entra token-based authentication.
        """
        return pulumi.get(self, "auth_mode")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the endpoint.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="scoringUri")
    def scoring_uri(self) -> builtins.str:
        """
        Endpoint URI.
        """
        return pulumi.get(self, "scoring_uri")

    @property
    @pulumi.getter(name="swaggerUri")
    def swagger_uri(self) -> builtins.str:
        """
        Endpoint Swagger URI.
        """
        return pulumi.get(self, "swagger_uri")

    @property
    @pulumi.getter
    def defaults(self) -> Optional['outputs.BatchEndpointDefaultsResponse']:
        """
        Default values for Batch Endpoint
        """
        return pulumi.get(self, "defaults")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description of the inference endpoint.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class BatchPipelineComponentDeploymentConfigurationResponse(dict):
    """
    Properties for a Batch Pipeline Component Deployment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentConfigurationType":
            suggest = "deployment_configuration_type"
        elif key == "componentId":
            suggest = "component_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BatchPipelineComponentDeploymentConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BatchPipelineComponentDeploymentConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BatchPipelineComponentDeploymentConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment_configuration_type: builtins.str,
                 component_id: Optional['outputs.IdAssetReferenceResponse'] = None,
                 description: Optional[builtins.str] = None,
                 settings: Optional[Mapping[str, builtins.str]] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Properties for a Batch Pipeline Component Deployment.
        :param builtins.str deployment_configuration_type: The enumerated property types for batch deployments.
               Expected value is 'PipelineComponent'.
        :param 'IdAssetReferenceResponse' component_id: The ARM id of the component to be run.
        :param builtins.str description: The description which will be applied to the job.
        :param Mapping[str, builtins.str] settings: Run-time settings for the pipeline job.
        :param Mapping[str, builtins.str] tags: The tags which will be applied to the job.
        """
        pulumi.set(__self__, "deployment_configuration_type", 'PipelineComponent')
        if component_id is not None:
            pulumi.set(__self__, "component_id", component_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="deploymentConfigurationType")
    def deployment_configuration_type(self) -> builtins.str:
        """
        The enumerated property types for batch deployments.
        Expected value is 'PipelineComponent'.
        """
        return pulumi.get(self, "deployment_configuration_type")

    @property
    @pulumi.getter(name="componentId")
    def component_id(self) -> Optional['outputs.IdAssetReferenceResponse']:
        """
        The ARM id of the component to be run.
        """
        return pulumi.get(self, "component_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description which will be applied to the job.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Run-time settings for the pipeline job.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The tags which will be applied to the job.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class BatchRetrySettingsResponse(dict):
    """
    Retry settings for a batch inference operation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxRetries":
            suggest = "max_retries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BatchRetrySettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BatchRetrySettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BatchRetrySettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_retries: Optional[builtins.int] = None,
                 timeout: Optional[builtins.str] = None):
        """
        Retry settings for a batch inference operation.
        :param builtins.int max_retries: Maximum retry count for a mini-batch
        :param builtins.str timeout: Invocation timeout for a mini-batch, in ISO 8601 format.
        """
        if max_retries is None:
            max_retries = 3
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if timeout is None:
            timeout = 'PT30S'
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[builtins.int]:
        """
        Maximum retry count for a mini-batch
        """
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[builtins.str]:
        """
        Invocation timeout for a mini-batch, in ISO 8601 format.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class BayesianSamplingAlgorithmResponse(dict):
    """
    Defines a Sampling Algorithm that generates values based on previous values
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "samplingAlgorithmType":
            suggest = "sampling_algorithm_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BayesianSamplingAlgorithmResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BayesianSamplingAlgorithmResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BayesianSamplingAlgorithmResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sampling_algorithm_type: builtins.str):
        """
        Defines a Sampling Algorithm that generates values based on previous values
        :param builtins.str sampling_algorithm_type: 
               Expected value is 'Bayesian'.
        """
        pulumi.set(__self__, "sampling_algorithm_type", 'Bayesian')

    @property
    @pulumi.getter(name="samplingAlgorithmType")
    def sampling_algorithm_type(self) -> builtins.str:
        """

        Expected value is 'Bayesian'.
        """
        return pulumi.get(self, "sampling_algorithm_type")


@pulumi.output_type
class BindOptionsResponse(dict):
    """
    Describes the bind options for the container
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createHostPath":
            suggest = "create_host_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BindOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BindOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BindOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_host_path: Optional[builtins.bool] = None,
                 propagation: Optional[builtins.str] = None,
                 selinux: Optional[builtins.str] = None):
        """
        Describes the bind options for the container
        :param builtins.bool create_host_path: Indicate whether to create host path.
        :param builtins.str propagation: Type of Bind Option
        :param builtins.str selinux: Mention the selinux options.
        """
        if create_host_path is not None:
            pulumi.set(__self__, "create_host_path", create_host_path)
        if propagation is not None:
            pulumi.set(__self__, "propagation", propagation)
        if selinux is not None:
            pulumi.set(__self__, "selinux", selinux)

    @property
    @pulumi.getter(name="createHostPath")
    def create_host_path(self) -> Optional[builtins.bool]:
        """
        Indicate whether to create host path.
        """
        return pulumi.get(self, "create_host_path")

    @property
    @pulumi.getter
    def propagation(self) -> Optional[builtins.str]:
        """
        Type of Bind Option
        """
        return pulumi.get(self, "propagation")

    @property
    @pulumi.getter
    def selinux(self) -> Optional[builtins.str]:
        """
        Mention the selinux options.
        """
        return pulumi.get(self, "selinux")


@pulumi.output_type
class BuildContextResponse(dict):
    """
    Configuration settings for Docker build context
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contextUri":
            suggest = "context_uri"
        elif key == "dockerfilePath":
            suggest = "dockerfile_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildContextResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildContextResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildContextResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 context_uri: builtins.str,
                 dockerfile_path: Optional[builtins.str] = None):
        """
        Configuration settings for Docker build context
        :param builtins.str context_uri: [Required] URI of the Docker build context used to build the image. Supports blob URIs on environment creation and may return blob or Git URIs.
               <seealso href="https://docs.docker.com/engine/reference/commandline/build/#extended-description" />
        :param builtins.str dockerfile_path: Path to the Dockerfile in the build context.
               <seealso href="https://docs.docker.com/engine/reference/builder/" />
        """
        pulumi.set(__self__, "context_uri", context_uri)
        if dockerfile_path is None:
            dockerfile_path = 'Dockerfile'
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)

    @property
    @pulumi.getter(name="contextUri")
    def context_uri(self) -> builtins.str:
        """
        [Required] URI of the Docker build context used to build the image. Supports blob URIs on environment creation and may return blob or Git URIs.
        <seealso href="https://docs.docker.com/engine/reference/commandline/build/#extended-description" />
        """
        return pulumi.get(self, "context_uri")

    @property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[builtins.str]:
        """
        Path to the Dockerfile in the build context.
        <seealso href="https://docs.docker.com/engine/reference/builder/" />
        """
        return pulumi.get(self, "dockerfile_path")


@pulumi.output_type
class CapabilityHostResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "aiServicesConnections":
            suggest = "ai_services_connections"
        elif key == "capabilityHostKind":
            suggest = "capability_host_kind"
        elif key == "customerSubnet":
            suggest = "customer_subnet"
        elif key == "storageConnections":
            suggest = "storage_connections"
        elif key == "threadStorageConnections":
            suggest = "thread_storage_connections"
        elif key == "vectorStoreConnections":
            suggest = "vector_store_connections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapabilityHostResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapabilityHostResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapabilityHostResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 ai_services_connections: Optional[Sequence[builtins.str]] = None,
                 capability_host_kind: Optional[builtins.str] = None,
                 customer_subnet: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 storage_connections: Optional[Sequence[builtins.str]] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None,
                 thread_storage_connections: Optional[Sequence[builtins.str]] = None,
                 vector_store_connections: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str provisioning_state: Provisioning state for the CapabilityHost.
        :param Sequence[builtins.str] ai_services_connections: List of AI services connections.
        :param builtins.str capability_host_kind: Kind of this capability host.
        :param builtins.str customer_subnet: Customer subnet info to help set up this capability host.
        :param builtins.str description: The asset description text.
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param Sequence[builtins.str] storage_connections: List of Storage connections.
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        :param Sequence[builtins.str] thread_storage_connections: List of Thread storage connections.
        :param Sequence[builtins.str] vector_store_connections: List of VectorStore connections.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if ai_services_connections is not None:
            pulumi.set(__self__, "ai_services_connections", ai_services_connections)
        if capability_host_kind is None:
            capability_host_kind = 'Agents'
        if capability_host_kind is not None:
            pulumi.set(__self__, "capability_host_kind", capability_host_kind)
        if customer_subnet is not None:
            pulumi.set(__self__, "customer_subnet", customer_subnet)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if storage_connections is not None:
            pulumi.set(__self__, "storage_connections", storage_connections)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if thread_storage_connections is not None:
            pulumi.set(__self__, "thread_storage_connections", thread_storage_connections)
        if vector_store_connections is not None:
            pulumi.set(__self__, "vector_store_connections", vector_store_connections)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the CapabilityHost.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="aiServicesConnections")
    def ai_services_connections(self) -> Optional[Sequence[builtins.str]]:
        """
        List of AI services connections.
        """
        return pulumi.get(self, "ai_services_connections")

    @property
    @pulumi.getter(name="capabilityHostKind")
    def capability_host_kind(self) -> Optional[builtins.str]:
        """
        Kind of this capability host.
        """
        return pulumi.get(self, "capability_host_kind")

    @property
    @pulumi.getter(name="customerSubnet")
    def customer_subnet(self) -> Optional[builtins.str]:
        """
        Customer subnet info to help set up this capability host.
        """
        return pulumi.get(self, "customer_subnet")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="storageConnections")
    def storage_connections(self) -> Optional[Sequence[builtins.str]]:
        """
        List of Storage connections.
        """
        return pulumi.get(self, "storage_connections")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="threadStorageConnections")
    def thread_storage_connections(self) -> Optional[Sequence[builtins.str]]:
        """
        List of Thread storage connections.
        """
        return pulumi.get(self, "thread_storage_connections")

    @property
    @pulumi.getter(name="vectorStoreConnections")
    def vector_store_connections(self) -> Optional[Sequence[builtins.str]]:
        """
        List of VectorStore connections.
        """
        return pulumi.get(self, "vector_store_connections")


@pulumi.output_type
class CapacityReservationGroupResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reservedCapacity":
            suggest = "reserved_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityReservationGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityReservationGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityReservationGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reserved_capacity: builtins.int,
                 offer: Optional['outputs.ServerlessOfferResponse'] = None):
        """
        :param builtins.int reserved_capacity: [Required] Specifies the amount of capacity to reserve.
        :param 'ServerlessOfferResponse' offer: Offer used by this capacity reservation group.
        """
        pulumi.set(__self__, "reserved_capacity", reserved_capacity)
        if offer is not None:
            pulumi.set(__self__, "offer", offer)

    @property
    @pulumi.getter(name="reservedCapacity")
    def reserved_capacity(self) -> builtins.int:
        """
        [Required] Specifies the amount of capacity to reserve.
        """
        return pulumi.get(self, "reserved_capacity")

    @property
    @pulumi.getter
    def offer(self) -> Optional['outputs.ServerlessOfferResponse']:
        """
        Offer used by this capacity reservation group.
        """
        return pulumi.get(self, "offer")


@pulumi.output_type
class CategoricalDataDriftMetricThresholdResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CategoricalDataDriftMetricThresholdResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CategoricalDataDriftMetricThresholdResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CategoricalDataDriftMetricThresholdResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: builtins.str,
                 metric: builtins.str,
                 threshold: Optional['outputs.MonitoringThresholdResponse'] = None):
        """
        :param builtins.str data_type: 
               Expected value is 'Categorical'.
        :param builtins.str metric: [Required] The categorical data drift metric to calculate.
        :param 'MonitoringThresholdResponse' threshold: The threshold value. If null, a default value will be set depending on the selected metric.
        """
        pulumi.set(__self__, "data_type", 'Categorical')
        pulumi.set(__self__, "metric", metric)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> builtins.str:
        """

        Expected value is 'Categorical'.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def metric(self) -> builtins.str:
        """
        [Required] The categorical data drift metric to calculate.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def threshold(self) -> Optional['outputs.MonitoringThresholdResponse']:
        """
        The threshold value. If null, a default value will be set depending on the selected metric.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class CategoricalDataQualityMetricThresholdResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CategoricalDataQualityMetricThresholdResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CategoricalDataQualityMetricThresholdResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CategoricalDataQualityMetricThresholdResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: builtins.str,
                 metric: builtins.str,
                 threshold: Optional['outputs.MonitoringThresholdResponse'] = None):
        """
        :param builtins.str data_type: 
               Expected value is 'Categorical'.
        :param builtins.str metric: [Required] The categorical data quality metric to calculate.
        :param 'MonitoringThresholdResponse' threshold: The threshold value. If null, a default value will be set depending on the selected metric.
        """
        pulumi.set(__self__, "data_type", 'Categorical')
        pulumi.set(__self__, "metric", metric)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> builtins.str:
        """

        Expected value is 'Categorical'.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def metric(self) -> builtins.str:
        """
        [Required] The categorical data quality metric to calculate.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def threshold(self) -> Optional['outputs.MonitoringThresholdResponse']:
        """
        The threshold value. If null, a default value will be set depending on the selected metric.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class CategoricalPredictionDriftMetricThresholdResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CategoricalPredictionDriftMetricThresholdResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CategoricalPredictionDriftMetricThresholdResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CategoricalPredictionDriftMetricThresholdResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: builtins.str,
                 metric: builtins.str,
                 threshold: Optional['outputs.MonitoringThresholdResponse'] = None):
        """
        :param builtins.str data_type: 
               Expected value is 'Categorical'.
        :param builtins.str metric: [Required] The categorical prediction drift metric to calculate.
        :param 'MonitoringThresholdResponse' threshold: The threshold value. If null, a default value will be set depending on the selected metric.
        """
        pulumi.set(__self__, "data_type", 'Categorical')
        pulumi.set(__self__, "metric", metric)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> builtins.str:
        """

        Expected value is 'Categorical'.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def metric(self) -> builtins.str:
        """
        [Required] The categorical prediction drift metric to calculate.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def threshold(self) -> Optional['outputs.MonitoringThresholdResponse']:
        """
        The threshold value. If null, a default value will be set depending on the selected metric.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class CertificateDatastoreCredentialsResponse(dict):
    """
    Certificate datastore credentials configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "credentialsType":
            suggest = "credentials_type"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "authorityUrl":
            suggest = "authority_url"
        elif key == "resourceUrl":
            suggest = "resource_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificateDatastoreCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificateDatastoreCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificateDatastoreCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: builtins.str,
                 credentials_type: builtins.str,
                 tenant_id: builtins.str,
                 thumbprint: builtins.str,
                 authority_url: Optional[builtins.str] = None,
                 resource_url: Optional[builtins.str] = None):
        """
        Certificate datastore credentials configuration.
        :param builtins.str client_id: [Required] Service principal client ID.
        :param builtins.str credentials_type: Enum to determine the datastore credentials type.
               Expected value is 'Certificate'.
        :param builtins.str tenant_id: [Required] ID of the tenant to which the service principal belongs.
        :param builtins.str thumbprint: [Required] Thumbprint of the certificate used for authentication.
        :param builtins.str authority_url: Authority URL used for authentication.
        :param builtins.str resource_url: Resource the service principal has access to.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "credentials_type", 'Certificate')
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "thumbprint", thumbprint)
        if authority_url is not None:
            pulumi.set(__self__, "authority_url", authority_url)
        if resource_url is not None:
            pulumi.set(__self__, "resource_url", resource_url)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> builtins.str:
        """
        [Required] Service principal client ID.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="credentialsType")
    def credentials_type(self) -> builtins.str:
        """
        Enum to determine the datastore credentials type.
        Expected value is 'Certificate'.
        """
        return pulumi.get(self, "credentials_type")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> builtins.str:
        """
        [Required] ID of the tenant to which the service principal belongs.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def thumbprint(self) -> builtins.str:
        """
        [Required] Thumbprint of the certificate used for authentication.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter(name="authorityUrl")
    def authority_url(self) -> Optional[builtins.str]:
        """
        Authority URL used for authentication.
        """
        return pulumi.get(self, "authority_url")

    @property
    @pulumi.getter(name="resourceUrl")
    def resource_url(self) -> Optional[builtins.str]:
        """
        Resource the service principal has access to.
        """
        return pulumi.get(self, "resource_url")


@pulumi.output_type
class ClassificationResponse(dict):
    """
    Classification task in AutoML Table vertical.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "trainingData":
            suggest = "training_data"
        elif key == "cvSplitColumnNames":
            suggest = "cv_split_column_names"
        elif key == "featurizationSettings":
            suggest = "featurization_settings"
        elif key == "limitSettings":
            suggest = "limit_settings"
        elif key == "logVerbosity":
            suggest = "log_verbosity"
        elif key == "nCrossValidations":
            suggest = "n_cross_validations"
        elif key == "positiveLabel":
            suggest = "positive_label"
        elif key == "primaryMetric":
            suggest = "primary_metric"
        elif key == "targetColumnName":
            suggest = "target_column_name"
        elif key == "testData":
            suggest = "test_data"
        elif key == "testDataSize":
            suggest = "test_data_size"
        elif key == "trainingSettings":
            suggest = "training_settings"
        elif key == "validationData":
            suggest = "validation_data"
        elif key == "validationDataSize":
            suggest = "validation_data_size"
        elif key == "weightColumnName":
            suggest = "weight_column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClassificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClassificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClassificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 task_type: builtins.str,
                 training_data: 'outputs.MLTableJobInputResponse',
                 cv_split_column_names: Optional[Sequence[builtins.str]] = None,
                 featurization_settings: Optional['outputs.TableVerticalFeaturizationSettingsResponse'] = None,
                 limit_settings: Optional['outputs.TableVerticalLimitSettingsResponse'] = None,
                 log_verbosity: Optional[builtins.str] = None,
                 n_cross_validations: Optional[Any] = None,
                 positive_label: Optional[builtins.str] = None,
                 primary_metric: Optional[builtins.str] = None,
                 target_column_name: Optional[builtins.str] = None,
                 test_data: Optional['outputs.MLTableJobInputResponse'] = None,
                 test_data_size: Optional[builtins.float] = None,
                 training_settings: Optional['outputs.ClassificationTrainingSettingsResponse'] = None,
                 validation_data: Optional['outputs.MLTableJobInputResponse'] = None,
                 validation_data_size: Optional[builtins.float] = None,
                 weight_column_name: Optional[builtins.str] = None):
        """
        Classification task in AutoML Table vertical.
        :param builtins.str task_type: AutoMLJob Task type.
               Expected value is 'Classification'.
        :param 'MLTableJobInputResponse' training_data: [Required] Training data input.
        :param Sequence[builtins.str] cv_split_column_names: Columns to use for CVSplit data.
        :param 'TableVerticalFeaturizationSettingsResponse' featurization_settings: Featurization inputs needed for AutoML job.
        :param 'TableVerticalLimitSettingsResponse' limit_settings: Execution constraints for AutoMLJob.
        :param builtins.str log_verbosity: Log verbosity for the job.
        :param Union['AutoNCrossValidationsResponse', 'CustomNCrossValidationsResponse'] n_cross_validations: Number of cross validation folds to be applied on training dataset
               when validation dataset is not provided.
        :param builtins.str positive_label: Positive label for binary metrics calculation.
        :param builtins.str primary_metric: Primary metric for the task.
        :param builtins.str target_column_name: Target column name: This is prediction values column.
               Also known as label column name in context of classification tasks.
        :param 'MLTableJobInputResponse' test_data: Test data input.
        :param builtins.float test_data_size: The fraction of test dataset that needs to be set aside for validation purpose.
               Values between (0.0 , 1.0)
               Applied when validation dataset is not provided.
        :param 'ClassificationTrainingSettingsResponse' training_settings: Inputs for training phase for an AutoML Job.
        :param 'MLTableJobInputResponse' validation_data: Validation data inputs.
        :param builtins.float validation_data_size: The fraction of training dataset that needs to be set aside for validation purpose.
               Values between (0.0 , 1.0)
               Applied when validation dataset is not provided.
        :param builtins.str weight_column_name: The name of the sample weight column. Automated ML supports a weighted column as an input, causing rows in the data to be weighted up or down.
        """
        pulumi.set(__self__, "task_type", 'Classification')
        pulumi.set(__self__, "training_data", training_data)
        if cv_split_column_names is not None:
            pulumi.set(__self__, "cv_split_column_names", cv_split_column_names)
        if featurization_settings is not None:
            pulumi.set(__self__, "featurization_settings", featurization_settings)
        if limit_settings is not None:
            pulumi.set(__self__, "limit_settings", limit_settings)
        if log_verbosity is None:
            log_verbosity = 'Info'
        if log_verbosity is not None:
            pulumi.set(__self__, "log_verbosity", log_verbosity)
        if n_cross_validations is not None:
            pulumi.set(__self__, "n_cross_validations", n_cross_validations)
        if positive_label is not None:
            pulumi.set(__self__, "positive_label", positive_label)
        if primary_metric is None:
            primary_metric = 'AUCWeighted'
        if primary_metric is not None:
            pulumi.set(__self__, "primary_metric", primary_metric)
        if target_column_name is not None:
            pulumi.set(__self__, "target_column_name", target_column_name)
        if test_data is not None:
            pulumi.set(__self__, "test_data", test_data)
        if test_data_size is not None:
            pulumi.set(__self__, "test_data_size", test_data_size)
        if training_settings is not None:
            pulumi.set(__self__, "training_settings", training_settings)
        if validation_data is not None:
            pulumi.set(__self__, "validation_data", validation_data)
        if validation_data_size is not None:
            pulumi.set(__self__, "validation_data_size", validation_data_size)
        if weight_column_name is not None:
            pulumi.set(__self__, "weight_column_name", weight_column_name)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> builtins.str:
        """
        AutoMLJob Task type.
        Expected value is 'Classification'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="trainingData")
    def training_data(self) -> 'outputs.MLTableJobInputResponse':
        """
        [Required] Training data input.
        """
        return pulumi.get(self, "training_data")

    @property
    @pulumi.getter(name="cvSplitColumnNames")
    def cv_split_column_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Columns to use for CVSplit data.
        """
        return pulumi.get(self, "cv_split_column_names")

    @property
    @pulumi.getter(name="featurizationSettings")
    def featurization_settings(self) -> Optional['outputs.TableVerticalFeaturizationSettingsResponse']:
        """
        Featurization inputs needed for AutoML job.
        """
        return pulumi.get(self, "featurization_settings")

    @property
    @pulumi.getter(name="limitSettings")
    def limit_settings(self) -> Optional['outputs.TableVerticalLimitSettingsResponse']:
        """
        Execution constraints for AutoMLJob.
        """
        return pulumi.get(self, "limit_settings")

    @property
    @pulumi.getter(name="logVerbosity")
    def log_verbosity(self) -> Optional[builtins.str]:
        """
        Log verbosity for the job.
        """
        return pulumi.get(self, "log_verbosity")

    @property
    @pulumi.getter(name="nCrossValidations")
    def n_cross_validations(self) -> Optional[Any]:
        """
        Number of cross validation folds to be applied on training dataset
        when validation dataset is not provided.
        """
        return pulumi.get(self, "n_cross_validations")

    @property
    @pulumi.getter(name="positiveLabel")
    def positive_label(self) -> Optional[builtins.str]:
        """
        Positive label for binary metrics calculation.
        """
        return pulumi.get(self, "positive_label")

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> Optional[builtins.str]:
        """
        Primary metric for the task.
        """
        return pulumi.get(self, "primary_metric")

    @property
    @pulumi.getter(name="targetColumnName")
    def target_column_name(self) -> Optional[builtins.str]:
        """
        Target column name: This is prediction values column.
        Also known as label column name in context of classification tasks.
        """
        return pulumi.get(self, "target_column_name")

    @property
    @pulumi.getter(name="testData")
    def test_data(self) -> Optional['outputs.MLTableJobInputResponse']:
        """
        Test data input.
        """
        return pulumi.get(self, "test_data")

    @property
    @pulumi.getter(name="testDataSize")
    def test_data_size(self) -> Optional[builtins.float]:
        """
        The fraction of test dataset that needs to be set aside for validation purpose.
        Values between (0.0 , 1.0)
        Applied when validation dataset is not provided.
        """
        return pulumi.get(self, "test_data_size")

    @property
    @pulumi.getter(name="trainingSettings")
    def training_settings(self) -> Optional['outputs.ClassificationTrainingSettingsResponse']:
        """
        Inputs for training phase for an AutoML Job.
        """
        return pulumi.get(self, "training_settings")

    @property
    @pulumi.getter(name="validationData")
    def validation_data(self) -> Optional['outputs.MLTableJobInputResponse']:
        """
        Validation data inputs.
        """
        return pulumi.get(self, "validation_data")

    @property
    @pulumi.getter(name="validationDataSize")
    def validation_data_size(self) -> Optional[builtins.float]:
        """
        The fraction of training dataset that needs to be set aside for validation purpose.
        Values between (0.0 , 1.0)
        Applied when validation dataset is not provided.
        """
        return pulumi.get(self, "validation_data_size")

    @property
    @pulumi.getter(name="weightColumnName")
    def weight_column_name(self) -> Optional[builtins.str]:
        """
        The name of the sample weight column. Automated ML supports a weighted column as an input, causing rows in the data to be weighted up or down.
        """
        return pulumi.get(self, "weight_column_name")


@pulumi.output_type
class ClassificationTrainingSettingsResponse(dict):
    """
    Classification Training related configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedTrainingAlgorithms":
            suggest = "allowed_training_algorithms"
        elif key == "blockedTrainingAlgorithms":
            suggest = "blocked_training_algorithms"
        elif key == "enableDnnTraining":
            suggest = "enable_dnn_training"
        elif key == "enableModelExplainability":
            suggest = "enable_model_explainability"
        elif key == "enableOnnxCompatibleModels":
            suggest = "enable_onnx_compatible_models"
        elif key == "enableStackEnsemble":
            suggest = "enable_stack_ensemble"
        elif key == "enableVoteEnsemble":
            suggest = "enable_vote_ensemble"
        elif key == "ensembleModelDownloadTimeout":
            suggest = "ensemble_model_download_timeout"
        elif key == "stackEnsembleSettings":
            suggest = "stack_ensemble_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClassificationTrainingSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClassificationTrainingSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClassificationTrainingSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_training_algorithms: Optional[Sequence[builtins.str]] = None,
                 blocked_training_algorithms: Optional[Sequence[builtins.str]] = None,
                 enable_dnn_training: Optional[builtins.bool] = None,
                 enable_model_explainability: Optional[builtins.bool] = None,
                 enable_onnx_compatible_models: Optional[builtins.bool] = None,
                 enable_stack_ensemble: Optional[builtins.bool] = None,
                 enable_vote_ensemble: Optional[builtins.bool] = None,
                 ensemble_model_download_timeout: Optional[builtins.str] = None,
                 stack_ensemble_settings: Optional['outputs.StackEnsembleSettingsResponse'] = None):
        """
        Classification Training related configuration.
        :param Sequence[builtins.str] allowed_training_algorithms: Allowed models for classification task.
        :param Sequence[builtins.str] blocked_training_algorithms: Blocked models for classification task.
        :param builtins.bool enable_dnn_training: Enable recommendation of DNN models.
        :param builtins.bool enable_model_explainability: Flag to turn on explainability on best model.
        :param builtins.bool enable_onnx_compatible_models: Flag for enabling onnx compatible models.
        :param builtins.bool enable_stack_ensemble: Enable stack ensemble run.
        :param builtins.bool enable_vote_ensemble: Enable voting ensemble run.
        :param builtins.str ensemble_model_download_timeout: During VotingEnsemble and StackEnsemble model generation, multiple fitted models from the previous child runs are downloaded.
               Configure this parameter with a higher value than 300 secs, if more time is needed.
        :param 'StackEnsembleSettingsResponse' stack_ensemble_settings: Stack ensemble settings for stack ensemble run.
        """
        if allowed_training_algorithms is not None:
            pulumi.set(__self__, "allowed_training_algorithms", allowed_training_algorithms)
        if blocked_training_algorithms is not None:
            pulumi.set(__self__, "blocked_training_algorithms", blocked_training_algorithms)
        if enable_dnn_training is None:
            enable_dnn_training = False
        if enable_dnn_training is not None:
            pulumi.set(__self__, "enable_dnn_training", enable_dnn_training)
        if enable_model_explainability is None:
            enable_model_explainability = True
        if enable_model_explainability is not None:
            pulumi.set(__self__, "enable_model_explainability", enable_model_explainability)
        if enable_onnx_compatible_models is None:
            enable_onnx_compatible_models = False
        if enable_onnx_compatible_models is not None:
            pulumi.set(__self__, "enable_onnx_compatible_models", enable_onnx_compatible_models)
        if enable_stack_ensemble is None:
            enable_stack_ensemble = True
        if enable_stack_ensemble is not None:
            pulumi.set(__self__, "enable_stack_ensemble", enable_stack_ensemble)
        if enable_vote_ensemble is None:
            enable_vote_ensemble = True
        if enable_vote_ensemble is not None:
            pulumi.set(__self__, "enable_vote_ensemble", enable_vote_ensemble)
        if ensemble_model_download_timeout is None:
            ensemble_model_download_timeout = 'PT5M'
        if ensemble_model_download_timeout is not None:
            pulumi.set(__self__, "ensemble_model_download_timeout", ensemble_model_download_timeout)
        if stack_ensemble_settings is not None:
            pulumi.set(__self__, "stack_ensemble_settings", stack_ensemble_settings)

    @property
    @pulumi.getter(name="allowedTrainingAlgorithms")
    def allowed_training_algorithms(self) -> Optional[Sequence[builtins.str]]:
        """
        Allowed models for classification task.
        """
        return pulumi.get(self, "allowed_training_algorithms")

    @property
    @pulumi.getter(name="blockedTrainingAlgorithms")
    def blocked_training_algorithms(self) -> Optional[Sequence[builtins.str]]:
        """
        Blocked models for classification task.
        """
        return pulumi.get(self, "blocked_training_algorithms")

    @property
    @pulumi.getter(name="enableDnnTraining")
    def enable_dnn_training(self) -> Optional[builtins.bool]:
        """
        Enable recommendation of DNN models.
        """
        return pulumi.get(self, "enable_dnn_training")

    @property
    @pulumi.getter(name="enableModelExplainability")
    def enable_model_explainability(self) -> Optional[builtins.bool]:
        """
        Flag to turn on explainability on best model.
        """
        return pulumi.get(self, "enable_model_explainability")

    @property
    @pulumi.getter(name="enableOnnxCompatibleModels")
    def enable_onnx_compatible_models(self) -> Optional[builtins.bool]:
        """
        Flag for enabling onnx compatible models.
        """
        return pulumi.get(self, "enable_onnx_compatible_models")

    @property
    @pulumi.getter(name="enableStackEnsemble")
    def enable_stack_ensemble(self) -> Optional[builtins.bool]:
        """
        Enable stack ensemble run.
        """
        return pulumi.get(self, "enable_stack_ensemble")

    @property
    @pulumi.getter(name="enableVoteEnsemble")
    def enable_vote_ensemble(self) -> Optional[builtins.bool]:
        """
        Enable voting ensemble run.
        """
        return pulumi.get(self, "enable_vote_ensemble")

    @property
    @pulumi.getter(name="ensembleModelDownloadTimeout")
    def ensemble_model_download_timeout(self) -> Optional[builtins.str]:
        """
        During VotingEnsemble and StackEnsemble model generation, multiple fitted models from the previous child runs are downloaded.
        Configure this parameter with a higher value than 300 secs, if more time is needed.
        """
        return pulumi.get(self, "ensemble_model_download_timeout")

    @property
    @pulumi.getter(name="stackEnsembleSettings")
    def stack_ensemble_settings(self) -> Optional['outputs.StackEnsembleSettingsResponse']:
        """
        Stack ensemble settings for stack ensemble run.
        """
        return pulumi.get(self, "stack_ensemble_settings")


@pulumi.output_type
class ClientCredentialsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorityUrl":
            suggest = "authority_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "isCertAuth":
            suggest = "is_cert_auth"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "resourceUri":
            suggest = "resource_uri"
        elif key == "serviceDataAccessAuthIdentity":
            suggest = "service_data_access_auth_identity"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authority_url: Optional[builtins.str] = None,
                 certificate: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 is_cert_auth: Optional[builtins.bool] = None,
                 resource_group: Optional[builtins.str] = None,
                 resource_uri: Optional[builtins.str] = None,
                 service_data_access_auth_identity: Optional[builtins.str] = None,
                 subscription_id: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None,
                 thumbprint: Optional[builtins.str] = None):
        """
        :param builtins.str authority_url: The authority URL used for authentication.
        :param builtins.str certificate: The content of the certificate used for authentication.
        :param builtins.str client_id: The Client ID/Application ID
        :param builtins.str client_secret: The client secret.
        :param builtins.bool is_cert_auth:  Is it using certificate to authenticate. If false then use client secret.
        :param builtins.str resource_group: Resource Group.
        :param builtins.str resource_uri: The resource the service principal/app has access to.
        :param builtins.str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param builtins.str subscription_id: Subscription ID.
        :param builtins.str tenant_id: The ID of the tenant the service principal/app belongs to.
        :param builtins.str thumbprint: The thumbprint of the certificate above.
        """
        if authority_url is not None:
            pulumi.set(__self__, "authority_url", authority_url)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if is_cert_auth is not None:
            pulumi.set(__self__, "is_cert_auth", is_cert_auth)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if resource_uri is not None:
            pulumi.set(__self__, "resource_uri", resource_uri)
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)

    @property
    @pulumi.getter(name="authorityUrl")
    def authority_url(self) -> Optional[builtins.str]:
        """
        The authority URL used for authentication.
        """
        return pulumi.get(self, "authority_url")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[builtins.str]:
        """
        The content of the certificate used for authentication.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        The Client ID/Application ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="isCertAuth")
    def is_cert_auth(self) -> Optional[builtins.bool]:
        """
         Is it using certificate to authenticate. If false then use client secret.
        """
        return pulumi.get(self, "is_cert_auth")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[builtins.str]:
        """
        Resource Group.
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[builtins.str]:
        """
        The resource the service principal/app has access to.
        """
        return pulumi.get(self, "resource_uri")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[builtins.str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[builtins.str]:
        """
        Subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        """
        The ID of the tenant the service principal/app belongs to.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[builtins.str]:
        """
        The thumbprint of the certificate above.
        """
        return pulumi.get(self, "thumbprint")


@pulumi.output_type
class CodeConfigurationResponse(dict):
    """
    Configuration for a scoring code asset.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scoringScript":
            suggest = "scoring_script"
        elif key == "codeId":
            suggest = "code_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scoring_script: builtins.str,
                 code_id: Optional[builtins.str] = None):
        """
        Configuration for a scoring code asset.
        :param builtins.str scoring_script: [Required] The script to execute on startup. eg. "score.py"
        :param builtins.str code_id: ARM resource ID of the code asset.
        """
        pulumi.set(__self__, "scoring_script", scoring_script)
        if code_id is not None:
            pulumi.set(__self__, "code_id", code_id)

    @property
    @pulumi.getter(name="scoringScript")
    def scoring_script(self) -> builtins.str:
        """
        [Required] The script to execute on startup. eg. "score.py"
        """
        return pulumi.get(self, "scoring_script")

    @property
    @pulumi.getter(name="codeId")
    def code_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of the code asset.
        """
        return pulumi.get(self, "code_id")


@pulumi.output_type
class CodeContainerResponse(dict):
    """
    Container for code asset versions.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latestVersion":
            suggest = "latest_version"
        elif key == "nextVersion":
            suggest = "next_version"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeContainerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeContainerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeContainerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latest_version: builtins.str,
                 next_version: builtins.str,
                 provisioning_state: builtins.str,
                 description: Optional[builtins.str] = None,
                 is_archived: Optional[builtins.bool] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Container for code asset versions.
        :param builtins.str latest_version: The latest version inside this container.
        :param builtins.str next_version: The next auto incremental version
        :param builtins.str provisioning_state: Provisioning state for the code container.
        :param builtins.str description: The asset description text.
        :param builtins.bool is_archived: Is the asset archived?
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "latest_version", latest_version)
        pulumi.set(__self__, "next_version", next_version)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> builtins.str:
        """
        The latest version inside this container.
        """
        return pulumi.get(self, "latest_version")

    @property
    @pulumi.getter(name="nextVersion")
    def next_version(self) -> builtins.str:
        """
        The next auto incremental version
        """
        return pulumi.get(self, "next_version")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the code container.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CodeVersionResponse(dict):
    """
    Code asset version details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "codeUri":
            suggest = "code_uri"
        elif key == "isAnonymous":
            suggest = "is_anonymous"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 code_uri: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 is_anonymous: Optional[builtins.bool] = None,
                 is_archived: Optional[builtins.bool] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Code asset version details.
        :param builtins.str provisioning_state: Provisioning state for the code version.
        :param builtins.str code_uri: Uri where code is located
        :param builtins.str description: The asset description text.
        :param builtins.bool is_anonymous: If the name version are system generated (anonymous registration).
        :param builtins.bool is_archived: Is the asset archived?
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if code_uri is not None:
            pulumi.set(__self__, "code_uri", code_uri)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_anonymous is None:
            is_anonymous = False
        if is_anonymous is not None:
            pulumi.set(__self__, "is_anonymous", is_anonymous)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the code version.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="codeUri")
    def code_uri(self) -> Optional[builtins.str]:
        """
        Uri where code is located
        """
        return pulumi.get(self, "code_uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[builtins.bool]:
        """
        If the name version are system generated (anonymous registration).
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CognitiveServicesSkuResponse(dict):
    def __init__(__self__, *,
                 capacity: Optional[builtins.int] = None,
                 family: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 size: Optional[builtins.str] = None,
                 tier: Optional[builtins.str] = None):
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[builtins.int]:
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def family(self) -> Optional[builtins.str]:
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def size(self) -> Optional[builtins.str]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def tier(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tier")


@pulumi.output_type
class CollectionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "dataCollectionMode":
            suggest = "data_collection_mode"
        elif key == "dataId":
            suggest = "data_id"
        elif key == "samplingRate":
            suggest = "sampling_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CollectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CollectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CollectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[builtins.str] = None,
                 data_collection_mode: Optional[builtins.str] = None,
                 data_id: Optional[builtins.str] = None,
                 sampling_rate: Optional[builtins.float] = None):
        """
        :param builtins.str client_id: The msi client id used to collect logging to blob storage. If it's null,backend will pick a registered endpoint identity to auth.
        :param builtins.str data_collection_mode: Enable or disable data collection.
        :param builtins.str data_id: The data asset arm resource id. Client side will ensure data asset is pointing to the blob storage, and backend will collect data to the blob storage.
        :param builtins.float sampling_rate: The sampling rate for collection. Sampling rate 1.0 means we collect 100% of data by default.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if data_collection_mode is None:
            data_collection_mode = 'Disabled'
        if data_collection_mode is not None:
            pulumi.set(__self__, "data_collection_mode", data_collection_mode)
        if data_id is not None:
            pulumi.set(__self__, "data_id", data_id)
        if sampling_rate is None:
            sampling_rate = 1
        if sampling_rate is not None:
            pulumi.set(__self__, "sampling_rate", sampling_rate)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        The msi client id used to collect logging to blob storage. If it's null,backend will pick a registered endpoint identity to auth.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="dataCollectionMode")
    def data_collection_mode(self) -> Optional[builtins.str]:
        """
        Enable or disable data collection.
        """
        return pulumi.get(self, "data_collection_mode")

    @property
    @pulumi.getter(name="dataId")
    def data_id(self) -> Optional[builtins.str]:
        """
        The data asset arm resource id. Client side will ensure data asset is pointing to the blob storage, and backend will collect data to the blob storage.
        """
        return pulumi.get(self, "data_id")

    @property
    @pulumi.getter(name="samplingRate")
    def sampling_rate(self) -> Optional[builtins.float]:
        """
        The sampling rate for collection. Sampling rate 1.0 means we collect 100% of data by default.
        """
        return pulumi.get(self, "sampling_rate")


@pulumi.output_type
class ColumnTransformerResponse(dict):
    """
    Column transformer parameters.
    """
    def __init__(__self__, *,
                 fields: Optional[Sequence[builtins.str]] = None,
                 parameters: Optional[Any] = None):
        """
        Column transformer parameters.
        :param Sequence[builtins.str] fields: Fields to apply transformer logic on.
        :param Any parameters: Different properties to be passed to transformer.
               Input expected is dictionary of key,value pairs in JSON format.
        """
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def fields(self) -> Optional[Sequence[builtins.str]]:
        """
        Fields to apply transformer logic on.
        """
        return pulumi.get(self, "fields")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Any]:
        """
        Different properties to be passed to transformer.
        Input expected is dictionary of key,value pairs in JSON format.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class CommandJobLimitsResponse(dict):
    """
    Command Job limit class.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobLimitsType":
            suggest = "job_limits_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CommandJobLimitsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CommandJobLimitsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CommandJobLimitsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_limits_type: builtins.str,
                 timeout: Optional[builtins.str] = None):
        """
        Command Job limit class.
        :param builtins.str job_limits_type: 
               Expected value is 'Command'.
        :param builtins.str timeout: The max run duration in ISO 8601 format, after which the job will be cancelled. Only supports duration with precision as low as Seconds.
        """
        pulumi.set(__self__, "job_limits_type", 'Command')
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="jobLimitsType")
    def job_limits_type(self) -> builtins.str:
        """

        Expected value is 'Command'.
        """
        return pulumi.get(self, "job_limits_type")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[builtins.str]:
        """
        The max run duration in ISO 8601 format, after which the job will be cancelled. Only supports duration with precision as low as Seconds.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class CommandJobResponse(dict):
    """
    Command job definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentId":
            suggest = "environment_id"
        elif key == "jobType":
            suggest = "job_type"
        elif key == "codeId":
            suggest = "code_id"
        elif key == "componentId":
            suggest = "component_id"
        elif key == "computeId":
            suggest = "compute_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "experimentName":
            suggest = "experiment_name"
        elif key == "isArchived":
            suggest = "is_archived"
        elif key == "notificationSetting":
            suggest = "notification_setting"
        elif key == "queueSettings":
            suggest = "queue_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CommandJobResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CommandJobResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CommandJobResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command: builtins.str,
                 environment_id: builtins.str,
                 job_type: builtins.str,
                 parameters: Any,
                 status: builtins.str,
                 code_id: Optional[builtins.str] = None,
                 component_id: Optional[builtins.str] = None,
                 compute_id: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 display_name: Optional[builtins.str] = None,
                 distribution: Optional[Any] = None,
                 environment_variables: Optional[Mapping[str, builtins.str]] = None,
                 experiment_name: Optional[builtins.str] = None,
                 identity: Optional[Any] = None,
                 inputs: Optional[Mapping[str, Any]] = None,
                 is_archived: Optional[builtins.bool] = None,
                 limits: Optional['outputs.CommandJobLimitsResponse'] = None,
                 notification_setting: Optional['outputs.NotificationSettingResponse'] = None,
                 outputs: Optional[Mapping[str, Any]] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 queue_settings: Optional['outputs.QueueSettingsResponse'] = None,
                 resources: Optional['outputs.JobResourceConfigurationResponse'] = None,
                 services: Optional[Mapping[str, 'outputs.JobServiceResponse']] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Command job definition.
        :param builtins.str command: [Required] The command to execute on startup of the job. eg. "python train.py"
        :param builtins.str environment_id: [Required] The ARM resource ID of the Environment specification for the job.
        :param builtins.str job_type: Enum to determine the type of job.
               Expected value is 'Command'.
        :param Any parameters: Input parameters.
        :param builtins.str status: Status of the job.
        :param builtins.str code_id: ARM resource ID of the code asset.
        :param builtins.str component_id: ARM resource ID of the component resource.
        :param builtins.str compute_id: ARM resource ID of the compute resource.
        :param builtins.str description: The asset description text.
        :param builtins.str display_name: Display name of job.
        :param Union['MpiResponse', 'PyTorchResponse', 'TensorFlowResponse'] distribution: Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, or null.
        :param Mapping[str, builtins.str] environment_variables: Environment variables included in the job.
        :param builtins.str experiment_name: The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        :param Union['AmlTokenResponse', 'ManagedIdentityResponse', 'UserIdentityResponse'] identity: Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
               Defaults to AmlToken if null.
        :param Mapping[str, Union['CustomModelJobInputResponse', 'LiteralJobInputResponse', 'MLFlowModelJobInputResponse', 'MLTableJobInputResponse', 'TritonModelJobInputResponse', 'UriFileJobInputResponse', 'UriFolderJobInputResponse']] inputs: Mapping of input data bindings used in the job.
        :param builtins.bool is_archived: Is the asset archived?
        :param 'CommandJobLimitsResponse' limits: Command Job limit.
        :param 'NotificationSettingResponse' notification_setting: Notification setting for the job
        :param Mapping[str, Union['CustomModelJobOutputResponse', 'MLFlowModelJobOutputResponse', 'MLTableJobOutputResponse', 'TritonModelJobOutputResponse', 'UriFileJobOutputResponse', 'UriFolderJobOutputResponse']] outputs: Mapping of output data bindings used in the job.
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param 'QueueSettingsResponse' queue_settings: Queue settings for the job
        :param 'JobResourceConfigurationResponse' resources: Compute Resource configuration for the job.
        :param Mapping[str, 'JobServiceResponse'] services: List of JobEndpoints.
               For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "command", command)
        pulumi.set(__self__, "environment_id", environment_id)
        pulumi.set(__self__, "job_type", 'Command')
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "status", status)
        if code_id is not None:
            pulumi.set(__self__, "code_id", code_id)
        if component_id is not None:
            pulumi.set(__self__, "component_id", component_id)
        if compute_id is not None:
            pulumi.set(__self__, "compute_id", compute_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if distribution is not None:
            pulumi.set(__self__, "distribution", distribution)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if experiment_name is None:
            experiment_name = 'Default'
        if experiment_name is not None:
            pulumi.set(__self__, "experiment_name", experiment_name)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if notification_setting is not None:
            pulumi.set(__self__, "notification_setting", notification_setting)
        if outputs is not None:
            pulumi.set(__self__, "outputs", outputs)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if queue_settings is not None:
            pulumi.set(__self__, "queue_settings", queue_settings)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def command(self) -> builtins.str:
        """
        [Required] The command to execute on startup of the job. eg. "python train.py"
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> builtins.str:
        """
        [Required] The ARM resource ID of the Environment specification for the job.
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="jobType")
    def job_type(self) -> builtins.str:
        """
        Enum to determine the type of job.
        Expected value is 'Command'.
        """
        return pulumi.get(self, "job_type")

    @property
    @pulumi.getter
    def parameters(self) -> Any:
        """
        Input parameters.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Status of the job.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="codeId")
    def code_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of the code asset.
        """
        return pulumi.get(self, "code_id")

    @property
    @pulumi.getter(name="componentId")
    def component_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of the component resource.
        """
        return pulumi.get(self, "component_id")

    @property
    @pulumi.getter(name="computeId")
    def compute_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of the compute resource.
        """
        return pulumi.get(self, "compute_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        Display name of job.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def distribution(self) -> Optional[Any]:
        """
        Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, or null.
        """
        return pulumi.get(self, "distribution")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Environment variables included in the job.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="experimentName")
    def experiment_name(self) -> Optional[builtins.str]:
        """
        The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        """
        return pulumi.get(self, "experiment_name")

    @property
    @pulumi.getter
    def identity(self) -> Optional[Any]:
        """
        Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
        Defaults to AmlToken if null.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter
    def inputs(self) -> Optional[Mapping[str, Any]]:
        """
        Mapping of input data bindings used in the job.
        """
        return pulumi.get(self, "inputs")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def limits(self) -> Optional['outputs.CommandJobLimitsResponse']:
        """
        Command Job limit.
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter(name="notificationSetting")
    def notification_setting(self) -> Optional['outputs.NotificationSettingResponse']:
        """
        Notification setting for the job
        """
        return pulumi.get(self, "notification_setting")

    @property
    @pulumi.getter
    def outputs(self) -> Optional[Mapping[str, Any]]:
        """
        Mapping of output data bindings used in the job.
        """
        return pulumi.get(self, "outputs")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="queueSettings")
    def queue_settings(self) -> Optional['outputs.QueueSettingsResponse']:
        """
        Queue settings for the job
        """
        return pulumi.get(self, "queue_settings")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.JobResourceConfigurationResponse']:
        """
        Compute Resource configuration for the job.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def services(self) -> Optional[Mapping[str, 'outputs.JobServiceResponse']]:
        """
        List of JobEndpoints.
        For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ComponentContainerResponse(dict):
    """
    Component container definition.
    <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latestVersion":
            suggest = "latest_version"
        elif key == "nextVersion":
            suggest = "next_version"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComponentContainerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComponentContainerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComponentContainerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latest_version: builtins.str,
                 next_version: builtins.str,
                 provisioning_state: builtins.str,
                 description: Optional[builtins.str] = None,
                 is_archived: Optional[builtins.bool] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Component container definition.
        <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
        :param builtins.str latest_version: The latest version inside this container.
        :param builtins.str next_version: The next auto incremental version
        :param builtins.str provisioning_state: Provisioning state for the component container.
        :param builtins.str description: The asset description text.
        :param builtins.bool is_archived: Is the asset archived?
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "latest_version", latest_version)
        pulumi.set(__self__, "next_version", next_version)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> builtins.str:
        """
        The latest version inside this container.
        """
        return pulumi.get(self, "latest_version")

    @property
    @pulumi.getter(name="nextVersion")
    def next_version(self) -> builtins.str:
        """
        The next auto incremental version
        """
        return pulumi.get(self, "next_version")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the component container.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ComponentVersionResponse(dict):
    """
    Definition of a component version: defines resources that span component types.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "componentSpec":
            suggest = "component_spec"
        elif key == "isAnonymous":
            suggest = "is_anonymous"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComponentVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComponentVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComponentVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 component_spec: Optional[Any] = None,
                 description: Optional[builtins.str] = None,
                 is_anonymous: Optional[builtins.bool] = None,
                 is_archived: Optional[builtins.bool] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Definition of a component version: defines resources that span component types.
        :param builtins.str provisioning_state: Provisioning state for the component version.
        :param Any component_spec: Defines Component definition details.
               <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
        :param builtins.str description: The asset description text.
        :param builtins.bool is_anonymous: If the name version are system generated (anonymous registration).
        :param builtins.bool is_archived: Is the asset archived?
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if component_spec is not None:
            pulumi.set(__self__, "component_spec", component_spec)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_anonymous is None:
            is_anonymous = False
        if is_anonymous is not None:
            pulumi.set(__self__, "is_anonymous", is_anonymous)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the component version.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="componentSpec")
    def component_spec(self) -> Optional[Any]:
        """
        Defines Component definition details.
        <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
        """
        return pulumi.get(self, "component_spec")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[builtins.bool]:
        """
        If the name version are system generated (anonymous registration).
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ComputeInstanceApplicationResponse(dict):
    """
    Defines an Aml Instance application and its connectivity endpoint URI.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "endpointUri":
            suggest = "endpoint_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceApplicationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceApplicationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceApplicationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[builtins.str] = None,
                 endpoint_uri: Optional[builtins.str] = None):
        """
        Defines an Aml Instance application and its connectivity endpoint URI.
        :param builtins.str display_name: Name of the ComputeInstance application.
        :param builtins.str endpoint_uri: Application' endpoint URI.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if endpoint_uri is not None:
            pulumi.set(__self__, "endpoint_uri", endpoint_uri)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        Name of the ComputeInstance application.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="endpointUri")
    def endpoint_uri(self) -> Optional[builtins.str]:
        """
        Application' endpoint URI.
        """
        return pulumi.get(self, "endpoint_uri")


@pulumi.output_type
class ComputeInstanceConnectivityEndpointsResponse(dict):
    """
    Defines all connectivity endpoints and properties for an ComputeInstance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "publicIpAddress":
            suggest = "public_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceConnectivityEndpointsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceConnectivityEndpointsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceConnectivityEndpointsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_ip_address: builtins.str,
                 public_ip_address: builtins.str):
        """
        Defines all connectivity endpoints and properties for an ComputeInstance.
        :param builtins.str private_ip_address: Private IP Address of this ComputeInstance (local to the VNET in which the compute instance is deployed).
        :param builtins.str public_ip_address: Public IP Address of this ComputeInstance.
        """
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        pulumi.set(__self__, "public_ip_address", public_ip_address)

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> builtins.str:
        """
        Private IP Address of this ComputeInstance (local to the VNET in which the compute instance is deployed).
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> builtins.str:
        """
        Public IP Address of this ComputeInstance.
        """
        return pulumi.get(self, "public_ip_address")


@pulumi.output_type
class ComputeInstanceContainerResponse(dict):
    """
    Defines an Aml Instance container.
    """
    def __init__(__self__, *,
                 services: Sequence[Any],
                 autosave: Optional[builtins.str] = None,
                 environment: Optional['outputs.ComputeInstanceEnvironmentInfoResponse'] = None,
                 gpu: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 network: Optional[builtins.str] = None):
        """
        Defines an Aml Instance container.
        :param Sequence[Any] services: services of this containers.
        :param builtins.str autosave: Auto save settings.
        :param 'ComputeInstanceEnvironmentInfoResponse' environment: Environment information of this container.
        :param builtins.str gpu: Information of GPU.
        :param builtins.str name: Name of the ComputeInstance container.
        :param builtins.str network: network of this container.
        """
        pulumi.set(__self__, "services", services)
        if autosave is not None:
            pulumi.set(__self__, "autosave", autosave)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if gpu is not None:
            pulumi.set(__self__, "gpu", gpu)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def services(self) -> Sequence[Any]:
        """
        services of this containers.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def autosave(self) -> Optional[builtins.str]:
        """
        Auto save settings.
        """
        return pulumi.get(self, "autosave")

    @property
    @pulumi.getter
    def environment(self) -> Optional['outputs.ComputeInstanceEnvironmentInfoResponse']:
        """
        Environment information of this container.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def gpu(self) -> Optional[builtins.str]:
        """
        Information of GPU.
        """
        return pulumi.get(self, "gpu")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the ComputeInstance container.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def network(self) -> Optional[builtins.str]:
        """
        network of this container.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class ComputeInstanceCreatedByResponse(dict):
    """
    Describes information on user who created this ComputeInstance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userId":
            suggest = "user_id"
        elif key == "userName":
            suggest = "user_name"
        elif key == "userOrgId":
            suggest = "user_org_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceCreatedByResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceCreatedByResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceCreatedByResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_id: builtins.str,
                 user_name: builtins.str,
                 user_org_id: builtins.str):
        """
        Describes information on user who created this ComputeInstance.
        :param builtins.str user_id: Uniquely identifies the user within his/her organization.
        :param builtins.str user_name: Name of the user.
        :param builtins.str user_org_id: Uniquely identifies user' Azure Active Directory organization.
        """
        pulumi.set(__self__, "user_id", user_id)
        pulumi.set(__self__, "user_name", user_name)
        pulumi.set(__self__, "user_org_id", user_org_id)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> builtins.str:
        """
        Uniquely identifies the user within his/her organization.
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> builtins.str:
        """
        Name of the user.
        """
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter(name="userOrgId")
    def user_org_id(self) -> builtins.str:
        """
        Uniquely identifies user' Azure Active Directory organization.
        """
        return pulumi.get(self, "user_org_id")


@pulumi.output_type
class ComputeInstanceDataDiskResponse(dict):
    """
    Defines an Aml Instance DataDisk.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSizeGB":
            suggest = "disk_size_gb"
        elif key == "storageAccountType":
            suggest = "storage_account_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceDataDiskResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceDataDiskResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceDataDiskResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 caching: Optional[builtins.str] = None,
                 disk_size_gb: Optional[builtins.int] = None,
                 lun: Optional[builtins.int] = None,
                 storage_account_type: Optional[builtins.str] = None):
        """
        Defines an Aml Instance DataDisk.
        :param builtins.str caching: Caching type of Data Disk.
        :param builtins.int disk_size_gb: The initial disk size in gigabytes.
        :param builtins.int lun: The lun is used to uniquely identify each data disk. If attaching multiple disks, each should have a distinct lun.
        :param builtins.str storage_account_type: type of this storage account.
        """
        if caching is not None:
            pulumi.set(__self__, "caching", caching)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if lun is not None:
            pulumi.set(__self__, "lun", lun)
        if storage_account_type is None:
            storage_account_type = 'Standard_LRS'
        if storage_account_type is not None:
            pulumi.set(__self__, "storage_account_type", storage_account_type)

    @property
    @pulumi.getter
    def caching(self) -> Optional[builtins.str]:
        """
        Caching type of Data Disk.
        """
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter(name="diskSizeGB")
    def disk_size_gb(self) -> Optional[builtins.int]:
        """
        The initial disk size in gigabytes.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter
    def lun(self) -> Optional[builtins.int]:
        """
        The lun is used to uniquely identify each data disk. If attaching multiple disks, each should have a distinct lun.
        """
        return pulumi.get(self, "lun")

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> Optional[builtins.str]:
        """
        type of this storage account.
        """
        return pulumi.get(self, "storage_account_type")


@pulumi.output_type
class ComputeInstanceDataMountResponse(dict):
    """
    Defines an Aml Instance DataMount.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdBy":
            suggest = "created_by"
        elif key == "mountAction":
            suggest = "mount_action"
        elif key == "mountName":
            suggest = "mount_name"
        elif key == "mountPath":
            suggest = "mount_path"
        elif key == "mountState":
            suggest = "mount_state"
        elif key == "mountedOn":
            suggest = "mounted_on"
        elif key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceDataMountResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceDataMountResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceDataMountResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_by: Optional[builtins.str] = None,
                 error: Optional[builtins.str] = None,
                 mount_action: Optional[builtins.str] = None,
                 mount_name: Optional[builtins.str] = None,
                 mount_path: Optional[builtins.str] = None,
                 mount_state: Optional[builtins.str] = None,
                 mounted_on: Optional[builtins.str] = None,
                 source: Optional[builtins.str] = None,
                 source_type: Optional[builtins.str] = None):
        """
        Defines an Aml Instance DataMount.
        :param builtins.str created_by: who this data mount created by.
        :param builtins.str error: Error of this data mount.
        :param builtins.str mount_action: Mount Action.
        :param builtins.str mount_name: name of the ComputeInstance data mount.
        :param builtins.str mount_path: Path of this data mount.
        :param builtins.str mount_state: Mount state.
        :param builtins.str mounted_on: The time when the disk mounted.
        :param builtins.str source: Source of the ComputeInstance data mount.
        :param builtins.str source_type: Data source type.
        """
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if error is not None:
            pulumi.set(__self__, "error", error)
        if mount_action is not None:
            pulumi.set(__self__, "mount_action", mount_action)
        if mount_name is not None:
            pulumi.set(__self__, "mount_name", mount_name)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)
        if mount_state is not None:
            pulumi.set(__self__, "mount_state", mount_state)
        if mounted_on is not None:
            pulumi.set(__self__, "mounted_on", mounted_on)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[builtins.str]:
        """
        who this data mount created by.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter
    def error(self) -> Optional[builtins.str]:
        """
        Error of this data mount.
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter(name="mountAction")
    def mount_action(self) -> Optional[builtins.str]:
        """
        Mount Action.
        """
        return pulumi.get(self, "mount_action")

    @property
    @pulumi.getter(name="mountName")
    def mount_name(self) -> Optional[builtins.str]:
        """
        name of the ComputeInstance data mount.
        """
        return pulumi.get(self, "mount_name")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[builtins.str]:
        """
        Path of this data mount.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter(name="mountState")
    def mount_state(self) -> Optional[builtins.str]:
        """
        Mount state.
        """
        return pulumi.get(self, "mount_state")

    @property
    @pulumi.getter(name="mountedOn")
    def mounted_on(self) -> Optional[builtins.str]:
        """
        The time when the disk mounted.
        """
        return pulumi.get(self, "mounted_on")

    @property
    @pulumi.getter
    def source(self) -> Optional[builtins.str]:
        """
        Source of the ComputeInstance data mount.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[builtins.str]:
        """
        Data source type.
        """
        return pulumi.get(self, "source_type")


@pulumi.output_type
class ComputeInstanceEnvironmentInfoResponse(dict):
    """
    Environment information
    """
    def __init__(__self__, *,
                 name: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        Environment information
        :param builtins.str name: name of environment.
        :param builtins.str version: version of environment.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        name of environment.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        version of environment.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class ComputeInstanceLastOperationResponse(dict):
    """
    The last operation on ComputeInstance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operationName":
            suggest = "operation_name"
        elif key == "operationStatus":
            suggest = "operation_status"
        elif key == "operationTime":
            suggest = "operation_time"
        elif key == "operationTrigger":
            suggest = "operation_trigger"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceLastOperationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceLastOperationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceLastOperationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operation_name: Optional[builtins.str] = None,
                 operation_status: Optional[builtins.str] = None,
                 operation_time: Optional[builtins.str] = None,
                 operation_trigger: Optional[builtins.str] = None):
        """
        The last operation on ComputeInstance.
        :param builtins.str operation_name: Name of the last operation.
        :param builtins.str operation_status: Operation status.
        :param builtins.str operation_time: Time of the last operation.
        :param builtins.str operation_trigger: Trigger of operation.
        """
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if operation_status is not None:
            pulumi.set(__self__, "operation_status", operation_status)
        if operation_time is not None:
            pulumi.set(__self__, "operation_time", operation_time)
        if operation_trigger is not None:
            pulumi.set(__self__, "operation_trigger", operation_trigger)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[builtins.str]:
        """
        Name of the last operation.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="operationStatus")
    def operation_status(self) -> Optional[builtins.str]:
        """
        Operation status.
        """
        return pulumi.get(self, "operation_status")

    @property
    @pulumi.getter(name="operationTime")
    def operation_time(self) -> Optional[builtins.str]:
        """
        Time of the last operation.
        """
        return pulumi.get(self, "operation_time")

    @property
    @pulumi.getter(name="operationTrigger")
    def operation_trigger(self) -> Optional[builtins.str]:
        """
        Trigger of operation.
        """
        return pulumi.get(self, "operation_trigger")


@pulumi.output_type
class ComputeInstancePropertiesResponse(dict):
    """
    Compute Instance properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectivityEndpoints":
            suggest = "connectivity_endpoints"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "dataDisks":
            suggest = "data_disks"
        elif key == "dataMounts":
            suggest = "data_mounts"
        elif key == "lastOperation":
            suggest = "last_operation"
        elif key == "osImageMetadata":
            suggest = "os_image_metadata"
        elif key == "applicationSharingPolicy":
            suggest = "application_sharing_policy"
        elif key == "computeInstanceAuthorizationType":
            suggest = "compute_instance_authorization_type"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "enableNodePublicIp":
            suggest = "enable_node_public_ip"
        elif key == "personalComputeInstanceSettings":
            suggest = "personal_compute_instance_settings"
        elif key == "setupScripts":
            suggest = "setup_scripts"
        elif key == "sshSettings":
            suggest = "ssh_settings"
        elif key == "vmSize":
            suggest = "vm_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstancePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstancePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstancePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applications: Sequence['outputs.ComputeInstanceApplicationResponse'],
                 connectivity_endpoints: 'outputs.ComputeInstanceConnectivityEndpointsResponse',
                 containers: Sequence['outputs.ComputeInstanceContainerResponse'],
                 created_by: 'outputs.ComputeInstanceCreatedByResponse',
                 data_disks: Sequence['outputs.ComputeInstanceDataDiskResponse'],
                 data_mounts: Sequence['outputs.ComputeInstanceDataMountResponse'],
                 errors: Sequence['outputs.ErrorResponseResponse'],
                 last_operation: 'outputs.ComputeInstanceLastOperationResponse',
                 os_image_metadata: 'outputs.ImageMetadataResponse',
                 state: builtins.str,
                 versions: 'outputs.ComputeInstanceVersionResponse',
                 application_sharing_policy: Optional[builtins.str] = None,
                 compute_instance_authorization_type: Optional[builtins.str] = None,
                 custom_services: Optional[Sequence['outputs.CustomServiceResponse']] = None,
                 enable_node_public_ip: Optional[builtins.bool] = None,
                 personal_compute_instance_settings: Optional['outputs.PersonalComputeInstanceSettingsResponse'] = None,
                 schedules: Optional['outputs.ComputeSchedulesResponse'] = None,
                 setup_scripts: Optional['outputs.SetupScriptsResponse'] = None,
                 ssh_settings: Optional['outputs.ComputeInstanceSshSettingsResponse'] = None,
                 subnet: Optional['outputs.ResourceIdResponse'] = None,
                 vm_size: Optional[builtins.str] = None):
        """
        Compute Instance properties
        :param Sequence['ComputeInstanceApplicationResponse'] applications: Describes available applications and their endpoints on this ComputeInstance.
        :param 'ComputeInstanceConnectivityEndpointsResponse' connectivity_endpoints: Describes all connectivity endpoints available for this ComputeInstance.
        :param Sequence['ComputeInstanceContainerResponse'] containers: Describes informations of containers on this ComputeInstance.
        :param 'ComputeInstanceCreatedByResponse' created_by: Describes information on user who created this ComputeInstance.
        :param Sequence['ComputeInstanceDataDiskResponse'] data_disks: Describes informations of dataDisks on this ComputeInstance.
        :param Sequence['ComputeInstanceDataMountResponse'] data_mounts: Describes informations of dataMounts on this ComputeInstance.
        :param Sequence['ErrorResponseResponse'] errors: Collection of errors encountered on this ComputeInstance.
        :param 'ComputeInstanceLastOperationResponse' last_operation: The last operation on ComputeInstance.
        :param 'ImageMetadataResponse' os_image_metadata: Returns metadata about the operating system image for this compute instance.
        :param builtins.str state: The current state of this ComputeInstance.
        :param 'ComputeInstanceVersionResponse' versions: ComputeInstance version.
        :param builtins.str application_sharing_policy: Policy for sharing applications on this compute instance among users of parent workspace. If Personal, only the creator can access applications on this compute instance. When Shared, any workspace user can access applications on this instance depending on his/her assigned role.
        :param builtins.str compute_instance_authorization_type: The Compute Instance Authorization type. Available values are personal (default).
        :param Sequence['CustomServiceResponse'] custom_services: List of Custom Services added to the compute.
        :param builtins.bool enable_node_public_ip: Enable or disable node public IP address provisioning. Possible values are: Possible values are: true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will have a private endpoint and no public IPs.
        :param 'PersonalComputeInstanceSettingsResponse' personal_compute_instance_settings: Settings for a personal compute instance.
        :param 'ComputeSchedulesResponse' schedules: The list of schedules to be applied on the computes.
        :param 'SetupScriptsResponse' setup_scripts: Details of customized scripts to execute for setting up the cluster.
        :param 'ComputeInstanceSshSettingsResponse' ssh_settings: Specifies policy and settings for SSH access.
        :param 'ResourceIdResponse' subnet: Virtual network subnet resource ID the compute nodes belong to.
        :param builtins.str vm_size: Virtual Machine Size
        """
        pulumi.set(__self__, "applications", applications)
        pulumi.set(__self__, "connectivity_endpoints", connectivity_endpoints)
        pulumi.set(__self__, "containers", containers)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "data_disks", data_disks)
        pulumi.set(__self__, "data_mounts", data_mounts)
        pulumi.set(__self__, "errors", errors)
        pulumi.set(__self__, "last_operation", last_operation)
        pulumi.set(__self__, "os_image_metadata", os_image_metadata)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "versions", versions)
        if application_sharing_policy is None:
            application_sharing_policy = 'Shared'
        if application_sharing_policy is not None:
            pulumi.set(__self__, "application_sharing_policy", application_sharing_policy)
        if compute_instance_authorization_type is None:
            compute_instance_authorization_type = 'personal'
        if compute_instance_authorization_type is not None:
            pulumi.set(__self__, "compute_instance_authorization_type", compute_instance_authorization_type)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if enable_node_public_ip is not None:
            pulumi.set(__self__, "enable_node_public_ip", enable_node_public_ip)
        if personal_compute_instance_settings is not None:
            pulumi.set(__self__, "personal_compute_instance_settings", personal_compute_instance_settings)
        if schedules is not None:
            pulumi.set(__self__, "schedules", schedules)
        if setup_scripts is not None:
            pulumi.set(__self__, "setup_scripts", setup_scripts)
        if ssh_settings is not None:
            pulumi.set(__self__, "ssh_settings", ssh_settings)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if vm_size is not None:
            pulumi.set(__self__, "vm_size", vm_size)

    @property
    @pulumi.getter
    def applications(self) -> Sequence['outputs.ComputeInstanceApplicationResponse']:
        """
        Describes available applications and their endpoints on this ComputeInstance.
        """
        return pulumi.get(self, "applications")

    @property
    @pulumi.getter(name="connectivityEndpoints")
    def connectivity_endpoints(self) -> 'outputs.ComputeInstanceConnectivityEndpointsResponse':
        """
        Describes all connectivity endpoints available for this ComputeInstance.
        """
        return pulumi.get(self, "connectivity_endpoints")

    @property
    @pulumi.getter
    def containers(self) -> Sequence['outputs.ComputeInstanceContainerResponse']:
        """
        Describes informations of containers on this ComputeInstance.
        """
        return pulumi.get(self, "containers")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> 'outputs.ComputeInstanceCreatedByResponse':
        """
        Describes information on user who created this ComputeInstance.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Sequence['outputs.ComputeInstanceDataDiskResponse']:
        """
        Describes informations of dataDisks on this ComputeInstance.
        """
        return pulumi.get(self, "data_disks")

    @property
    @pulumi.getter(name="dataMounts")
    def data_mounts(self) -> Sequence['outputs.ComputeInstanceDataMountResponse']:
        """
        Describes informations of dataMounts on this ComputeInstance.
        """
        return pulumi.get(self, "data_mounts")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ErrorResponseResponse']:
        """
        Collection of errors encountered on this ComputeInstance.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter(name="lastOperation")
    def last_operation(self) -> 'outputs.ComputeInstanceLastOperationResponse':
        """
        The last operation on ComputeInstance.
        """
        return pulumi.get(self, "last_operation")

    @property
    @pulumi.getter(name="osImageMetadata")
    def os_image_metadata(self) -> 'outputs.ImageMetadataResponse':
        """
        Returns metadata about the operating system image for this compute instance.
        """
        return pulumi.get(self, "os_image_metadata")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        The current state of this ComputeInstance.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def versions(self) -> 'outputs.ComputeInstanceVersionResponse':
        """
        ComputeInstance version.
        """
        return pulumi.get(self, "versions")

    @property
    @pulumi.getter(name="applicationSharingPolicy")
    def application_sharing_policy(self) -> Optional[builtins.str]:
        """
        Policy for sharing applications on this compute instance among users of parent workspace. If Personal, only the creator can access applications on this compute instance. When Shared, any workspace user can access applications on this instance depending on his/her assigned role.
        """
        return pulumi.get(self, "application_sharing_policy")

    @property
    @pulumi.getter(name="computeInstanceAuthorizationType")
    def compute_instance_authorization_type(self) -> Optional[builtins.str]:
        """
        The Compute Instance Authorization type. Available values are personal (default).
        """
        return pulumi.get(self, "compute_instance_authorization_type")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.CustomServiceResponse']]:
        """
        List of Custom Services added to the compute.
        """
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter(name="enableNodePublicIp")
    def enable_node_public_ip(self) -> Optional[builtins.bool]:
        """
        Enable or disable node public IP address provisioning. Possible values are: Possible values are: true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will have a private endpoint and no public IPs.
        """
        return pulumi.get(self, "enable_node_public_ip")

    @property
    @pulumi.getter(name="personalComputeInstanceSettings")
    def personal_compute_instance_settings(self) -> Optional['outputs.PersonalComputeInstanceSettingsResponse']:
        """
        Settings for a personal compute instance.
        """
        return pulumi.get(self, "personal_compute_instance_settings")

    @property
    @pulumi.getter
    def schedules(self) -> Optional['outputs.ComputeSchedulesResponse']:
        """
        The list of schedules to be applied on the computes.
        """
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter(name="setupScripts")
    def setup_scripts(self) -> Optional['outputs.SetupScriptsResponse']:
        """
        Details of customized scripts to execute for setting up the cluster.
        """
        return pulumi.get(self, "setup_scripts")

    @property
    @pulumi.getter(name="sshSettings")
    def ssh_settings(self) -> Optional['outputs.ComputeInstanceSshSettingsResponse']:
        """
        Specifies policy and settings for SSH access.
        """
        return pulumi.get(self, "ssh_settings")

    @property
    @pulumi.getter
    def subnet(self) -> Optional['outputs.ResourceIdResponse']:
        """
        Virtual network subnet resource ID the compute nodes belong to.
        """
        return pulumi.get(self, "subnet")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> Optional[builtins.str]:
        """
        Virtual Machine Size
        """
        return pulumi.get(self, "vm_size")


@pulumi.output_type
class ComputeInstanceResponse(dict):
    """
    An Azure Machine Learning compute instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeType":
            suggest = "compute_type"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "isAttachedCompute":
            suggest = "is_attached_compute"
        elif key == "modifiedOn":
            suggest = "modified_on"
        elif key == "provisioningErrors":
            suggest = "provisioning_errors"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "computeLocation":
            suggest = "compute_location"
        elif key == "disableLocalAuth":
            suggest = "disable_local_auth"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_type: builtins.str,
                 created_on: builtins.str,
                 is_attached_compute: builtins.bool,
                 modified_on: builtins.str,
                 provisioning_errors: Sequence['outputs.ErrorResponseResponse'],
                 provisioning_state: builtins.str,
                 compute_location: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 disable_local_auth: Optional[builtins.bool] = None,
                 properties: Optional['outputs.ComputeInstancePropertiesResponse'] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        An Azure Machine Learning compute instance.
        :param builtins.str compute_type: The type of compute
               Expected value is 'ComputeInstance'.
        :param builtins.str created_on: The time at which the compute was created.
        :param builtins.bool is_attached_compute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        :param builtins.str modified_on: The time at which the compute was last modified.
        :param Sequence['ErrorResponseResponse'] provisioning_errors: Errors during provisioning
        :param builtins.str provisioning_state: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        :param builtins.str compute_location: Location for the underlying compute
        :param builtins.str description: The description of the Machine Learning compute.
        :param builtins.bool disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        :param 'ComputeInstancePropertiesResponse' properties: Properties of ComputeInstance
        :param builtins.str resource_id: ARM resource id of the underlying compute
        """
        pulumi.set(__self__, "compute_type", 'ComputeInstance')
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "is_attached_compute", is_attached_compute)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "provisioning_errors", provisioning_errors)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if compute_location is not None:
            pulumi.set(__self__, "compute_location", compute_location)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_local_auth is not None:
            pulumi.set(__self__, "disable_local_auth", disable_local_auth)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> builtins.str:
        """
        The type of compute
        Expected value is 'ComputeInstance'.
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> builtins.str:
        """
        The time at which the compute was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="isAttachedCompute")
    def is_attached_compute(self) -> builtins.bool:
        """
        Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        """
        return pulumi.get(self, "is_attached_compute")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> builtins.str:
        """
        The time at which the compute was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="provisioningErrors")
    def provisioning_errors(self) -> Sequence['outputs.ErrorResponseResponse']:
        """
        Errors during provisioning
        """
        return pulumi.get(self, "provisioning_errors")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[builtins.str]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[builtins.bool]:
        """
        Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        """
        return pulumi.get(self, "disable_local_auth")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.ComputeInstancePropertiesResponse']:
        """
        Properties of ComputeInstance
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class ComputeInstanceSshSettingsResponse(dict):
    """
    Specifies policy and settings for SSH access.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUserName":
            suggest = "admin_user_name"
        elif key == "sshPort":
            suggest = "ssh_port"
        elif key == "adminPublicKey":
            suggest = "admin_public_key"
        elif key == "sshPublicAccess":
            suggest = "ssh_public_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceSshSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceSshSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceSshSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_user_name: builtins.str,
                 ssh_port: builtins.int,
                 admin_public_key: Optional[builtins.str] = None,
                 ssh_public_access: Optional[builtins.str] = None):
        """
        Specifies policy and settings for SSH access.
        :param builtins.str admin_user_name: Describes the admin user name.
        :param builtins.int ssh_port: Describes the port for connecting through SSH.
        :param builtins.str admin_public_key: Specifies the SSH rsa public key file as a string. Use "ssh-keygen -t rsa -b 2048" to generate your SSH key pairs.
        :param builtins.str ssh_public_access: State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on this instance. Enabled - Indicates that the public ssh port is open and accessible according to the VNet/subnet policy if applicable.
        """
        pulumi.set(__self__, "admin_user_name", admin_user_name)
        pulumi.set(__self__, "ssh_port", ssh_port)
        if admin_public_key is not None:
            pulumi.set(__self__, "admin_public_key", admin_public_key)
        if ssh_public_access is None:
            ssh_public_access = 'Disabled'
        if ssh_public_access is not None:
            pulumi.set(__self__, "ssh_public_access", ssh_public_access)

    @property
    @pulumi.getter(name="adminUserName")
    def admin_user_name(self) -> builtins.str:
        """
        Describes the admin user name.
        """
        return pulumi.get(self, "admin_user_name")

    @property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> builtins.int:
        """
        Describes the port for connecting through SSH.
        """
        return pulumi.get(self, "ssh_port")

    @property
    @pulumi.getter(name="adminPublicKey")
    def admin_public_key(self) -> Optional[builtins.str]:
        """
        Specifies the SSH rsa public key file as a string. Use "ssh-keygen -t rsa -b 2048" to generate your SSH key pairs.
        """
        return pulumi.get(self, "admin_public_key")

    @property
    @pulumi.getter(name="sshPublicAccess")
    def ssh_public_access(self) -> Optional[builtins.str]:
        """
        State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on this instance. Enabled - Indicates that the public ssh port is open and accessible according to the VNet/subnet policy if applicable.
        """
        return pulumi.get(self, "ssh_public_access")


@pulumi.output_type
class ComputeInstanceVersionResponse(dict):
    """
    Version of computeInstance.
    """
    def __init__(__self__, *,
                 runtime: Optional[builtins.str] = None):
        """
        Version of computeInstance.
        :param builtins.str runtime: Runtime of compute instance.
        """
        if runtime is not None:
            pulumi.set(__self__, "runtime", runtime)

    @property
    @pulumi.getter
    def runtime(self) -> Optional[builtins.str]:
        """
        Runtime of compute instance.
        """
        return pulumi.get(self, "runtime")


@pulumi.output_type
class ComputeRecurrenceScheduleResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monthDays":
            suggest = "month_days"
        elif key == "weekDays":
            suggest = "week_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeRecurrenceScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeRecurrenceScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeRecurrenceScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hours: Sequence[builtins.int],
                 minutes: Sequence[builtins.int],
                 month_days: Optional[Sequence[builtins.int]] = None,
                 week_days: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.int] hours: [Required] List of hours for the schedule.
        :param Sequence[builtins.int] minutes: [Required] List of minutes for the schedule.
        :param Sequence[builtins.int] month_days: List of month days for the schedule
        :param Sequence[builtins.str] week_days: List of days for the schedule.
        """
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)
        if month_days is not None:
            pulumi.set(__self__, "month_days", month_days)
        if week_days is not None:
            pulumi.set(__self__, "week_days", week_days)

    @property
    @pulumi.getter
    def hours(self) -> Sequence[builtins.int]:
        """
        [Required] List of hours for the schedule.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Sequence[builtins.int]:
        """
        [Required] List of minutes for the schedule.
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter(name="monthDays")
    def month_days(self) -> Optional[Sequence[builtins.int]]:
        """
        List of month days for the schedule
        """
        return pulumi.get(self, "month_days")

    @property
    @pulumi.getter(name="weekDays")
    def week_days(self) -> Optional[Sequence[builtins.str]]:
        """
        List of days for the schedule.
        """
        return pulumi.get(self, "week_days")


@pulumi.output_type
class ComputeRuntimeDtoResponse(dict):
    """
    Compute runtime config for feature store type workspace.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sparkRuntimeVersion":
            suggest = "spark_runtime_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeRuntimeDtoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeRuntimeDtoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeRuntimeDtoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 spark_runtime_version: Optional[builtins.str] = None):
        """
        Compute runtime config for feature store type workspace.
        """
        if spark_runtime_version is not None:
            pulumi.set(__self__, "spark_runtime_version", spark_runtime_version)

    @property
    @pulumi.getter(name="sparkRuntimeVersion")
    def spark_runtime_version(self) -> Optional[builtins.str]:
        return pulumi.get(self, "spark_runtime_version")


@pulumi.output_type
class ComputeSchedulesResponse(dict):
    """
    The list of schedules to be applied on the computes
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeStartStop":
            suggest = "compute_start_stop"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeSchedulesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeSchedulesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeSchedulesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_start_stop: Optional[Sequence['outputs.ComputeStartStopScheduleResponse']] = None):
        """
        The list of schedules to be applied on the computes
        :param Sequence['ComputeStartStopScheduleResponse'] compute_start_stop: The list of compute start stop schedules to be applied.
        """
        if compute_start_stop is not None:
            pulumi.set(__self__, "compute_start_stop", compute_start_stop)

    @property
    @pulumi.getter(name="computeStartStop")
    def compute_start_stop(self) -> Optional[Sequence['outputs.ComputeStartStopScheduleResponse']]:
        """
        The list of compute start stop schedules to be applied.
        """
        return pulumi.get(self, "compute_start_stop")


@pulumi.output_type
class ComputeStartStopScheduleResponse(dict):
    """
    Compute start stop schedule properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningStatus":
            suggest = "provisioning_status"
        elif key == "triggerType":
            suggest = "trigger_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeStartStopScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeStartStopScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeStartStopScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: builtins.str,
                 provisioning_status: builtins.str,
                 action: Optional[builtins.str] = None,
                 cron: Optional['outputs.CronResponse'] = None,
                 recurrence: Optional['outputs.RecurrenceResponse'] = None,
                 schedule: Optional['outputs.ScheduleBaseResponse'] = None,
                 status: Optional[builtins.str] = None,
                 trigger_type: Optional[builtins.str] = None):
        """
        Compute start stop schedule properties
        :param builtins.str id: A system assigned id for the schedule.
        :param builtins.str provisioning_status: The current deployment state of schedule.
        :param builtins.str action: [Required] The compute power action.
        :param 'CronResponse' cron: Required if triggerType is Cron.
        :param 'RecurrenceResponse' recurrence: Required if triggerType is Recurrence.
        :param 'ScheduleBaseResponse' schedule: [Deprecated] Not used any more.
        :param builtins.str status: Is the schedule enabled or disabled?
        :param builtins.str trigger_type: [Required] The schedule trigger type.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "provisioning_status", provisioning_status)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if cron is not None:
            pulumi.set(__self__, "cron", cron)
        if recurrence is not None:
            pulumi.set(__self__, "recurrence", recurrence)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        A system assigned id for the schedule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="provisioningStatus")
    def provisioning_status(self) -> builtins.str:
        """
        The current deployment state of schedule.
        """
        return pulumi.get(self, "provisioning_status")

    @property
    @pulumi.getter
    def action(self) -> Optional[builtins.str]:
        """
        [Required] The compute power action.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def cron(self) -> Optional['outputs.CronResponse']:
        """
        Required if triggerType is Cron.
        """
        return pulumi.get(self, "cron")

    @property
    @pulumi.getter
    def recurrence(self) -> Optional['outputs.RecurrenceResponse']:
        """
        Required if triggerType is Recurrence.
        """
        return pulumi.get(self, "recurrence")

    @property
    @pulumi.getter
    def schedule(self) -> Optional['outputs.ScheduleBaseResponse']:
        """
        [Deprecated] Not used any more.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Is the schedule enabled or disabled?
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[builtins.str]:
        """
        [Required] The schedule trigger type.
        """
        return pulumi.get(self, "trigger_type")


@pulumi.output_type
class ContainerResourceRequirementsResponse(dict):
    """
    Resource requirements for each container instance within an online deployment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerResourceLimits":
            suggest = "container_resource_limits"
        elif key == "containerResourceRequests":
            suggest = "container_resource_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerResourceRequirementsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerResourceRequirementsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerResourceRequirementsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_resource_limits: Optional['outputs.ContainerResourceSettingsResponse'] = None,
                 container_resource_requests: Optional['outputs.ContainerResourceSettingsResponse'] = None):
        """
        Resource requirements for each container instance within an online deployment.
        :param 'ContainerResourceSettingsResponse' container_resource_limits: Container resource limit info:
        :param 'ContainerResourceSettingsResponse' container_resource_requests: Container resource request info:
        """
        if container_resource_limits is not None:
            pulumi.set(__self__, "container_resource_limits", container_resource_limits)
        if container_resource_requests is not None:
            pulumi.set(__self__, "container_resource_requests", container_resource_requests)

    @property
    @pulumi.getter(name="containerResourceLimits")
    def container_resource_limits(self) -> Optional['outputs.ContainerResourceSettingsResponse']:
        """
        Container resource limit info:
        """
        return pulumi.get(self, "container_resource_limits")

    @property
    @pulumi.getter(name="containerResourceRequests")
    def container_resource_requests(self) -> Optional['outputs.ContainerResourceSettingsResponse']:
        """
        Container resource request info:
        """
        return pulumi.get(self, "container_resource_requests")


@pulumi.output_type
class ContainerResourceSettingsResponse(dict):
    def __init__(__self__, *,
                 cpu: Optional[builtins.str] = None,
                 gpu: Optional[builtins.str] = None,
                 memory: Optional[builtins.str] = None):
        """
        :param builtins.str cpu: Number of vCPUs request/limit for container. More info:
               https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param builtins.str gpu: Number of Nvidia GPU cards request/limit for container. More info:
               https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param builtins.str memory: Memory size request/limit for container. More info:
               https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if gpu is not None:
            pulumi.set(__self__, "gpu", gpu)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[builtins.str]:
        """
        Number of vCPUs request/limit for container. More info:
        https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def gpu(self) -> Optional[builtins.str]:
        """
        Number of Nvidia GPU cards request/limit for container. More info:
        https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "gpu")

    @property
    @pulumi.getter
    def memory(self) -> Optional[builtins.str]:
        """
        Memory size request/limit for container. More info:
        https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class ContentSafetyEndpointDeploymentResourcePropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "failureReason":
            suggest = "failure_reason"
        elif key == "raiPolicyName":
            suggest = "rai_policy_name"
        elif key == "versionUpgradeOption":
            suggest = "version_upgrade_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContentSafetyEndpointDeploymentResourcePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContentSafetyEndpointDeploymentResourcePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContentSafetyEndpointDeploymentResourcePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model: 'outputs.EndpointDeploymentModelResponse',
                 provisioning_state: builtins.str,
                 type: builtins.str,
                 failure_reason: Optional[builtins.str] = None,
                 rai_policy_name: Optional[builtins.str] = None,
                 sku: Optional['outputs.CognitiveServicesSkuResponse'] = None,
                 version_upgrade_option: Optional[builtins.str] = None):
        """
        :param 'EndpointDeploymentModelResponse' model: Model used for the endpoint deployment.
        :param builtins.str provisioning_state: Read-only provision state status property.
        :param builtins.str type: Kind of the deployment.
               Expected value is 'Azure.ContentSafety'.
        :param builtins.str failure_reason: The failure reason if the creation failed.
        :param builtins.str rai_policy_name: The name of RAI policy.
        :param builtins.str version_upgrade_option: Deployment model version upgrade option.
        """
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "type", 'Azure.ContentSafety')
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if rai_policy_name is not None:
            pulumi.set(__self__, "rai_policy_name", rai_policy_name)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)
        if version_upgrade_option is not None:
            pulumi.set(__self__, "version_upgrade_option", version_upgrade_option)

    @property
    @pulumi.getter
    def model(self) -> 'outputs.EndpointDeploymentModelResponse':
        """
        Model used for the endpoint deployment.
        """
        return pulumi.get(self, "model")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Read-only provision state status property.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Kind of the deployment.
        Expected value is 'Azure.ContentSafety'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[builtins.str]:
        """
        The failure reason if the creation failed.
        """
        return pulumi.get(self, "failure_reason")

    @property
    @pulumi.getter(name="raiPolicyName")
    def rai_policy_name(self) -> Optional[builtins.str]:
        """
        The name of RAI policy.
        """
        return pulumi.get(self, "rai_policy_name")

    @property
    @pulumi.getter
    def sku(self) -> Optional['outputs.CognitiveServicesSkuResponse']:
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter(name="versionUpgradeOption")
    def version_upgrade_option(self) -> Optional[builtins.str]:
        """
        Deployment model version upgrade option.
        """
        return pulumi.get(self, "version_upgrade_option")


@pulumi.output_type
class ContentSafetyResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentSafetyStatus":
            suggest = "content_safety_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContentSafetyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContentSafetyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContentSafetyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_safety_status: builtins.str):
        """
        :param builtins.str content_safety_status: [Required] Specifies the status of content safety.
        """
        pulumi.set(__self__, "content_safety_status", content_safety_status)

    @property
    @pulumi.getter(name="contentSafetyStatus")
    def content_safety_status(self) -> builtins.str:
        """
        [Required] Specifies the status of content safety.
        """
        return pulumi.get(self, "content_safety_status")


@pulumi.output_type
class CosmosDbSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionsThroughput":
            suggest = "collections_throughput"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CosmosDbSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CosmosDbSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CosmosDbSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collections_throughput: Optional[builtins.int] = None):
        """
        :param builtins.int collections_throughput: The throughput of the collections in cosmosdb database
        """
        if collections_throughput is not None:
            pulumi.set(__self__, "collections_throughput", collections_throughput)

    @property
    @pulumi.getter(name="collectionsThroughput")
    def collections_throughput(self) -> Optional[builtins.int]:
        """
        The throughput of the collections in cosmosdb database
        """
        return pulumi.get(self, "collections_throughput")


@pulumi.output_type
class CreateMonitorActionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "monitorDefinition":
            suggest = "monitor_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CreateMonitorActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CreateMonitorActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CreateMonitorActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: builtins.str,
                 monitor_definition: 'outputs.MonitorDefinitionResponse'):
        """
        :param builtins.str action_type: 
               Expected value is 'CreateMonitor'.
        :param 'MonitorDefinitionResponse' monitor_definition: [Required] Defines the monitor.
        """
        pulumi.set(__self__, "action_type", 'CreateMonitor')
        pulumi.set(__self__, "monitor_definition", monitor_definition)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> builtins.str:
        """

        Expected value is 'CreateMonitor'.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="monitorDefinition")
    def monitor_definition(self) -> 'outputs.MonitorDefinitionResponse':
        """
        [Required] Defines the monitor.
        """
        return pulumi.get(self, "monitor_definition")


@pulumi.output_type
class CronResponse(dict):
    """
    The workflow trigger cron for ComputeStartStop schedule type.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CronResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CronResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CronResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: Optional[builtins.str] = None,
                 start_time: Optional[builtins.str] = None,
                 time_zone: Optional[builtins.str] = None):
        """
        The workflow trigger cron for ComputeStartStop schedule type.
        :param builtins.str expression: [Required] Specifies cron expression of schedule.
               The expression should follow NCronTab format.
        :param builtins.str start_time: The start time in yyyy-MM-ddTHH:mm:ss format.
        :param builtins.str time_zone: Specifies time zone in which the schedule runs.
               TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if time_zone is None:
            time_zone = 'UTC'
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def expression(self) -> Optional[builtins.str]:
        """
        [Required] Specifies cron expression of schedule.
        The expression should follow NCronTab format.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[builtins.str]:
        """
        The start time in yyyy-MM-ddTHH:mm:ss format.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[builtins.str]:
        """
        Specifies time zone in which the schedule runs.
        TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class CronTriggerResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "triggerType":
            suggest = "trigger_type"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CronTriggerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CronTriggerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CronTriggerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: builtins.str,
                 trigger_type: builtins.str,
                 end_time: Optional[builtins.str] = None,
                 start_time: Optional[builtins.str] = None,
                 time_zone: Optional[builtins.str] = None):
        """
        :param builtins.str expression: [Required] Specifies cron expression of schedule.
               The expression should follow NCronTab format.
        :param builtins.str trigger_type: 
               Expected value is 'Cron'.
        :param builtins.str end_time: Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer https://en.wikipedia.org/wiki/ISO_8601.
               Recommented format would be "2022-06-01T00:00:01"
               If not present, the schedule will run indefinitely
        :param builtins.str start_time: Specifies start time of schedule in ISO 8601 format, but without a UTC offset.
        :param builtins.str time_zone: Specifies time zone in which the schedule runs.
               TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "trigger_type", 'Cron')
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if time_zone is None:
            time_zone = 'UTC'
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        """
        [Required] Specifies cron expression of schedule.
        The expression should follow NCronTab format.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> builtins.str:
        """

        Expected value is 'Cron'.
        """
        return pulumi.get(self, "trigger_type")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[builtins.str]:
        """
        Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer https://en.wikipedia.org/wiki/ISO_8601.
        Recommented format would be "2022-06-01T00:00:01"
        If not present, the schedule will run indefinitely
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[builtins.str]:
        """
        Specifies start time of schedule in ISO 8601 format, but without a UTC offset.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[builtins.str]:
        """
        Specifies time zone in which the schedule runs.
        TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class CustomForecastHorizonResponse(dict):
    """
    The desired maximum forecast horizon in units of time-series frequency.
    """
    def __init__(__self__, *,
                 mode: builtins.str,
                 value: builtins.int):
        """
        The desired maximum forecast horizon in units of time-series frequency.
        :param builtins.str mode: Enum to determine forecast horizon selection mode.
               Expected value is 'Custom'.
        :param builtins.int value: [Required] Forecast horizon value.
        """
        pulumi.set(__self__, "mode", 'Custom')
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def mode(self) -> builtins.str:
        """
        Enum to determine forecast horizon selection mode.
        Expected value is 'Custom'.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def value(self) -> builtins.int:
        """
        [Required] Forecast horizon value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomKeysResponse(dict):
    """
    Custom Keys credential object
    """
    def __init__(__self__, *,
                 keys: Optional[Mapping[str, builtins.str]] = None):
        """
        Custom Keys credential object
        """
        if keys is not None:
            pulumi.set(__self__, "keys", keys)

    @property
    @pulumi.getter
    def keys(self) -> Optional[Mapping[str, builtins.str]]:
        return pulumi.get(self, "keys")


@pulumi.output_type
class CustomKeysWorkspaceConnectionPropertiesResponse(dict):
    """
    Category:= CustomKeys
    AuthType:= CustomKeys (as type discriminator)
    Credentials:= {CustomKeys} as Microsoft.MachineLearning.AccountRP.Contracts.WorkspaceConnection.CustomKeys
    Target:= {any value}
    Use Metadata property bag for ApiVersion and other metadata fields
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "createdByWorkspaceArmId":
            suggest = "created_by_workspace_arm_id"
        elif key == "expiryTime":
            suggest = "expiry_time"
        elif key == "isSharedToAll":
            suggest = "is_shared_to_all"
        elif key == "sharedUserList":
            suggest = "shared_user_list"
        elif key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomKeysWorkspaceConnectionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomKeysWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomKeysWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: builtins.str,
                 created_by_workspace_arm_id: builtins.str,
                 group: builtins.str,
                 category: Optional[builtins.str] = None,
                 credentials: Optional['outputs.CustomKeysResponse'] = None,
                 expiry_time: Optional[builtins.str] = None,
                 is_shared_to_all: Optional[builtins.bool] = None,
                 metadata: Optional[Mapping[str, builtins.str]] = None,
                 shared_user_list: Optional[Sequence[builtins.str]] = None,
                 target: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None,
                 value_format: Optional[builtins.str] = None):
        """
        Category:= CustomKeys
        AuthType:= CustomKeys (as type discriminator)
        Credentials:= {CustomKeys} as Microsoft.MachineLearning.AccountRP.Contracts.WorkspaceConnection.CustomKeys
        Target:= {any value}
        Use Metadata property bag for ApiVersion and other metadata fields
        :param builtins.str auth_type: Authentication type of the connection target
               Expected value is 'CustomKeys'.
        :param builtins.str group: Group based on connection category
        :param builtins.str category: Category of the connection
        :param 'CustomKeysResponse' credentials: Custom Keys credential object
        :param Mapping[str, builtins.str] metadata: Store user metadata for this connection
        :param builtins.str value: Value details of the workspace connection.
        :param builtins.str value_format: format for the workspace connection value
        """
        pulumi.set(__self__, "auth_type", 'CustomKeys')
        pulumi.set(__self__, "created_by_workspace_arm_id", created_by_workspace_arm_id)
        pulumi.set(__self__, "group", group)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if expiry_time is not None:
            pulumi.set(__self__, "expiry_time", expiry_time)
        if is_shared_to_all is not None:
            pulumi.set(__self__, "is_shared_to_all", is_shared_to_all)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if shared_user_list is not None:
            pulumi.set(__self__, "shared_user_list", shared_user_list)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> builtins.str:
        """
        Authentication type of the connection target
        Expected value is 'CustomKeys'.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="createdByWorkspaceArmId")
    def created_by_workspace_arm_id(self) -> builtins.str:
        return pulumi.get(self, "created_by_workspace_arm_id")

    @property
    @pulumi.getter
    def group(self) -> builtins.str:
        """
        Group based on connection category
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def category(self) -> Optional[builtins.str]:
        """
        Category of the connection
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.CustomKeysResponse']:
        """
        Custom Keys credential object
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="expiryTime")
    def expiry_time(self) -> Optional[builtins.str]:
        return pulumi.get(self, "expiry_time")

    @property
    @pulumi.getter(name="isSharedToAll")
    def is_shared_to_all(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_shared_to_all")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Store user metadata for this connection
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="sharedUserList")
    def shared_user_list(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "shared_user_list")

    @property
    @pulumi.getter
    def target(self) -> Optional[builtins.str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value details of the workspace connection.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[builtins.str]:
        """
        format for the workspace connection value
        """
        return pulumi.get(self, "value_format")


@pulumi.output_type
class CustomMetricThresholdResponse(dict):
    def __init__(__self__, *,
                 metric: builtins.str,
                 threshold: Optional['outputs.MonitoringThresholdResponse'] = None):
        """
        :param builtins.str metric: [Required] The user-defined metric to calculate.
        :param 'MonitoringThresholdResponse' threshold: The threshold value. If null, a default value will be set depending on the selected metric.
        """
        pulumi.set(__self__, "metric", metric)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def metric(self) -> builtins.str:
        """
        [Required] The user-defined metric to calculate.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def threshold(self) -> Optional['outputs.MonitoringThresholdResponse']:
        """
        The threshold value. If null, a default value will be set depending on the selected metric.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class CustomModelJobInputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobInputType":
            suggest = "job_input_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomModelJobInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomModelJobInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomModelJobInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_input_type: builtins.str,
                 uri: builtins.str,
                 description: Optional[builtins.str] = None,
                 mode: Optional[builtins.str] = None):
        """
        :param builtins.str job_input_type: Enum to determine the Job Input Type.
               Expected value is 'custom_model'.
        :param builtins.str uri: [Required] Input Asset URI.
        :param builtins.str description: Description for the input.
        :param builtins.str mode: Input Asset Delivery Mode.
        """
        pulumi.set(__self__, "job_input_type", 'custom_model')
        pulumi.set(__self__, "uri", uri)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if mode is None:
            mode = 'ReadOnlyMount'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="jobInputType")
    def job_input_type(self) -> builtins.str:
        """
        Enum to determine the Job Input Type.
        Expected value is 'custom_model'.
        """
        return pulumi.get(self, "job_input_type")

    @property
    @pulumi.getter
    def uri(self) -> builtins.str:
        """
        [Required] Input Asset URI.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description for the input.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Input Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class CustomModelJobOutputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobOutputType":
            suggest = "job_output_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomModelJobOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomModelJobOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomModelJobOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_output_type: builtins.str,
                 description: Optional[builtins.str] = None,
                 mode: Optional[builtins.str] = None,
                 uri: Optional[builtins.str] = None):
        """
        :param builtins.str job_output_type: Enum to determine the Job Output Type.
               Expected value is 'custom_model'.
        :param builtins.str description: Description for the output.
        :param builtins.str mode: Output Asset Delivery Mode.
        :param builtins.str uri: Output Asset URI.
        """
        pulumi.set(__self__, "job_output_type", 'custom_model')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if mode is None:
            mode = 'ReadWriteMount'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter(name="jobOutputType")
    def job_output_type(self) -> builtins.str:
        """
        Enum to determine the Job Output Type.
        Expected value is 'custom_model'.
        """
        return pulumi.get(self, "job_output_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description for the output.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Output Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def uri(self) -> Optional[builtins.str]:
        """
        Output Asset URI.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class CustomMonitoringSignalResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "componentId":
            suggest = "component_id"
        elif key == "metricThresholds":
            suggest = "metric_thresholds"
        elif key == "signalType":
            suggest = "signal_type"
        elif key == "inputAssets":
            suggest = "input_assets"
        elif key == "notificationTypes":
            suggest = "notification_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomMonitoringSignalResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomMonitoringSignalResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomMonitoringSignalResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component_id: builtins.str,
                 metric_thresholds: Sequence['outputs.CustomMetricThresholdResponse'],
                 signal_type: builtins.str,
                 input_assets: Optional[Mapping[str, Any]] = None,
                 inputs: Optional[Mapping[str, Any]] = None,
                 notification_types: Optional[Sequence[builtins.str]] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str component_id: [Required] Reference to the component asset used to calculate the custom metrics.
        :param Sequence['CustomMetricThresholdResponse'] metric_thresholds: [Required] A list of metrics to calculate and their associated thresholds.
        :param builtins.str signal_type: 
               Expected value is 'Custom'.
        :param Mapping[str, Union['FixedInputDataResponse', 'RollingInputDataResponse', 'StaticInputDataResponse']] input_assets: Monitoring assets to take as input. Key is the component input port name, value is the data asset.
        :param Mapping[str, Union['CustomModelJobInputResponse', 'LiteralJobInputResponse', 'MLFlowModelJobInputResponse', 'MLTableJobInputResponse', 'TritonModelJobInputResponse', 'UriFileJobInputResponse', 'UriFolderJobInputResponse']] inputs: Extra component parameters to take as input. Key is the component literal input port name, value is the parameter value.
        :param Sequence[builtins.str] notification_types: The current notification mode for this signal.
        :param Mapping[str, builtins.str] properties: Property dictionary. Properties can be added, but not removed or altered.
        """
        pulumi.set(__self__, "component_id", component_id)
        pulumi.set(__self__, "metric_thresholds", metric_thresholds)
        pulumi.set(__self__, "signal_type", 'Custom')
        if input_assets is not None:
            pulumi.set(__self__, "input_assets", input_assets)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)
        if notification_types is not None:
            pulumi.set(__self__, "notification_types", notification_types)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter(name="componentId")
    def component_id(self) -> builtins.str:
        """
        [Required] Reference to the component asset used to calculate the custom metrics.
        """
        return pulumi.get(self, "component_id")

    @property
    @pulumi.getter(name="metricThresholds")
    def metric_thresholds(self) -> Sequence['outputs.CustomMetricThresholdResponse']:
        """
        [Required] A list of metrics to calculate and their associated thresholds.
        """
        return pulumi.get(self, "metric_thresholds")

    @property
    @pulumi.getter(name="signalType")
    def signal_type(self) -> builtins.str:
        """

        Expected value is 'Custom'.
        """
        return pulumi.get(self, "signal_type")

    @property
    @pulumi.getter(name="inputAssets")
    def input_assets(self) -> Optional[Mapping[str, Any]]:
        """
        Monitoring assets to take as input. Key is the component input port name, value is the data asset.
        """
        return pulumi.get(self, "input_assets")

    @property
    @pulumi.getter
    def inputs(self) -> Optional[Mapping[str, Any]]:
        """
        Extra component parameters to take as input. Key is the component literal input port name, value is the parameter value.
        """
        return pulumi.get(self, "inputs")

    @property
    @pulumi.getter(name="notificationTypes")
    def notification_types(self) -> Optional[Sequence[builtins.str]]:
        """
        The current notification mode for this signal.
        """
        return pulumi.get(self, "notification_types")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class CustomNCrossValidationsResponse(dict):
    """
    N-Cross validations are specified by user.
    """
    def __init__(__self__, *,
                 mode: builtins.str,
                 value: builtins.int):
        """
        N-Cross validations are specified by user.
        :param builtins.str mode: Determines how N-Cross validations value is determined.
               Expected value is 'Custom'.
        :param builtins.int value: [Required] N-Cross validations value.
        """
        pulumi.set(__self__, "mode", 'Custom')
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def mode(self) -> builtins.str:
        """
        Determines how N-Cross validations value is determined.
        Expected value is 'Custom'.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def value(self) -> builtins.int:
        """
        [Required] N-Cross validations value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomSeasonalityResponse(dict):
    def __init__(__self__, *,
                 mode: builtins.str,
                 value: builtins.int):
        """
        :param builtins.str mode: Forecasting seasonality mode.
               Expected value is 'Custom'.
        :param builtins.int value: [Required] Seasonality value.
        """
        pulumi.set(__self__, "mode", 'Custom')
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def mode(self) -> builtins.str:
        """
        Forecasting seasonality mode.
        Expected value is 'Custom'.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def value(self) -> builtins.int:
        """
        [Required] Seasonality value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomServiceResponse(dict):
    """
    Specifies the custom service configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentVariables":
            suggest = "environment_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomServiceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomServiceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomServiceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 docker: Optional['outputs.DockerResponse'] = None,
                 endpoints: Optional[Sequence['outputs.EndpointResponse']] = None,
                 environment_variables: Optional[Mapping[str, 'outputs.EnvironmentVariableResponse']] = None,
                 image: Optional['outputs.ImageResponse'] = None,
                 name: Optional[builtins.str] = None,
                 volumes: Optional[Sequence['outputs.VolumeDefinitionResponse']] = None):
        """
        Specifies the custom service configuration
        :param 'DockerResponse' docker: Describes the docker settings for the image
        :param Sequence['EndpointResponse'] endpoints: Configuring the endpoints for the container
        :param Mapping[str, 'EnvironmentVariableResponse'] environment_variables: Environment Variable for the container
        :param 'ImageResponse' image: Describes the Image Specifications
        :param builtins.str name: Name of the Custom Service
        :param Sequence['VolumeDefinitionResponse'] volumes: Configuring the volumes for the container
        """
        if docker is not None:
            pulumi.set(__self__, "docker", docker)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter
    def docker(self) -> Optional['outputs.DockerResponse']:
        """
        Describes the docker settings for the image
        """
        return pulumi.get(self, "docker")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.EndpointResponse']]:
        """
        Configuring the endpoints for the container
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, 'outputs.EnvironmentVariableResponse']]:
        """
        Environment Variable for the container
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter
    def image(self) -> Optional['outputs.ImageResponse']:
        """
        Describes the Image Specifications
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the Custom Service
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.VolumeDefinitionResponse']]:
        """
        Configuring the volumes for the container
        """
        return pulumi.get(self, "volumes")


@pulumi.output_type
class CustomTargetLagsResponse(dict):
    def __init__(__self__, *,
                 mode: builtins.str,
                 values: Sequence[builtins.int]):
        """
        :param builtins.str mode: Target lags selection modes.
               Expected value is 'Custom'.
        :param Sequence[builtins.int] values: [Required] Set target lags values.
        """
        pulumi.set(__self__, "mode", 'Custom')
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def mode(self) -> builtins.str:
        """
        Target lags selection modes.
        Expected value is 'Custom'.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.int]:
        """
        [Required] Set target lags values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class CustomTargetRollingWindowSizeResponse(dict):
    def __init__(__self__, *,
                 mode: builtins.str,
                 value: builtins.int):
        """
        :param builtins.str mode: Target rolling windows size mode.
               Expected value is 'Custom'.
        :param builtins.int value: [Required] TargetRollingWindowSize value.
        """
        pulumi.set(__self__, "mode", 'Custom')
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def mode(self) -> builtins.str:
        """
        Target rolling windows size mode.
        Expected value is 'Custom'.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def value(self) -> builtins.int:
        """
        [Required] TargetRollingWindowSize value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DataCollectorResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestLogging":
            suggest = "request_logging"
        elif key == "rollingRate":
            suggest = "rolling_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCollectorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCollectorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCollectorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collections: Mapping[str, 'outputs.CollectionResponse'],
                 request_logging: Optional['outputs.RequestLoggingResponse'] = None,
                 rolling_rate: Optional[builtins.str] = None):
        """
        :param Mapping[str, 'CollectionResponse'] collections: [Required] The collection configuration. Each collection has it own configuration to collect model data and the name of collection can be arbitrary string.
               Model data collector can be used for either payload logging or custom logging or both of them. Collection request and response are reserved for payload logging, others are for custom logging.
        :param 'RequestLoggingResponse' request_logging: The request logging configuration for mdc, it includes advanced logging settings for all collections. It's optional.
        :param builtins.str rolling_rate: When model data is collected to blob storage, we need to roll the data to different path to avoid logging all of them in a single blob file.
               If the rolling rate is hour, all data will be collected in the blob path /yyyy/MM/dd/HH/.
               If it's day, all data will be collected in blob path /yyyy/MM/dd/.
               The other benefit of rolling path is that model monitoring ui is able to select a time range of data very quickly.
        """
        pulumi.set(__self__, "collections", collections)
        if request_logging is not None:
            pulumi.set(__self__, "request_logging", request_logging)
        if rolling_rate is None:
            rolling_rate = 'Hour'
        if rolling_rate is not None:
            pulumi.set(__self__, "rolling_rate", rolling_rate)

    @property
    @pulumi.getter
    def collections(self) -> Mapping[str, 'outputs.CollectionResponse']:
        """
        [Required] The collection configuration. Each collection has it own configuration to collect model data and the name of collection can be arbitrary string.
        Model data collector can be used for either payload logging or custom logging or both of them. Collection request and response are reserved for payload logging, others are for custom logging.
        """
        return pulumi.get(self, "collections")

    @property
    @pulumi.getter(name="requestLogging")
    def request_logging(self) -> Optional['outputs.RequestLoggingResponse']:
        """
        The request logging configuration for mdc, it includes advanced logging settings for all collections. It's optional.
        """
        return pulumi.get(self, "request_logging")

    @property
    @pulumi.getter(name="rollingRate")
    def rolling_rate(self) -> Optional[builtins.str]:
        """
        When model data is collected to blob storage, we need to roll the data to different path to avoid logging all of them in a single blob file.
        If the rolling rate is hour, all data will be collected in the blob path /yyyy/MM/dd/HH/.
        If it's day, all data will be collected in blob path /yyyy/MM/dd/.
        The other benefit of rolling path is that model monitoring ui is able to select a time range of data very quickly.
        """
        return pulumi.get(self, "rolling_rate")


@pulumi.output_type
class DataContainerResponse(dict):
    """
    Container for data asset versions.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "latestVersion":
            suggest = "latest_version"
        elif key == "nextVersion":
            suggest = "next_version"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataContainerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataContainerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataContainerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: builtins.str,
                 latest_version: builtins.str,
                 next_version: builtins.str,
                 description: Optional[builtins.str] = None,
                 is_archived: Optional[builtins.bool] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Container for data asset versions.
        :param builtins.str data_type: [Required] Specifies the type of data.
        :param builtins.str latest_version: The latest version inside this container.
        :param builtins.str next_version: The next auto incremental version
        :param builtins.str description: The asset description text.
        :param builtins.bool is_archived: Is the asset archived?
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "data_type", data_type)
        pulumi.set(__self__, "latest_version", latest_version)
        pulumi.set(__self__, "next_version", next_version)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> builtins.str:
        """
        [Required] Specifies the type of data.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> builtins.str:
        """
        The latest version inside this container.
        """
        return pulumi.get(self, "latest_version")

    @property
    @pulumi.getter(name="nextVersion")
    def next_version(self) -> builtins.str:
        """
        The next auto incremental version
        """
        return pulumi.get(self, "next_version")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class DataDriftMonitoringSignalResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricThresholds":
            suggest = "metric_thresholds"
        elif key == "productionData":
            suggest = "production_data"
        elif key == "referenceData":
            suggest = "reference_data"
        elif key == "signalType":
            suggest = "signal_type"
        elif key == "featureDataTypeOverride":
            suggest = "feature_data_type_override"
        elif key == "featureImportanceSettings":
            suggest = "feature_importance_settings"
        elif key == "notificationTypes":
            suggest = "notification_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataDriftMonitoringSignalResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataDriftMonitoringSignalResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataDriftMonitoringSignalResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_thresholds: Sequence[Any],
                 production_data: Any,
                 reference_data: Any,
                 signal_type: builtins.str,
                 feature_data_type_override: Optional[Mapping[str, builtins.str]] = None,
                 feature_importance_settings: Optional['outputs.FeatureImportanceSettingsResponse'] = None,
                 features: Optional[Any] = None,
                 notification_types: Optional[Sequence[builtins.str]] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None):
        """
        :param Sequence[Union['CategoricalDataDriftMetricThresholdResponse', 'NumericalDataDriftMetricThresholdResponse']] metric_thresholds: [Required] A list of metrics to calculate and their associated thresholds.
        :param Union['FixedInputDataResponse', 'RollingInputDataResponse', 'StaticInputDataResponse'] production_data: [Required] The data which drift will be calculated for.
        :param Union['FixedInputDataResponse', 'RollingInputDataResponse', 'StaticInputDataResponse'] reference_data: [Required] The data to calculate drift against.
        :param builtins.str signal_type: 
               Expected value is 'DataDrift'.
        :param Mapping[str, builtins.str] feature_data_type_override: A dictionary that maps feature names to their respective data types.
        :param 'FeatureImportanceSettingsResponse' feature_importance_settings: The settings for computing feature importance.
        :param Union['AllFeaturesResponse', 'FeatureSubsetResponse', 'TopNFeaturesByAttributionResponse'] features: The feature filter which identifies which feature to calculate drift over.
        :param Sequence[builtins.str] notification_types: The current notification mode for this signal.
        :param Mapping[str, builtins.str] properties: Property dictionary. Properties can be added, but not removed or altered.
        """
        pulumi.set(__self__, "metric_thresholds", metric_thresholds)
        pulumi.set(__self__, "production_data", production_data)
        pulumi.set(__self__, "reference_data", reference_data)
        pulumi.set(__self__, "signal_type", 'DataDrift')
        if feature_data_type_override is not None:
            pulumi.set(__self__, "feature_data_type_override", feature_data_type_override)
        if feature_importance_settings is not None:
            pulumi.set(__self__, "feature_importance_settings", feature_importance_settings)
        if features is not None:
            pulumi.set(__self__, "features", features)
        if notification_types is not None:
            pulumi.set(__self__, "notification_types", notification_types)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter(name="metricThresholds")
    def metric_thresholds(self) -> Sequence[Any]:
        """
        [Required] A list of metrics to calculate and their associated thresholds.
        """
        return pulumi.get(self, "metric_thresholds")

    @property
    @pulumi.getter(name="productionData")
    def production_data(self) -> Any:
        """
        [Required] The data which drift will be calculated for.
        """
        return pulumi.get(self, "production_data")

    @property
    @pulumi.getter(name="referenceData")
    def reference_data(self) -> Any:
        """
        [Required] The data to calculate drift against.
        """
        return pulumi.get(self, "reference_data")

    @property
    @pulumi.getter(name="signalType")
    def signal_type(self) -> builtins.str:
        """

        Expected value is 'DataDrift'.
        """
        return pulumi.get(self, "signal_type")

    @property
    @pulumi.getter(name="featureDataTypeOverride")
    def feature_data_type_override(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A dictionary that maps feature names to their respective data types.
        """
        return pulumi.get(self, "feature_data_type_override")

    @property
    @pulumi.getter(name="featureImportanceSettings")
    def feature_importance_settings(self) -> Optional['outputs.FeatureImportanceSettingsResponse']:
        """
        The settings for computing feature importance.
        """
        return pulumi.get(self, "feature_importance_settings")

    @property
    @pulumi.getter
    def features(self) -> Optional[Any]:
        """
        The feature filter which identifies which feature to calculate drift over.
        """
        return pulumi.get(self, "features")

    @property
    @pulumi.getter(name="notificationTypes")
    def notification_types(self) -> Optional[Sequence[builtins.str]]:
        """
        The current notification mode for this signal.
        """
        return pulumi.get(self, "notification_types")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class DataFactoryResponse(dict):
    """
    A DataFactory compute.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeType":
            suggest = "compute_type"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "isAttachedCompute":
            suggest = "is_attached_compute"
        elif key == "modifiedOn":
            suggest = "modified_on"
        elif key == "provisioningErrors":
            suggest = "provisioning_errors"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "computeLocation":
            suggest = "compute_location"
        elif key == "disableLocalAuth":
            suggest = "disable_local_auth"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataFactoryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataFactoryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataFactoryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_type: builtins.str,
                 created_on: builtins.str,
                 is_attached_compute: builtins.bool,
                 modified_on: builtins.str,
                 provisioning_errors: Sequence['outputs.ErrorResponseResponse'],
                 provisioning_state: builtins.str,
                 compute_location: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 disable_local_auth: Optional[builtins.bool] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        A DataFactory compute.
        :param builtins.str compute_type: The type of compute
               Expected value is 'DataFactory'.
        :param builtins.str created_on: The time at which the compute was created.
        :param builtins.bool is_attached_compute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        :param builtins.str modified_on: The time at which the compute was last modified.
        :param Sequence['ErrorResponseResponse'] provisioning_errors: Errors during provisioning
        :param builtins.str provisioning_state: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        :param builtins.str compute_location: Location for the underlying compute
        :param builtins.str description: The description of the Machine Learning compute.
        :param builtins.bool disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        :param builtins.str resource_id: ARM resource id of the underlying compute
        """
        pulumi.set(__self__, "compute_type", 'DataFactory')
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "is_attached_compute", is_attached_compute)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "provisioning_errors", provisioning_errors)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if compute_location is not None:
            pulumi.set(__self__, "compute_location", compute_location)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_local_auth is not None:
            pulumi.set(__self__, "disable_local_auth", disable_local_auth)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> builtins.str:
        """
        The type of compute
        Expected value is 'DataFactory'.
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> builtins.str:
        """
        The time at which the compute was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="isAttachedCompute")
    def is_attached_compute(self) -> builtins.bool:
        """
        Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        """
        return pulumi.get(self, "is_attached_compute")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> builtins.str:
        """
        The time at which the compute was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="provisioningErrors")
    def provisioning_errors(self) -> Sequence['outputs.ErrorResponseResponse']:
        """
        Errors during provisioning
        """
        return pulumi.get(self, "provisioning_errors")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[builtins.str]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[builtins.bool]:
        """
        Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        """
        return pulumi.get(self, "disable_local_auth")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class DataLakeAnalyticsResponse(dict):
    """
    A DataLakeAnalytics compute.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeType":
            suggest = "compute_type"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "isAttachedCompute":
            suggest = "is_attached_compute"
        elif key == "modifiedOn":
            suggest = "modified_on"
        elif key == "provisioningErrors":
            suggest = "provisioning_errors"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "computeLocation":
            suggest = "compute_location"
        elif key == "disableLocalAuth":
            suggest = "disable_local_auth"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeAnalyticsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeAnalyticsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeAnalyticsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_type: builtins.str,
                 created_on: builtins.str,
                 is_attached_compute: builtins.bool,
                 modified_on: builtins.str,
                 provisioning_errors: Sequence['outputs.ErrorResponseResponse'],
                 provisioning_state: builtins.str,
                 compute_location: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 disable_local_auth: Optional[builtins.bool] = None,
                 properties: Optional['outputs.DataLakeAnalyticsSchemaResponseProperties'] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        A DataLakeAnalytics compute.
        :param builtins.str compute_type: The type of compute
               Expected value is 'DataLakeAnalytics'.
        :param builtins.str created_on: The time at which the compute was created.
        :param builtins.bool is_attached_compute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        :param builtins.str modified_on: The time at which the compute was last modified.
        :param Sequence['ErrorResponseResponse'] provisioning_errors: Errors during provisioning
        :param builtins.str provisioning_state: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        :param builtins.str compute_location: Location for the underlying compute
        :param builtins.str description: The description of the Machine Learning compute.
        :param builtins.bool disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        :param builtins.str resource_id: ARM resource id of the underlying compute
        """
        pulumi.set(__self__, "compute_type", 'DataLakeAnalytics')
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "is_attached_compute", is_attached_compute)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "provisioning_errors", provisioning_errors)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if compute_location is not None:
            pulumi.set(__self__, "compute_location", compute_location)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_local_auth is not None:
            pulumi.set(__self__, "disable_local_auth", disable_local_auth)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> builtins.str:
        """
        The type of compute
        Expected value is 'DataLakeAnalytics'.
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> builtins.str:
        """
        The time at which the compute was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="isAttachedCompute")
    def is_attached_compute(self) -> builtins.bool:
        """
        Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        """
        return pulumi.get(self, "is_attached_compute")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> builtins.str:
        """
        The time at which the compute was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="provisioningErrors")
    def provisioning_errors(self) -> Sequence['outputs.ErrorResponseResponse']:
        """
        Errors during provisioning
        """
        return pulumi.get(self, "provisioning_errors")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[builtins.str]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[builtins.bool]:
        """
        Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        """
        return pulumi.get(self, "disable_local_auth")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.DataLakeAnalyticsSchemaResponseProperties']:
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class DataLakeAnalyticsSchemaResponseProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLakeStoreAccountName":
            suggest = "data_lake_store_account_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeAnalyticsSchemaResponseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeAnalyticsSchemaResponseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeAnalyticsSchemaResponseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_lake_store_account_name: Optional[builtins.str] = None):
        """
        :param builtins.str data_lake_store_account_name: DataLake Store Account Name
        """
        if data_lake_store_account_name is not None:
            pulumi.set(__self__, "data_lake_store_account_name", data_lake_store_account_name)

    @property
    @pulumi.getter(name="dataLakeStoreAccountName")
    def data_lake_store_account_name(self) -> Optional[builtins.str]:
        """
        DataLake Store Account Name
        """
        return pulumi.get(self, "data_lake_store_account_name")


@pulumi.output_type
class DataPathAssetReferenceResponse(dict):
    """
    Reference to an asset via its path in a datastore.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referenceType":
            suggest = "reference_type"
        elif key == "datastoreId":
            suggest = "datastore_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataPathAssetReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataPathAssetReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataPathAssetReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reference_type: builtins.str,
                 datastore_id: Optional[builtins.str] = None,
                 path: Optional[builtins.str] = None):
        """
        Reference to an asset via its path in a datastore.
        :param builtins.str reference_type: Enum to determine which reference method to use for an asset.
               Expected value is 'DataPath'.
        :param builtins.str datastore_id: ARM resource ID of the datastore where the asset is located.
        :param builtins.str path: The path of the file/directory in the datastore.
        """
        pulumi.set(__self__, "reference_type", 'DataPath')
        if datastore_id is not None:
            pulumi.set(__self__, "datastore_id", datastore_id)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="referenceType")
    def reference_type(self) -> builtins.str:
        """
        Enum to determine which reference method to use for an asset.
        Expected value is 'DataPath'.
        """
        return pulumi.get(self, "reference_type")

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of the datastore where the asset is located.
        """
        return pulumi.get(self, "datastore_id")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        The path of the file/directory in the datastore.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DataQualityMonitoringSignalResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricThresholds":
            suggest = "metric_thresholds"
        elif key == "productionData":
            suggest = "production_data"
        elif key == "referenceData":
            suggest = "reference_data"
        elif key == "signalType":
            suggest = "signal_type"
        elif key == "featureDataTypeOverride":
            suggest = "feature_data_type_override"
        elif key == "featureImportanceSettings":
            suggest = "feature_importance_settings"
        elif key == "notificationTypes":
            suggest = "notification_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataQualityMonitoringSignalResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataQualityMonitoringSignalResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataQualityMonitoringSignalResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_thresholds: Sequence[Any],
                 production_data: Any,
                 reference_data: Any,
                 signal_type: builtins.str,
                 feature_data_type_override: Optional[Mapping[str, builtins.str]] = None,
                 feature_importance_settings: Optional['outputs.FeatureImportanceSettingsResponse'] = None,
                 features: Optional[Any] = None,
                 notification_types: Optional[Sequence[builtins.str]] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None):
        """
        :param Sequence[Union['CategoricalDataQualityMetricThresholdResponse', 'NumericalDataQualityMetricThresholdResponse']] metric_thresholds: [Required] A list of metrics to calculate and their associated thresholds.
        :param Union['FixedInputDataResponse', 'RollingInputDataResponse', 'StaticInputDataResponse'] production_data: [Required] The data produced by the production service which drift will be calculated for.
        :param Union['FixedInputDataResponse', 'RollingInputDataResponse', 'StaticInputDataResponse'] reference_data: [Required] The data to calculate drift against.
        :param builtins.str signal_type: 
               Expected value is 'DataQuality'.
        :param Mapping[str, builtins.str] feature_data_type_override: A dictionary that maps feature names to their respective data types.
        :param 'FeatureImportanceSettingsResponse' feature_importance_settings: The settings for computing feature importance.
        :param Union['AllFeaturesResponse', 'FeatureSubsetResponse', 'TopNFeaturesByAttributionResponse'] features: The features to calculate drift over.
        :param Sequence[builtins.str] notification_types: The current notification mode for this signal.
        :param Mapping[str, builtins.str] properties: Property dictionary. Properties can be added, but not removed or altered.
        """
        pulumi.set(__self__, "metric_thresholds", metric_thresholds)
        pulumi.set(__self__, "production_data", production_data)
        pulumi.set(__self__, "reference_data", reference_data)
        pulumi.set(__self__, "signal_type", 'DataQuality')
        if feature_data_type_override is not None:
            pulumi.set(__self__, "feature_data_type_override", feature_data_type_override)
        if feature_importance_settings is not None:
            pulumi.set(__self__, "feature_importance_settings", feature_importance_settings)
        if features is not None:
            pulumi.set(__self__, "features", features)
        if notification_types is not None:
            pulumi.set(__self__, "notification_types", notification_types)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter(name="metricThresholds")
    def metric_thresholds(self) -> Sequence[Any]:
        """
        [Required] A list of metrics to calculate and their associated thresholds.
        """
        return pulumi.get(self, "metric_thresholds")

    @property
    @pulumi.getter(name="productionData")
    def production_data(self) -> Any:
        """
        [Required] The data produced by the production service which drift will be calculated for.
        """
        return pulumi.get(self, "production_data")

    @property
    @pulumi.getter(name="referenceData")
    def reference_data(self) -> Any:
        """
        [Required] The data to calculate drift against.
        """
        return pulumi.get(self, "reference_data")

    @property
    @pulumi.getter(name="signalType")
    def signal_type(self) -> builtins.str:
        """

        Expected value is 'DataQuality'.
        """
        return pulumi.get(self, "signal_type")

    @property
    @pulumi.getter(name="featureDataTypeOverride")
    def feature_data_type_override(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A dictionary that maps feature names to their respective data types.
        """
        return pulumi.get(self, "feature_data_type_override")

    @property
    @pulumi.getter(name="featureImportanceSettings")
    def feature_importance_settings(self) -> Optional['outputs.FeatureImportanceSettingsResponse']:
        """
        The settings for computing feature importance.
        """
        return pulumi.get(self, "feature_importance_settings")

    @property
    @pulumi.getter
    def features(self) -> Optional[Any]:
        """
        The features to calculate drift over.
        """
        return pulumi.get(self, "features")

    @property
    @pulumi.getter(name="notificationTypes")
    def notification_types(self) -> Optional[Sequence[builtins.str]]:
        """
        The current notification mode for this signal.
        """
        return pulumi.get(self, "notification_types")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class DatabricksPropertiesResponse(dict):
    """
    Properties of Databricks
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databricksAccessToken":
            suggest = "databricks_access_token"
        elif key == "workspaceUrl":
            suggest = "workspace_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabricksPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabricksPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabricksPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 databricks_access_token: Optional[builtins.str] = None,
                 workspace_url: Optional[builtins.str] = None):
        """
        Properties of Databricks
        :param builtins.str databricks_access_token: Databricks access token
        :param builtins.str workspace_url: Workspace Url
        """
        if databricks_access_token is not None:
            pulumi.set(__self__, "databricks_access_token", databricks_access_token)
        if workspace_url is not None:
            pulumi.set(__self__, "workspace_url", workspace_url)

    @property
    @pulumi.getter(name="databricksAccessToken")
    def databricks_access_token(self) -> Optional[builtins.str]:
        """
        Databricks access token
        """
        return pulumi.get(self, "databricks_access_token")

    @property
    @pulumi.getter(name="workspaceUrl")
    def workspace_url(self) -> Optional[builtins.str]:
        """
        Workspace Url
        """
        return pulumi.get(self, "workspace_url")


@pulumi.output_type
class DatabricksResponse(dict):
    """
    A DataFactory compute.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeType":
            suggest = "compute_type"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "isAttachedCompute":
            suggest = "is_attached_compute"
        elif key == "modifiedOn":
            suggest = "modified_on"
        elif key == "provisioningErrors":
            suggest = "provisioning_errors"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "computeLocation":
            suggest = "compute_location"
        elif key == "disableLocalAuth":
            suggest = "disable_local_auth"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabricksResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabricksResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabricksResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_type: builtins.str,
                 created_on: builtins.str,
                 is_attached_compute: builtins.bool,
                 modified_on: builtins.str,
                 provisioning_errors: Sequence['outputs.ErrorResponseResponse'],
                 provisioning_state: builtins.str,
                 compute_location: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 disable_local_auth: Optional[builtins.bool] = None,
                 properties: Optional['outputs.DatabricksPropertiesResponse'] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        A DataFactory compute.
        :param builtins.str compute_type: The type of compute
               Expected value is 'Databricks'.
        :param builtins.str created_on: The time at which the compute was created.
        :param builtins.bool is_attached_compute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        :param builtins.str modified_on: The time at which the compute was last modified.
        :param Sequence['ErrorResponseResponse'] provisioning_errors: Errors during provisioning
        :param builtins.str provisioning_state: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        :param builtins.str compute_location: Location for the underlying compute
        :param builtins.str description: The description of the Machine Learning compute.
        :param builtins.bool disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        :param 'DatabricksPropertiesResponse' properties: Properties of Databricks
        :param builtins.str resource_id: ARM resource id of the underlying compute
        """
        pulumi.set(__self__, "compute_type", 'Databricks')
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "is_attached_compute", is_attached_compute)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "provisioning_errors", provisioning_errors)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if compute_location is not None:
            pulumi.set(__self__, "compute_location", compute_location)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_local_auth is not None:
            pulumi.set(__self__, "disable_local_auth", disable_local_auth)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> builtins.str:
        """
        The type of compute
        Expected value is 'Databricks'.
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> builtins.str:
        """
        The time at which the compute was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="isAttachedCompute")
    def is_attached_compute(self) -> builtins.bool:
        """
        Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        """
        return pulumi.get(self, "is_attached_compute")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> builtins.str:
        """
        The time at which the compute was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="provisioningErrors")
    def provisioning_errors(self) -> Sequence['outputs.ErrorResponseResponse']:
        """
        Errors during provisioning
        """
        return pulumi.get(self, "provisioning_errors")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[builtins.str]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[builtins.bool]:
        """
        Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        """
        return pulumi.get(self, "disable_local_auth")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.DatabricksPropertiesResponse']:
        """
        Properties of Databricks
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class DatasetResponse(dict):
    """
    Machine Learning dataset object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdTime":
            suggest = "created_time"
        elif key == "datasetId":
            suggest = "dataset_id"
        elif key == "datasetType":
            suggest = "dataset_type"
        elif key == "defaultCompute":
            suggest = "default_compute"
        elif key == "isVisible":
            suggest = "is_visible"
        elif key == "modifiedTime":
            suggest = "modified_time"
        elif key == "datasetState":
            suggest = "dataset_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_time: builtins.str,
                 dataset_id: builtins.str,
                 dataset_type: builtins.str,
                 default_compute: builtins.str,
                 description: builtins.str,
                 etag: builtins.str,
                 is_visible: builtins.bool,
                 modified_time: builtins.str,
                 name: builtins.str,
                 tags: Mapping[str, builtins.str],
                 dataset_state: Optional['outputs.DatasetStateResponse'] = None,
                 latest: Optional['outputs.DatasetResponseLatest'] = None):
        """
        Machine Learning dataset object.
        :param builtins.str created_time: The dataset creation time (UTC).
        :param builtins.str dataset_id: Unique Dataset identifier.
        :param builtins.str dataset_type: Dataset Type.
        :param builtins.str default_compute: Name of the default compute to be used for any Dataset actions (such as Profile, Write).
        :param builtins.str description: Description about this dataset version.
        :param builtins.str etag: eTag description
        :param builtins.bool is_visible: Flag to hide Dataset in UI
        :param builtins.str modified_time: The dataset last modified time (UTC).
        :param builtins.str name: Unique dataset name
        :param Mapping[str, builtins.str] tags: Tags for this dataset version.
        :param 'DatasetStateResponse' dataset_state: Dataset state
        :param 'DatasetResponseLatest' latest: Last created Dataset definition.
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "dataset_type", dataset_type)
        pulumi.set(__self__, "default_compute", default_compute)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "etag", etag)
        pulumi.set(__self__, "is_visible", is_visible)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tags", tags)
        if dataset_state is not None:
            pulumi.set(__self__, "dataset_state", dataset_state)
        if latest is not None:
            pulumi.set(__self__, "latest", latest)

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> builtins.str:
        """
        The dataset creation time (UTC).
        """
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> builtins.str:
        """
        Unique Dataset identifier.
        """
        return pulumi.get(self, "dataset_id")

    @property
    @pulumi.getter(name="datasetType")
    def dataset_type(self) -> builtins.str:
        """
        Dataset Type.
        """
        return pulumi.get(self, "dataset_type")

    @property
    @pulumi.getter(name="defaultCompute")
    def default_compute(self) -> builtins.str:
        """
        Name of the default compute to be used for any Dataset actions (such as Profile, Write).
        """
        return pulumi.get(self, "default_compute")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        Description about this dataset version.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def etag(self) -> builtins.str:
        """
        eTag description
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="isVisible")
    def is_visible(self) -> builtins.bool:
        """
        Flag to hide Dataset in UI
        """
        return pulumi.get(self, "is_visible")

    @property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> builtins.str:
        """
        The dataset last modified time (UTC).
        """
        return pulumi.get(self, "modified_time")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Unique dataset name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, builtins.str]:
        """
        Tags for this dataset version.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="datasetState")
    def dataset_state(self) -> Optional['outputs.DatasetStateResponse']:
        """
        Dataset state
        """
        return pulumi.get(self, "dataset_state")

    @property
    @pulumi.getter
    def latest(self) -> Optional['outputs.DatasetResponseLatest']:
        """
        Last created Dataset definition.
        """
        return pulumi.get(self, "latest")


@pulumi.output_type
class DatasetResponseDataPath(dict):
    """
     Datastore and reference to location of data such as relativePath, Sql Query and etc.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureFilePath":
            suggest = "azure_file_path"
        elif key == "datastoreName":
            suggest = "datastore_name"
        elif key == "httpUrl":
            suggest = "http_url"
        elif key == "partitionFormat":
            suggest = "partition_format"
        elif key == "partitionFormatIgnoreError":
            suggest = "partition_format_ignore_error"
        elif key == "relativePath":
            suggest = "relative_path"
        elif key == "additionalProperties":
            suggest = "additional_properties"
        elif key == "sqlDataPath":
            suggest = "sql_data_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetResponseDataPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetResponseDataPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetResponseDataPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_file_path: builtins.str,
                 datastore_name: builtins.str,
                 http_url: builtins.str,
                 partition_format: builtins.str,
                 partition_format_ignore_error: builtins.bool,
                 paths: Sequence[builtins.str],
                 relative_path: builtins.str,
                 additional_properties: Optional[Mapping[str, Any]] = None,
                 sql_data_path: Optional['outputs.DatasetResponseSqlDataPath'] = None):
        """
         Datastore and reference to location of data such as relativePath, Sql Query and etc.
        :param builtins.str azure_file_path: Azure path for Azure Blob or File
        :param builtins.str datastore_name: Data store Name
        :param builtins.str http_url: HTTP URL.
        :param builtins.str partition_format: Specify the partition format of path. Defaults to None.
        :param builtins.bool partition_format_ignore_error: Whether or not to ignore unmatched path.
        :param Sequence[builtins.str] paths: List of files expanded from a file GLOB specified
        :param builtins.str relative_path: Relative path in the data store
        :param Mapping[str, Any] additional_properties: Additional Properties.
        :param 'DatasetResponseSqlDataPath' sql_data_path: Sql Query/Table/Stored Procedure details.
        """
        pulumi.set(__self__, "azure_file_path", azure_file_path)
        pulumi.set(__self__, "datastore_name", datastore_name)
        pulumi.set(__self__, "http_url", http_url)
        pulumi.set(__self__, "partition_format", partition_format)
        pulumi.set(__self__, "partition_format_ignore_error", partition_format_ignore_error)
        pulumi.set(__self__, "paths", paths)
        pulumi.set(__self__, "relative_path", relative_path)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if sql_data_path is not None:
            pulumi.set(__self__, "sql_data_path", sql_data_path)

    @property
    @pulumi.getter(name="azureFilePath")
    def azure_file_path(self) -> builtins.str:
        """
        Azure path for Azure Blob or File
        """
        return pulumi.get(self, "azure_file_path")

    @property
    @pulumi.getter(name="datastoreName")
    def datastore_name(self) -> builtins.str:
        """
        Data store Name
        """
        return pulumi.get(self, "datastore_name")

    @property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> builtins.str:
        """
        HTTP URL.
        """
        return pulumi.get(self, "http_url")

    @property
    @pulumi.getter(name="partitionFormat")
    def partition_format(self) -> builtins.str:
        """
        Specify the partition format of path. Defaults to None.
        """
        return pulumi.get(self, "partition_format")

    @property
    @pulumi.getter(name="partitionFormatIgnoreError")
    def partition_format_ignore_error(self) -> builtins.bool:
        """
        Whether or not to ignore unmatched path.
        """
        return pulumi.get(self, "partition_format_ignore_error")

    @property
    @pulumi.getter
    def paths(self) -> Sequence[builtins.str]:
        """
        List of files expanded from a file GLOB specified
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> builtins.str:
        """
        Relative path in the data store
        """
        return pulumi.get(self, "relative_path")

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[Mapping[str, Any]]:
        """
        Additional Properties.
        """
        return pulumi.get(self, "additional_properties")

    @property
    @pulumi.getter(name="sqlDataPath")
    def sql_data_path(self) -> Optional['outputs.DatasetResponseSqlDataPath']:
        """
        Sql Query/Table/Stored Procedure details.
        """
        return pulumi.get(self, "sql_data_path")


@pulumi.output_type
class DatasetResponseLatest(dict):
    """
    Last created Dataset definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdTime":
            suggest = "created_time"
        elif key == "datasetId":
            suggest = "dataset_id"
        elif key == "fileType":
            suggest = "file_type"
        elif key == "modifiedTime":
            suggest = "modified_time"
        elif key == "partitionFormatInPath":
            suggest = "partition_format_in_path"
        elif key == "savedDatasetId":
            suggest = "saved_dataset_id"
        elif key == "telemetryInfo":
            suggest = "telemetry_info"
        elif key == "useDescriptionTagsFromDefinition":
            suggest = "use_description_tags_from_definition"
        elif key == "versionId":
            suggest = "version_id"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "dataPath":
            suggest = "data_path"
        elif key == "datasetDefinitionState":
            suggest = "dataset_definition_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetResponseLatest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetResponseLatest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetResponseLatest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_time: builtins.str,
                 dataflow: builtins.str,
                 dataset_id: builtins.str,
                 description: builtins.str,
                 etag: builtins.str,
                 file_type: builtins.str,
                 modified_time: builtins.str,
                 notes: builtins.str,
                 partition_format_in_path: builtins.bool,
                 saved_dataset_id: builtins.str,
                 tags: Mapping[str, builtins.str],
                 telemetry_info: Mapping[str, builtins.str],
                 use_description_tags_from_definition: builtins.bool,
                 version_id: builtins.str,
                 created_by: Optional['outputs.UserInfoResponse'] = None,
                 data_path: Optional['outputs.DatasetResponseDataPath'] = None,
                 dataset_definition_state: Optional['outputs.DatasetStateResponse'] = None,
                 properties: Optional[Mapping[str, Any]] = None):
        """
        Last created Dataset definition.
        :param builtins.str created_time: The dataset creation time (UTC).
        :param builtins.str dataflow: Dataflow Json
        :param builtins.str dataset_id: Unique Dataset identifier.
        :param builtins.str description: Description about the dataset.
        :param builtins.str etag: eTag description
        :param builtins.str file_type: Dataset FileType, specified by user.
        :param builtins.str modified_time: The dataset last modified time (UTC).
        :param builtins.str notes: Summary of Definition changes.
        :param builtins.bool partition_format_in_path: Indicates how the source data is partitioned. This is defined to filter on a range of partitioned data before performing actions or materialization.
        :param builtins.str saved_dataset_id: Indicates the saved dataset this definition is mapping to, populated on Get.
        :param Mapping[str, builtins.str] tags: Tags associated with the dataset.
        :param Mapping[str, builtins.str] telemetry_info:  Telemetry information about the dataset including information like which service the dataset was created from.
        :param builtins.bool use_description_tags_from_definition:  Whether to use description and tags from the definition level as opposed to dataset level (old behavior).
        :param builtins.str version_id: An identifier uniquely identifies a definition change.
        :param 'UserInfoResponse' created_by: User who created.
        :param 'DatasetResponseDataPath' data_path:  Datastore and reference to location of data such as relativePath, Sql Query and etc.
        :param 'DatasetStateResponse' dataset_definition_state: Dataset state
        :param Mapping[str, Any] properties: Properties stores information like name of time series column for time series dataset.
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "dataflow", dataflow)
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "etag", etag)
        pulumi.set(__self__, "file_type", file_type)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "notes", notes)
        pulumi.set(__self__, "partition_format_in_path", partition_format_in_path)
        pulumi.set(__self__, "saved_dataset_id", saved_dataset_id)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "telemetry_info", telemetry_info)
        pulumi.set(__self__, "use_description_tags_from_definition", use_description_tags_from_definition)
        pulumi.set(__self__, "version_id", version_id)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if data_path is not None:
            pulumi.set(__self__, "data_path", data_path)
        if dataset_definition_state is not None:
            pulumi.set(__self__, "dataset_definition_state", dataset_definition_state)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> builtins.str:
        """
        The dataset creation time (UTC).
        """
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter
    def dataflow(self) -> builtins.str:
        """
        Dataflow Json
        """
        return pulumi.get(self, "dataflow")

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> builtins.str:
        """
        Unique Dataset identifier.
        """
        return pulumi.get(self, "dataset_id")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        Description about the dataset.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def etag(self) -> builtins.str:
        """
        eTag description
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="fileType")
    def file_type(self) -> builtins.str:
        """
        Dataset FileType, specified by user.
        """
        return pulumi.get(self, "file_type")

    @property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> builtins.str:
        """
        The dataset last modified time (UTC).
        """
        return pulumi.get(self, "modified_time")

    @property
    @pulumi.getter
    def notes(self) -> builtins.str:
        """
        Summary of Definition changes.
        """
        return pulumi.get(self, "notes")

    @property
    @pulumi.getter(name="partitionFormatInPath")
    def partition_format_in_path(self) -> builtins.bool:
        """
        Indicates how the source data is partitioned. This is defined to filter on a range of partitioned data before performing actions or materialization.
        """
        return pulumi.get(self, "partition_format_in_path")

    @property
    @pulumi.getter(name="savedDatasetId")
    def saved_dataset_id(self) -> builtins.str:
        """
        Indicates the saved dataset this definition is mapping to, populated on Get.
        """
        return pulumi.get(self, "saved_dataset_id")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, builtins.str]:
        """
        Tags associated with the dataset.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="telemetryInfo")
    def telemetry_info(self) -> Mapping[str, builtins.str]:
        """
         Telemetry information about the dataset including information like which service the dataset was created from.
        """
        return pulumi.get(self, "telemetry_info")

    @property
    @pulumi.getter(name="useDescriptionTagsFromDefinition")
    def use_description_tags_from_definition(self) -> builtins.bool:
        """
         Whether to use description and tags from the definition level as opposed to dataset level (old behavior).
        """
        return pulumi.get(self, "use_description_tags_from_definition")

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> builtins.str:
        """
        An identifier uniquely identifies a definition change.
        """
        return pulumi.get(self, "version_id")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional['outputs.UserInfoResponse']:
        """
        User who created.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="dataPath")
    def data_path(self) -> Optional['outputs.DatasetResponseDataPath']:
        """
         Datastore and reference to location of data such as relativePath, Sql Query and etc.
        """
        return pulumi.get(self, "data_path")

    @property
    @pulumi.getter(name="datasetDefinitionState")
    def dataset_definition_state(self) -> Optional['outputs.DatasetStateResponse']:
        """
        Dataset state
        """
        return pulumi.get(self, "dataset_definition_state")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, Any]]:
        """
        Properties stores information like name of time series column for time series dataset.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class DatasetResponseSqlDataPath(dict):
    """
    Sql Query/Table/Stored Procedure details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryTimeout":
            suggest = "query_timeout"
        elif key == "sqlQuery":
            suggest = "sql_query"
        elif key == "sqlStoredProcedureName":
            suggest = "sql_stored_procedure_name"
        elif key == "sqlTableName":
            suggest = "sql_table_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetResponseSqlDataPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetResponseSqlDataPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetResponseSqlDataPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_timeout: builtins.float,
                 sql_query: builtins.str,
                 sql_stored_procedure_name: builtins.str,
                 sql_table_name: builtins.str):
        """
        Sql Query/Table/Stored Procedure details.
        :param builtins.float query_timeout: SQL query timeout. Unit in seconds.
        :param builtins.str sql_query: SQL query
        :param builtins.str sql_stored_procedure_name: SQL storedProcedure name
        :param builtins.str sql_table_name: SQL table name
        """
        pulumi.set(__self__, "query_timeout", query_timeout)
        pulumi.set(__self__, "sql_query", sql_query)
        pulumi.set(__self__, "sql_stored_procedure_name", sql_stored_procedure_name)
        pulumi.set(__self__, "sql_table_name", sql_table_name)

    @property
    @pulumi.getter(name="queryTimeout")
    def query_timeout(self) -> builtins.float:
        """
        SQL query timeout. Unit in seconds.
        """
        return pulumi.get(self, "query_timeout")

    @property
    @pulumi.getter(name="sqlQuery")
    def sql_query(self) -> builtins.str:
        """
        SQL query
        """
        return pulumi.get(self, "sql_query")

    @property
    @pulumi.getter(name="sqlStoredProcedureName")
    def sql_stored_procedure_name(self) -> builtins.str:
        """
        SQL storedProcedure name
        """
        return pulumi.get(self, "sql_stored_procedure_name")

    @property
    @pulumi.getter(name="sqlTableName")
    def sql_table_name(self) -> builtins.str:
        """
        SQL table name
        """
        return pulumi.get(self, "sql_table_name")


@pulumi.output_type
class DatasetStateResponse(dict):
    """
    Dataset state
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deprecatedBy":
            suggest = "deprecated_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 etag: builtins.str,
                 deprecated_by: Optional['outputs.DatasetStateResponseDeprecatedBy'] = None,
                 state: Optional[builtins.str] = None):
        """
        Dataset state
        :param builtins.str etag: eTag description
        :param 'DatasetStateResponseDeprecatedBy' deprecated_by: Reference to better Dataset or a Definition
        :param builtins.str state: Dataset state
        """
        pulumi.set(__self__, "etag", etag)
        if deprecated_by is not None:
            pulumi.set(__self__, "deprecated_by", deprecated_by)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def etag(self) -> builtins.str:
        """
        eTag description
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="deprecatedBy")
    def deprecated_by(self) -> Optional['outputs.DatasetStateResponseDeprecatedBy']:
        """
        Reference to better Dataset or a Definition
        """
        return pulumi.get(self, "deprecated_by")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        Dataset state
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DatasetStateResponseDeprecatedBy(dict):
    """
    Reference to better Dataset or a Definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetId":
            suggest = "dataset_id"
        elif key == "definitionVersion":
            suggest = "definition_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetStateResponseDeprecatedBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetStateResponseDeprecatedBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetStateResponseDeprecatedBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_id: builtins.str,
                 definition_version: Optional[builtins.str] = None):
        """
        Reference to better Dataset or a Definition
        :param builtins.str dataset_id: Unique Dataset identifier.
        :param builtins.str definition_version: Definition Version
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        if definition_version is not None:
            pulumi.set(__self__, "definition_version", definition_version)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> builtins.str:
        """
        Unique Dataset identifier.
        """
        return pulumi.get(self, "dataset_id")

    @property
    @pulumi.getter(name="definitionVersion")
    def definition_version(self) -> Optional[builtins.str]:
        """
        Definition Version
        """
        return pulumi.get(self, "definition_version")


@pulumi.output_type
class DatastoreResponse(dict):
    """
    Machine Learning datastore object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdBy":
            suggest = "created_by"
        elif key == "createdTime":
            suggest = "created_time"
        elif key == "modifiedBy":
            suggest = "modified_by"
        elif key == "modifiedTime":
            suggest = "modified_time"
        elif key == "azureDataLakeSection":
            suggest = "azure_data_lake_section"
        elif key == "azureMySqlSection":
            suggest = "azure_my_sql_section"
        elif key == "azurePostgreSqlSection":
            suggest = "azure_postgre_sql_section"
        elif key == "azureSqlDatabaseSection":
            suggest = "azure_sql_database_section"
        elif key == "azureStorageSection":
            suggest = "azure_storage_section"
        elif key == "dataStoreType":
            suggest = "data_store_type"
        elif key == "glusterFsSection":
            suggest = "gluster_fs_section"
        elif key == "hasBeenValidated":
            suggest = "has_been_validated"
        elif key == "linkedInfo":
            suggest = "linked_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatastoreResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatastoreResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatastoreResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_by: 'outputs.UserInfoResponse',
                 created_time: builtins.str,
                 modified_by: 'outputs.UserInfoResponse',
                 modified_time: builtins.str,
                 tags: Mapping[str, builtins.str],
                 azure_data_lake_section: Optional['outputs.AzureDataLakeSectionResponse'] = None,
                 azure_my_sql_section: Optional['outputs.AzureMySqlSectionResponse'] = None,
                 azure_postgre_sql_section: Optional['outputs.AzurePostgreSqlSectionResponse'] = None,
                 azure_sql_database_section: Optional['outputs.AzureSqlDatabaseSectionResponse'] = None,
                 azure_storage_section: Optional['outputs.AzureStorageSectionResponse'] = None,
                 data_store_type: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 gluster_fs_section: Optional['outputs.GlusterFsSectionResponse'] = None,
                 has_been_validated: Optional[builtins.bool] = None,
                 linked_info: Optional['outputs.LinkedInfoResponse'] = None,
                 name: Optional[builtins.str] = None):
        """
        Machine Learning datastore object.
        :param 'UserInfoResponse' created_by: The User who created the datastore.
        :param builtins.str created_time: The date and time when the datastore was created.
        :param 'UserInfoResponse' modified_by: The User who modified the datastore.
        :param builtins.str modified_time: The date and time when the datastore was last modified.
        :param Mapping[str, builtins.str] tags: Tags for this datastore.
        :param builtins.str data_store_type: The datastore type.
        :param builtins.str description: Description of the datastore.
        :param 'GlusterFsSectionResponse' gluster_fs_section: Data specific to GlusterFS.
        :param builtins.bool has_been_validated: A read only property that denotes whether the service datastore has been validated with credentials.
        :param 'LinkedInfoResponse' linked_info: Info about origin if it is linked.
        :param builtins.str name: Name of the datastore.
        """
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "modified_by", modified_by)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "tags", tags)
        if azure_data_lake_section is not None:
            pulumi.set(__self__, "azure_data_lake_section", azure_data_lake_section)
        if azure_my_sql_section is not None:
            pulumi.set(__self__, "azure_my_sql_section", azure_my_sql_section)
        if azure_postgre_sql_section is not None:
            pulumi.set(__self__, "azure_postgre_sql_section", azure_postgre_sql_section)
        if azure_sql_database_section is not None:
            pulumi.set(__self__, "azure_sql_database_section", azure_sql_database_section)
        if azure_storage_section is not None:
            pulumi.set(__self__, "azure_storage_section", azure_storage_section)
        if data_store_type is not None:
            pulumi.set(__self__, "data_store_type", data_store_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if gluster_fs_section is not None:
            pulumi.set(__self__, "gluster_fs_section", gluster_fs_section)
        if has_been_validated is None:
            has_been_validated = False
        if has_been_validated is not None:
            pulumi.set(__self__, "has_been_validated", has_been_validated)
        if linked_info is not None:
            pulumi.set(__self__, "linked_info", linked_info)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> 'outputs.UserInfoResponse':
        """
        The User who created the datastore.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> builtins.str:
        """
        The date and time when the datastore was created.
        """
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter(name="modifiedBy")
    def modified_by(self) -> 'outputs.UserInfoResponse':
        """
        The User who modified the datastore.
        """
        return pulumi.get(self, "modified_by")

    @property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> builtins.str:
        """
        The date and time when the datastore was last modified.
        """
        return pulumi.get(self, "modified_time")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, builtins.str]:
        """
        Tags for this datastore.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="azureDataLakeSection")
    def azure_data_lake_section(self) -> Optional['outputs.AzureDataLakeSectionResponse']:
        return pulumi.get(self, "azure_data_lake_section")

    @property
    @pulumi.getter(name="azureMySqlSection")
    def azure_my_sql_section(self) -> Optional['outputs.AzureMySqlSectionResponse']:
        return pulumi.get(self, "azure_my_sql_section")

    @property
    @pulumi.getter(name="azurePostgreSqlSection")
    def azure_postgre_sql_section(self) -> Optional['outputs.AzurePostgreSqlSectionResponse']:
        return pulumi.get(self, "azure_postgre_sql_section")

    @property
    @pulumi.getter(name="azureSqlDatabaseSection")
    def azure_sql_database_section(self) -> Optional['outputs.AzureSqlDatabaseSectionResponse']:
        return pulumi.get(self, "azure_sql_database_section")

    @property
    @pulumi.getter(name="azureStorageSection")
    def azure_storage_section(self) -> Optional['outputs.AzureStorageSectionResponse']:
        return pulumi.get(self, "azure_storage_section")

    @property
    @pulumi.getter(name="dataStoreType")
    def data_store_type(self) -> Optional[builtins.str]:
        """
        The datastore type.
        """
        return pulumi.get(self, "data_store_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description of the datastore.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="glusterFsSection")
    def gluster_fs_section(self) -> Optional['outputs.GlusterFsSectionResponse']:
        """
        Data specific to GlusterFS.
        """
        return pulumi.get(self, "gluster_fs_section")

    @property
    @pulumi.getter(name="hasBeenValidated")
    def has_been_validated(self) -> Optional[builtins.bool]:
        """
        A read only property that denotes whether the service datastore has been validated with credentials.
        """
        return pulumi.get(self, "has_been_validated")

    @property
    @pulumi.getter(name="linkedInfo")
    def linked_info(self) -> Optional['outputs.LinkedInfoResponse']:
        """
        Info about origin if it is linked.
        """
        return pulumi.get(self, "linked_info")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the datastore.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DefaultScaleSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleType":
            suggest = "scale_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultScaleSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultScaleSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultScaleSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scale_type: builtins.str):
        """
        :param builtins.str scale_type: 
               Expected value is 'Default'.
        """
        pulumi.set(__self__, "scale_type", 'Default')

    @property
    @pulumi.getter(name="scaleType")
    def scale_type(self) -> builtins.str:
        """

        Expected value is 'Default'.
        """
        return pulumi.get(self, "scale_type")


@pulumi.output_type
class DeltaModelCurrentStateResponse(dict):
    """
    Contract for DeltaModelCurrentState.
    """
    def __init__(__self__, *,
                 count: Optional[builtins.int] = None,
                 sample_instance_id: Optional[builtins.str] = None,
                 status: Optional[builtins.str] = None):
        """
        Contract for DeltaModelCurrentState.
        :param builtins.int count: Gets or sets Count of instances with model.
        :param builtins.str sample_instance_id: Gets or sets sample of instances with model.
        :param builtins.str status: Gets or sets status.
        """
        if count is None:
            count = 0
        if count is not None:
            pulumi.set(__self__, "count", count)
        if sample_instance_id is not None:
            pulumi.set(__self__, "sample_instance_id", sample_instance_id)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def count(self) -> Optional[builtins.int]:
        """
        Gets or sets Count of instances with model.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="sampleInstanceID")
    def sample_instance_id(self) -> Optional[builtins.str]:
        """
        Gets or sets sample of instances with model.
        """
        return pulumi.get(self, "sample_instance_id")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Gets or sets status.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class DeploymentResourceConfigurationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceCount":
            suggest = "instance_count"
        elif key == "instanceType":
            suggest = "instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentResourceConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentResourceConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentResourceConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_count: Optional[builtins.int] = None,
                 instance_type: Optional[builtins.str] = None,
                 properties: Optional[Mapping[str, Any]] = None):
        """
        :param builtins.int instance_count: Optional number of instances or nodes used by the compute target.
        :param builtins.str instance_type: Optional type of VM used as supported by the compute target.
        :param Mapping[str, Any] properties: Additional properties bag.
        """
        if instance_count is None:
            instance_count = 1
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[builtins.int]:
        """
        Optional number of instances or nodes used by the compute target.
        """
        return pulumi.get(self, "instance_count")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[builtins.str]:
        """
        Optional type of VM used as supported by the compute target.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, Any]]:
        """
        Additional properties bag.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class DockerBuildResponse(dict):
    """
    Class to represent configuration settings for Docker Build
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dockerSpecificationType":
            suggest = "docker_specification_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DockerBuildResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DockerBuildResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DockerBuildResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 docker_specification_type: builtins.str,
                 dockerfile: builtins.str,
                 context: Optional[builtins.str] = None,
                 platform: Optional['outputs.DockerImagePlatformResponse'] = None):
        """
        Class to represent configuration settings for Docker Build
        :param builtins.str docker_specification_type: Enum to determine docker specification type. Must be either Build or Image.
               Expected value is 'Build'.
        :param builtins.str dockerfile: [Required] Docker command line instructions to assemble an image.
               <seealso href="https://repo2docker.readthedocs.io/en/latest/config_files.html#dockerfile-advanced-environments" />
        :param builtins.str context: Path to a snapshot of the Docker Context. This property is only valid if Dockerfile is specified.
               The path is relative to the asset path which must contain a single Blob URI value.
               <seealso href="https://docs.docker.com/engine/context/working-with-contexts/" />
        :param 'DockerImagePlatformResponse' platform: The platform information of the docker image.
        """
        pulumi.set(__self__, "docker_specification_type", 'Build')
        pulumi.set(__self__, "dockerfile", dockerfile)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)

    @property
    @pulumi.getter(name="dockerSpecificationType")
    def docker_specification_type(self) -> builtins.str:
        """
        Enum to determine docker specification type. Must be either Build or Image.
        Expected value is 'Build'.
        """
        return pulumi.get(self, "docker_specification_type")

    @property
    @pulumi.getter
    def dockerfile(self) -> builtins.str:
        """
        [Required] Docker command line instructions to assemble an image.
        <seealso href="https://repo2docker.readthedocs.io/en/latest/config_files.html#dockerfile-advanced-environments" />
        """
        return pulumi.get(self, "dockerfile")

    @property
    @pulumi.getter
    def context(self) -> Optional[builtins.str]:
        """
        Path to a snapshot of the Docker Context. This property is only valid if Dockerfile is specified.
        The path is relative to the asset path which must contain a single Blob URI value.
        <seealso href="https://docs.docker.com/engine/context/working-with-contexts/" />
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def platform(self) -> Optional['outputs.DockerImagePlatformResponse']:
        """
        The platform information of the docker image.
        """
        return pulumi.get(self, "platform")


@pulumi.output_type
class DockerImagePlatformResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatingSystemType":
            suggest = "operating_system_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DockerImagePlatformResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DockerImagePlatformResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DockerImagePlatformResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operating_system_type: Optional[builtins.str] = None):
        """
        :param builtins.str operating_system_type: The OS type the Environment.
        """
        if operating_system_type is not None:
            pulumi.set(__self__, "operating_system_type", operating_system_type)

    @property
    @pulumi.getter(name="operatingSystemType")
    def operating_system_type(self) -> Optional[builtins.str]:
        """
        The OS type the Environment.
        """
        return pulumi.get(self, "operating_system_type")


@pulumi.output_type
class DockerImageResponse(dict):
    """
    Class to represent configuration settings for Docker Build
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dockerImageUri":
            suggest = "docker_image_uri"
        elif key == "dockerSpecificationType":
            suggest = "docker_specification_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DockerImageResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DockerImageResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DockerImageResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 docker_image_uri: builtins.str,
                 docker_specification_type: builtins.str,
                 platform: Optional['outputs.DockerImagePlatformResponse'] = None):
        """
        Class to represent configuration settings for Docker Build
        :param builtins.str docker_image_uri: [Required] Image name of a custom base image.
               <seealso href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-image#use-a-custom-base-image" />
        :param builtins.str docker_specification_type: Enum to determine docker specification type. Must be either Build or Image.
               Expected value is 'Image'.
        :param 'DockerImagePlatformResponse' platform: The platform information of the docker image.
        """
        pulumi.set(__self__, "docker_image_uri", docker_image_uri)
        pulumi.set(__self__, "docker_specification_type", 'Image')
        if platform is not None:
            pulumi.set(__self__, "platform", platform)

    @property
    @pulumi.getter(name="dockerImageUri")
    def docker_image_uri(self) -> builtins.str:
        """
        [Required] Image name of a custom base image.
        <seealso href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-image#use-a-custom-base-image" />
        """
        return pulumi.get(self, "docker_image_uri")

    @property
    @pulumi.getter(name="dockerSpecificationType")
    def docker_specification_type(self) -> builtins.str:
        """
        Enum to determine docker specification type. Must be either Build or Image.
        Expected value is 'Image'.
        """
        return pulumi.get(self, "docker_specification_type")

    @property
    @pulumi.getter
    def platform(self) -> Optional['outputs.DockerImagePlatformResponse']:
        """
        The platform information of the docker image.
        """
        return pulumi.get(self, "platform")


@pulumi.output_type
class DockerResponse(dict):
    """
    Docker container configuration
    """
    def __init__(__self__, *,
                 privileged: Optional[builtins.bool] = None):
        """
        Docker container configuration
        :param builtins.bool privileged: Indicate whether container shall run in privileged or non-privileged mode.
        """
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)

    @property
    @pulumi.getter
    def privileged(self) -> Optional[builtins.bool]:
        """
        Indicate whether container shall run in privileged or non-privileged mode.
        """
        return pulumi.get(self, "privileged")


@pulumi.output_type
class EncryptionKeyVaultPropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyIdentifier":
            suggest = "key_identifier"
        elif key == "keyVaultArmId":
            suggest = "key_vault_arm_id"
        elif key == "identityClientId":
            suggest = "identity_client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionKeyVaultPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionKeyVaultPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionKeyVaultPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_identifier: builtins.str,
                 key_vault_arm_id: builtins.str,
                 identity_client_id: Optional[builtins.str] = None):
        """
        :param builtins.str key_identifier: Key vault uri to access the encryption key.
        :param builtins.str key_vault_arm_id: The ArmId of the keyVault where the customer owned encryption key is present.
        :param builtins.str identity_client_id: For future use - The client id of the identity which will be used to access key vault.
        """
        pulumi.set(__self__, "key_identifier", key_identifier)
        pulumi.set(__self__, "key_vault_arm_id", key_vault_arm_id)
        if identity_client_id is not None:
            pulumi.set(__self__, "identity_client_id", identity_client_id)

    @property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> builtins.str:
        """
        Key vault uri to access the encryption key.
        """
        return pulumi.get(self, "key_identifier")

    @property
    @pulumi.getter(name="keyVaultArmId")
    def key_vault_arm_id(self) -> builtins.str:
        """
        The ArmId of the keyVault where the customer owned encryption key is present.
        """
        return pulumi.get(self, "key_vault_arm_id")

    @property
    @pulumi.getter(name="identityClientId")
    def identity_client_id(self) -> Optional[builtins.str]:
        """
        For future use - The client id of the identity which will be used to access key vault.
        """
        return pulumi.get(self, "identity_client_id")


@pulumi.output_type
class EncryptionPropertyResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultProperties":
            suggest = "key_vault_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionPropertyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionPropertyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionPropertyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_properties: 'outputs.EncryptionKeyVaultPropertiesResponse',
                 status: builtins.str,
                 identity: Optional['outputs.IdentityForCmkResponse'] = None):
        """
        :param 'EncryptionKeyVaultPropertiesResponse' key_vault_properties: Customer Key vault properties.
        :param builtins.str status: Indicates whether or not the encryption is enabled for the workspace.
        :param 'IdentityForCmkResponse' identity: The identity that will be used to access the key vault for encryption at rest.
        """
        pulumi.set(__self__, "key_vault_properties", key_vault_properties)
        pulumi.set(__self__, "status", status)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)

    @property
    @pulumi.getter(name="keyVaultProperties")
    def key_vault_properties(self) -> 'outputs.EncryptionKeyVaultPropertiesResponse':
        """
        Customer Key vault properties.
        """
        return pulumi.get(self, "key_vault_properties")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Indicates whether or not the encryption is enabled for the workspace.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def identity(self) -> Optional['outputs.IdentityForCmkResponse']:
        """
        The identity that will be used to access the key vault for encryption at rest.
        """
        return pulumi.get(self, "identity")


@pulumi.output_type
class EndpointDeploymentModelResponse(dict):
    def __init__(__self__, *,
                 format: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 source: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        :param builtins.str format: Model format
        :param builtins.str name: Model name.
        :param builtins.str source: Optional. Deployment model source ARM resource ID.
        :param builtins.str version: Model version.
        """
        if format is not None:
            pulumi.set(__self__, "format", format)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def format(self) -> Optional[builtins.str]:
        """
        Model format
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Model name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def source(self) -> Optional[builtins.str]:
        """
        Optional. Deployment model source ARM resource ID.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Model version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class EndpointModelDeprecationPropertiesResponse(dict):
    def __init__(__self__, *,
                 fine_tune: Optional[builtins.str] = None,
                 inference: Optional[builtins.str] = None):
        """
        :param builtins.str fine_tune: The datetime of deprecation of the fineTune Model.
        :param builtins.str inference: The datetime of deprecation of the inference Model.
        """
        if fine_tune is not None:
            pulumi.set(__self__, "fine_tune", fine_tune)
        if inference is not None:
            pulumi.set(__self__, "inference", inference)

    @property
    @pulumi.getter(name="fineTune")
    def fine_tune(self) -> Optional[builtins.str]:
        """
        The datetime of deprecation of the fineTune Model.
        """
        return pulumi.get(self, "fine_tune")

    @property
    @pulumi.getter
    def inference(self) -> Optional[builtins.str]:
        """
        The datetime of deprecation of the inference Model.
        """
        return pulumi.get(self, "inference")


@pulumi.output_type
class EndpointModelPropertiesResponse(dict):
    """
    Endpoint Model properties.
    """
    def __init__(__self__, *,
                 system_data: 'outputs.SystemDataResponse',
                 capabilities: Optional[Mapping[str, builtins.str]] = None,
                 deprecation: Optional['outputs.EndpointModelDeprecationPropertiesResponse'] = None,
                 finetune_capabilities: Optional[Mapping[str, builtins.str]] = None,
                 format: Optional[builtins.str] = None,
                 is_default_version: Optional[builtins.bool] = None,
                 lifecycle_status: Optional[builtins.str] = None,
                 max_capacity: Optional[builtins.int] = None,
                 name: Optional[builtins.str] = None,
                 skus: Optional[Sequence['outputs.EndpointModelSkuPropertiesResponse']] = None,
                 version: Optional[builtins.str] = None):
        """
        Endpoint Model properties.
        :param 'SystemDataResponse' system_data: Metadata pertaining to creation and last modification of the resource.
        :param Mapping[str, builtins.str] capabilities: The capabilities.
        :param Mapping[str, builtins.str] finetune_capabilities: The capabilities for finetune models.
        :param builtins.str format: Deployment model format.
        :param builtins.bool is_default_version: If the model is default version.
        :param builtins.str lifecycle_status: Model lifecycle status.
        :param builtins.int max_capacity: The max capacity.
        :param builtins.str name: Deployment model name.
        :param Sequence['EndpointModelSkuPropertiesResponse'] skus: The list of Model Sku.
        :param builtins.str version: Optional. Deployment model version. If version is not specified, a default version will be assigned. The default version is different for different models and might change when there is new version available for a model. Default version for a model could be found from list models API.
        """
        pulumi.set(__self__, "system_data", system_data)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if deprecation is not None:
            pulumi.set(__self__, "deprecation", deprecation)
        if finetune_capabilities is not None:
            pulumi.set(__self__, "finetune_capabilities", finetune_capabilities)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if is_default_version is not None:
            pulumi.set(__self__, "is_default_version", is_default_version)
        if lifecycle_status is not None:
            pulumi.set(__self__, "lifecycle_status", lifecycle_status)
        if max_capacity is not None:
            pulumi.set(__self__, "max_capacity", max_capacity)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if skus is not None:
            pulumi.set(__self__, "skus", skus)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Metadata pertaining to creation and last modification of the resource.
        """
        return pulumi.get(self, "system_data")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The capabilities.
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def deprecation(self) -> Optional['outputs.EndpointModelDeprecationPropertiesResponse']:
        return pulumi.get(self, "deprecation")

    @property
    @pulumi.getter(name="finetuneCapabilities")
    def finetune_capabilities(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The capabilities for finetune models.
        """
        return pulumi.get(self, "finetune_capabilities")

    @property
    @pulumi.getter
    def format(self) -> Optional[builtins.str]:
        """
        Deployment model format.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="isDefaultVersion")
    def is_default_version(self) -> Optional[builtins.bool]:
        """
        If the model is default version.
        """
        return pulumi.get(self, "is_default_version")

    @property
    @pulumi.getter(name="lifecycleStatus")
    def lifecycle_status(self) -> Optional[builtins.str]:
        """
        Model lifecycle status.
        """
        return pulumi.get(self, "lifecycle_status")

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[builtins.int]:
        """
        The max capacity.
        """
        return pulumi.get(self, "max_capacity")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Deployment model name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def skus(self) -> Optional[Sequence['outputs.EndpointModelSkuPropertiesResponse']]:
        """
        The list of Model Sku.
        """
        return pulumi.get(self, "skus")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Optional. Deployment model version. If version is not specified, a default version will be assigned. The default version is different for different models and might change when there is new version available for a model. Default version for a model could be found from list models API.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class EndpointModelSkuCapacityPropertiesResponse(dict):
    def __init__(__self__, *,
                 default: Optional[builtins.int] = None,
                 maximum: Optional[builtins.int] = None):
        """
        :param builtins.int default: The default capacity.
        :param builtins.int maximum: The maximum capacity.
        """
        if default is not None:
            pulumi.set(__self__, "default", default)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)

    @property
    @pulumi.getter
    def default(self) -> Optional[builtins.int]:
        """
        The default capacity.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def maximum(self) -> Optional[builtins.int]:
        """
        The maximum capacity.
        """
        return pulumi.get(self, "maximum")


@pulumi.output_type
class EndpointModelSkuPropertiesResponse(dict):
    def __init__(__self__, *,
                 capacity: Optional['outputs.EndpointModelSkuCapacityPropertiesResponse'] = None,
                 connection_ids: Optional[Sequence[builtins.str]] = None,
                 deprecation_date: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 rate_limits: Optional[Sequence['outputs.EndpointModelSkuRateLimitPropertiesResponse']] = None,
                 usage_name: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] connection_ids: The list of ARM id for the connection support this SKU.
        :param builtins.str deprecation_date: The datetime of deprecation of the model SKU.
        :param builtins.str name: The name of the model SKU.
        :param builtins.str usage_name: The usage name of the model SKU.
        """
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if connection_ids is not None:
            pulumi.set(__self__, "connection_ids", connection_ids)
        if deprecation_date is not None:
            pulumi.set(__self__, "deprecation_date", deprecation_date)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if rate_limits is not None:
            pulumi.set(__self__, "rate_limits", rate_limits)
        if usage_name is not None:
            pulumi.set(__self__, "usage_name", usage_name)

    @property
    @pulumi.getter
    def capacity(self) -> Optional['outputs.EndpointModelSkuCapacityPropertiesResponse']:
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter(name="connectionIds")
    def connection_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        The list of ARM id for the connection support this SKU.
        """
        return pulumi.get(self, "connection_ids")

    @property
    @pulumi.getter(name="deprecationDate")
    def deprecation_date(self) -> Optional[builtins.str]:
        """
        The datetime of deprecation of the model SKU.
        """
        return pulumi.get(self, "deprecation_date")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the model SKU.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="rateLimits")
    def rate_limits(self) -> Optional[Sequence['outputs.EndpointModelSkuRateLimitPropertiesResponse']]:
        return pulumi.get(self, "rate_limits")

    @property
    @pulumi.getter(name="usageName")
    def usage_name(self) -> Optional[builtins.str]:
        """
        The usage name of the model SKU.
        """
        return pulumi.get(self, "usage_name")


@pulumi.output_type
class EndpointModelSkuRateLimitPropertiesResponse(dict):
    def __init__(__self__, *,
                 count: Optional[builtins.float] = None,
                 renewal_period: Optional[builtins.float] = None,
                 rules: Optional[Sequence['outputs.EndpointModelSkuRateLimitRulePropertiesResponse']] = None):
        """
        :param builtins.float count: The count value of Call Rate Limit.
        :param builtins.float renewal_period: The renewal period in seconds of Call Rate Limit.
        :param Sequence['EndpointModelSkuRateLimitRulePropertiesResponse'] rules: The call rate limit for the model.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if renewal_period is not None:
            pulumi.set(__self__, "renewal_period", renewal_period)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def count(self) -> Optional[builtins.float]:
        """
        The count value of Call Rate Limit.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="renewalPeriod")
    def renewal_period(self) -> Optional[builtins.float]:
        """
        The renewal period in seconds of Call Rate Limit.
        """
        return pulumi.get(self, "renewal_period")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.EndpointModelSkuRateLimitRulePropertiesResponse']]:
        """
        The call rate limit for the model.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class EndpointModelSkuRateLimitRulePatternPropertiesResponse(dict):
    def __init__(__self__, *,
                 method: Optional[builtins.str] = None,
                 path: Optional[builtins.str] = None):
        if method is not None:
            pulumi.set(__self__, "method", method)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def method(self) -> Optional[builtins.str]:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class EndpointModelSkuRateLimitRulePropertiesResponse(dict):
    def __init__(__self__, *,
                 count: Optional[builtins.float] = None,
                 dynamic_throttling_enabled: Optional[builtins.bool] = None,
                 key: Optional[builtins.str] = None,
                 match_patterns: Optional[Sequence['outputs.EndpointModelSkuRateLimitRulePatternPropertiesResponse']] = None,
                 min_count: Optional[builtins.float] = None,
                 renewal_period: Optional[builtins.float] = None):
        """
        :param builtins.bool dynamic_throttling_enabled: If the dynamic throttling is enabled.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if dynamic_throttling_enabled is not None:
            pulumi.set(__self__, "dynamic_throttling_enabled", dynamic_throttling_enabled)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_patterns is not None:
            pulumi.set(__self__, "match_patterns", match_patterns)
        if min_count is not None:
            pulumi.set(__self__, "min_count", min_count)
        if renewal_period is not None:
            pulumi.set(__self__, "renewal_period", renewal_period)

    @property
    @pulumi.getter
    def count(self) -> Optional[builtins.float]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="dynamicThrottlingEnabled")
    def dynamic_throttling_enabled(self) -> Optional[builtins.bool]:
        """
        If the dynamic throttling is enabled.
        """
        return pulumi.get(self, "dynamic_throttling_enabled")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Optional[Sequence['outputs.EndpointModelSkuRateLimitRulePatternPropertiesResponse']]:
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="minCount")
    def min_count(self) -> Optional[builtins.float]:
        return pulumi.get(self, "min_count")

    @property
    @pulumi.getter(name="renewalPeriod")
    def renewal_period(self) -> Optional[builtins.float]:
        return pulumi.get(self, "renewal_period")


@pulumi.output_type
class EndpointResponse(dict):
    """
    Describes the endpoint configuration for the container
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostIp":
            suggest = "host_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_ip: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 protocol: Optional[builtins.str] = None,
                 published: Optional[builtins.int] = None,
                 target: Optional[builtins.int] = None):
        """
        Describes the endpoint configuration for the container
        :param builtins.str host_ip: Host IP over which the application is exposed from the container
        :param builtins.str name: Name of the Endpoint
        :param builtins.str protocol: Protocol over which communication will happen over this endpoint
        :param builtins.int published: Port over which the application is exposed from container.
        :param builtins.int target: Application port inside the container.
        """
        if host_ip is not None:
            pulumi.set(__self__, "host_ip", host_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is None:
            protocol = 'tcp'
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if published is not None:
            pulumi.set(__self__, "published", published)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="hostIp")
    def host_ip(self) -> Optional[builtins.str]:
        """
        Host IP over which the application is exposed from the container
        """
        return pulumi.get(self, "host_ip")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the Endpoint
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[builtins.str]:
        """
        Protocol over which communication will happen over this endpoint
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def published(self) -> Optional[builtins.int]:
        """
        Port over which the application is exposed from container.
        """
        return pulumi.get(self, "published")

    @property
    @pulumi.getter
    def target(self) -> Optional[builtins.int]:
        """
        Application port inside the container.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class EndpointScheduleActionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "endpointInvocationDefinition":
            suggest = "endpoint_invocation_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointScheduleActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointScheduleActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointScheduleActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: builtins.str,
                 endpoint_invocation_definition: Any):
        """
        :param builtins.str action_type: 
               Expected value is 'InvokeBatchEndpoint'.
        :param Any endpoint_invocation_definition: [Required] Defines Schedule action definition details.
               <see href="TBD" />
        """
        pulumi.set(__self__, "action_type", 'InvokeBatchEndpoint')
        pulumi.set(__self__, "endpoint_invocation_definition", endpoint_invocation_definition)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> builtins.str:
        """

        Expected value is 'InvokeBatchEndpoint'.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="endpointInvocationDefinition")
    def endpoint_invocation_definition(self) -> Any:
        """
        [Required] Defines Schedule action definition details.
        <see href="TBD" />
        """
        return pulumi.get(self, "endpoint_invocation_definition")


@pulumi.output_type
class EnvironmentContainerResponse(dict):
    """
    Container for environment specification versions.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latestVersion":
            suggest = "latest_version"
        elif key == "nextVersion":
            suggest = "next_version"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentContainerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentContainerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentContainerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latest_version: builtins.str,
                 next_version: builtins.str,
                 provisioning_state: builtins.str,
                 description: Optional[builtins.str] = None,
                 is_archived: Optional[builtins.bool] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Container for environment specification versions.
        :param builtins.str latest_version: The latest version inside this container.
        :param builtins.str next_version: The next auto incremental version
        :param builtins.str provisioning_state: Provisioning state for the environment container.
        :param builtins.str description: The asset description text.
        :param builtins.bool is_archived: Is the asset archived?
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "latest_version", latest_version)
        pulumi.set(__self__, "next_version", next_version)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> builtins.str:
        """
        The latest version inside this container.
        """
        return pulumi.get(self, "latest_version")

    @property
    @pulumi.getter(name="nextVersion")
    def next_version(self) -> builtins.str:
        """
        The next auto incremental version
        """
        return pulumi.get(self, "next_version")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the environment container.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class EnvironmentSpecificationVersionResponse(dict):
    """
    Environment specification version details.
    <see href="https://repo2docker.readthedocs.io/en/latest/specification.html" />
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentSpecificationType":
            suggest = "environment_specification_type"
        elif key == "condaFile":
            suggest = "conda_file"
        elif key == "inferenceContainerProperties":
            suggest = "inference_container_properties"
        elif key == "isAnonymous":
            suggest = "is_anonymous"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentSpecificationVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentSpecificationVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentSpecificationVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 environment_specification_type: builtins.str,
                 conda_file: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 docker: Optional[Any] = None,
                 inference_container_properties: Optional['outputs.InferenceContainerPropertiesResponse'] = None,
                 is_anonymous: Optional[builtins.bool] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Environment specification version details.
        <see href="https://repo2docker.readthedocs.io/en/latest/specification.html" />
        :param builtins.str environment_specification_type: Environment specification is either user managed or curated by the Azure ML service
               <see href="https://docs.microsoft.com/en-us/azure/machine-learning/resource-curated-environments" />
        :param builtins.str conda_file: Standard configuration file used by Conda that lets you install any kind of package, including Python, R, and C/C++ packages.
               <see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-install-a-conda-environment" />
        :param builtins.str description: The asset description text.
        :param Union['DockerBuildResponse', 'DockerImageResponse'] docker: Configuration settings for Docker.
        :param 'InferenceContainerPropertiesResponse' inference_container_properties: Defines configuration specific to inference.
        :param builtins.bool is_anonymous: If the name version are system generated (anonymous registration).
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "environment_specification_type", environment_specification_type)
        if conda_file is not None:
            pulumi.set(__self__, "conda_file", conda_file)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if docker is not None:
            pulumi.set(__self__, "docker", docker)
        if inference_container_properties is not None:
            pulumi.set(__self__, "inference_container_properties", inference_container_properties)
        if is_anonymous is not None:
            pulumi.set(__self__, "is_anonymous", is_anonymous)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="environmentSpecificationType")
    def environment_specification_type(self) -> builtins.str:
        """
        Environment specification is either user managed or curated by the Azure ML service
        <see href="https://docs.microsoft.com/en-us/azure/machine-learning/resource-curated-environments" />
        """
        return pulumi.get(self, "environment_specification_type")

    @property
    @pulumi.getter(name="condaFile")
    def conda_file(self) -> Optional[builtins.str]:
        """
        Standard configuration file used by Conda that lets you install any kind of package, including Python, R, and C/C++ packages.
        <see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-install-a-conda-environment" />
        """
        return pulumi.get(self, "conda_file")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def docker(self) -> Optional[Any]:
        """
        Configuration settings for Docker.
        """
        return pulumi.get(self, "docker")

    @property
    @pulumi.getter(name="inferenceContainerProperties")
    def inference_container_properties(self) -> Optional['outputs.InferenceContainerPropertiesResponse']:
        """
        Defines configuration specific to inference.
        """
        return pulumi.get(self, "inference_container_properties")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[builtins.bool]:
        """
        If the name version are system generated (anonymous registration).
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class EnvironmentVariableResponse(dict):
    """
    Environment Variables for the container
    """
    def __init__(__self__, *,
                 type: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        Environment Variables for the container
        :param builtins.str type: Type of the Environment Variable. Possible values are: local - For local variable
        :param builtins.str value: Value of the Environment variable
        """
        if type is None:
            type = 'local'
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the Environment Variable. Possible values are: local - For local variable
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value of the Environment variable
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EnvironmentVersionResponse(dict):
    """
    Environment version details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentType":
            suggest = "environment_type"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "autoRebuild":
            suggest = "auto_rebuild"
        elif key == "condaFile":
            suggest = "conda_file"
        elif key == "inferenceConfig":
            suggest = "inference_config"
        elif key == "isAnonymous":
            suggest = "is_anonymous"
        elif key == "isArchived":
            suggest = "is_archived"
        elif key == "osType":
            suggest = "os_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 environment_type: builtins.str,
                 provisioning_state: builtins.str,
                 auto_rebuild: Optional[builtins.str] = None,
                 build: Optional['outputs.BuildContextResponse'] = None,
                 conda_file: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 image: Optional[builtins.str] = None,
                 inference_config: Optional['outputs.InferenceContainerPropertiesResponse'] = None,
                 is_anonymous: Optional[builtins.bool] = None,
                 is_archived: Optional[builtins.bool] = None,
                 os_type: Optional[builtins.str] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 stage: Optional[builtins.str] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Environment version details.
        :param builtins.str environment_type: Environment type is either user managed or curated by the Azure ML service
               <see href="https://docs.microsoft.com/en-us/azure/machine-learning/resource-curated-environments" />
        :param builtins.str provisioning_state: Provisioning state for the environment version.
        :param builtins.str auto_rebuild: Defines if image needs to be rebuilt based on base image changes.
        :param 'BuildContextResponse' build: Configuration settings for Docker build context.
        :param builtins.str conda_file: Standard configuration file used by Conda that lets you install any kind of package, including Python, R, and C/C++ packages.
               <see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-install-a-conda-environment" />
        :param builtins.str description: The asset description text.
        :param builtins.str image: Name of the image that will be used for the environment.
               <seealso href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-image#use-a-custom-base-image" />
        :param 'InferenceContainerPropertiesResponse' inference_config: Defines configuration specific to inference.
        :param builtins.bool is_anonymous: If the name version are system generated (anonymous registration).
        :param builtins.bool is_archived: Is the asset archived?
        :param builtins.str os_type: The OS type of the environment.
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param builtins.str stage: Stage in the environment lifecycle assigned to this environment
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "environment_type", environment_type)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if auto_rebuild is None:
            auto_rebuild = 'Disabled'
        if auto_rebuild is not None:
            pulumi.set(__self__, "auto_rebuild", auto_rebuild)
        if build is not None:
            pulumi.set(__self__, "build", build)
        if conda_file is not None:
            pulumi.set(__self__, "conda_file", conda_file)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if inference_config is not None:
            pulumi.set(__self__, "inference_config", inference_config)
        if is_anonymous is None:
            is_anonymous = False
        if is_anonymous is not None:
            pulumi.set(__self__, "is_anonymous", is_anonymous)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if os_type is None:
            os_type = 'Linux'
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if stage is not None:
            pulumi.set(__self__, "stage", stage)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="environmentType")
    def environment_type(self) -> builtins.str:
        """
        Environment type is either user managed or curated by the Azure ML service
        <see href="https://docs.microsoft.com/en-us/azure/machine-learning/resource-curated-environments" />
        """
        return pulumi.get(self, "environment_type")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the environment version.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="autoRebuild")
    def auto_rebuild(self) -> Optional[builtins.str]:
        """
        Defines if image needs to be rebuilt based on base image changes.
        """
        return pulumi.get(self, "auto_rebuild")

    @property
    @pulumi.getter
    def build(self) -> Optional['outputs.BuildContextResponse']:
        """
        Configuration settings for Docker build context.
        """
        return pulumi.get(self, "build")

    @property
    @pulumi.getter(name="condaFile")
    def conda_file(self) -> Optional[builtins.str]:
        """
        Standard configuration file used by Conda that lets you install any kind of package, including Python, R, and C/C++ packages.
        <see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-install-a-conda-environment" />
        """
        return pulumi.get(self, "conda_file")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def image(self) -> Optional[builtins.str]:
        """
        Name of the image that will be used for the environment.
        <seealso href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-image#use-a-custom-base-image" />
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="inferenceConfig")
    def inference_config(self) -> Optional['outputs.InferenceContainerPropertiesResponse']:
        """
        Defines configuration specific to inference.
        """
        return pulumi.get(self, "inference_config")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[builtins.bool]:
        """
        If the name version are system generated (anonymous registration).
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[builtins.str]:
        """
        The OS type of the environment.
        """
        return pulumi.get(self, "os_type")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def stage(self) -> Optional[builtins.str]:
        """
        Stage in the environment lifecycle assigned to this environment
        """
        return pulumi.get(self, "stage")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ErrorAdditionalInfoResponse(dict):
    """
    The resource management error additional info.
    """
    def __init__(__self__, *,
                 info: Any,
                 type: builtins.str):
        """
        The resource management error additional info.
        :param Any info: The additional info.
        :param builtins.str type: The additional info type.
        """
        pulumi.set(__self__, "info", info)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def info(self) -> Any:
        """
        The additional info.
        """
        return pulumi.get(self, "info")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The additional info type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ErrorDetailResponse(dict):
    """
    The error detail.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalInfo":
            suggest = "additional_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ErrorDetailResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ErrorDetailResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ErrorDetailResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_info: Sequence['outputs.ErrorAdditionalInfoResponse'],
                 code: builtins.str,
                 details: Sequence['outputs.ErrorDetailResponse'],
                 message: builtins.str,
                 target: builtins.str):
        """
        The error detail.
        :param Sequence['ErrorAdditionalInfoResponse'] additional_info: The error additional info.
        :param builtins.str code: The error code.
        :param Sequence['ErrorDetailResponse'] details: The error details.
        :param builtins.str message: The error message.
        :param builtins.str target: The error target.
        """
        pulumi.set(__self__, "additional_info", additional_info)
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="additionalInfo")
    def additional_info(self) -> Sequence['outputs.ErrorAdditionalInfoResponse']:
        """
        The error additional info.
        """
        return pulumi.get(self, "additional_info")

    @property
    @pulumi.getter
    def code(self) -> builtins.str:
        """
        The error code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.ErrorDetailResponse']:
        """
        The error details.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def message(self) -> builtins.str:
        """
        The error message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def target(self) -> builtins.str:
        """
        The error target.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class ErrorResponseResponse(dict):
    """
    Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData error response format.).
    """
    def __init__(__self__, *,
                 error: Optional['outputs.ErrorDetailResponse'] = None):
        """
        Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData error response format.).
        :param 'ErrorDetailResponse' error: The error object.
        """
        if error is not None:
            pulumi.set(__self__, "error", error)

    @property
    @pulumi.getter
    def error(self) -> Optional['outputs.ErrorDetailResponse']:
        """
        The error object.
        """
        return pulumi.get(self, "error")


@pulumi.output_type
class EstimatedVMPriceResponse(dict):
    """
    The estimated price info for using a VM of a particular OS type, tier, etc.
    """
    def __init__(__self__, *,
                 os_type: builtins.str,
                 retail_price: builtins.float,
                 vm_tier: builtins.str):
        """
        The estimated price info for using a VM of a particular OS type, tier, etc.
        :param builtins.str os_type: Operating system type used by the VM.
        :param builtins.float retail_price: The price charged for using the VM.
        :param builtins.str vm_tier: The type of the VM.
        """
        pulumi.set(__self__, "os_type", os_type)
        pulumi.set(__self__, "retail_price", retail_price)
        pulumi.set(__self__, "vm_tier", vm_tier)

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> builtins.str:
        """
        Operating system type used by the VM.
        """
        return pulumi.get(self, "os_type")

    @property
    @pulumi.getter(name="retailPrice")
    def retail_price(self) -> builtins.float:
        """
        The price charged for using the VM.
        """
        return pulumi.get(self, "retail_price")

    @property
    @pulumi.getter(name="vmTier")
    def vm_tier(self) -> builtins.str:
        """
        The type of the VM.
        """
        return pulumi.get(self, "vm_tier")


@pulumi.output_type
class EstimatedVMPricesResponse(dict):
    """
    The estimated price info for using a VM.
    """
    def __init__(__self__, *,
                 billing_currency: builtins.str,
                 unit_of_measure: builtins.str,
                 values: Sequence['outputs.EstimatedVMPriceResponse']):
        """
        The estimated price info for using a VM.
        :param builtins.str billing_currency: Three lettered code specifying the currency of the VM price. Example: USD
        :param builtins.str unit_of_measure: The unit of time measurement for the specified VM price. Example: OneHour
        :param Sequence['EstimatedVMPriceResponse'] values: The list of estimated prices for using a VM of a particular OS type, tier, etc.
        """
        pulumi.set(__self__, "billing_currency", billing_currency)
        pulumi.set(__self__, "unit_of_measure", unit_of_measure)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="billingCurrency")
    def billing_currency(self) -> builtins.str:
        """
        Three lettered code specifying the currency of the VM price. Example: USD
        """
        return pulumi.get(self, "billing_currency")

    @property
    @pulumi.getter(name="unitOfMeasure")
    def unit_of_measure(self) -> builtins.str:
        """
        The unit of time measurement for the specified VM price. Example: OneHour
        """
        return pulumi.get(self, "unit_of_measure")

    @property
    @pulumi.getter
    def values(self) -> Sequence['outputs.EstimatedVMPriceResponse']:
        """
        The list of estimated prices for using a VM of a particular OS type, tier, etc.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class FeatureAttributionDriftMonitoringSignalResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "featureImportanceSettings":
            suggest = "feature_importance_settings"
        elif key == "metricThreshold":
            suggest = "metric_threshold"
        elif key == "productionData":
            suggest = "production_data"
        elif key == "referenceData":
            suggest = "reference_data"
        elif key == "signalType":
            suggest = "signal_type"
        elif key == "featureDataTypeOverride":
            suggest = "feature_data_type_override"
        elif key == "notificationTypes":
            suggest = "notification_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureAttributionDriftMonitoringSignalResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureAttributionDriftMonitoringSignalResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureAttributionDriftMonitoringSignalResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 feature_importance_settings: 'outputs.FeatureImportanceSettingsResponse',
                 metric_threshold: 'outputs.FeatureAttributionMetricThresholdResponse',
                 production_data: Sequence[Any],
                 reference_data: Any,
                 signal_type: builtins.str,
                 feature_data_type_override: Optional[Mapping[str, builtins.str]] = None,
                 notification_types: Optional[Sequence[builtins.str]] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None):
        """
        :param 'FeatureImportanceSettingsResponse' feature_importance_settings: [Required] The settings for computing feature importance.
        :param 'FeatureAttributionMetricThresholdResponse' metric_threshold: [Required] A list of metrics to calculate and their associated thresholds.
        :param Sequence[Union['FixedInputDataResponse', 'RollingInputDataResponse', 'StaticInputDataResponse']] production_data: [Required] The data which drift will be calculated for.
        :param Union['FixedInputDataResponse', 'RollingInputDataResponse', 'StaticInputDataResponse'] reference_data: [Required] The data to calculate drift against.
        :param builtins.str signal_type: 
               Expected value is 'FeatureAttributionDrift'.
        :param Mapping[str, builtins.str] feature_data_type_override: A dictionary that maps feature names to their respective data types.
        :param Sequence[builtins.str] notification_types: The current notification mode for this signal.
        :param Mapping[str, builtins.str] properties: Property dictionary. Properties can be added, but not removed or altered.
        """
        pulumi.set(__self__, "feature_importance_settings", feature_importance_settings)
        pulumi.set(__self__, "metric_threshold", metric_threshold)
        pulumi.set(__self__, "production_data", production_data)
        pulumi.set(__self__, "reference_data", reference_data)
        pulumi.set(__self__, "signal_type", 'FeatureAttributionDrift')
        if feature_data_type_override is not None:
            pulumi.set(__self__, "feature_data_type_override", feature_data_type_override)
        if notification_types is not None:
            pulumi.set(__self__, "notification_types", notification_types)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter(name="featureImportanceSettings")
    def feature_importance_settings(self) -> 'outputs.FeatureImportanceSettingsResponse':
        """
        [Required] The settings for computing feature importance.
        """
        return pulumi.get(self, "feature_importance_settings")

    @property
    @pulumi.getter(name="metricThreshold")
    def metric_threshold(self) -> 'outputs.FeatureAttributionMetricThresholdResponse':
        """
        [Required] A list of metrics to calculate and their associated thresholds.
        """
        return pulumi.get(self, "metric_threshold")

    @property
    @pulumi.getter(name="productionData")
    def production_data(self) -> Sequence[Any]:
        """
        [Required] The data which drift will be calculated for.
        """
        return pulumi.get(self, "production_data")

    @property
    @pulumi.getter(name="referenceData")
    def reference_data(self) -> Any:
        """
        [Required] The data to calculate drift against.
        """
        return pulumi.get(self, "reference_data")

    @property
    @pulumi.getter(name="signalType")
    def signal_type(self) -> builtins.str:
        """

        Expected value is 'FeatureAttributionDrift'.
        """
        return pulumi.get(self, "signal_type")

    @property
    @pulumi.getter(name="featureDataTypeOverride")
    def feature_data_type_override(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A dictionary that maps feature names to their respective data types.
        """
        return pulumi.get(self, "feature_data_type_override")

    @property
    @pulumi.getter(name="notificationTypes")
    def notification_types(self) -> Optional[Sequence[builtins.str]]:
        """
        The current notification mode for this signal.
        """
        return pulumi.get(self, "notification_types")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class FeatureAttributionMetricThresholdResponse(dict):
    def __init__(__self__, *,
                 metric: builtins.str,
                 threshold: Optional['outputs.MonitoringThresholdResponse'] = None):
        """
        :param builtins.str metric: [Required] The feature attribution metric to calculate.
        :param 'MonitoringThresholdResponse' threshold: The threshold value. If null, a default value will be set depending on the selected metric.
        """
        pulumi.set(__self__, "metric", metric)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def metric(self) -> builtins.str:
        """
        [Required] The feature attribution metric to calculate.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def threshold(self) -> Optional['outputs.MonitoringThresholdResponse']:
        """
        The threshold value. If null, a default value will be set depending on the selected metric.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class FeatureImportanceSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetColumn":
            suggest = "target_column"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureImportanceSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureImportanceSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureImportanceSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[builtins.str] = None,
                 target_column: Optional[builtins.str] = None):
        """
        :param builtins.str mode: The mode of operation for computing feature importance.
        :param builtins.str target_column: The name of the target column within the input data asset.
        """
        if mode is None:
            mode = 'Disabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if target_column is not None:
            pulumi.set(__self__, "target_column", target_column)

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        The mode of operation for computing feature importance.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="targetColumn")
    def target_column(self) -> Optional[builtins.str]:
        """
        The name of the target column within the input data asset.
        """
        return pulumi.get(self, "target_column")


@pulumi.output_type
class FeatureResponse(dict):
    """
    Dto object representing feature
    """
    def __init__(__self__, *,
                 data_type: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 feature_name: Optional[builtins.str] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Dto object representing feature
        :param builtins.str data_type: Specifies type
        :param builtins.str description: Specifies description
        :param builtins.str feature_name: Specifies name
        :param Mapping[str, builtins.str] tags: Specifies tags
        """
        if data_type is None:
            data_type = 'String'
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if feature_name is not None:
            pulumi.set(__self__, "feature_name", feature_name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[builtins.str]:
        """
        Specifies type
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Specifies description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="featureName")
    def feature_name(self) -> Optional[builtins.str]:
        """
        Specifies name
        """
        return pulumi.get(self, "feature_name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Specifies tags
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class FeatureStoreSettingsResponse(dict):
    """
    Settings for feature store type workspace.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeRuntime":
            suggest = "compute_runtime"
        elif key == "offlineStoreConnectionName":
            suggest = "offline_store_connection_name"
        elif key == "onlineStoreConnectionName":
            suggest = "online_store_connection_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureStoreSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureStoreSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureStoreSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_runtime: Optional['outputs.ComputeRuntimeDtoResponse'] = None,
                 offline_store_connection_name: Optional[builtins.str] = None,
                 online_store_connection_name: Optional[builtins.str] = None):
        """
        Settings for feature store type workspace.
        :param 'ComputeRuntimeDtoResponse' compute_runtime: Compute runtime config for feature store type workspace.
        """
        if compute_runtime is not None:
            pulumi.set(__self__, "compute_runtime", compute_runtime)
        if offline_store_connection_name is not None:
            pulumi.set(__self__, "offline_store_connection_name", offline_store_connection_name)
        if online_store_connection_name is not None:
            pulumi.set(__self__, "online_store_connection_name", online_store_connection_name)

    @property
    @pulumi.getter(name="computeRuntime")
    def compute_runtime(self) -> Optional['outputs.ComputeRuntimeDtoResponse']:
        """
        Compute runtime config for feature store type workspace.
        """
        return pulumi.get(self, "compute_runtime")

    @property
    @pulumi.getter(name="offlineStoreConnectionName")
    def offline_store_connection_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "offline_store_connection_name")

    @property
    @pulumi.getter(name="onlineStoreConnectionName")
    def online_store_connection_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "online_store_connection_name")


@pulumi.output_type
class FeatureSubsetResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureSubsetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureSubsetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureSubsetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 features: Sequence[builtins.str],
                 filter_type: builtins.str):
        """
        :param Sequence[builtins.str] features: [Required] The list of features to include.
        :param builtins.str filter_type: 
               Expected value is 'FeatureSubset'.
        """
        pulumi.set(__self__, "features", features)
        pulumi.set(__self__, "filter_type", 'FeatureSubset')

    @property
    @pulumi.getter
    def features(self) -> Sequence[builtins.str]:
        """
        [Required] The list of features to include.
        """
        return pulumi.get(self, "features")

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        """

        Expected value is 'FeatureSubset'.
        """
        return pulumi.get(self, "filter_type")


@pulumi.output_type
class FeatureWindowResponse(dict):
    """
    Specifies the feature window
    """
    def __init__(__self__, *,
                 feature_window_end: Optional[builtins.str] = None,
                 feature_window_start: Optional[builtins.str] = None):
        """
        Specifies the feature window
        :param builtins.str feature_window_end: Specifies the feature window end time
        :param builtins.str feature_window_start: Specifies the feature window start time
        """
        if feature_window_end is not None:
            pulumi.set(__self__, "feature_window_end", feature_window_end)
        if feature_window_start is not None:
            pulumi.set(__self__, "feature_window_start", feature_window_start)

    @property
    @pulumi.getter(name="featureWindowEnd")
    def feature_window_end(self) -> Optional[builtins.str]:
        """
        Specifies the feature window end time
        """
        return pulumi.get(self, "feature_window_end")

    @property
    @pulumi.getter(name="featureWindowStart")
    def feature_window_start(self) -> Optional[builtins.str]:
        """
        Specifies the feature window start time
        """
        return pulumi.get(self, "feature_window_start")


@pulumi.output_type
class FeaturesetContainerResponse(dict):
    """
    DTO object representing feature set
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latestVersion":
            suggest = "latest_version"
        elif key == "nextVersion":
            suggest = "next_version"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeaturesetContainerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeaturesetContainerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeaturesetContainerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latest_version: builtins.str,
                 next_version: builtins.str,
                 provisioning_state: builtins.str,
                 description: Optional[builtins.str] = None,
                 is_archived: Optional[builtins.bool] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        DTO object representing feature set
        :param builtins.str latest_version: The latest version inside this container.
        :param builtins.str next_version: The next auto incremental version
        :param builtins.str provisioning_state: Provisioning state for the featureset container.
        :param builtins.str description: The asset description text.
        :param builtins.bool is_archived: Is the asset archived?
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "latest_version", latest_version)
        pulumi.set(__self__, "next_version", next_version)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> builtins.str:
        """
        The latest version inside this container.
        """
        return pulumi.get(self, "latest_version")

    @property
    @pulumi.getter(name="nextVersion")
    def next_version(self) -> builtins.str:
        """
        The next auto incremental version
        """
        return pulumi.get(self, "next_version")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the featureset container.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class FeaturesetJobResponse(dict):
    """
    Dto object representing the feature set job
    """
    def __init__(__self__, *,
                 created_date: Optional[builtins.str] = None,
                 display_name: Optional[builtins.str] = None,
                 duration: Optional[builtins.str] = None,
                 experiment_id: Optional[builtins.str] = None,
                 feature_window: Optional['outputs.FeatureWindowResponse'] = None,
                 job_id: Optional[builtins.str] = None,
                 status: Optional[builtins.str] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None,
                 type: Optional[builtins.str] = None):
        """
        Dto object representing the feature set job
        :param builtins.str created_date: Specifies the created date
        :param builtins.str display_name: Specifies the display name
        :param builtins.str duration: Specifies the duration
        :param builtins.str experiment_id: Specifies the experiment id
        :param 'FeatureWindowResponse' feature_window: Specifies the backfill feature window to be materialized
        :param builtins.str job_id: Specifies the job id
        :param builtins.str status: Specifies the job status
        :param Mapping[str, builtins.str] tags: Specifies the tags if any
        :param builtins.str type: Specifies the feature store job type
        """
        if created_date is not None:
            pulumi.set(__self__, "created_date", created_date)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if experiment_id is not None:
            pulumi.set(__self__, "experiment_id", experiment_id)
        if feature_window is not None:
            pulumi.set(__self__, "feature_window", feature_window)
        if job_id is not None:
            pulumi.set(__self__, "job_id", job_id)
        if status is None:
            status = 'Unknown'
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is None:
            type = 'RecurrentMaterialization'
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> Optional[builtins.str]:
        """
        Specifies the created date
        """
        return pulumi.get(self, "created_date")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        Specifies the display name
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def duration(self) -> Optional[builtins.str]:
        """
        Specifies the duration
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="experimentId")
    def experiment_id(self) -> Optional[builtins.str]:
        """
        Specifies the experiment id
        """
        return pulumi.get(self, "experiment_id")

    @property
    @pulumi.getter(name="featureWindow")
    def feature_window(self) -> Optional['outputs.FeatureWindowResponse']:
        """
        Specifies the backfill feature window to be materialized
        """
        return pulumi.get(self, "feature_window")

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> Optional[builtins.str]:
        """
        Specifies the job id
        """
        return pulumi.get(self, "job_id")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Specifies the job status
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Specifies the tags if any
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Specifies the feature store job type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FeaturesetSpecificationResponse(dict):
    """
    DTO object representing specification
    """
    def __init__(__self__, *,
                 path: Optional[builtins.str] = None):
        """
        DTO object representing specification
        :param builtins.str path: Specifies the spec path
        """
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        Specifies the spec path
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class FeaturesetVersionResponse(dict):
    """
    DTO object representing feature set version
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "isAnonymous":
            suggest = "is_anonymous"
        elif key == "isArchived":
            suggest = "is_archived"
        elif key == "materializationSettings":
            suggest = "materialization_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeaturesetVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeaturesetVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeaturesetVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 description: Optional[builtins.str] = None,
                 entities: Optional[Sequence[builtins.str]] = None,
                 is_anonymous: Optional[builtins.bool] = None,
                 is_archived: Optional[builtins.bool] = None,
                 materialization_settings: Optional['outputs.MaterializationSettingsResponse'] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 specification: Optional['outputs.FeaturesetSpecificationResponse'] = None,
                 stage: Optional[builtins.str] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        DTO object representing feature set version
        :param builtins.str provisioning_state: Provisioning state for the featureset version container.
        :param builtins.str description: The asset description text.
        :param Sequence[builtins.str] entities: Specifies list of entities
        :param builtins.bool is_anonymous: If the name version are system generated (anonymous registration).
        :param builtins.bool is_archived: Is the asset archived?
        :param 'MaterializationSettingsResponse' materialization_settings: Specifies the materialization settings
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param 'FeaturesetSpecificationResponse' specification: Specifies the feature spec details
        :param builtins.str stage: Specifies the asset stage
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if is_anonymous is None:
            is_anonymous = False
        if is_anonymous is not None:
            pulumi.set(__self__, "is_anonymous", is_anonymous)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if materialization_settings is not None:
            pulumi.set(__self__, "materialization_settings", materialization_settings)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if specification is not None:
            pulumi.set(__self__, "specification", specification)
        if stage is not None:
            pulumi.set(__self__, "stage", stage)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the featureset version container.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence[builtins.str]]:
        """
        Specifies list of entities
        """
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[builtins.bool]:
        """
        If the name version are system generated (anonymous registration).
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter(name="materializationSettings")
    def materialization_settings(self) -> Optional['outputs.MaterializationSettingsResponse']:
        """
        Specifies the materialization settings
        """
        return pulumi.get(self, "materialization_settings")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def specification(self) -> Optional['outputs.FeaturesetSpecificationResponse']:
        """
        Specifies the feature spec details
        """
        return pulumi.get(self, "specification")

    @property
    @pulumi.getter
    def stage(self) -> Optional[builtins.str]:
        """
        Specifies the asset stage
        """
        return pulumi.get(self, "stage")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class FeaturestoreEntityContainerResponse(dict):
    """
    DTO object representing feature entity
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latestVersion":
            suggest = "latest_version"
        elif key == "nextVersion":
            suggest = "next_version"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeaturestoreEntityContainerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeaturestoreEntityContainerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeaturestoreEntityContainerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latest_version: builtins.str,
                 next_version: builtins.str,
                 provisioning_state: builtins.str,
                 description: Optional[builtins.str] = None,
                 is_archived: Optional[builtins.bool] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        DTO object representing feature entity
        :param builtins.str latest_version: The latest version inside this container.
        :param builtins.str next_version: The next auto incremental version
        :param builtins.str provisioning_state: Provisioning state for the featurestore entity container.
        :param builtins.str description: The asset description text.
        :param builtins.bool is_archived: Is the asset archived?
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "latest_version", latest_version)
        pulumi.set(__self__, "next_version", next_version)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> builtins.str:
        """
        The latest version inside this container.
        """
        return pulumi.get(self, "latest_version")

    @property
    @pulumi.getter(name="nextVersion")
    def next_version(self) -> builtins.str:
        """
        The next auto incremental version
        """
        return pulumi.get(self, "next_version")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the featurestore entity container.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class FeaturestoreEntityVersionResponse(dict):
    """
    DTO object representing feature entity version
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "indexColumns":
            suggest = "index_columns"
        elif key == "isAnonymous":
            suggest = "is_anonymous"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeaturestoreEntityVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeaturestoreEntityVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeaturestoreEntityVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 description: Optional[builtins.str] = None,
                 index_columns: Optional[Sequence['outputs.IndexColumnResponse']] = None,
                 is_anonymous: Optional[builtins.bool] = None,
                 is_archived: Optional[builtins.bool] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 stage: Optional[builtins.str] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        DTO object representing feature entity version
        :param builtins.str provisioning_state: Provisioning state for the featurestore entity version.
        :param builtins.str description: The asset description text.
        :param Sequence['IndexColumnResponse'] index_columns: Specifies index columns
        :param builtins.bool is_anonymous: If the name version are system generated (anonymous registration).
        :param builtins.bool is_archived: Is the asset archived?
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param builtins.str stage: Specifies the asset stage
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if index_columns is not None:
            pulumi.set(__self__, "index_columns", index_columns)
        if is_anonymous is None:
            is_anonymous = False
        if is_anonymous is not None:
            pulumi.set(__self__, "is_anonymous", is_anonymous)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if stage is not None:
            pulumi.set(__self__, "stage", stage)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the featurestore entity version.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="indexColumns")
    def index_columns(self) -> Optional[Sequence['outputs.IndexColumnResponse']]:
        """
        Specifies index columns
        """
        return pulumi.get(self, "index_columns")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[builtins.bool]:
        """
        If the name version are system generated (anonymous registration).
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def stage(self) -> Optional[builtins.str]:
        """
        Specifies the asset stage
        """
        return pulumi.get(self, "stage")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class FixedInputDataResponse(dict):
    """
    Fixed input data definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputDataType":
            suggest = "input_data_type"
        elif key == "jobInputType":
            suggest = "job_input_type"
        elif key == "dataContext":
            suggest = "data_context"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FixedInputDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FixedInputDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FixedInputDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_data_type: builtins.str,
                 job_input_type: builtins.str,
                 uri: builtins.str,
                 columns: Optional[Mapping[str, builtins.str]] = None,
                 data_context: Optional[builtins.str] = None):
        """
        Fixed input data definition.
        :param builtins.str input_data_type: Monitoring input data type enum.
               Expected value is 'Fixed'.
        :param builtins.str job_input_type: [Required] Specifies the type of job.
        :param builtins.str uri: [Required] Input Asset URI.
        :param Mapping[str, builtins.str] columns: Mapping of column names to special uses.
        :param builtins.str data_context: The context metadata of the data source.
        """
        pulumi.set(__self__, "input_data_type", 'Fixed')
        pulumi.set(__self__, "job_input_type", job_input_type)
        pulumi.set(__self__, "uri", uri)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if data_context is not None:
            pulumi.set(__self__, "data_context", data_context)

    @property
    @pulumi.getter(name="inputDataType")
    def input_data_type(self) -> builtins.str:
        """
        Monitoring input data type enum.
        Expected value is 'Fixed'.
        """
        return pulumi.get(self, "input_data_type")

    @property
    @pulumi.getter(name="jobInputType")
    def job_input_type(self) -> builtins.str:
        """
        [Required] Specifies the type of job.
        """
        return pulumi.get(self, "job_input_type")

    @property
    @pulumi.getter
    def uri(self) -> builtins.str:
        """
        [Required] Input Asset URI.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def columns(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Mapping of column names to special uses.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter(name="dataContext")
    def data_context(self) -> Optional[builtins.str]:
        """
        The context metadata of the data source.
        """
        return pulumi.get(self, "data_context")


@pulumi.output_type
class FlavorDataResponse(dict):
    def __init__(__self__, *,
                 data: Optional[Mapping[str, builtins.str]] = None):
        """
        :param Mapping[str, builtins.str] data: Model flavor-specific data.
        """
        if data is not None:
            pulumi.set(__self__, "data", data)

    @property
    @pulumi.getter
    def data(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Model flavor-specific data.
        """
        return pulumi.get(self, "data")


@pulumi.output_type
class ForecastingResponse(dict):
    """
    Forecasting task in AutoML Table vertical.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "trainingData":
            suggest = "training_data"
        elif key == "cvSplitColumnNames":
            suggest = "cv_split_column_names"
        elif key == "featurizationSettings":
            suggest = "featurization_settings"
        elif key == "forecastingSettings":
            suggest = "forecasting_settings"
        elif key == "limitSettings":
            suggest = "limit_settings"
        elif key == "logVerbosity":
            suggest = "log_verbosity"
        elif key == "nCrossValidations":
            suggest = "n_cross_validations"
        elif key == "primaryMetric":
            suggest = "primary_metric"
        elif key == "targetColumnName":
            suggest = "target_column_name"
        elif key == "testData":
            suggest = "test_data"
        elif key == "testDataSize":
            suggest = "test_data_size"
        elif key == "trainingSettings":
            suggest = "training_settings"
        elif key == "validationData":
            suggest = "validation_data"
        elif key == "validationDataSize":
            suggest = "validation_data_size"
        elif key == "weightColumnName":
            suggest = "weight_column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ForecastingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ForecastingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ForecastingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 task_type: builtins.str,
                 training_data: 'outputs.MLTableJobInputResponse',
                 cv_split_column_names: Optional[Sequence[builtins.str]] = None,
                 featurization_settings: Optional['outputs.TableVerticalFeaturizationSettingsResponse'] = None,
                 forecasting_settings: Optional['outputs.ForecastingSettingsResponse'] = None,
                 limit_settings: Optional['outputs.TableVerticalLimitSettingsResponse'] = None,
                 log_verbosity: Optional[builtins.str] = None,
                 n_cross_validations: Optional[Any] = None,
                 primary_metric: Optional[builtins.str] = None,
                 target_column_name: Optional[builtins.str] = None,
                 test_data: Optional['outputs.MLTableJobInputResponse'] = None,
                 test_data_size: Optional[builtins.float] = None,
                 training_settings: Optional['outputs.ForecastingTrainingSettingsResponse'] = None,
                 validation_data: Optional['outputs.MLTableJobInputResponse'] = None,
                 validation_data_size: Optional[builtins.float] = None,
                 weight_column_name: Optional[builtins.str] = None):
        """
        Forecasting task in AutoML Table vertical.
        :param builtins.str task_type: AutoMLJob Task type.
               Expected value is 'Forecasting'.
        :param 'MLTableJobInputResponse' training_data: [Required] Training data input.
        :param Sequence[builtins.str] cv_split_column_names: Columns to use for CVSplit data.
        :param 'TableVerticalFeaturizationSettingsResponse' featurization_settings: Featurization inputs needed for AutoML job.
        :param 'ForecastingSettingsResponse' forecasting_settings: Forecasting task specific inputs.
        :param 'TableVerticalLimitSettingsResponse' limit_settings: Execution constraints for AutoMLJob.
        :param builtins.str log_verbosity: Log verbosity for the job.
        :param Union['AutoNCrossValidationsResponse', 'CustomNCrossValidationsResponse'] n_cross_validations: Number of cross validation folds to be applied on training dataset
               when validation dataset is not provided.
        :param builtins.str primary_metric: Primary metric for forecasting task.
        :param builtins.str target_column_name: Target column name: This is prediction values column.
               Also known as label column name in context of classification tasks.
        :param 'MLTableJobInputResponse' test_data: Test data input.
        :param builtins.float test_data_size: The fraction of test dataset that needs to be set aside for validation purpose.
               Values between (0.0 , 1.0)
               Applied when validation dataset is not provided.
        :param 'ForecastingTrainingSettingsResponse' training_settings: Inputs for training phase for an AutoML Job.
        :param 'MLTableJobInputResponse' validation_data: Validation data inputs.
        :param builtins.float validation_data_size: The fraction of training dataset that needs to be set aside for validation purpose.
               Values between (0.0 , 1.0)
               Applied when validation dataset is not provided.
        :param builtins.str weight_column_name: The name of the sample weight column. Automated ML supports a weighted column as an input, causing rows in the data to be weighted up or down.
        """
        pulumi.set(__self__, "task_type", 'Forecasting')
        pulumi.set(__self__, "training_data", training_data)
        if cv_split_column_names is not None:
            pulumi.set(__self__, "cv_split_column_names", cv_split_column_names)
        if featurization_settings is not None:
            pulumi.set(__self__, "featurization_settings", featurization_settings)
        if forecasting_settings is not None:
            pulumi.set(__self__, "forecasting_settings", forecasting_settings)
        if limit_settings is not None:
            pulumi.set(__self__, "limit_settings", limit_settings)
        if log_verbosity is None:
            log_verbosity = 'Info'
        if log_verbosity is not None:
            pulumi.set(__self__, "log_verbosity", log_verbosity)
        if n_cross_validations is not None:
            pulumi.set(__self__, "n_cross_validations", n_cross_validations)
        if primary_metric is None:
            primary_metric = 'NormalizedRootMeanSquaredError'
        if primary_metric is not None:
            pulumi.set(__self__, "primary_metric", primary_metric)
        if target_column_name is not None:
            pulumi.set(__self__, "target_column_name", target_column_name)
        if test_data is not None:
            pulumi.set(__self__, "test_data", test_data)
        if test_data_size is not None:
            pulumi.set(__self__, "test_data_size", test_data_size)
        if training_settings is not None:
            pulumi.set(__self__, "training_settings", training_settings)
        if validation_data is not None:
            pulumi.set(__self__, "validation_data", validation_data)
        if validation_data_size is not None:
            pulumi.set(__self__, "validation_data_size", validation_data_size)
        if weight_column_name is not None:
            pulumi.set(__self__, "weight_column_name", weight_column_name)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> builtins.str:
        """
        AutoMLJob Task type.
        Expected value is 'Forecasting'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="trainingData")
    def training_data(self) -> 'outputs.MLTableJobInputResponse':
        """
        [Required] Training data input.
        """
        return pulumi.get(self, "training_data")

    @property
    @pulumi.getter(name="cvSplitColumnNames")
    def cv_split_column_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Columns to use for CVSplit data.
        """
        return pulumi.get(self, "cv_split_column_names")

    @property
    @pulumi.getter(name="featurizationSettings")
    def featurization_settings(self) -> Optional['outputs.TableVerticalFeaturizationSettingsResponse']:
        """
        Featurization inputs needed for AutoML job.
        """
        return pulumi.get(self, "featurization_settings")

    @property
    @pulumi.getter(name="forecastingSettings")
    def forecasting_settings(self) -> Optional['outputs.ForecastingSettingsResponse']:
        """
        Forecasting task specific inputs.
        """
        return pulumi.get(self, "forecasting_settings")

    @property
    @pulumi.getter(name="limitSettings")
    def limit_settings(self) -> Optional['outputs.TableVerticalLimitSettingsResponse']:
        """
        Execution constraints for AutoMLJob.
        """
        return pulumi.get(self, "limit_settings")

    @property
    @pulumi.getter(name="logVerbosity")
    def log_verbosity(self) -> Optional[builtins.str]:
        """
        Log verbosity for the job.
        """
        return pulumi.get(self, "log_verbosity")

    @property
    @pulumi.getter(name="nCrossValidations")
    def n_cross_validations(self) -> Optional[Any]:
        """
        Number of cross validation folds to be applied on training dataset
        when validation dataset is not provided.
        """
        return pulumi.get(self, "n_cross_validations")

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> Optional[builtins.str]:
        """
        Primary metric for forecasting task.
        """
        return pulumi.get(self, "primary_metric")

    @property
    @pulumi.getter(name="targetColumnName")
    def target_column_name(self) -> Optional[builtins.str]:
        """
        Target column name: This is prediction values column.
        Also known as label column name in context of classification tasks.
        """
        return pulumi.get(self, "target_column_name")

    @property
    @pulumi.getter(name="testData")
    def test_data(self) -> Optional['outputs.MLTableJobInputResponse']:
        """
        Test data input.
        """
        return pulumi.get(self, "test_data")

    @property
    @pulumi.getter(name="testDataSize")
    def test_data_size(self) -> Optional[builtins.float]:
        """
        The fraction of test dataset that needs to be set aside for validation purpose.
        Values between (0.0 , 1.0)
        Applied when validation dataset is not provided.
        """
        return pulumi.get(self, "test_data_size")

    @property
    @pulumi.getter(name="trainingSettings")
    def training_settings(self) -> Optional['outputs.ForecastingTrainingSettingsResponse']:
        """
        Inputs for training phase for an AutoML Job.
        """
        return pulumi.get(self, "training_settings")

    @property
    @pulumi.getter(name="validationData")
    def validation_data(self) -> Optional['outputs.MLTableJobInputResponse']:
        """
        Validation data inputs.
        """
        return pulumi.get(self, "validation_data")

    @property
    @pulumi.getter(name="validationDataSize")
    def validation_data_size(self) -> Optional[builtins.float]:
        """
        The fraction of training dataset that needs to be set aside for validation purpose.
        Values between (0.0 , 1.0)
        Applied when validation dataset is not provided.
        """
        return pulumi.get(self, "validation_data_size")

    @property
    @pulumi.getter(name="weightColumnName")
    def weight_column_name(self) -> Optional[builtins.str]:
        """
        The name of the sample weight column. Automated ML supports a weighted column as an input, causing rows in the data to be weighted up or down.
        """
        return pulumi.get(self, "weight_column_name")


@pulumi.output_type
class ForecastingSettingsResponse(dict):
    """
    Forecasting specific parameters.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryOrRegionForHolidays":
            suggest = "country_or_region_for_holidays"
        elif key == "cvStepSize":
            suggest = "cv_step_size"
        elif key == "featureLags":
            suggest = "feature_lags"
        elif key == "forecastHorizon":
            suggest = "forecast_horizon"
        elif key == "shortSeriesHandlingConfig":
            suggest = "short_series_handling_config"
        elif key == "targetAggregateFunction":
            suggest = "target_aggregate_function"
        elif key == "targetLags":
            suggest = "target_lags"
        elif key == "targetRollingWindowSize":
            suggest = "target_rolling_window_size"
        elif key == "timeColumnName":
            suggest = "time_column_name"
        elif key == "timeSeriesIdColumnNames":
            suggest = "time_series_id_column_names"
        elif key == "useStl":
            suggest = "use_stl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ForecastingSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ForecastingSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ForecastingSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_or_region_for_holidays: Optional[builtins.str] = None,
                 cv_step_size: Optional[builtins.int] = None,
                 feature_lags: Optional[builtins.str] = None,
                 forecast_horizon: Optional[Any] = None,
                 frequency: Optional[builtins.str] = None,
                 seasonality: Optional[Any] = None,
                 short_series_handling_config: Optional[builtins.str] = None,
                 target_aggregate_function: Optional[builtins.str] = None,
                 target_lags: Optional[Any] = None,
                 target_rolling_window_size: Optional[Any] = None,
                 time_column_name: Optional[builtins.str] = None,
                 time_series_id_column_names: Optional[Sequence[builtins.str]] = None,
                 use_stl: Optional[builtins.str] = None):
        """
        Forecasting specific parameters.
        :param builtins.str country_or_region_for_holidays: Country or region for holidays for forecasting tasks.
               These should be ISO 3166 two-letter country/region codes, for example 'US' or 'GB'.
        :param builtins.int cv_step_size: Number of periods between the origin time of one CV fold and the next fold. For
               example, if `CVStepSize` = 3 for daily data, the origin time for each fold will be
               three days apart.
        :param builtins.str feature_lags: Flag for generating lags for the numeric features with 'auto' or null.
        :param Union['AutoForecastHorizonResponse', 'CustomForecastHorizonResponse'] forecast_horizon: The desired maximum forecast horizon in units of time-series frequency.
        :param builtins.str frequency: When forecasting, this parameter represents the period with which the forecast is desired, for example daily, weekly, yearly, etc. The forecast frequency is dataset frequency by default.
        :param Union['AutoSeasonalityResponse', 'CustomSeasonalityResponse'] seasonality: Set time series seasonality as an integer multiple of the series frequency.
               If seasonality is set to 'auto', it will be inferred.
        :param builtins.str short_series_handling_config: The parameter defining how if AutoML should handle short time series.
        :param builtins.str target_aggregate_function: The function to be used to aggregate the time series target column to conform to a user specified frequency.
               If the TargetAggregateFunction is set i.e. not 'None', but the freq parameter is not set, the error is raised. The possible target aggregation functions are: "sum", "max", "min" and "mean".
        :param Union['AutoTargetLagsResponse', 'CustomTargetLagsResponse'] target_lags: The number of past periods to lag from the target column.
        :param Union['AutoTargetRollingWindowSizeResponse', 'CustomTargetRollingWindowSizeResponse'] target_rolling_window_size: The number of past periods used to create a rolling window average of the target column.
        :param builtins.str time_column_name: The name of the time column. This parameter is required when forecasting to specify the datetime column in the input data used for building the time series and inferring its frequency.
        :param Sequence[builtins.str] time_series_id_column_names: The names of columns used to group a timeseries. It can be used to create multiple series.
               If grain is not defined, the data set is assumed to be one time-series. This parameter is used with task type forecasting.
        :param builtins.str use_stl: Configure STL Decomposition of the time-series target column.
        """
        if country_or_region_for_holidays is not None:
            pulumi.set(__self__, "country_or_region_for_holidays", country_or_region_for_holidays)
        if cv_step_size is not None:
            pulumi.set(__self__, "cv_step_size", cv_step_size)
        if feature_lags is None:
            feature_lags = 'None'
        if feature_lags is not None:
            pulumi.set(__self__, "feature_lags", feature_lags)
        if forecast_horizon is not None:
            pulumi.set(__self__, "forecast_horizon", forecast_horizon)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if seasonality is not None:
            pulumi.set(__self__, "seasonality", seasonality)
        if short_series_handling_config is None:
            short_series_handling_config = 'Auto'
        if short_series_handling_config is not None:
            pulumi.set(__self__, "short_series_handling_config", short_series_handling_config)
        if target_aggregate_function is None:
            target_aggregate_function = 'None'
        if target_aggregate_function is not None:
            pulumi.set(__self__, "target_aggregate_function", target_aggregate_function)
        if target_lags is not None:
            pulumi.set(__self__, "target_lags", target_lags)
        if target_rolling_window_size is not None:
            pulumi.set(__self__, "target_rolling_window_size", target_rolling_window_size)
        if time_column_name is not None:
            pulumi.set(__self__, "time_column_name", time_column_name)
        if time_series_id_column_names is not None:
            pulumi.set(__self__, "time_series_id_column_names", time_series_id_column_names)
        if use_stl is None:
            use_stl = 'None'
        if use_stl is not None:
            pulumi.set(__self__, "use_stl", use_stl)

    @property
    @pulumi.getter(name="countryOrRegionForHolidays")
    def country_or_region_for_holidays(self) -> Optional[builtins.str]:
        """
        Country or region for holidays for forecasting tasks.
        These should be ISO 3166 two-letter country/region codes, for example 'US' or 'GB'.
        """
        return pulumi.get(self, "country_or_region_for_holidays")

    @property
    @pulumi.getter(name="cvStepSize")
    def cv_step_size(self) -> Optional[builtins.int]:
        """
        Number of periods between the origin time of one CV fold and the next fold. For
        example, if `CVStepSize` = 3 for daily data, the origin time for each fold will be
        three days apart.
        """
        return pulumi.get(self, "cv_step_size")

    @property
    @pulumi.getter(name="featureLags")
    def feature_lags(self) -> Optional[builtins.str]:
        """
        Flag for generating lags for the numeric features with 'auto' or null.
        """
        return pulumi.get(self, "feature_lags")

    @property
    @pulumi.getter(name="forecastHorizon")
    def forecast_horizon(self) -> Optional[Any]:
        """
        The desired maximum forecast horizon in units of time-series frequency.
        """
        return pulumi.get(self, "forecast_horizon")

    @property
    @pulumi.getter
    def frequency(self) -> Optional[builtins.str]:
        """
        When forecasting, this parameter represents the period with which the forecast is desired, for example daily, weekly, yearly, etc. The forecast frequency is dataset frequency by default.
        """
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter
    def seasonality(self) -> Optional[Any]:
        """
        Set time series seasonality as an integer multiple of the series frequency.
        If seasonality is set to 'auto', it will be inferred.
        """
        return pulumi.get(self, "seasonality")

    @property
    @pulumi.getter(name="shortSeriesHandlingConfig")
    def short_series_handling_config(self) -> Optional[builtins.str]:
        """
        The parameter defining how if AutoML should handle short time series.
        """
        return pulumi.get(self, "short_series_handling_config")

    @property
    @pulumi.getter(name="targetAggregateFunction")
    def target_aggregate_function(self) -> Optional[builtins.str]:
        """
        The function to be used to aggregate the time series target column to conform to a user specified frequency.
        If the TargetAggregateFunction is set i.e. not 'None', but the freq parameter is not set, the error is raised. The possible target aggregation functions are: "sum", "max", "min" and "mean".
        """
        return pulumi.get(self, "target_aggregate_function")

    @property
    @pulumi.getter(name="targetLags")
    def target_lags(self) -> Optional[Any]:
        """
        The number of past periods to lag from the target column.
        """
        return pulumi.get(self, "target_lags")

    @property
    @pulumi.getter(name="targetRollingWindowSize")
    def target_rolling_window_size(self) -> Optional[Any]:
        """
        The number of past periods used to create a rolling window average of the target column.
        """
        return pulumi.get(self, "target_rolling_window_size")

    @property
    @pulumi.getter(name="timeColumnName")
    def time_column_name(self) -> Optional[builtins.str]:
        """
        The name of the time column. This parameter is required when forecasting to specify the datetime column in the input data used for building the time series and inferring its frequency.
        """
        return pulumi.get(self, "time_column_name")

    @property
    @pulumi.getter(name="timeSeriesIdColumnNames")
    def time_series_id_column_names(self) -> Optional[Sequence[builtins.str]]:
        """
        The names of columns used to group a timeseries. It can be used to create multiple series.
        If grain is not defined, the data set is assumed to be one time-series. This parameter is used with task type forecasting.
        """
        return pulumi.get(self, "time_series_id_column_names")

    @property
    @pulumi.getter(name="useStl")
    def use_stl(self) -> Optional[builtins.str]:
        """
        Configure STL Decomposition of the time-series target column.
        """
        return pulumi.get(self, "use_stl")


@pulumi.output_type
class ForecastingTrainingSettingsResponse(dict):
    """
    Forecasting Training related configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedTrainingAlgorithms":
            suggest = "allowed_training_algorithms"
        elif key == "blockedTrainingAlgorithms":
            suggest = "blocked_training_algorithms"
        elif key == "enableDnnTraining":
            suggest = "enable_dnn_training"
        elif key == "enableModelExplainability":
            suggest = "enable_model_explainability"
        elif key == "enableOnnxCompatibleModels":
            suggest = "enable_onnx_compatible_models"
        elif key == "enableStackEnsemble":
            suggest = "enable_stack_ensemble"
        elif key == "enableVoteEnsemble":
            suggest = "enable_vote_ensemble"
        elif key == "ensembleModelDownloadTimeout":
            suggest = "ensemble_model_download_timeout"
        elif key == "stackEnsembleSettings":
            suggest = "stack_ensemble_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ForecastingTrainingSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ForecastingTrainingSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ForecastingTrainingSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_training_algorithms: Optional[Sequence[builtins.str]] = None,
                 blocked_training_algorithms: Optional[Sequence[builtins.str]] = None,
                 enable_dnn_training: Optional[builtins.bool] = None,
                 enable_model_explainability: Optional[builtins.bool] = None,
                 enable_onnx_compatible_models: Optional[builtins.bool] = None,
                 enable_stack_ensemble: Optional[builtins.bool] = None,
                 enable_vote_ensemble: Optional[builtins.bool] = None,
                 ensemble_model_download_timeout: Optional[builtins.str] = None,
                 stack_ensemble_settings: Optional['outputs.StackEnsembleSettingsResponse'] = None):
        """
        Forecasting Training related configuration.
        :param Sequence[builtins.str] allowed_training_algorithms: Allowed models for forecasting task.
        :param Sequence[builtins.str] blocked_training_algorithms: Blocked models for forecasting task.
        :param builtins.bool enable_dnn_training: Enable recommendation of DNN models.
        :param builtins.bool enable_model_explainability: Flag to turn on explainability on best model.
        :param builtins.bool enable_onnx_compatible_models: Flag for enabling onnx compatible models.
        :param builtins.bool enable_stack_ensemble: Enable stack ensemble run.
        :param builtins.bool enable_vote_ensemble: Enable voting ensemble run.
        :param builtins.str ensemble_model_download_timeout: During VotingEnsemble and StackEnsemble model generation, multiple fitted models from the previous child runs are downloaded.
               Configure this parameter with a higher value than 300 secs, if more time is needed.
        :param 'StackEnsembleSettingsResponse' stack_ensemble_settings: Stack ensemble settings for stack ensemble run.
        """
        if allowed_training_algorithms is not None:
            pulumi.set(__self__, "allowed_training_algorithms", allowed_training_algorithms)
        if blocked_training_algorithms is not None:
            pulumi.set(__self__, "blocked_training_algorithms", blocked_training_algorithms)
        if enable_dnn_training is None:
            enable_dnn_training = False
        if enable_dnn_training is not None:
            pulumi.set(__self__, "enable_dnn_training", enable_dnn_training)
        if enable_model_explainability is None:
            enable_model_explainability = True
        if enable_model_explainability is not None:
            pulumi.set(__self__, "enable_model_explainability", enable_model_explainability)
        if enable_onnx_compatible_models is None:
            enable_onnx_compatible_models = False
        if enable_onnx_compatible_models is not None:
            pulumi.set(__self__, "enable_onnx_compatible_models", enable_onnx_compatible_models)
        if enable_stack_ensemble is None:
            enable_stack_ensemble = True
        if enable_stack_ensemble is not None:
            pulumi.set(__self__, "enable_stack_ensemble", enable_stack_ensemble)
        if enable_vote_ensemble is None:
            enable_vote_ensemble = True
        if enable_vote_ensemble is not None:
            pulumi.set(__self__, "enable_vote_ensemble", enable_vote_ensemble)
        if ensemble_model_download_timeout is None:
            ensemble_model_download_timeout = 'PT5M'
        if ensemble_model_download_timeout is not None:
            pulumi.set(__self__, "ensemble_model_download_timeout", ensemble_model_download_timeout)
        if stack_ensemble_settings is not None:
            pulumi.set(__self__, "stack_ensemble_settings", stack_ensemble_settings)

    @property
    @pulumi.getter(name="allowedTrainingAlgorithms")
    def allowed_training_algorithms(self) -> Optional[Sequence[builtins.str]]:
        """
        Allowed models for forecasting task.
        """
        return pulumi.get(self, "allowed_training_algorithms")

    @property
    @pulumi.getter(name="blockedTrainingAlgorithms")
    def blocked_training_algorithms(self) -> Optional[Sequence[builtins.str]]:
        """
        Blocked models for forecasting task.
        """
        return pulumi.get(self, "blocked_training_algorithms")

    @property
    @pulumi.getter(name="enableDnnTraining")
    def enable_dnn_training(self) -> Optional[builtins.bool]:
        """
        Enable recommendation of DNN models.
        """
        return pulumi.get(self, "enable_dnn_training")

    @property
    @pulumi.getter(name="enableModelExplainability")
    def enable_model_explainability(self) -> Optional[builtins.bool]:
        """
        Flag to turn on explainability on best model.
        """
        return pulumi.get(self, "enable_model_explainability")

    @property
    @pulumi.getter(name="enableOnnxCompatibleModels")
    def enable_onnx_compatible_models(self) -> Optional[builtins.bool]:
        """
        Flag for enabling onnx compatible models.
        """
        return pulumi.get(self, "enable_onnx_compatible_models")

    @property
    @pulumi.getter(name="enableStackEnsemble")
    def enable_stack_ensemble(self) -> Optional[builtins.bool]:
        """
        Enable stack ensemble run.
        """
        return pulumi.get(self, "enable_stack_ensemble")

    @property
    @pulumi.getter(name="enableVoteEnsemble")
    def enable_vote_ensemble(self) -> Optional[builtins.bool]:
        """
        Enable voting ensemble run.
        """
        return pulumi.get(self, "enable_vote_ensemble")

    @property
    @pulumi.getter(name="ensembleModelDownloadTimeout")
    def ensemble_model_download_timeout(self) -> Optional[builtins.str]:
        """
        During VotingEnsemble and StackEnsemble model generation, multiple fitted models from the previous child runs are downloaded.
        Configure this parameter with a higher value than 300 secs, if more time is needed.
        """
        return pulumi.get(self, "ensemble_model_download_timeout")

    @property
    @pulumi.getter(name="stackEnsembleSettings")
    def stack_ensemble_settings(self) -> Optional['outputs.StackEnsembleSettingsResponse']:
        """
        Stack ensemble settings for stack ensemble run.
        """
        return pulumi.get(self, "stack_ensemble_settings")


@pulumi.output_type
class FqdnOutboundRuleResponse(dict):
    """
    FQDN Outbound Rule for the managed network of a machine learning workspace.
    """
    def __init__(__self__, *,
                 type: builtins.str,
                 category: Optional[builtins.str] = None,
                 destination: Optional[builtins.str] = None,
                 status: Optional[builtins.str] = None):
        """
        FQDN Outbound Rule for the managed network of a machine learning workspace.
        :param builtins.str type: Type of a managed network Outbound Rule of a machine learning workspace.
               Expected value is 'FQDN'.
        :param builtins.str category: Category of a managed network Outbound Rule of a machine learning workspace.
        :param builtins.str status: Type of a managed network Outbound Rule of a machine learning workspace.
        """
        pulumi.set(__self__, "type", 'FQDN')
        if category is not None:
            pulumi.set(__self__, "category", category)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        Expected value is 'FQDN'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def category(self) -> Optional[builtins.str]:
        """
        Category of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def destination(self) -> Optional[builtins.str]:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GlusterFsSectionResponse(dict):
    """
    Data specific to GlusterFS.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverAddress":
            suggest = "server_address"
        elif key == "volumeName":
            suggest = "volume_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlusterFsSectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlusterFsSectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlusterFsSectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_address: builtins.str,
                 volume_name: builtins.str):
        """
        Data specific to GlusterFS.
        :param builtins.str server_address: The server address of one of the servers that hosts the GlusterFS. Can be either the IP address or server name.
        :param builtins.str volume_name: The name of the created GlusterFS volume.
        """
        pulumi.set(__self__, "server_address", server_address)
        pulumi.set(__self__, "volume_name", volume_name)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> builtins.str:
        """
        The server address of one of the servers that hosts the GlusterFS. Can be either the IP address or server name.
        """
        return pulumi.get(self, "server_address")

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> builtins.str:
        """
        The name of the created GlusterFS volume.
        """
        return pulumi.get(self, "volume_name")


@pulumi.output_type
class GridSamplingAlgorithmResponse(dict):
    """
    Defines a Sampling Algorithm that exhaustively generates every value combination in the space
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "samplingAlgorithmType":
            suggest = "sampling_algorithm_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GridSamplingAlgorithmResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GridSamplingAlgorithmResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GridSamplingAlgorithmResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sampling_algorithm_type: builtins.str):
        """
        Defines a Sampling Algorithm that exhaustively generates every value combination in the space
        :param builtins.str sampling_algorithm_type: 
               Expected value is 'Grid'.
        """
        pulumi.set(__self__, "sampling_algorithm_type", 'Grid')

    @property
    @pulumi.getter(name="samplingAlgorithmType")
    def sampling_algorithm_type(self) -> builtins.str:
        """

        Expected value is 'Grid'.
        """
        return pulumi.get(self, "sampling_algorithm_type")


@pulumi.output_type
class GroupEnvironmentConfigurationResponse(dict):
    """
    Environment configuration options.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentId":
            suggest = "environment_id"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "livenessProbe":
            suggest = "liveness_probe"
        elif key == "readinessProbe":
            suggest = "readiness_probe"
        elif key == "startupProbe":
            suggest = "startup_probe"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupEnvironmentConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupEnvironmentConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupEnvironmentConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 environment_id: Optional[builtins.str] = None,
                 environment_variables: Optional[Sequence['outputs.StringStringKeyValuePairResponse']] = None,
                 liveness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
                 readiness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
                 startup_probe: Optional['outputs.ProbeSettingsResponse'] = None):
        """
        Environment configuration options.
        :param builtins.str environment_id: ARM resource ID of the environment specification for the inference pool.
        :param Sequence['StringStringKeyValuePairResponse'] environment_variables: Environment variables configuration for the inference pool.
        :param 'ProbeSettingsResponse' liveness_probe: Liveness probe monitors the health of the container regularly.
        :param 'ProbeSettingsResponse' readiness_probe: Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
        :param 'ProbeSettingsResponse' startup_probe: This verifies whether the application within a container is started. Startup probes run before any other probe, and, unless it finishes successfully, disables other probes.
        """
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if startup_probe is not None:
            pulumi.set(__self__, "startup_probe", startup_probe)

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of the environment specification for the inference pool.
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Sequence['outputs.StringStringKeyValuePairResponse']]:
        """
        Environment variables configuration for the inference pool.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.ProbeSettingsResponse']:
        """
        Liveness probe monitors the health of the container regularly.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.ProbeSettingsResponse']:
        """
        Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter(name="startupProbe")
    def startup_probe(self) -> Optional['outputs.ProbeSettingsResponse']:
        """
        This verifies whether the application within a container is started. Startup probes run before any other probe, and, unless it finishes successfully, disables other probes.
        """
        return pulumi.get(self, "startup_probe")


@pulumi.output_type
class GroupModelConfigurationResponse(dict):
    """
    Model configuration options.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelId":
            suggest = "model_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupModelConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupModelConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupModelConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model_id: Optional[builtins.str] = None):
        """
        Model configuration options.
        :param builtins.str model_id: The URI path to the model.
        """
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)

    @property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[builtins.str]:
        """
        The URI path to the model.
        """
        return pulumi.get(self, "model_id")


@pulumi.output_type
class HDInsightPropertiesResponse(dict):
    """
    HDInsight compute properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "administratorAccount":
            suggest = "administrator_account"
        elif key == "sshPort":
            suggest = "ssh_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HDInsightPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HDInsightPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HDInsightPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[builtins.str] = None,
                 administrator_account: Optional['outputs.VirtualMachineSshCredentialsResponse'] = None,
                 ssh_port: Optional[builtins.int] = None):
        """
        HDInsight compute properties
        :param builtins.str address: Public IP address of the master node of the cluster.
        :param 'VirtualMachineSshCredentialsResponse' administrator_account: Admin credentials for master node of the cluster
        :param builtins.int ssh_port: Port open for ssh connections on the master node of the cluster.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if administrator_account is not None:
            pulumi.set(__self__, "administrator_account", administrator_account)
        if ssh_port is not None:
            pulumi.set(__self__, "ssh_port", ssh_port)

    @property
    @pulumi.getter
    def address(self) -> Optional[builtins.str]:
        """
        Public IP address of the master node of the cluster.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="administratorAccount")
    def administrator_account(self) -> Optional['outputs.VirtualMachineSshCredentialsResponse']:
        """
        Admin credentials for master node of the cluster
        """
        return pulumi.get(self, "administrator_account")

    @property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[builtins.int]:
        """
        Port open for ssh connections on the master node of the cluster.
        """
        return pulumi.get(self, "ssh_port")


@pulumi.output_type
class HDInsightResponse(dict):
    """
    A HDInsight compute.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeType":
            suggest = "compute_type"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "isAttachedCompute":
            suggest = "is_attached_compute"
        elif key == "modifiedOn":
            suggest = "modified_on"
        elif key == "provisioningErrors":
            suggest = "provisioning_errors"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "computeLocation":
            suggest = "compute_location"
        elif key == "disableLocalAuth":
            suggest = "disable_local_auth"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HDInsightResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HDInsightResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HDInsightResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_type: builtins.str,
                 created_on: builtins.str,
                 is_attached_compute: builtins.bool,
                 modified_on: builtins.str,
                 provisioning_errors: Sequence['outputs.ErrorResponseResponse'],
                 provisioning_state: builtins.str,
                 compute_location: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 disable_local_auth: Optional[builtins.bool] = None,
                 properties: Optional['outputs.HDInsightPropertiesResponse'] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        A HDInsight compute.
        :param builtins.str compute_type: The type of compute
               Expected value is 'HDInsight'.
        :param builtins.str created_on: The time at which the compute was created.
        :param builtins.bool is_attached_compute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        :param builtins.str modified_on: The time at which the compute was last modified.
        :param Sequence['ErrorResponseResponse'] provisioning_errors: Errors during provisioning
        :param builtins.str provisioning_state: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        :param builtins.str compute_location: Location for the underlying compute
        :param builtins.str description: The description of the Machine Learning compute.
        :param builtins.bool disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        :param 'HDInsightPropertiesResponse' properties: HDInsight compute properties
        :param builtins.str resource_id: ARM resource id of the underlying compute
        """
        pulumi.set(__self__, "compute_type", 'HDInsight')
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "is_attached_compute", is_attached_compute)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "provisioning_errors", provisioning_errors)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if compute_location is not None:
            pulumi.set(__self__, "compute_location", compute_location)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_local_auth is not None:
            pulumi.set(__self__, "disable_local_auth", disable_local_auth)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> builtins.str:
        """
        The type of compute
        Expected value is 'HDInsight'.
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> builtins.str:
        """
        The time at which the compute was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="isAttachedCompute")
    def is_attached_compute(self) -> builtins.bool:
        """
        Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        """
        return pulumi.get(self, "is_attached_compute")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> builtins.str:
        """
        The time at which the compute was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="provisioningErrors")
    def provisioning_errors(self) -> Sequence['outputs.ErrorResponseResponse']:
        """
        Errors during provisioning
        """
        return pulumi.get(self, "provisioning_errors")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[builtins.str]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[builtins.bool]:
        """
        Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        """
        return pulumi.get(self, "disable_local_auth")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.HDInsightPropertiesResponse']:
        """
        HDInsight compute properties
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class IdAssetReferenceResponse(dict):
    """
    Reference to an asset via its ARM resource ID.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assetId":
            suggest = "asset_id"
        elif key == "referenceType":
            suggest = "reference_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdAssetReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdAssetReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdAssetReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asset_id: builtins.str,
                 reference_type: builtins.str):
        """
        Reference to an asset via its ARM resource ID.
        :param builtins.str asset_id: [Required] ARM resource ID of the asset.
        :param builtins.str reference_type: Enum to determine which reference method to use for an asset.
               Expected value is 'Id'.
        """
        pulumi.set(__self__, "asset_id", asset_id)
        pulumi.set(__self__, "reference_type", 'Id')

    @property
    @pulumi.getter(name="assetId")
    def asset_id(self) -> builtins.str:
        """
        [Required] ARM resource ID of the asset.
        """
        return pulumi.get(self, "asset_id")

    @property
    @pulumi.getter(name="referenceType")
    def reference_type(self) -> builtins.str:
        """
        Enum to determine which reference method to use for an asset.
        Expected value is 'Id'.
        """
        return pulumi.get(self, "reference_type")


@pulumi.output_type
class IdentityForCmkResponse(dict):
    """
    Identity that will be used to access key vault for encryption at rest
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userAssignedIdentity":
            suggest = "user_assigned_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityForCmkResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityForCmkResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityForCmkResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_assigned_identity: Optional[builtins.str] = None):
        """
        Identity that will be used to access key vault for encryption at rest
        :param builtins.str user_assigned_identity: The ArmId of the user assigned identity that will be used to access the customer managed key vault
        """
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[builtins.str]:
        """
        The ArmId of the user assigned identity that will be used to access the customer managed key vault
        """
        return pulumi.get(self, "user_assigned_identity")


@pulumi.output_type
class IdentityResponse(dict):
    """
    Identity for the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: builtins.str,
                 tenant_id: builtins.str,
                 type: Optional[builtins.str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Identity for the resource.
        :param builtins.str principal_id: The principal ID of resource identity.
        :param builtins.str tenant_id: The tenant ID of resource.
        :param builtins.str type: The identity type.
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The user assigned identities associated with the resource.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> builtins.str:
        """
        The principal ID of resource identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> builtins.str:
        """
        The tenant ID of resource.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        The identity type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The user assigned identities associated with the resource.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class ImageClassificationMultilabelResponse(dict):
    """
    Image Classification Multilabel. Multi-label image classification is used when an image could have one or more labels
    from a set of labels - e.g. an image could be labeled with both 'cat' and 'dog'.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitSettings":
            suggest = "limit_settings"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "trainingData":
            suggest = "training_data"
        elif key == "logVerbosity":
            suggest = "log_verbosity"
        elif key == "modelSettings":
            suggest = "model_settings"
        elif key == "primaryMetric":
            suggest = "primary_metric"
        elif key == "searchSpace":
            suggest = "search_space"
        elif key == "sweepSettings":
            suggest = "sweep_settings"
        elif key == "targetColumnName":
            suggest = "target_column_name"
        elif key == "validationData":
            suggest = "validation_data"
        elif key == "validationDataSize":
            suggest = "validation_data_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageClassificationMultilabelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageClassificationMultilabelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageClassificationMultilabelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_settings: 'outputs.ImageLimitSettingsResponse',
                 task_type: builtins.str,
                 training_data: 'outputs.MLTableJobInputResponse',
                 log_verbosity: Optional[builtins.str] = None,
                 model_settings: Optional['outputs.ImageModelSettingsClassificationResponse'] = None,
                 primary_metric: Optional[builtins.str] = None,
                 search_space: Optional[Sequence['outputs.ImageModelDistributionSettingsClassificationResponse']] = None,
                 sweep_settings: Optional['outputs.ImageSweepSettingsResponse'] = None,
                 target_column_name: Optional[builtins.str] = None,
                 validation_data: Optional['outputs.MLTableJobInputResponse'] = None,
                 validation_data_size: Optional[builtins.float] = None):
        """
        Image Classification Multilabel. Multi-label image classification is used when an image could have one or more labels
        from a set of labels - e.g. an image could be labeled with both 'cat' and 'dog'.
        :param 'ImageLimitSettingsResponse' limit_settings: [Required] Limit settings for the AutoML job.
        :param builtins.str task_type: AutoMLJob Task type.
               Expected value is 'ImageClassificationMultilabel'.
        :param 'MLTableJobInputResponse' training_data: [Required] Training data input.
        :param builtins.str log_verbosity: Log verbosity for the job.
        :param 'ImageModelSettingsClassificationResponse' model_settings: Settings used for training the model.
        :param builtins.str primary_metric: Primary metric to optimize for this task.
        :param Sequence['ImageModelDistributionSettingsClassificationResponse'] search_space: Search space for sampling different combinations of models and their hyperparameters.
        :param 'ImageSweepSettingsResponse' sweep_settings: Model sweeping and hyperparameter sweeping related settings.
        :param builtins.str target_column_name: Target column name: This is prediction values column.
               Also known as label column name in context of classification tasks.
        :param 'MLTableJobInputResponse' validation_data: Validation data inputs.
        :param builtins.float validation_data_size: The fraction of training dataset that needs to be set aside for validation purpose.
               Values between (0.0 , 1.0)
               Applied when validation dataset is not provided.
        """
        pulumi.set(__self__, "limit_settings", limit_settings)
        pulumi.set(__self__, "task_type", 'ImageClassificationMultilabel')
        pulumi.set(__self__, "training_data", training_data)
        if log_verbosity is None:
            log_verbosity = 'Info'
        if log_verbosity is not None:
            pulumi.set(__self__, "log_verbosity", log_verbosity)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)
        if primary_metric is None:
            primary_metric = 'IOU'
        if primary_metric is not None:
            pulumi.set(__self__, "primary_metric", primary_metric)
        if search_space is not None:
            pulumi.set(__self__, "search_space", search_space)
        if sweep_settings is not None:
            pulumi.set(__self__, "sweep_settings", sweep_settings)
        if target_column_name is not None:
            pulumi.set(__self__, "target_column_name", target_column_name)
        if validation_data is not None:
            pulumi.set(__self__, "validation_data", validation_data)
        if validation_data_size is not None:
            pulumi.set(__self__, "validation_data_size", validation_data_size)

    @property
    @pulumi.getter(name="limitSettings")
    def limit_settings(self) -> 'outputs.ImageLimitSettingsResponse':
        """
        [Required] Limit settings for the AutoML job.
        """
        return pulumi.get(self, "limit_settings")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> builtins.str:
        """
        AutoMLJob Task type.
        Expected value is 'ImageClassificationMultilabel'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="trainingData")
    def training_data(self) -> 'outputs.MLTableJobInputResponse':
        """
        [Required] Training data input.
        """
        return pulumi.get(self, "training_data")

    @property
    @pulumi.getter(name="logVerbosity")
    def log_verbosity(self) -> Optional[builtins.str]:
        """
        Log verbosity for the job.
        """
        return pulumi.get(self, "log_verbosity")

    @property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional['outputs.ImageModelSettingsClassificationResponse']:
        """
        Settings used for training the model.
        """
        return pulumi.get(self, "model_settings")

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> Optional[builtins.str]:
        """
        Primary metric to optimize for this task.
        """
        return pulumi.get(self, "primary_metric")

    @property
    @pulumi.getter(name="searchSpace")
    def search_space(self) -> Optional[Sequence['outputs.ImageModelDistributionSettingsClassificationResponse']]:
        """
        Search space for sampling different combinations of models and their hyperparameters.
        """
        return pulumi.get(self, "search_space")

    @property
    @pulumi.getter(name="sweepSettings")
    def sweep_settings(self) -> Optional['outputs.ImageSweepSettingsResponse']:
        """
        Model sweeping and hyperparameter sweeping related settings.
        """
        return pulumi.get(self, "sweep_settings")

    @property
    @pulumi.getter(name="targetColumnName")
    def target_column_name(self) -> Optional[builtins.str]:
        """
        Target column name: This is prediction values column.
        Also known as label column name in context of classification tasks.
        """
        return pulumi.get(self, "target_column_name")

    @property
    @pulumi.getter(name="validationData")
    def validation_data(self) -> Optional['outputs.MLTableJobInputResponse']:
        """
        Validation data inputs.
        """
        return pulumi.get(self, "validation_data")

    @property
    @pulumi.getter(name="validationDataSize")
    def validation_data_size(self) -> Optional[builtins.float]:
        """
        The fraction of training dataset that needs to be set aside for validation purpose.
        Values between (0.0 , 1.0)
        Applied when validation dataset is not provided.
        """
        return pulumi.get(self, "validation_data_size")


@pulumi.output_type
class ImageClassificationResponse(dict):
    """
    Image Classification. Multi-class image classification is used when an image is classified with only a single label
    from a set of classes - e.g. each image is classified as either an image of a 'cat' or a 'dog' or a 'duck'.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitSettings":
            suggest = "limit_settings"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "trainingData":
            suggest = "training_data"
        elif key == "logVerbosity":
            suggest = "log_verbosity"
        elif key == "modelSettings":
            suggest = "model_settings"
        elif key == "primaryMetric":
            suggest = "primary_metric"
        elif key == "searchSpace":
            suggest = "search_space"
        elif key == "sweepSettings":
            suggest = "sweep_settings"
        elif key == "targetColumnName":
            suggest = "target_column_name"
        elif key == "validationData":
            suggest = "validation_data"
        elif key == "validationDataSize":
            suggest = "validation_data_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageClassificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageClassificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageClassificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_settings: 'outputs.ImageLimitSettingsResponse',
                 task_type: builtins.str,
                 training_data: 'outputs.MLTableJobInputResponse',
                 log_verbosity: Optional[builtins.str] = None,
                 model_settings: Optional['outputs.ImageModelSettingsClassificationResponse'] = None,
                 primary_metric: Optional[builtins.str] = None,
                 search_space: Optional[Sequence['outputs.ImageModelDistributionSettingsClassificationResponse']] = None,
                 sweep_settings: Optional['outputs.ImageSweepSettingsResponse'] = None,
                 target_column_name: Optional[builtins.str] = None,
                 validation_data: Optional['outputs.MLTableJobInputResponse'] = None,
                 validation_data_size: Optional[builtins.float] = None):
        """
        Image Classification. Multi-class image classification is used when an image is classified with only a single label
        from a set of classes - e.g. each image is classified as either an image of a 'cat' or a 'dog' or a 'duck'.
        :param 'ImageLimitSettingsResponse' limit_settings: [Required] Limit settings for the AutoML job.
        :param builtins.str task_type: AutoMLJob Task type.
               Expected value is 'ImageClassification'.
        :param 'MLTableJobInputResponse' training_data: [Required] Training data input.
        :param builtins.str log_verbosity: Log verbosity for the job.
        :param 'ImageModelSettingsClassificationResponse' model_settings: Settings used for training the model.
        :param builtins.str primary_metric: Primary metric to optimize for this task.
        :param Sequence['ImageModelDistributionSettingsClassificationResponse'] search_space: Search space for sampling different combinations of models and their hyperparameters.
        :param 'ImageSweepSettingsResponse' sweep_settings: Model sweeping and hyperparameter sweeping related settings.
        :param builtins.str target_column_name: Target column name: This is prediction values column.
               Also known as label column name in context of classification tasks.
        :param 'MLTableJobInputResponse' validation_data: Validation data inputs.
        :param builtins.float validation_data_size: The fraction of training dataset that needs to be set aside for validation purpose.
               Values between (0.0 , 1.0)
               Applied when validation dataset is not provided.
        """
        pulumi.set(__self__, "limit_settings", limit_settings)
        pulumi.set(__self__, "task_type", 'ImageClassification')
        pulumi.set(__self__, "training_data", training_data)
        if log_verbosity is None:
            log_verbosity = 'Info'
        if log_verbosity is not None:
            pulumi.set(__self__, "log_verbosity", log_verbosity)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)
        if primary_metric is None:
            primary_metric = 'Accuracy'
        if primary_metric is not None:
            pulumi.set(__self__, "primary_metric", primary_metric)
        if search_space is not None:
            pulumi.set(__self__, "search_space", search_space)
        if sweep_settings is not None:
            pulumi.set(__self__, "sweep_settings", sweep_settings)
        if target_column_name is not None:
            pulumi.set(__self__, "target_column_name", target_column_name)
        if validation_data is not None:
            pulumi.set(__self__, "validation_data", validation_data)
        if validation_data_size is not None:
            pulumi.set(__self__, "validation_data_size", validation_data_size)

    @property
    @pulumi.getter(name="limitSettings")
    def limit_settings(self) -> 'outputs.ImageLimitSettingsResponse':
        """
        [Required] Limit settings for the AutoML job.
        """
        return pulumi.get(self, "limit_settings")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> builtins.str:
        """
        AutoMLJob Task type.
        Expected value is 'ImageClassification'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="trainingData")
    def training_data(self) -> 'outputs.MLTableJobInputResponse':
        """
        [Required] Training data input.
        """
        return pulumi.get(self, "training_data")

    @property
    @pulumi.getter(name="logVerbosity")
    def log_verbosity(self) -> Optional[builtins.str]:
        """
        Log verbosity for the job.
        """
        return pulumi.get(self, "log_verbosity")

    @property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional['outputs.ImageModelSettingsClassificationResponse']:
        """
        Settings used for training the model.
        """
        return pulumi.get(self, "model_settings")

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> Optional[builtins.str]:
        """
        Primary metric to optimize for this task.
        """
        return pulumi.get(self, "primary_metric")

    @property
    @pulumi.getter(name="searchSpace")
    def search_space(self) -> Optional[Sequence['outputs.ImageModelDistributionSettingsClassificationResponse']]:
        """
        Search space for sampling different combinations of models and their hyperparameters.
        """
        return pulumi.get(self, "search_space")

    @property
    @pulumi.getter(name="sweepSettings")
    def sweep_settings(self) -> Optional['outputs.ImageSweepSettingsResponse']:
        """
        Model sweeping and hyperparameter sweeping related settings.
        """
        return pulumi.get(self, "sweep_settings")

    @property
    @pulumi.getter(name="targetColumnName")
    def target_column_name(self) -> Optional[builtins.str]:
        """
        Target column name: This is prediction values column.
        Also known as label column name in context of classification tasks.
        """
        return pulumi.get(self, "target_column_name")

    @property
    @pulumi.getter(name="validationData")
    def validation_data(self) -> Optional['outputs.MLTableJobInputResponse']:
        """
        Validation data inputs.
        """
        return pulumi.get(self, "validation_data")

    @property
    @pulumi.getter(name="validationDataSize")
    def validation_data_size(self) -> Optional[builtins.float]:
        """
        The fraction of training dataset that needs to be set aside for validation purpose.
        Values between (0.0 , 1.0)
        Applied when validation dataset is not provided.
        """
        return pulumi.get(self, "validation_data_size")


@pulumi.output_type
class ImageInstanceSegmentationResponse(dict):
    """
    Image Instance Segmentation. Instance segmentation is used to identify objects in an image at the pixel level,
    drawing a polygon around each object in the image.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitSettings":
            suggest = "limit_settings"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "trainingData":
            suggest = "training_data"
        elif key == "logVerbosity":
            suggest = "log_verbosity"
        elif key == "modelSettings":
            suggest = "model_settings"
        elif key == "primaryMetric":
            suggest = "primary_metric"
        elif key == "searchSpace":
            suggest = "search_space"
        elif key == "sweepSettings":
            suggest = "sweep_settings"
        elif key == "targetColumnName":
            suggest = "target_column_name"
        elif key == "validationData":
            suggest = "validation_data"
        elif key == "validationDataSize":
            suggest = "validation_data_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageInstanceSegmentationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageInstanceSegmentationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageInstanceSegmentationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_settings: 'outputs.ImageLimitSettingsResponse',
                 task_type: builtins.str,
                 training_data: 'outputs.MLTableJobInputResponse',
                 log_verbosity: Optional[builtins.str] = None,
                 model_settings: Optional['outputs.ImageModelSettingsObjectDetectionResponse'] = None,
                 primary_metric: Optional[builtins.str] = None,
                 search_space: Optional[Sequence['outputs.ImageModelDistributionSettingsObjectDetectionResponse']] = None,
                 sweep_settings: Optional['outputs.ImageSweepSettingsResponse'] = None,
                 target_column_name: Optional[builtins.str] = None,
                 validation_data: Optional['outputs.MLTableJobInputResponse'] = None,
                 validation_data_size: Optional[builtins.float] = None):
        """
        Image Instance Segmentation. Instance segmentation is used to identify objects in an image at the pixel level,
        drawing a polygon around each object in the image.
        :param 'ImageLimitSettingsResponse' limit_settings: [Required] Limit settings for the AutoML job.
        :param builtins.str task_type: AutoMLJob Task type.
               Expected value is 'ImageInstanceSegmentation'.
        :param 'MLTableJobInputResponse' training_data: [Required] Training data input.
        :param builtins.str log_verbosity: Log verbosity for the job.
        :param 'ImageModelSettingsObjectDetectionResponse' model_settings: Settings used for training the model.
        :param builtins.str primary_metric: Primary metric to optimize for this task.
        :param Sequence['ImageModelDistributionSettingsObjectDetectionResponse'] search_space: Search space for sampling different combinations of models and their hyperparameters.
        :param 'ImageSweepSettingsResponse' sweep_settings: Model sweeping and hyperparameter sweeping related settings.
        :param builtins.str target_column_name: Target column name: This is prediction values column.
               Also known as label column name in context of classification tasks.
        :param 'MLTableJobInputResponse' validation_data: Validation data inputs.
        :param builtins.float validation_data_size: The fraction of training dataset that needs to be set aside for validation purpose.
               Values between (0.0 , 1.0)
               Applied when validation dataset is not provided.
        """
        pulumi.set(__self__, "limit_settings", limit_settings)
        pulumi.set(__self__, "task_type", 'ImageInstanceSegmentation')
        pulumi.set(__self__, "training_data", training_data)
        if log_verbosity is None:
            log_verbosity = 'Info'
        if log_verbosity is not None:
            pulumi.set(__self__, "log_verbosity", log_verbosity)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)
        if primary_metric is None:
            primary_metric = 'MeanAveragePrecision'
        if primary_metric is not None:
            pulumi.set(__self__, "primary_metric", primary_metric)
        if search_space is not None:
            pulumi.set(__self__, "search_space", search_space)
        if sweep_settings is not None:
            pulumi.set(__self__, "sweep_settings", sweep_settings)
        if target_column_name is not None:
            pulumi.set(__self__, "target_column_name", target_column_name)
        if validation_data is not None:
            pulumi.set(__self__, "validation_data", validation_data)
        if validation_data_size is not None:
            pulumi.set(__self__, "validation_data_size", validation_data_size)

    @property
    @pulumi.getter(name="limitSettings")
    def limit_settings(self) -> 'outputs.ImageLimitSettingsResponse':
        """
        [Required] Limit settings for the AutoML job.
        """
        return pulumi.get(self, "limit_settings")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> builtins.str:
        """
        AutoMLJob Task type.
        Expected value is 'ImageInstanceSegmentation'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="trainingData")
    def training_data(self) -> 'outputs.MLTableJobInputResponse':
        """
        [Required] Training data input.
        """
        return pulumi.get(self, "training_data")

    @property
    @pulumi.getter(name="logVerbosity")
    def log_verbosity(self) -> Optional[builtins.str]:
        """
        Log verbosity for the job.
        """
        return pulumi.get(self, "log_verbosity")

    @property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional['outputs.ImageModelSettingsObjectDetectionResponse']:
        """
        Settings used for training the model.
        """
        return pulumi.get(self, "model_settings")

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> Optional[builtins.str]:
        """
        Primary metric to optimize for this task.
        """
        return pulumi.get(self, "primary_metric")

    @property
    @pulumi.getter(name="searchSpace")
    def search_space(self) -> Optional[Sequence['outputs.ImageModelDistributionSettingsObjectDetectionResponse']]:
        """
        Search space for sampling different combinations of models and their hyperparameters.
        """
        return pulumi.get(self, "search_space")

    @property
    @pulumi.getter(name="sweepSettings")
    def sweep_settings(self) -> Optional['outputs.ImageSweepSettingsResponse']:
        """
        Model sweeping and hyperparameter sweeping related settings.
        """
        return pulumi.get(self, "sweep_settings")

    @property
    @pulumi.getter(name="targetColumnName")
    def target_column_name(self) -> Optional[builtins.str]:
        """
        Target column name: This is prediction values column.
        Also known as label column name in context of classification tasks.
        """
        return pulumi.get(self, "target_column_name")

    @property
    @pulumi.getter(name="validationData")
    def validation_data(self) -> Optional['outputs.MLTableJobInputResponse']:
        """
        Validation data inputs.
        """
        return pulumi.get(self, "validation_data")

    @property
    @pulumi.getter(name="validationDataSize")
    def validation_data_size(self) -> Optional[builtins.float]:
        """
        The fraction of training dataset that needs to be set aside for validation purpose.
        Values between (0.0 , 1.0)
        Applied when validation dataset is not provided.
        """
        return pulumi.get(self, "validation_data_size")


@pulumi.output_type
class ImageLimitSettingsResponse(dict):
    """
    Limit settings for the AutoML job.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentTrials":
            suggest = "max_concurrent_trials"
        elif key == "maxTrials":
            suggest = "max_trials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageLimitSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageLimitSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageLimitSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_trials: Optional[builtins.int] = None,
                 max_trials: Optional[builtins.int] = None,
                 timeout: Optional[builtins.str] = None):
        """
        Limit settings for the AutoML job.
        :param builtins.int max_concurrent_trials: Maximum number of concurrent AutoML iterations.
        :param builtins.int max_trials: Maximum number of AutoML iterations.
        :param builtins.str timeout: AutoML job timeout.
        """
        if max_concurrent_trials is None:
            max_concurrent_trials = 1
        if max_concurrent_trials is not None:
            pulumi.set(__self__, "max_concurrent_trials", max_concurrent_trials)
        if max_trials is None:
            max_trials = 1
        if max_trials is not None:
            pulumi.set(__self__, "max_trials", max_trials)
        if timeout is None:
            timeout = 'P7D'
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="maxConcurrentTrials")
    def max_concurrent_trials(self) -> Optional[builtins.int]:
        """
        Maximum number of concurrent AutoML iterations.
        """
        return pulumi.get(self, "max_concurrent_trials")

    @property
    @pulumi.getter(name="maxTrials")
    def max_trials(self) -> Optional[builtins.int]:
        """
        Maximum number of AutoML iterations.
        """
        return pulumi.get(self, "max_trials")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[builtins.str]:
        """
        AutoML job timeout.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ImageMetadataResponse(dict):
    """
    Returns metadata about the operating system image for this compute instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentImageVersion":
            suggest = "current_image_version"
        elif key == "isLatestOsImageVersion":
            suggest = "is_latest_os_image_version"
        elif key == "latestImageVersion":
            suggest = "latest_image_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageMetadataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageMetadataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageMetadataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 current_image_version: Optional[builtins.str] = None,
                 is_latest_os_image_version: Optional[builtins.bool] = None,
                 latest_image_version: Optional[builtins.str] = None):
        """
        Returns metadata about the operating system image for this compute instance.
        :param builtins.str current_image_version: Specifies the current operating system image version this compute instance is running on.
        :param builtins.bool is_latest_os_image_version: Specifies whether this compute instance is running on the latest operating system image.
        :param builtins.str latest_image_version: Specifies the latest available operating system image version.
        """
        if current_image_version is not None:
            pulumi.set(__self__, "current_image_version", current_image_version)
        if is_latest_os_image_version is not None:
            pulumi.set(__self__, "is_latest_os_image_version", is_latest_os_image_version)
        if latest_image_version is not None:
            pulumi.set(__self__, "latest_image_version", latest_image_version)

    @property
    @pulumi.getter(name="currentImageVersion")
    def current_image_version(self) -> Optional[builtins.str]:
        """
        Specifies the current operating system image version this compute instance is running on.
        """
        return pulumi.get(self, "current_image_version")

    @property
    @pulumi.getter(name="isLatestOsImageVersion")
    def is_latest_os_image_version(self) -> Optional[builtins.bool]:
        """
        Specifies whether this compute instance is running on the latest operating system image.
        """
        return pulumi.get(self, "is_latest_os_image_version")

    @property
    @pulumi.getter(name="latestImageVersion")
    def latest_image_version(self) -> Optional[builtins.str]:
        """
        Specifies the latest available operating system image version.
        """
        return pulumi.get(self, "latest_image_version")


@pulumi.output_type
class ImageModelDistributionSettingsClassificationResponse(dict):
    """
    Distribution expressions to sweep over values of model settings.
    <example>
    Some examples are:
    ```
    ModelName = "choice('seresnext', 'resnest50')";
    LearningRate = "uniform(0.001, 0.01)";
    LayersToFreeze = "choice(0, 2)";
    ```</example>
    For more details on how to compose distribution expressions please check the documentation:
    https://docs.microsoft.com/en-us/azure/machine-learning/how-to-tune-hyperparameters
    For more information on the available settings please visit the official documentation:
    https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amsGradient":
            suggest = "ams_gradient"
        elif key == "earlyStopping":
            suggest = "early_stopping"
        elif key == "earlyStoppingDelay":
            suggest = "early_stopping_delay"
        elif key == "earlyStoppingPatience":
            suggest = "early_stopping_patience"
        elif key == "enableOnnxNormalization":
            suggest = "enable_onnx_normalization"
        elif key == "evaluationFrequency":
            suggest = "evaluation_frequency"
        elif key == "gradientAccumulationStep":
            suggest = "gradient_accumulation_step"
        elif key == "layersToFreeze":
            suggest = "layers_to_freeze"
        elif key == "learningRate":
            suggest = "learning_rate"
        elif key == "learningRateScheduler":
            suggest = "learning_rate_scheduler"
        elif key == "modelName":
            suggest = "model_name"
        elif key == "numberOfEpochs":
            suggest = "number_of_epochs"
        elif key == "numberOfWorkers":
            suggest = "number_of_workers"
        elif key == "randomSeed":
            suggest = "random_seed"
        elif key == "stepLRGamma":
            suggest = "step_lr_gamma"
        elif key == "stepLRStepSize":
            suggest = "step_lr_step_size"
        elif key == "trainingBatchSize":
            suggest = "training_batch_size"
        elif key == "trainingCropSize":
            suggest = "training_crop_size"
        elif key == "validationBatchSize":
            suggest = "validation_batch_size"
        elif key == "validationCropSize":
            suggest = "validation_crop_size"
        elif key == "validationResizeSize":
            suggest = "validation_resize_size"
        elif key == "warmupCosineLRCycles":
            suggest = "warmup_cosine_lr_cycles"
        elif key == "warmupCosineLRWarmupEpochs":
            suggest = "warmup_cosine_lr_warmup_epochs"
        elif key == "weightDecay":
            suggest = "weight_decay"
        elif key == "weightedLoss":
            suggest = "weighted_loss"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageModelDistributionSettingsClassificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageModelDistributionSettingsClassificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageModelDistributionSettingsClassificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ams_gradient: Optional[builtins.str] = None,
                 augmentations: Optional[builtins.str] = None,
                 beta1: Optional[builtins.str] = None,
                 beta2: Optional[builtins.str] = None,
                 distributed: Optional[builtins.str] = None,
                 early_stopping: Optional[builtins.str] = None,
                 early_stopping_delay: Optional[builtins.str] = None,
                 early_stopping_patience: Optional[builtins.str] = None,
                 enable_onnx_normalization: Optional[builtins.str] = None,
                 evaluation_frequency: Optional[builtins.str] = None,
                 gradient_accumulation_step: Optional[builtins.str] = None,
                 layers_to_freeze: Optional[builtins.str] = None,
                 learning_rate: Optional[builtins.str] = None,
                 learning_rate_scheduler: Optional[builtins.str] = None,
                 model_name: Optional[builtins.str] = None,
                 momentum: Optional[builtins.str] = None,
                 nesterov: Optional[builtins.str] = None,
                 number_of_epochs: Optional[builtins.str] = None,
                 number_of_workers: Optional[builtins.str] = None,
                 optimizer: Optional[builtins.str] = None,
                 random_seed: Optional[builtins.str] = None,
                 step_lr_gamma: Optional[builtins.str] = None,
                 step_lr_step_size: Optional[builtins.str] = None,
                 training_batch_size: Optional[builtins.str] = None,
                 training_crop_size: Optional[builtins.str] = None,
                 validation_batch_size: Optional[builtins.str] = None,
                 validation_crop_size: Optional[builtins.str] = None,
                 validation_resize_size: Optional[builtins.str] = None,
                 warmup_cosine_lr_cycles: Optional[builtins.str] = None,
                 warmup_cosine_lr_warmup_epochs: Optional[builtins.str] = None,
                 weight_decay: Optional[builtins.str] = None,
                 weighted_loss: Optional[builtins.str] = None):
        """
        Distribution expressions to sweep over values of model settings.
        <example>
        Some examples are:
        ```
        ModelName = "choice('seresnext', 'resnest50')";
        LearningRate = "uniform(0.001, 0.01)";
        LayersToFreeze = "choice(0, 2)";
        ```</example>
        For more details on how to compose distribution expressions please check the documentation:
        https://docs.microsoft.com/en-us/azure/machine-learning/how-to-tune-hyperparameters
        For more information on the available settings please visit the official documentation:
        https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param builtins.str ams_gradient: Enable AMSGrad when optimizer is 'adam' or 'adamw'.
        :param builtins.str augmentations: Settings for using Augmentations.
        :param builtins.str beta1: Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        :param builtins.str beta2: Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        :param builtins.str distributed: Whether to use distributer training.
        :param builtins.str early_stopping: Enable early stopping logic during training.
        :param builtins.str early_stopping_delay: Minimum number of epochs or validation evaluations to wait before primary metric improvement
               is tracked for early stopping. Must be a positive integer.
        :param builtins.str early_stopping_patience: Minimum number of epochs or validation evaluations with no primary metric improvement before
               the run is stopped. Must be a positive integer.
        :param builtins.str enable_onnx_normalization: Enable normalization when exporting ONNX model.
        :param builtins.str evaluation_frequency: Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
        :param builtins.str gradient_accumulation_step: Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
               updating the model weights while accumulating the gradients of those steps, and then using
               the accumulated gradients to compute the weight updates. Must be a positive integer.
        :param builtins.str layers_to_freeze: Number of layers to freeze for the model. Must be a positive integer.
               For instance, passing 2 as value for 'seresnext' means
               freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
               see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param builtins.str learning_rate: Initial learning rate. Must be a float in the range [0, 1].
        :param builtins.str learning_rate_scheduler: Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
        :param builtins.str model_name: Name of the model to use for training.
               For more information on the available models please visit the official documentation:
               https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param builtins.str momentum: Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
        :param builtins.str nesterov: Enable nesterov when optimizer is 'sgd'.
        :param builtins.str number_of_epochs: Number of training epochs. Must be a positive integer.
        :param builtins.str number_of_workers: Number of data loader workers. Must be a non-negative integer.
        :param builtins.str optimizer: Type of optimizer. Must be either 'sgd', 'adam', or 'adamw'.
        :param builtins.str random_seed: Random seed to be used when using deterministic training.
        :param builtins.str step_lr_gamma: Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
        :param builtins.str step_lr_step_size: Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
        :param builtins.str training_batch_size: Training batch size. Must be a positive integer.
        :param builtins.str training_crop_size: Image crop size that is input to the neural network for the training dataset. Must be a positive integer.
        :param builtins.str validation_batch_size: Validation batch size. Must be a positive integer.
        :param builtins.str validation_crop_size: Image crop size that is input to the neural network for the validation dataset. Must be a positive integer.
        :param builtins.str validation_resize_size: Image size to which to resize before cropping for validation dataset. Must be a positive integer.
        :param builtins.str warmup_cosine_lr_cycles: Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
        :param builtins.str warmup_cosine_lr_warmup_epochs: Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
        :param builtins.str weight_decay: Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
        :param builtins.str weighted_loss: Weighted loss. The accepted values are 0 for no weighted loss.
               1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be 0 or 1 or 2.
        """
        if ams_gradient is not None:
            pulumi.set(__self__, "ams_gradient", ams_gradient)
        if augmentations is not None:
            pulumi.set(__self__, "augmentations", augmentations)
        if beta1 is not None:
            pulumi.set(__self__, "beta1", beta1)
        if beta2 is not None:
            pulumi.set(__self__, "beta2", beta2)
        if distributed is not None:
            pulumi.set(__self__, "distributed", distributed)
        if early_stopping is not None:
            pulumi.set(__self__, "early_stopping", early_stopping)
        if early_stopping_delay is not None:
            pulumi.set(__self__, "early_stopping_delay", early_stopping_delay)
        if early_stopping_patience is not None:
            pulumi.set(__self__, "early_stopping_patience", early_stopping_patience)
        if enable_onnx_normalization is not None:
            pulumi.set(__self__, "enable_onnx_normalization", enable_onnx_normalization)
        if evaluation_frequency is not None:
            pulumi.set(__self__, "evaluation_frequency", evaluation_frequency)
        if gradient_accumulation_step is not None:
            pulumi.set(__self__, "gradient_accumulation_step", gradient_accumulation_step)
        if layers_to_freeze is not None:
            pulumi.set(__self__, "layers_to_freeze", layers_to_freeze)
        if learning_rate is not None:
            pulumi.set(__self__, "learning_rate", learning_rate)
        if learning_rate_scheduler is not None:
            pulumi.set(__self__, "learning_rate_scheduler", learning_rate_scheduler)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)
        if momentum is not None:
            pulumi.set(__self__, "momentum", momentum)
        if nesterov is not None:
            pulumi.set(__self__, "nesterov", nesterov)
        if number_of_epochs is not None:
            pulumi.set(__self__, "number_of_epochs", number_of_epochs)
        if number_of_workers is not None:
            pulumi.set(__self__, "number_of_workers", number_of_workers)
        if optimizer is not None:
            pulumi.set(__self__, "optimizer", optimizer)
        if random_seed is not None:
            pulumi.set(__self__, "random_seed", random_seed)
        if step_lr_gamma is not None:
            pulumi.set(__self__, "step_lr_gamma", step_lr_gamma)
        if step_lr_step_size is not None:
            pulumi.set(__self__, "step_lr_step_size", step_lr_step_size)
        if training_batch_size is not None:
            pulumi.set(__self__, "training_batch_size", training_batch_size)
        if training_crop_size is not None:
            pulumi.set(__self__, "training_crop_size", training_crop_size)
        if validation_batch_size is not None:
            pulumi.set(__self__, "validation_batch_size", validation_batch_size)
        if validation_crop_size is not None:
            pulumi.set(__self__, "validation_crop_size", validation_crop_size)
        if validation_resize_size is not None:
            pulumi.set(__self__, "validation_resize_size", validation_resize_size)
        if warmup_cosine_lr_cycles is not None:
            pulumi.set(__self__, "warmup_cosine_lr_cycles", warmup_cosine_lr_cycles)
        if warmup_cosine_lr_warmup_epochs is not None:
            pulumi.set(__self__, "warmup_cosine_lr_warmup_epochs", warmup_cosine_lr_warmup_epochs)
        if weight_decay is not None:
            pulumi.set(__self__, "weight_decay", weight_decay)
        if weighted_loss is not None:
            pulumi.set(__self__, "weighted_loss", weighted_loss)

    @property
    @pulumi.getter(name="amsGradient")
    def ams_gradient(self) -> Optional[builtins.str]:
        """
        Enable AMSGrad when optimizer is 'adam' or 'adamw'.
        """
        return pulumi.get(self, "ams_gradient")

    @property
    @pulumi.getter
    def augmentations(self) -> Optional[builtins.str]:
        """
        Settings for using Augmentations.
        """
        return pulumi.get(self, "augmentations")

    @property
    @pulumi.getter
    def beta1(self) -> Optional[builtins.str]:
        """
        Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "beta1")

    @property
    @pulumi.getter
    def beta2(self) -> Optional[builtins.str]:
        """
        Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "beta2")

    @property
    @pulumi.getter
    def distributed(self) -> Optional[builtins.str]:
        """
        Whether to use distributer training.
        """
        return pulumi.get(self, "distributed")

    @property
    @pulumi.getter(name="earlyStopping")
    def early_stopping(self) -> Optional[builtins.str]:
        """
        Enable early stopping logic during training.
        """
        return pulumi.get(self, "early_stopping")

    @property
    @pulumi.getter(name="earlyStoppingDelay")
    def early_stopping_delay(self) -> Optional[builtins.str]:
        """
        Minimum number of epochs or validation evaluations to wait before primary metric improvement
        is tracked for early stopping. Must be a positive integer.
        """
        return pulumi.get(self, "early_stopping_delay")

    @property
    @pulumi.getter(name="earlyStoppingPatience")
    def early_stopping_patience(self) -> Optional[builtins.str]:
        """
        Minimum number of epochs or validation evaluations with no primary metric improvement before
        the run is stopped. Must be a positive integer.
        """
        return pulumi.get(self, "early_stopping_patience")

    @property
    @pulumi.getter(name="enableOnnxNormalization")
    def enable_onnx_normalization(self) -> Optional[builtins.str]:
        """
        Enable normalization when exporting ONNX model.
        """
        return pulumi.get(self, "enable_onnx_normalization")

    @property
    @pulumi.getter(name="evaluationFrequency")
    def evaluation_frequency(self) -> Optional[builtins.str]:
        """
        Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
        """
        return pulumi.get(self, "evaluation_frequency")

    @property
    @pulumi.getter(name="gradientAccumulationStep")
    def gradient_accumulation_step(self) -> Optional[builtins.str]:
        """
        Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
        updating the model weights while accumulating the gradients of those steps, and then using
        the accumulated gradients to compute the weight updates. Must be a positive integer.
        """
        return pulumi.get(self, "gradient_accumulation_step")

    @property
    @pulumi.getter(name="layersToFreeze")
    def layers_to_freeze(self) -> Optional[builtins.str]:
        """
        Number of layers to freeze for the model. Must be a positive integer.
        For instance, passing 2 as value for 'seresnext' means
        freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
        see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        """
        return pulumi.get(self, "layers_to_freeze")

    @property
    @pulumi.getter(name="learningRate")
    def learning_rate(self) -> Optional[builtins.str]:
        """
        Initial learning rate. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "learning_rate")

    @property
    @pulumi.getter(name="learningRateScheduler")
    def learning_rate_scheduler(self) -> Optional[builtins.str]:
        """
        Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
        """
        return pulumi.get(self, "learning_rate_scheduler")

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[builtins.str]:
        """
        Name of the model to use for training.
        For more information on the available models please visit the official documentation:
        https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        """
        return pulumi.get(self, "model_name")

    @property
    @pulumi.getter
    def momentum(self) -> Optional[builtins.str]:
        """
        Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "momentum")

    @property
    @pulumi.getter
    def nesterov(self) -> Optional[builtins.str]:
        """
        Enable nesterov when optimizer is 'sgd'.
        """
        return pulumi.get(self, "nesterov")

    @property
    @pulumi.getter(name="numberOfEpochs")
    def number_of_epochs(self) -> Optional[builtins.str]:
        """
        Number of training epochs. Must be a positive integer.
        """
        return pulumi.get(self, "number_of_epochs")

    @property
    @pulumi.getter(name="numberOfWorkers")
    def number_of_workers(self) -> Optional[builtins.str]:
        """
        Number of data loader workers. Must be a non-negative integer.
        """
        return pulumi.get(self, "number_of_workers")

    @property
    @pulumi.getter
    def optimizer(self) -> Optional[builtins.str]:
        """
        Type of optimizer. Must be either 'sgd', 'adam', or 'adamw'.
        """
        return pulumi.get(self, "optimizer")

    @property
    @pulumi.getter(name="randomSeed")
    def random_seed(self) -> Optional[builtins.str]:
        """
        Random seed to be used when using deterministic training.
        """
        return pulumi.get(self, "random_seed")

    @property
    @pulumi.getter(name="stepLRGamma")
    def step_lr_gamma(self) -> Optional[builtins.str]:
        """
        Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "step_lr_gamma")

    @property
    @pulumi.getter(name="stepLRStepSize")
    def step_lr_step_size(self) -> Optional[builtins.str]:
        """
        Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
        """
        return pulumi.get(self, "step_lr_step_size")

    @property
    @pulumi.getter(name="trainingBatchSize")
    def training_batch_size(self) -> Optional[builtins.str]:
        """
        Training batch size. Must be a positive integer.
        """
        return pulumi.get(self, "training_batch_size")

    @property
    @pulumi.getter(name="trainingCropSize")
    def training_crop_size(self) -> Optional[builtins.str]:
        """
        Image crop size that is input to the neural network for the training dataset. Must be a positive integer.
        """
        return pulumi.get(self, "training_crop_size")

    @property
    @pulumi.getter(name="validationBatchSize")
    def validation_batch_size(self) -> Optional[builtins.str]:
        """
        Validation batch size. Must be a positive integer.
        """
        return pulumi.get(self, "validation_batch_size")

    @property
    @pulumi.getter(name="validationCropSize")
    def validation_crop_size(self) -> Optional[builtins.str]:
        """
        Image crop size that is input to the neural network for the validation dataset. Must be a positive integer.
        """
        return pulumi.get(self, "validation_crop_size")

    @property
    @pulumi.getter(name="validationResizeSize")
    def validation_resize_size(self) -> Optional[builtins.str]:
        """
        Image size to which to resize before cropping for validation dataset. Must be a positive integer.
        """
        return pulumi.get(self, "validation_resize_size")

    @property
    @pulumi.getter(name="warmupCosineLRCycles")
    def warmup_cosine_lr_cycles(self) -> Optional[builtins.str]:
        """
        Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "warmup_cosine_lr_cycles")

    @property
    @pulumi.getter(name="warmupCosineLRWarmupEpochs")
    def warmup_cosine_lr_warmup_epochs(self) -> Optional[builtins.str]:
        """
        Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
        """
        return pulumi.get(self, "warmup_cosine_lr_warmup_epochs")

    @property
    @pulumi.getter(name="weightDecay")
    def weight_decay(self) -> Optional[builtins.str]:
        """
        Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
        """
        return pulumi.get(self, "weight_decay")

    @property
    @pulumi.getter(name="weightedLoss")
    def weighted_loss(self) -> Optional[builtins.str]:
        """
        Weighted loss. The accepted values are 0 for no weighted loss.
        1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be 0 or 1 or 2.
        """
        return pulumi.get(self, "weighted_loss")


@pulumi.output_type
class ImageModelDistributionSettingsObjectDetectionResponse(dict):
    """
    Distribution expressions to sweep over values of model settings.
    <example>
    Some examples are:
    ```
    ModelName = "choice('seresnext', 'resnest50')";
    LearningRate = "uniform(0.001, 0.01)";
    LayersToFreeze = "choice(0, 2)";
    ```</example>
    For more details on how to compose distribution expressions please check the documentation:
    https://docs.microsoft.com/en-us/azure/machine-learning/how-to-tune-hyperparameters
    For more information on the available settings please visit the official documentation:
    https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amsGradient":
            suggest = "ams_gradient"
        elif key == "boxDetectionsPerImage":
            suggest = "box_detections_per_image"
        elif key == "boxScoreThreshold":
            suggest = "box_score_threshold"
        elif key == "earlyStopping":
            suggest = "early_stopping"
        elif key == "earlyStoppingDelay":
            suggest = "early_stopping_delay"
        elif key == "earlyStoppingPatience":
            suggest = "early_stopping_patience"
        elif key == "enableOnnxNormalization":
            suggest = "enable_onnx_normalization"
        elif key == "evaluationFrequency":
            suggest = "evaluation_frequency"
        elif key == "gradientAccumulationStep":
            suggest = "gradient_accumulation_step"
        elif key == "imageSize":
            suggest = "image_size"
        elif key == "layersToFreeze":
            suggest = "layers_to_freeze"
        elif key == "learningRate":
            suggest = "learning_rate"
        elif key == "learningRateScheduler":
            suggest = "learning_rate_scheduler"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "modelName":
            suggest = "model_name"
        elif key == "modelSize":
            suggest = "model_size"
        elif key == "multiScale":
            suggest = "multi_scale"
        elif key == "nmsIouThreshold":
            suggest = "nms_iou_threshold"
        elif key == "numberOfEpochs":
            suggest = "number_of_epochs"
        elif key == "numberOfWorkers":
            suggest = "number_of_workers"
        elif key == "randomSeed":
            suggest = "random_seed"
        elif key == "stepLRGamma":
            suggest = "step_lr_gamma"
        elif key == "stepLRStepSize":
            suggest = "step_lr_step_size"
        elif key == "tileGridSize":
            suggest = "tile_grid_size"
        elif key == "tileOverlapRatio":
            suggest = "tile_overlap_ratio"
        elif key == "tilePredictionsNmsThreshold":
            suggest = "tile_predictions_nms_threshold"
        elif key == "trainingBatchSize":
            suggest = "training_batch_size"
        elif key == "validationBatchSize":
            suggest = "validation_batch_size"
        elif key == "validationIouThreshold":
            suggest = "validation_iou_threshold"
        elif key == "validationMetricType":
            suggest = "validation_metric_type"
        elif key == "warmupCosineLRCycles":
            suggest = "warmup_cosine_lr_cycles"
        elif key == "warmupCosineLRWarmupEpochs":
            suggest = "warmup_cosine_lr_warmup_epochs"
        elif key == "weightDecay":
            suggest = "weight_decay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageModelDistributionSettingsObjectDetectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageModelDistributionSettingsObjectDetectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageModelDistributionSettingsObjectDetectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ams_gradient: Optional[builtins.str] = None,
                 augmentations: Optional[builtins.str] = None,
                 beta1: Optional[builtins.str] = None,
                 beta2: Optional[builtins.str] = None,
                 box_detections_per_image: Optional[builtins.str] = None,
                 box_score_threshold: Optional[builtins.str] = None,
                 distributed: Optional[builtins.str] = None,
                 early_stopping: Optional[builtins.str] = None,
                 early_stopping_delay: Optional[builtins.str] = None,
                 early_stopping_patience: Optional[builtins.str] = None,
                 enable_onnx_normalization: Optional[builtins.str] = None,
                 evaluation_frequency: Optional[builtins.str] = None,
                 gradient_accumulation_step: Optional[builtins.str] = None,
                 image_size: Optional[builtins.str] = None,
                 layers_to_freeze: Optional[builtins.str] = None,
                 learning_rate: Optional[builtins.str] = None,
                 learning_rate_scheduler: Optional[builtins.str] = None,
                 max_size: Optional[builtins.str] = None,
                 min_size: Optional[builtins.str] = None,
                 model_name: Optional[builtins.str] = None,
                 model_size: Optional[builtins.str] = None,
                 momentum: Optional[builtins.str] = None,
                 multi_scale: Optional[builtins.str] = None,
                 nesterov: Optional[builtins.str] = None,
                 nms_iou_threshold: Optional[builtins.str] = None,
                 number_of_epochs: Optional[builtins.str] = None,
                 number_of_workers: Optional[builtins.str] = None,
                 optimizer: Optional[builtins.str] = None,
                 random_seed: Optional[builtins.str] = None,
                 step_lr_gamma: Optional[builtins.str] = None,
                 step_lr_step_size: Optional[builtins.str] = None,
                 tile_grid_size: Optional[builtins.str] = None,
                 tile_overlap_ratio: Optional[builtins.str] = None,
                 tile_predictions_nms_threshold: Optional[builtins.str] = None,
                 training_batch_size: Optional[builtins.str] = None,
                 validation_batch_size: Optional[builtins.str] = None,
                 validation_iou_threshold: Optional[builtins.str] = None,
                 validation_metric_type: Optional[builtins.str] = None,
                 warmup_cosine_lr_cycles: Optional[builtins.str] = None,
                 warmup_cosine_lr_warmup_epochs: Optional[builtins.str] = None,
                 weight_decay: Optional[builtins.str] = None):
        """
        Distribution expressions to sweep over values of model settings.
        <example>
        Some examples are:
        ```
        ModelName = "choice('seresnext', 'resnest50')";
        LearningRate = "uniform(0.001, 0.01)";
        LayersToFreeze = "choice(0, 2)";
        ```</example>
        For more details on how to compose distribution expressions please check the documentation:
        https://docs.microsoft.com/en-us/azure/machine-learning/how-to-tune-hyperparameters
        For more information on the available settings please visit the official documentation:
        https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param builtins.str ams_gradient: Enable AMSGrad when optimizer is 'adam' or 'adamw'.
        :param builtins.str augmentations: Settings for using Augmentations.
        :param builtins.str beta1: Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        :param builtins.str beta2: Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        :param builtins.str box_detections_per_image: Maximum number of detections per image, for all classes. Must be a positive integer.
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param builtins.str box_score_threshold: During inference, only return proposals with a classification score greater than
               BoxScoreThreshold. Must be a float in the range[0, 1].
        :param builtins.str distributed: Whether to use distributer training.
        :param builtins.str early_stopping: Enable early stopping logic during training.
        :param builtins.str early_stopping_delay: Minimum number of epochs or validation evaluations to wait before primary metric improvement
               is tracked for early stopping. Must be a positive integer.
        :param builtins.str early_stopping_patience: Minimum number of epochs or validation evaluations with no primary metric improvement before
               the run is stopped. Must be a positive integer.
        :param builtins.str enable_onnx_normalization: Enable normalization when exporting ONNX model.
        :param builtins.str evaluation_frequency: Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
        :param builtins.str gradient_accumulation_step: Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
               updating the model weights while accumulating the gradients of those steps, and then using
               the accumulated gradients to compute the weight updates. Must be a positive integer.
        :param builtins.str image_size: Image size for train and validation. Must be a positive integer.
               Note: The training run may get into CUDA OOM if the size is too big.
               Note: This settings is only supported for the 'yolov5' algorithm.
        :param builtins.str layers_to_freeze: Number of layers to freeze for the model. Must be a positive integer.
               For instance, passing 2 as value for 'seresnext' means
               freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
               see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param builtins.str learning_rate: Initial learning rate. Must be a float in the range [0, 1].
        :param builtins.str learning_rate_scheduler: Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
        :param builtins.str max_size: Maximum size of the image to be rescaled before feeding it to the backbone.
               Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param builtins.str min_size: Minimum size of the image to be rescaled before feeding it to the backbone.
               Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param builtins.str model_name: Name of the model to use for training.
               For more information on the available models please visit the official documentation:
               https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param builtins.str model_size: Model size. Must be 'small', 'medium', 'large', or 'xlarge'.
               Note: training run may get into CUDA OOM if the model size is too big.
               Note: This settings is only supported for the 'yolov5' algorithm.
        :param builtins.str momentum: Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
        :param builtins.str multi_scale: Enable multi-scale image by varying image size by +/- 50%.
               Note: training run may get into CUDA OOM if no sufficient GPU memory.
               Note: This settings is only supported for the 'yolov5' algorithm.
        :param builtins.str nesterov: Enable nesterov when optimizer is 'sgd'.
        :param builtins.str nms_iou_threshold: IOU threshold used during inference in NMS post processing. Must be float in the range [0, 1].
        :param builtins.str number_of_epochs: Number of training epochs. Must be a positive integer.
        :param builtins.str number_of_workers: Number of data loader workers. Must be a non-negative integer.
        :param builtins.str optimizer: Type of optimizer. Must be either 'sgd', 'adam', or 'adamw'.
        :param builtins.str random_seed: Random seed to be used when using deterministic training.
        :param builtins.str step_lr_gamma: Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
        :param builtins.str step_lr_step_size: Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
        :param builtins.str tile_grid_size: The grid size to use for tiling each image. Note: TileGridSize must not be
               None to enable small object detection logic. A string containing two integers in mxn format.
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param builtins.str tile_overlap_ratio: Overlap ratio between adjacent tiles in each dimension. Must be float in the range [0, 1).
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param builtins.str tile_predictions_nms_threshold: The IOU threshold to use to perform NMS while merging predictions from tiles and image.
               Used in validation/ inference. Must be float in the range [0, 1].
               Note: This settings is not supported for the 'yolov5' algorithm.
               NMS: Non-maximum suppression
        :param builtins.str training_batch_size: Training batch size. Must be a positive integer.
        :param builtins.str validation_batch_size: Validation batch size. Must be a positive integer.
        :param builtins.str validation_iou_threshold: IOU threshold to use when computing validation metric. Must be float in the range [0, 1].
        :param builtins.str validation_metric_type: Metric computation method to use for validation metrics. Must be 'none', 'coco', 'voc', or 'coco_voc'.
        :param builtins.str warmup_cosine_lr_cycles: Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
        :param builtins.str warmup_cosine_lr_warmup_epochs: Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
        :param builtins.str weight_decay: Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
        """
        if ams_gradient is not None:
            pulumi.set(__self__, "ams_gradient", ams_gradient)
        if augmentations is not None:
            pulumi.set(__self__, "augmentations", augmentations)
        if beta1 is not None:
            pulumi.set(__self__, "beta1", beta1)
        if beta2 is not None:
            pulumi.set(__self__, "beta2", beta2)
        if box_detections_per_image is not None:
            pulumi.set(__self__, "box_detections_per_image", box_detections_per_image)
        if box_score_threshold is not None:
            pulumi.set(__self__, "box_score_threshold", box_score_threshold)
        if distributed is not None:
            pulumi.set(__self__, "distributed", distributed)
        if early_stopping is not None:
            pulumi.set(__self__, "early_stopping", early_stopping)
        if early_stopping_delay is not None:
            pulumi.set(__self__, "early_stopping_delay", early_stopping_delay)
        if early_stopping_patience is not None:
            pulumi.set(__self__, "early_stopping_patience", early_stopping_patience)
        if enable_onnx_normalization is not None:
            pulumi.set(__self__, "enable_onnx_normalization", enable_onnx_normalization)
        if evaluation_frequency is not None:
            pulumi.set(__self__, "evaluation_frequency", evaluation_frequency)
        if gradient_accumulation_step is not None:
            pulumi.set(__self__, "gradient_accumulation_step", gradient_accumulation_step)
        if image_size is not None:
            pulumi.set(__self__, "image_size", image_size)
        if layers_to_freeze is not None:
            pulumi.set(__self__, "layers_to_freeze", layers_to_freeze)
        if learning_rate is not None:
            pulumi.set(__self__, "learning_rate", learning_rate)
        if learning_rate_scheduler is not None:
            pulumi.set(__self__, "learning_rate_scheduler", learning_rate_scheduler)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)
        if model_size is not None:
            pulumi.set(__self__, "model_size", model_size)
        if momentum is not None:
            pulumi.set(__self__, "momentum", momentum)
        if multi_scale is not None:
            pulumi.set(__self__, "multi_scale", multi_scale)
        if nesterov is not None:
            pulumi.set(__self__, "nesterov", nesterov)
        if nms_iou_threshold is not None:
            pulumi.set(__self__, "nms_iou_threshold", nms_iou_threshold)
        if number_of_epochs is not None:
            pulumi.set(__self__, "number_of_epochs", number_of_epochs)
        if number_of_workers is not None:
            pulumi.set(__self__, "number_of_workers", number_of_workers)
        if optimizer is not None:
            pulumi.set(__self__, "optimizer", optimizer)
        if random_seed is not None:
            pulumi.set(__self__, "random_seed", random_seed)
        if step_lr_gamma is not None:
            pulumi.set(__self__, "step_lr_gamma", step_lr_gamma)
        if step_lr_step_size is not None:
            pulumi.set(__self__, "step_lr_step_size", step_lr_step_size)
        if tile_grid_size is not None:
            pulumi.set(__self__, "tile_grid_size", tile_grid_size)
        if tile_overlap_ratio is not None:
            pulumi.set(__self__, "tile_overlap_ratio", tile_overlap_ratio)
        if tile_predictions_nms_threshold is not None:
            pulumi.set(__self__, "tile_predictions_nms_threshold", tile_predictions_nms_threshold)
        if training_batch_size is not None:
            pulumi.set(__self__, "training_batch_size", training_batch_size)
        if validation_batch_size is not None:
            pulumi.set(__self__, "validation_batch_size", validation_batch_size)
        if validation_iou_threshold is not None:
            pulumi.set(__self__, "validation_iou_threshold", validation_iou_threshold)
        if validation_metric_type is not None:
            pulumi.set(__self__, "validation_metric_type", validation_metric_type)
        if warmup_cosine_lr_cycles is not None:
            pulumi.set(__self__, "warmup_cosine_lr_cycles", warmup_cosine_lr_cycles)
        if warmup_cosine_lr_warmup_epochs is not None:
            pulumi.set(__self__, "warmup_cosine_lr_warmup_epochs", warmup_cosine_lr_warmup_epochs)
        if weight_decay is not None:
            pulumi.set(__self__, "weight_decay", weight_decay)

    @property
    @pulumi.getter(name="amsGradient")
    def ams_gradient(self) -> Optional[builtins.str]:
        """
        Enable AMSGrad when optimizer is 'adam' or 'adamw'.
        """
        return pulumi.get(self, "ams_gradient")

    @property
    @pulumi.getter
    def augmentations(self) -> Optional[builtins.str]:
        """
        Settings for using Augmentations.
        """
        return pulumi.get(self, "augmentations")

    @property
    @pulumi.getter
    def beta1(self) -> Optional[builtins.str]:
        """
        Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "beta1")

    @property
    @pulumi.getter
    def beta2(self) -> Optional[builtins.str]:
        """
        Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "beta2")

    @property
    @pulumi.getter(name="boxDetectionsPerImage")
    def box_detections_per_image(self) -> Optional[builtins.str]:
        """
        Maximum number of detections per image, for all classes. Must be a positive integer.
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "box_detections_per_image")

    @property
    @pulumi.getter(name="boxScoreThreshold")
    def box_score_threshold(self) -> Optional[builtins.str]:
        """
        During inference, only return proposals with a classification score greater than
        BoxScoreThreshold. Must be a float in the range[0, 1].
        """
        return pulumi.get(self, "box_score_threshold")

    @property
    @pulumi.getter
    def distributed(self) -> Optional[builtins.str]:
        """
        Whether to use distributer training.
        """
        return pulumi.get(self, "distributed")

    @property
    @pulumi.getter(name="earlyStopping")
    def early_stopping(self) -> Optional[builtins.str]:
        """
        Enable early stopping logic during training.
        """
        return pulumi.get(self, "early_stopping")

    @property
    @pulumi.getter(name="earlyStoppingDelay")
    def early_stopping_delay(self) -> Optional[builtins.str]:
        """
        Minimum number of epochs or validation evaluations to wait before primary metric improvement
        is tracked for early stopping. Must be a positive integer.
        """
        return pulumi.get(self, "early_stopping_delay")

    @property
    @pulumi.getter(name="earlyStoppingPatience")
    def early_stopping_patience(self) -> Optional[builtins.str]:
        """
        Minimum number of epochs or validation evaluations with no primary metric improvement before
        the run is stopped. Must be a positive integer.
        """
        return pulumi.get(self, "early_stopping_patience")

    @property
    @pulumi.getter(name="enableOnnxNormalization")
    def enable_onnx_normalization(self) -> Optional[builtins.str]:
        """
        Enable normalization when exporting ONNX model.
        """
        return pulumi.get(self, "enable_onnx_normalization")

    @property
    @pulumi.getter(name="evaluationFrequency")
    def evaluation_frequency(self) -> Optional[builtins.str]:
        """
        Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
        """
        return pulumi.get(self, "evaluation_frequency")

    @property
    @pulumi.getter(name="gradientAccumulationStep")
    def gradient_accumulation_step(self) -> Optional[builtins.str]:
        """
        Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
        updating the model weights while accumulating the gradients of those steps, and then using
        the accumulated gradients to compute the weight updates. Must be a positive integer.
        """
        return pulumi.get(self, "gradient_accumulation_step")

    @property
    @pulumi.getter(name="imageSize")
    def image_size(self) -> Optional[builtins.str]:
        """
        Image size for train and validation. Must be a positive integer.
        Note: The training run may get into CUDA OOM if the size is too big.
        Note: This settings is only supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "image_size")

    @property
    @pulumi.getter(name="layersToFreeze")
    def layers_to_freeze(self) -> Optional[builtins.str]:
        """
        Number of layers to freeze for the model. Must be a positive integer.
        For instance, passing 2 as value for 'seresnext' means
        freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
        see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        """
        return pulumi.get(self, "layers_to_freeze")

    @property
    @pulumi.getter(name="learningRate")
    def learning_rate(self) -> Optional[builtins.str]:
        """
        Initial learning rate. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "learning_rate")

    @property
    @pulumi.getter(name="learningRateScheduler")
    def learning_rate_scheduler(self) -> Optional[builtins.str]:
        """
        Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
        """
        return pulumi.get(self, "learning_rate_scheduler")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[builtins.str]:
        """
        Maximum size of the image to be rescaled before feeding it to the backbone.
        Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[builtins.str]:
        """
        Minimum size of the image to be rescaled before feeding it to the backbone.
        Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[builtins.str]:
        """
        Name of the model to use for training.
        For more information on the available models please visit the official documentation:
        https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        """
        return pulumi.get(self, "model_name")

    @property
    @pulumi.getter(name="modelSize")
    def model_size(self) -> Optional[builtins.str]:
        """
        Model size. Must be 'small', 'medium', 'large', or 'xlarge'.
        Note: training run may get into CUDA OOM if the model size is too big.
        Note: This settings is only supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "model_size")

    @property
    @pulumi.getter
    def momentum(self) -> Optional[builtins.str]:
        """
        Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "momentum")

    @property
    @pulumi.getter(name="multiScale")
    def multi_scale(self) -> Optional[builtins.str]:
        """
        Enable multi-scale image by varying image size by +/- 50%.
        Note: training run may get into CUDA OOM if no sufficient GPU memory.
        Note: This settings is only supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "multi_scale")

    @property
    @pulumi.getter
    def nesterov(self) -> Optional[builtins.str]:
        """
        Enable nesterov when optimizer is 'sgd'.
        """
        return pulumi.get(self, "nesterov")

    @property
    @pulumi.getter(name="nmsIouThreshold")
    def nms_iou_threshold(self) -> Optional[builtins.str]:
        """
        IOU threshold used during inference in NMS post processing. Must be float in the range [0, 1].
        """
        return pulumi.get(self, "nms_iou_threshold")

    @property
    @pulumi.getter(name="numberOfEpochs")
    def number_of_epochs(self) -> Optional[builtins.str]:
        """
        Number of training epochs. Must be a positive integer.
        """
        return pulumi.get(self, "number_of_epochs")

    @property
    @pulumi.getter(name="numberOfWorkers")
    def number_of_workers(self) -> Optional[builtins.str]:
        """
        Number of data loader workers. Must be a non-negative integer.
        """
        return pulumi.get(self, "number_of_workers")

    @property
    @pulumi.getter
    def optimizer(self) -> Optional[builtins.str]:
        """
        Type of optimizer. Must be either 'sgd', 'adam', or 'adamw'.
        """
        return pulumi.get(self, "optimizer")

    @property
    @pulumi.getter(name="randomSeed")
    def random_seed(self) -> Optional[builtins.str]:
        """
        Random seed to be used when using deterministic training.
        """
        return pulumi.get(self, "random_seed")

    @property
    @pulumi.getter(name="stepLRGamma")
    def step_lr_gamma(self) -> Optional[builtins.str]:
        """
        Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "step_lr_gamma")

    @property
    @pulumi.getter(name="stepLRStepSize")
    def step_lr_step_size(self) -> Optional[builtins.str]:
        """
        Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
        """
        return pulumi.get(self, "step_lr_step_size")

    @property
    @pulumi.getter(name="tileGridSize")
    def tile_grid_size(self) -> Optional[builtins.str]:
        """
        The grid size to use for tiling each image. Note: TileGridSize must not be
        None to enable small object detection logic. A string containing two integers in mxn format.
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "tile_grid_size")

    @property
    @pulumi.getter(name="tileOverlapRatio")
    def tile_overlap_ratio(self) -> Optional[builtins.str]:
        """
        Overlap ratio between adjacent tiles in each dimension. Must be float in the range [0, 1).
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "tile_overlap_ratio")

    @property
    @pulumi.getter(name="tilePredictionsNmsThreshold")
    def tile_predictions_nms_threshold(self) -> Optional[builtins.str]:
        """
        The IOU threshold to use to perform NMS while merging predictions from tiles and image.
        Used in validation/ inference. Must be float in the range [0, 1].
        Note: This settings is not supported for the 'yolov5' algorithm.
        NMS: Non-maximum suppression
        """
        return pulumi.get(self, "tile_predictions_nms_threshold")

    @property
    @pulumi.getter(name="trainingBatchSize")
    def training_batch_size(self) -> Optional[builtins.str]:
        """
        Training batch size. Must be a positive integer.
        """
        return pulumi.get(self, "training_batch_size")

    @property
    @pulumi.getter(name="validationBatchSize")
    def validation_batch_size(self) -> Optional[builtins.str]:
        """
        Validation batch size. Must be a positive integer.
        """
        return pulumi.get(self, "validation_batch_size")

    @property
    @pulumi.getter(name="validationIouThreshold")
    def validation_iou_threshold(self) -> Optional[builtins.str]:
        """
        IOU threshold to use when computing validation metric. Must be float in the range [0, 1].
        """
        return pulumi.get(self, "validation_iou_threshold")

    @property
    @pulumi.getter(name="validationMetricType")
    def validation_metric_type(self) -> Optional[builtins.str]:
        """
        Metric computation method to use for validation metrics. Must be 'none', 'coco', 'voc', or 'coco_voc'.
        """
        return pulumi.get(self, "validation_metric_type")

    @property
    @pulumi.getter(name="warmupCosineLRCycles")
    def warmup_cosine_lr_cycles(self) -> Optional[builtins.str]:
        """
        Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "warmup_cosine_lr_cycles")

    @property
    @pulumi.getter(name="warmupCosineLRWarmupEpochs")
    def warmup_cosine_lr_warmup_epochs(self) -> Optional[builtins.str]:
        """
        Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
        """
        return pulumi.get(self, "warmup_cosine_lr_warmup_epochs")

    @property
    @pulumi.getter(name="weightDecay")
    def weight_decay(self) -> Optional[builtins.str]:
        """
        Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
        """
        return pulumi.get(self, "weight_decay")


@pulumi.output_type
class ImageModelSettingsClassificationResponse(dict):
    """
    Settings used for training the model.
    For more information on the available settings please visit the official documentation:
    https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advancedSettings":
            suggest = "advanced_settings"
        elif key == "amsGradient":
            suggest = "ams_gradient"
        elif key == "checkpointFrequency":
            suggest = "checkpoint_frequency"
        elif key == "checkpointModel":
            suggest = "checkpoint_model"
        elif key == "checkpointRunId":
            suggest = "checkpoint_run_id"
        elif key == "earlyStopping":
            suggest = "early_stopping"
        elif key == "earlyStoppingDelay":
            suggest = "early_stopping_delay"
        elif key == "earlyStoppingPatience":
            suggest = "early_stopping_patience"
        elif key == "enableOnnxNormalization":
            suggest = "enable_onnx_normalization"
        elif key == "evaluationFrequency":
            suggest = "evaluation_frequency"
        elif key == "gradientAccumulationStep":
            suggest = "gradient_accumulation_step"
        elif key == "layersToFreeze":
            suggest = "layers_to_freeze"
        elif key == "learningRate":
            suggest = "learning_rate"
        elif key == "learningRateScheduler":
            suggest = "learning_rate_scheduler"
        elif key == "modelName":
            suggest = "model_name"
        elif key == "numberOfEpochs":
            suggest = "number_of_epochs"
        elif key == "numberOfWorkers":
            suggest = "number_of_workers"
        elif key == "randomSeed":
            suggest = "random_seed"
        elif key == "stepLRGamma":
            suggest = "step_lr_gamma"
        elif key == "stepLRStepSize":
            suggest = "step_lr_step_size"
        elif key == "trainingBatchSize":
            suggest = "training_batch_size"
        elif key == "trainingCropSize":
            suggest = "training_crop_size"
        elif key == "validationBatchSize":
            suggest = "validation_batch_size"
        elif key == "validationCropSize":
            suggest = "validation_crop_size"
        elif key == "validationResizeSize":
            suggest = "validation_resize_size"
        elif key == "warmupCosineLRCycles":
            suggest = "warmup_cosine_lr_cycles"
        elif key == "warmupCosineLRWarmupEpochs":
            suggest = "warmup_cosine_lr_warmup_epochs"
        elif key == "weightDecay":
            suggest = "weight_decay"
        elif key == "weightedLoss":
            suggest = "weighted_loss"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageModelSettingsClassificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageModelSettingsClassificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageModelSettingsClassificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advanced_settings: Optional[builtins.str] = None,
                 ams_gradient: Optional[builtins.bool] = None,
                 augmentations: Optional[builtins.str] = None,
                 beta1: Optional[builtins.float] = None,
                 beta2: Optional[builtins.float] = None,
                 checkpoint_frequency: Optional[builtins.int] = None,
                 checkpoint_model: Optional['outputs.MLFlowModelJobInputResponse'] = None,
                 checkpoint_run_id: Optional[builtins.str] = None,
                 distributed: Optional[builtins.bool] = None,
                 early_stopping: Optional[builtins.bool] = None,
                 early_stopping_delay: Optional[builtins.int] = None,
                 early_stopping_patience: Optional[builtins.int] = None,
                 enable_onnx_normalization: Optional[builtins.bool] = None,
                 evaluation_frequency: Optional[builtins.int] = None,
                 gradient_accumulation_step: Optional[builtins.int] = None,
                 layers_to_freeze: Optional[builtins.int] = None,
                 learning_rate: Optional[builtins.float] = None,
                 learning_rate_scheduler: Optional[builtins.str] = None,
                 model_name: Optional[builtins.str] = None,
                 momentum: Optional[builtins.float] = None,
                 nesterov: Optional[builtins.bool] = None,
                 number_of_epochs: Optional[builtins.int] = None,
                 number_of_workers: Optional[builtins.int] = None,
                 optimizer: Optional[builtins.str] = None,
                 random_seed: Optional[builtins.int] = None,
                 step_lr_gamma: Optional[builtins.float] = None,
                 step_lr_step_size: Optional[builtins.int] = None,
                 training_batch_size: Optional[builtins.int] = None,
                 training_crop_size: Optional[builtins.int] = None,
                 validation_batch_size: Optional[builtins.int] = None,
                 validation_crop_size: Optional[builtins.int] = None,
                 validation_resize_size: Optional[builtins.int] = None,
                 warmup_cosine_lr_cycles: Optional[builtins.float] = None,
                 warmup_cosine_lr_warmup_epochs: Optional[builtins.int] = None,
                 weight_decay: Optional[builtins.float] = None,
                 weighted_loss: Optional[builtins.int] = None):
        """
        Settings used for training the model.
        For more information on the available settings please visit the official documentation:
        https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param builtins.str advanced_settings: Settings for advanced scenarios.
        :param builtins.bool ams_gradient: Enable AMSGrad when optimizer is 'adam' or 'adamw'.
        :param builtins.str augmentations: Settings for using Augmentations.
        :param builtins.float beta1: Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        :param builtins.float beta2: Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        :param builtins.int checkpoint_frequency: Frequency to store model checkpoints. Must be a positive integer.
        :param 'MLFlowModelJobInputResponse' checkpoint_model: The pretrained checkpoint model for incremental training.
        :param builtins.str checkpoint_run_id: The id of a previous run that has a pretrained checkpoint for incremental training.
        :param builtins.bool distributed: Whether to use distributed training.
        :param builtins.bool early_stopping: Enable early stopping logic during training.
        :param builtins.int early_stopping_delay: Minimum number of epochs or validation evaluations to wait before primary metric improvement
               is tracked for early stopping. Must be a positive integer.
        :param builtins.int early_stopping_patience: Minimum number of epochs or validation evaluations with no primary metric improvement before
               the run is stopped. Must be a positive integer.
        :param builtins.bool enable_onnx_normalization: Enable normalization when exporting ONNX model.
        :param builtins.int evaluation_frequency: Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
        :param builtins.int gradient_accumulation_step: Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
               updating the model weights while accumulating the gradients of those steps, and then using
               the accumulated gradients to compute the weight updates. Must be a positive integer.
        :param builtins.int layers_to_freeze: Number of layers to freeze for the model. Must be a positive integer.
               For instance, passing 2 as value for 'seresnext' means
               freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
               see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param builtins.float learning_rate: Initial learning rate. Must be a float in the range [0, 1].
        :param builtins.str learning_rate_scheduler: Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
        :param builtins.str model_name: Name of the model to use for training.
               For more information on the available models please visit the official documentation:
               https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param builtins.float momentum: Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
        :param builtins.bool nesterov: Enable nesterov when optimizer is 'sgd'.
        :param builtins.int number_of_epochs: Number of training epochs. Must be a positive integer.
        :param builtins.int number_of_workers: Number of data loader workers. Must be a non-negative integer.
        :param builtins.str optimizer: Type of optimizer.
        :param builtins.int random_seed: Random seed to be used when using deterministic training.
        :param builtins.float step_lr_gamma: Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
        :param builtins.int step_lr_step_size: Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
        :param builtins.int training_batch_size: Training batch size. Must be a positive integer.
        :param builtins.int training_crop_size: Image crop size that is input to the neural network for the training dataset. Must be a positive integer.
        :param builtins.int validation_batch_size: Validation batch size. Must be a positive integer.
        :param builtins.int validation_crop_size: Image crop size that is input to the neural network for the validation dataset. Must be a positive integer.
        :param builtins.int validation_resize_size: Image size to which to resize before cropping for validation dataset. Must be a positive integer.
        :param builtins.float warmup_cosine_lr_cycles: Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
        :param builtins.int warmup_cosine_lr_warmup_epochs: Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
        :param builtins.float weight_decay: Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
        :param builtins.int weighted_loss: Weighted loss. The accepted values are 0 for no weighted loss.
               1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be 0 or 1 or 2.
        """
        if advanced_settings is not None:
            pulumi.set(__self__, "advanced_settings", advanced_settings)
        if ams_gradient is not None:
            pulumi.set(__self__, "ams_gradient", ams_gradient)
        if augmentations is not None:
            pulumi.set(__self__, "augmentations", augmentations)
        if beta1 is not None:
            pulumi.set(__self__, "beta1", beta1)
        if beta2 is not None:
            pulumi.set(__self__, "beta2", beta2)
        if checkpoint_frequency is not None:
            pulumi.set(__self__, "checkpoint_frequency", checkpoint_frequency)
        if checkpoint_model is not None:
            pulumi.set(__self__, "checkpoint_model", checkpoint_model)
        if checkpoint_run_id is not None:
            pulumi.set(__self__, "checkpoint_run_id", checkpoint_run_id)
        if distributed is not None:
            pulumi.set(__self__, "distributed", distributed)
        if early_stopping is not None:
            pulumi.set(__self__, "early_stopping", early_stopping)
        if early_stopping_delay is not None:
            pulumi.set(__self__, "early_stopping_delay", early_stopping_delay)
        if early_stopping_patience is not None:
            pulumi.set(__self__, "early_stopping_patience", early_stopping_patience)
        if enable_onnx_normalization is not None:
            pulumi.set(__self__, "enable_onnx_normalization", enable_onnx_normalization)
        if evaluation_frequency is not None:
            pulumi.set(__self__, "evaluation_frequency", evaluation_frequency)
        if gradient_accumulation_step is not None:
            pulumi.set(__self__, "gradient_accumulation_step", gradient_accumulation_step)
        if layers_to_freeze is not None:
            pulumi.set(__self__, "layers_to_freeze", layers_to_freeze)
        if learning_rate is not None:
            pulumi.set(__self__, "learning_rate", learning_rate)
        if learning_rate_scheduler is None:
            learning_rate_scheduler = 'None'
        if learning_rate_scheduler is not None:
            pulumi.set(__self__, "learning_rate_scheduler", learning_rate_scheduler)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)
        if momentum is not None:
            pulumi.set(__self__, "momentum", momentum)
        if nesterov is not None:
            pulumi.set(__self__, "nesterov", nesterov)
        if number_of_epochs is not None:
            pulumi.set(__self__, "number_of_epochs", number_of_epochs)
        if number_of_workers is not None:
            pulumi.set(__self__, "number_of_workers", number_of_workers)
        if optimizer is None:
            optimizer = 'None'
        if optimizer is not None:
            pulumi.set(__self__, "optimizer", optimizer)
        if random_seed is not None:
            pulumi.set(__self__, "random_seed", random_seed)
        if step_lr_gamma is not None:
            pulumi.set(__self__, "step_lr_gamma", step_lr_gamma)
        if step_lr_step_size is not None:
            pulumi.set(__self__, "step_lr_step_size", step_lr_step_size)
        if training_batch_size is not None:
            pulumi.set(__self__, "training_batch_size", training_batch_size)
        if training_crop_size is not None:
            pulumi.set(__self__, "training_crop_size", training_crop_size)
        if validation_batch_size is not None:
            pulumi.set(__self__, "validation_batch_size", validation_batch_size)
        if validation_crop_size is not None:
            pulumi.set(__self__, "validation_crop_size", validation_crop_size)
        if validation_resize_size is not None:
            pulumi.set(__self__, "validation_resize_size", validation_resize_size)
        if warmup_cosine_lr_cycles is not None:
            pulumi.set(__self__, "warmup_cosine_lr_cycles", warmup_cosine_lr_cycles)
        if warmup_cosine_lr_warmup_epochs is not None:
            pulumi.set(__self__, "warmup_cosine_lr_warmup_epochs", warmup_cosine_lr_warmup_epochs)
        if weight_decay is not None:
            pulumi.set(__self__, "weight_decay", weight_decay)
        if weighted_loss is not None:
            pulumi.set(__self__, "weighted_loss", weighted_loss)

    @property
    @pulumi.getter(name="advancedSettings")
    def advanced_settings(self) -> Optional[builtins.str]:
        """
        Settings for advanced scenarios.
        """
        return pulumi.get(self, "advanced_settings")

    @property
    @pulumi.getter(name="amsGradient")
    def ams_gradient(self) -> Optional[builtins.bool]:
        """
        Enable AMSGrad when optimizer is 'adam' or 'adamw'.
        """
        return pulumi.get(self, "ams_gradient")

    @property
    @pulumi.getter
    def augmentations(self) -> Optional[builtins.str]:
        """
        Settings for using Augmentations.
        """
        return pulumi.get(self, "augmentations")

    @property
    @pulumi.getter
    def beta1(self) -> Optional[builtins.float]:
        """
        Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "beta1")

    @property
    @pulumi.getter
    def beta2(self) -> Optional[builtins.float]:
        """
        Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "beta2")

    @property
    @pulumi.getter(name="checkpointFrequency")
    def checkpoint_frequency(self) -> Optional[builtins.int]:
        """
        Frequency to store model checkpoints. Must be a positive integer.
        """
        return pulumi.get(self, "checkpoint_frequency")

    @property
    @pulumi.getter(name="checkpointModel")
    def checkpoint_model(self) -> Optional['outputs.MLFlowModelJobInputResponse']:
        """
        The pretrained checkpoint model for incremental training.
        """
        return pulumi.get(self, "checkpoint_model")

    @property
    @pulumi.getter(name="checkpointRunId")
    def checkpoint_run_id(self) -> Optional[builtins.str]:
        """
        The id of a previous run that has a pretrained checkpoint for incremental training.
        """
        return pulumi.get(self, "checkpoint_run_id")

    @property
    @pulumi.getter
    def distributed(self) -> Optional[builtins.bool]:
        """
        Whether to use distributed training.
        """
        return pulumi.get(self, "distributed")

    @property
    @pulumi.getter(name="earlyStopping")
    def early_stopping(self) -> Optional[builtins.bool]:
        """
        Enable early stopping logic during training.
        """
        return pulumi.get(self, "early_stopping")

    @property
    @pulumi.getter(name="earlyStoppingDelay")
    def early_stopping_delay(self) -> Optional[builtins.int]:
        """
        Minimum number of epochs or validation evaluations to wait before primary metric improvement
        is tracked for early stopping. Must be a positive integer.
        """
        return pulumi.get(self, "early_stopping_delay")

    @property
    @pulumi.getter(name="earlyStoppingPatience")
    def early_stopping_patience(self) -> Optional[builtins.int]:
        """
        Minimum number of epochs or validation evaluations with no primary metric improvement before
        the run is stopped. Must be a positive integer.
        """
        return pulumi.get(self, "early_stopping_patience")

    @property
    @pulumi.getter(name="enableOnnxNormalization")
    def enable_onnx_normalization(self) -> Optional[builtins.bool]:
        """
        Enable normalization when exporting ONNX model.
        """
        return pulumi.get(self, "enable_onnx_normalization")

    @property
    @pulumi.getter(name="evaluationFrequency")
    def evaluation_frequency(self) -> Optional[builtins.int]:
        """
        Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
        """
        return pulumi.get(self, "evaluation_frequency")

    @property
    @pulumi.getter(name="gradientAccumulationStep")
    def gradient_accumulation_step(self) -> Optional[builtins.int]:
        """
        Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
        updating the model weights while accumulating the gradients of those steps, and then using
        the accumulated gradients to compute the weight updates. Must be a positive integer.
        """
        return pulumi.get(self, "gradient_accumulation_step")

    @property
    @pulumi.getter(name="layersToFreeze")
    def layers_to_freeze(self) -> Optional[builtins.int]:
        """
        Number of layers to freeze for the model. Must be a positive integer.
        For instance, passing 2 as value for 'seresnext' means
        freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
        see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        """
        return pulumi.get(self, "layers_to_freeze")

    @property
    @pulumi.getter(name="learningRate")
    def learning_rate(self) -> Optional[builtins.float]:
        """
        Initial learning rate. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "learning_rate")

    @property
    @pulumi.getter(name="learningRateScheduler")
    def learning_rate_scheduler(self) -> Optional[builtins.str]:
        """
        Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
        """
        return pulumi.get(self, "learning_rate_scheduler")

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[builtins.str]:
        """
        Name of the model to use for training.
        For more information on the available models please visit the official documentation:
        https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        """
        return pulumi.get(self, "model_name")

    @property
    @pulumi.getter
    def momentum(self) -> Optional[builtins.float]:
        """
        Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "momentum")

    @property
    @pulumi.getter
    def nesterov(self) -> Optional[builtins.bool]:
        """
        Enable nesterov when optimizer is 'sgd'.
        """
        return pulumi.get(self, "nesterov")

    @property
    @pulumi.getter(name="numberOfEpochs")
    def number_of_epochs(self) -> Optional[builtins.int]:
        """
        Number of training epochs. Must be a positive integer.
        """
        return pulumi.get(self, "number_of_epochs")

    @property
    @pulumi.getter(name="numberOfWorkers")
    def number_of_workers(self) -> Optional[builtins.int]:
        """
        Number of data loader workers. Must be a non-negative integer.
        """
        return pulumi.get(self, "number_of_workers")

    @property
    @pulumi.getter
    def optimizer(self) -> Optional[builtins.str]:
        """
        Type of optimizer.
        """
        return pulumi.get(self, "optimizer")

    @property
    @pulumi.getter(name="randomSeed")
    def random_seed(self) -> Optional[builtins.int]:
        """
        Random seed to be used when using deterministic training.
        """
        return pulumi.get(self, "random_seed")

    @property
    @pulumi.getter(name="stepLRGamma")
    def step_lr_gamma(self) -> Optional[builtins.float]:
        """
        Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "step_lr_gamma")

    @property
    @pulumi.getter(name="stepLRStepSize")
    def step_lr_step_size(self) -> Optional[builtins.int]:
        """
        Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
        """
        return pulumi.get(self, "step_lr_step_size")

    @property
    @pulumi.getter(name="trainingBatchSize")
    def training_batch_size(self) -> Optional[builtins.int]:
        """
        Training batch size. Must be a positive integer.
        """
        return pulumi.get(self, "training_batch_size")

    @property
    @pulumi.getter(name="trainingCropSize")
    def training_crop_size(self) -> Optional[builtins.int]:
        """
        Image crop size that is input to the neural network for the training dataset. Must be a positive integer.
        """
        return pulumi.get(self, "training_crop_size")

    @property
    @pulumi.getter(name="validationBatchSize")
    def validation_batch_size(self) -> Optional[builtins.int]:
        """
        Validation batch size. Must be a positive integer.
        """
        return pulumi.get(self, "validation_batch_size")

    @property
    @pulumi.getter(name="validationCropSize")
    def validation_crop_size(self) -> Optional[builtins.int]:
        """
        Image crop size that is input to the neural network for the validation dataset. Must be a positive integer.
        """
        return pulumi.get(self, "validation_crop_size")

    @property
    @pulumi.getter(name="validationResizeSize")
    def validation_resize_size(self) -> Optional[builtins.int]:
        """
        Image size to which to resize before cropping for validation dataset. Must be a positive integer.
        """
        return pulumi.get(self, "validation_resize_size")

    @property
    @pulumi.getter(name="warmupCosineLRCycles")
    def warmup_cosine_lr_cycles(self) -> Optional[builtins.float]:
        """
        Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "warmup_cosine_lr_cycles")

    @property
    @pulumi.getter(name="warmupCosineLRWarmupEpochs")
    def warmup_cosine_lr_warmup_epochs(self) -> Optional[builtins.int]:
        """
        Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
        """
        return pulumi.get(self, "warmup_cosine_lr_warmup_epochs")

    @property
    @pulumi.getter(name="weightDecay")
    def weight_decay(self) -> Optional[builtins.float]:
        """
        Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
        """
        return pulumi.get(self, "weight_decay")

    @property
    @pulumi.getter(name="weightedLoss")
    def weighted_loss(self) -> Optional[builtins.int]:
        """
        Weighted loss. The accepted values are 0 for no weighted loss.
        1 for weighted loss with sqrt.(class_weights). 2 for weighted loss with class_weights. Must be 0 or 1 or 2.
        """
        return pulumi.get(self, "weighted_loss")


@pulumi.output_type
class ImageModelSettingsObjectDetectionResponse(dict):
    """
    Settings used for training the model.
    For more information on the available settings please visit the official documentation:
    https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advancedSettings":
            suggest = "advanced_settings"
        elif key == "amsGradient":
            suggest = "ams_gradient"
        elif key == "boxDetectionsPerImage":
            suggest = "box_detections_per_image"
        elif key == "boxScoreThreshold":
            suggest = "box_score_threshold"
        elif key == "checkpointFrequency":
            suggest = "checkpoint_frequency"
        elif key == "checkpointModel":
            suggest = "checkpoint_model"
        elif key == "checkpointRunId":
            suggest = "checkpoint_run_id"
        elif key == "earlyStopping":
            suggest = "early_stopping"
        elif key == "earlyStoppingDelay":
            suggest = "early_stopping_delay"
        elif key == "earlyStoppingPatience":
            suggest = "early_stopping_patience"
        elif key == "enableOnnxNormalization":
            suggest = "enable_onnx_normalization"
        elif key == "evaluationFrequency":
            suggest = "evaluation_frequency"
        elif key == "gradientAccumulationStep":
            suggest = "gradient_accumulation_step"
        elif key == "imageSize":
            suggest = "image_size"
        elif key == "layersToFreeze":
            suggest = "layers_to_freeze"
        elif key == "learningRate":
            suggest = "learning_rate"
        elif key == "learningRateScheduler":
            suggest = "learning_rate_scheduler"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "modelName":
            suggest = "model_name"
        elif key == "modelSize":
            suggest = "model_size"
        elif key == "multiScale":
            suggest = "multi_scale"
        elif key == "nmsIouThreshold":
            suggest = "nms_iou_threshold"
        elif key == "numberOfEpochs":
            suggest = "number_of_epochs"
        elif key == "numberOfWorkers":
            suggest = "number_of_workers"
        elif key == "randomSeed":
            suggest = "random_seed"
        elif key == "stepLRGamma":
            suggest = "step_lr_gamma"
        elif key == "stepLRStepSize":
            suggest = "step_lr_step_size"
        elif key == "tileGridSize":
            suggest = "tile_grid_size"
        elif key == "tileOverlapRatio":
            suggest = "tile_overlap_ratio"
        elif key == "tilePredictionsNmsThreshold":
            suggest = "tile_predictions_nms_threshold"
        elif key == "trainingBatchSize":
            suggest = "training_batch_size"
        elif key == "validationBatchSize":
            suggest = "validation_batch_size"
        elif key == "validationIouThreshold":
            suggest = "validation_iou_threshold"
        elif key == "validationMetricType":
            suggest = "validation_metric_type"
        elif key == "warmupCosineLRCycles":
            suggest = "warmup_cosine_lr_cycles"
        elif key == "warmupCosineLRWarmupEpochs":
            suggest = "warmup_cosine_lr_warmup_epochs"
        elif key == "weightDecay":
            suggest = "weight_decay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageModelSettingsObjectDetectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageModelSettingsObjectDetectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageModelSettingsObjectDetectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advanced_settings: Optional[builtins.str] = None,
                 ams_gradient: Optional[builtins.bool] = None,
                 augmentations: Optional[builtins.str] = None,
                 beta1: Optional[builtins.float] = None,
                 beta2: Optional[builtins.float] = None,
                 box_detections_per_image: Optional[builtins.int] = None,
                 box_score_threshold: Optional[builtins.float] = None,
                 checkpoint_frequency: Optional[builtins.int] = None,
                 checkpoint_model: Optional['outputs.MLFlowModelJobInputResponse'] = None,
                 checkpoint_run_id: Optional[builtins.str] = None,
                 distributed: Optional[builtins.bool] = None,
                 early_stopping: Optional[builtins.bool] = None,
                 early_stopping_delay: Optional[builtins.int] = None,
                 early_stopping_patience: Optional[builtins.int] = None,
                 enable_onnx_normalization: Optional[builtins.bool] = None,
                 evaluation_frequency: Optional[builtins.int] = None,
                 gradient_accumulation_step: Optional[builtins.int] = None,
                 image_size: Optional[builtins.int] = None,
                 layers_to_freeze: Optional[builtins.int] = None,
                 learning_rate: Optional[builtins.float] = None,
                 learning_rate_scheduler: Optional[builtins.str] = None,
                 max_size: Optional[builtins.int] = None,
                 min_size: Optional[builtins.int] = None,
                 model_name: Optional[builtins.str] = None,
                 model_size: Optional[builtins.str] = None,
                 momentum: Optional[builtins.float] = None,
                 multi_scale: Optional[builtins.bool] = None,
                 nesterov: Optional[builtins.bool] = None,
                 nms_iou_threshold: Optional[builtins.float] = None,
                 number_of_epochs: Optional[builtins.int] = None,
                 number_of_workers: Optional[builtins.int] = None,
                 optimizer: Optional[builtins.str] = None,
                 random_seed: Optional[builtins.int] = None,
                 step_lr_gamma: Optional[builtins.float] = None,
                 step_lr_step_size: Optional[builtins.int] = None,
                 tile_grid_size: Optional[builtins.str] = None,
                 tile_overlap_ratio: Optional[builtins.float] = None,
                 tile_predictions_nms_threshold: Optional[builtins.float] = None,
                 training_batch_size: Optional[builtins.int] = None,
                 validation_batch_size: Optional[builtins.int] = None,
                 validation_iou_threshold: Optional[builtins.float] = None,
                 validation_metric_type: Optional[builtins.str] = None,
                 warmup_cosine_lr_cycles: Optional[builtins.float] = None,
                 warmup_cosine_lr_warmup_epochs: Optional[builtins.int] = None,
                 weight_decay: Optional[builtins.float] = None):
        """
        Settings used for training the model.
        For more information on the available settings please visit the official documentation:
        https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param builtins.str advanced_settings: Settings for advanced scenarios.
        :param builtins.bool ams_gradient: Enable AMSGrad when optimizer is 'adam' or 'adamw'.
        :param builtins.str augmentations: Settings for using Augmentations.
        :param builtins.float beta1: Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        :param builtins.float beta2: Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        :param builtins.int box_detections_per_image: Maximum number of detections per image, for all classes. Must be a positive integer.
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param builtins.float box_score_threshold: During inference, only return proposals with a classification score greater than
               BoxScoreThreshold. Must be a float in the range[0, 1].
        :param builtins.int checkpoint_frequency: Frequency to store model checkpoints. Must be a positive integer.
        :param 'MLFlowModelJobInputResponse' checkpoint_model: The pretrained checkpoint model for incremental training.
        :param builtins.str checkpoint_run_id: The id of a previous run that has a pretrained checkpoint for incremental training.
        :param builtins.bool distributed: Whether to use distributed training.
        :param builtins.bool early_stopping: Enable early stopping logic during training.
        :param builtins.int early_stopping_delay: Minimum number of epochs or validation evaluations to wait before primary metric improvement
               is tracked for early stopping. Must be a positive integer.
        :param builtins.int early_stopping_patience: Minimum number of epochs or validation evaluations with no primary metric improvement before
               the run is stopped. Must be a positive integer.
        :param builtins.bool enable_onnx_normalization: Enable normalization when exporting ONNX model.
        :param builtins.int evaluation_frequency: Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
        :param builtins.int gradient_accumulation_step: Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
               updating the model weights while accumulating the gradients of those steps, and then using
               the accumulated gradients to compute the weight updates. Must be a positive integer.
        :param builtins.int image_size: Image size for train and validation. Must be a positive integer.
               Note: The training run may get into CUDA OOM if the size is too big.
               Note: This settings is only supported for the 'yolov5' algorithm.
        :param builtins.int layers_to_freeze: Number of layers to freeze for the model. Must be a positive integer.
               For instance, passing 2 as value for 'seresnext' means
               freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
               see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param builtins.float learning_rate: Initial learning rate. Must be a float in the range [0, 1].
        :param builtins.str learning_rate_scheduler: Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
        :param builtins.int max_size: Maximum size of the image to be rescaled before feeding it to the backbone.
               Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param builtins.int min_size: Minimum size of the image to be rescaled before feeding it to the backbone.
               Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param builtins.str model_name: Name of the model to use for training.
               For more information on the available models please visit the official documentation:
               https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        :param builtins.str model_size: Model size. Must be 'small', 'medium', 'large', or 'xlarge'.
               Note: training run may get into CUDA OOM if the model size is too big.
               Note: This settings is only supported for the 'yolov5' algorithm.
        :param builtins.float momentum: Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
        :param builtins.bool multi_scale: Enable multi-scale image by varying image size by +/- 50%.
               Note: training run may get into CUDA OOM if no sufficient GPU memory.
               Note: This settings is only supported for the 'yolov5' algorithm.
        :param builtins.bool nesterov: Enable nesterov when optimizer is 'sgd'.
        :param builtins.float nms_iou_threshold: IOU threshold used during inference in NMS post processing. Must be a float in the range [0, 1].
        :param builtins.int number_of_epochs: Number of training epochs. Must be a positive integer.
        :param builtins.int number_of_workers: Number of data loader workers. Must be a non-negative integer.
        :param builtins.str optimizer: Type of optimizer.
        :param builtins.int random_seed: Random seed to be used when using deterministic training.
        :param builtins.float step_lr_gamma: Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
        :param builtins.int step_lr_step_size: Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
        :param builtins.str tile_grid_size: The grid size to use for tiling each image. Note: TileGridSize must not be
               None to enable small object detection logic. A string containing two integers in mxn format.
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param builtins.float tile_overlap_ratio: Overlap ratio between adjacent tiles in each dimension. Must be float in the range [0, 1).
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param builtins.float tile_predictions_nms_threshold: The IOU threshold to use to perform NMS while merging predictions from tiles and image.
               Used in validation/ inference. Must be float in the range [0, 1].
               Note: This settings is not supported for the 'yolov5' algorithm.
        :param builtins.int training_batch_size: Training batch size. Must be a positive integer.
        :param builtins.int validation_batch_size: Validation batch size. Must be a positive integer.
        :param builtins.float validation_iou_threshold: IOU threshold to use when computing validation metric. Must be float in the range [0, 1].
        :param builtins.str validation_metric_type: Metric computation method to use for validation metrics.
        :param builtins.float warmup_cosine_lr_cycles: Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
        :param builtins.int warmup_cosine_lr_warmup_epochs: Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
        :param builtins.float weight_decay: Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
        """
        if advanced_settings is not None:
            pulumi.set(__self__, "advanced_settings", advanced_settings)
        if ams_gradient is not None:
            pulumi.set(__self__, "ams_gradient", ams_gradient)
        if augmentations is not None:
            pulumi.set(__self__, "augmentations", augmentations)
        if beta1 is not None:
            pulumi.set(__self__, "beta1", beta1)
        if beta2 is not None:
            pulumi.set(__self__, "beta2", beta2)
        if box_detections_per_image is not None:
            pulumi.set(__self__, "box_detections_per_image", box_detections_per_image)
        if box_score_threshold is not None:
            pulumi.set(__self__, "box_score_threshold", box_score_threshold)
        if checkpoint_frequency is not None:
            pulumi.set(__self__, "checkpoint_frequency", checkpoint_frequency)
        if checkpoint_model is not None:
            pulumi.set(__self__, "checkpoint_model", checkpoint_model)
        if checkpoint_run_id is not None:
            pulumi.set(__self__, "checkpoint_run_id", checkpoint_run_id)
        if distributed is not None:
            pulumi.set(__self__, "distributed", distributed)
        if early_stopping is not None:
            pulumi.set(__self__, "early_stopping", early_stopping)
        if early_stopping_delay is not None:
            pulumi.set(__self__, "early_stopping_delay", early_stopping_delay)
        if early_stopping_patience is not None:
            pulumi.set(__self__, "early_stopping_patience", early_stopping_patience)
        if enable_onnx_normalization is not None:
            pulumi.set(__self__, "enable_onnx_normalization", enable_onnx_normalization)
        if evaluation_frequency is not None:
            pulumi.set(__self__, "evaluation_frequency", evaluation_frequency)
        if gradient_accumulation_step is not None:
            pulumi.set(__self__, "gradient_accumulation_step", gradient_accumulation_step)
        if image_size is not None:
            pulumi.set(__self__, "image_size", image_size)
        if layers_to_freeze is not None:
            pulumi.set(__self__, "layers_to_freeze", layers_to_freeze)
        if learning_rate is not None:
            pulumi.set(__self__, "learning_rate", learning_rate)
        if learning_rate_scheduler is None:
            learning_rate_scheduler = 'None'
        if learning_rate_scheduler is not None:
            pulumi.set(__self__, "learning_rate_scheduler", learning_rate_scheduler)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)
        if model_size is None:
            model_size = 'None'
        if model_size is not None:
            pulumi.set(__self__, "model_size", model_size)
        if momentum is not None:
            pulumi.set(__self__, "momentum", momentum)
        if multi_scale is not None:
            pulumi.set(__self__, "multi_scale", multi_scale)
        if nesterov is not None:
            pulumi.set(__self__, "nesterov", nesterov)
        if nms_iou_threshold is not None:
            pulumi.set(__self__, "nms_iou_threshold", nms_iou_threshold)
        if number_of_epochs is not None:
            pulumi.set(__self__, "number_of_epochs", number_of_epochs)
        if number_of_workers is not None:
            pulumi.set(__self__, "number_of_workers", number_of_workers)
        if optimizer is None:
            optimizer = 'None'
        if optimizer is not None:
            pulumi.set(__self__, "optimizer", optimizer)
        if random_seed is not None:
            pulumi.set(__self__, "random_seed", random_seed)
        if step_lr_gamma is not None:
            pulumi.set(__self__, "step_lr_gamma", step_lr_gamma)
        if step_lr_step_size is not None:
            pulumi.set(__self__, "step_lr_step_size", step_lr_step_size)
        if tile_grid_size is not None:
            pulumi.set(__self__, "tile_grid_size", tile_grid_size)
        if tile_overlap_ratio is not None:
            pulumi.set(__self__, "tile_overlap_ratio", tile_overlap_ratio)
        if tile_predictions_nms_threshold is not None:
            pulumi.set(__self__, "tile_predictions_nms_threshold", tile_predictions_nms_threshold)
        if training_batch_size is not None:
            pulumi.set(__self__, "training_batch_size", training_batch_size)
        if validation_batch_size is not None:
            pulumi.set(__self__, "validation_batch_size", validation_batch_size)
        if validation_iou_threshold is not None:
            pulumi.set(__self__, "validation_iou_threshold", validation_iou_threshold)
        if validation_metric_type is None:
            validation_metric_type = 'None'
        if validation_metric_type is not None:
            pulumi.set(__self__, "validation_metric_type", validation_metric_type)
        if warmup_cosine_lr_cycles is not None:
            pulumi.set(__self__, "warmup_cosine_lr_cycles", warmup_cosine_lr_cycles)
        if warmup_cosine_lr_warmup_epochs is not None:
            pulumi.set(__self__, "warmup_cosine_lr_warmup_epochs", warmup_cosine_lr_warmup_epochs)
        if weight_decay is not None:
            pulumi.set(__self__, "weight_decay", weight_decay)

    @property
    @pulumi.getter(name="advancedSettings")
    def advanced_settings(self) -> Optional[builtins.str]:
        """
        Settings for advanced scenarios.
        """
        return pulumi.get(self, "advanced_settings")

    @property
    @pulumi.getter(name="amsGradient")
    def ams_gradient(self) -> Optional[builtins.bool]:
        """
        Enable AMSGrad when optimizer is 'adam' or 'adamw'.
        """
        return pulumi.get(self, "ams_gradient")

    @property
    @pulumi.getter
    def augmentations(self) -> Optional[builtins.str]:
        """
        Settings for using Augmentations.
        """
        return pulumi.get(self, "augmentations")

    @property
    @pulumi.getter
    def beta1(self) -> Optional[builtins.float]:
        """
        Value of 'beta1' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "beta1")

    @property
    @pulumi.getter
    def beta2(self) -> Optional[builtins.float]:
        """
        Value of 'beta2' when optimizer is 'adam' or 'adamw'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "beta2")

    @property
    @pulumi.getter(name="boxDetectionsPerImage")
    def box_detections_per_image(self) -> Optional[builtins.int]:
        """
        Maximum number of detections per image, for all classes. Must be a positive integer.
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "box_detections_per_image")

    @property
    @pulumi.getter(name="boxScoreThreshold")
    def box_score_threshold(self) -> Optional[builtins.float]:
        """
        During inference, only return proposals with a classification score greater than
        BoxScoreThreshold. Must be a float in the range[0, 1].
        """
        return pulumi.get(self, "box_score_threshold")

    @property
    @pulumi.getter(name="checkpointFrequency")
    def checkpoint_frequency(self) -> Optional[builtins.int]:
        """
        Frequency to store model checkpoints. Must be a positive integer.
        """
        return pulumi.get(self, "checkpoint_frequency")

    @property
    @pulumi.getter(name="checkpointModel")
    def checkpoint_model(self) -> Optional['outputs.MLFlowModelJobInputResponse']:
        """
        The pretrained checkpoint model for incremental training.
        """
        return pulumi.get(self, "checkpoint_model")

    @property
    @pulumi.getter(name="checkpointRunId")
    def checkpoint_run_id(self) -> Optional[builtins.str]:
        """
        The id of a previous run that has a pretrained checkpoint for incremental training.
        """
        return pulumi.get(self, "checkpoint_run_id")

    @property
    @pulumi.getter
    def distributed(self) -> Optional[builtins.bool]:
        """
        Whether to use distributed training.
        """
        return pulumi.get(self, "distributed")

    @property
    @pulumi.getter(name="earlyStopping")
    def early_stopping(self) -> Optional[builtins.bool]:
        """
        Enable early stopping logic during training.
        """
        return pulumi.get(self, "early_stopping")

    @property
    @pulumi.getter(name="earlyStoppingDelay")
    def early_stopping_delay(self) -> Optional[builtins.int]:
        """
        Minimum number of epochs or validation evaluations to wait before primary metric improvement
        is tracked for early stopping. Must be a positive integer.
        """
        return pulumi.get(self, "early_stopping_delay")

    @property
    @pulumi.getter(name="earlyStoppingPatience")
    def early_stopping_patience(self) -> Optional[builtins.int]:
        """
        Minimum number of epochs or validation evaluations with no primary metric improvement before
        the run is stopped. Must be a positive integer.
        """
        return pulumi.get(self, "early_stopping_patience")

    @property
    @pulumi.getter(name="enableOnnxNormalization")
    def enable_onnx_normalization(self) -> Optional[builtins.bool]:
        """
        Enable normalization when exporting ONNX model.
        """
        return pulumi.get(self, "enable_onnx_normalization")

    @property
    @pulumi.getter(name="evaluationFrequency")
    def evaluation_frequency(self) -> Optional[builtins.int]:
        """
        Frequency to evaluate validation dataset to get metric scores. Must be a positive integer.
        """
        return pulumi.get(self, "evaluation_frequency")

    @property
    @pulumi.getter(name="gradientAccumulationStep")
    def gradient_accumulation_step(self) -> Optional[builtins.int]:
        """
        Gradient accumulation means running a configured number of "GradAccumulationStep" steps without
        updating the model weights while accumulating the gradients of those steps, and then using
        the accumulated gradients to compute the weight updates. Must be a positive integer.
        """
        return pulumi.get(self, "gradient_accumulation_step")

    @property
    @pulumi.getter(name="imageSize")
    def image_size(self) -> Optional[builtins.int]:
        """
        Image size for train and validation. Must be a positive integer.
        Note: The training run may get into CUDA OOM if the size is too big.
        Note: This settings is only supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "image_size")

    @property
    @pulumi.getter(name="layersToFreeze")
    def layers_to_freeze(self) -> Optional[builtins.int]:
        """
        Number of layers to freeze for the model. Must be a positive integer.
        For instance, passing 2 as value for 'seresnext' means
        freezing layer0 and layer1. For a full list of models supported and details on layer freeze, please
        see: https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        """
        return pulumi.get(self, "layers_to_freeze")

    @property
    @pulumi.getter(name="learningRate")
    def learning_rate(self) -> Optional[builtins.float]:
        """
        Initial learning rate. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "learning_rate")

    @property
    @pulumi.getter(name="learningRateScheduler")
    def learning_rate_scheduler(self) -> Optional[builtins.str]:
        """
        Type of learning rate scheduler. Must be 'warmup_cosine' or 'step'.
        """
        return pulumi.get(self, "learning_rate_scheduler")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[builtins.int]:
        """
        Maximum size of the image to be rescaled before feeding it to the backbone.
        Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[builtins.int]:
        """
        Minimum size of the image to be rescaled before feeding it to the backbone.
        Must be a positive integer. Note: training run may get into CUDA OOM if the size is too big.
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[builtins.str]:
        """
        Name of the model to use for training.
        For more information on the available models please visit the official documentation:
        https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-image-models.
        """
        return pulumi.get(self, "model_name")

    @property
    @pulumi.getter(name="modelSize")
    def model_size(self) -> Optional[builtins.str]:
        """
        Model size. Must be 'small', 'medium', 'large', or 'xlarge'.
        Note: training run may get into CUDA OOM if the model size is too big.
        Note: This settings is only supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "model_size")

    @property
    @pulumi.getter
    def momentum(self) -> Optional[builtins.float]:
        """
        Value of momentum when optimizer is 'sgd'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "momentum")

    @property
    @pulumi.getter(name="multiScale")
    def multi_scale(self) -> Optional[builtins.bool]:
        """
        Enable multi-scale image by varying image size by +/- 50%.
        Note: training run may get into CUDA OOM if no sufficient GPU memory.
        Note: This settings is only supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "multi_scale")

    @property
    @pulumi.getter
    def nesterov(self) -> Optional[builtins.bool]:
        """
        Enable nesterov when optimizer is 'sgd'.
        """
        return pulumi.get(self, "nesterov")

    @property
    @pulumi.getter(name="nmsIouThreshold")
    def nms_iou_threshold(self) -> Optional[builtins.float]:
        """
        IOU threshold used during inference in NMS post processing. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "nms_iou_threshold")

    @property
    @pulumi.getter(name="numberOfEpochs")
    def number_of_epochs(self) -> Optional[builtins.int]:
        """
        Number of training epochs. Must be a positive integer.
        """
        return pulumi.get(self, "number_of_epochs")

    @property
    @pulumi.getter(name="numberOfWorkers")
    def number_of_workers(self) -> Optional[builtins.int]:
        """
        Number of data loader workers. Must be a non-negative integer.
        """
        return pulumi.get(self, "number_of_workers")

    @property
    @pulumi.getter
    def optimizer(self) -> Optional[builtins.str]:
        """
        Type of optimizer.
        """
        return pulumi.get(self, "optimizer")

    @property
    @pulumi.getter(name="randomSeed")
    def random_seed(self) -> Optional[builtins.int]:
        """
        Random seed to be used when using deterministic training.
        """
        return pulumi.get(self, "random_seed")

    @property
    @pulumi.getter(name="stepLRGamma")
    def step_lr_gamma(self) -> Optional[builtins.float]:
        """
        Value of gamma when learning rate scheduler is 'step'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "step_lr_gamma")

    @property
    @pulumi.getter(name="stepLRStepSize")
    def step_lr_step_size(self) -> Optional[builtins.int]:
        """
        Value of step size when learning rate scheduler is 'step'. Must be a positive integer.
        """
        return pulumi.get(self, "step_lr_step_size")

    @property
    @pulumi.getter(name="tileGridSize")
    def tile_grid_size(self) -> Optional[builtins.str]:
        """
        The grid size to use for tiling each image. Note: TileGridSize must not be
        None to enable small object detection logic. A string containing two integers in mxn format.
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "tile_grid_size")

    @property
    @pulumi.getter(name="tileOverlapRatio")
    def tile_overlap_ratio(self) -> Optional[builtins.float]:
        """
        Overlap ratio between adjacent tiles in each dimension. Must be float in the range [0, 1).
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "tile_overlap_ratio")

    @property
    @pulumi.getter(name="tilePredictionsNmsThreshold")
    def tile_predictions_nms_threshold(self) -> Optional[builtins.float]:
        """
        The IOU threshold to use to perform NMS while merging predictions from tiles and image.
        Used in validation/ inference. Must be float in the range [0, 1].
        Note: This settings is not supported for the 'yolov5' algorithm.
        """
        return pulumi.get(self, "tile_predictions_nms_threshold")

    @property
    @pulumi.getter(name="trainingBatchSize")
    def training_batch_size(self) -> Optional[builtins.int]:
        """
        Training batch size. Must be a positive integer.
        """
        return pulumi.get(self, "training_batch_size")

    @property
    @pulumi.getter(name="validationBatchSize")
    def validation_batch_size(self) -> Optional[builtins.int]:
        """
        Validation batch size. Must be a positive integer.
        """
        return pulumi.get(self, "validation_batch_size")

    @property
    @pulumi.getter(name="validationIouThreshold")
    def validation_iou_threshold(self) -> Optional[builtins.float]:
        """
        IOU threshold to use when computing validation metric. Must be float in the range [0, 1].
        """
        return pulumi.get(self, "validation_iou_threshold")

    @property
    @pulumi.getter(name="validationMetricType")
    def validation_metric_type(self) -> Optional[builtins.str]:
        """
        Metric computation method to use for validation metrics.
        """
        return pulumi.get(self, "validation_metric_type")

    @property
    @pulumi.getter(name="warmupCosineLRCycles")
    def warmup_cosine_lr_cycles(self) -> Optional[builtins.float]:
        """
        Value of cosine cycle when learning rate scheduler is 'warmup_cosine'. Must be a float in the range [0, 1].
        """
        return pulumi.get(self, "warmup_cosine_lr_cycles")

    @property
    @pulumi.getter(name="warmupCosineLRWarmupEpochs")
    def warmup_cosine_lr_warmup_epochs(self) -> Optional[builtins.int]:
        """
        Value of warmup epochs when learning rate scheduler is 'warmup_cosine'. Must be a positive integer.
        """
        return pulumi.get(self, "warmup_cosine_lr_warmup_epochs")

    @property
    @pulumi.getter(name="weightDecay")
    def weight_decay(self) -> Optional[builtins.float]:
        """
        Value of weight decay when optimizer is 'sgd', 'adam', or 'adamw'. Must be a float in the range[0, 1].
        """
        return pulumi.get(self, "weight_decay")


@pulumi.output_type
class ImageObjectDetectionResponse(dict):
    """
    Image Object Detection. Object detection is used to identify objects in an image and locate each object with a
    bounding box e.g. locate all dogs and cats in an image and draw a bounding box around each.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitSettings":
            suggest = "limit_settings"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "trainingData":
            suggest = "training_data"
        elif key == "logVerbosity":
            suggest = "log_verbosity"
        elif key == "modelSettings":
            suggest = "model_settings"
        elif key == "primaryMetric":
            suggest = "primary_metric"
        elif key == "searchSpace":
            suggest = "search_space"
        elif key == "sweepSettings":
            suggest = "sweep_settings"
        elif key == "targetColumnName":
            suggest = "target_column_name"
        elif key == "validationData":
            suggest = "validation_data"
        elif key == "validationDataSize":
            suggest = "validation_data_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageObjectDetectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageObjectDetectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageObjectDetectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_settings: 'outputs.ImageLimitSettingsResponse',
                 task_type: builtins.str,
                 training_data: 'outputs.MLTableJobInputResponse',
                 log_verbosity: Optional[builtins.str] = None,
                 model_settings: Optional['outputs.ImageModelSettingsObjectDetectionResponse'] = None,
                 primary_metric: Optional[builtins.str] = None,
                 search_space: Optional[Sequence['outputs.ImageModelDistributionSettingsObjectDetectionResponse']] = None,
                 sweep_settings: Optional['outputs.ImageSweepSettingsResponse'] = None,
                 target_column_name: Optional[builtins.str] = None,
                 validation_data: Optional['outputs.MLTableJobInputResponse'] = None,
                 validation_data_size: Optional[builtins.float] = None):
        """
        Image Object Detection. Object detection is used to identify objects in an image and locate each object with a
        bounding box e.g. locate all dogs and cats in an image and draw a bounding box around each.
        :param 'ImageLimitSettingsResponse' limit_settings: [Required] Limit settings for the AutoML job.
        :param builtins.str task_type: AutoMLJob Task type.
               Expected value is 'ImageObjectDetection'.
        :param 'MLTableJobInputResponse' training_data: [Required] Training data input.
        :param builtins.str log_verbosity: Log verbosity for the job.
        :param 'ImageModelSettingsObjectDetectionResponse' model_settings: Settings used for training the model.
        :param builtins.str primary_metric: Primary metric to optimize for this task.
        :param Sequence['ImageModelDistributionSettingsObjectDetectionResponse'] search_space: Search space for sampling different combinations of models and their hyperparameters.
        :param 'ImageSweepSettingsResponse' sweep_settings: Model sweeping and hyperparameter sweeping related settings.
        :param builtins.str target_column_name: Target column name: This is prediction values column.
               Also known as label column name in context of classification tasks.
        :param 'MLTableJobInputResponse' validation_data: Validation data inputs.
        :param builtins.float validation_data_size: The fraction of training dataset that needs to be set aside for validation purpose.
               Values between (0.0 , 1.0)
               Applied when validation dataset is not provided.
        """
        pulumi.set(__self__, "limit_settings", limit_settings)
        pulumi.set(__self__, "task_type", 'ImageObjectDetection')
        pulumi.set(__self__, "training_data", training_data)
        if log_verbosity is None:
            log_verbosity = 'Info'
        if log_verbosity is not None:
            pulumi.set(__self__, "log_verbosity", log_verbosity)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)
        if primary_metric is None:
            primary_metric = 'MeanAveragePrecision'
        if primary_metric is not None:
            pulumi.set(__self__, "primary_metric", primary_metric)
        if search_space is not None:
            pulumi.set(__self__, "search_space", search_space)
        if sweep_settings is not None:
            pulumi.set(__self__, "sweep_settings", sweep_settings)
        if target_column_name is not None:
            pulumi.set(__self__, "target_column_name", target_column_name)
        if validation_data is not None:
            pulumi.set(__self__, "validation_data", validation_data)
        if validation_data_size is not None:
            pulumi.set(__self__, "validation_data_size", validation_data_size)

    @property
    @pulumi.getter(name="limitSettings")
    def limit_settings(self) -> 'outputs.ImageLimitSettingsResponse':
        """
        [Required] Limit settings for the AutoML job.
        """
        return pulumi.get(self, "limit_settings")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> builtins.str:
        """
        AutoMLJob Task type.
        Expected value is 'ImageObjectDetection'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="trainingData")
    def training_data(self) -> 'outputs.MLTableJobInputResponse':
        """
        [Required] Training data input.
        """
        return pulumi.get(self, "training_data")

    @property
    @pulumi.getter(name="logVerbosity")
    def log_verbosity(self) -> Optional[builtins.str]:
        """
        Log verbosity for the job.
        """
        return pulumi.get(self, "log_verbosity")

    @property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional['outputs.ImageModelSettingsObjectDetectionResponse']:
        """
        Settings used for training the model.
        """
        return pulumi.get(self, "model_settings")

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> Optional[builtins.str]:
        """
        Primary metric to optimize for this task.
        """
        return pulumi.get(self, "primary_metric")

    @property
    @pulumi.getter(name="searchSpace")
    def search_space(self) -> Optional[Sequence['outputs.ImageModelDistributionSettingsObjectDetectionResponse']]:
        """
        Search space for sampling different combinations of models and their hyperparameters.
        """
        return pulumi.get(self, "search_space")

    @property
    @pulumi.getter(name="sweepSettings")
    def sweep_settings(self) -> Optional['outputs.ImageSweepSettingsResponse']:
        """
        Model sweeping and hyperparameter sweeping related settings.
        """
        return pulumi.get(self, "sweep_settings")

    @property
    @pulumi.getter(name="targetColumnName")
    def target_column_name(self) -> Optional[builtins.str]:
        """
        Target column name: This is prediction values column.
        Also known as label column name in context of classification tasks.
        """
        return pulumi.get(self, "target_column_name")

    @property
    @pulumi.getter(name="validationData")
    def validation_data(self) -> Optional['outputs.MLTableJobInputResponse']:
        """
        Validation data inputs.
        """
        return pulumi.get(self, "validation_data")

    @property
    @pulumi.getter(name="validationDataSize")
    def validation_data_size(self) -> Optional[builtins.float]:
        """
        The fraction of training dataset that needs to be set aside for validation purpose.
        Values between (0.0 , 1.0)
        Applied when validation dataset is not provided.
        """
        return pulumi.get(self, "validation_data_size")


@pulumi.output_type
class ImageResponse(dict):
    """
    Describes the Image Specifications
    """
    def __init__(__self__, *,
                 reference: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        Describes the Image Specifications
        :param builtins.str reference: Image reference
        :param builtins.str type: Type of the image. Possible values are: docker - For docker images. azureml - For AzureML images
        """
        if reference is not None:
            pulumi.set(__self__, "reference", reference)
        if type is None:
            type = 'docker'
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def reference(self) -> Optional[builtins.str]:
        """
        Image reference
        """
        return pulumi.get(self, "reference")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the image. Possible values are: docker - For docker images. azureml - For AzureML images
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ImageSweepSettingsResponse(dict):
    """
    Model sweeping and hyperparameter sweeping related settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "samplingAlgorithm":
            suggest = "sampling_algorithm"
        elif key == "earlyTermination":
            suggest = "early_termination"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageSweepSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageSweepSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageSweepSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sampling_algorithm: builtins.str,
                 early_termination: Optional[Any] = None):
        """
        Model sweeping and hyperparameter sweeping related settings.
        :param builtins.str sampling_algorithm: [Required] Type of the hyperparameter sampling algorithms.
        :param Union['BanditPolicyResponse', 'MedianStoppingPolicyResponse', 'TruncationSelectionPolicyResponse'] early_termination: Type of early termination policy.
        """
        pulumi.set(__self__, "sampling_algorithm", sampling_algorithm)
        if early_termination is not None:
            pulumi.set(__self__, "early_termination", early_termination)

    @property
    @pulumi.getter(name="samplingAlgorithm")
    def sampling_algorithm(self) -> builtins.str:
        """
        [Required] Type of the hyperparameter sampling algorithms.
        """
        return pulumi.get(self, "sampling_algorithm")

    @property
    @pulumi.getter(name="earlyTermination")
    def early_termination(self) -> Optional[Any]:
        """
        Type of early termination policy.
        """
        return pulumi.get(self, "early_termination")


@pulumi.output_type
class IndexColumnResponse(dict):
    """
    DTO object representing index column
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"
        elif key == "dataType":
            suggest = "data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IndexColumnResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IndexColumnResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IndexColumnResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: Optional[builtins.str] = None,
                 data_type: Optional[builtins.str] = None):
        """
        DTO object representing index column
        :param builtins.str column_name: Specifies the column name
        :param builtins.str data_type: Specifies the data type
        """
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)
        if data_type is None:
            data_type = 'String'
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[builtins.str]:
        """
        Specifies the column name
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[builtins.str]:
        """
        Specifies the data type
        """
        return pulumi.get(self, "data_type")


@pulumi.output_type
class InferenceContainerPropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "livenessRoute":
            suggest = "liveness_route"
        elif key == "readinessRoute":
            suggest = "readiness_route"
        elif key == "scoringRoute":
            suggest = "scoring_route"
        elif key == "startupRoute":
            suggest = "startup_route"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InferenceContainerPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InferenceContainerPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InferenceContainerPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 liveness_route: Optional['outputs.RouteResponse'] = None,
                 readiness_route: Optional['outputs.RouteResponse'] = None,
                 scoring_route: Optional['outputs.RouteResponse'] = None,
                 startup_route: Optional['outputs.RouteResponse'] = None):
        """
        :param 'RouteResponse' liveness_route: The route to check the liveness of the inference server container.
        :param 'RouteResponse' readiness_route: The route to check the readiness of the inference server container.
        :param 'RouteResponse' scoring_route: The port to send the scoring requests to, within the inference server container.
        :param 'RouteResponse' startup_route: The route to check the startup of the application in the container.
        """
        if liveness_route is not None:
            pulumi.set(__self__, "liveness_route", liveness_route)
        if readiness_route is not None:
            pulumi.set(__self__, "readiness_route", readiness_route)
        if scoring_route is not None:
            pulumi.set(__self__, "scoring_route", scoring_route)
        if startup_route is not None:
            pulumi.set(__self__, "startup_route", startup_route)

    @property
    @pulumi.getter(name="livenessRoute")
    def liveness_route(self) -> Optional['outputs.RouteResponse']:
        """
        The route to check the liveness of the inference server container.
        """
        return pulumi.get(self, "liveness_route")

    @property
    @pulumi.getter(name="readinessRoute")
    def readiness_route(self) -> Optional['outputs.RouteResponse']:
        """
        The route to check the readiness of the inference server container.
        """
        return pulumi.get(self, "readiness_route")

    @property
    @pulumi.getter(name="scoringRoute")
    def scoring_route(self) -> Optional['outputs.RouteResponse']:
        """
        The port to send the scoring requests to, within the inference server container.
        """
        return pulumi.get(self, "scoring_route")

    @property
    @pulumi.getter(name="startupRoute")
    def startup_route(self) -> Optional['outputs.RouteResponse']:
        """
        The route to check the startup of the application in the container.
        """
        return pulumi.get(self, "startup_route")


@pulumi.output_type
class InferenceEndpointResponse(dict):
    """
    InferenceEndpoint configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authMode":
            suggest = "auth_mode"
        elif key == "endpointUri":
            suggest = "endpoint_uri"
        elif key == "groupName":
            suggest = "group_name"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "requestConfiguration":
            suggest = "request_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InferenceEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InferenceEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InferenceEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_mode: builtins.str,
                 endpoint_uri: builtins.str,
                 group_name: builtins.str,
                 provisioning_state: builtins.str,
                 description: Optional[builtins.str] = None,
                 properties: Optional[Sequence['outputs.StringStringKeyValuePairResponse']] = None,
                 request_configuration: Optional['outputs.RequestConfigurationResponse'] = None):
        """
        InferenceEndpoint configuration
        :param builtins.str auth_mode: [Required] Authentication mode for the endpoint.
        :param builtins.str endpoint_uri: Endpoint URI for the inference endpoint.
        :param builtins.str group_name: [Required] Group within the same pool with which this endpoint needs to be associated with.
        :param builtins.str provisioning_state: Provisioning state for the endpoint.
        :param builtins.str description: Description of the resource.
        :param Sequence['StringStringKeyValuePairResponse'] properties: Property dictionary. Properties can be added, but not removed or altered.
        :param 'RequestConfigurationResponse' request_configuration: RequestConfiguration for endpoint.
        """
        pulumi.set(__self__, "auth_mode", auth_mode)
        pulumi.set(__self__, "endpoint_uri", endpoint_uri)
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if request_configuration is not None:
            pulumi.set(__self__, "request_configuration", request_configuration)

    @property
    @pulumi.getter(name="authMode")
    def auth_mode(self) -> builtins.str:
        """
        [Required] Authentication mode for the endpoint.
        """
        return pulumi.get(self, "auth_mode")

    @property
    @pulumi.getter(name="endpointUri")
    def endpoint_uri(self) -> builtins.str:
        """
        Endpoint URI for the inference endpoint.
        """
        return pulumi.get(self, "endpoint_uri")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> builtins.str:
        """
        [Required] Group within the same pool with which this endpoint needs to be associated with.
        """
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the endpoint.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description of the resource.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Sequence['outputs.StringStringKeyValuePairResponse']]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="requestConfiguration")
    def request_configuration(self) -> Optional['outputs.RequestConfigurationResponse']:
        """
        RequestConfiguration for endpoint.
        """
        return pulumi.get(self, "request_configuration")


@pulumi.output_type
class InferenceGroupResponse(dict):
    """
    Inference group configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "environmentConfiguration":
            suggest = "environment_configuration"
        elif key == "modelConfiguration":
            suggest = "model_configuration"
        elif key == "nodeSkuType":
            suggest = "node_sku_type"
        elif key == "scaleUnitSize":
            suggest = "scale_unit_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InferenceGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InferenceGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InferenceGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 description: Optional[builtins.str] = None,
                 environment_configuration: Optional['outputs.GroupEnvironmentConfigurationResponse'] = None,
                 model_configuration: Optional['outputs.GroupModelConfigurationResponse'] = None,
                 node_sku_type: Optional[builtins.str] = None,
                 properties: Optional[Sequence['outputs.StringStringKeyValuePairResponse']] = None,
                 scale_unit_size: Optional[builtins.int] = None):
        """
        Inference group configuration
        :param builtins.str provisioning_state: Provisioning state for the inference group.
        :param builtins.str description: Description of the resource.
        :param 'GroupEnvironmentConfigurationResponse' environment_configuration: Gets or sets environment configuration for the inference group. Used if PoolType=ScaleUnit.
        :param 'GroupModelConfigurationResponse' model_configuration: Gets or sets model configuration for the inference group. Used if PoolType=ScaleUnit.
        :param builtins.str node_sku_type: Gets or sets compute instance type.
        :param Sequence['StringStringKeyValuePairResponse'] properties: Property dictionary. Properties can be added, but not removed or altered.
        :param builtins.int scale_unit_size: Gets or sets Scale Unit size.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if environment_configuration is not None:
            pulumi.set(__self__, "environment_configuration", environment_configuration)
        if model_configuration is not None:
            pulumi.set(__self__, "model_configuration", model_configuration)
        if node_sku_type is not None:
            pulumi.set(__self__, "node_sku_type", node_sku_type)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if scale_unit_size is not None:
            pulumi.set(__self__, "scale_unit_size", scale_unit_size)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the inference group.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description of the resource.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="environmentConfiguration")
    def environment_configuration(self) -> Optional['outputs.GroupEnvironmentConfigurationResponse']:
        """
        Gets or sets environment configuration for the inference group. Used if PoolType=ScaleUnit.
        """
        return pulumi.get(self, "environment_configuration")

    @property
    @pulumi.getter(name="modelConfiguration")
    def model_configuration(self) -> Optional['outputs.GroupModelConfigurationResponse']:
        """
        Gets or sets model configuration for the inference group. Used if PoolType=ScaleUnit.
        """
        return pulumi.get(self, "model_configuration")

    @property
    @pulumi.getter(name="nodeSkuType")
    def node_sku_type(self) -> Optional[builtins.str]:
        """
        Gets or sets compute instance type.
        """
        return pulumi.get(self, "node_sku_type")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Sequence['outputs.StringStringKeyValuePairResponse']]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="scaleUnitSize")
    def scale_unit_size(self) -> Optional[builtins.int]:
        """
        Gets or sets Scale Unit size.
        """
        return pulumi.get(self, "scale_unit_size")


@pulumi.output_type
class InferencePoolResponse(dict):
    """
    Inference pool configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "scaleUnitConfiguration":
            suggest = "scale_unit_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InferencePoolResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InferencePoolResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InferencePoolResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 description: Optional[builtins.str] = None,
                 properties: Optional[Sequence['outputs.StringStringKeyValuePairResponse']] = None,
                 scale_unit_configuration: Optional['outputs.ScaleUnitConfigurationResponse'] = None):
        """
        Inference pool configuration
        :param builtins.str provisioning_state: Provisioning state for the pool.
        :param builtins.str description: Description of the resource.
        :param Sequence['StringStringKeyValuePairResponse'] properties: Property dictionary. Properties can be added, but not removed or altered.
        :param 'ScaleUnitConfigurationResponse' scale_unit_configuration: Gets or sets ScaleUnitConfiguration for the inference pool. Used if PoolType=ScaleUnit.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if scale_unit_configuration is not None:
            pulumi.set(__self__, "scale_unit_configuration", scale_unit_configuration)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the pool.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description of the resource.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Sequence['outputs.StringStringKeyValuePairResponse']]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="scaleUnitConfiguration")
    def scale_unit_configuration(self) -> Optional['outputs.ScaleUnitConfigurationResponse']:
        """
        Gets or sets ScaleUnitConfiguration for the inference pool. Used if PoolType=ScaleUnit.
        """
        return pulumi.get(self, "scale_unit_configuration")


@pulumi.output_type
class InstanceTypeSchemaResponse(dict):
    """
    Instance type schema.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeSelector":
            suggest = "node_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceTypeSchemaResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceTypeSchemaResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceTypeSchemaResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_selector: Optional[Mapping[str, builtins.str]] = None,
                 resources: Optional['outputs.InstanceTypeSchemaResponseResources'] = None):
        """
        Instance type schema.
        :param Mapping[str, builtins.str] node_selector: Node Selector
        :param 'InstanceTypeSchemaResponseResources' resources: Resource requests/limits for this instance type
        """
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Node Selector
        """
        return pulumi.get(self, "node_selector")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.InstanceTypeSchemaResponseResources']:
        """
        Resource requests/limits for this instance type
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class InstanceTypeSchemaResponseResources(dict):
    """
    Resource requests/limits for this instance type
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, builtins.str]] = None,
                 requests: Optional[Mapping[str, builtins.str]] = None):
        """
        Resource requests/limits for this instance type
        :param Mapping[str, builtins.str] limits: Resource limits for this instance type
        :param Mapping[str, builtins.str] requests: Resource requests for this instance type
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Resource limits for this instance type
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Resource requests for this instance type
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class JobResourceConfigurationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dockerArgs":
            suggest = "docker_args"
        elif key == "instanceCount":
            suggest = "instance_count"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "shmSize":
            suggest = "shm_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobResourceConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobResourceConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobResourceConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 docker_args: Optional[builtins.str] = None,
                 instance_count: Optional[builtins.int] = None,
                 instance_type: Optional[builtins.str] = None,
                 properties: Optional[Mapping[str, Any]] = None,
                 shm_size: Optional[builtins.str] = None):
        """
        :param builtins.str docker_args: Extra arguments to pass to the Docker run command. This would override any parameters that have already been set by the system, or in this section. This parameter is only supported for Azure ML compute types.
        :param builtins.int instance_count: Optional number of instances or nodes used by the compute target.
        :param builtins.str instance_type: Optional type of VM used as supported by the compute target.
        :param Mapping[str, Any] properties: Additional properties bag.
        :param builtins.str shm_size: Size of the docker container's shared memory block. This should be in the format of (number)(unit) where number as to be greater than 0 and the unit can be one of b(bytes), k(kilobytes), m(megabytes), or g(gigabytes).
        """
        if docker_args is not None:
            pulumi.set(__self__, "docker_args", docker_args)
        if instance_count is None:
            instance_count = 1
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if shm_size is None:
            shm_size = '2g'
        if shm_size is not None:
            pulumi.set(__self__, "shm_size", shm_size)

    @property
    @pulumi.getter(name="dockerArgs")
    def docker_args(self) -> Optional[builtins.str]:
        """
        Extra arguments to pass to the Docker run command. This would override any parameters that have already been set by the system, or in this section. This parameter is only supported for Azure ML compute types.
        """
        return pulumi.get(self, "docker_args")

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[builtins.int]:
        """
        Optional number of instances or nodes used by the compute target.
        """
        return pulumi.get(self, "instance_count")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[builtins.str]:
        """
        Optional type of VM used as supported by the compute target.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, Any]]:
        """
        Additional properties bag.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="shmSize")
    def shm_size(self) -> Optional[builtins.str]:
        """
        Size of the docker container's shared memory block. This should be in the format of (number)(unit) where number as to be greater than 0 and the unit can be one of b(bytes), k(kilobytes), m(megabytes), or g(gigabytes).
        """
        return pulumi.get(self, "shm_size")


@pulumi.output_type
class JobScheduleActionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "jobBaseProperties":
            suggest = "job_base_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobScheduleActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobScheduleActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobScheduleActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: builtins.str,
                 job_base_properties: Any):
        """
        :param builtins.str action_type: 
               Expected value is 'CreateJob'.
        :param Union['AutoMLJobResponse', 'CommandJobResponse', 'PipelineJobResponse', 'SparkJobResponse', 'SweepJobResponse'] job_base_properties: [Required] Defines Schedule action definition details.
        """
        pulumi.set(__self__, "action_type", 'CreateJob')
        pulumi.set(__self__, "job_base_properties", job_base_properties)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> builtins.str:
        """

        Expected value is 'CreateJob'.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="jobBaseProperties")
    def job_base_properties(self) -> Any:
        """
        [Required] Defines Schedule action definition details.
        """
        return pulumi.get(self, "job_base_properties")


@pulumi.output_type
class JobServiceResponse(dict):
    """
    Job endpoint definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"
        elif key == "jobServiceType":
            suggest = "job_service_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobServiceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobServiceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobServiceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_message: builtins.str,
                 status: builtins.str,
                 endpoint: Optional[builtins.str] = None,
                 job_service_type: Optional[builtins.str] = None,
                 nodes: Optional['outputs.AllNodesResponse'] = None,
                 port: Optional[builtins.int] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None):
        """
        Job endpoint definition
        :param builtins.str error_message: Any error in the service.
        :param builtins.str status: Status of endpoint.
        :param builtins.str endpoint: Url for endpoint.
        :param builtins.str job_service_type: Endpoint type.
        :param 'AllNodesResponse' nodes: Nodes that user would like to start the service on.
               If Nodes is not set or set to null, the service will only be started on leader node.
        :param builtins.int port: Port for endpoint.
        :param Mapping[str, builtins.str] properties: Additional properties to set on the endpoint.
        """
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "status", status)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if job_service_type is not None:
            pulumi.set(__self__, "job_service_type", job_service_type)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> builtins.str:
        """
        Any error in the service.
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Status of endpoint.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[builtins.str]:
        """
        Url for endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="jobServiceType")
    def job_service_type(self) -> Optional[builtins.str]:
        """
        Endpoint type.
        """
        return pulumi.get(self, "job_service_type")

    @property
    @pulumi.getter
    def nodes(self) -> Optional['outputs.AllNodesResponse']:
        """
        Nodes that user would like to start the service on.
        If Nodes is not set or set to null, the service will only be started on leader node.
        """
        return pulumi.get(self, "nodes")

    @property
    @pulumi.getter
    def port(self) -> Optional[builtins.int]:
        """
        Port for endpoint.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Additional properties to set on the endpoint.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class KubernetesOnlineDeploymentResponse(dict):
    """
    Properties specific to a KubernetesOnlineDeployment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointComputeType":
            suggest = "endpoint_compute_type"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "appInsightsEnabled":
            suggest = "app_insights_enabled"
        elif key == "codeConfiguration":
            suggest = "code_configuration"
        elif key == "containerResourceRequirements":
            suggest = "container_resource_requirements"
        elif key == "dataCollector":
            suggest = "data_collector"
        elif key == "egressPublicNetworkAccess":
            suggest = "egress_public_network_access"
        elif key == "environmentId":
            suggest = "environment_id"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "livenessProbe":
            suggest = "liveness_probe"
        elif key == "modelMountPath":
            suggest = "model_mount_path"
        elif key == "readinessProbe":
            suggest = "readiness_probe"
        elif key == "requestSettings":
            suggest = "request_settings"
        elif key == "scaleSettings":
            suggest = "scale_settings"
        elif key == "startupProbe":
            suggest = "startup_probe"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesOnlineDeploymentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesOnlineDeploymentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesOnlineDeploymentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_compute_type: builtins.str,
                 provisioning_state: builtins.str,
                 app_insights_enabled: Optional[builtins.bool] = None,
                 code_configuration: Optional['outputs.CodeConfigurationResponse'] = None,
                 container_resource_requirements: Optional['outputs.ContainerResourceRequirementsResponse'] = None,
                 data_collector: Optional['outputs.DataCollectorResponse'] = None,
                 description: Optional[builtins.str] = None,
                 egress_public_network_access: Optional[builtins.str] = None,
                 environment_id: Optional[builtins.str] = None,
                 environment_variables: Optional[Mapping[str, builtins.str]] = None,
                 instance_type: Optional[builtins.str] = None,
                 liveness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
                 model: Optional[builtins.str] = None,
                 model_mount_path: Optional[builtins.str] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 readiness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
                 request_settings: Optional['outputs.OnlineRequestSettingsResponse'] = None,
                 scale_settings: Optional[Any] = None,
                 startup_probe: Optional['outputs.ProbeSettingsResponse'] = None):
        """
        Properties specific to a KubernetesOnlineDeployment.
        :param builtins.str endpoint_compute_type: Enum to determine endpoint compute type.
               Expected value is 'Kubernetes'.
        :param builtins.str provisioning_state: Provisioning state for the endpoint deployment.
        :param builtins.bool app_insights_enabled: If true, enables Application Insights logging.
        :param 'CodeConfigurationResponse' code_configuration: Code configuration for the endpoint deployment.
        :param 'ContainerResourceRequirementsResponse' container_resource_requirements: The resource requirements for the container (cpu and memory).
        :param 'DataCollectorResponse' data_collector: The mdc configuration, we disable mdc when it's null.
        :param builtins.str description: Description of the endpoint deployment.
        :param builtins.str egress_public_network_access: If Enabled, allow egress public network access. If Disabled, this will create secure egress. Default: Enabled.
        :param builtins.str environment_id: ARM resource ID or AssetId of the environment specification for the endpoint deployment.
        :param Mapping[str, builtins.str] environment_variables: Environment variables configuration for the deployment.
        :param builtins.str instance_type: Compute instance type. Default: Standard_F4s_v2.
        :param 'ProbeSettingsResponse' liveness_probe: Liveness probe monitors the health of the container regularly.
        :param builtins.str model: The URI path to the model.
        :param builtins.str model_mount_path: The path to mount the model in custom container.
        :param Mapping[str, builtins.str] properties: Property dictionary. Properties can be added, but not removed or altered.
        :param 'ProbeSettingsResponse' readiness_probe: Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
        :param 'OnlineRequestSettingsResponse' request_settings: Request settings for the deployment.
        :param Union['DefaultScaleSettingsResponse', 'TargetUtilizationScaleSettingsResponse'] scale_settings: Scale settings for the deployment.
               If it is null or not provided,
               it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
               and to DefaultScaleSettings for ManagedOnlineDeployment.
        :param 'ProbeSettingsResponse' startup_probe: Startup probe verify whether an application within a container has started successfully.
        """
        pulumi.set(__self__, "endpoint_compute_type", 'Kubernetes')
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if app_insights_enabled is None:
            app_insights_enabled = False
        if app_insights_enabled is not None:
            pulumi.set(__self__, "app_insights_enabled", app_insights_enabled)
        if code_configuration is not None:
            pulumi.set(__self__, "code_configuration", code_configuration)
        if container_resource_requirements is not None:
            pulumi.set(__self__, "container_resource_requirements", container_resource_requirements)
        if data_collector is not None:
            pulumi.set(__self__, "data_collector", data_collector)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if egress_public_network_access is None:
            egress_public_network_access = 'Enabled'
        if egress_public_network_access is not None:
            pulumi.set(__self__, "egress_public_network_access", egress_public_network_access)
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if instance_type is None:
            instance_type = 'Standard_F4s_v2'
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if model_mount_path is not None:
            pulumi.set(__self__, "model_mount_path", model_mount_path)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if request_settings is not None:
            pulumi.set(__self__, "request_settings", request_settings)
        if scale_settings is not None:
            pulumi.set(__self__, "scale_settings", scale_settings)
        if startup_probe is not None:
            pulumi.set(__self__, "startup_probe", startup_probe)

    @property
    @pulumi.getter(name="endpointComputeType")
    def endpoint_compute_type(self) -> builtins.str:
        """
        Enum to determine endpoint compute type.
        Expected value is 'Kubernetes'.
        """
        return pulumi.get(self, "endpoint_compute_type")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the endpoint deployment.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="appInsightsEnabled")
    def app_insights_enabled(self) -> Optional[builtins.bool]:
        """
        If true, enables Application Insights logging.
        """
        return pulumi.get(self, "app_insights_enabled")

    @property
    @pulumi.getter(name="codeConfiguration")
    def code_configuration(self) -> Optional['outputs.CodeConfigurationResponse']:
        """
        Code configuration for the endpoint deployment.
        """
        return pulumi.get(self, "code_configuration")

    @property
    @pulumi.getter(name="containerResourceRequirements")
    def container_resource_requirements(self) -> Optional['outputs.ContainerResourceRequirementsResponse']:
        """
        The resource requirements for the container (cpu and memory).
        """
        return pulumi.get(self, "container_resource_requirements")

    @property
    @pulumi.getter(name="dataCollector")
    def data_collector(self) -> Optional['outputs.DataCollectorResponse']:
        """
        The mdc configuration, we disable mdc when it's null.
        """
        return pulumi.get(self, "data_collector")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description of the endpoint deployment.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="egressPublicNetworkAccess")
    def egress_public_network_access(self) -> Optional[builtins.str]:
        """
        If Enabled, allow egress public network access. If Disabled, this will create secure egress. Default: Enabled.
        """
        return pulumi.get(self, "egress_public_network_access")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID or AssetId of the environment specification for the endpoint deployment.
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Environment variables configuration for the deployment.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[builtins.str]:
        """
        Compute instance type. Default: Standard_F4s_v2.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.ProbeSettingsResponse']:
        """
        Liveness probe monitors the health of the container regularly.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def model(self) -> Optional[builtins.str]:
        """
        The URI path to the model.
        """
        return pulumi.get(self, "model")

    @property
    @pulumi.getter(name="modelMountPath")
    def model_mount_path(self) -> Optional[builtins.str]:
        """
        The path to mount the model in custom container.
        """
        return pulumi.get(self, "model_mount_path")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.ProbeSettingsResponse']:
        """
        Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter(name="requestSettings")
    def request_settings(self) -> Optional['outputs.OnlineRequestSettingsResponse']:
        """
        Request settings for the deployment.
        """
        return pulumi.get(self, "request_settings")

    @property
    @pulumi.getter(name="scaleSettings")
    def scale_settings(self) -> Optional[Any]:
        """
        Scale settings for the deployment.
        If it is null or not provided,
        it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
        and to DefaultScaleSettings for ManagedOnlineDeployment.
        """
        return pulumi.get(self, "scale_settings")

    @property
    @pulumi.getter(name="startupProbe")
    def startup_probe(self) -> Optional['outputs.ProbeSettingsResponse']:
        """
        Startup probe verify whether an application within a container has started successfully.
        """
        return pulumi.get(self, "startup_probe")


@pulumi.output_type
class KubernetesPropertiesResponse(dict):
    """
    Kubernetes properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultInstanceType":
            suggest = "default_instance_type"
        elif key == "extensionInstanceReleaseTrain":
            suggest = "extension_instance_release_train"
        elif key == "extensionPrincipalId":
            suggest = "extension_principal_id"
        elif key == "instanceTypes":
            suggest = "instance_types"
        elif key == "relayConnectionString":
            suggest = "relay_connection_string"
        elif key == "serviceBusConnectionString":
            suggest = "service_bus_connection_string"
        elif key == "vcName":
            suggest = "vc_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_instance_type: Optional[builtins.str] = None,
                 extension_instance_release_train: Optional[builtins.str] = None,
                 extension_principal_id: Optional[builtins.str] = None,
                 instance_types: Optional[Mapping[str, 'outputs.InstanceTypeSchemaResponse']] = None,
                 namespace: Optional[builtins.str] = None,
                 relay_connection_string: Optional[builtins.str] = None,
                 service_bus_connection_string: Optional[builtins.str] = None,
                 vc_name: Optional[builtins.str] = None):
        """
        Kubernetes properties
        :param builtins.str default_instance_type: Default instance type
        :param builtins.str extension_instance_release_train: Extension instance release train.
        :param builtins.str extension_principal_id: Extension principal-id.
        :param Mapping[str, 'InstanceTypeSchemaResponse'] instance_types: Instance Type Schema
        :param builtins.str namespace: Compute namespace
        :param builtins.str relay_connection_string: Relay connection string.
        :param builtins.str service_bus_connection_string: ServiceBus connection string.
        :param builtins.str vc_name: VC name.
        """
        if default_instance_type is not None:
            pulumi.set(__self__, "default_instance_type", default_instance_type)
        if extension_instance_release_train is not None:
            pulumi.set(__self__, "extension_instance_release_train", extension_instance_release_train)
        if extension_principal_id is not None:
            pulumi.set(__self__, "extension_principal_id", extension_principal_id)
        if instance_types is not None:
            pulumi.set(__self__, "instance_types", instance_types)
        if namespace is None:
            namespace = 'default'
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if relay_connection_string is not None:
            pulumi.set(__self__, "relay_connection_string", relay_connection_string)
        if service_bus_connection_string is not None:
            pulumi.set(__self__, "service_bus_connection_string", service_bus_connection_string)
        if vc_name is not None:
            pulumi.set(__self__, "vc_name", vc_name)

    @property
    @pulumi.getter(name="defaultInstanceType")
    def default_instance_type(self) -> Optional[builtins.str]:
        """
        Default instance type
        """
        return pulumi.get(self, "default_instance_type")

    @property
    @pulumi.getter(name="extensionInstanceReleaseTrain")
    def extension_instance_release_train(self) -> Optional[builtins.str]:
        """
        Extension instance release train.
        """
        return pulumi.get(self, "extension_instance_release_train")

    @property
    @pulumi.getter(name="extensionPrincipalId")
    def extension_principal_id(self) -> Optional[builtins.str]:
        """
        Extension principal-id.
        """
        return pulumi.get(self, "extension_principal_id")

    @property
    @pulumi.getter(name="instanceTypes")
    def instance_types(self) -> Optional[Mapping[str, 'outputs.InstanceTypeSchemaResponse']]:
        """
        Instance Type Schema
        """
        return pulumi.get(self, "instance_types")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        """
        Compute namespace
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="relayConnectionString")
    def relay_connection_string(self) -> Optional[builtins.str]:
        """
        Relay connection string.
        """
        return pulumi.get(self, "relay_connection_string")

    @property
    @pulumi.getter(name="serviceBusConnectionString")
    def service_bus_connection_string(self) -> Optional[builtins.str]:
        """
        ServiceBus connection string.
        """
        return pulumi.get(self, "service_bus_connection_string")

    @property
    @pulumi.getter(name="vcName")
    def vc_name(self) -> Optional[builtins.str]:
        """
        VC name.
        """
        return pulumi.get(self, "vc_name")


@pulumi.output_type
class KubernetesResponse(dict):
    """
    A Machine Learning compute based on Kubernetes Compute.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeType":
            suggest = "compute_type"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "isAttachedCompute":
            suggest = "is_attached_compute"
        elif key == "modifiedOn":
            suggest = "modified_on"
        elif key == "provisioningErrors":
            suggest = "provisioning_errors"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "computeLocation":
            suggest = "compute_location"
        elif key == "disableLocalAuth":
            suggest = "disable_local_auth"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_type: builtins.str,
                 created_on: builtins.str,
                 is_attached_compute: builtins.bool,
                 modified_on: builtins.str,
                 provisioning_errors: Sequence['outputs.ErrorResponseResponse'],
                 provisioning_state: builtins.str,
                 compute_location: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 disable_local_auth: Optional[builtins.bool] = None,
                 properties: Optional['outputs.KubernetesPropertiesResponse'] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        A Machine Learning compute based on Kubernetes Compute.
        :param builtins.str compute_type: The type of compute
               Expected value is 'Kubernetes'.
        :param builtins.str created_on: The time at which the compute was created.
        :param builtins.bool is_attached_compute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        :param builtins.str modified_on: The time at which the compute was last modified.
        :param Sequence['ErrorResponseResponse'] provisioning_errors: Errors during provisioning
        :param builtins.str provisioning_state: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        :param builtins.str compute_location: Location for the underlying compute
        :param builtins.str description: The description of the Machine Learning compute.
        :param builtins.bool disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        :param 'KubernetesPropertiesResponse' properties: Properties of Kubernetes
        :param builtins.str resource_id: ARM resource id of the underlying compute
        """
        pulumi.set(__self__, "compute_type", 'Kubernetes')
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "is_attached_compute", is_attached_compute)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "provisioning_errors", provisioning_errors)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if compute_location is not None:
            pulumi.set(__self__, "compute_location", compute_location)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_local_auth is not None:
            pulumi.set(__self__, "disable_local_auth", disable_local_auth)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> builtins.str:
        """
        The type of compute
        Expected value is 'Kubernetes'.
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> builtins.str:
        """
        The time at which the compute was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="isAttachedCompute")
    def is_attached_compute(self) -> builtins.bool:
        """
        Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        """
        return pulumi.get(self, "is_attached_compute")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> builtins.str:
        """
        The time at which the compute was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="provisioningErrors")
    def provisioning_errors(self) -> Sequence['outputs.ErrorResponseResponse']:
        """
        Errors during provisioning
        """
        return pulumi.get(self, "provisioning_errors")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[builtins.str]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[builtins.bool]:
        """
        Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        """
        return pulumi.get(self, "disable_local_auth")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.KubernetesPropertiesResponse']:
        """
        Properties of Kubernetes
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class LabelCategoryResponse(dict):
    """
    Label category definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "multiSelect":
            suggest = "multi_select"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LabelCategoryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LabelCategoryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LabelCategoryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classes: Optional[Mapping[str, 'outputs.LabelClassResponse']] = None,
                 display_name: Optional[builtins.str] = None,
                 multi_select: Optional[builtins.str] = None):
        """
        Label category definition
        :param Mapping[str, 'LabelClassResponse'] classes: Dictionary of label classes in this category.
        :param builtins.str display_name: Display name of the label category.
        :param builtins.str multi_select: Indicates whether it is allowed to select multiple classes in this category.
        """
        if classes is not None:
            pulumi.set(__self__, "classes", classes)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if multi_select is None:
            multi_select = 'Disabled'
        if multi_select is not None:
            pulumi.set(__self__, "multi_select", multi_select)

    @property
    @pulumi.getter
    def classes(self) -> Optional[Mapping[str, 'outputs.LabelClassResponse']]:
        """
        Dictionary of label classes in this category.
        """
        return pulumi.get(self, "classes")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        Display name of the label category.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="multiSelect")
    def multi_select(self) -> Optional[builtins.str]:
        """
        Indicates whether it is allowed to select multiple classes in this category.
        """
        return pulumi.get(self, "multi_select")


@pulumi.output_type
class LabelClassResponse(dict):
    """
    Label class definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LabelClassResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LabelClassResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LabelClassResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[builtins.str] = None,
                 subclasses: Optional[Mapping[str, 'outputs.LabelClassResponse']] = None):
        """
        Label class definition
        :param builtins.str display_name: Display name of the label class.
        :param Mapping[str, 'LabelClassResponse'] subclasses: Dictionary of subclasses of the label class.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if subclasses is not None:
            pulumi.set(__self__, "subclasses", subclasses)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        Display name of the label class.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def subclasses(self) -> Optional[Mapping[str, 'outputs.LabelClassResponse']]:
        """
        Dictionary of subclasses of the label class.
        """
        return pulumi.get(self, "subclasses")


@pulumi.output_type
class LabelingDataConfigurationResponse(dict):
    """
    Labeling data configuration definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataId":
            suggest = "data_id"
        elif key == "incrementalDataRefresh":
            suggest = "incremental_data_refresh"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LabelingDataConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LabelingDataConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LabelingDataConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_id: Optional[builtins.str] = None,
                 incremental_data_refresh: Optional[builtins.str] = None):
        """
        Labeling data configuration definition
        :param builtins.str data_id: Resource Id of the data asset to perform labeling.
        :param builtins.str incremental_data_refresh: Indicates whether to enable incremental data refresh.
        """
        if data_id is not None:
            pulumi.set(__self__, "data_id", data_id)
        if incremental_data_refresh is None:
            incremental_data_refresh = 'Disabled'
        if incremental_data_refresh is not None:
            pulumi.set(__self__, "incremental_data_refresh", incremental_data_refresh)

    @property
    @pulumi.getter(name="dataId")
    def data_id(self) -> Optional[builtins.str]:
        """
        Resource Id of the data asset to perform labeling.
        """
        return pulumi.get(self, "data_id")

    @property
    @pulumi.getter(name="incrementalDataRefresh")
    def incremental_data_refresh(self) -> Optional[builtins.str]:
        """
        Indicates whether to enable incremental data refresh.
        """
        return pulumi.get(self, "incremental_data_refresh")


@pulumi.output_type
class LabelingJobImagePropertiesResponse(dict):
    """
    Properties of a labeling job for image data
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mediaType":
            suggest = "media_type"
        elif key == "annotationType":
            suggest = "annotation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LabelingJobImagePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LabelingJobImagePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LabelingJobImagePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 media_type: builtins.str,
                 annotation_type: Optional[builtins.str] = None):
        """
        Properties of a labeling job for image data
        :param builtins.str media_type: Media type of data asset.
               Expected value is 'Image'.
        :param builtins.str annotation_type: Annotation type of image labeling job.
        """
        pulumi.set(__self__, "media_type", 'Image')
        if annotation_type is None:
            annotation_type = 'Classification'
        if annotation_type is not None:
            pulumi.set(__self__, "annotation_type", annotation_type)

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> builtins.str:
        """
        Media type of data asset.
        Expected value is 'Image'.
        """
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter(name="annotationType")
    def annotation_type(self) -> Optional[builtins.str]:
        """
        Annotation type of image labeling job.
        """
        return pulumi.get(self, "annotation_type")


@pulumi.output_type
class LabelingJobInstructionsResponse(dict):
    """
    Instructions for labeling job
    """
    def __init__(__self__, *,
                 uri: Optional[builtins.str] = None):
        """
        Instructions for labeling job
        :param builtins.str uri: The link to a page with detailed labeling instructions for labelers.
        """
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def uri(self) -> Optional[builtins.str]:
        """
        The link to a page with detailed labeling instructions for labelers.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class LabelingJobResponse(dict):
    """
    Labeling job definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdDateTime":
            suggest = "created_date_time"
        elif key == "jobType":
            suggest = "job_type"
        elif key == "progressMetrics":
            suggest = "progress_metrics"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "statusMessages":
            suggest = "status_messages"
        elif key == "componentId":
            suggest = "component_id"
        elif key == "computeId":
            suggest = "compute_id"
        elif key == "dataConfiguration":
            suggest = "data_configuration"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "experimentName":
            suggest = "experiment_name"
        elif key == "isArchived":
            suggest = "is_archived"
        elif key == "jobInstructions":
            suggest = "job_instructions"
        elif key == "labelCategories":
            suggest = "label_categories"
        elif key == "labelingJobMediaProperties":
            suggest = "labeling_job_media_properties"
        elif key == "mlAssistConfiguration":
            suggest = "ml_assist_configuration"
        elif key == "notificationSetting":
            suggest = "notification_setting"
        elif key == "secretsConfiguration":
            suggest = "secrets_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LabelingJobResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LabelingJobResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LabelingJobResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_date_time: builtins.str,
                 job_type: builtins.str,
                 progress_metrics: 'outputs.ProgressMetricsResponse',
                 project_id: builtins.str,
                 provisioning_state: builtins.str,
                 status: builtins.str,
                 status_messages: Sequence['outputs.StatusMessageResponse'],
                 component_id: Optional[builtins.str] = None,
                 compute_id: Optional[builtins.str] = None,
                 data_configuration: Optional['outputs.LabelingDataConfigurationResponse'] = None,
                 description: Optional[builtins.str] = None,
                 display_name: Optional[builtins.str] = None,
                 experiment_name: Optional[builtins.str] = None,
                 identity: Optional[Any] = None,
                 is_archived: Optional[builtins.bool] = None,
                 job_instructions: Optional['outputs.LabelingJobInstructionsResponse'] = None,
                 label_categories: Optional[Mapping[str, 'outputs.LabelCategoryResponse']] = None,
                 labeling_job_media_properties: Optional[Any] = None,
                 ml_assist_configuration: Optional[Any] = None,
                 notification_setting: Optional['outputs.NotificationSettingResponse'] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 secrets_configuration: Optional[Mapping[str, 'outputs.SecretConfigurationResponse']] = None,
                 services: Optional[Mapping[str, 'outputs.JobServiceResponse']] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Labeling job definition
        :param builtins.str created_date_time: Created time of the job in UTC timezone.
        :param builtins.str job_type: Enum to determine the type of job.
               Expected value is 'Labeling'.
        :param 'ProgressMetricsResponse' progress_metrics: Progress metrics of the job.
        :param builtins.str project_id: Internal id of the job(Previously called project).
        :param builtins.str provisioning_state: Specifies the labeling job provisioning state.
        :param builtins.str status: Status of the job.
        :param Sequence['StatusMessageResponse'] status_messages: Status messages of the job.
        :param builtins.str component_id: ARM resource ID of the component resource.
        :param builtins.str compute_id: ARM resource ID of the compute resource.
        :param 'LabelingDataConfigurationResponse' data_configuration: Configuration of data used in the job.
        :param builtins.str description: The asset description text.
        :param builtins.str display_name: Display name of job.
        :param builtins.str experiment_name: The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        :param Union['AmlTokenResponse', 'ManagedIdentityResponse', 'UserIdentityResponse'] identity: Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
               Defaults to AmlToken if null.
        :param builtins.bool is_archived: Is the asset archived?
        :param 'LabelingJobInstructionsResponse' job_instructions: Labeling instructions of the job.
        :param Mapping[str, 'LabelCategoryResponse'] label_categories: Label categories of the job.
        :param Union['LabelingJobImagePropertiesResponse', 'LabelingJobTextPropertiesResponse'] labeling_job_media_properties: Media type specific properties in the job.
        :param Union['MLAssistConfigurationDisabledResponse', 'MLAssistConfigurationEnabledResponse'] ml_assist_configuration: Configuration of MLAssist feature in the job.
        :param 'NotificationSettingResponse' notification_setting: Notification setting for the job
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param Mapping[str, 'SecretConfigurationResponse'] secrets_configuration: Configuration for secrets to be made available during runtime.
        :param Mapping[str, 'JobServiceResponse'] services: List of JobEndpoints.
               For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "created_date_time", created_date_time)
        pulumi.set(__self__, "job_type", 'Labeling')
        pulumi.set(__self__, "progress_metrics", progress_metrics)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_messages", status_messages)
        if component_id is not None:
            pulumi.set(__self__, "component_id", component_id)
        if compute_id is not None:
            pulumi.set(__self__, "compute_id", compute_id)
        if data_configuration is not None:
            pulumi.set(__self__, "data_configuration", data_configuration)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if experiment_name is None:
            experiment_name = 'Default'
        if experiment_name is not None:
            pulumi.set(__self__, "experiment_name", experiment_name)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if job_instructions is not None:
            pulumi.set(__self__, "job_instructions", job_instructions)
        if label_categories is not None:
            pulumi.set(__self__, "label_categories", label_categories)
        if labeling_job_media_properties is not None:
            pulumi.set(__self__, "labeling_job_media_properties", labeling_job_media_properties)
        if ml_assist_configuration is not None:
            pulumi.set(__self__, "ml_assist_configuration", ml_assist_configuration)
        if notification_setting is not None:
            pulumi.set(__self__, "notification_setting", notification_setting)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if secrets_configuration is not None:
            pulumi.set(__self__, "secrets_configuration", secrets_configuration)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="createdDateTime")
    def created_date_time(self) -> builtins.str:
        """
        Created time of the job in UTC timezone.
        """
        return pulumi.get(self, "created_date_time")

    @property
    @pulumi.getter(name="jobType")
    def job_type(self) -> builtins.str:
        """
        Enum to determine the type of job.
        Expected value is 'Labeling'.
        """
        return pulumi.get(self, "job_type")

    @property
    @pulumi.getter(name="progressMetrics")
    def progress_metrics(self) -> 'outputs.ProgressMetricsResponse':
        """
        Progress metrics of the job.
        """
        return pulumi.get(self, "progress_metrics")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> builtins.str:
        """
        Internal id of the job(Previously called project).
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Specifies the labeling job provisioning state.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Status of the job.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusMessages")
    def status_messages(self) -> Sequence['outputs.StatusMessageResponse']:
        """
        Status messages of the job.
        """
        return pulumi.get(self, "status_messages")

    @property
    @pulumi.getter(name="componentId")
    def component_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of the component resource.
        """
        return pulumi.get(self, "component_id")

    @property
    @pulumi.getter(name="computeId")
    def compute_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of the compute resource.
        """
        return pulumi.get(self, "compute_id")

    @property
    @pulumi.getter(name="dataConfiguration")
    def data_configuration(self) -> Optional['outputs.LabelingDataConfigurationResponse']:
        """
        Configuration of data used in the job.
        """
        return pulumi.get(self, "data_configuration")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        Display name of job.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="experimentName")
    def experiment_name(self) -> Optional[builtins.str]:
        """
        The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        """
        return pulumi.get(self, "experiment_name")

    @property
    @pulumi.getter
    def identity(self) -> Optional[Any]:
        """
        Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
        Defaults to AmlToken if null.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter(name="jobInstructions")
    def job_instructions(self) -> Optional['outputs.LabelingJobInstructionsResponse']:
        """
        Labeling instructions of the job.
        """
        return pulumi.get(self, "job_instructions")

    @property
    @pulumi.getter(name="labelCategories")
    def label_categories(self) -> Optional[Mapping[str, 'outputs.LabelCategoryResponse']]:
        """
        Label categories of the job.
        """
        return pulumi.get(self, "label_categories")

    @property
    @pulumi.getter(name="labelingJobMediaProperties")
    def labeling_job_media_properties(self) -> Optional[Any]:
        """
        Media type specific properties in the job.
        """
        return pulumi.get(self, "labeling_job_media_properties")

    @property
    @pulumi.getter(name="mlAssistConfiguration")
    def ml_assist_configuration(self) -> Optional[Any]:
        """
        Configuration of MLAssist feature in the job.
        """
        return pulumi.get(self, "ml_assist_configuration")

    @property
    @pulumi.getter(name="notificationSetting")
    def notification_setting(self) -> Optional['outputs.NotificationSettingResponse']:
        """
        Notification setting for the job
        """
        return pulumi.get(self, "notification_setting")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="secretsConfiguration")
    def secrets_configuration(self) -> Optional[Mapping[str, 'outputs.SecretConfigurationResponse']]:
        """
        Configuration for secrets to be made available during runtime.
        """
        return pulumi.get(self, "secrets_configuration")

    @property
    @pulumi.getter
    def services(self) -> Optional[Mapping[str, 'outputs.JobServiceResponse']]:
        """
        List of JobEndpoints.
        For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class LabelingJobTextPropertiesResponse(dict):
    """
    Properties of a labeling job for text data
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mediaType":
            suggest = "media_type"
        elif key == "annotationType":
            suggest = "annotation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LabelingJobTextPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LabelingJobTextPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LabelingJobTextPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 media_type: builtins.str,
                 annotation_type: Optional[builtins.str] = None):
        """
        Properties of a labeling job for text data
        :param builtins.str media_type: Media type of data asset.
               Expected value is 'Text'.
        :param builtins.str annotation_type: Annotation type of text labeling job.
        """
        pulumi.set(__self__, "media_type", 'Text')
        if annotation_type is None:
            annotation_type = 'Classification'
        if annotation_type is not None:
            pulumi.set(__self__, "annotation_type", annotation_type)

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> builtins.str:
        """
        Media type of data asset.
        Expected value is 'Text'.
        """
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter(name="annotationType")
    def annotation_type(self) -> Optional[builtins.str]:
        """
        Annotation type of text labeling job.
        """
        return pulumi.get(self, "annotation_type")


@pulumi.output_type
class LakeHouseArtifactResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "artifactName":
            suggest = "artifact_name"
        elif key == "artifactType":
            suggest = "artifact_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LakeHouseArtifactResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LakeHouseArtifactResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LakeHouseArtifactResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 artifact_name: builtins.str,
                 artifact_type: builtins.str):
        """
        :param builtins.str artifact_name: [Required] OneLake artifact name
        :param builtins.str artifact_type: Enum to determine OneLake artifact type.
               Expected value is 'LakeHouse'.
        """
        pulumi.set(__self__, "artifact_name", artifact_name)
        pulumi.set(__self__, "artifact_type", 'LakeHouse')

    @property
    @pulumi.getter(name="artifactName")
    def artifact_name(self) -> builtins.str:
        """
        [Required] OneLake artifact name
        """
        return pulumi.get(self, "artifact_name")

    @property
    @pulumi.getter(name="artifactType")
    def artifact_type(self) -> builtins.str:
        """
        Enum to determine OneLake artifact type.
        Expected value is 'LakeHouse'.
        """
        return pulumi.get(self, "artifact_type")


@pulumi.output_type
class LinkedInfoResponse(dict):
    """
    Info about origin if it is linked.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedId":
            suggest = "linked_id"
        elif key == "linkedResourceName":
            suggest = "linked_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_id: Optional[builtins.str] = None,
                 linked_resource_name: Optional[builtins.str] = None,
                 origin: Optional[builtins.str] = None):
        """
        Info about origin if it is linked.
        :param builtins.str linked_id: LinkedId id.
        :param builtins.str linked_resource_name: Linked resource name.
        :param builtins.str origin: Datastore origin
        """
        if linked_id is not None:
            pulumi.set(__self__, "linked_id", linked_id)
        if linked_resource_name is not None:
            pulumi.set(__self__, "linked_resource_name", linked_resource_name)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)

    @property
    @pulumi.getter(name="linkedId")
    def linked_id(self) -> Optional[builtins.str]:
        """
        LinkedId id.
        """
        return pulumi.get(self, "linked_id")

    @property
    @pulumi.getter(name="linkedResourceName")
    def linked_resource_name(self) -> Optional[builtins.str]:
        """
        Linked resource name.
        """
        return pulumi.get(self, "linked_resource_name")

    @property
    @pulumi.getter
    def origin(self) -> Optional[builtins.str]:
        """
        Datastore origin
        """
        return pulumi.get(self, "origin")


@pulumi.output_type
class LinkedServicePropsResponse(dict):
    """
    LinkedService specific properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedServiceResourceId":
            suggest = "linked_service_resource_id"
        elif key == "createdTime":
            suggest = "created_time"
        elif key == "linkType":
            suggest = "link_type"
        elif key == "modifiedTime":
            suggest = "modified_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedServicePropsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedServicePropsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedServicePropsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_service_resource_id: builtins.str,
                 created_time: Optional[builtins.str] = None,
                 link_type: Optional[builtins.str] = None,
                 modified_time: Optional[builtins.str] = None):
        """
        LinkedService specific properties.
        :param builtins.str linked_service_resource_id: ResourceId of the link target of the linked service.
        :param builtins.str created_time: The creation time of the linked service.
        :param builtins.str link_type: Type of the link target.
        :param builtins.str modified_time: The last modified time of the linked service.
        """
        pulumi.set(__self__, "linked_service_resource_id", linked_service_resource_id)
        if created_time is not None:
            pulumi.set(__self__, "created_time", created_time)
        if link_type is not None:
            pulumi.set(__self__, "link_type", link_type)
        if modified_time is not None:
            pulumi.set(__self__, "modified_time", modified_time)

    @property
    @pulumi.getter(name="linkedServiceResourceId")
    def linked_service_resource_id(self) -> builtins.str:
        """
        ResourceId of the link target of the linked service.
        """
        return pulumi.get(self, "linked_service_resource_id")

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> Optional[builtins.str]:
        """
        The creation time of the linked service.
        """
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter(name="linkType")
    def link_type(self) -> Optional[builtins.str]:
        """
        Type of the link target.
        """
        return pulumi.get(self, "link_type")

    @property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> Optional[builtins.str]:
        """
        The last modified time of the linked service.
        """
        return pulumi.get(self, "modified_time")


@pulumi.output_type
class LinkedWorkspacePropsResponse(dict):
    """
    LinkedWorkspace specific properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedWorkspaceResourceId":
            suggest = "linked_workspace_resource_id"
        elif key == "userAssignedIdentityResourceId":
            suggest = "user_assigned_identity_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedWorkspacePropsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedWorkspacePropsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedWorkspacePropsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_workspace_resource_id: Optional[builtins.str] = None,
                 user_assigned_identity_resource_id: Optional[builtins.str] = None):
        """
        LinkedWorkspace specific properties.
        :param builtins.str linked_workspace_resource_id: ResourceId of the link target of the linked workspace.
        :param builtins.str user_assigned_identity_resource_id: ResourceId of the user assigned identity for the linked workspace.
        """
        if linked_workspace_resource_id is not None:
            pulumi.set(__self__, "linked_workspace_resource_id", linked_workspace_resource_id)
        if user_assigned_identity_resource_id is not None:
            pulumi.set(__self__, "user_assigned_identity_resource_id", user_assigned_identity_resource_id)

    @property
    @pulumi.getter(name="linkedWorkspaceResourceId")
    def linked_workspace_resource_id(self) -> Optional[builtins.str]:
        """
        ResourceId of the link target of the linked workspace.
        """
        return pulumi.get(self, "linked_workspace_resource_id")

    @property
    @pulumi.getter(name="userAssignedIdentityResourceId")
    def user_assigned_identity_resource_id(self) -> Optional[builtins.str]:
        """
        ResourceId of the user assigned identity for the linked workspace.
        """
        return pulumi.get(self, "user_assigned_identity_resource_id")


@pulumi.output_type
class ListNotebookKeysResultResponse(dict):
    def __init__(__self__, *,
                 primary_access_key: builtins.str,
                 secondary_access_key: builtins.str):
        pulumi.set(__self__, "primary_access_key", primary_access_key)
        pulumi.set(__self__, "secondary_access_key", secondary_access_key)

    @property
    @pulumi.getter(name="primaryAccessKey")
    def primary_access_key(self) -> builtins.str:
        return pulumi.get(self, "primary_access_key")

    @property
    @pulumi.getter(name="secondaryAccessKey")
    def secondary_access_key(self) -> builtins.str:
        return pulumi.get(self, "secondary_access_key")


@pulumi.output_type
class LiteralJobInputResponse(dict):
    """
    Literal input type.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobInputType":
            suggest = "job_input_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LiteralJobInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LiteralJobInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LiteralJobInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_input_type: builtins.str,
                 value: builtins.str,
                 description: Optional[builtins.str] = None):
        """
        Literal input type.
        :param builtins.str job_input_type: Enum to determine the Job Input Type.
               Expected value is 'literal'.
        :param builtins.str value: [Required] Literal value for the input.
        :param builtins.str description: Description for the input.
        """
        pulumi.set(__self__, "job_input_type", 'literal')
        pulumi.set(__self__, "value", value)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="jobInputType")
    def job_input_type(self) -> builtins.str:
        """
        Enum to determine the Job Input Type.
        Expected value is 'literal'.
        """
        return pulumi.get(self, "job_input_type")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        [Required] Literal value for the input.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description for the input.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class MLAssistConfigurationDisabledResponse(dict):
    """
    Labeling MLAssist configuration definition when MLAssist is disabled
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mlAssist":
            suggest = "ml_assist"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLAssistConfigurationDisabledResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLAssistConfigurationDisabledResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLAssistConfigurationDisabledResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ml_assist: builtins.str):
        """
        Labeling MLAssist configuration definition when MLAssist is disabled
        :param builtins.str ml_assist: 
               Expected value is 'Disabled'.
        """
        pulumi.set(__self__, "ml_assist", 'Disabled')

    @property
    @pulumi.getter(name="mlAssist")
    def ml_assist(self) -> builtins.str:
        """

        Expected value is 'Disabled'.
        """
        return pulumi.get(self, "ml_assist")


@pulumi.output_type
class MLAssistConfigurationEnabledResponse(dict):
    """
    Labeling MLAssist configuration definition when MLAssist is enabled
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inferencingComputeBinding":
            suggest = "inferencing_compute_binding"
        elif key == "mlAssist":
            suggest = "ml_assist"
        elif key == "trainingComputeBinding":
            suggest = "training_compute_binding"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLAssistConfigurationEnabledResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLAssistConfigurationEnabledResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLAssistConfigurationEnabledResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inferencing_compute_binding: builtins.str,
                 ml_assist: builtins.str,
                 training_compute_binding: builtins.str):
        """
        Labeling MLAssist configuration definition when MLAssist is enabled
        :param builtins.str inferencing_compute_binding: [Required] AML compute binding used in inferencing.
        :param builtins.str ml_assist: 
               Expected value is 'Enabled'.
        :param builtins.str training_compute_binding: [Required] AML compute binding used in training.
        """
        pulumi.set(__self__, "inferencing_compute_binding", inferencing_compute_binding)
        pulumi.set(__self__, "ml_assist", 'Enabled')
        pulumi.set(__self__, "training_compute_binding", training_compute_binding)

    @property
    @pulumi.getter(name="inferencingComputeBinding")
    def inferencing_compute_binding(self) -> builtins.str:
        """
        [Required] AML compute binding used in inferencing.
        """
        return pulumi.get(self, "inferencing_compute_binding")

    @property
    @pulumi.getter(name="mlAssist")
    def ml_assist(self) -> builtins.str:
        """

        Expected value is 'Enabled'.
        """
        return pulumi.get(self, "ml_assist")

    @property
    @pulumi.getter(name="trainingComputeBinding")
    def training_compute_binding(self) -> builtins.str:
        """
        [Required] AML compute binding used in training.
        """
        return pulumi.get(self, "training_compute_binding")


@pulumi.output_type
class MLFlowModelJobInputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobInputType":
            suggest = "job_input_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLFlowModelJobInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLFlowModelJobInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLFlowModelJobInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_input_type: builtins.str,
                 uri: builtins.str,
                 description: Optional[builtins.str] = None,
                 mode: Optional[builtins.str] = None):
        """
        :param builtins.str job_input_type: Enum to determine the Job Input Type.
               Expected value is 'mlflow_model'.
        :param builtins.str uri: [Required] Input Asset URI.
        :param builtins.str description: Description for the input.
        :param builtins.str mode: Input Asset Delivery Mode.
        """
        pulumi.set(__self__, "job_input_type", 'mlflow_model')
        pulumi.set(__self__, "uri", uri)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if mode is None:
            mode = 'ReadOnlyMount'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="jobInputType")
    def job_input_type(self) -> builtins.str:
        """
        Enum to determine the Job Input Type.
        Expected value is 'mlflow_model'.
        """
        return pulumi.get(self, "job_input_type")

    @property
    @pulumi.getter
    def uri(self) -> builtins.str:
        """
        [Required] Input Asset URI.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description for the input.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Input Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class MLFlowModelJobOutputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobOutputType":
            suggest = "job_output_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLFlowModelJobOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLFlowModelJobOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLFlowModelJobOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_output_type: builtins.str,
                 description: Optional[builtins.str] = None,
                 mode: Optional[builtins.str] = None,
                 uri: Optional[builtins.str] = None):
        """
        :param builtins.str job_output_type: Enum to determine the Job Output Type.
               Expected value is 'mlflow_model'.
        :param builtins.str description: Description for the output.
        :param builtins.str mode: Output Asset Delivery Mode.
        :param builtins.str uri: Output Asset URI.
        """
        pulumi.set(__self__, "job_output_type", 'mlflow_model')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if mode is None:
            mode = 'ReadWriteMount'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter(name="jobOutputType")
    def job_output_type(self) -> builtins.str:
        """
        Enum to determine the Job Output Type.
        Expected value is 'mlflow_model'.
        """
        return pulumi.get(self, "job_output_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description for the output.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Output Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def uri(self) -> Optional[builtins.str]:
        """
        Output Asset URI.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class MLTableDataResponse(dict):
    """
    MLTable data definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "dataUri":
            suggest = "data_uri"
        elif key == "isAnonymous":
            suggest = "is_anonymous"
        elif key == "isArchived":
            suggest = "is_archived"
        elif key == "referencedUris":
            suggest = "referenced_uris"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLTableDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLTableDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLTableDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: builtins.str,
                 data_uri: builtins.str,
                 description: Optional[builtins.str] = None,
                 is_anonymous: Optional[builtins.bool] = None,
                 is_archived: Optional[builtins.bool] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 referenced_uris: Optional[Sequence[builtins.str]] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        MLTable data definition
        :param builtins.str data_type: Enum to determine the type of data.
               Expected value is 'mltable'.
        :param builtins.str data_uri: [Required] Uri of the data. Example: https://go.microsoft.com/fwlink/?linkid=2202330
        :param builtins.str description: The asset description text.
        :param builtins.bool is_anonymous: If the name version are system generated (anonymous registration).
        :param builtins.bool is_archived: Is the asset archived?
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param Sequence[builtins.str] referenced_uris: Uris referenced in the MLTable definition (required for lineage)
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "data_type", 'mltable')
        pulumi.set(__self__, "data_uri", data_uri)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_anonymous is None:
            is_anonymous = False
        if is_anonymous is not None:
            pulumi.set(__self__, "is_anonymous", is_anonymous)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if referenced_uris is not None:
            pulumi.set(__self__, "referenced_uris", referenced_uris)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> builtins.str:
        """
        Enum to determine the type of data.
        Expected value is 'mltable'.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="dataUri")
    def data_uri(self) -> builtins.str:
        """
        [Required] Uri of the data. Example: https://go.microsoft.com/fwlink/?linkid=2202330
        """
        return pulumi.get(self, "data_uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[builtins.bool]:
        """
        If the name version are system generated (anonymous registration).
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="referencedUris")
    def referenced_uris(self) -> Optional[Sequence[builtins.str]]:
        """
        Uris referenced in the MLTable definition (required for lineage)
        """
        return pulumi.get(self, "referenced_uris")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class MLTableJobInputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobInputType":
            suggest = "job_input_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLTableJobInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLTableJobInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLTableJobInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_input_type: builtins.str,
                 uri: builtins.str,
                 description: Optional[builtins.str] = None,
                 mode: Optional[builtins.str] = None):
        """
        :param builtins.str job_input_type: Enum to determine the Job Input Type.
               Expected value is 'mltable'.
        :param builtins.str uri: [Required] Input Asset URI.
        :param builtins.str description: Description for the input.
        :param builtins.str mode: Input Asset Delivery Mode.
        """
        pulumi.set(__self__, "job_input_type", 'mltable')
        pulumi.set(__self__, "uri", uri)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if mode is None:
            mode = 'ReadOnlyMount'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="jobInputType")
    def job_input_type(self) -> builtins.str:
        """
        Enum to determine the Job Input Type.
        Expected value is 'mltable'.
        """
        return pulumi.get(self, "job_input_type")

    @property
    @pulumi.getter
    def uri(self) -> builtins.str:
        """
        [Required] Input Asset URI.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description for the input.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Input Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class MLTableJobOutputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobOutputType":
            suggest = "job_output_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLTableJobOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLTableJobOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLTableJobOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_output_type: builtins.str,
                 description: Optional[builtins.str] = None,
                 mode: Optional[builtins.str] = None,
                 uri: Optional[builtins.str] = None):
        """
        :param builtins.str job_output_type: Enum to determine the Job Output Type.
               Expected value is 'mltable'.
        :param builtins.str description: Description for the output.
        :param builtins.str mode: Output Asset Delivery Mode.
        :param builtins.str uri: Output Asset URI.
        """
        pulumi.set(__self__, "job_output_type", 'mltable')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if mode is None:
            mode = 'ReadWriteMount'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter(name="jobOutputType")
    def job_output_type(self) -> builtins.str:
        """
        Enum to determine the Job Output Type.
        Expected value is 'mltable'.
        """
        return pulumi.get(self, "job_output_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description for the output.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Output Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def uri(self) -> Optional[builtins.str]:
        """
        Output Asset URI.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class ManagedComputeIdentityResponse(dict):
    """
    Managed compute identity definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeIdentityType":
            suggest = "compute_identity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedComputeIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedComputeIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedComputeIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_identity_type: builtins.str,
                 identity: Optional['outputs.ManagedServiceIdentityResponse'] = None):
        """
        Managed compute identity definition.
        :param builtins.str compute_identity_type: Monitor compute identity type enum.
               Expected value is 'ManagedIdentity'.
        :param 'ManagedServiceIdentityResponse' identity: The identity which will be leveraged by the monitoring jobs.
        """
        pulumi.set(__self__, "compute_identity_type", 'ManagedIdentity')
        if identity is not None:
            pulumi.set(__self__, "identity", identity)

    @property
    @pulumi.getter(name="computeIdentityType")
    def compute_identity_type(self) -> builtins.str:
        """
        Monitor compute identity type enum.
        Expected value is 'ManagedIdentity'.
        """
        return pulumi.get(self, "compute_identity_type")

    @property
    @pulumi.getter
    def identity(self) -> Optional['outputs.ManagedServiceIdentityResponse']:
        """
        The identity which will be leveraged by the monitoring jobs.
        """
        return pulumi.get(self, "identity")


@pulumi.output_type
class ManagedIdentityAuthTypeWorkspaceConnectionPropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "createdByWorkspaceArmId":
            suggest = "created_by_workspace_arm_id"
        elif key == "expiryTime":
            suggest = "expiry_time"
        elif key == "isSharedToAll":
            suggest = "is_shared_to_all"
        elif key == "sharedUserList":
            suggest = "shared_user_list"
        elif key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedIdentityAuthTypeWorkspaceConnectionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedIdentityAuthTypeWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedIdentityAuthTypeWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: builtins.str,
                 created_by_workspace_arm_id: builtins.str,
                 group: builtins.str,
                 category: Optional[builtins.str] = None,
                 credentials: Optional['outputs.WorkspaceConnectionManagedIdentityResponse'] = None,
                 expiry_time: Optional[builtins.str] = None,
                 is_shared_to_all: Optional[builtins.bool] = None,
                 metadata: Optional[Mapping[str, builtins.str]] = None,
                 shared_user_list: Optional[Sequence[builtins.str]] = None,
                 target: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None,
                 value_format: Optional[builtins.str] = None):
        """
        :param builtins.str auth_type: Authentication type of the connection target
               Expected value is 'ManagedIdentity'.
        :param builtins.str group: Group based on connection category
        :param builtins.str category: Category of the connection
        :param Mapping[str, builtins.str] metadata: Store user metadata for this connection
        :param builtins.str value: Value details of the workspace connection.
        :param builtins.str value_format: format for the workspace connection value
        """
        pulumi.set(__self__, "auth_type", 'ManagedIdentity')
        pulumi.set(__self__, "created_by_workspace_arm_id", created_by_workspace_arm_id)
        pulumi.set(__self__, "group", group)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if expiry_time is not None:
            pulumi.set(__self__, "expiry_time", expiry_time)
        if is_shared_to_all is not None:
            pulumi.set(__self__, "is_shared_to_all", is_shared_to_all)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if shared_user_list is not None:
            pulumi.set(__self__, "shared_user_list", shared_user_list)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> builtins.str:
        """
        Authentication type of the connection target
        Expected value is 'ManagedIdentity'.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="createdByWorkspaceArmId")
    def created_by_workspace_arm_id(self) -> builtins.str:
        return pulumi.get(self, "created_by_workspace_arm_id")

    @property
    @pulumi.getter
    def group(self) -> builtins.str:
        """
        Group based on connection category
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def category(self) -> Optional[builtins.str]:
        """
        Category of the connection
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.WorkspaceConnectionManagedIdentityResponse']:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="expiryTime")
    def expiry_time(self) -> Optional[builtins.str]:
        return pulumi.get(self, "expiry_time")

    @property
    @pulumi.getter(name="isSharedToAll")
    def is_shared_to_all(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_shared_to_all")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Store user metadata for this connection
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="sharedUserList")
    def shared_user_list(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "shared_user_list")

    @property
    @pulumi.getter
    def target(self) -> Optional[builtins.str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value details of the workspace connection.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[builtins.str]:
        """
        format for the workspace connection value
        """
        return pulumi.get(self, "value_format")


@pulumi.output_type
class ManagedIdentityResponse(dict):
    """
    Managed identity configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityType":
            suggest = "identity_type"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_type: builtins.str,
                 client_id: Optional[builtins.str] = None,
                 object_id: Optional[builtins.str] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        Managed identity configuration.
        :param builtins.str identity_type: Enum to determine identity framework.
               Expected value is 'Managed'.
        :param builtins.str client_id: Specifies a user-assigned identity by client ID. For system-assigned, do not set this field.
        :param builtins.str object_id: Specifies a user-assigned identity by object ID. For system-assigned, do not set this field.
        :param builtins.str resource_id: Specifies a user-assigned identity by ARM resource ID. For system-assigned, do not set this field.
        """
        pulumi.set(__self__, "identity_type", 'Managed')
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="identityType")
    def identity_type(self) -> builtins.str:
        """
        Enum to determine identity framework.
        Expected value is 'Managed'.
        """
        return pulumi.get(self, "identity_type")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        Specifies a user-assigned identity by client ID. For system-assigned, do not set this field.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[builtins.str]:
        """
        Specifies a user-assigned identity by object ID. For system-assigned, do not set this field.
        """
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        Specifies a user-assigned identity by ARM resource ID. For system-assigned, do not set this field.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class ManagedNetworkProvisionStatusResponse(dict):
    """
    Status of the Provisioning for the managed network of a machine learning workspace.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sparkReady":
            suggest = "spark_ready"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedNetworkProvisionStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedNetworkProvisionStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedNetworkProvisionStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 spark_ready: Optional[builtins.bool] = None,
                 status: Optional[builtins.str] = None):
        """
        Status of the Provisioning for the managed network of a machine learning workspace.
        :param builtins.str status: Status for the managed network of a machine learning workspace.
        """
        if spark_ready is not None:
            pulumi.set(__self__, "spark_ready", spark_ready)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="sparkReady")
    def spark_ready(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "spark_ready")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Status for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ManagedNetworkSettingsResponse(dict):
    """
    Managed Network settings for a machine learning workspace.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "firewallSku":
            suggest = "firewall_sku"
        elif key == "isolationMode":
            suggest = "isolation_mode"
        elif key == "outboundRules":
            suggest = "outbound_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedNetworkSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedNetworkSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedNetworkSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: builtins.str,
                 firewall_sku: Optional[builtins.str] = None,
                 isolation_mode: Optional[builtins.str] = None,
                 outbound_rules: Optional[Mapping[str, Any]] = None,
                 status: Optional['outputs.ManagedNetworkProvisionStatusResponse'] = None):
        """
        Managed Network settings for a machine learning workspace.
        :param builtins.str firewall_sku: Firewall Sku used for FQDN Rules
        :param builtins.str isolation_mode: Isolation mode for the managed network of a machine learning workspace.
        :param 'ManagedNetworkProvisionStatusResponse' status: Status of the Provisioning for the managed network of a machine learning workspace.
        """
        pulumi.set(__self__, "network_id", network_id)
        if firewall_sku is not None:
            pulumi.set(__self__, "firewall_sku", firewall_sku)
        if isolation_mode is not None:
            pulumi.set(__self__, "isolation_mode", isolation_mode)
        if outbound_rules is not None:
            pulumi.set(__self__, "outbound_rules", outbound_rules)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> builtins.str:
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter(name="firewallSku")
    def firewall_sku(self) -> Optional[builtins.str]:
        """
        Firewall Sku used for FQDN Rules
        """
        return pulumi.get(self, "firewall_sku")

    @property
    @pulumi.getter(name="isolationMode")
    def isolation_mode(self) -> Optional[builtins.str]:
        """
        Isolation mode for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "isolation_mode")

    @property
    @pulumi.getter(name="outboundRules")
    def outbound_rules(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "outbound_rules")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.ManagedNetworkProvisionStatusResponse']:
        """
        Status of the Provisioning for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ManagedOnlineDeploymentResponse(dict):
    """
    Properties specific to a ManagedOnlineDeployment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointComputeType":
            suggest = "endpoint_compute_type"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "appInsightsEnabled":
            suggest = "app_insights_enabled"
        elif key == "codeConfiguration":
            suggest = "code_configuration"
        elif key == "dataCollector":
            suggest = "data_collector"
        elif key == "egressPublicNetworkAccess":
            suggest = "egress_public_network_access"
        elif key == "environmentId":
            suggest = "environment_id"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "livenessProbe":
            suggest = "liveness_probe"
        elif key == "modelMountPath":
            suggest = "model_mount_path"
        elif key == "readinessProbe":
            suggest = "readiness_probe"
        elif key == "requestSettings":
            suggest = "request_settings"
        elif key == "scaleSettings":
            suggest = "scale_settings"
        elif key == "startupProbe":
            suggest = "startup_probe"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedOnlineDeploymentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedOnlineDeploymentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedOnlineDeploymentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_compute_type: builtins.str,
                 provisioning_state: builtins.str,
                 app_insights_enabled: Optional[builtins.bool] = None,
                 code_configuration: Optional['outputs.CodeConfigurationResponse'] = None,
                 data_collector: Optional['outputs.DataCollectorResponse'] = None,
                 description: Optional[builtins.str] = None,
                 egress_public_network_access: Optional[builtins.str] = None,
                 environment_id: Optional[builtins.str] = None,
                 environment_variables: Optional[Mapping[str, builtins.str]] = None,
                 instance_type: Optional[builtins.str] = None,
                 liveness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
                 model: Optional[builtins.str] = None,
                 model_mount_path: Optional[builtins.str] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 readiness_probe: Optional['outputs.ProbeSettingsResponse'] = None,
                 request_settings: Optional['outputs.OnlineRequestSettingsResponse'] = None,
                 scale_settings: Optional[Any] = None,
                 startup_probe: Optional['outputs.ProbeSettingsResponse'] = None):
        """
        Properties specific to a ManagedOnlineDeployment.
        :param builtins.str endpoint_compute_type: Enum to determine endpoint compute type.
               Expected value is 'Managed'.
        :param builtins.str provisioning_state: Provisioning state for the endpoint deployment.
        :param builtins.bool app_insights_enabled: If true, enables Application Insights logging.
        :param 'CodeConfigurationResponse' code_configuration: Code configuration for the endpoint deployment.
        :param 'DataCollectorResponse' data_collector: The mdc configuration, we disable mdc when it's null.
        :param builtins.str description: Description of the endpoint deployment.
        :param builtins.str egress_public_network_access: If Enabled, allow egress public network access. If Disabled, this will create secure egress. Default: Enabled.
        :param builtins.str environment_id: ARM resource ID or AssetId of the environment specification for the endpoint deployment.
        :param Mapping[str, builtins.str] environment_variables: Environment variables configuration for the deployment.
        :param builtins.str instance_type: Compute instance type. Default: Standard_F4s_v2.
        :param 'ProbeSettingsResponse' liveness_probe: Liveness probe monitors the health of the container regularly.
        :param builtins.str model: The URI path to the model.
        :param builtins.str model_mount_path: The path to mount the model in custom container.
        :param Mapping[str, builtins.str] properties: Property dictionary. Properties can be added, but not removed or altered.
        :param 'ProbeSettingsResponse' readiness_probe: Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
        :param 'OnlineRequestSettingsResponse' request_settings: Request settings for the deployment.
        :param Union['DefaultScaleSettingsResponse', 'TargetUtilizationScaleSettingsResponse'] scale_settings: Scale settings for the deployment.
               If it is null or not provided,
               it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
               and to DefaultScaleSettings for ManagedOnlineDeployment.
        :param 'ProbeSettingsResponse' startup_probe: Startup probe verify whether an application within a container has started successfully.
        """
        pulumi.set(__self__, "endpoint_compute_type", 'Managed')
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if app_insights_enabled is None:
            app_insights_enabled = False
        if app_insights_enabled is not None:
            pulumi.set(__self__, "app_insights_enabled", app_insights_enabled)
        if code_configuration is not None:
            pulumi.set(__self__, "code_configuration", code_configuration)
        if data_collector is not None:
            pulumi.set(__self__, "data_collector", data_collector)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if egress_public_network_access is None:
            egress_public_network_access = 'Enabled'
        if egress_public_network_access is not None:
            pulumi.set(__self__, "egress_public_network_access", egress_public_network_access)
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if instance_type is None:
            instance_type = 'Standard_F4s_v2'
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if model_mount_path is not None:
            pulumi.set(__self__, "model_mount_path", model_mount_path)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if request_settings is not None:
            pulumi.set(__self__, "request_settings", request_settings)
        if scale_settings is not None:
            pulumi.set(__self__, "scale_settings", scale_settings)
        if startup_probe is not None:
            pulumi.set(__self__, "startup_probe", startup_probe)

    @property
    @pulumi.getter(name="endpointComputeType")
    def endpoint_compute_type(self) -> builtins.str:
        """
        Enum to determine endpoint compute type.
        Expected value is 'Managed'.
        """
        return pulumi.get(self, "endpoint_compute_type")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the endpoint deployment.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="appInsightsEnabled")
    def app_insights_enabled(self) -> Optional[builtins.bool]:
        """
        If true, enables Application Insights logging.
        """
        return pulumi.get(self, "app_insights_enabled")

    @property
    @pulumi.getter(name="codeConfiguration")
    def code_configuration(self) -> Optional['outputs.CodeConfigurationResponse']:
        """
        Code configuration for the endpoint deployment.
        """
        return pulumi.get(self, "code_configuration")

    @property
    @pulumi.getter(name="dataCollector")
    def data_collector(self) -> Optional['outputs.DataCollectorResponse']:
        """
        The mdc configuration, we disable mdc when it's null.
        """
        return pulumi.get(self, "data_collector")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description of the endpoint deployment.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="egressPublicNetworkAccess")
    def egress_public_network_access(self) -> Optional[builtins.str]:
        """
        If Enabled, allow egress public network access. If Disabled, this will create secure egress. Default: Enabled.
        """
        return pulumi.get(self, "egress_public_network_access")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID or AssetId of the environment specification for the endpoint deployment.
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Environment variables configuration for the deployment.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[builtins.str]:
        """
        Compute instance type. Default: Standard_F4s_v2.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.ProbeSettingsResponse']:
        """
        Liveness probe monitors the health of the container regularly.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def model(self) -> Optional[builtins.str]:
        """
        The URI path to the model.
        """
        return pulumi.get(self, "model")

    @property
    @pulumi.getter(name="modelMountPath")
    def model_mount_path(self) -> Optional[builtins.str]:
        """
        The path to mount the model in custom container.
        """
        return pulumi.get(self, "model_mount_path")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.ProbeSettingsResponse']:
        """
        Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter(name="requestSettings")
    def request_settings(self) -> Optional['outputs.OnlineRequestSettingsResponse']:
        """
        Request settings for the deployment.
        """
        return pulumi.get(self, "request_settings")

    @property
    @pulumi.getter(name="scaleSettings")
    def scale_settings(self) -> Optional[Any]:
        """
        Scale settings for the deployment.
        If it is null or not provided,
        it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
        and to DefaultScaleSettings for ManagedOnlineDeployment.
        """
        return pulumi.get(self, "scale_settings")

    @property
    @pulumi.getter(name="startupProbe")
    def startup_probe(self) -> Optional['outputs.ProbeSettingsResponse']:
        """
        Startup probe verify whether an application within a container has started successfully.
        """
        return pulumi.get(self, "startup_probe")


@pulumi.output_type
class ManagedOnlineEndpointDeploymentResourcePropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "endpointComputeType":
            suggest = "endpoint_compute_type"
        elif key == "failureReason":
            suggest = "failure_reason"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedOnlineEndpointDeploymentResourcePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedOnlineEndpointDeploymentResourcePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedOnlineEndpointDeploymentResourcePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 type: builtins.str,
                 endpoint_compute_type: Optional[builtins.str] = None,
                 failure_reason: Optional[builtins.str] = None,
                 model: Optional[builtins.str] = None):
        """
        :param builtins.str provisioning_state: Read-only provision state status property.
        :param builtins.str type: Kind of the deployment.
               Expected value is 'managedOnlineEndpoint'.
        :param builtins.str failure_reason: The failure reason if the creation failed.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "type", 'managedOnlineEndpoint')
        if endpoint_compute_type is not None:
            pulumi.set(__self__, "endpoint_compute_type", endpoint_compute_type)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if model is not None:
            pulumi.set(__self__, "model", model)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Read-only provision state status property.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Kind of the deployment.
        Expected value is 'managedOnlineEndpoint'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="endpointComputeType")
    def endpoint_compute_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "endpoint_compute_type")

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[builtins.str]:
        """
        The failure reason if the creation failed.
        """
        return pulumi.get(self, "failure_reason")

    @property
    @pulumi.getter
    def model(self) -> Optional[builtins.str]:
        return pulumi.get(self, "model")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity (system assigned and/or user assigned identities)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: builtins.str,
                 tenant_id: builtins.str,
                 type: builtins.str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param builtins.str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param builtins.str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param builtins.str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> builtins.str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> builtins.str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class MarketplacePlanResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offerId":
            suggest = "offer_id"
        elif key == "planId":
            suggest = "plan_id"
        elif key == "publisherId":
            suggest = "publisher_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MarketplacePlanResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MarketplacePlanResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MarketplacePlanResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 offer_id: builtins.str,
                 plan_id: builtins.str,
                 publisher_id: builtins.str):
        """
        :param builtins.str offer_id: The identifying name of the Offer of the Marketplace Plan.
        :param builtins.str plan_id: The identifying name of the Plan of the Marketplace Plan.
        :param builtins.str publisher_id: The identifying name of the Publisher of the Marketplace Plan.
        """
        pulumi.set(__self__, "offer_id", offer_id)
        pulumi.set(__self__, "plan_id", plan_id)
        pulumi.set(__self__, "publisher_id", publisher_id)

    @property
    @pulumi.getter(name="offerId")
    def offer_id(self) -> builtins.str:
        """
        The identifying name of the Offer of the Marketplace Plan.
        """
        return pulumi.get(self, "offer_id")

    @property
    @pulumi.getter(name="planId")
    def plan_id(self) -> builtins.str:
        """
        The identifying name of the Plan of the Marketplace Plan.
        """
        return pulumi.get(self, "plan_id")

    @property
    @pulumi.getter(name="publisherId")
    def publisher_id(self) -> builtins.str:
        """
        The identifying name of the Publisher of the Marketplace Plan.
        """
        return pulumi.get(self, "publisher_id")


@pulumi.output_type
class MarketplaceSubscriptionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "marketplacePlan":
            suggest = "marketplace_plan"
        elif key == "marketplaceSubscriptionStatus":
            suggest = "marketplace_subscription_status"
        elif key == "modelId":
            suggest = "model_id"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MarketplaceSubscriptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MarketplaceSubscriptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MarketplaceSubscriptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 marketplace_plan: 'outputs.MarketplacePlanResponse',
                 marketplace_subscription_status: builtins.str,
                 model_id: builtins.str,
                 provisioning_state: builtins.str):
        """
        :param 'MarketplacePlanResponse' marketplace_plan: Marketplace Plan associated with the Marketplace Subscription.
        :param builtins.str marketplace_subscription_status: Current status of the Marketplace Subscription.
        :param builtins.str model_id: [Required] Target Marketplace Model ID to create a Marketplace Subscription for.
        :param builtins.str provisioning_state: Provisioning State of the Marketplace Subscription.
        """
        pulumi.set(__self__, "marketplace_plan", marketplace_plan)
        pulumi.set(__self__, "marketplace_subscription_status", marketplace_subscription_status)
        pulumi.set(__self__, "model_id", model_id)
        pulumi.set(__self__, "provisioning_state", provisioning_state)

    @property
    @pulumi.getter(name="marketplacePlan")
    def marketplace_plan(self) -> 'outputs.MarketplacePlanResponse':
        """
        Marketplace Plan associated with the Marketplace Subscription.
        """
        return pulumi.get(self, "marketplace_plan")

    @property
    @pulumi.getter(name="marketplaceSubscriptionStatus")
    def marketplace_subscription_status(self) -> builtins.str:
        """
        Current status of the Marketplace Subscription.
        """
        return pulumi.get(self, "marketplace_subscription_status")

    @property
    @pulumi.getter(name="modelId")
    def model_id(self) -> builtins.str:
        """
        [Required] Target Marketplace Model ID to create a Marketplace Subscription for.
        """
        return pulumi.get(self, "model_id")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning State of the Marketplace Subscription.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class MaterializationComputeResourceResponse(dict):
    """
    DTO object representing compute resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceType":
            suggest = "instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaterializationComputeResourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaterializationComputeResourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaterializationComputeResourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_type: Optional[builtins.str] = None):
        """
        DTO object representing compute resource
        :param builtins.str instance_type: Specifies the instance type
        """
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[builtins.str]:
        """
        Specifies the instance type
        """
        return pulumi.get(self, "instance_type")


@pulumi.output_type
class MaterializationSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sparkConfiguration":
            suggest = "spark_configuration"
        elif key == "storeType":
            suggest = "store_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaterializationSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaterializationSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaterializationSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notification: Optional['outputs.NotificationSettingResponse'] = None,
                 resource: Optional['outputs.MaterializationComputeResourceResponse'] = None,
                 schedule: Optional['outputs.RecurrenceTriggerResponse'] = None,
                 spark_configuration: Optional[Mapping[str, builtins.str]] = None,
                 store_type: Optional[builtins.str] = None):
        """
        :param 'NotificationSettingResponse' notification: Specifies the notification details
        :param 'MaterializationComputeResourceResponse' resource: Specifies the compute resource settings
        :param 'RecurrenceTriggerResponse' schedule: Specifies the schedule details
        :param Mapping[str, builtins.str] spark_configuration: Specifies the spark compute settings
        :param builtins.str store_type: Specifies the stores to which materialization should happen
        """
        if notification is not None:
            pulumi.set(__self__, "notification", notification)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if spark_configuration is not None:
            pulumi.set(__self__, "spark_configuration", spark_configuration)
        if store_type is None:
            store_type = 'None'
        if store_type is not None:
            pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter
    def notification(self) -> Optional['outputs.NotificationSettingResponse']:
        """
        Specifies the notification details
        """
        return pulumi.get(self, "notification")

    @property
    @pulumi.getter
    def resource(self) -> Optional['outputs.MaterializationComputeResourceResponse']:
        """
        Specifies the compute resource settings
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def schedule(self) -> Optional['outputs.RecurrenceTriggerResponse']:
        """
        Specifies the schedule details
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="sparkConfiguration")
    def spark_configuration(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Specifies the spark compute settings
        """
        return pulumi.get(self, "spark_configuration")

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> Optional[builtins.str]:
        """
        Specifies the stores to which materialization should happen
        """
        return pulumi.get(self, "store_type")


@pulumi.output_type
class MedianStoppingPolicyResponse(dict):
    """
    Defines an early termination policy based on running averages of the primary metric of all runs
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyType":
            suggest = "policy_type"
        elif key == "delayEvaluation":
            suggest = "delay_evaluation"
        elif key == "evaluationInterval":
            suggest = "evaluation_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MedianStoppingPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MedianStoppingPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MedianStoppingPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_type: builtins.str,
                 delay_evaluation: Optional[builtins.int] = None,
                 evaluation_interval: Optional[builtins.int] = None):
        """
        Defines an early termination policy based on running averages of the primary metric of all runs
        :param builtins.str policy_type: 
               Expected value is 'MedianStopping'.
        :param builtins.int delay_evaluation: Number of intervals by which to delay the first evaluation.
        :param builtins.int evaluation_interval: Interval (number of runs) between policy evaluations.
        """
        pulumi.set(__self__, "policy_type", 'MedianStopping')
        if delay_evaluation is None:
            delay_evaluation = 0
        if delay_evaluation is not None:
            pulumi.set(__self__, "delay_evaluation", delay_evaluation)
        if evaluation_interval is None:
            evaluation_interval = 0
        if evaluation_interval is not None:
            pulumi.set(__self__, "evaluation_interval", evaluation_interval)

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> builtins.str:
        """

        Expected value is 'MedianStopping'.
        """
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="delayEvaluation")
    def delay_evaluation(self) -> Optional[builtins.int]:
        """
        Number of intervals by which to delay the first evaluation.
        """
        return pulumi.get(self, "delay_evaluation")

    @property
    @pulumi.getter(name="evaluationInterval")
    def evaluation_interval(self) -> Optional[builtins.int]:
        """
        Interval (number of runs) between policy evaluations.
        """
        return pulumi.get(self, "evaluation_interval")


@pulumi.output_type
class ModelContainerResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latestVersion":
            suggest = "latest_version"
        elif key == "nextVersion":
            suggest = "next_version"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelContainerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelContainerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelContainerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latest_version: builtins.str,
                 next_version: builtins.str,
                 provisioning_state: builtins.str,
                 description: Optional[builtins.str] = None,
                 is_archived: Optional[builtins.bool] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        :param builtins.str latest_version: The latest version inside this container.
        :param builtins.str next_version: The next auto incremental version
        :param builtins.str provisioning_state: Provisioning state for the model container.
        :param builtins.str description: The asset description text.
        :param builtins.bool is_archived: Is the asset archived?
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "latest_version", latest_version)
        pulumi.set(__self__, "next_version", next_version)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> builtins.str:
        """
        The latest version inside this container.
        """
        return pulumi.get(self, "latest_version")

    @property
    @pulumi.getter(name="nextVersion")
    def next_version(self) -> builtins.str:
        """
        The next auto incremental version
        """
        return pulumi.get(self, "next_version")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the model container.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ModelSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelId":
            suggest = "model_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model_id: Optional[builtins.str] = None):
        """
        :param builtins.str model_id: The unique model identifier that this ServerlessEndpoint should provision.
        """
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)

    @property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[builtins.str]:
        """
        The unique model identifier that this ServerlessEndpoint should provision.
        """
        return pulumi.get(self, "model_id")


@pulumi.output_type
class ModelVersionResponse(dict):
    """
    Model asset version details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "isAnonymous":
            suggest = "is_anonymous"
        elif key == "isArchived":
            suggest = "is_archived"
        elif key == "jobName":
            suggest = "job_name"
        elif key == "modelType":
            suggest = "model_type"
        elif key == "modelUri":
            suggest = "model_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 description: Optional[builtins.str] = None,
                 flavors: Optional[Mapping[str, 'outputs.FlavorDataResponse']] = None,
                 is_anonymous: Optional[builtins.bool] = None,
                 is_archived: Optional[builtins.bool] = None,
                 job_name: Optional[builtins.str] = None,
                 model_type: Optional[builtins.str] = None,
                 model_uri: Optional[builtins.str] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 stage: Optional[builtins.str] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Model asset version details.
        :param builtins.str provisioning_state: Provisioning state for the model version.
        :param builtins.str description: The asset description text.
        :param Mapping[str, 'FlavorDataResponse'] flavors: Mapping of model flavors to their properties.
        :param builtins.bool is_anonymous: If the name version are system generated (anonymous registration).
        :param builtins.bool is_archived: Is the asset archived?
        :param builtins.str job_name: Name of the training job which produced this model
        :param builtins.str model_type: The storage format for this entity. Used for NCD.
        :param builtins.str model_uri: The URI path to the model contents.
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param builtins.str stage: Stage in the model lifecycle assigned to this model
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if flavors is not None:
            pulumi.set(__self__, "flavors", flavors)
        if is_anonymous is None:
            is_anonymous = False
        if is_anonymous is not None:
            pulumi.set(__self__, "is_anonymous", is_anonymous)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if job_name is not None:
            pulumi.set(__self__, "job_name", job_name)
        if model_type is not None:
            pulumi.set(__self__, "model_type", model_type)
        if model_uri is not None:
            pulumi.set(__self__, "model_uri", model_uri)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if stage is not None:
            pulumi.set(__self__, "stage", stage)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the model version.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def flavors(self) -> Optional[Mapping[str, 'outputs.FlavorDataResponse']]:
        """
        Mapping of model flavors to their properties.
        """
        return pulumi.get(self, "flavors")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[builtins.bool]:
        """
        If the name version are system generated (anonymous registration).
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter(name="jobName")
    def job_name(self) -> Optional[builtins.str]:
        """
        Name of the training job which produced this model
        """
        return pulumi.get(self, "job_name")

    @property
    @pulumi.getter(name="modelType")
    def model_type(self) -> Optional[builtins.str]:
        """
        The storage format for this entity. Used for NCD.
        """
        return pulumi.get(self, "model_type")

    @property
    @pulumi.getter(name="modelUri")
    def model_uri(self) -> Optional[builtins.str]:
        """
        The URI path to the model contents.
        """
        return pulumi.get(self, "model_uri")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def stage(self) -> Optional[builtins.str]:
        """
        Stage in the model lifecycle assigned to this model
        """
        return pulumi.get(self, "stage")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class MonitorDefinitionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeConfiguration":
            suggest = "compute_configuration"
        elif key == "alertNotificationSettings":
            suggest = "alert_notification_settings"
        elif key == "monitoringTarget":
            suggest = "monitoring_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_configuration: 'outputs.MonitorServerlessSparkComputeResponse',
                 signals: Mapping[str, Any],
                 alert_notification_settings: Optional['outputs.MonitorNotificationSettingsResponse'] = None,
                 monitoring_target: Optional['outputs.MonitoringTargetResponse'] = None):
        """
        :param 'MonitorServerlessSparkComputeResponse' compute_configuration: [Required] The ARM resource ID of the compute resource to run the monitoring job on.
        :param Mapping[str, Union['CustomMonitoringSignalResponse', 'DataDriftMonitoringSignalResponse', 'DataQualityMonitoringSignalResponse', 'FeatureAttributionDriftMonitoringSignalResponse', 'PredictionDriftMonitoringSignalResponse']] signals: [Required] The signals to monitor.
        :param 'MonitorNotificationSettingsResponse' alert_notification_settings: The monitor's notification settings.
        :param 'MonitoringTargetResponse' monitoring_target: The entities targeted by the monitor.
        """
        pulumi.set(__self__, "compute_configuration", compute_configuration)
        pulumi.set(__self__, "signals", signals)
        if alert_notification_settings is not None:
            pulumi.set(__self__, "alert_notification_settings", alert_notification_settings)
        if monitoring_target is not None:
            pulumi.set(__self__, "monitoring_target", monitoring_target)

    @property
    @pulumi.getter(name="computeConfiguration")
    def compute_configuration(self) -> 'outputs.MonitorServerlessSparkComputeResponse':
        """
        [Required] The ARM resource ID of the compute resource to run the monitoring job on.
        """
        return pulumi.get(self, "compute_configuration")

    @property
    @pulumi.getter
    def signals(self) -> Mapping[str, Any]:
        """
        [Required] The signals to monitor.
        """
        return pulumi.get(self, "signals")

    @property
    @pulumi.getter(name="alertNotificationSettings")
    def alert_notification_settings(self) -> Optional['outputs.MonitorNotificationSettingsResponse']:
        """
        The monitor's notification settings.
        """
        return pulumi.get(self, "alert_notification_settings")

    @property
    @pulumi.getter(name="monitoringTarget")
    def monitoring_target(self) -> Optional['outputs.MonitoringTargetResponse']:
        """
        The entities targeted by the monitor.
        """
        return pulumi.get(self, "monitoring_target")


@pulumi.output_type
class MonitorEmailNotificationSettingsResponse(dict):
    def __init__(__self__, *,
                 emails: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] emails: The email recipient list which has a limitation of 499 characters in total.
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[builtins.str]]:
        """
        The email recipient list which has a limitation of 499 characters in total.
        """
        return pulumi.get(self, "emails")


@pulumi.output_type
class MonitorNotificationSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailNotificationSettings":
            suggest = "email_notification_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorNotificationSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorNotificationSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorNotificationSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_notification_settings: Optional['outputs.MonitorEmailNotificationSettingsResponse'] = None):
        """
        :param 'MonitorEmailNotificationSettingsResponse' email_notification_settings: The AML notification email settings.
        """
        if email_notification_settings is not None:
            pulumi.set(__self__, "email_notification_settings", email_notification_settings)

    @property
    @pulumi.getter(name="emailNotificationSettings")
    def email_notification_settings(self) -> Optional['outputs.MonitorEmailNotificationSettingsResponse']:
        """
        The AML notification email settings.
        """
        return pulumi.get(self, "email_notification_settings")


@pulumi.output_type
class MonitorServerlessSparkComputeResponse(dict):
    """
    Monitor serverless spark compute definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeIdentity":
            suggest = "compute_identity"
        elif key == "computeType":
            suggest = "compute_type"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "runtimeVersion":
            suggest = "runtime_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorServerlessSparkComputeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorServerlessSparkComputeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorServerlessSparkComputeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_identity: Any,
                 compute_type: builtins.str,
                 instance_type: builtins.str,
                 runtime_version: builtins.str):
        """
        Monitor serverless spark compute definition.
        :param Union['AmlTokenComputeIdentityResponse', 'ManagedComputeIdentityResponse'] compute_identity: [Required] The identity scheme leveraged to by the spark jobs running on serverless Spark.
        :param builtins.str compute_type: Monitor compute type enum.
               Expected value is 'ServerlessSpark'.
        :param builtins.str instance_type: [Required] The instance type running the Spark job.
        :param builtins.str runtime_version: [Required] The Spark runtime version.
        """
        pulumi.set(__self__, "compute_identity", compute_identity)
        pulumi.set(__self__, "compute_type", 'ServerlessSpark')
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "runtime_version", runtime_version)

    @property
    @pulumi.getter(name="computeIdentity")
    def compute_identity(self) -> Any:
        """
        [Required] The identity scheme leveraged to by the spark jobs running on serverless Spark.
        """
        return pulumi.get(self, "compute_identity")

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> builtins.str:
        """
        Monitor compute type enum.
        Expected value is 'ServerlessSpark'.
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> builtins.str:
        """
        [Required] The instance type running the Spark job.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> builtins.str:
        """
        [Required] The Spark runtime version.
        """
        return pulumi.get(self, "runtime_version")


@pulumi.output_type
class MonitoringTargetResponse(dict):
    """
    Monitoring target definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "deploymentId":
            suggest = "deployment_id"
        elif key == "modelId":
            suggest = "model_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoringTargetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoringTargetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoringTargetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 task_type: builtins.str,
                 deployment_id: Optional[builtins.str] = None,
                 model_id: Optional[builtins.str] = None):
        """
        Monitoring target definition.
        :param builtins.str task_type: [Required] The machine learning task type of the monitored model.
        :param builtins.str deployment_id: Reference to the deployment asset targeted by this monitor.
        :param builtins.str model_id: Reference to the model asset targeted by this monitor.
        """
        pulumi.set(__self__, "task_type", task_type)
        if deployment_id is not None:
            pulumi.set(__self__, "deployment_id", deployment_id)
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> builtins.str:
        """
        [Required] The machine learning task type of the monitored model.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> Optional[builtins.str]:
        """
        Reference to the deployment asset targeted by this monitor.
        """
        return pulumi.get(self, "deployment_id")

    @property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[builtins.str]:
        """
        Reference to the model asset targeted by this monitor.
        """
        return pulumi.get(self, "model_id")


@pulumi.output_type
class MonitoringThresholdResponse(dict):
    def __init__(__self__, *,
                 value: Optional[builtins.float] = None):
        """
        :param builtins.float value: The threshold value. If null, the set default is dependent on the metric type.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.float]:
        """
        The threshold value. If null, the set default is dependent on the metric type.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class MpiResponse(dict):
    """
    MPI distribution configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "distributionType":
            suggest = "distribution_type"
        elif key == "processCountPerInstance":
            suggest = "process_count_per_instance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MpiResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MpiResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MpiResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 distribution_type: builtins.str,
                 process_count_per_instance: Optional[builtins.int] = None):
        """
        MPI distribution configuration.
        :param builtins.str distribution_type: Enum to determine the job distribution type.
               Expected value is 'Mpi'.
        :param builtins.int process_count_per_instance: Number of processes per MPI node.
        """
        pulumi.set(__self__, "distribution_type", 'Mpi')
        if process_count_per_instance is not None:
            pulumi.set(__self__, "process_count_per_instance", process_count_per_instance)

    @property
    @pulumi.getter(name="distributionType")
    def distribution_type(self) -> builtins.str:
        """
        Enum to determine the job distribution type.
        Expected value is 'Mpi'.
        """
        return pulumi.get(self, "distribution_type")

    @property
    @pulumi.getter(name="processCountPerInstance")
    def process_count_per_instance(self) -> Optional[builtins.int]:
        """
        Number of processes per MPI node.
        """
        return pulumi.get(self, "process_count_per_instance")


@pulumi.output_type
class NlpVerticalFeaturizationSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetLanguage":
            suggest = "dataset_language"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NlpVerticalFeaturizationSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NlpVerticalFeaturizationSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NlpVerticalFeaturizationSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_language: Optional[builtins.str] = None):
        """
        :param builtins.str dataset_language: Dataset language, useful for the text data.
        """
        if dataset_language is not None:
            pulumi.set(__self__, "dataset_language", dataset_language)

    @property
    @pulumi.getter(name="datasetLanguage")
    def dataset_language(self) -> Optional[builtins.str]:
        """
        Dataset language, useful for the text data.
        """
        return pulumi.get(self, "dataset_language")


@pulumi.output_type
class NlpVerticalLimitSettingsResponse(dict):
    """
    Job execution constraints.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentTrials":
            suggest = "max_concurrent_trials"
        elif key == "maxTrials":
            suggest = "max_trials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NlpVerticalLimitSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NlpVerticalLimitSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NlpVerticalLimitSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_trials: Optional[builtins.int] = None,
                 max_trials: Optional[builtins.int] = None,
                 timeout: Optional[builtins.str] = None):
        """
        Job execution constraints.
        :param builtins.int max_concurrent_trials: Maximum Concurrent AutoML iterations.
        :param builtins.int max_trials: Number of AutoML iterations.
        :param builtins.str timeout: AutoML job timeout.
        """
        if max_concurrent_trials is None:
            max_concurrent_trials = 1
        if max_concurrent_trials is not None:
            pulumi.set(__self__, "max_concurrent_trials", max_concurrent_trials)
        if max_trials is None:
            max_trials = 1
        if max_trials is not None:
            pulumi.set(__self__, "max_trials", max_trials)
        if timeout is None:
            timeout = 'P7D'
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="maxConcurrentTrials")
    def max_concurrent_trials(self) -> Optional[builtins.int]:
        """
        Maximum Concurrent AutoML iterations.
        """
        return pulumi.get(self, "max_concurrent_trials")

    @property
    @pulumi.getter(name="maxTrials")
    def max_trials(self) -> Optional[builtins.int]:
        """
        Number of AutoML iterations.
        """
        return pulumi.get(self, "max_trials")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[builtins.str]:
        """
        AutoML job timeout.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class NodeStateCountsResponse(dict):
    """
    Counts of various compute node states on the amlCompute.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "idleNodeCount":
            suggest = "idle_node_count"
        elif key == "leavingNodeCount":
            suggest = "leaving_node_count"
        elif key == "preemptedNodeCount":
            suggest = "preempted_node_count"
        elif key == "preparingNodeCount":
            suggest = "preparing_node_count"
        elif key == "runningNodeCount":
            suggest = "running_node_count"
        elif key == "unusableNodeCount":
            suggest = "unusable_node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeStateCountsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeStateCountsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeStateCountsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 idle_node_count: builtins.int,
                 leaving_node_count: builtins.int,
                 preempted_node_count: builtins.int,
                 preparing_node_count: builtins.int,
                 running_node_count: builtins.int,
                 unusable_node_count: builtins.int):
        """
        Counts of various compute node states on the amlCompute.
        :param builtins.int idle_node_count: Number of compute nodes in idle state.
        :param builtins.int leaving_node_count: Number of compute nodes which are leaving the amlCompute.
        :param builtins.int preempted_node_count: Number of compute nodes which are in preempted state.
        :param builtins.int preparing_node_count: Number of compute nodes which are being prepared.
        :param builtins.int running_node_count: Number of compute nodes which are running jobs.
        :param builtins.int unusable_node_count: Number of compute nodes which are in unusable state.
        """
        pulumi.set(__self__, "idle_node_count", idle_node_count)
        pulumi.set(__self__, "leaving_node_count", leaving_node_count)
        pulumi.set(__self__, "preempted_node_count", preempted_node_count)
        pulumi.set(__self__, "preparing_node_count", preparing_node_count)
        pulumi.set(__self__, "running_node_count", running_node_count)
        pulumi.set(__self__, "unusable_node_count", unusable_node_count)

    @property
    @pulumi.getter(name="idleNodeCount")
    def idle_node_count(self) -> builtins.int:
        """
        Number of compute nodes in idle state.
        """
        return pulumi.get(self, "idle_node_count")

    @property
    @pulumi.getter(name="leavingNodeCount")
    def leaving_node_count(self) -> builtins.int:
        """
        Number of compute nodes which are leaving the amlCompute.
        """
        return pulumi.get(self, "leaving_node_count")

    @property
    @pulumi.getter(name="preemptedNodeCount")
    def preempted_node_count(self) -> builtins.int:
        """
        Number of compute nodes which are in preempted state.
        """
        return pulumi.get(self, "preempted_node_count")

    @property
    @pulumi.getter(name="preparingNodeCount")
    def preparing_node_count(self) -> builtins.int:
        """
        Number of compute nodes which are being prepared.
        """
        return pulumi.get(self, "preparing_node_count")

    @property
    @pulumi.getter(name="runningNodeCount")
    def running_node_count(self) -> builtins.int:
        """
        Number of compute nodes which are running jobs.
        """
        return pulumi.get(self, "running_node_count")

    @property
    @pulumi.getter(name="unusableNodeCount")
    def unusable_node_count(self) -> builtins.int:
        """
        Number of compute nodes which are in unusable state.
        """
        return pulumi.get(self, "unusable_node_count")


@pulumi.output_type
class NoneAuthTypeWorkspaceConnectionPropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "createdByWorkspaceArmId":
            suggest = "created_by_workspace_arm_id"
        elif key == "expiryTime":
            suggest = "expiry_time"
        elif key == "isSharedToAll":
            suggest = "is_shared_to_all"
        elif key == "sharedUserList":
            suggest = "shared_user_list"
        elif key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NoneAuthTypeWorkspaceConnectionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NoneAuthTypeWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NoneAuthTypeWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: builtins.str,
                 created_by_workspace_arm_id: builtins.str,
                 group: builtins.str,
                 category: Optional[builtins.str] = None,
                 expiry_time: Optional[builtins.str] = None,
                 is_shared_to_all: Optional[builtins.bool] = None,
                 metadata: Optional[Mapping[str, builtins.str]] = None,
                 shared_user_list: Optional[Sequence[builtins.str]] = None,
                 target: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None,
                 value_format: Optional[builtins.str] = None):
        """
        :param builtins.str auth_type: Authentication type of the connection target
               Expected value is 'None'.
        :param builtins.str group: Group based on connection category
        :param builtins.str category: Category of the connection
        :param Mapping[str, builtins.str] metadata: Store user metadata for this connection
        :param builtins.str value: Value details of the workspace connection.
        :param builtins.str value_format: format for the workspace connection value
        """
        pulumi.set(__self__, "auth_type", 'None')
        pulumi.set(__self__, "created_by_workspace_arm_id", created_by_workspace_arm_id)
        pulumi.set(__self__, "group", group)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if expiry_time is not None:
            pulumi.set(__self__, "expiry_time", expiry_time)
        if is_shared_to_all is not None:
            pulumi.set(__self__, "is_shared_to_all", is_shared_to_all)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if shared_user_list is not None:
            pulumi.set(__self__, "shared_user_list", shared_user_list)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> builtins.str:
        """
        Authentication type of the connection target
        Expected value is 'None'.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="createdByWorkspaceArmId")
    def created_by_workspace_arm_id(self) -> builtins.str:
        return pulumi.get(self, "created_by_workspace_arm_id")

    @property
    @pulumi.getter
    def group(self) -> builtins.str:
        """
        Group based on connection category
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def category(self) -> Optional[builtins.str]:
        """
        Category of the connection
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="expiryTime")
    def expiry_time(self) -> Optional[builtins.str]:
        return pulumi.get(self, "expiry_time")

    @property
    @pulumi.getter(name="isSharedToAll")
    def is_shared_to_all(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_shared_to_all")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Store user metadata for this connection
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="sharedUserList")
    def shared_user_list(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "shared_user_list")

    @property
    @pulumi.getter
    def target(self) -> Optional[builtins.str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value details of the workspace connection.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[builtins.str]:
        """
        format for the workspace connection value
        """
        return pulumi.get(self, "value_format")


@pulumi.output_type
class NoneDatastoreCredentialsResponse(dict):
    """
    Empty/none datastore credentials.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsType":
            suggest = "credentials_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NoneDatastoreCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NoneDatastoreCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NoneDatastoreCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_type: builtins.str):
        """
        Empty/none datastore credentials.
        :param builtins.str credentials_type: Enum to determine the datastore credentials type.
               Expected value is 'None'.
        """
        pulumi.set(__self__, "credentials_type", 'None')

    @property
    @pulumi.getter(name="credentialsType")
    def credentials_type(self) -> builtins.str:
        """
        Enum to determine the datastore credentials type.
        Expected value is 'None'.
        """
        return pulumi.get(self, "credentials_type")


@pulumi.output_type
class NotebookPreparationErrorResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotebookPreparationErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotebookPreparationErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotebookPreparationErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_message: Optional[builtins.str] = None,
                 status_code: Optional[builtins.int] = None):
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[builtins.str]:
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[builtins.int]:
        return pulumi.get(self, "status_code")


@pulumi.output_type
class NotebookResourceInfoResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notebookPreparationError":
            suggest = "notebook_preparation_error"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotebookResourceInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotebookResourceInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotebookResourceInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: Optional[builtins.str] = None,
                 notebook_preparation_error: Optional['outputs.NotebookPreparationErrorResponse'] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        :param 'NotebookPreparationErrorResponse' notebook_preparation_error: The error that occurs when preparing notebook.
        :param builtins.str resource_id: the data plane resourceId that used to initialize notebook component
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if notebook_preparation_error is not None:
            pulumi.set(__self__, "notebook_preparation_error", notebook_preparation_error)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[builtins.str]:
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="notebookPreparationError")
    def notebook_preparation_error(self) -> Optional['outputs.NotebookPreparationErrorResponse']:
        """
        The error that occurs when preparing notebook.
        """
        return pulumi.get(self, "notebook_preparation_error")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        the data plane resourceId that used to initialize notebook component
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class NotificationSettingResponse(dict):
    """
    Configuration for notification.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailOn":
            suggest = "email_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationSettingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationSettingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationSettingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_on: Optional[Sequence[builtins.str]] = None,
                 emails: Optional[Sequence[builtins.str]] = None,
                 webhooks: Optional[Mapping[str, 'outputs.AzureDevOpsWebhookResponse']] = None):
        """
        Configuration for notification.
        :param Sequence[builtins.str] email_on: Send email notification to user on specified notification type
        :param Sequence[builtins.str] emails: This is the email recipient list which has a limitation of 499 characters in total concat with comma separator
        :param Mapping[str, 'AzureDevOpsWebhookResponse'] webhooks: Send webhook callback to a service. Key is a user-provided name for the webhook.
        """
        if email_on is not None:
            pulumi.set(__self__, "email_on", email_on)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if webhooks is not None:
            pulumi.set(__self__, "webhooks", webhooks)

    @property
    @pulumi.getter(name="emailOn")
    def email_on(self) -> Optional[Sequence[builtins.str]]:
        """
        Send email notification to user on specified notification type
        """
        return pulumi.get(self, "email_on")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[builtins.str]]:
        """
        This is the email recipient list which has a limitation of 499 characters in total concat with comma separator
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def webhooks(self) -> Optional[Mapping[str, 'outputs.AzureDevOpsWebhookResponse']]:
        """
        Send webhook callback to a service. Key is a user-provided name for the webhook.
        """
        return pulumi.get(self, "webhooks")


@pulumi.output_type
class NumericalDataDriftMetricThresholdResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NumericalDataDriftMetricThresholdResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NumericalDataDriftMetricThresholdResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NumericalDataDriftMetricThresholdResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: builtins.str,
                 metric: builtins.str,
                 threshold: Optional['outputs.MonitoringThresholdResponse'] = None):
        """
        :param builtins.str data_type: 
               Expected value is 'Numerical'.
        :param builtins.str metric: [Required] The numerical data drift metric to calculate.
        :param 'MonitoringThresholdResponse' threshold: The threshold value. If null, a default value will be set depending on the selected metric.
        """
        pulumi.set(__self__, "data_type", 'Numerical')
        pulumi.set(__self__, "metric", metric)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> builtins.str:
        """

        Expected value is 'Numerical'.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def metric(self) -> builtins.str:
        """
        [Required] The numerical data drift metric to calculate.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def threshold(self) -> Optional['outputs.MonitoringThresholdResponse']:
        """
        The threshold value. If null, a default value will be set depending on the selected metric.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class NumericalDataQualityMetricThresholdResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NumericalDataQualityMetricThresholdResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NumericalDataQualityMetricThresholdResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NumericalDataQualityMetricThresholdResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: builtins.str,
                 metric: builtins.str,
                 threshold: Optional['outputs.MonitoringThresholdResponse'] = None):
        """
        :param builtins.str data_type: 
               Expected value is 'Numerical'.
        :param builtins.str metric: [Required] The numerical data quality metric to calculate.
        :param 'MonitoringThresholdResponse' threshold: The threshold value. If null, a default value will be set depending on the selected metric.
        """
        pulumi.set(__self__, "data_type", 'Numerical')
        pulumi.set(__self__, "metric", metric)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> builtins.str:
        """

        Expected value is 'Numerical'.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def metric(self) -> builtins.str:
        """
        [Required] The numerical data quality metric to calculate.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def threshold(self) -> Optional['outputs.MonitoringThresholdResponse']:
        """
        The threshold value. If null, a default value will be set depending on the selected metric.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class NumericalPredictionDriftMetricThresholdResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NumericalPredictionDriftMetricThresholdResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NumericalPredictionDriftMetricThresholdResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NumericalPredictionDriftMetricThresholdResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: builtins.str,
                 metric: builtins.str,
                 threshold: Optional['outputs.MonitoringThresholdResponse'] = None):
        """
        :param builtins.str data_type: 
               Expected value is 'Numerical'.
        :param builtins.str metric: [Required] The numerical prediction drift metric to calculate.
        :param 'MonitoringThresholdResponse' threshold: The threshold value. If null, a default value will be set depending on the selected metric.
        """
        pulumi.set(__self__, "data_type", 'Numerical')
        pulumi.set(__self__, "metric", metric)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> builtins.str:
        """

        Expected value is 'Numerical'.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def metric(self) -> builtins.str:
        """
        [Required] The numerical prediction drift metric to calculate.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def threshold(self) -> Optional['outputs.MonitoringThresholdResponse']:
        """
        The threshold value. If null, a default value will be set depending on the selected metric.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class OAuth2AuthTypeWorkspaceConnectionPropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "createdByWorkspaceArmId":
            suggest = "created_by_workspace_arm_id"
        elif key == "expiryTime":
            suggest = "expiry_time"
        elif key == "isSharedToAll":
            suggest = "is_shared_to_all"
        elif key == "sharedUserList":
            suggest = "shared_user_list"
        elif key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OAuth2AuthTypeWorkspaceConnectionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OAuth2AuthTypeWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OAuth2AuthTypeWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: builtins.str,
                 created_by_workspace_arm_id: builtins.str,
                 group: builtins.str,
                 category: Optional[builtins.str] = None,
                 credentials: Optional['outputs.WorkspaceConnectionOAuth2Response'] = None,
                 expiry_time: Optional[builtins.str] = None,
                 is_shared_to_all: Optional[builtins.bool] = None,
                 metadata: Optional[Mapping[str, builtins.str]] = None,
                 shared_user_list: Optional[Sequence[builtins.str]] = None,
                 target: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None,
                 value_format: Optional[builtins.str] = None):
        """
        :param builtins.str auth_type: Authentication type of the connection target
               Expected value is 'OAuth2'.
        :param builtins.str group: Group based on connection category
        :param builtins.str category: Category of the connection
        :param 'WorkspaceConnectionOAuth2Response' credentials: ClientId and ClientSecret are required. Other properties are optional
               depending on each OAuth2 provider's implementation.
        :param Mapping[str, builtins.str] metadata: Store user metadata for this connection
        :param builtins.str value: Value details of the workspace connection.
        :param builtins.str value_format: format for the workspace connection value
        """
        pulumi.set(__self__, "auth_type", 'OAuth2')
        pulumi.set(__self__, "created_by_workspace_arm_id", created_by_workspace_arm_id)
        pulumi.set(__self__, "group", group)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if expiry_time is not None:
            pulumi.set(__self__, "expiry_time", expiry_time)
        if is_shared_to_all is not None:
            pulumi.set(__self__, "is_shared_to_all", is_shared_to_all)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if shared_user_list is not None:
            pulumi.set(__self__, "shared_user_list", shared_user_list)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> builtins.str:
        """
        Authentication type of the connection target
        Expected value is 'OAuth2'.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="createdByWorkspaceArmId")
    def created_by_workspace_arm_id(self) -> builtins.str:
        return pulumi.get(self, "created_by_workspace_arm_id")

    @property
    @pulumi.getter
    def group(self) -> builtins.str:
        """
        Group based on connection category
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def category(self) -> Optional[builtins.str]:
        """
        Category of the connection
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.WorkspaceConnectionOAuth2Response']:
        """
        ClientId and ClientSecret are required. Other properties are optional
        depending on each OAuth2 provider's implementation.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="expiryTime")
    def expiry_time(self) -> Optional[builtins.str]:
        return pulumi.get(self, "expiry_time")

    @property
    @pulumi.getter(name="isSharedToAll")
    def is_shared_to_all(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_shared_to_all")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Store user metadata for this connection
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="sharedUserList")
    def shared_user_list(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "shared_user_list")

    @property
    @pulumi.getter
    def target(self) -> Optional[builtins.str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value details of the workspace connection.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[builtins.str]:
        """
        format for the workspace connection value
        """
        return pulumi.get(self, "value_format")


@pulumi.output_type
class ObjectiveResponse(dict):
    """
    Optimization objective.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryMetric":
            suggest = "primary_metric"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectiveResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectiveResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectiveResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 goal: builtins.str,
                 primary_metric: builtins.str):
        """
        Optimization objective.
        :param builtins.str goal: [Required] Defines supported metric goals for hyperparameter tuning
        :param builtins.str primary_metric: [Required] Name of the metric to optimize.
        """
        pulumi.set(__self__, "goal", goal)
        pulumi.set(__self__, "primary_metric", primary_metric)

    @property
    @pulumi.getter
    def goal(self) -> builtins.str:
        """
        [Required] Defines supported metric goals for hyperparameter tuning
        """
        return pulumi.get(self, "goal")

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> builtins.str:
        """
        [Required] Name of the metric to optimize.
        """
        return pulumi.get(self, "primary_metric")


@pulumi.output_type
class OneLakeDatastoreResponse(dict):
    """
    OneLake (Trident) datastore configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datastoreType":
            suggest = "datastore_type"
        elif key == "isDefault":
            suggest = "is_default"
        elif key == "oneLakeWorkspaceName":
            suggest = "one_lake_workspace_name"
        elif key == "serviceDataAccessAuthIdentity":
            suggest = "service_data_access_auth_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OneLakeDatastoreResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OneLakeDatastoreResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OneLakeDatastoreResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 artifact: 'outputs.LakeHouseArtifactResponse',
                 credentials: Any,
                 datastore_type: builtins.str,
                 is_default: builtins.bool,
                 one_lake_workspace_name: builtins.str,
                 description: Optional[builtins.str] = None,
                 endpoint: Optional[builtins.str] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 service_data_access_auth_identity: Optional[builtins.str] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        OneLake (Trident) datastore configuration.
        :param 'LakeHouseArtifactResponse' artifact: [Required] OneLake artifact backing the datastore.
        :param Union['AccountKeyDatastoreCredentialsResponse', 'CertificateDatastoreCredentialsResponse', 'NoneDatastoreCredentialsResponse', 'SasDatastoreCredentialsResponse', 'ServicePrincipalDatastoreCredentialsResponse'] credentials: [Required] Account credentials.
        :param builtins.str datastore_type: Enum to determine the datastore contents type.
               Expected value is 'OneLake'.
        :param builtins.bool is_default: Readonly property to indicate if datastore is the workspace default datastore
        :param builtins.str one_lake_workspace_name: [Required] OneLake workspace name.
        :param builtins.str description: The asset description text.
        :param builtins.str endpoint: OneLake endpoint to use for the datastore.
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param builtins.str service_data_access_auth_identity: Indicates which identity to use to authenticate service data access to customer's storage.
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "artifact", artifact)
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "datastore_type", 'OneLake')
        pulumi.set(__self__, "is_default", is_default)
        pulumi.set(__self__, "one_lake_workspace_name", one_lake_workspace_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if service_data_access_auth_identity is None:
            service_data_access_auth_identity = 'None'
        if service_data_access_auth_identity is not None:
            pulumi.set(__self__, "service_data_access_auth_identity", service_data_access_auth_identity)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def artifact(self) -> 'outputs.LakeHouseArtifactResponse':
        """
        [Required] OneLake artifact backing the datastore.
        """
        return pulumi.get(self, "artifact")

    @property
    @pulumi.getter
    def credentials(self) -> Any:
        """
        [Required] Account credentials.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="datastoreType")
    def datastore_type(self) -> builtins.str:
        """
        Enum to determine the datastore contents type.
        Expected value is 'OneLake'.
        """
        return pulumi.get(self, "datastore_type")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> builtins.bool:
        """
        Readonly property to indicate if datastore is the workspace default datastore
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter(name="oneLakeWorkspaceName")
    def one_lake_workspace_name(self) -> builtins.str:
        """
        [Required] OneLake workspace name.
        """
        return pulumi.get(self, "one_lake_workspace_name")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[builtins.str]:
        """
        OneLake endpoint to use for the datastore.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="serviceDataAccessAuthIdentity")
    def service_data_access_auth_identity(self) -> Optional[builtins.str]:
        """
        Indicates which identity to use to authenticate service data access to customer's storage.
        """
        return pulumi.get(self, "service_data_access_auth_identity")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class OnlineEndpointResponse(dict):
    """
    Online endpoint configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authMode":
            suggest = "auth_mode"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "scoringUri":
            suggest = "scoring_uri"
        elif key == "swaggerUri":
            suggest = "swagger_uri"
        elif key == "mirrorTraffic":
            suggest = "mirror_traffic"
        elif key == "publicNetworkAccess":
            suggest = "public_network_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_mode: builtins.str,
                 provisioning_state: builtins.str,
                 scoring_uri: builtins.str,
                 swagger_uri: builtins.str,
                 compute: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 mirror_traffic: Optional[Mapping[str, builtins.int]] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 public_network_access: Optional[builtins.str] = None,
                 traffic: Optional[Mapping[str, builtins.int]] = None):
        """
        Online endpoint configuration
        :param builtins.str auth_mode: [Required] The authentication method for invoking the endpoint (data plane operation). Use 'Key' for key-based authentication. Use 'AMLToken' for Azure Machine Learning token-based authentication. Use 'AADToken' for Microsoft Entra token-based authentication.
        :param builtins.str provisioning_state: Provisioning state for the endpoint.
        :param builtins.str scoring_uri: Endpoint URI.
        :param builtins.str swagger_uri: Endpoint Swagger URI.
        :param builtins.str compute: ARM resource ID of the compute if it exists.
               optional
        :param builtins.str description: Description of the inference endpoint.
        :param Mapping[str, builtins.int] mirror_traffic: Percentage of traffic to be mirrored to each deployment without using returned scoring. Traffic values need to sum to utmost 50.
        :param Mapping[str, builtins.str] properties: Property dictionary. Properties can be added, but not removed or altered.
        :param builtins.str public_network_access: Set to "Enabled" for endpoints that should allow public access when Private Link is enabled.
        :param Mapping[str, builtins.int] traffic: Percentage of traffic from endpoint to divert to each deployment. Traffic values need to sum to 100.
        """
        pulumi.set(__self__, "auth_mode", auth_mode)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "scoring_uri", scoring_uri)
        pulumi.set(__self__, "swagger_uri", swagger_uri)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if mirror_traffic is not None:
            pulumi.set(__self__, "mirror_traffic", mirror_traffic)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if public_network_access is None:
            public_network_access = 'Enabled'
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)
        if traffic is not None:
            pulumi.set(__self__, "traffic", traffic)

    @property
    @pulumi.getter(name="authMode")
    def auth_mode(self) -> builtins.str:
        """
        [Required] The authentication method for invoking the endpoint (data plane operation). Use 'Key' for key-based authentication. Use 'AMLToken' for Azure Machine Learning token-based authentication. Use 'AADToken' for Microsoft Entra token-based authentication.
        """
        return pulumi.get(self, "auth_mode")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the endpoint.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="scoringUri")
    def scoring_uri(self) -> builtins.str:
        """
        Endpoint URI.
        """
        return pulumi.get(self, "scoring_uri")

    @property
    @pulumi.getter(name="swaggerUri")
    def swagger_uri(self) -> builtins.str:
        """
        Endpoint Swagger URI.
        """
        return pulumi.get(self, "swagger_uri")

    @property
    @pulumi.getter
    def compute(self) -> Optional[builtins.str]:
        """
        ARM resource ID of the compute if it exists.
        optional
        """
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description of the inference endpoint.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="mirrorTraffic")
    def mirror_traffic(self) -> Optional[Mapping[str, builtins.int]]:
        """
        Percentage of traffic to be mirrored to each deployment without using returned scoring. Traffic values need to sum to utmost 50.
        """
        return pulumi.get(self, "mirror_traffic")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[builtins.str]:
        """
        Set to "Enabled" for endpoints that should allow public access when Private Link is enabled.
        """
        return pulumi.get(self, "public_network_access")

    @property
    @pulumi.getter
    def traffic(self) -> Optional[Mapping[str, builtins.int]]:
        """
        Percentage of traffic from endpoint to divert to each deployment. Traffic values need to sum to 100.
        """
        return pulumi.get(self, "traffic")


@pulumi.output_type
class OnlineRequestSettingsResponse(dict):
    """
    Online deployment scoring requests configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentRequestsPerInstance":
            suggest = "max_concurrent_requests_per_instance"
        elif key == "maxQueueWait":
            suggest = "max_queue_wait"
        elif key == "requestTimeout":
            suggest = "request_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineRequestSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineRequestSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineRequestSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_requests_per_instance: Optional[builtins.int] = None,
                 max_queue_wait: Optional[builtins.str] = None,
                 request_timeout: Optional[builtins.str] = None):
        """
        Online deployment scoring requests configuration.
        :param builtins.int max_concurrent_requests_per_instance: The number of maximum concurrent requests per node allowed per deployment. Defaults to 1.
        :param builtins.str max_queue_wait: (Deprecated for Managed Online Endpoints) The maximum amount of time a request will stay in the queue in ISO 8601 format.
               Defaults to 500ms.
               (Now increase `request_timeout_ms` to account for any networking/queue delays)
        :param builtins.str request_timeout: The scoring timeout in ISO 8601 format.
               Defaults to 5000ms.
        """
        if max_concurrent_requests_per_instance is None:
            max_concurrent_requests_per_instance = 1
        if max_concurrent_requests_per_instance is not None:
            pulumi.set(__self__, "max_concurrent_requests_per_instance", max_concurrent_requests_per_instance)
        if max_queue_wait is None:
            max_queue_wait = 'PT0.5S'
        if max_queue_wait is not None:
            pulumi.set(__self__, "max_queue_wait", max_queue_wait)
        if request_timeout is None:
            request_timeout = 'PT5S'
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)

    @property
    @pulumi.getter(name="maxConcurrentRequestsPerInstance")
    def max_concurrent_requests_per_instance(self) -> Optional[builtins.int]:
        """
        The number of maximum concurrent requests per node allowed per deployment. Defaults to 1.
        """
        return pulumi.get(self, "max_concurrent_requests_per_instance")

    @property
    @pulumi.getter(name="maxQueueWait")
    def max_queue_wait(self) -> Optional[builtins.str]:
        """
        (Deprecated for Managed Online Endpoints) The maximum amount of time a request will stay in the queue in ISO 8601 format.
        Defaults to 500ms.
        (Now increase `request_timeout_ms` to account for any networking/queue delays)
        """
        return pulumi.get(self, "max_queue_wait")

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[builtins.str]:
        """
        The scoring timeout in ISO 8601 format.
        Defaults to 5000ms.
        """
        return pulumi.get(self, "request_timeout")


@pulumi.output_type
class OpenAIEndpointDeploymentResourcePropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "failureReason":
            suggest = "failure_reason"
        elif key == "raiPolicyName":
            suggest = "rai_policy_name"
        elif key == "versionUpgradeOption":
            suggest = "version_upgrade_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenAIEndpointDeploymentResourcePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenAIEndpointDeploymentResourcePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenAIEndpointDeploymentResourcePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model: 'outputs.EndpointDeploymentModelResponse',
                 provisioning_state: builtins.str,
                 type: builtins.str,
                 failure_reason: Optional[builtins.str] = None,
                 rai_policy_name: Optional[builtins.str] = None,
                 sku: Optional['outputs.CognitiveServicesSkuResponse'] = None,
                 version_upgrade_option: Optional[builtins.str] = None):
        """
        :param 'EndpointDeploymentModelResponse' model: Model used for the endpoint deployment.
        :param builtins.str provisioning_state: Read-only provision state status property.
        :param builtins.str type: Kind of the deployment.
               Expected value is 'Azure.OpenAI'.
        :param builtins.str failure_reason: The failure reason if the creation failed.
        :param builtins.str rai_policy_name: The name of RAI policy.
        :param builtins.str version_upgrade_option: Deployment model version upgrade option.
        """
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "type", 'Azure.OpenAI')
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if rai_policy_name is not None:
            pulumi.set(__self__, "rai_policy_name", rai_policy_name)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)
        if version_upgrade_option is not None:
            pulumi.set(__self__, "version_upgrade_option", version_upgrade_option)

    @property
    @pulumi.getter
    def model(self) -> 'outputs.EndpointDeploymentModelResponse':
        """
        Model used for the endpoint deployment.
        """
        return pulumi.get(self, "model")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Read-only provision state status property.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Kind of the deployment.
        Expected value is 'Azure.OpenAI'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[builtins.str]:
        """
        The failure reason if the creation failed.
        """
        return pulumi.get(self, "failure_reason")

    @property
    @pulumi.getter(name="raiPolicyName")
    def rai_policy_name(self) -> Optional[builtins.str]:
        """
        The name of RAI policy.
        """
        return pulumi.get(self, "rai_policy_name")

    @property
    @pulumi.getter
    def sku(self) -> Optional['outputs.CognitiveServicesSkuResponse']:
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter(name="versionUpgradeOption")
    def version_upgrade_option(self) -> Optional[builtins.str]:
        """
        Deployment model version upgrade option.
        """
        return pulumi.get(self, "version_upgrade_option")


@pulumi.output_type
class OutputPathAssetReferenceResponse(dict):
    """
    Reference to an asset via its path in a job output.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referenceType":
            suggest = "reference_type"
        elif key == "jobId":
            suggest = "job_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OutputPathAssetReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OutputPathAssetReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OutputPathAssetReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reference_type: builtins.str,
                 job_id: Optional[builtins.str] = None,
                 path: Optional[builtins.str] = None):
        """
        Reference to an asset via its path in a job output.
        :param builtins.str reference_type: Enum to determine which reference method to use for an asset.
               Expected value is 'OutputPath'.
        :param builtins.str job_id: ARM resource ID of the job.
        :param builtins.str path: The path of the file/directory in the job output.
        """
        pulumi.set(__self__, "reference_type", 'OutputPath')
        if job_id is not None:
            pulumi.set(__self__, "job_id", job_id)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="referenceType")
    def reference_type(self) -> builtins.str:
        """
        Enum to determine which reference method to use for an asset.
        Expected value is 'OutputPath'.
        """
        return pulumi.get(self, "reference_type")

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of the job.
        """
        return pulumi.get(self, "job_id")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        The path of the file/directory in the job output.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class PATAuthTypeWorkspaceConnectionPropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "createdByWorkspaceArmId":
            suggest = "created_by_workspace_arm_id"
        elif key == "expiryTime":
            suggest = "expiry_time"
        elif key == "isSharedToAll":
            suggest = "is_shared_to_all"
        elif key == "sharedUserList":
            suggest = "shared_user_list"
        elif key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PATAuthTypeWorkspaceConnectionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PATAuthTypeWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PATAuthTypeWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: builtins.str,
                 created_by_workspace_arm_id: builtins.str,
                 group: builtins.str,
                 category: Optional[builtins.str] = None,
                 credentials: Optional['outputs.WorkspaceConnectionPersonalAccessTokenResponse'] = None,
                 expiry_time: Optional[builtins.str] = None,
                 is_shared_to_all: Optional[builtins.bool] = None,
                 metadata: Optional[Mapping[str, builtins.str]] = None,
                 shared_user_list: Optional[Sequence[builtins.str]] = None,
                 target: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None,
                 value_format: Optional[builtins.str] = None):
        """
        :param builtins.str auth_type: Authentication type of the connection target
               Expected value is 'PAT'.
        :param builtins.str group: Group based on connection category
        :param builtins.str category: Category of the connection
        :param Mapping[str, builtins.str] metadata: Store user metadata for this connection
        :param builtins.str value: Value details of the workspace connection.
        :param builtins.str value_format: format for the workspace connection value
        """
        pulumi.set(__self__, "auth_type", 'PAT')
        pulumi.set(__self__, "created_by_workspace_arm_id", created_by_workspace_arm_id)
        pulumi.set(__self__, "group", group)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if expiry_time is not None:
            pulumi.set(__self__, "expiry_time", expiry_time)
        if is_shared_to_all is not None:
            pulumi.set(__self__, "is_shared_to_all", is_shared_to_all)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if shared_user_list is not None:
            pulumi.set(__self__, "shared_user_list", shared_user_list)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> builtins.str:
        """
        Authentication type of the connection target
        Expected value is 'PAT'.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="createdByWorkspaceArmId")
    def created_by_workspace_arm_id(self) -> builtins.str:
        return pulumi.get(self, "created_by_workspace_arm_id")

    @property
    @pulumi.getter
    def group(self) -> builtins.str:
        """
        Group based on connection category
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def category(self) -> Optional[builtins.str]:
        """
        Category of the connection
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.WorkspaceConnectionPersonalAccessTokenResponse']:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="expiryTime")
    def expiry_time(self) -> Optional[builtins.str]:
        return pulumi.get(self, "expiry_time")

    @property
    @pulumi.getter(name="isSharedToAll")
    def is_shared_to_all(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_shared_to_all")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Store user metadata for this connection
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="sharedUserList")
    def shared_user_list(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "shared_user_list")

    @property
    @pulumi.getter
    def target(self) -> Optional[builtins.str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value details of the workspace connection.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[builtins.str]:
        """
        format for the workspace connection value
        """
        return pulumi.get(self, "value_format")


@pulumi.output_type
class PasswordResponse(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 value: builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class PersonalComputeInstanceSettingsResponse(dict):
    """
    Settings for a personal compute instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignedUser":
            suggest = "assigned_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PersonalComputeInstanceSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PersonalComputeInstanceSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PersonalComputeInstanceSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assigned_user: Optional['outputs.AssignedUserResponse'] = None):
        """
        Settings for a personal compute instance.
        :param 'AssignedUserResponse' assigned_user: A user explicitly assigned to a personal compute instance.
        """
        if assigned_user is not None:
            pulumi.set(__self__, "assigned_user", assigned_user)

    @property
    @pulumi.getter(name="assignedUser")
    def assigned_user(self) -> Optional['outputs.AssignedUserResponse']:
        """
        A user explicitly assigned to a personal compute instance.
        """
        return pulumi.get(self, "assigned_user")


@pulumi.output_type
class PipelineJobResponse(dict):
    """
    Pipeline Job definition: defines generic to MFE attributes.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobType":
            suggest = "job_type"
        elif key == "componentId":
            suggest = "component_id"
        elif key == "computeId":
            suggest = "compute_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "experimentName":
            suggest = "experiment_name"
        elif key == "isArchived":
            suggest = "is_archived"
        elif key == "notificationSetting":
            suggest = "notification_setting"
        elif key == "sourceJobId":
            suggest = "source_job_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineJobResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineJobResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineJobResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_type: builtins.str,
                 status: builtins.str,
                 component_id: Optional[builtins.str] = None,
                 compute_id: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 display_name: Optional[builtins.str] = None,
                 experiment_name: Optional[builtins.str] = None,
                 identity: Optional[Any] = None,
                 inputs: Optional[Mapping[str, Any]] = None,
                 is_archived: Optional[builtins.bool] = None,
                 jobs: Optional[Mapping[str, Any]] = None,
                 notification_setting: Optional['outputs.NotificationSettingResponse'] = None,
                 outputs: Optional[Mapping[str, Any]] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 services: Optional[Mapping[str, 'outputs.JobServiceResponse']] = None,
                 settings: Optional[Any] = None,
                 source_job_id: Optional[builtins.str] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Pipeline Job definition: defines generic to MFE attributes.
        :param builtins.str job_type: Enum to determine the type of job.
               Expected value is 'Pipeline'.
        :param builtins.str status: Status of the job.
        :param builtins.str component_id: ARM resource ID of the component resource.
        :param builtins.str compute_id: ARM resource ID of the compute resource.
        :param builtins.str description: The asset description text.
        :param builtins.str display_name: Display name of job.
        :param builtins.str experiment_name: The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        :param Union['AmlTokenResponse', 'ManagedIdentityResponse', 'UserIdentityResponse'] identity: Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
               Defaults to AmlToken if null.
        :param Mapping[str, Union['CustomModelJobInputResponse', 'LiteralJobInputResponse', 'MLFlowModelJobInputResponse', 'MLTableJobInputResponse', 'TritonModelJobInputResponse', 'UriFileJobInputResponse', 'UriFolderJobInputResponse']] inputs: Inputs for the pipeline job.
        :param builtins.bool is_archived: Is the asset archived?
        :param Mapping[str, Any] jobs: Jobs construct the Pipeline Job.
        :param 'NotificationSettingResponse' notification_setting: Notification setting for the job
        :param Mapping[str, Union['CustomModelJobOutputResponse', 'MLFlowModelJobOutputResponse', 'MLTableJobOutputResponse', 'TritonModelJobOutputResponse', 'UriFileJobOutputResponse', 'UriFolderJobOutputResponse']] outputs: Outputs for the pipeline job
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param Mapping[str, 'JobServiceResponse'] services: List of JobEndpoints.
               For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        :param Any settings: Pipeline settings, for things like ContinueRunOnStepFailure etc.
        :param builtins.str source_job_id: ARM resource ID of source job.
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "job_type", 'Pipeline')
        pulumi.set(__self__, "status", status)
        if component_id is not None:
            pulumi.set(__self__, "component_id", component_id)
        if compute_id is not None:
            pulumi.set(__self__, "compute_id", compute_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if experiment_name is None:
            experiment_name = 'Default'
        if experiment_name is not None:
            pulumi.set(__self__, "experiment_name", experiment_name)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notification_setting is not None:
            pulumi.set(__self__, "notification_setting", notification_setting)
        if outputs is not None:
            pulumi.set(__self__, "outputs", outputs)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if source_job_id is not None:
            pulumi.set(__self__, "source_job_id", source_job_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="jobType")
    def job_type(self) -> builtins.str:
        """
        Enum to determine the type of job.
        Expected value is 'Pipeline'.
        """
        return pulumi.get(self, "job_type")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Status of the job.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="componentId")
    def component_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of the component resource.
        """
        return pulumi.get(self, "component_id")

    @property
    @pulumi.getter(name="computeId")
    def compute_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of the compute resource.
        """
        return pulumi.get(self, "compute_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        Display name of job.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="experimentName")
    def experiment_name(self) -> Optional[builtins.str]:
        """
        The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        """
        return pulumi.get(self, "experiment_name")

    @property
    @pulumi.getter
    def identity(self) -> Optional[Any]:
        """
        Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
        Defaults to AmlToken if null.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter
    def inputs(self) -> Optional[Mapping[str, Any]]:
        """
        Inputs for the pipeline job.
        """
        return pulumi.get(self, "inputs")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def jobs(self) -> Optional[Mapping[str, Any]]:
        """
        Jobs construct the Pipeline Job.
        """
        return pulumi.get(self, "jobs")

    @property
    @pulumi.getter(name="notificationSetting")
    def notification_setting(self) -> Optional['outputs.NotificationSettingResponse']:
        """
        Notification setting for the job
        """
        return pulumi.get(self, "notification_setting")

    @property
    @pulumi.getter
    def outputs(self) -> Optional[Mapping[str, Any]]:
        """
        Outputs for the pipeline job
        """
        return pulumi.get(self, "outputs")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def services(self) -> Optional[Mapping[str, 'outputs.JobServiceResponse']]:
        """
        List of JobEndpoints.
        For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Any]:
        """
        Pipeline settings, for things like ContinueRunOnStepFailure etc.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter(name="sourceJobId")
    def source_job_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of source job.
        """
        return pulumi.get(self, "source_job_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class PredictionDriftMonitoringSignalResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricThresholds":
            suggest = "metric_thresholds"
        elif key == "productionData":
            suggest = "production_data"
        elif key == "referenceData":
            suggest = "reference_data"
        elif key == "signalType":
            suggest = "signal_type"
        elif key == "featureDataTypeOverride":
            suggest = "feature_data_type_override"
        elif key == "notificationTypes":
            suggest = "notification_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PredictionDriftMonitoringSignalResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PredictionDriftMonitoringSignalResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PredictionDriftMonitoringSignalResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_thresholds: Sequence[Any],
                 production_data: Any,
                 reference_data: Any,
                 signal_type: builtins.str,
                 feature_data_type_override: Optional[Mapping[str, builtins.str]] = None,
                 notification_types: Optional[Sequence[builtins.str]] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None):
        """
        :param Sequence[Union['CategoricalPredictionDriftMetricThresholdResponse', 'NumericalPredictionDriftMetricThresholdResponse']] metric_thresholds: [Required] A list of metrics to calculate and their associated thresholds.
        :param Union['FixedInputDataResponse', 'RollingInputDataResponse', 'StaticInputDataResponse'] production_data: [Required] The data which drift will be calculated for.
        :param Union['FixedInputDataResponse', 'RollingInputDataResponse', 'StaticInputDataResponse'] reference_data: [Required] The data to calculate drift against.
        :param builtins.str signal_type: 
               Expected value is 'PredictionDrift'.
        :param Mapping[str, builtins.str] feature_data_type_override: A dictionary that maps feature names to their respective data types.
        :param Sequence[builtins.str] notification_types: The current notification mode for this signal.
        :param Mapping[str, builtins.str] properties: Property dictionary. Properties can be added, but not removed or altered.
        """
        pulumi.set(__self__, "metric_thresholds", metric_thresholds)
        pulumi.set(__self__, "production_data", production_data)
        pulumi.set(__self__, "reference_data", reference_data)
        pulumi.set(__self__, "signal_type", 'PredictionDrift')
        if feature_data_type_override is not None:
            pulumi.set(__self__, "feature_data_type_override", feature_data_type_override)
        if notification_types is not None:
            pulumi.set(__self__, "notification_types", notification_types)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter(name="metricThresholds")
    def metric_thresholds(self) -> Sequence[Any]:
        """
        [Required] A list of metrics to calculate and their associated thresholds.
        """
        return pulumi.get(self, "metric_thresholds")

    @property
    @pulumi.getter(name="productionData")
    def production_data(self) -> Any:
        """
        [Required] The data which drift will be calculated for.
        """
        return pulumi.get(self, "production_data")

    @property
    @pulumi.getter(name="referenceData")
    def reference_data(self) -> Any:
        """
        [Required] The data to calculate drift against.
        """
        return pulumi.get(self, "reference_data")

    @property
    @pulumi.getter(name="signalType")
    def signal_type(self) -> builtins.str:
        """

        Expected value is 'PredictionDrift'.
        """
        return pulumi.get(self, "signal_type")

    @property
    @pulumi.getter(name="featureDataTypeOverride")
    def feature_data_type_override(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A dictionary that maps feature names to their respective data types.
        """
        return pulumi.get(self, "feature_data_type_override")

    @property
    @pulumi.getter(name="notificationTypes")
    def notification_types(self) -> Optional[Sequence[builtins.str]]:
        """
        The current notification mode for this signal.
        """
        return pulumi.get(self, "notification_types")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Property dictionary. Properties can be added, but not removed or altered.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class PrivateEndpointConnectionResponse(dict):
    """
    The Private Endpoint Connection resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateLinkServiceConnectionState":
            suggest = "private_link_service_connection_state"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "systemData":
            suggest = "system_data"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: builtins.str,
                 name: builtins.str,
                 private_link_service_connection_state: 'outputs.PrivateLinkServiceConnectionStateResponse',
                 provisioning_state: builtins.str,
                 system_data: 'outputs.SystemDataResponse',
                 type: builtins.str,
                 identity: Optional['outputs.ManagedServiceIdentityResponse'] = None,
                 location: Optional[builtins.str] = None,
                 private_endpoint: Optional['outputs.PrivateEndpointResponse'] = None,
                 sku: Optional['outputs.SkuResponse'] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        The Private Endpoint Connection resource.
        :param builtins.str id: Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        :param builtins.str name: The name of the resource
        :param 'PrivateLinkServiceConnectionStateResponse' private_link_service_connection_state: A collection of information about the state of the connection between service consumer and provider.
        :param builtins.str provisioning_state: The provisioning state of the private endpoint connection resource.
        :param 'SystemDataResponse' system_data: Azure Resource Manager metadata containing createdBy and modifiedBy information.
        :param builtins.str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param 'ManagedServiceIdentityResponse' identity: The identity of the resource.
        :param builtins.str location: Specifies the location of the resource.
        :param 'PrivateEndpointResponse' private_endpoint: The resource of private end point.
        :param 'SkuResponse' sku: The sku of the workspace.
        :param Mapping[str, builtins.str] tags: Contains resource tags defined as key/value pairs.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_link_service_connection_state", private_link_service_connection_state)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "system_data", system_data)
        pulumi.set(__self__, "type", type)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> 'outputs.PrivateLinkServiceConnectionStateResponse':
        """
        A collection of information about the state of the connection between service consumer and provider.
        """
        return pulumi.get(self, "private_link_service_connection_state")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The provisioning state of the private endpoint connection resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Azure Resource Manager metadata containing createdBy and modifiedBy information.
        """
        return pulumi.get(self, "system_data")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def identity(self) -> Optional['outputs.ManagedServiceIdentityResponse']:
        """
        The identity of the resource.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter
    def location(self) -> Optional[builtins.str]:
        """
        Specifies the location of the resource.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.PrivateEndpointResponse']:
        """
        The resource of private end point.
        """
        return pulumi.get(self, "private_endpoint")

    @property
    @pulumi.getter
    def sku(self) -> Optional['outputs.SkuResponse']:
        """
        The sku of the workspace.
        """
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Contains resource tags defined as key/value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class PrivateEndpointDestinationResponse(dict):
    """
    Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceResourceId":
            suggest = "service_resource_id"
        elif key == "sparkEnabled":
            suggest = "spark_enabled"
        elif key == "sparkStatus":
            suggest = "spark_status"
        elif key == "subresourceTarget":
            suggest = "subresource_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_resource_id: Optional[builtins.str] = None,
                 spark_enabled: Optional[builtins.bool] = None,
                 spark_status: Optional[builtins.str] = None,
                 subresource_target: Optional[builtins.str] = None):
        """
        Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        :param builtins.str spark_status: Type of a managed network Outbound Rule of a machine learning workspace.
        """
        if service_resource_id is not None:
            pulumi.set(__self__, "service_resource_id", service_resource_id)
        if spark_enabled is not None:
            pulumi.set(__self__, "spark_enabled", spark_enabled)
        if spark_status is not None:
            pulumi.set(__self__, "spark_status", spark_status)
        if subresource_target is not None:
            pulumi.set(__self__, "subresource_target", subresource_target)

    @property
    @pulumi.getter(name="serviceResourceId")
    def service_resource_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "service_resource_id")

    @property
    @pulumi.getter(name="sparkEnabled")
    def spark_enabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "spark_enabled")

    @property
    @pulumi.getter(name="sparkStatus")
    def spark_status(self) -> Optional[builtins.str]:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "spark_status")

    @property
    @pulumi.getter(name="subresourceTarget")
    def subresource_target(self) -> Optional[builtins.str]:
        return pulumi.get(self, "subresource_target")


@pulumi.output_type
class PrivateEndpointOutboundRuleResponse(dict):
    """
    Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
    """
    def __init__(__self__, *,
                 type: builtins.str,
                 category: Optional[builtins.str] = None,
                 destination: Optional['outputs.PrivateEndpointDestinationResponse'] = None,
                 status: Optional[builtins.str] = None):
        """
        Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        :param builtins.str type: Type of a managed network Outbound Rule of a machine learning workspace.
               Expected value is 'PrivateEndpoint'.
        :param builtins.str category: Category of a managed network Outbound Rule of a machine learning workspace.
        :param 'PrivateEndpointDestinationResponse' destination: Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        :param builtins.str status: Type of a managed network Outbound Rule of a machine learning workspace.
        """
        pulumi.set(__self__, "type", 'PrivateEndpoint')
        if category is not None:
            pulumi.set(__self__, "category", category)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        Expected value is 'PrivateEndpoint'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def category(self) -> Optional[builtins.str]:
        """
        Category of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.PrivateEndpointDestinationResponse']:
        """
        Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class PrivateEndpointResourceResponse(dict):
    """
    The PE network resource that is linked to this PE connection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetArmId":
            suggest = "subnet_arm_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointResourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointResourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointResourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: builtins.str,
                 subnet_arm_id: Optional[builtins.str] = None):
        """
        The PE network resource that is linked to this PE connection.
        :param builtins.str id: The ARM identifier for Private Endpoint
        :param builtins.str subnet_arm_id: The subnetId that the private endpoint is connected to.
        """
        pulumi.set(__self__, "id", id)
        if subnet_arm_id is not None:
            pulumi.set(__self__, "subnet_arm_id", subnet_arm_id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The ARM identifier for Private Endpoint
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="subnetArmId")
    def subnet_arm_id(self) -> Optional[builtins.str]:
        """
        The subnetId that the private endpoint is connected to.
        """
        return pulumi.get(self, "subnet_arm_id")


@pulumi.output_type
class PrivateEndpointResponse(dict):
    """
    The Private Endpoint resource.
    """
    def __init__(__self__, *,
                 id: builtins.str):
        """
        The Private Endpoint resource.
        :param builtins.str id: The ARM identifier for Private Endpoint
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The ARM identifier for Private Endpoint
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrivateLinkServiceConnectionStateResponse(dict):
    """
    A collection of information about the state of the connection between service consumer and provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsRequired":
            suggest = "actions_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkServiceConnectionStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_required: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 status: Optional[builtins.str] = None):
        """
        A collection of information about the state of the connection between service consumer and provider.
        :param builtins.str actions_required: A message indicating if changes on the service provider require any updates on the consumer.
        :param builtins.str description: The reason for approval/rejection of the connection.
        :param builtins.str status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        if actions_required is not None:
            pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[builtins.str]:
        """
        A message indicating if changes on the service provider require any updates on the consumer.
        """
        return pulumi.get(self, "actions_required")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The reason for approval/rejection of the connection.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ProbeSettingsResponse(dict):
    """
    Deployment container liveness/readiness probe configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "initialDelay":
            suggest = "initial_delay"
        elif key == "successThreshold":
            suggest = "success_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProbeSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProbeSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProbeSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_threshold: Optional[builtins.int] = None,
                 initial_delay: Optional[builtins.str] = None,
                 period: Optional[builtins.str] = None,
                 success_threshold: Optional[builtins.int] = None,
                 timeout: Optional[builtins.str] = None):
        """
        Deployment container liveness/readiness probe configuration.
        :param builtins.int failure_threshold: The number of failures to allow before returning an unhealthy status.
        :param builtins.str initial_delay: The delay before the first probe in ISO 8601 format.
        :param builtins.str period: The length of time between probes in ISO 8601 format.
        :param builtins.int success_threshold: The number of successful probes before returning a healthy status.
        :param builtins.str timeout: The probe timeout in ISO 8601 format.
        """
        if failure_threshold is None:
            failure_threshold = 30
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay is not None:
            pulumi.set(__self__, "initial_delay", initial_delay)
        if period is None:
            period = 'PT10S'
        if period is not None:
            pulumi.set(__self__, "period", period)
        if success_threshold is None:
            success_threshold = 1
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout is None:
            timeout = 'PT2S'
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[builtins.int]:
        """
        The number of failures to allow before returning an unhealthy status.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelay")
    def initial_delay(self) -> Optional[builtins.str]:
        """
        The delay before the first probe in ISO 8601 format.
        """
        return pulumi.get(self, "initial_delay")

    @property
    @pulumi.getter
    def period(self) -> Optional[builtins.str]:
        """
        The length of time between probes in ISO 8601 format.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[builtins.int]:
        """
        The number of successful probes before returning a healthy status.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[builtins.str]:
        """
        The probe timeout in ISO 8601 format.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ProgressMetricsResponse(dict):
    """
    Progress metrics definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "completedDatapointCount":
            suggest = "completed_datapoint_count"
        elif key == "incrementalDataLastRefreshDateTime":
            suggest = "incremental_data_last_refresh_date_time"
        elif key == "skippedDatapointCount":
            suggest = "skipped_datapoint_count"
        elif key == "totalDatapointCount":
            suggest = "total_datapoint_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProgressMetricsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProgressMetricsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProgressMetricsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 completed_datapoint_count: builtins.float,
                 incremental_data_last_refresh_date_time: builtins.str,
                 skipped_datapoint_count: builtins.float,
                 total_datapoint_count: builtins.float):
        """
        Progress metrics definition
        :param builtins.float completed_datapoint_count: The completed datapoint count.
        :param builtins.str incremental_data_last_refresh_date_time: The time of last successful incremental data refresh in UTC.
        :param builtins.float skipped_datapoint_count: The skipped datapoint count.
        :param builtins.float total_datapoint_count: The total datapoint count.
        """
        pulumi.set(__self__, "completed_datapoint_count", completed_datapoint_count)
        pulumi.set(__self__, "incremental_data_last_refresh_date_time", incremental_data_last_refresh_date_time)
        pulumi.set(__self__, "skipped_datapoint_count", skipped_datapoint_count)
        pulumi.set(__self__, "total_datapoint_count", total_datapoint_count)

    @property
    @pulumi.getter(name="completedDatapointCount")
    def completed_datapoint_count(self) -> builtins.float:
        """
        The completed datapoint count.
        """
        return pulumi.get(self, "completed_datapoint_count")

    @property
    @pulumi.getter(name="incrementalDataLastRefreshDateTime")
    def incremental_data_last_refresh_date_time(self) -> builtins.str:
        """
        The time of last successful incremental data refresh in UTC.
        """
        return pulumi.get(self, "incremental_data_last_refresh_date_time")

    @property
    @pulumi.getter(name="skippedDatapointCount")
    def skipped_datapoint_count(self) -> builtins.float:
        """
        The skipped datapoint count.
        """
        return pulumi.get(self, "skipped_datapoint_count")

    @property
    @pulumi.getter(name="totalDatapointCount")
    def total_datapoint_count(self) -> builtins.float:
        """
        The total datapoint count.
        """
        return pulumi.get(self, "total_datapoint_count")


@pulumi.output_type
class PyTorchResponse(dict):
    """
    PyTorch distribution configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "distributionType":
            suggest = "distribution_type"
        elif key == "processCountPerInstance":
            suggest = "process_count_per_instance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PyTorchResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PyTorchResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PyTorchResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 distribution_type: builtins.str,
                 process_count_per_instance: Optional[builtins.int] = None):
        """
        PyTorch distribution configuration.
        :param builtins.str distribution_type: Enum to determine the job distribution type.
               Expected value is 'PyTorch'.
        :param builtins.int process_count_per_instance: Number of processes per node.
        """
        pulumi.set(__self__, "distribution_type", 'PyTorch')
        if process_count_per_instance is not None:
            pulumi.set(__self__, "process_count_per_instance", process_count_per_instance)

    @property
    @pulumi.getter(name="distributionType")
    def distribution_type(self) -> builtins.str:
        """
        Enum to determine the job distribution type.
        Expected value is 'PyTorch'.
        """
        return pulumi.get(self, "distribution_type")

    @property
    @pulumi.getter(name="processCountPerInstance")
    def process_count_per_instance(self) -> Optional[builtins.int]:
        """
        Number of processes per node.
        """
        return pulumi.get(self, "process_count_per_instance")


@pulumi.output_type
class QueueSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobTier":
            suggest = "job_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_tier: Optional[builtins.str] = None):
        """
        :param builtins.str job_tier: Controls the compute job tier
        """
        if job_tier is None:
            job_tier = 'Null'
        if job_tier is not None:
            pulumi.set(__self__, "job_tier", job_tier)

    @property
    @pulumi.getter(name="jobTier")
    def job_tier(self) -> Optional[builtins.str]:
        """
        Controls the compute job tier
        """
        return pulumi.get(self, "job_tier")


@pulumi.output_type
class RaiBlocklistConfigResponse(dict):
    """
    Azure OpenAI blocklist config.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blocklistName":
            suggest = "blocklist_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RaiBlocklistConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RaiBlocklistConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RaiBlocklistConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blocking: Optional[builtins.bool] = None,
                 blocklist_name: Optional[builtins.str] = None):
        """
        Azure OpenAI blocklist config.
        :param builtins.bool blocking: If blocking would occur.
        :param builtins.str blocklist_name: Name of ContentFilter.
        """
        if blocking is not None:
            pulumi.set(__self__, "blocking", blocking)
        if blocklist_name is not None:
            pulumi.set(__self__, "blocklist_name", blocklist_name)

    @property
    @pulumi.getter
    def blocking(self) -> Optional[builtins.bool]:
        """
        If blocking would occur.
        """
        return pulumi.get(self, "blocking")

    @property
    @pulumi.getter(name="blocklistName")
    def blocklist_name(self) -> Optional[builtins.str]:
        """
        Name of ContentFilter.
        """
        return pulumi.get(self, "blocklist_name")


@pulumi.output_type
class RaiBlocklistItemPropertiesResponse(dict):
    """
    RAI Custom Blocklist Item properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isRegex":
            suggest = "is_regex"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RaiBlocklistItemPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RaiBlocklistItemPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RaiBlocklistItemPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_regex: Optional[builtins.bool] = None,
                 pattern: Optional[builtins.str] = None):
        """
        RAI Custom Blocklist Item properties.
        :param builtins.bool is_regex: If the pattern is a regex pattern.
        :param builtins.str pattern: Pattern to match against.
        """
        if is_regex is not None:
            pulumi.set(__self__, "is_regex", is_regex)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter(name="isRegex")
    def is_regex(self) -> Optional[builtins.bool]:
        """
        If the pattern is a regex pattern.
        """
        return pulumi.get(self, "is_regex")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[builtins.str]:
        """
        Pattern to match against.
        """
        return pulumi.get(self, "pattern")


@pulumi.output_type
class RaiBlocklistPropertiesResponse(dict):
    """
    RAI Custom Blocklist properties.
    """
    def __init__(__self__, *,
                 description: Optional[builtins.str] = None):
        """
        RAI Custom Blocklist properties.
        :param builtins.str description: Description of the block list.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description of the block list.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class RaiPolicyContentFilterResponse(dict):
    """
    Azure OpenAI Content Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedContentLevel":
            suggest = "allowed_content_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RaiPolicyContentFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RaiPolicyContentFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RaiPolicyContentFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_content_level: Optional[builtins.str] = None,
                 blocking: Optional[builtins.bool] = None,
                 enabled: Optional[builtins.bool] = None,
                 name: Optional[builtins.str] = None,
                 source: Optional[builtins.str] = None):
        """
        Azure OpenAI Content Filter.
        :param builtins.str allowed_content_level: Level at which content is filtered.
        :param builtins.bool blocking: If blocking would occur.
        :param builtins.bool enabled: If the ContentFilter is enabled.
        :param builtins.str name: Name of ContentFilter.
        :param builtins.str source: Content source to apply the Content Filters.
        """
        if allowed_content_level is not None:
            pulumi.set(__self__, "allowed_content_level", allowed_content_level)
        if blocking is not None:
            pulumi.set(__self__, "blocking", blocking)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="allowedContentLevel")
    def allowed_content_level(self) -> Optional[builtins.str]:
        """
        Level at which content is filtered.
        """
        return pulumi.get(self, "allowed_content_level")

    @property
    @pulumi.getter
    def blocking(self) -> Optional[builtins.bool]:
        """
        If blocking would occur.
        """
        return pulumi.get(self, "blocking")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        If the ContentFilter is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of ContentFilter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def source(self) -> Optional[builtins.str]:
        """
        Content source to apply the Content Filters.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class RaiPolicyPropertiesResponse(dict):
    """
    Azure OpenAI Content Filters properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basePolicyName":
            suggest = "base_policy_name"
        elif key == "completionBlocklists":
            suggest = "completion_blocklists"
        elif key == "contentFilters":
            suggest = "content_filters"
        elif key == "promptBlocklists":
            suggest = "prompt_blocklists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RaiPolicyPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RaiPolicyPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RaiPolicyPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_policy_name: Optional[builtins.str] = None,
                 completion_blocklists: Optional[Sequence['outputs.RaiBlocklistConfigResponse']] = None,
                 content_filters: Optional[Sequence['outputs.RaiPolicyContentFilterResponse']] = None,
                 mode: Optional[builtins.str] = None,
                 prompt_blocklists: Optional[Sequence['outputs.RaiBlocklistConfigResponse']] = None,
                 type: Optional[builtins.str] = None):
        """
        Azure OpenAI Content Filters properties.
        :param builtins.str base_policy_name: Name of the base Content Filters.
        :param builtins.str mode: Content Filters mode.
        :param builtins.str type: Content Filters policy type.
        """
        if base_policy_name is not None:
            pulumi.set(__self__, "base_policy_name", base_policy_name)
        if completion_blocklists is not None:
            pulumi.set(__self__, "completion_blocklists", completion_blocklists)
        if content_filters is not None:
            pulumi.set(__self__, "content_filters", content_filters)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if prompt_blocklists is not None:
            pulumi.set(__self__, "prompt_blocklists", prompt_blocklists)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="basePolicyName")
    def base_policy_name(self) -> Optional[builtins.str]:
        """
        Name of the base Content Filters.
        """
        return pulumi.get(self, "base_policy_name")

    @property
    @pulumi.getter(name="completionBlocklists")
    def completion_blocklists(self) -> Optional[Sequence['outputs.RaiBlocklistConfigResponse']]:
        return pulumi.get(self, "completion_blocklists")

    @property
    @pulumi.getter(name="contentFilters")
    def content_filters(self) -> Optional[Sequence['outputs.RaiPolicyContentFilterResponse']]:
        return pulumi.get(self, "content_filters")

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Content Filters mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="promptBlocklists")
    def prompt_blocklists(self) -> Optional[Sequence['outputs.RaiBlocklistConfigResponse']]:
        return pulumi.get(self, "prompt_blocklists")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Content Filters policy type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RandomSamplingAlgorithmResponse(dict):
    """
    Defines a Sampling Algorithm that generates values randomly
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "samplingAlgorithmType":
            suggest = "sampling_algorithm_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RandomSamplingAlgorithmResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RandomSamplingAlgorithmResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RandomSamplingAlgorithmResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sampling_algorithm_type: builtins.str,
                 rule: Optional[builtins.str] = None,
                 seed: Optional[builtins.int] = None):
        """
        Defines a Sampling Algorithm that generates values randomly
        :param builtins.str sampling_algorithm_type: 
               Expected value is 'Random'.
        :param builtins.str rule: The specific type of random algorithm
        :param builtins.int seed: An optional integer to use as the seed for random number generation
        """
        pulumi.set(__self__, "sampling_algorithm_type", 'Random')
        if rule is None:
            rule = 'Random'
        if rule is not None:
            pulumi.set(__self__, "rule", rule)
        if seed is not None:
            pulumi.set(__self__, "seed", seed)

    @property
    @pulumi.getter(name="samplingAlgorithmType")
    def sampling_algorithm_type(self) -> builtins.str:
        """

        Expected value is 'Random'.
        """
        return pulumi.get(self, "sampling_algorithm_type")

    @property
    @pulumi.getter
    def rule(self) -> Optional[builtins.str]:
        """
        The specific type of random algorithm
        """
        return pulumi.get(self, "rule")

    @property
    @pulumi.getter
    def seed(self) -> Optional[builtins.int]:
        """
        An optional integer to use as the seed for random number generation
        """
        return pulumi.get(self, "seed")


@pulumi.output_type
class RecurrenceResponse(dict):
    """
    The workflow trigger recurrence for ComputeStartStop schedule type.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecurrenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecurrenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecurrenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency: Optional[builtins.str] = None,
                 interval: Optional[builtins.int] = None,
                 schedule: Optional['outputs.ComputeRecurrenceScheduleResponse'] = None,
                 start_time: Optional[builtins.str] = None,
                 time_zone: Optional[builtins.str] = None):
        """
        The workflow trigger recurrence for ComputeStartStop schedule type.
        :param builtins.str frequency: [Required] The frequency to trigger schedule.
        :param builtins.int interval: [Required] Specifies schedule interval in conjunction with frequency
        :param 'ComputeRecurrenceScheduleResponse' schedule: [Required] The recurrence schedule.
        :param builtins.str start_time: The start time in yyyy-MM-ddTHH:mm:ss format.
        :param builtins.str time_zone: Specifies time zone in which the schedule runs.
               TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
        """
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if time_zone is None:
            time_zone = 'UTC'
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def frequency(self) -> Optional[builtins.str]:
        """
        [Required] The frequency to trigger schedule.
        """
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter
    def interval(self) -> Optional[builtins.int]:
        """
        [Required] Specifies schedule interval in conjunction with frequency
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def schedule(self) -> Optional['outputs.ComputeRecurrenceScheduleResponse']:
        """
        [Required] The recurrence schedule.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[builtins.str]:
        """
        The start time in yyyy-MM-ddTHH:mm:ss format.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[builtins.str]:
        """
        Specifies time zone in which the schedule runs.
        TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class RecurrenceScheduleResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monthDays":
            suggest = "month_days"
        elif key == "weekDays":
            suggest = "week_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecurrenceScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecurrenceScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecurrenceScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hours: Sequence[builtins.int],
                 minutes: Sequence[builtins.int],
                 month_days: Optional[Sequence[builtins.int]] = None,
                 week_days: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.int] hours: [Required] List of hours for the schedule.
        :param Sequence[builtins.int] minutes: [Required] List of minutes for the schedule.
        :param Sequence[builtins.int] month_days: List of month days for the schedule
        :param Sequence[builtins.str] week_days: List of days for the schedule.
        """
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)
        if month_days is not None:
            pulumi.set(__self__, "month_days", month_days)
        if week_days is not None:
            pulumi.set(__self__, "week_days", week_days)

    @property
    @pulumi.getter
    def hours(self) -> Sequence[builtins.int]:
        """
        [Required] List of hours for the schedule.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Sequence[builtins.int]:
        """
        [Required] List of minutes for the schedule.
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter(name="monthDays")
    def month_days(self) -> Optional[Sequence[builtins.int]]:
        """
        List of month days for the schedule
        """
        return pulumi.get(self, "month_days")

    @property
    @pulumi.getter(name="weekDays")
    def week_days(self) -> Optional[Sequence[builtins.str]]:
        """
        List of days for the schedule.
        """
        return pulumi.get(self, "week_days")


@pulumi.output_type
class RecurrenceTriggerResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "triggerType":
            suggest = "trigger_type"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecurrenceTriggerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecurrenceTriggerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecurrenceTriggerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency: builtins.str,
                 interval: builtins.int,
                 trigger_type: builtins.str,
                 end_time: Optional[builtins.str] = None,
                 schedule: Optional['outputs.RecurrenceScheduleResponse'] = None,
                 start_time: Optional[builtins.str] = None,
                 time_zone: Optional[builtins.str] = None):
        """
        :param builtins.str frequency: [Required] The frequency to trigger schedule.
        :param builtins.int interval: [Required] Specifies schedule interval in conjunction with frequency
        :param builtins.str trigger_type: 
               Expected value is 'Recurrence'.
        :param builtins.str end_time: Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer https://en.wikipedia.org/wiki/ISO_8601.
               Recommented format would be "2022-06-01T00:00:01"
               If not present, the schedule will run indefinitely
        :param 'RecurrenceScheduleResponse' schedule: The recurrence schedule.
        :param builtins.str start_time: Specifies start time of schedule in ISO 8601 format, but without a UTC offset.
        :param builtins.str time_zone: Specifies time zone in which the schedule runs.
               TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
        """
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "trigger_type", 'Recurrence')
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if time_zone is None:
            time_zone = 'UTC'
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def frequency(self) -> builtins.str:
        """
        [Required] The frequency to trigger schedule.
        """
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter
    def interval(self) -> builtins.int:
        """
        [Required] Specifies schedule interval in conjunction with frequency
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> builtins.str:
        """

        Expected value is 'Recurrence'.
        """
        return pulumi.get(self, "trigger_type")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[builtins.str]:
        """
        Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer https://en.wikipedia.org/wiki/ISO_8601.
        Recommented format would be "2022-06-01T00:00:01"
        If not present, the schedule will run indefinitely
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter
    def schedule(self) -> Optional['outputs.RecurrenceScheduleResponse']:
        """
        The recurrence schedule.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[builtins.str]:
        """
        Specifies start time of schedule in ISO 8601 format, but without a UTC offset.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[builtins.str]:
        """
        Specifies time zone in which the schedule runs.
        TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class RegistryListCredentialsResultResponse(dict):
    def __init__(__self__, *,
                 location: builtins.str,
                 username: builtins.str,
                 passwords: Optional[Sequence['outputs.PasswordResponse']] = None):
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "username", username)
        if passwords is not None:
            pulumi.set(__self__, "passwords", passwords)

    @property
    @pulumi.getter
    def location(self) -> builtins.str:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def username(self) -> builtins.str:
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def passwords(self) -> Optional[Sequence['outputs.PasswordResponse']]:
        return pulumi.get(self, "passwords")


@pulumi.output_type
class RegistryPrivateEndpointConnectionPropertiesResponse(dict):
    """
    Properties of the Private Endpoint Connection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupIds":
            suggest = "group_ids"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "registryPrivateLinkServiceConnectionState":
            suggest = "registry_private_link_service_connection_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryPrivateEndpointConnectionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryPrivateEndpointConnectionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryPrivateEndpointConnectionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_ids: Optional[Sequence[builtins.str]] = None,
                 private_endpoint: Optional['outputs.PrivateEndpointResourceResponse'] = None,
                 provisioning_state: Optional[builtins.str] = None,
                 registry_private_link_service_connection_state: Optional['outputs.RegistryPrivateLinkServiceConnectionStateResponse'] = None):
        """
        Properties of the Private Endpoint Connection
        :param Sequence[builtins.str] group_ids: The group ids
        :param 'PrivateEndpointResourceResponse' private_endpoint: The PE network resource that is linked to this PE connection.
        :param builtins.str provisioning_state: One of null, "Succeeded", "Provisioning", "Failed". While not approved, it's null.
        :param 'RegistryPrivateLinkServiceConnectionStateResponse' registry_private_link_service_connection_state: The connection state.
        """
        if group_ids is not None:
            pulumi.set(__self__, "group_ids", group_ids)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if provisioning_state is not None:
            pulumi.set(__self__, "provisioning_state", provisioning_state)
        if registry_private_link_service_connection_state is not None:
            pulumi.set(__self__, "registry_private_link_service_connection_state", registry_private_link_service_connection_state)

    @property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        The group ids
        """
        return pulumi.get(self, "group_ids")

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.PrivateEndpointResourceResponse']:
        """
        The PE network resource that is linked to this PE connection.
        """
        return pulumi.get(self, "private_endpoint")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[builtins.str]:
        """
        One of null, "Succeeded", "Provisioning", "Failed". While not approved, it's null.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="registryPrivateLinkServiceConnectionState")
    def registry_private_link_service_connection_state(self) -> Optional['outputs.RegistryPrivateLinkServiceConnectionStateResponse']:
        """
        The connection state.
        """
        return pulumi.get(self, "registry_private_link_service_connection_state")


@pulumi.output_type
class RegistryPrivateEndpointConnectionResponse(dict):
    """
    Private endpoint connection definition.
    """
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None,
                 location: Optional[builtins.str] = None,
                 properties: Optional['outputs.RegistryPrivateEndpointConnectionPropertiesResponse'] = None):
        """
        Private endpoint connection definition.
        :param builtins.str id: This is the private endpoint connection name created on SRP
               Full resource id: /subscriptions/{subId}/resourceGroups/{rgName}/providers/Microsoft.MachineLearningServices/{resourceType}/{resourceName}/registryPrivateEndpointConnections/{peConnectionName}
        :param builtins.str location: Same as workspace location.
        :param 'RegistryPrivateEndpointConnectionPropertiesResponse' properties: Properties of the Private Endpoint Connection
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        This is the private endpoint connection name created on SRP
        Full resource id: /subscriptions/{subId}/resourceGroups/{rgName}/providers/Microsoft.MachineLearningServices/{resourceType}/{resourceName}/registryPrivateEndpointConnections/{peConnectionName}
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> Optional[builtins.str]:
        """
        Same as workspace location.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.RegistryPrivateEndpointConnectionPropertiesResponse']:
        """
        Properties of the Private Endpoint Connection
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class RegistryPrivateLinkServiceConnectionStateResponse(dict):
    """
    The connection state.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsRequired":
            suggest = "actions_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryPrivateLinkServiceConnectionStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryPrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryPrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_required: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 status: Optional[builtins.str] = None):
        """
        The connection state.
        :param builtins.str actions_required: Some RP chose "None". Other RPs use this for region expansion.
        :param builtins.str description: User-defined message that, per NRP doc, may be used for approval-related message.
        :param builtins.str status: Connection status of the service consumer with the service provider
        """
        if actions_required is not None:
            pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[builtins.str]:
        """
        Some RP chose "None". Other RPs use this for region expansion.
        """
        return pulumi.get(self, "actions_required")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        User-defined message that, per NRP doc, may be used for approval-related message.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Connection status of the service consumer with the service provider
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class RegistryRegionArmDetailsResponse(dict):
    """
    Details for each region the registry is in
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acrDetails":
            suggest = "acr_details"
        elif key == "storageAccountDetails":
            suggest = "storage_account_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryRegionArmDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryRegionArmDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryRegionArmDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acr_details: Optional[Sequence['outputs.AcrDetailsResponse']] = None,
                 location: Optional[builtins.str] = None,
                 storage_account_details: Optional[Sequence['outputs.StorageAccountDetailsResponse']] = None):
        """
        Details for each region the registry is in
        :param Sequence['AcrDetailsResponse'] acr_details: List of ACR accounts
        :param builtins.str location: The location where the registry exists
        :param Sequence['StorageAccountDetailsResponse'] storage_account_details: List of storage accounts
        """
        if acr_details is not None:
            pulumi.set(__self__, "acr_details", acr_details)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if storage_account_details is not None:
            pulumi.set(__self__, "storage_account_details", storage_account_details)

    @property
    @pulumi.getter(name="acrDetails")
    def acr_details(self) -> Optional[Sequence['outputs.AcrDetailsResponse']]:
        """
        List of ACR accounts
        """
        return pulumi.get(self, "acr_details")

    @property
    @pulumi.getter
    def location(self) -> Optional[builtins.str]:
        """
        The location where the registry exists
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="storageAccountDetails")
    def storage_account_details(self) -> Optional[Sequence['outputs.StorageAccountDetailsResponse']]:
        """
        List of storage accounts
        """
        return pulumi.get(self, "storage_account_details")


@pulumi.output_type
class RegistryResponse(dict):
    """
    Details of the Registry
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "discoveryUrl":
            suggest = "discovery_url"
        elif key == "intellectualPropertyPublisher":
            suggest = "intellectual_property_publisher"
        elif key == "managedResourceGroup":
            suggest = "managed_resource_group"
        elif key == "mlFlowRegistryUri":
            suggest = "ml_flow_registry_uri"
        elif key == "publicNetworkAccess":
            suggest = "public_network_access"
        elif key == "regionDetails":
            suggest = "region_details"
        elif key == "registryPrivateEndpointConnections":
            suggest = "registry_private_endpoint_connections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 discovery_url: Optional[builtins.str] = None,
                 intellectual_property_publisher: Optional[builtins.str] = None,
                 managed_resource_group: Optional['outputs.ArmResourceIdResponse'] = None,
                 ml_flow_registry_uri: Optional[builtins.str] = None,
                 public_network_access: Optional[builtins.str] = None,
                 region_details: Optional[Sequence['outputs.RegistryRegionArmDetailsResponse']] = None,
                 registry_private_endpoint_connections: Optional[Sequence['outputs.RegistryPrivateEndpointConnectionResponse']] = None):
        """
        Details of the Registry
        :param builtins.str discovery_url: Discovery URL for the Registry
        :param builtins.str intellectual_property_publisher: IntellectualPropertyPublisher for the registry
        :param 'ArmResourceIdResponse' managed_resource_group: ResourceId of the managed RG if the registry has system created resources
        :param builtins.str ml_flow_registry_uri: MLFlow Registry URI for the Registry
        :param builtins.str public_network_access: Is the Registry accessible from the internet?
               Possible values: "Enabled" or "Disabled"
        :param Sequence['RegistryRegionArmDetailsResponse'] region_details: Details of each region the registry is in
        :param Sequence['RegistryPrivateEndpointConnectionResponse'] registry_private_endpoint_connections: Private endpoint connections info used for pending connections in private link portal
        """
        if discovery_url is not None:
            pulumi.set(__self__, "discovery_url", discovery_url)
        if intellectual_property_publisher is not None:
            pulumi.set(__self__, "intellectual_property_publisher", intellectual_property_publisher)
        if managed_resource_group is not None:
            pulumi.set(__self__, "managed_resource_group", managed_resource_group)
        if ml_flow_registry_uri is not None:
            pulumi.set(__self__, "ml_flow_registry_uri", ml_flow_registry_uri)
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)
        if region_details is not None:
            pulumi.set(__self__, "region_details", region_details)
        if registry_private_endpoint_connections is not None:
            pulumi.set(__self__, "registry_private_endpoint_connections", registry_private_endpoint_connections)

    @property
    @pulumi.getter(name="discoveryUrl")
    def discovery_url(self) -> Optional[builtins.str]:
        """
        Discovery URL for the Registry
        """
        return pulumi.get(self, "discovery_url")

    @property
    @pulumi.getter(name="intellectualPropertyPublisher")
    def intellectual_property_publisher(self) -> Optional[builtins.str]:
        """
        IntellectualPropertyPublisher for the registry
        """
        return pulumi.get(self, "intellectual_property_publisher")

    @property
    @pulumi.getter(name="managedResourceGroup")
    def managed_resource_group(self) -> Optional['outputs.ArmResourceIdResponse']:
        """
        ResourceId of the managed RG if the registry has system created resources
        """
        return pulumi.get(self, "managed_resource_group")

    @property
    @pulumi.getter(name="mlFlowRegistryUri")
    def ml_flow_registry_uri(self) -> Optional[builtins.str]:
        """
        MLFlow Registry URI for the Registry
        """
        return pulumi.get(self, "ml_flow_registry_uri")

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[builtins.str]:
        """
        Is the Registry accessible from the internet?
        Possible values: "Enabled" or "Disabled"
        """
        return pulumi.get(self, "public_network_access")

    @property
    @pulumi.getter(name="regionDetails")
    def region_details(self) -> Optional[Sequence['outputs.RegistryRegionArmDetailsResponse']]:
        """
        Details of each region the registry is in
        """
        return pulumi.get(self, "region_details")

    @property
    @pulumi.getter(name="registryPrivateEndpointConnections")
    def registry_private_endpoint_connections(self) -> Optional[Sequence['outputs.RegistryPrivateEndpointConnectionResponse']]:
        """
        Private endpoint connections info used for pending connections in private link portal
        """
        return pulumi.get(self, "registry_private_endpoint_connections")


@pulumi.output_type
class RegressionResponse(dict):
    """
    Regression task in AutoML Table vertical.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "trainingData":
            suggest = "training_data"
        elif key == "cvSplitColumnNames":
            suggest = "cv_split_column_names"
        elif key == "featurizationSettings":
            suggest = "featurization_settings"
        elif key == "limitSettings":
            suggest = "limit_settings"
        elif key == "logVerbosity":
            suggest = "log_verbosity"
        elif key == "nCrossValidations":
            suggest = "n_cross_validations"
        elif key == "primaryMetric":
            suggest = "primary_metric"
        elif key == "targetColumnName":
            suggest = "target_column_name"
        elif key == "testData":
            suggest = "test_data"
        elif key == "testDataSize":
            suggest = "test_data_size"
        elif key == "trainingSettings":
            suggest = "training_settings"
        elif key == "validationData":
            suggest = "validation_data"
        elif key == "validationDataSize":
            suggest = "validation_data_size"
        elif key == "weightColumnName":
            suggest = "weight_column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegressionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegressionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegressionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 task_type: builtins.str,
                 training_data: 'outputs.MLTableJobInputResponse',
                 cv_split_column_names: Optional[Sequence[builtins.str]] = None,
                 featurization_settings: Optional['outputs.TableVerticalFeaturizationSettingsResponse'] = None,
                 limit_settings: Optional['outputs.TableVerticalLimitSettingsResponse'] = None,
                 log_verbosity: Optional[builtins.str] = None,
                 n_cross_validations: Optional[Any] = None,
                 primary_metric: Optional[builtins.str] = None,
                 target_column_name: Optional[builtins.str] = None,
                 test_data: Optional['outputs.MLTableJobInputResponse'] = None,
                 test_data_size: Optional[builtins.float] = None,
                 training_settings: Optional['outputs.RegressionTrainingSettingsResponse'] = None,
                 validation_data: Optional['outputs.MLTableJobInputResponse'] = None,
                 validation_data_size: Optional[builtins.float] = None,
                 weight_column_name: Optional[builtins.str] = None):
        """
        Regression task in AutoML Table vertical.
        :param builtins.str task_type: AutoMLJob Task type.
               Expected value is 'Regression'.
        :param 'MLTableJobInputResponse' training_data: [Required] Training data input.
        :param Sequence[builtins.str] cv_split_column_names: Columns to use for CVSplit data.
        :param 'TableVerticalFeaturizationSettingsResponse' featurization_settings: Featurization inputs needed for AutoML job.
        :param 'TableVerticalLimitSettingsResponse' limit_settings: Execution constraints for AutoMLJob.
        :param builtins.str log_verbosity: Log verbosity for the job.
        :param Union['AutoNCrossValidationsResponse', 'CustomNCrossValidationsResponse'] n_cross_validations: Number of cross validation folds to be applied on training dataset
               when validation dataset is not provided.
        :param builtins.str primary_metric: Primary metric for regression task.
        :param builtins.str target_column_name: Target column name: This is prediction values column.
               Also known as label column name in context of classification tasks.
        :param 'MLTableJobInputResponse' test_data: Test data input.
        :param builtins.float test_data_size: The fraction of test dataset that needs to be set aside for validation purpose.
               Values between (0.0 , 1.0)
               Applied when validation dataset is not provided.
        :param 'RegressionTrainingSettingsResponse' training_settings: Inputs for training phase for an AutoML Job.
        :param 'MLTableJobInputResponse' validation_data: Validation data inputs.
        :param builtins.float validation_data_size: The fraction of training dataset that needs to be set aside for validation purpose.
               Values between (0.0 , 1.0)
               Applied when validation dataset is not provided.
        :param builtins.str weight_column_name: The name of the sample weight column. Automated ML supports a weighted column as an input, causing rows in the data to be weighted up or down.
        """
        pulumi.set(__self__, "task_type", 'Regression')
        pulumi.set(__self__, "training_data", training_data)
        if cv_split_column_names is not None:
            pulumi.set(__self__, "cv_split_column_names", cv_split_column_names)
        if featurization_settings is not None:
            pulumi.set(__self__, "featurization_settings", featurization_settings)
        if limit_settings is not None:
            pulumi.set(__self__, "limit_settings", limit_settings)
        if log_verbosity is None:
            log_verbosity = 'Info'
        if log_verbosity is not None:
            pulumi.set(__self__, "log_verbosity", log_verbosity)
        if n_cross_validations is not None:
            pulumi.set(__self__, "n_cross_validations", n_cross_validations)
        if primary_metric is None:
            primary_metric = 'NormalizedRootMeanSquaredError'
        if primary_metric is not None:
            pulumi.set(__self__, "primary_metric", primary_metric)
        if target_column_name is not None:
            pulumi.set(__self__, "target_column_name", target_column_name)
        if test_data is not None:
            pulumi.set(__self__, "test_data", test_data)
        if test_data_size is not None:
            pulumi.set(__self__, "test_data_size", test_data_size)
        if training_settings is not None:
            pulumi.set(__self__, "training_settings", training_settings)
        if validation_data is not None:
            pulumi.set(__self__, "validation_data", validation_data)
        if validation_data_size is not None:
            pulumi.set(__self__, "validation_data_size", validation_data_size)
        if weight_column_name is not None:
            pulumi.set(__self__, "weight_column_name", weight_column_name)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> builtins.str:
        """
        AutoMLJob Task type.
        Expected value is 'Regression'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="trainingData")
    def training_data(self) -> 'outputs.MLTableJobInputResponse':
        """
        [Required] Training data input.
        """
        return pulumi.get(self, "training_data")

    @property
    @pulumi.getter(name="cvSplitColumnNames")
    def cv_split_column_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Columns to use for CVSplit data.
        """
        return pulumi.get(self, "cv_split_column_names")

    @property
    @pulumi.getter(name="featurizationSettings")
    def featurization_settings(self) -> Optional['outputs.TableVerticalFeaturizationSettingsResponse']:
        """
        Featurization inputs needed for AutoML job.
        """
        return pulumi.get(self, "featurization_settings")

    @property
    @pulumi.getter(name="limitSettings")
    def limit_settings(self) -> Optional['outputs.TableVerticalLimitSettingsResponse']:
        """
        Execution constraints for AutoMLJob.
        """
        return pulumi.get(self, "limit_settings")

    @property
    @pulumi.getter(name="logVerbosity")
    def log_verbosity(self) -> Optional[builtins.str]:
        """
        Log verbosity for the job.
        """
        return pulumi.get(self, "log_verbosity")

    @property
    @pulumi.getter(name="nCrossValidations")
    def n_cross_validations(self) -> Optional[Any]:
        """
        Number of cross validation folds to be applied on training dataset
        when validation dataset is not provided.
        """
        return pulumi.get(self, "n_cross_validations")

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> Optional[builtins.str]:
        """
        Primary metric for regression task.
        """
        return pulumi.get(self, "primary_metric")

    @property
    @pulumi.getter(name="targetColumnName")
    def target_column_name(self) -> Optional[builtins.str]:
        """
        Target column name: This is prediction values column.
        Also known as label column name in context of classification tasks.
        """
        return pulumi.get(self, "target_column_name")

    @property
    @pulumi.getter(name="testData")
    def test_data(self) -> Optional['outputs.MLTableJobInputResponse']:
        """
        Test data input.
        """
        return pulumi.get(self, "test_data")

    @property
    @pulumi.getter(name="testDataSize")
    def test_data_size(self) -> Optional[builtins.float]:
        """
        The fraction of test dataset that needs to be set aside for validation purpose.
        Values between (0.0 , 1.0)
        Applied when validation dataset is not provided.
        """
        return pulumi.get(self, "test_data_size")

    @property
    @pulumi.getter(name="trainingSettings")
    def training_settings(self) -> Optional['outputs.RegressionTrainingSettingsResponse']:
        """
        Inputs for training phase for an AutoML Job.
        """
        return pulumi.get(self, "training_settings")

    @property
    @pulumi.getter(name="validationData")
    def validation_data(self) -> Optional['outputs.MLTableJobInputResponse']:
        """
        Validation data inputs.
        """
        return pulumi.get(self, "validation_data")

    @property
    @pulumi.getter(name="validationDataSize")
    def validation_data_size(self) -> Optional[builtins.float]:
        """
        The fraction of training dataset that needs to be set aside for validation purpose.
        Values between (0.0 , 1.0)
        Applied when validation dataset is not provided.
        """
        return pulumi.get(self, "validation_data_size")

    @property
    @pulumi.getter(name="weightColumnName")
    def weight_column_name(self) -> Optional[builtins.str]:
        """
        The name of the sample weight column. Automated ML supports a weighted column as an input, causing rows in the data to be weighted up or down.
        """
        return pulumi.get(self, "weight_column_name")


@pulumi.output_type
class RegressionTrainingSettingsResponse(dict):
    """
    Regression Training related configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedTrainingAlgorithms":
            suggest = "allowed_training_algorithms"
        elif key == "blockedTrainingAlgorithms":
            suggest = "blocked_training_algorithms"
        elif key == "enableDnnTraining":
            suggest = "enable_dnn_training"
        elif key == "enableModelExplainability":
            suggest = "enable_model_explainability"
        elif key == "enableOnnxCompatibleModels":
            suggest = "enable_onnx_compatible_models"
        elif key == "enableStackEnsemble":
            suggest = "enable_stack_ensemble"
        elif key == "enableVoteEnsemble":
            suggest = "enable_vote_ensemble"
        elif key == "ensembleModelDownloadTimeout":
            suggest = "ensemble_model_download_timeout"
        elif key == "stackEnsembleSettings":
            suggest = "stack_ensemble_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegressionTrainingSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegressionTrainingSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegressionTrainingSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_training_algorithms: Optional[Sequence[builtins.str]] = None,
                 blocked_training_algorithms: Optional[Sequence[builtins.str]] = None,
                 enable_dnn_training: Optional[builtins.bool] = None,
                 enable_model_explainability: Optional[builtins.bool] = None,
                 enable_onnx_compatible_models: Optional[builtins.bool] = None,
                 enable_stack_ensemble: Optional[builtins.bool] = None,
                 enable_vote_ensemble: Optional[builtins.bool] = None,
                 ensemble_model_download_timeout: Optional[builtins.str] = None,
                 stack_ensemble_settings: Optional['outputs.StackEnsembleSettingsResponse'] = None):
        """
        Regression Training related configuration.
        :param Sequence[builtins.str] allowed_training_algorithms: Allowed models for regression task.
        :param Sequence[builtins.str] blocked_training_algorithms: Blocked models for regression task.
        :param builtins.bool enable_dnn_training: Enable recommendation of DNN models.
        :param builtins.bool enable_model_explainability: Flag to turn on explainability on best model.
        :param builtins.bool enable_onnx_compatible_models: Flag for enabling onnx compatible models.
        :param builtins.bool enable_stack_ensemble: Enable stack ensemble run.
        :param builtins.bool enable_vote_ensemble: Enable voting ensemble run.
        :param builtins.str ensemble_model_download_timeout: During VotingEnsemble and StackEnsemble model generation, multiple fitted models from the previous child runs are downloaded.
               Configure this parameter with a higher value than 300 secs, if more time is needed.
        :param 'StackEnsembleSettingsResponse' stack_ensemble_settings: Stack ensemble settings for stack ensemble run.
        """
        if allowed_training_algorithms is not None:
            pulumi.set(__self__, "allowed_training_algorithms", allowed_training_algorithms)
        if blocked_training_algorithms is not None:
            pulumi.set(__self__, "blocked_training_algorithms", blocked_training_algorithms)
        if enable_dnn_training is None:
            enable_dnn_training = False
        if enable_dnn_training is not None:
            pulumi.set(__self__, "enable_dnn_training", enable_dnn_training)
        if enable_model_explainability is None:
            enable_model_explainability = True
        if enable_model_explainability is not None:
            pulumi.set(__self__, "enable_model_explainability", enable_model_explainability)
        if enable_onnx_compatible_models is None:
            enable_onnx_compatible_models = False
        if enable_onnx_compatible_models is not None:
            pulumi.set(__self__, "enable_onnx_compatible_models", enable_onnx_compatible_models)
        if enable_stack_ensemble is None:
            enable_stack_ensemble = True
        if enable_stack_ensemble is not None:
            pulumi.set(__self__, "enable_stack_ensemble", enable_stack_ensemble)
        if enable_vote_ensemble is None:
            enable_vote_ensemble = True
        if enable_vote_ensemble is not None:
            pulumi.set(__self__, "enable_vote_ensemble", enable_vote_ensemble)
        if ensemble_model_download_timeout is None:
            ensemble_model_download_timeout = 'PT5M'
        if ensemble_model_download_timeout is not None:
            pulumi.set(__self__, "ensemble_model_download_timeout", ensemble_model_download_timeout)
        if stack_ensemble_settings is not None:
            pulumi.set(__self__, "stack_ensemble_settings", stack_ensemble_settings)

    @property
    @pulumi.getter(name="allowedTrainingAlgorithms")
    def allowed_training_algorithms(self) -> Optional[Sequence[builtins.str]]:
        """
        Allowed models for regression task.
        """
        return pulumi.get(self, "allowed_training_algorithms")

    @property
    @pulumi.getter(name="blockedTrainingAlgorithms")
    def blocked_training_algorithms(self) -> Optional[Sequence[builtins.str]]:
        """
        Blocked models for regression task.
        """
        return pulumi.get(self, "blocked_training_algorithms")

    @property
    @pulumi.getter(name="enableDnnTraining")
    def enable_dnn_training(self) -> Optional[builtins.bool]:
        """
        Enable recommendation of DNN models.
        """
        return pulumi.get(self, "enable_dnn_training")

    @property
    @pulumi.getter(name="enableModelExplainability")
    def enable_model_explainability(self) -> Optional[builtins.bool]:
        """
        Flag to turn on explainability on best model.
        """
        return pulumi.get(self, "enable_model_explainability")

    @property
    @pulumi.getter(name="enableOnnxCompatibleModels")
    def enable_onnx_compatible_models(self) -> Optional[builtins.bool]:
        """
        Flag for enabling onnx compatible models.
        """
        return pulumi.get(self, "enable_onnx_compatible_models")

    @property
    @pulumi.getter(name="enableStackEnsemble")
    def enable_stack_ensemble(self) -> Optional[builtins.bool]:
        """
        Enable stack ensemble run.
        """
        return pulumi.get(self, "enable_stack_ensemble")

    @property
    @pulumi.getter(name="enableVoteEnsemble")
    def enable_vote_ensemble(self) -> Optional[builtins.bool]:
        """
        Enable voting ensemble run.
        """
        return pulumi.get(self, "enable_vote_ensemble")

    @property
    @pulumi.getter(name="ensembleModelDownloadTimeout")
    def ensemble_model_download_timeout(self) -> Optional[builtins.str]:
        """
        During VotingEnsemble and StackEnsemble model generation, multiple fitted models from the previous child runs are downloaded.
        Configure this parameter with a higher value than 300 secs, if more time is needed.
        """
        return pulumi.get(self, "ensemble_model_download_timeout")

    @property
    @pulumi.getter(name="stackEnsembleSettings")
    def stack_ensemble_settings(self) -> Optional['outputs.StackEnsembleSettingsResponse']:
        """
        Stack ensemble settings for stack ensemble run.
        """
        return pulumi.get(self, "stack_ensemble_settings")


@pulumi.output_type
class RequestConfigurationResponse(dict):
    """
    Scoring requests configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentRequestsPerInstance":
            suggest = "max_concurrent_requests_per_instance"
        elif key == "requestTimeout":
            suggest = "request_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_requests_per_instance: Optional[builtins.int] = None,
                 request_timeout: Optional[builtins.str] = None):
        """
        Scoring requests configuration.
        :param builtins.int max_concurrent_requests_per_instance: The number of maximum concurrent requests per node allowed per deployment. Defaults to 1.
        :param builtins.str request_timeout: The scoring timeout in ISO 8601 format.
               Defaults to 5000ms.
        """
        if max_concurrent_requests_per_instance is None:
            max_concurrent_requests_per_instance = 1
        if max_concurrent_requests_per_instance is not None:
            pulumi.set(__self__, "max_concurrent_requests_per_instance", max_concurrent_requests_per_instance)
        if request_timeout is None:
            request_timeout = 'PT5S'
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)

    @property
    @pulumi.getter(name="maxConcurrentRequestsPerInstance")
    def max_concurrent_requests_per_instance(self) -> Optional[builtins.int]:
        """
        The number of maximum concurrent requests per node allowed per deployment. Defaults to 1.
        """
        return pulumi.get(self, "max_concurrent_requests_per_instance")

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[builtins.str]:
        """
        The scoring timeout in ISO 8601 format.
        Defaults to 5000ms.
        """
        return pulumi.get(self, "request_timeout")


@pulumi.output_type
class RequestLoggingResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "captureHeaders":
            suggest = "capture_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestLoggingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestLoggingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestLoggingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capture_headers: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] capture_headers: For payload logging, we only collect payload by default. If customers also want to collect the specified headers, they can set them in captureHeaders so that backend will collect those headers along with payload.
        """
        if capture_headers is not None:
            pulumi.set(__self__, "capture_headers", capture_headers)

    @property
    @pulumi.getter(name="captureHeaders")
    def capture_headers(self) -> Optional[Sequence[builtins.str]]:
        """
        For payload logging, we only collect payload by default. If customers also want to collect the specified headers, they can set them in captureHeaders so that backend will collect those headers along with payload.
        """
        return pulumi.get(self, "capture_headers")


@pulumi.output_type
class ResourceIdResponse(dict):
    """
    Represents a resource ID. For example, for a subnet, it is the resource URL for the subnet.
    """
    def __init__(__self__, *,
                 id: builtins.str):
        """
        Represents a resource ID. For example, for a subnet, it is the resource URL for the subnet.
        :param builtins.str id: The ID of the resource
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The ID of the resource
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class RollingInputDataResponse(dict):
    """
    Rolling input data definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputDataType":
            suggest = "input_data_type"
        elif key == "jobInputType":
            suggest = "job_input_type"
        elif key == "windowOffset":
            suggest = "window_offset"
        elif key == "windowSize":
            suggest = "window_size"
        elif key == "dataContext":
            suggest = "data_context"
        elif key == "preprocessingComponentId":
            suggest = "preprocessing_component_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RollingInputDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RollingInputDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RollingInputDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_data_type: builtins.str,
                 job_input_type: builtins.str,
                 uri: builtins.str,
                 window_offset: builtins.str,
                 window_size: builtins.str,
                 columns: Optional[Mapping[str, builtins.str]] = None,
                 data_context: Optional[builtins.str] = None,
                 preprocessing_component_id: Optional[builtins.str] = None):
        """
        Rolling input data definition.
        :param builtins.str input_data_type: Monitoring input data type enum.
               Expected value is 'Rolling'.
        :param builtins.str job_input_type: [Required] Specifies the type of job.
        :param builtins.str uri: [Required] Input Asset URI.
        :param builtins.str window_offset: [Required] The time offset between the end of the data window and the monitor's current run time.
        :param builtins.str window_size: [Required] The size of the rolling data window.
        :param Mapping[str, builtins.str] columns: Mapping of column names to special uses.
        :param builtins.str data_context: The context metadata of the data source.
        :param builtins.str preprocessing_component_id: Reference to the component asset used to preprocess the data.
        """
        pulumi.set(__self__, "input_data_type", 'Rolling')
        pulumi.set(__self__, "job_input_type", job_input_type)
        pulumi.set(__self__, "uri", uri)
        pulumi.set(__self__, "window_offset", window_offset)
        pulumi.set(__self__, "window_size", window_size)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if data_context is not None:
            pulumi.set(__self__, "data_context", data_context)
        if preprocessing_component_id is not None:
            pulumi.set(__self__, "preprocessing_component_id", preprocessing_component_id)

    @property
    @pulumi.getter(name="inputDataType")
    def input_data_type(self) -> builtins.str:
        """
        Monitoring input data type enum.
        Expected value is 'Rolling'.
        """
        return pulumi.get(self, "input_data_type")

    @property
    @pulumi.getter(name="jobInputType")
    def job_input_type(self) -> builtins.str:
        """
        [Required] Specifies the type of job.
        """
        return pulumi.get(self, "job_input_type")

    @property
    @pulumi.getter
    def uri(self) -> builtins.str:
        """
        [Required] Input Asset URI.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="windowOffset")
    def window_offset(self) -> builtins.str:
        """
        [Required] The time offset between the end of the data window and the monitor's current run time.
        """
        return pulumi.get(self, "window_offset")

    @property
    @pulumi.getter(name="windowSize")
    def window_size(self) -> builtins.str:
        """
        [Required] The size of the rolling data window.
        """
        return pulumi.get(self, "window_size")

    @property
    @pulumi.getter
    def columns(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Mapping of column names to special uses.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter(name="dataContext")
    def data_context(self) -> Optional[builtins.str]:
        """
        The context metadata of the data source.
        """
        return pulumi.get(self, "data_context")

    @property
    @pulumi.getter(name="preprocessingComponentId")
    def preprocessing_component_id(self) -> Optional[builtins.str]:
        """
        Reference to the component asset used to preprocess the data.
        """
        return pulumi.get(self, "preprocessing_component_id")


@pulumi.output_type
class RouteResponse(dict):
    def __init__(__self__, *,
                 path: builtins.str,
                 port: builtins.int):
        """
        :param builtins.str path: [Required] The path for the route.
        :param builtins.int port: [Required] The port for the route.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def path(self) -> builtins.str:
        """
        [Required] The path for the route.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> builtins.int:
        """
        [Required] The port for the route.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class SASAuthTypeWorkspaceConnectionPropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "createdByWorkspaceArmId":
            suggest = "created_by_workspace_arm_id"
        elif key == "expiryTime":
            suggest = "expiry_time"
        elif key == "isSharedToAll":
            suggest = "is_shared_to_all"
        elif key == "sharedUserList":
            suggest = "shared_user_list"
        elif key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SASAuthTypeWorkspaceConnectionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SASAuthTypeWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SASAuthTypeWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: builtins.str,
                 created_by_workspace_arm_id: builtins.str,
                 group: builtins.str,
                 category: Optional[builtins.str] = None,
                 credentials: Optional['outputs.WorkspaceConnectionSharedAccessSignatureResponse'] = None,
                 expiry_time: Optional[builtins.str] = None,
                 is_shared_to_all: Optional[builtins.bool] = None,
                 metadata: Optional[Mapping[str, builtins.str]] = None,
                 shared_user_list: Optional[Sequence[builtins.str]] = None,
                 target: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None,
                 value_format: Optional[builtins.str] = None):
        """
        :param builtins.str auth_type: Authentication type of the connection target
               Expected value is 'SAS'.
        :param builtins.str group: Group based on connection category
        :param builtins.str category: Category of the connection
        :param Mapping[str, builtins.str] metadata: Store user metadata for this connection
        :param builtins.str value: Value details of the workspace connection.
        :param builtins.str value_format: format for the workspace connection value
        """
        pulumi.set(__self__, "auth_type", 'SAS')
        pulumi.set(__self__, "created_by_workspace_arm_id", created_by_workspace_arm_id)
        pulumi.set(__self__, "group", group)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if expiry_time is not None:
            pulumi.set(__self__, "expiry_time", expiry_time)
        if is_shared_to_all is not None:
            pulumi.set(__self__, "is_shared_to_all", is_shared_to_all)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if shared_user_list is not None:
            pulumi.set(__self__, "shared_user_list", shared_user_list)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> builtins.str:
        """
        Authentication type of the connection target
        Expected value is 'SAS'.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="createdByWorkspaceArmId")
    def created_by_workspace_arm_id(self) -> builtins.str:
        return pulumi.get(self, "created_by_workspace_arm_id")

    @property
    @pulumi.getter
    def group(self) -> builtins.str:
        """
        Group based on connection category
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def category(self) -> Optional[builtins.str]:
        """
        Category of the connection
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.WorkspaceConnectionSharedAccessSignatureResponse']:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="expiryTime")
    def expiry_time(self) -> Optional[builtins.str]:
        return pulumi.get(self, "expiry_time")

    @property
    @pulumi.getter(name="isSharedToAll")
    def is_shared_to_all(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_shared_to_all")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Store user metadata for this connection
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="sharedUserList")
    def shared_user_list(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "shared_user_list")

    @property
    @pulumi.getter
    def target(self) -> Optional[builtins.str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value details of the workspace connection.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[builtins.str]:
        """
        format for the workspace connection value
        """
        return pulumi.get(self, "value_format")


@pulumi.output_type
class SasDatastoreCredentialsResponse(dict):
    """
    SAS datastore credentials configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsType":
            suggest = "credentials_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SasDatastoreCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SasDatastoreCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SasDatastoreCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_type: builtins.str):
        """
        SAS datastore credentials configuration.
        :param builtins.str credentials_type: Enum to determine the datastore credentials type.
               Expected value is 'Sas'.
        """
        pulumi.set(__self__, "credentials_type", 'Sas')

    @property
    @pulumi.getter(name="credentialsType")
    def credentials_type(self) -> builtins.str:
        """
        Enum to determine the datastore credentials type.
        Expected value is 'Sas'.
        """
        return pulumi.get(self, "credentials_type")


@pulumi.output_type
class ScaleSettingsResponse(dict):
    """
    scale settings for AML Compute
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxNodeCount":
            suggest = "max_node_count"
        elif key == "minNodeCount":
            suggest = "min_node_count"
        elif key == "nodeIdleTimeBeforeScaleDown":
            suggest = "node_idle_time_before_scale_down"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_node_count: builtins.int,
                 min_node_count: Optional[builtins.int] = None,
                 node_idle_time_before_scale_down: Optional[builtins.str] = None):
        """
        scale settings for AML Compute
        :param builtins.int max_node_count: Max number of nodes to use
        :param builtins.int min_node_count: Min number of nodes to use
        :param builtins.str node_idle_time_before_scale_down: Node Idle Time before scaling down amlCompute. This string needs to be in the RFC Format.
        """
        pulumi.set(__self__, "max_node_count", max_node_count)
        if min_node_count is None:
            min_node_count = 0
        if min_node_count is not None:
            pulumi.set(__self__, "min_node_count", min_node_count)
        if node_idle_time_before_scale_down is not None:
            pulumi.set(__self__, "node_idle_time_before_scale_down", node_idle_time_before_scale_down)

    @property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> builtins.int:
        """
        Max number of nodes to use
        """
        return pulumi.get(self, "max_node_count")

    @property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> Optional[builtins.int]:
        """
        Min number of nodes to use
        """
        return pulumi.get(self, "min_node_count")

    @property
    @pulumi.getter(name="nodeIdleTimeBeforeScaleDown")
    def node_idle_time_before_scale_down(self) -> Optional[builtins.str]:
        """
        Node Idle Time before scaling down amlCompute. This string needs to be in the RFC Format.
        """
        return pulumi.get(self, "node_idle_time_before_scale_down")


@pulumi.output_type
class ScaleUnitConfigurationResponse(dict):
    """
    Configuration for ScaleUnit pool.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disablePublicEgress":
            suggest = "disable_public_egress"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleUnitConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleUnitConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleUnitConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_public_egress: Optional[builtins.bool] = None,
                 registries: Optional[Sequence[builtins.str]] = None):
        """
        Configuration for ScaleUnit pool.
        :param builtins.bool disable_public_egress: Gets or sets a value indicating whether PublicEgress is disabled.
        :param Sequence[builtins.str] registries: Gets or sets a list of Registry sources that will be used to confirm identity, storage, ACR.
        """
        if disable_public_egress is None:
            disable_public_egress = False
        if disable_public_egress is not None:
            pulumi.set(__self__, "disable_public_egress", disable_public_egress)
        if registries is not None:
            pulumi.set(__self__, "registries", registries)

    @property
    @pulumi.getter(name="disablePublicEgress")
    def disable_public_egress(self) -> Optional[builtins.bool]:
        """
        Gets or sets a value indicating whether PublicEgress is disabled.
        """
        return pulumi.get(self, "disable_public_egress")

    @property
    @pulumi.getter
    def registries(self) -> Optional[Sequence[builtins.str]]:
        """
        Gets or sets a list of Registry sources that will be used to confirm identity, storage, ACR.
        """
        return pulumi.get(self, "registries")


@pulumi.output_type
class ScheduleBaseResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningStatus":
            suggest = "provisioning_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleBaseResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleBaseResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleBaseResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[builtins.str] = None,
                 provisioning_status: Optional[builtins.str] = None,
                 status: Optional[builtins.str] = None):
        """
        :param builtins.str id: A system assigned id for the schedule.
        :param builtins.str provisioning_status: The current deployment state of schedule.
        :param builtins.str status: Is the schedule enabled or disabled?
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if provisioning_status is not None:
            pulumi.set(__self__, "provisioning_status", provisioning_status)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        A system assigned id for the schedule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="provisioningStatus")
    def provisioning_status(self) -> Optional[builtins.str]:
        """
        The current deployment state of schedule.
        """
        return pulumi.get(self, "provisioning_status")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Is the schedule enabled or disabled?
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ScheduleResponse(dict):
    """
    Base definition of a schedule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Any,
                 provisioning_state: builtins.str,
                 trigger: Any,
                 description: Optional[builtins.str] = None,
                 display_name: Optional[builtins.str] = None,
                 is_enabled: Optional[builtins.bool] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Base definition of a schedule
        :param Union['CreateMonitorActionResponse', 'EndpointScheduleActionResponse', 'JobScheduleActionResponse'] action: [Required] Specifies the action of the schedule
        :param builtins.str provisioning_state: Provisioning state for the schedule.
        :param Union['CronTriggerResponse', 'RecurrenceTriggerResponse'] trigger: [Required] Specifies the trigger details
        :param builtins.str description: The asset description text.
        :param builtins.str display_name: Display name of schedule.
        :param builtins.bool is_enabled: Is the schedule enabled?
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "trigger", trigger)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if is_enabled is None:
            is_enabled = True
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def action(self) -> Any:
        """
        [Required] Specifies the action of the schedule
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the schedule.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def trigger(self) -> Any:
        """
        [Required] Specifies the trigger details
        """
        return pulumi.get(self, "trigger")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        Display name of schedule.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[builtins.bool]:
        """
        Is the schedule enabled?
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ScriptReferenceResponse(dict):
    """
    Script reference
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scriptArguments":
            suggest = "script_arguments"
        elif key == "scriptData":
            suggest = "script_data"
        elif key == "scriptSource":
            suggest = "script_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScriptReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScriptReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScriptReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 script_arguments: Optional[builtins.str] = None,
                 script_data: Optional[builtins.str] = None,
                 script_source: Optional[builtins.str] = None,
                 timeout: Optional[builtins.str] = None):
        """
        Script reference
        :param builtins.str script_arguments: Optional command line arguments passed to the script to run.
        :param builtins.str script_data: The location of scripts in the mounted volume.
        :param builtins.str script_source: The storage source of the script: workspace.
        :param builtins.str timeout: Optional time period passed to timeout command.
        """
        if script_arguments is not None:
            pulumi.set(__self__, "script_arguments", script_arguments)
        if script_data is not None:
            pulumi.set(__self__, "script_data", script_data)
        if script_source is not None:
            pulumi.set(__self__, "script_source", script_source)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="scriptArguments")
    def script_arguments(self) -> Optional[builtins.str]:
        """
        Optional command line arguments passed to the script to run.
        """
        return pulumi.get(self, "script_arguments")

    @property
    @pulumi.getter(name="scriptData")
    def script_data(self) -> Optional[builtins.str]:
        """
        The location of scripts in the mounted volume.
        """
        return pulumi.get(self, "script_data")

    @property
    @pulumi.getter(name="scriptSource")
    def script_source(self) -> Optional[builtins.str]:
        """
        The storage source of the script: workspace.
        """
        return pulumi.get(self, "script_source")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[builtins.str]:
        """
        Optional time period passed to timeout command.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ScriptsToExecuteResponse(dict):
    """
    Customized setup scripts
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "creationScript":
            suggest = "creation_script"
        elif key == "startupScript":
            suggest = "startup_script"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScriptsToExecuteResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScriptsToExecuteResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScriptsToExecuteResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 creation_script: Optional['outputs.ScriptReferenceResponse'] = None,
                 startup_script: Optional['outputs.ScriptReferenceResponse'] = None):
        """
        Customized setup scripts
        :param 'ScriptReferenceResponse' creation_script: Script that's run only once during provision of the compute.
        :param 'ScriptReferenceResponse' startup_script: Script that's run every time the machine starts.
        """
        if creation_script is not None:
            pulumi.set(__self__, "creation_script", creation_script)
        if startup_script is not None:
            pulumi.set(__self__, "startup_script", startup_script)

    @property
    @pulumi.getter(name="creationScript")
    def creation_script(self) -> Optional['outputs.ScriptReferenceResponse']:
        """
        Script that's run only once during provision of the compute.
        """
        return pulumi.get(self, "creation_script")

    @property
    @pulumi.getter(name="startupScript")
    def startup_script(self) -> Optional['outputs.ScriptReferenceResponse']:
        """
        Script that's run every time the machine starts.
        """
        return pulumi.get(self, "startup_script")


@pulumi.output_type
class SecretConfigurationResponse(dict):
    """
    Secret Configuration definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceSecretName":
            suggest = "workspace_secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: Optional[builtins.str] = None,
                 workspace_secret_name: Optional[builtins.str] = None):
        """
        Secret Configuration definition.
        :param builtins.str uri: Secret Uri.
               Sample Uri : https://myvault.vault.azure.net/secrets/mysecretname/secretversion
        :param builtins.str workspace_secret_name: Name of secret in workspace key vault.
        """
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if workspace_secret_name is not None:
            pulumi.set(__self__, "workspace_secret_name", workspace_secret_name)

    @property
    @pulumi.getter
    def uri(self) -> Optional[builtins.str]:
        """
        Secret Uri.
        Sample Uri : https://myvault.vault.azure.net/secrets/mysecretname/secretversion
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="workspaceSecretName")
    def workspace_secret_name(self) -> Optional[builtins.str]:
        """
        Name of secret in workspace key vault.
        """
        return pulumi.get(self, "workspace_secret_name")


@pulumi.output_type
class ServerlessComputeSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverlessComputeCustomSubnet":
            suggest = "serverless_compute_custom_subnet"
        elif key == "serverlessComputeNoPublicIP":
            suggest = "serverless_compute_no_public_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessComputeSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessComputeSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessComputeSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 serverless_compute_custom_subnet: Optional[builtins.str] = None,
                 serverless_compute_no_public_ip: Optional[builtins.bool] = None):
        """
        :param builtins.str serverless_compute_custom_subnet: The resource ID of an existing virtual network subnet in which serverless compute nodes should be deployed
        :param builtins.bool serverless_compute_no_public_ip: The flag to signal if serverless compute nodes deployed in custom vNet would have no public IP addresses for a workspace with private endpoint
        """
        if serverless_compute_custom_subnet is not None:
            pulumi.set(__self__, "serverless_compute_custom_subnet", serverless_compute_custom_subnet)
        if serverless_compute_no_public_ip is not None:
            pulumi.set(__self__, "serverless_compute_no_public_ip", serverless_compute_no_public_ip)

    @property
    @pulumi.getter(name="serverlessComputeCustomSubnet")
    def serverless_compute_custom_subnet(self) -> Optional[builtins.str]:
        """
        The resource ID of an existing virtual network subnet in which serverless compute nodes should be deployed
        """
        return pulumi.get(self, "serverless_compute_custom_subnet")

    @property
    @pulumi.getter(name="serverlessComputeNoPublicIP")
    def serverless_compute_no_public_ip(self) -> Optional[builtins.bool]:
        """
        The flag to signal if serverless compute nodes deployed in custom vNet would have no public IP addresses for a workspace with private endpoint
        """
        return pulumi.get(self, "serverless_compute_no_public_ip")


@pulumi.output_type
class ServerlessEndpointResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authMode":
            suggest = "auth_mode"
        elif key == "endpointState":
            suggest = "endpoint_state"
        elif key == "inferenceEndpoint":
            suggest = "inference_endpoint"
        elif key == "marketplaceSubscriptionId":
            suggest = "marketplace_subscription_id"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "contentSafety":
            suggest = "content_safety"
        elif key == "modelSettings":
            suggest = "model_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_mode: builtins.str,
                 endpoint_state: builtins.str,
                 inference_endpoint: 'outputs.ServerlessInferenceEndpointResponse',
                 marketplace_subscription_id: builtins.str,
                 provisioning_state: builtins.str,
                 content_safety: Optional['outputs.ContentSafetyResponse'] = None,
                 model_settings: Optional['outputs.ModelSettingsResponse'] = None):
        """
        :param builtins.str auth_mode: [Required] Specifies the authentication mode for the Serverless endpoint.
        :param builtins.str endpoint_state: The current state of the ServerlessEndpoint.
        :param 'ServerlessInferenceEndpointResponse' inference_endpoint: The inference uri to target when making requests against the serverless endpoint
        :param builtins.str marketplace_subscription_id: The MarketplaceSubscription Azure ID associated to this ServerlessEndpoint.
        :param builtins.str provisioning_state: Provisioning state for the endpoint.
        :param 'ContentSafetyResponse' content_safety: Specifies the content safety options. If omitted, the default content safety settings will be configured
        :param 'ModelSettingsResponse' model_settings: The model settings (model id) for the model being serviced on the ServerlessEndpoint.
        """
        pulumi.set(__self__, "auth_mode", auth_mode)
        pulumi.set(__self__, "endpoint_state", endpoint_state)
        pulumi.set(__self__, "inference_endpoint", inference_endpoint)
        pulumi.set(__self__, "marketplace_subscription_id", marketplace_subscription_id)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if content_safety is not None:
            pulumi.set(__self__, "content_safety", content_safety)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)

    @property
    @pulumi.getter(name="authMode")
    def auth_mode(self) -> builtins.str:
        """
        [Required] Specifies the authentication mode for the Serverless endpoint.
        """
        return pulumi.get(self, "auth_mode")

    @property
    @pulumi.getter(name="endpointState")
    def endpoint_state(self) -> builtins.str:
        """
        The current state of the ServerlessEndpoint.
        """
        return pulumi.get(self, "endpoint_state")

    @property
    @pulumi.getter(name="inferenceEndpoint")
    def inference_endpoint(self) -> 'outputs.ServerlessInferenceEndpointResponse':
        """
        The inference uri to target when making requests against the serverless endpoint
        """
        return pulumi.get(self, "inference_endpoint")

    @property
    @pulumi.getter(name="marketplaceSubscriptionId")
    def marketplace_subscription_id(self) -> builtins.str:
        """
        The MarketplaceSubscription Azure ID associated to this ServerlessEndpoint.
        """
        return pulumi.get(self, "marketplace_subscription_id")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state for the endpoint.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="contentSafety")
    def content_safety(self) -> Optional['outputs.ContentSafetyResponse']:
        """
        Specifies the content safety options. If omitted, the default content safety settings will be configured
        """
        return pulumi.get(self, "content_safety")

    @property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional['outputs.ModelSettingsResponse']:
        """
        The model settings (model id) for the model being serviced on the ServerlessEndpoint.
        """
        return pulumi.get(self, "model_settings")


@pulumi.output_type
class ServerlessInferenceEndpointResponse(dict):
    def __init__(__self__, *,
                 headers: Mapping[str, builtins.str],
                 uri: builtins.str):
        """
        :param Mapping[str, builtins.str] headers: Specifies any required headers to target this serverless endpoint.
        :param builtins.str uri: [Required] The inference uri to target when making requests against the Serverless Endpoint.
        """
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def headers(self) -> Mapping[str, builtins.str]:
        """
        Specifies any required headers to target this serverless endpoint.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def uri(self) -> builtins.str:
        """
        [Required] The inference uri to target when making requests against the Serverless Endpoint.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class ServerlessOfferResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offerName":
            suggest = "offer_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessOfferResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessOfferResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessOfferResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 offer_name: builtins.str,
                 publisher: builtins.str):
        """
        :param builtins.str offer_name: [Required] The name of the Serverless Offer
        :param builtins.str publisher: [Required] Publisher name of the Serverless Offer
        """
        pulumi.set(__self__, "offer_name", offer_name)
        pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter(name="offerName")
    def offer_name(self) -> builtins.str:
        """
        [Required] The name of the Serverless Offer
        """
        return pulumi.get(self, "offer_name")

    @property
    @pulumi.getter
    def publisher(self) -> builtins.str:
        """
        [Required] Publisher name of the Serverless Offer
        """
        return pulumi.get(self, "publisher")


@pulumi.output_type
class ServiceManagedResourcesSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cosmosDb":
            suggest = "cosmos_db"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceManagedResourcesSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceManagedResourcesSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceManagedResourcesSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cosmos_db: Optional['outputs.CosmosDbSettingsResponse'] = None):
        """
        :param 'CosmosDbSettingsResponse' cosmos_db: The settings for the service managed cosmosdb account.
        """
        if cosmos_db is not None:
            pulumi.set(__self__, "cosmos_db", cosmos_db)

    @property
    @pulumi.getter(name="cosmosDb")
    def cosmos_db(self) -> Optional['outputs.CosmosDbSettingsResponse']:
        """
        The settings for the service managed cosmosdb account.
        """
        return pulumi.get(self, "cosmos_db")


@pulumi.output_type
class ServicePrincipalAuthTypeWorkspaceConnectionPropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "createdByWorkspaceArmId":
            suggest = "created_by_workspace_arm_id"
        elif key == "expiryTime":
            suggest = "expiry_time"
        elif key == "isSharedToAll":
            suggest = "is_shared_to_all"
        elif key == "sharedUserList":
            suggest = "shared_user_list"
        elif key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicePrincipalAuthTypeWorkspaceConnectionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicePrincipalAuthTypeWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicePrincipalAuthTypeWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: builtins.str,
                 created_by_workspace_arm_id: builtins.str,
                 group: builtins.str,
                 category: Optional[builtins.str] = None,
                 credentials: Optional['outputs.WorkspaceConnectionServicePrincipalResponse'] = None,
                 expiry_time: Optional[builtins.str] = None,
                 is_shared_to_all: Optional[builtins.bool] = None,
                 metadata: Optional[Mapping[str, builtins.str]] = None,
                 shared_user_list: Optional[Sequence[builtins.str]] = None,
                 target: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None,
                 value_format: Optional[builtins.str] = None):
        """
        :param builtins.str auth_type: Authentication type of the connection target
               Expected value is 'ServicePrincipal'.
        :param builtins.str group: Group based on connection category
        :param builtins.str category: Category of the connection
        :param Mapping[str, builtins.str] metadata: Store user metadata for this connection
        :param builtins.str value: Value details of the workspace connection.
        :param builtins.str value_format: format for the workspace connection value
        """
        pulumi.set(__self__, "auth_type", 'ServicePrincipal')
        pulumi.set(__self__, "created_by_workspace_arm_id", created_by_workspace_arm_id)
        pulumi.set(__self__, "group", group)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if expiry_time is not None:
            pulumi.set(__self__, "expiry_time", expiry_time)
        if is_shared_to_all is not None:
            pulumi.set(__self__, "is_shared_to_all", is_shared_to_all)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if shared_user_list is not None:
            pulumi.set(__self__, "shared_user_list", shared_user_list)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> builtins.str:
        """
        Authentication type of the connection target
        Expected value is 'ServicePrincipal'.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="createdByWorkspaceArmId")
    def created_by_workspace_arm_id(self) -> builtins.str:
        return pulumi.get(self, "created_by_workspace_arm_id")

    @property
    @pulumi.getter
    def group(self) -> builtins.str:
        """
        Group based on connection category
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def category(self) -> Optional[builtins.str]:
        """
        Category of the connection
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.WorkspaceConnectionServicePrincipalResponse']:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="expiryTime")
    def expiry_time(self) -> Optional[builtins.str]:
        return pulumi.get(self, "expiry_time")

    @property
    @pulumi.getter(name="isSharedToAll")
    def is_shared_to_all(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_shared_to_all")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Store user metadata for this connection
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="sharedUserList")
    def shared_user_list(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "shared_user_list")

    @property
    @pulumi.getter
    def target(self) -> Optional[builtins.str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value details of the workspace connection.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[builtins.str]:
        """
        format for the workspace connection value
        """
        return pulumi.get(self, "value_format")


@pulumi.output_type
class ServicePrincipalDatastoreCredentialsResponse(dict):
    """
    Service Principal datastore credentials configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "credentialsType":
            suggest = "credentials_type"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "authorityUrl":
            suggest = "authority_url"
        elif key == "resourceUrl":
            suggest = "resource_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicePrincipalDatastoreCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicePrincipalDatastoreCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicePrincipalDatastoreCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: builtins.str,
                 credentials_type: builtins.str,
                 tenant_id: builtins.str,
                 authority_url: Optional[builtins.str] = None,
                 resource_url: Optional[builtins.str] = None):
        """
        Service Principal datastore credentials configuration.
        :param builtins.str client_id: [Required] Service principal client ID.
        :param builtins.str credentials_type: Enum to determine the datastore credentials type.
               Expected value is 'ServicePrincipal'.
        :param builtins.str tenant_id: [Required] ID of the tenant to which the service principal belongs.
        :param builtins.str authority_url: Authority URL used for authentication.
        :param builtins.str resource_url: Resource the service principal has access to.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "credentials_type", 'ServicePrincipal')
        pulumi.set(__self__, "tenant_id", tenant_id)
        if authority_url is not None:
            pulumi.set(__self__, "authority_url", authority_url)
        if resource_url is not None:
            pulumi.set(__self__, "resource_url", resource_url)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> builtins.str:
        """
        [Required] Service principal client ID.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="credentialsType")
    def credentials_type(self) -> builtins.str:
        """
        Enum to determine the datastore credentials type.
        Expected value is 'ServicePrincipal'.
        """
        return pulumi.get(self, "credentials_type")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> builtins.str:
        """
        [Required] ID of the tenant to which the service principal belongs.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="authorityUrl")
    def authority_url(self) -> Optional[builtins.str]:
        """
        Authority URL used for authentication.
        """
        return pulumi.get(self, "authority_url")

    @property
    @pulumi.getter(name="resourceUrl")
    def resource_url(self) -> Optional[builtins.str]:
        """
        Resource the service principal has access to.
        """
        return pulumi.get(self, "resource_url")


@pulumi.output_type
class ServiceTagDestinationResponse(dict):
    """
    Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPrefixes":
            suggest = "address_prefixes"
        elif key == "portRanges":
            suggest = "port_ranges"
        elif key == "serviceTag":
            suggest = "service_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceTagDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceTagDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceTagDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_prefixes: Sequence[builtins.str],
                 action: Optional[builtins.str] = None,
                 port_ranges: Optional[builtins.str] = None,
                 protocol: Optional[builtins.str] = None,
                 service_tag: Optional[builtins.str] = None):
        """
        Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
        :param Sequence[builtins.str] address_prefixes: Optional, if provided, the ServiceTag property will be ignored.
        :param builtins.str action: The action enum for networking rule.
        """
        pulumi.set(__self__, "address_prefixes", address_prefixes)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Sequence[builtins.str]:
        """
        Optional, if provided, the ServiceTag property will be ignored.
        """
        return pulumi.get(self, "address_prefixes")

    @property
    @pulumi.getter
    def action(self) -> Optional[builtins.str]:
        """
        The action enum for networking rule.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[builtins.str]:
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[builtins.str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[builtins.str]:
        return pulumi.get(self, "service_tag")


@pulumi.output_type
class ServiceTagOutboundRuleResponse(dict):
    """
    Service Tag Outbound Rule for the managed network of a machine learning workspace.
    """
    def __init__(__self__, *,
                 type: builtins.str,
                 category: Optional[builtins.str] = None,
                 destination: Optional['outputs.ServiceTagDestinationResponse'] = None,
                 status: Optional[builtins.str] = None):
        """
        Service Tag Outbound Rule for the managed network of a machine learning workspace.
        :param builtins.str type: Type of a managed network Outbound Rule of a machine learning workspace.
               Expected value is 'ServiceTag'.
        :param builtins.str category: Category of a managed network Outbound Rule of a machine learning workspace.
        :param 'ServiceTagDestinationResponse' destination: Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
        :param builtins.str status: Type of a managed network Outbound Rule of a machine learning workspace.
        """
        pulumi.set(__self__, "type", 'ServiceTag')
        if category is not None:
            pulumi.set(__self__, "category", category)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        Expected value is 'ServiceTag'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def category(self) -> Optional[builtins.str]:
        """
        Category of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.ServiceTagDestinationResponse']:
        """
        Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SetupScriptsResponse(dict):
    """
    Details of customized scripts to execute for setting up the cluster.
    """
    def __init__(__self__, *,
                 scripts: Optional['outputs.ScriptsToExecuteResponse'] = None):
        """
        Details of customized scripts to execute for setting up the cluster.
        :param 'ScriptsToExecuteResponse' scripts: Customized setup scripts
        """
        if scripts is not None:
            pulumi.set(__self__, "scripts", scripts)

    @property
    @pulumi.getter
    def scripts(self) -> Optional['outputs.ScriptsToExecuteResponse']:
        """
        Customized setup scripts
        """
        return pulumi.get(self, "scripts")


@pulumi.output_type
class SharedPrivateLinkResourceResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"
        elif key == "privateLinkResourceId":
            suggest = "private_link_resource_id"
        elif key == "requestMessage":
            suggest = "request_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SharedPrivateLinkResourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SharedPrivateLinkResourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SharedPrivateLinkResourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 private_link_resource_id: Optional[builtins.str] = None,
                 request_message: Optional[builtins.str] = None,
                 status: Optional[builtins.str] = None):
        """
        :param builtins.str group_id: The private link resource group id.
        :param builtins.str name: Unique name of the private link.
        :param builtins.str private_link_resource_id: The resource id that private link links to.
        :param builtins.str request_message: Request message.
        :param builtins.str status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_link_resource_id is not None:
            pulumi.set(__self__, "private_link_resource_id", private_link_resource_id)
        if request_message is not None:
            pulumi.set(__self__, "request_message", request_message)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[builtins.str]:
        """
        The private link resource group id.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Unique name of the private link.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateLinkResourceId")
    def private_link_resource_id(self) -> Optional[builtins.str]:
        """
        The resource id that private link links to.
        """
        return pulumi.get(self, "private_link_resource_id")

    @property
    @pulumi.getter(name="requestMessage")
    def request_message(self) -> Optional[builtins.str]:
        """
        Request message.
        """
        return pulumi.get(self, "request_message")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SkuResponse(dict):
    """
    The resource model definition representing SKU
    """
    def __init__(__self__, *,
                 name: builtins.str,
                 capacity: Optional[builtins.int] = None,
                 family: Optional[builtins.str] = None,
                 size: Optional[builtins.str] = None,
                 tier: Optional[builtins.str] = None):
        """
        The resource model definition representing SKU
        :param builtins.str name: The name of the SKU. Ex - P3. It is typically a letter+number code
        :param builtins.int capacity: If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        :param builtins.str family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
        :param builtins.str size: The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        :param builtins.str tier: This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the SKU. Ex - P3. It is typically a letter+number code
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def capacity(self) -> Optional[builtins.int]:
        """
        If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def family(self) -> Optional[builtins.str]:
        """
        If the service has different generations of hardware, for the same SKU, then that can be captured here.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def size(self) -> Optional[builtins.str]:
        """
        The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def tier(self) -> Optional[builtins.str]:
        """
        This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class SparkJobPythonEntryResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sparkJobEntryType":
            suggest = "spark_job_entry_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkJobPythonEntryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkJobPythonEntryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkJobPythonEntryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file: builtins.str,
                 spark_job_entry_type: builtins.str):
        """
        :param builtins.str file: [Required] Relative python file path for job entry point.
        :param builtins.str spark_job_entry_type: 
               Expected value is 'SparkJobPythonEntry'.
        """
        pulumi.set(__self__, "file", file)
        pulumi.set(__self__, "spark_job_entry_type", 'SparkJobPythonEntry')

    @property
    @pulumi.getter
    def file(self) -> builtins.str:
        """
        [Required] Relative python file path for job entry point.
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter(name="sparkJobEntryType")
    def spark_job_entry_type(self) -> builtins.str:
        """

        Expected value is 'SparkJobPythonEntry'.
        """
        return pulumi.get(self, "spark_job_entry_type")


@pulumi.output_type
class SparkJobResponse(dict):
    """
    Spark job definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codeId":
            suggest = "code_id"
        elif key == "jobType":
            suggest = "job_type"
        elif key == "componentId":
            suggest = "component_id"
        elif key == "computeId":
            suggest = "compute_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "environmentId":
            suggest = "environment_id"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "experimentName":
            suggest = "experiment_name"
        elif key == "isArchived":
            suggest = "is_archived"
        elif key == "notificationSetting":
            suggest = "notification_setting"
        elif key == "pyFiles":
            suggest = "py_files"
        elif key == "queueSettings":
            suggest = "queue_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkJobResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkJobResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkJobResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code_id: builtins.str,
                 entry: Any,
                 job_type: builtins.str,
                 status: builtins.str,
                 archives: Optional[Sequence[builtins.str]] = None,
                 args: Optional[builtins.str] = None,
                 component_id: Optional[builtins.str] = None,
                 compute_id: Optional[builtins.str] = None,
                 conf: Optional[Mapping[str, builtins.str]] = None,
                 description: Optional[builtins.str] = None,
                 display_name: Optional[builtins.str] = None,
                 environment_id: Optional[builtins.str] = None,
                 environment_variables: Optional[Mapping[str, builtins.str]] = None,
                 experiment_name: Optional[builtins.str] = None,
                 files: Optional[Sequence[builtins.str]] = None,
                 identity: Optional[Any] = None,
                 inputs: Optional[Mapping[str, Any]] = None,
                 is_archived: Optional[builtins.bool] = None,
                 jars: Optional[Sequence[builtins.str]] = None,
                 notification_setting: Optional['outputs.NotificationSettingResponse'] = None,
                 outputs: Optional[Mapping[str, Any]] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 py_files: Optional[Sequence[builtins.str]] = None,
                 queue_settings: Optional['outputs.QueueSettingsResponse'] = None,
                 resources: Optional['outputs.SparkResourceConfigurationResponse'] = None,
                 services: Optional[Mapping[str, 'outputs.JobServiceResponse']] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Spark job definition.
        :param builtins.str code_id: [Required] arm-id of the code asset.
        :param Union['SparkJobPythonEntryResponse', 'SparkJobScalaEntryResponse'] entry: [Required] The entry to execute on startup of the job.
        :param builtins.str job_type: Enum to determine the type of job.
               Expected value is 'Spark'.
        :param builtins.str status: Status of the job.
        :param Sequence[builtins.str] archives: Archive files used in the job.
        :param builtins.str args: Arguments for the job.
        :param builtins.str component_id: ARM resource ID of the component resource.
        :param builtins.str compute_id: ARM resource ID of the compute resource.
        :param Mapping[str, builtins.str] conf: Spark configured properties.
        :param builtins.str description: The asset description text.
        :param builtins.str display_name: Display name of job.
        :param builtins.str environment_id: The ARM resource ID of the Environment specification for the job.
        :param Mapping[str, builtins.str] environment_variables: Environment variables included in the job.
        :param builtins.str experiment_name: The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        :param Sequence[builtins.str] files: Files used in the job.
        :param Union['AmlTokenResponse', 'ManagedIdentityResponse', 'UserIdentityResponse'] identity: Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
               Defaults to AmlToken if null.
        :param Mapping[str, Union['CustomModelJobInputResponse', 'LiteralJobInputResponse', 'MLFlowModelJobInputResponse', 'MLTableJobInputResponse', 'TritonModelJobInputResponse', 'UriFileJobInputResponse', 'UriFolderJobInputResponse']] inputs: Mapping of input data bindings used in the job.
        :param builtins.bool is_archived: Is the asset archived?
        :param Sequence[builtins.str] jars: Jar files used in the job.
        :param 'NotificationSettingResponse' notification_setting: Notification setting for the job
        :param Mapping[str, Union['CustomModelJobOutputResponse', 'MLFlowModelJobOutputResponse', 'MLTableJobOutputResponse', 'TritonModelJobOutputResponse', 'UriFileJobOutputResponse', 'UriFolderJobOutputResponse']] outputs: Mapping of output data bindings used in the job.
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param Sequence[builtins.str] py_files: Python files used in the job.
        :param 'QueueSettingsResponse' queue_settings: Queue settings for the job
        :param 'SparkResourceConfigurationResponse' resources: Compute Resource configuration for the job.
        :param Mapping[str, 'JobServiceResponse'] services: List of JobEndpoints.
               For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "code_id", code_id)
        pulumi.set(__self__, "entry", entry)
        pulumi.set(__self__, "job_type", 'Spark')
        pulumi.set(__self__, "status", status)
        if archives is not None:
            pulumi.set(__self__, "archives", archives)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if component_id is not None:
            pulumi.set(__self__, "component_id", component_id)
        if compute_id is not None:
            pulumi.set(__self__, "compute_id", compute_id)
        if conf is not None:
            pulumi.set(__self__, "conf", conf)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if experiment_name is None:
            experiment_name = 'Default'
        if experiment_name is not None:
            pulumi.set(__self__, "experiment_name", experiment_name)
        if files is not None:
            pulumi.set(__self__, "files", files)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if jars is not None:
            pulumi.set(__self__, "jars", jars)
        if notification_setting is not None:
            pulumi.set(__self__, "notification_setting", notification_setting)
        if outputs is not None:
            pulumi.set(__self__, "outputs", outputs)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if py_files is not None:
            pulumi.set(__self__, "py_files", py_files)
        if queue_settings is not None:
            pulumi.set(__self__, "queue_settings", queue_settings)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="codeId")
    def code_id(self) -> builtins.str:
        """
        [Required] arm-id of the code asset.
        """
        return pulumi.get(self, "code_id")

    @property
    @pulumi.getter
    def entry(self) -> Any:
        """
        [Required] The entry to execute on startup of the job.
        """
        return pulumi.get(self, "entry")

    @property
    @pulumi.getter(name="jobType")
    def job_type(self) -> builtins.str:
        """
        Enum to determine the type of job.
        Expected value is 'Spark'.
        """
        return pulumi.get(self, "job_type")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Status of the job.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def archives(self) -> Optional[Sequence[builtins.str]]:
        """
        Archive files used in the job.
        """
        return pulumi.get(self, "archives")

    @property
    @pulumi.getter
    def args(self) -> Optional[builtins.str]:
        """
        Arguments for the job.
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter(name="componentId")
    def component_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of the component resource.
        """
        return pulumi.get(self, "component_id")

    @property
    @pulumi.getter(name="computeId")
    def compute_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of the compute resource.
        """
        return pulumi.get(self, "compute_id")

    @property
    @pulumi.getter
    def conf(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Spark configured properties.
        """
        return pulumi.get(self, "conf")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        Display name of job.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[builtins.str]:
        """
        The ARM resource ID of the Environment specification for the job.
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Environment variables included in the job.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="experimentName")
    def experiment_name(self) -> Optional[builtins.str]:
        """
        The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        """
        return pulumi.get(self, "experiment_name")

    @property
    @pulumi.getter
    def files(self) -> Optional[Sequence[builtins.str]]:
        """
        Files used in the job.
        """
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def identity(self) -> Optional[Any]:
        """
        Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
        Defaults to AmlToken if null.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter
    def inputs(self) -> Optional[Mapping[str, Any]]:
        """
        Mapping of input data bindings used in the job.
        """
        return pulumi.get(self, "inputs")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def jars(self) -> Optional[Sequence[builtins.str]]:
        """
        Jar files used in the job.
        """
        return pulumi.get(self, "jars")

    @property
    @pulumi.getter(name="notificationSetting")
    def notification_setting(self) -> Optional['outputs.NotificationSettingResponse']:
        """
        Notification setting for the job
        """
        return pulumi.get(self, "notification_setting")

    @property
    @pulumi.getter
    def outputs(self) -> Optional[Mapping[str, Any]]:
        """
        Mapping of output data bindings used in the job.
        """
        return pulumi.get(self, "outputs")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="pyFiles")
    def py_files(self) -> Optional[Sequence[builtins.str]]:
        """
        Python files used in the job.
        """
        return pulumi.get(self, "py_files")

    @property
    @pulumi.getter(name="queueSettings")
    def queue_settings(self) -> Optional['outputs.QueueSettingsResponse']:
        """
        Queue settings for the job
        """
        return pulumi.get(self, "queue_settings")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.SparkResourceConfigurationResponse']:
        """
        Compute Resource configuration for the job.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def services(self) -> Optional[Mapping[str, 'outputs.JobServiceResponse']]:
        """
        List of JobEndpoints.
        For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SparkJobScalaEntryResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "className":
            suggest = "class_name"
        elif key == "sparkJobEntryType":
            suggest = "spark_job_entry_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkJobScalaEntryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkJobScalaEntryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkJobScalaEntryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_name: builtins.str,
                 spark_job_entry_type: builtins.str):
        """
        :param builtins.str class_name: [Required] Scala class name used as entry point.
        :param builtins.str spark_job_entry_type: 
               Expected value is 'SparkJobScalaEntry'.
        """
        pulumi.set(__self__, "class_name", class_name)
        pulumi.set(__self__, "spark_job_entry_type", 'SparkJobScalaEntry')

    @property
    @pulumi.getter(name="className")
    def class_name(self) -> builtins.str:
        """
        [Required] Scala class name used as entry point.
        """
        return pulumi.get(self, "class_name")

    @property
    @pulumi.getter(name="sparkJobEntryType")
    def spark_job_entry_type(self) -> builtins.str:
        """

        Expected value is 'SparkJobScalaEntry'.
        """
        return pulumi.get(self, "spark_job_entry_type")


@pulumi.output_type
class SparkResourceConfigurationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceType":
            suggest = "instance_type"
        elif key == "runtimeVersion":
            suggest = "runtime_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkResourceConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkResourceConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkResourceConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_type: Optional[builtins.str] = None,
                 runtime_version: Optional[builtins.str] = None):
        """
        :param builtins.str instance_type: Optional type of VM used as supported by the compute target.
        :param builtins.str runtime_version: Version of spark runtime used for the job.
        """
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if runtime_version is None:
            runtime_version = '3.1'
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[builtins.str]:
        """
        Optional type of VM used as supported by the compute target.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[builtins.str]:
        """
        Version of spark runtime used for the job.
        """
        return pulumi.get(self, "runtime_version")


@pulumi.output_type
class SpeechEndpointDeploymentResourcePropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "failureReason":
            suggest = "failure_reason"
        elif key == "raiPolicyName":
            suggest = "rai_policy_name"
        elif key == "versionUpgradeOption":
            suggest = "version_upgrade_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpeechEndpointDeploymentResourcePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpeechEndpointDeploymentResourcePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpeechEndpointDeploymentResourcePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model: 'outputs.EndpointDeploymentModelResponse',
                 provisioning_state: builtins.str,
                 type: builtins.str,
                 failure_reason: Optional[builtins.str] = None,
                 rai_policy_name: Optional[builtins.str] = None,
                 sku: Optional['outputs.CognitiveServicesSkuResponse'] = None,
                 version_upgrade_option: Optional[builtins.str] = None):
        """
        :param 'EndpointDeploymentModelResponse' model: Model used for the endpoint deployment.
        :param builtins.str provisioning_state: Read-only provision state status property.
        :param builtins.str type: Kind of the deployment.
               Expected value is 'Azure.Speech'.
        :param builtins.str failure_reason: The failure reason if the creation failed.
        :param builtins.str rai_policy_name: The name of RAI policy.
        :param builtins.str version_upgrade_option: Deployment model version upgrade option.
        """
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "type", 'Azure.Speech')
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if rai_policy_name is not None:
            pulumi.set(__self__, "rai_policy_name", rai_policy_name)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)
        if version_upgrade_option is not None:
            pulumi.set(__self__, "version_upgrade_option", version_upgrade_option)

    @property
    @pulumi.getter
    def model(self) -> 'outputs.EndpointDeploymentModelResponse':
        """
        Model used for the endpoint deployment.
        """
        return pulumi.get(self, "model")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Read-only provision state status property.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Kind of the deployment.
        Expected value is 'Azure.Speech'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[builtins.str]:
        """
        The failure reason if the creation failed.
        """
        return pulumi.get(self, "failure_reason")

    @property
    @pulumi.getter(name="raiPolicyName")
    def rai_policy_name(self) -> Optional[builtins.str]:
        """
        The name of RAI policy.
        """
        return pulumi.get(self, "rai_policy_name")

    @property
    @pulumi.getter
    def sku(self) -> Optional['outputs.CognitiveServicesSkuResponse']:
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter(name="versionUpgradeOption")
    def version_upgrade_option(self) -> Optional[builtins.str]:
        """
        Deployment model version upgrade option.
        """
        return pulumi.get(self, "version_upgrade_option")


@pulumi.output_type
class SslConfigurationResponse(dict):
    """
    The ssl configuration for scoring
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "leafDomainLabel":
            suggest = "leaf_domain_label"
        elif key == "overwriteExistingDomain":
            suggest = "overwrite_existing_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SslConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SslConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SslConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert: Optional[builtins.str] = None,
                 cname: Optional[builtins.str] = None,
                 key: Optional[builtins.str] = None,
                 leaf_domain_label: Optional[builtins.str] = None,
                 overwrite_existing_domain: Optional[builtins.bool] = None,
                 status: Optional[builtins.str] = None):
        """
        The ssl configuration for scoring
        :param builtins.str cert: Cert data
        :param builtins.str cname: CNAME of the cert
        :param builtins.str key: Key data
        :param builtins.str leaf_domain_label: Leaf domain label of public endpoint
        :param builtins.bool overwrite_existing_domain: Indicates whether to overwrite existing domain label.
        :param builtins.str status: Enable or disable ssl for scoring
        """
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if cname is not None:
            pulumi.set(__self__, "cname", cname)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if leaf_domain_label is not None:
            pulumi.set(__self__, "leaf_domain_label", leaf_domain_label)
        if overwrite_existing_domain is not None:
            pulumi.set(__self__, "overwrite_existing_domain", overwrite_existing_domain)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def cert(self) -> Optional[builtins.str]:
        """
        Cert data
        """
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def cname(self) -> Optional[builtins.str]:
        """
        CNAME of the cert
        """
        return pulumi.get(self, "cname")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        Key data
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="leafDomainLabel")
    def leaf_domain_label(self) -> Optional[builtins.str]:
        """
        Leaf domain label of public endpoint
        """
        return pulumi.get(self, "leaf_domain_label")

    @property
    @pulumi.getter(name="overwriteExistingDomain")
    def overwrite_existing_domain(self) -> Optional[builtins.bool]:
        """
        Indicates whether to overwrite existing domain label.
        """
        return pulumi.get(self, "overwrite_existing_domain")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Enable or disable ssl for scoring
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class StackEnsembleSettingsResponse(dict):
    """
    Advances setting to customize StackEnsemble run.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stackMetaLearnerKWargs":
            suggest = "stack_meta_learner_k_wargs"
        elif key == "stackMetaLearnerTrainPercentage":
            suggest = "stack_meta_learner_train_percentage"
        elif key == "stackMetaLearnerType":
            suggest = "stack_meta_learner_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StackEnsembleSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StackEnsembleSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StackEnsembleSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 stack_meta_learner_k_wargs: Optional[Any] = None,
                 stack_meta_learner_train_percentage: Optional[builtins.float] = None,
                 stack_meta_learner_type: Optional[builtins.str] = None):
        """
        Advances setting to customize StackEnsemble run.
        :param Any stack_meta_learner_k_wargs: Optional parameters to pass to the initializer of the meta-learner.
        :param builtins.float stack_meta_learner_train_percentage: Specifies the proportion of the training set (when choosing train and validation type of training) to be reserved for training the meta-learner. Default value is 0.2.
        :param builtins.str stack_meta_learner_type: The meta-learner is a model trained on the output of the individual heterogeneous models.
        """
        if stack_meta_learner_k_wargs is not None:
            pulumi.set(__self__, "stack_meta_learner_k_wargs", stack_meta_learner_k_wargs)
        if stack_meta_learner_train_percentage is None:
            stack_meta_learner_train_percentage = 0.2
        if stack_meta_learner_train_percentage is not None:
            pulumi.set(__self__, "stack_meta_learner_train_percentage", stack_meta_learner_train_percentage)
        if stack_meta_learner_type is None:
            stack_meta_learner_type = 'None'
        if stack_meta_learner_type is not None:
            pulumi.set(__self__, "stack_meta_learner_type", stack_meta_learner_type)

    @property
    @pulumi.getter(name="stackMetaLearnerKWargs")
    def stack_meta_learner_k_wargs(self) -> Optional[Any]:
        """
        Optional parameters to pass to the initializer of the meta-learner.
        """
        return pulumi.get(self, "stack_meta_learner_k_wargs")

    @property
    @pulumi.getter(name="stackMetaLearnerTrainPercentage")
    def stack_meta_learner_train_percentage(self) -> Optional[builtins.float]:
        """
        Specifies the proportion of the training set (when choosing train and validation type of training) to be reserved for training the meta-learner. Default value is 0.2.
        """
        return pulumi.get(self, "stack_meta_learner_train_percentage")

    @property
    @pulumi.getter(name="stackMetaLearnerType")
    def stack_meta_learner_type(self) -> Optional[builtins.str]:
        """
        The meta-learner is a model trained on the output of the individual heterogeneous models.
        """
        return pulumi.get(self, "stack_meta_learner_type")


@pulumi.output_type
class StaticInputDataResponse(dict):
    """
    Static input data definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputDataType":
            suggest = "input_data_type"
        elif key == "jobInputType":
            suggest = "job_input_type"
        elif key == "windowEnd":
            suggest = "window_end"
        elif key == "windowStart":
            suggest = "window_start"
        elif key == "dataContext":
            suggest = "data_context"
        elif key == "preprocessingComponentId":
            suggest = "preprocessing_component_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StaticInputDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StaticInputDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StaticInputDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_data_type: builtins.str,
                 job_input_type: builtins.str,
                 uri: builtins.str,
                 window_end: builtins.str,
                 window_start: builtins.str,
                 columns: Optional[Mapping[str, builtins.str]] = None,
                 data_context: Optional[builtins.str] = None,
                 preprocessing_component_id: Optional[builtins.str] = None):
        """
        Static input data definition.
        :param builtins.str input_data_type: Monitoring input data type enum.
               Expected value is 'Static'.
        :param builtins.str job_input_type: [Required] Specifies the type of job.
        :param builtins.str uri: [Required] Input Asset URI.
        :param builtins.str window_end: [Required] The end date of the data window.
        :param builtins.str window_start: [Required] The start date of the data window.
        :param Mapping[str, builtins.str] columns: Mapping of column names to special uses.
        :param builtins.str data_context: The context metadata of the data source.
        :param builtins.str preprocessing_component_id: Reference to the component asset used to preprocess the data.
        """
        pulumi.set(__self__, "input_data_type", 'Static')
        pulumi.set(__self__, "job_input_type", job_input_type)
        pulumi.set(__self__, "uri", uri)
        pulumi.set(__self__, "window_end", window_end)
        pulumi.set(__self__, "window_start", window_start)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if data_context is not None:
            pulumi.set(__self__, "data_context", data_context)
        if preprocessing_component_id is not None:
            pulumi.set(__self__, "preprocessing_component_id", preprocessing_component_id)

    @property
    @pulumi.getter(name="inputDataType")
    def input_data_type(self) -> builtins.str:
        """
        Monitoring input data type enum.
        Expected value is 'Static'.
        """
        return pulumi.get(self, "input_data_type")

    @property
    @pulumi.getter(name="jobInputType")
    def job_input_type(self) -> builtins.str:
        """
        [Required] Specifies the type of job.
        """
        return pulumi.get(self, "job_input_type")

    @property
    @pulumi.getter
    def uri(self) -> builtins.str:
        """
        [Required] Input Asset URI.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="windowEnd")
    def window_end(self) -> builtins.str:
        """
        [Required] The end date of the data window.
        """
        return pulumi.get(self, "window_end")

    @property
    @pulumi.getter(name="windowStart")
    def window_start(self) -> builtins.str:
        """
        [Required] The start date of the data window.
        """
        return pulumi.get(self, "window_start")

    @property
    @pulumi.getter
    def columns(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Mapping of column names to special uses.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter(name="dataContext")
    def data_context(self) -> Optional[builtins.str]:
        """
        The context metadata of the data source.
        """
        return pulumi.get(self, "data_context")

    @property
    @pulumi.getter(name="preprocessingComponentId")
    def preprocessing_component_id(self) -> Optional[builtins.str]:
        """
        Reference to the component asset used to preprocess the data.
        """
        return pulumi.get(self, "preprocessing_component_id")


@pulumi.output_type
class StatusMessageResponse(dict):
    """
    Active message associated with project
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdDateTime":
            suggest = "created_date_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatusMessageResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatusMessageResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatusMessageResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code: builtins.str,
                 created_date_time: builtins.str,
                 level: builtins.str,
                 message: builtins.str):
        """
        Active message associated with project
        :param builtins.str code: Service-defined message code.
        :param builtins.str created_date_time: Time in UTC at which the message was created.
        :param builtins.str level: Severity level of message.
        :param builtins.str message: A human-readable representation of the message code.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "created_date_time", created_date_time)
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> builtins.str:
        """
        Service-defined message code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="createdDateTime")
    def created_date_time(self) -> builtins.str:
        """
        Time in UTC at which the message was created.
        """
        return pulumi.get(self, "created_date_time")

    @property
    @pulumi.getter
    def level(self) -> builtins.str:
        """
        Severity level of message.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def message(self) -> builtins.str:
        """
        A human-readable representation of the message code.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class StorageAccountDetailsResponse(dict):
    """
    Details of storage account to be used for the Registry
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemCreatedStorageAccount":
            suggest = "system_created_storage_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageAccountDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageAccountDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageAccountDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 system_created_storage_account: Optional['outputs.SystemCreatedStorageAccountResponse'] = None):
        """
        Details of storage account to be used for the Registry
        :param 'SystemCreatedStorageAccountResponse' system_created_storage_account: Details of system created storage account to be used for the registry
        """
        if system_created_storage_account is not None:
            pulumi.set(__self__, "system_created_storage_account", system_created_storage_account)

    @property
    @pulumi.getter(name="systemCreatedStorageAccount")
    def system_created_storage_account(self) -> Optional['outputs.SystemCreatedStorageAccountResponse']:
        """
        Details of system created storage account to be used for the registry
        """
        return pulumi.get(self, "system_created_storage_account")


@pulumi.output_type
class StringStringKeyValuePairResponse(dict):
    def __init__(__self__, *,
                 key: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class SweepJobLimitsResponse(dict):
    """
    Sweep Job limit class.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobLimitsType":
            suggest = "job_limits_type"
        elif key == "maxConcurrentTrials":
            suggest = "max_concurrent_trials"
        elif key == "maxTotalTrials":
            suggest = "max_total_trials"
        elif key == "trialTimeout":
            suggest = "trial_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SweepJobLimitsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SweepJobLimitsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SweepJobLimitsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_limits_type: builtins.str,
                 max_concurrent_trials: Optional[builtins.int] = None,
                 max_total_trials: Optional[builtins.int] = None,
                 timeout: Optional[builtins.str] = None,
                 trial_timeout: Optional[builtins.str] = None):
        """
        Sweep Job limit class.
        :param builtins.str job_limits_type: 
               Expected value is 'Sweep'.
        :param builtins.int max_concurrent_trials: Sweep Job max concurrent trials.
        :param builtins.int max_total_trials: Sweep Job max total trials.
        :param builtins.str timeout: The max run duration in ISO 8601 format, after which the job will be cancelled. Only supports duration with precision as low as Seconds.
        :param builtins.str trial_timeout: Sweep Job Trial timeout value.
        """
        pulumi.set(__self__, "job_limits_type", 'Sweep')
        if max_concurrent_trials is not None:
            pulumi.set(__self__, "max_concurrent_trials", max_concurrent_trials)
        if max_total_trials is not None:
            pulumi.set(__self__, "max_total_trials", max_total_trials)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if trial_timeout is not None:
            pulumi.set(__self__, "trial_timeout", trial_timeout)

    @property
    @pulumi.getter(name="jobLimitsType")
    def job_limits_type(self) -> builtins.str:
        """

        Expected value is 'Sweep'.
        """
        return pulumi.get(self, "job_limits_type")

    @property
    @pulumi.getter(name="maxConcurrentTrials")
    def max_concurrent_trials(self) -> Optional[builtins.int]:
        """
        Sweep Job max concurrent trials.
        """
        return pulumi.get(self, "max_concurrent_trials")

    @property
    @pulumi.getter(name="maxTotalTrials")
    def max_total_trials(self) -> Optional[builtins.int]:
        """
        Sweep Job max total trials.
        """
        return pulumi.get(self, "max_total_trials")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[builtins.str]:
        """
        The max run duration in ISO 8601 format, after which the job will be cancelled. Only supports duration with precision as low as Seconds.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="trialTimeout")
    def trial_timeout(self) -> Optional[builtins.str]:
        """
        Sweep Job Trial timeout value.
        """
        return pulumi.get(self, "trial_timeout")


@pulumi.output_type
class SweepJobResponse(dict):
    """
    Sweep job definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobType":
            suggest = "job_type"
        elif key == "samplingAlgorithm":
            suggest = "sampling_algorithm"
        elif key == "searchSpace":
            suggest = "search_space"
        elif key == "componentId":
            suggest = "component_id"
        elif key == "computeId":
            suggest = "compute_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "earlyTermination":
            suggest = "early_termination"
        elif key == "experimentName":
            suggest = "experiment_name"
        elif key == "isArchived":
            suggest = "is_archived"
        elif key == "notificationSetting":
            suggest = "notification_setting"
        elif key == "queueSettings":
            suggest = "queue_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SweepJobResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SweepJobResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SweepJobResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_type: builtins.str,
                 objective: 'outputs.ObjectiveResponse',
                 sampling_algorithm: Any,
                 search_space: Any,
                 status: builtins.str,
                 trial: 'outputs.TrialComponentResponse',
                 component_id: Optional[builtins.str] = None,
                 compute_id: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 display_name: Optional[builtins.str] = None,
                 early_termination: Optional[Any] = None,
                 experiment_name: Optional[builtins.str] = None,
                 identity: Optional[Any] = None,
                 inputs: Optional[Mapping[str, Any]] = None,
                 is_archived: Optional[builtins.bool] = None,
                 limits: Optional['outputs.SweepJobLimitsResponse'] = None,
                 notification_setting: Optional['outputs.NotificationSettingResponse'] = None,
                 outputs: Optional[Mapping[str, Any]] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 queue_settings: Optional['outputs.QueueSettingsResponse'] = None,
                 services: Optional[Mapping[str, 'outputs.JobServiceResponse']] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Sweep job definition.
        :param builtins.str job_type: Enum to determine the type of job.
               Expected value is 'Sweep'.
        :param 'ObjectiveResponse' objective: [Required] Optimization objective.
        :param Union['BayesianSamplingAlgorithmResponse', 'GridSamplingAlgorithmResponse', 'RandomSamplingAlgorithmResponse'] sampling_algorithm: [Required] The hyperparameter sampling algorithm
        :param Any search_space: [Required] A dictionary containing each parameter and its distribution. The dictionary key is the name of the parameter
        :param builtins.str status: Status of the job.
        :param 'TrialComponentResponse' trial: [Required] Trial component definition.
        :param builtins.str component_id: ARM resource ID of the component resource.
        :param builtins.str compute_id: ARM resource ID of the compute resource.
        :param builtins.str description: The asset description text.
        :param builtins.str display_name: Display name of job.
        :param Union['BanditPolicyResponse', 'MedianStoppingPolicyResponse', 'TruncationSelectionPolicyResponse'] early_termination: Early termination policies enable canceling poor-performing runs before they complete
        :param builtins.str experiment_name: The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        :param Union['AmlTokenResponse', 'ManagedIdentityResponse', 'UserIdentityResponse'] identity: Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
               Defaults to AmlToken if null.
        :param Mapping[str, Union['CustomModelJobInputResponse', 'LiteralJobInputResponse', 'MLFlowModelJobInputResponse', 'MLTableJobInputResponse', 'TritonModelJobInputResponse', 'UriFileJobInputResponse', 'UriFolderJobInputResponse']] inputs: Mapping of input data bindings used in the job.
        :param builtins.bool is_archived: Is the asset archived?
        :param 'SweepJobLimitsResponse' limits: Sweep Job limit.
        :param 'NotificationSettingResponse' notification_setting: Notification setting for the job
        :param Mapping[str, Union['CustomModelJobOutputResponse', 'MLFlowModelJobOutputResponse', 'MLTableJobOutputResponse', 'TritonModelJobOutputResponse', 'UriFileJobOutputResponse', 'UriFolderJobOutputResponse']] outputs: Mapping of output data bindings used in the job.
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param 'QueueSettingsResponse' queue_settings: Queue settings for the job
        :param Mapping[str, 'JobServiceResponse'] services: List of JobEndpoints.
               For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "job_type", 'Sweep')
        pulumi.set(__self__, "objective", objective)
        pulumi.set(__self__, "sampling_algorithm", sampling_algorithm)
        pulumi.set(__self__, "search_space", search_space)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "trial", trial)
        if component_id is not None:
            pulumi.set(__self__, "component_id", component_id)
        if compute_id is not None:
            pulumi.set(__self__, "compute_id", compute_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if early_termination is not None:
            pulumi.set(__self__, "early_termination", early_termination)
        if experiment_name is None:
            experiment_name = 'Default'
        if experiment_name is not None:
            pulumi.set(__self__, "experiment_name", experiment_name)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if notification_setting is not None:
            pulumi.set(__self__, "notification_setting", notification_setting)
        if outputs is not None:
            pulumi.set(__self__, "outputs", outputs)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if queue_settings is not None:
            pulumi.set(__self__, "queue_settings", queue_settings)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="jobType")
    def job_type(self) -> builtins.str:
        """
        Enum to determine the type of job.
        Expected value is 'Sweep'.
        """
        return pulumi.get(self, "job_type")

    @property
    @pulumi.getter
    def objective(self) -> 'outputs.ObjectiveResponse':
        """
        [Required] Optimization objective.
        """
        return pulumi.get(self, "objective")

    @property
    @pulumi.getter(name="samplingAlgorithm")
    def sampling_algorithm(self) -> Any:
        """
        [Required] The hyperparameter sampling algorithm
        """
        return pulumi.get(self, "sampling_algorithm")

    @property
    @pulumi.getter(name="searchSpace")
    def search_space(self) -> Any:
        """
        [Required] A dictionary containing each parameter and its distribution. The dictionary key is the name of the parameter
        """
        return pulumi.get(self, "search_space")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Status of the job.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def trial(self) -> 'outputs.TrialComponentResponse':
        """
        [Required] Trial component definition.
        """
        return pulumi.get(self, "trial")

    @property
    @pulumi.getter(name="componentId")
    def component_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of the component resource.
        """
        return pulumi.get(self, "component_id")

    @property
    @pulumi.getter(name="computeId")
    def compute_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of the compute resource.
        """
        return pulumi.get(self, "compute_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        Display name of job.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="earlyTermination")
    def early_termination(self) -> Optional[Any]:
        """
        Early termination policies enable canceling poor-performing runs before they complete
        """
        return pulumi.get(self, "early_termination")

    @property
    @pulumi.getter(name="experimentName")
    def experiment_name(self) -> Optional[builtins.str]:
        """
        The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        """
        return pulumi.get(self, "experiment_name")

    @property
    @pulumi.getter
    def identity(self) -> Optional[Any]:
        """
        Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
        Defaults to AmlToken if null.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter
    def inputs(self) -> Optional[Mapping[str, Any]]:
        """
        Mapping of input data bindings used in the job.
        """
        return pulumi.get(self, "inputs")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def limits(self) -> Optional['outputs.SweepJobLimitsResponse']:
        """
        Sweep Job limit.
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter(name="notificationSetting")
    def notification_setting(self) -> Optional['outputs.NotificationSettingResponse']:
        """
        Notification setting for the job
        """
        return pulumi.get(self, "notification_setting")

    @property
    @pulumi.getter
    def outputs(self) -> Optional[Mapping[str, Any]]:
        """
        Mapping of output data bindings used in the job.
        """
        return pulumi.get(self, "outputs")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="queueSettings")
    def queue_settings(self) -> Optional['outputs.QueueSettingsResponse']:
        """
        Queue settings for the job
        """
        return pulumi.get(self, "queue_settings")

    @property
    @pulumi.getter
    def services(self) -> Optional[Mapping[str, 'outputs.JobServiceResponse']]:
        """
        List of JobEndpoints.
        For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SynapseSparkResponse(dict):
    """
    A SynapseSpark compute.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeType":
            suggest = "compute_type"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "isAttachedCompute":
            suggest = "is_attached_compute"
        elif key == "modifiedOn":
            suggest = "modified_on"
        elif key == "provisioningErrors":
            suggest = "provisioning_errors"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "computeLocation":
            suggest = "compute_location"
        elif key == "disableLocalAuth":
            suggest = "disable_local_auth"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SynapseSparkResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SynapseSparkResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SynapseSparkResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_type: builtins.str,
                 created_on: builtins.str,
                 is_attached_compute: builtins.bool,
                 modified_on: builtins.str,
                 provisioning_errors: Sequence['outputs.ErrorResponseResponse'],
                 provisioning_state: builtins.str,
                 compute_location: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 disable_local_auth: Optional[builtins.bool] = None,
                 properties: Optional['outputs.SynapseSparkResponseProperties'] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        A SynapseSpark compute.
        :param builtins.str compute_type: The type of compute
               Expected value is 'SynapseSpark'.
        :param builtins.str created_on: The time at which the compute was created.
        :param builtins.bool is_attached_compute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        :param builtins.str modified_on: The time at which the compute was last modified.
        :param Sequence['ErrorResponseResponse'] provisioning_errors: Errors during provisioning
        :param builtins.str provisioning_state: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        :param builtins.str compute_location: Location for the underlying compute
        :param builtins.str description: The description of the Machine Learning compute.
        :param builtins.bool disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        :param builtins.str resource_id: ARM resource id of the underlying compute
        """
        pulumi.set(__self__, "compute_type", 'SynapseSpark')
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "is_attached_compute", is_attached_compute)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "provisioning_errors", provisioning_errors)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if compute_location is not None:
            pulumi.set(__self__, "compute_location", compute_location)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_local_auth is not None:
            pulumi.set(__self__, "disable_local_auth", disable_local_auth)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> builtins.str:
        """
        The type of compute
        Expected value is 'SynapseSpark'.
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> builtins.str:
        """
        The time at which the compute was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="isAttachedCompute")
    def is_attached_compute(self) -> builtins.bool:
        """
        Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        """
        return pulumi.get(self, "is_attached_compute")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> builtins.str:
        """
        The time at which the compute was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="provisioningErrors")
    def provisioning_errors(self) -> Sequence['outputs.ErrorResponseResponse']:
        """
        Errors during provisioning
        """
        return pulumi.get(self, "provisioning_errors")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[builtins.str]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[builtins.bool]:
        """
        Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        """
        return pulumi.get(self, "disable_local_auth")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.SynapseSparkResponseProperties']:
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class SynapseSparkResponseProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoPauseProperties":
            suggest = "auto_pause_properties"
        elif key == "autoScaleProperties":
            suggest = "auto_scale_properties"
        elif key == "nodeCount":
            suggest = "node_count"
        elif key == "nodeSize":
            suggest = "node_size"
        elif key == "nodeSizeFamily":
            suggest = "node_size_family"
        elif key == "poolName":
            suggest = "pool_name"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "sparkVersion":
            suggest = "spark_version"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "workspaceName":
            suggest = "workspace_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SynapseSparkResponseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SynapseSparkResponseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SynapseSparkResponseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_pause_properties: Optional['outputs.AutoPausePropertiesResponse'] = None,
                 auto_scale_properties: Optional['outputs.AutoScalePropertiesResponse'] = None,
                 node_count: Optional[builtins.int] = None,
                 node_size: Optional[builtins.str] = None,
                 node_size_family: Optional[builtins.str] = None,
                 pool_name: Optional[builtins.str] = None,
                 resource_group: Optional[builtins.str] = None,
                 spark_version: Optional[builtins.str] = None,
                 subscription_id: Optional[builtins.str] = None,
                 workspace_name: Optional[builtins.str] = None):
        """
        :param 'AutoPausePropertiesResponse' auto_pause_properties: Auto pause properties.
        :param 'AutoScalePropertiesResponse' auto_scale_properties: Auto scale properties.
        :param builtins.int node_count: The number of compute nodes currently assigned to the compute.
        :param builtins.str node_size: Node size.
        :param builtins.str node_size_family: Node size family.
        :param builtins.str pool_name: Pool name.
        :param builtins.str resource_group: Name of the resource group in which workspace is located.
        :param builtins.str spark_version: Spark version.
        :param builtins.str subscription_id: Azure subscription identifier.
        :param builtins.str workspace_name: Name of Azure Machine Learning workspace.
        """
        if auto_pause_properties is not None:
            pulumi.set(__self__, "auto_pause_properties", auto_pause_properties)
        if auto_scale_properties is not None:
            pulumi.set(__self__, "auto_scale_properties", auto_scale_properties)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if node_size is not None:
            pulumi.set(__self__, "node_size", node_size)
        if node_size_family is not None:
            pulumi.set(__self__, "node_size_family", node_size_family)
        if pool_name is not None:
            pulumi.set(__self__, "pool_name", pool_name)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if spark_version is not None:
            pulumi.set(__self__, "spark_version", spark_version)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if workspace_name is not None:
            pulumi.set(__self__, "workspace_name", workspace_name)

    @property
    @pulumi.getter(name="autoPauseProperties")
    def auto_pause_properties(self) -> Optional['outputs.AutoPausePropertiesResponse']:
        """
        Auto pause properties.
        """
        return pulumi.get(self, "auto_pause_properties")

    @property
    @pulumi.getter(name="autoScaleProperties")
    def auto_scale_properties(self) -> Optional['outputs.AutoScalePropertiesResponse']:
        """
        Auto scale properties.
        """
        return pulumi.get(self, "auto_scale_properties")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[builtins.int]:
        """
        The number of compute nodes currently assigned to the compute.
        """
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter(name="nodeSize")
    def node_size(self) -> Optional[builtins.str]:
        """
        Node size.
        """
        return pulumi.get(self, "node_size")

    @property
    @pulumi.getter(name="nodeSizeFamily")
    def node_size_family(self) -> Optional[builtins.str]:
        """
        Node size family.
        """
        return pulumi.get(self, "node_size_family")

    @property
    @pulumi.getter(name="poolName")
    def pool_name(self) -> Optional[builtins.str]:
        """
        Pool name.
        """
        return pulumi.get(self, "pool_name")

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[builtins.str]:
        """
        Name of the resource group in which workspace is located.
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> Optional[builtins.str]:
        """
        Spark version.
        """
        return pulumi.get(self, "spark_version")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[builtins.str]:
        """
        Azure subscription identifier.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="workspaceName")
    def workspace_name(self) -> Optional[builtins.str]:
        """
        Name of Azure Machine Learning workspace.
        """
        return pulumi.get(self, "workspace_name")


@pulumi.output_type
class SystemCreatedAcrAccountResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acrAccountName":
            suggest = "acr_account_name"
        elif key == "acrAccountSku":
            suggest = "acr_account_sku"
        elif key == "armResourceId":
            suggest = "arm_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemCreatedAcrAccountResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemCreatedAcrAccountResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemCreatedAcrAccountResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acr_account_name: Optional[builtins.str] = None,
                 acr_account_sku: Optional[builtins.str] = None,
                 arm_resource_id: Optional['outputs.ArmResourceIdResponse'] = None):
        """
        :param builtins.str acr_account_name: Name of the ACR account
        :param builtins.str acr_account_sku: SKU of the ACR account
        :param 'ArmResourceIdResponse' arm_resource_id: This is populated once the ACR account is created.
        """
        if acr_account_name is not None:
            pulumi.set(__self__, "acr_account_name", acr_account_name)
        if acr_account_sku is not None:
            pulumi.set(__self__, "acr_account_sku", acr_account_sku)
        if arm_resource_id is not None:
            pulumi.set(__self__, "arm_resource_id", arm_resource_id)

    @property
    @pulumi.getter(name="acrAccountName")
    def acr_account_name(self) -> Optional[builtins.str]:
        """
        Name of the ACR account
        """
        return pulumi.get(self, "acr_account_name")

    @property
    @pulumi.getter(name="acrAccountSku")
    def acr_account_sku(self) -> Optional[builtins.str]:
        """
        SKU of the ACR account
        """
        return pulumi.get(self, "acr_account_sku")

    @property
    @pulumi.getter(name="armResourceId")
    def arm_resource_id(self) -> Optional['outputs.ArmResourceIdResponse']:
        """
        This is populated once the ACR account is created.
        """
        return pulumi.get(self, "arm_resource_id")


@pulumi.output_type
class SystemCreatedStorageAccountResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowBlobPublicAccess":
            suggest = "allow_blob_public_access"
        elif key == "armResourceId":
            suggest = "arm_resource_id"
        elif key == "storageAccountHnsEnabled":
            suggest = "storage_account_hns_enabled"
        elif key == "storageAccountName":
            suggest = "storage_account_name"
        elif key == "storageAccountType":
            suggest = "storage_account_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemCreatedStorageAccountResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemCreatedStorageAccountResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemCreatedStorageAccountResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_blob_public_access: Optional[builtins.bool] = None,
                 arm_resource_id: Optional['outputs.ArmResourceIdResponse'] = None,
                 storage_account_hns_enabled: Optional[builtins.bool] = None,
                 storage_account_name: Optional[builtins.str] = None,
                 storage_account_type: Optional[builtins.str] = None):
        """
        :param builtins.bool allow_blob_public_access: Public blob access allowed
        :param 'ArmResourceIdResponse' arm_resource_id: This is populated once the storage account is created.
        :param builtins.bool storage_account_hns_enabled: HNS enabled for storage account
        :param builtins.str storage_account_name: Name of the storage account
        :param builtins.str storage_account_type: Allowed values:
               "Standard_LRS",
               "Standard_GRS",
               "Standard_RAGRS",
               "Standard_ZRS",
               "Standard_GZRS",
               "Standard_RAGZRS",
               "Premium_LRS",
               "Premium_ZRS"
        """
        if allow_blob_public_access is not None:
            pulumi.set(__self__, "allow_blob_public_access", allow_blob_public_access)
        if arm_resource_id is not None:
            pulumi.set(__self__, "arm_resource_id", arm_resource_id)
        if storage_account_hns_enabled is not None:
            pulumi.set(__self__, "storage_account_hns_enabled", storage_account_hns_enabled)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)
        if storage_account_type is not None:
            pulumi.set(__self__, "storage_account_type", storage_account_type)

    @property
    @pulumi.getter(name="allowBlobPublicAccess")
    def allow_blob_public_access(self) -> Optional[builtins.bool]:
        """
        Public blob access allowed
        """
        return pulumi.get(self, "allow_blob_public_access")

    @property
    @pulumi.getter(name="armResourceId")
    def arm_resource_id(self) -> Optional['outputs.ArmResourceIdResponse']:
        """
        This is populated once the storage account is created.
        """
        return pulumi.get(self, "arm_resource_id")

    @property
    @pulumi.getter(name="storageAccountHnsEnabled")
    def storage_account_hns_enabled(self) -> Optional[builtins.bool]:
        """
        HNS enabled for storage account
        """
        return pulumi.get(self, "storage_account_hns_enabled")

    @property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[builtins.str]:
        """
        Name of the storage account
        """
        return pulumi.get(self, "storage_account_name")

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> Optional[builtins.str]:
        """
        Allowed values:
        "Standard_LRS",
        "Standard_GRS",
        "Standard_RAGRS",
        "Standard_ZRS",
        "Standard_GZRS",
        "Standard_RAGZRS",
        "Premium_LRS",
        "Premium_ZRS"
        """
        return pulumi.get(self, "storage_account_type")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[builtins.str] = None,
                 created_by: Optional[builtins.str] = None,
                 created_by_type: Optional[builtins.str] = None,
                 last_modified_at: Optional[builtins.str] = None,
                 last_modified_by: Optional[builtins.str] = None,
                 last_modified_by_type: Optional[builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param builtins.str created_at: The timestamp of resource creation (UTC).
        :param builtins.str created_by: The identity that created the resource.
        :param builtins.str created_by_type: The type of identity that created the resource.
        :param builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param builtins.str last_modified_by: The identity that last modified the resource.
        :param builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class SystemServiceResponse(dict):
    """
    A system service running on a compute.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicIpAddress":
            suggest = "public_ip_address"
        elif key == "systemServiceType":
            suggest = "system_service_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemServiceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemServiceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemServiceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_ip_address: builtins.str,
                 system_service_type: builtins.str,
                 version: builtins.str):
        """
        A system service running on a compute.
        :param builtins.str public_ip_address: Public IP address
        :param builtins.str system_service_type: The type of this system service.
        :param builtins.str version: The version for this type.
        """
        pulumi.set(__self__, "public_ip_address", public_ip_address)
        pulumi.set(__self__, "system_service_type", system_service_type)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> builtins.str:
        """
        Public IP address
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter(name="systemServiceType")
    def system_service_type(self) -> builtins.str:
        """
        The type of this system service.
        """
        return pulumi.get(self, "system_service_type")

    @property
    @pulumi.getter
    def version(self) -> builtins.str:
        """
        The version for this type.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class TableVerticalFeaturizationSettingsResponse(dict):
    """
    Featurization Configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockedTransformers":
            suggest = "blocked_transformers"
        elif key == "columnNameAndTypes":
            suggest = "column_name_and_types"
        elif key == "datasetLanguage":
            suggest = "dataset_language"
        elif key == "enableDnnFeaturization":
            suggest = "enable_dnn_featurization"
        elif key == "transformerParams":
            suggest = "transformer_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableVerticalFeaturizationSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableVerticalFeaturizationSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableVerticalFeaturizationSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blocked_transformers: Optional[Sequence[builtins.str]] = None,
                 column_name_and_types: Optional[Mapping[str, builtins.str]] = None,
                 dataset_language: Optional[builtins.str] = None,
                 enable_dnn_featurization: Optional[builtins.bool] = None,
                 mode: Optional[builtins.str] = None,
                 transformer_params: Optional[Mapping[str, Sequence['outputs.ColumnTransformerResponse']]] = None):
        """
        Featurization Configuration.
        :param Sequence[builtins.str] blocked_transformers: These transformers shall not be used in featurization.
        :param Mapping[str, builtins.str] column_name_and_types: Dictionary of column name and its type (int, float, string, datetime etc).
        :param builtins.str dataset_language: Dataset language, useful for the text data.
        :param builtins.bool enable_dnn_featurization: Determines whether to use Dnn based featurizers for data featurization.
        :param builtins.str mode: Featurization mode - User can keep the default 'Auto' mode and AutoML will take care of necessary transformation of the data in featurization phase.
               If 'Off' is selected then no featurization is done.
               If 'Custom' is selected then user can specify additional inputs to customize how featurization is done.
        :param Mapping[str, Sequence['ColumnTransformerResponse']] transformer_params: User can specify additional transformers to be used along with the columns to which it would be applied and parameters for the transformer constructor.
        """
        if blocked_transformers is not None:
            pulumi.set(__self__, "blocked_transformers", blocked_transformers)
        if column_name_and_types is not None:
            pulumi.set(__self__, "column_name_and_types", column_name_and_types)
        if dataset_language is not None:
            pulumi.set(__self__, "dataset_language", dataset_language)
        if enable_dnn_featurization is None:
            enable_dnn_featurization = False
        if enable_dnn_featurization is not None:
            pulumi.set(__self__, "enable_dnn_featurization", enable_dnn_featurization)
        if mode is None:
            mode = 'Auto'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if transformer_params is not None:
            pulumi.set(__self__, "transformer_params", transformer_params)

    @property
    @pulumi.getter(name="blockedTransformers")
    def blocked_transformers(self) -> Optional[Sequence[builtins.str]]:
        """
        These transformers shall not be used in featurization.
        """
        return pulumi.get(self, "blocked_transformers")

    @property
    @pulumi.getter(name="columnNameAndTypes")
    def column_name_and_types(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Dictionary of column name and its type (int, float, string, datetime etc).
        """
        return pulumi.get(self, "column_name_and_types")

    @property
    @pulumi.getter(name="datasetLanguage")
    def dataset_language(self) -> Optional[builtins.str]:
        """
        Dataset language, useful for the text data.
        """
        return pulumi.get(self, "dataset_language")

    @property
    @pulumi.getter(name="enableDnnFeaturization")
    def enable_dnn_featurization(self) -> Optional[builtins.bool]:
        """
        Determines whether to use Dnn based featurizers for data featurization.
        """
        return pulumi.get(self, "enable_dnn_featurization")

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Featurization mode - User can keep the default 'Auto' mode and AutoML will take care of necessary transformation of the data in featurization phase.
        If 'Off' is selected then no featurization is done.
        If 'Custom' is selected then user can specify additional inputs to customize how featurization is done.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="transformerParams")
    def transformer_params(self) -> Optional[Mapping[str, Sequence['outputs.ColumnTransformerResponse']]]:
        """
        User can specify additional transformers to be used along with the columns to which it would be applied and parameters for the transformer constructor.
        """
        return pulumi.get(self, "transformer_params")


@pulumi.output_type
class TableVerticalLimitSettingsResponse(dict):
    """
    Job execution constraints.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableEarlyTermination":
            suggest = "enable_early_termination"
        elif key == "exitScore":
            suggest = "exit_score"
        elif key == "maxConcurrentTrials":
            suggest = "max_concurrent_trials"
        elif key == "maxCoresPerTrial":
            suggest = "max_cores_per_trial"
        elif key == "maxTrials":
            suggest = "max_trials"
        elif key == "trialTimeout":
            suggest = "trial_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableVerticalLimitSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableVerticalLimitSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableVerticalLimitSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_early_termination: Optional[builtins.bool] = None,
                 exit_score: Optional[builtins.float] = None,
                 max_concurrent_trials: Optional[builtins.int] = None,
                 max_cores_per_trial: Optional[builtins.int] = None,
                 max_trials: Optional[builtins.int] = None,
                 timeout: Optional[builtins.str] = None,
                 trial_timeout: Optional[builtins.str] = None):
        """
        Job execution constraints.
        :param builtins.bool enable_early_termination: Enable early termination, determines whether or not if AutoMLJob will terminate early if there is no score improvement in last 20 iterations.
        :param builtins.float exit_score: Exit score for the AutoML job.
        :param builtins.int max_concurrent_trials: Maximum Concurrent iterations.
        :param builtins.int max_cores_per_trial: Max cores per iteration.
        :param builtins.int max_trials: Number of iterations.
        :param builtins.str timeout: AutoML job timeout.
        :param builtins.str trial_timeout: Iteration timeout.
        """
        if enable_early_termination is None:
            enable_early_termination = True
        if enable_early_termination is not None:
            pulumi.set(__self__, "enable_early_termination", enable_early_termination)
        if exit_score is not None:
            pulumi.set(__self__, "exit_score", exit_score)
        if max_concurrent_trials is None:
            max_concurrent_trials = 1
        if max_concurrent_trials is not None:
            pulumi.set(__self__, "max_concurrent_trials", max_concurrent_trials)
        if max_cores_per_trial is None:
            max_cores_per_trial = -1
        if max_cores_per_trial is not None:
            pulumi.set(__self__, "max_cores_per_trial", max_cores_per_trial)
        if max_trials is None:
            max_trials = 1000
        if max_trials is not None:
            pulumi.set(__self__, "max_trials", max_trials)
        if timeout is None:
            timeout = 'PT6H'
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if trial_timeout is None:
            trial_timeout = 'PT30M'
        if trial_timeout is not None:
            pulumi.set(__self__, "trial_timeout", trial_timeout)

    @property
    @pulumi.getter(name="enableEarlyTermination")
    def enable_early_termination(self) -> Optional[builtins.bool]:
        """
        Enable early termination, determines whether or not if AutoMLJob will terminate early if there is no score improvement in last 20 iterations.
        """
        return pulumi.get(self, "enable_early_termination")

    @property
    @pulumi.getter(name="exitScore")
    def exit_score(self) -> Optional[builtins.float]:
        """
        Exit score for the AutoML job.
        """
        return pulumi.get(self, "exit_score")

    @property
    @pulumi.getter(name="maxConcurrentTrials")
    def max_concurrent_trials(self) -> Optional[builtins.int]:
        """
        Maximum Concurrent iterations.
        """
        return pulumi.get(self, "max_concurrent_trials")

    @property
    @pulumi.getter(name="maxCoresPerTrial")
    def max_cores_per_trial(self) -> Optional[builtins.int]:
        """
        Max cores per iteration.
        """
        return pulumi.get(self, "max_cores_per_trial")

    @property
    @pulumi.getter(name="maxTrials")
    def max_trials(self) -> Optional[builtins.int]:
        """
        Number of iterations.
        """
        return pulumi.get(self, "max_trials")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[builtins.str]:
        """
        AutoML job timeout.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="trialTimeout")
    def trial_timeout(self) -> Optional[builtins.str]:
        """
        Iteration timeout.
        """
        return pulumi.get(self, "trial_timeout")


@pulumi.output_type
class TargetUtilizationScaleSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleType":
            suggest = "scale_type"
        elif key == "maxInstances":
            suggest = "max_instances"
        elif key == "minInstances":
            suggest = "min_instances"
        elif key == "pollingInterval":
            suggest = "polling_interval"
        elif key == "targetUtilizationPercentage":
            suggest = "target_utilization_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetUtilizationScaleSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetUtilizationScaleSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetUtilizationScaleSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scale_type: builtins.str,
                 max_instances: Optional[builtins.int] = None,
                 min_instances: Optional[builtins.int] = None,
                 polling_interval: Optional[builtins.str] = None,
                 target_utilization_percentage: Optional[builtins.int] = None):
        """
        :param builtins.str scale_type: 
               Expected value is 'TargetUtilization'.
        :param builtins.int max_instances: The maximum number of instances that the deployment can scale to. The quota will be reserved for max_instances.
        :param builtins.int min_instances: The minimum number of instances to always be present.
        :param builtins.str polling_interval: The polling interval in ISO 8691 format. Only supports duration with precision as low as Seconds.
        :param builtins.int target_utilization_percentage: Target CPU usage for the autoscaler.
        """
        pulumi.set(__self__, "scale_type", 'TargetUtilization')
        if max_instances is None:
            max_instances = 1
        if max_instances is not None:
            pulumi.set(__self__, "max_instances", max_instances)
        if min_instances is None:
            min_instances = 1
        if min_instances is not None:
            pulumi.set(__self__, "min_instances", min_instances)
        if polling_interval is None:
            polling_interval = 'PT1S'
        if polling_interval is not None:
            pulumi.set(__self__, "polling_interval", polling_interval)
        if target_utilization_percentage is None:
            target_utilization_percentage = 70
        if target_utilization_percentage is not None:
            pulumi.set(__self__, "target_utilization_percentage", target_utilization_percentage)

    @property
    @pulumi.getter(name="scaleType")
    def scale_type(self) -> builtins.str:
        """

        Expected value is 'TargetUtilization'.
        """
        return pulumi.get(self, "scale_type")

    @property
    @pulumi.getter(name="maxInstances")
    def max_instances(self) -> Optional[builtins.int]:
        """
        The maximum number of instances that the deployment can scale to. The quota will be reserved for max_instances.
        """
        return pulumi.get(self, "max_instances")

    @property
    @pulumi.getter(name="minInstances")
    def min_instances(self) -> Optional[builtins.int]:
        """
        The minimum number of instances to always be present.
        """
        return pulumi.get(self, "min_instances")

    @property
    @pulumi.getter(name="pollingInterval")
    def polling_interval(self) -> Optional[builtins.str]:
        """
        The polling interval in ISO 8691 format. Only supports duration with precision as low as Seconds.
        """
        return pulumi.get(self, "polling_interval")

    @property
    @pulumi.getter(name="targetUtilizationPercentage")
    def target_utilization_percentage(self) -> Optional[builtins.int]:
        """
        Target CPU usage for the autoscaler.
        """
        return pulumi.get(self, "target_utilization_percentage")


@pulumi.output_type
class TensorFlowResponse(dict):
    """
    TensorFlow distribution configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "distributionType":
            suggest = "distribution_type"
        elif key == "parameterServerCount":
            suggest = "parameter_server_count"
        elif key == "workerCount":
            suggest = "worker_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TensorFlowResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TensorFlowResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TensorFlowResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 distribution_type: builtins.str,
                 parameter_server_count: Optional[builtins.int] = None,
                 worker_count: Optional[builtins.int] = None):
        """
        TensorFlow distribution configuration.
        :param builtins.str distribution_type: Enum to determine the job distribution type.
               Expected value is 'TensorFlow'.
        :param builtins.int parameter_server_count: Number of parameter server tasks.
        :param builtins.int worker_count: Number of workers. If not specified, will default to the instance count.
        """
        pulumi.set(__self__, "distribution_type", 'TensorFlow')
        if parameter_server_count is None:
            parameter_server_count = 0
        if parameter_server_count is not None:
            pulumi.set(__self__, "parameter_server_count", parameter_server_count)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)

    @property
    @pulumi.getter(name="distributionType")
    def distribution_type(self) -> builtins.str:
        """
        Enum to determine the job distribution type.
        Expected value is 'TensorFlow'.
        """
        return pulumi.get(self, "distribution_type")

    @property
    @pulumi.getter(name="parameterServerCount")
    def parameter_server_count(self) -> Optional[builtins.int]:
        """
        Number of parameter server tasks.
        """
        return pulumi.get(self, "parameter_server_count")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[builtins.int]:
        """
        Number of workers. If not specified, will default to the instance count.
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class TextClassificationMultilabelResponse(dict):
    """
    Text Classification Multilabel task in AutoML NLP vertical.
    NLP - Natural Language Processing.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryMetric":
            suggest = "primary_metric"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "trainingData":
            suggest = "training_data"
        elif key == "featurizationSettings":
            suggest = "featurization_settings"
        elif key == "limitSettings":
            suggest = "limit_settings"
        elif key == "logVerbosity":
            suggest = "log_verbosity"
        elif key == "targetColumnName":
            suggest = "target_column_name"
        elif key == "validationData":
            suggest = "validation_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TextClassificationMultilabelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TextClassificationMultilabelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TextClassificationMultilabelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary_metric: builtins.str,
                 task_type: builtins.str,
                 training_data: 'outputs.MLTableJobInputResponse',
                 featurization_settings: Optional['outputs.NlpVerticalFeaturizationSettingsResponse'] = None,
                 limit_settings: Optional['outputs.NlpVerticalLimitSettingsResponse'] = None,
                 log_verbosity: Optional[builtins.str] = None,
                 target_column_name: Optional[builtins.str] = None,
                 validation_data: Optional['outputs.MLTableJobInputResponse'] = None):
        """
        Text Classification Multilabel task in AutoML NLP vertical.
        NLP - Natural Language Processing.
        :param builtins.str primary_metric: Primary metric for Text-Classification-Multilabel task.
               Currently only Accuracy is supported as primary metric, hence user need not set it explicitly.
        :param builtins.str task_type: AutoMLJob Task type.
               Expected value is 'TextClassificationMultilabel'.
        :param 'MLTableJobInputResponse' training_data: [Required] Training data input.
        :param 'NlpVerticalFeaturizationSettingsResponse' featurization_settings: Featurization inputs needed for AutoML job.
        :param 'NlpVerticalLimitSettingsResponse' limit_settings: Execution constraints for AutoMLJob.
        :param builtins.str log_verbosity: Log verbosity for the job.
        :param builtins.str target_column_name: Target column name: This is prediction values column.
               Also known as label column name in context of classification tasks.
        :param 'MLTableJobInputResponse' validation_data: Validation data inputs.
        """
        pulumi.set(__self__, "primary_metric", primary_metric)
        pulumi.set(__self__, "task_type", 'TextClassificationMultilabel')
        pulumi.set(__self__, "training_data", training_data)
        if featurization_settings is not None:
            pulumi.set(__self__, "featurization_settings", featurization_settings)
        if limit_settings is not None:
            pulumi.set(__self__, "limit_settings", limit_settings)
        if log_verbosity is None:
            log_verbosity = 'Info'
        if log_verbosity is not None:
            pulumi.set(__self__, "log_verbosity", log_verbosity)
        if target_column_name is not None:
            pulumi.set(__self__, "target_column_name", target_column_name)
        if validation_data is not None:
            pulumi.set(__self__, "validation_data", validation_data)

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> builtins.str:
        """
        Primary metric for Text-Classification-Multilabel task.
        Currently only Accuracy is supported as primary metric, hence user need not set it explicitly.
        """
        return pulumi.get(self, "primary_metric")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> builtins.str:
        """
        AutoMLJob Task type.
        Expected value is 'TextClassificationMultilabel'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="trainingData")
    def training_data(self) -> 'outputs.MLTableJobInputResponse':
        """
        [Required] Training data input.
        """
        return pulumi.get(self, "training_data")

    @property
    @pulumi.getter(name="featurizationSettings")
    def featurization_settings(self) -> Optional['outputs.NlpVerticalFeaturizationSettingsResponse']:
        """
        Featurization inputs needed for AutoML job.
        """
        return pulumi.get(self, "featurization_settings")

    @property
    @pulumi.getter(name="limitSettings")
    def limit_settings(self) -> Optional['outputs.NlpVerticalLimitSettingsResponse']:
        """
        Execution constraints for AutoMLJob.
        """
        return pulumi.get(self, "limit_settings")

    @property
    @pulumi.getter(name="logVerbosity")
    def log_verbosity(self) -> Optional[builtins.str]:
        """
        Log verbosity for the job.
        """
        return pulumi.get(self, "log_verbosity")

    @property
    @pulumi.getter(name="targetColumnName")
    def target_column_name(self) -> Optional[builtins.str]:
        """
        Target column name: This is prediction values column.
        Also known as label column name in context of classification tasks.
        """
        return pulumi.get(self, "target_column_name")

    @property
    @pulumi.getter(name="validationData")
    def validation_data(self) -> Optional['outputs.MLTableJobInputResponse']:
        """
        Validation data inputs.
        """
        return pulumi.get(self, "validation_data")


@pulumi.output_type
class TextClassificationResponse(dict):
    """
    Text Classification task in AutoML NLP vertical.
    NLP - Natural Language Processing.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "trainingData":
            suggest = "training_data"
        elif key == "featurizationSettings":
            suggest = "featurization_settings"
        elif key == "limitSettings":
            suggest = "limit_settings"
        elif key == "logVerbosity":
            suggest = "log_verbosity"
        elif key == "primaryMetric":
            suggest = "primary_metric"
        elif key == "targetColumnName":
            suggest = "target_column_name"
        elif key == "validationData":
            suggest = "validation_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TextClassificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TextClassificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TextClassificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 task_type: builtins.str,
                 training_data: 'outputs.MLTableJobInputResponse',
                 featurization_settings: Optional['outputs.NlpVerticalFeaturizationSettingsResponse'] = None,
                 limit_settings: Optional['outputs.NlpVerticalLimitSettingsResponse'] = None,
                 log_verbosity: Optional[builtins.str] = None,
                 primary_metric: Optional[builtins.str] = None,
                 target_column_name: Optional[builtins.str] = None,
                 validation_data: Optional['outputs.MLTableJobInputResponse'] = None):
        """
        Text Classification task in AutoML NLP vertical.
        NLP - Natural Language Processing.
        :param builtins.str task_type: AutoMLJob Task type.
               Expected value is 'TextClassification'.
        :param 'MLTableJobInputResponse' training_data: [Required] Training data input.
        :param 'NlpVerticalFeaturizationSettingsResponse' featurization_settings: Featurization inputs needed for AutoML job.
        :param 'NlpVerticalLimitSettingsResponse' limit_settings: Execution constraints for AutoMLJob.
        :param builtins.str log_verbosity: Log verbosity for the job.
        :param builtins.str primary_metric: Primary metric for Text-Classification task.
        :param builtins.str target_column_name: Target column name: This is prediction values column.
               Also known as label column name in context of classification tasks.
        :param 'MLTableJobInputResponse' validation_data: Validation data inputs.
        """
        pulumi.set(__self__, "task_type", 'TextClassification')
        pulumi.set(__self__, "training_data", training_data)
        if featurization_settings is not None:
            pulumi.set(__self__, "featurization_settings", featurization_settings)
        if limit_settings is not None:
            pulumi.set(__self__, "limit_settings", limit_settings)
        if log_verbosity is None:
            log_verbosity = 'Info'
        if log_verbosity is not None:
            pulumi.set(__self__, "log_verbosity", log_verbosity)
        if primary_metric is None:
            primary_metric = 'Accuracy'
        if primary_metric is not None:
            pulumi.set(__self__, "primary_metric", primary_metric)
        if target_column_name is not None:
            pulumi.set(__self__, "target_column_name", target_column_name)
        if validation_data is not None:
            pulumi.set(__self__, "validation_data", validation_data)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> builtins.str:
        """
        AutoMLJob Task type.
        Expected value is 'TextClassification'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="trainingData")
    def training_data(self) -> 'outputs.MLTableJobInputResponse':
        """
        [Required] Training data input.
        """
        return pulumi.get(self, "training_data")

    @property
    @pulumi.getter(name="featurizationSettings")
    def featurization_settings(self) -> Optional['outputs.NlpVerticalFeaturizationSettingsResponse']:
        """
        Featurization inputs needed for AutoML job.
        """
        return pulumi.get(self, "featurization_settings")

    @property
    @pulumi.getter(name="limitSettings")
    def limit_settings(self) -> Optional['outputs.NlpVerticalLimitSettingsResponse']:
        """
        Execution constraints for AutoMLJob.
        """
        return pulumi.get(self, "limit_settings")

    @property
    @pulumi.getter(name="logVerbosity")
    def log_verbosity(self) -> Optional[builtins.str]:
        """
        Log verbosity for the job.
        """
        return pulumi.get(self, "log_verbosity")

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> Optional[builtins.str]:
        """
        Primary metric for Text-Classification task.
        """
        return pulumi.get(self, "primary_metric")

    @property
    @pulumi.getter(name="targetColumnName")
    def target_column_name(self) -> Optional[builtins.str]:
        """
        Target column name: This is prediction values column.
        Also known as label column name in context of classification tasks.
        """
        return pulumi.get(self, "target_column_name")

    @property
    @pulumi.getter(name="validationData")
    def validation_data(self) -> Optional['outputs.MLTableJobInputResponse']:
        """
        Validation data inputs.
        """
        return pulumi.get(self, "validation_data")


@pulumi.output_type
class TextNerResponse(dict):
    """
    Text-NER task in AutoML NLP vertical.
    NER - Named Entity Recognition.
    NLP - Natural Language Processing.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryMetric":
            suggest = "primary_metric"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "trainingData":
            suggest = "training_data"
        elif key == "featurizationSettings":
            suggest = "featurization_settings"
        elif key == "limitSettings":
            suggest = "limit_settings"
        elif key == "logVerbosity":
            suggest = "log_verbosity"
        elif key == "targetColumnName":
            suggest = "target_column_name"
        elif key == "validationData":
            suggest = "validation_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TextNerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TextNerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TextNerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary_metric: builtins.str,
                 task_type: builtins.str,
                 training_data: 'outputs.MLTableJobInputResponse',
                 featurization_settings: Optional['outputs.NlpVerticalFeaturizationSettingsResponse'] = None,
                 limit_settings: Optional['outputs.NlpVerticalLimitSettingsResponse'] = None,
                 log_verbosity: Optional[builtins.str] = None,
                 target_column_name: Optional[builtins.str] = None,
                 validation_data: Optional['outputs.MLTableJobInputResponse'] = None):
        """
        Text-NER task in AutoML NLP vertical.
        NER - Named Entity Recognition.
        NLP - Natural Language Processing.
        :param builtins.str primary_metric: Primary metric for Text-NER task.
               Only 'Accuracy' is supported for Text-NER, so user need not set this explicitly.
        :param builtins.str task_type: AutoMLJob Task type.
               Expected value is 'TextNER'.
        :param 'MLTableJobInputResponse' training_data: [Required] Training data input.
        :param 'NlpVerticalFeaturizationSettingsResponse' featurization_settings: Featurization inputs needed for AutoML job.
        :param 'NlpVerticalLimitSettingsResponse' limit_settings: Execution constraints for AutoMLJob.
        :param builtins.str log_verbosity: Log verbosity for the job.
        :param builtins.str target_column_name: Target column name: This is prediction values column.
               Also known as label column name in context of classification tasks.
        :param 'MLTableJobInputResponse' validation_data: Validation data inputs.
        """
        pulumi.set(__self__, "primary_metric", primary_metric)
        pulumi.set(__self__, "task_type", 'TextNER')
        pulumi.set(__self__, "training_data", training_data)
        if featurization_settings is not None:
            pulumi.set(__self__, "featurization_settings", featurization_settings)
        if limit_settings is not None:
            pulumi.set(__self__, "limit_settings", limit_settings)
        if log_verbosity is None:
            log_verbosity = 'Info'
        if log_verbosity is not None:
            pulumi.set(__self__, "log_verbosity", log_verbosity)
        if target_column_name is not None:
            pulumi.set(__self__, "target_column_name", target_column_name)
        if validation_data is not None:
            pulumi.set(__self__, "validation_data", validation_data)

    @property
    @pulumi.getter(name="primaryMetric")
    def primary_metric(self) -> builtins.str:
        """
        Primary metric for Text-NER task.
        Only 'Accuracy' is supported for Text-NER, so user need not set this explicitly.
        """
        return pulumi.get(self, "primary_metric")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> builtins.str:
        """
        AutoMLJob Task type.
        Expected value is 'TextNER'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="trainingData")
    def training_data(self) -> 'outputs.MLTableJobInputResponse':
        """
        [Required] Training data input.
        """
        return pulumi.get(self, "training_data")

    @property
    @pulumi.getter(name="featurizationSettings")
    def featurization_settings(self) -> Optional['outputs.NlpVerticalFeaturizationSettingsResponse']:
        """
        Featurization inputs needed for AutoML job.
        """
        return pulumi.get(self, "featurization_settings")

    @property
    @pulumi.getter(name="limitSettings")
    def limit_settings(self) -> Optional['outputs.NlpVerticalLimitSettingsResponse']:
        """
        Execution constraints for AutoMLJob.
        """
        return pulumi.get(self, "limit_settings")

    @property
    @pulumi.getter(name="logVerbosity")
    def log_verbosity(self) -> Optional[builtins.str]:
        """
        Log verbosity for the job.
        """
        return pulumi.get(self, "log_verbosity")

    @property
    @pulumi.getter(name="targetColumnName")
    def target_column_name(self) -> Optional[builtins.str]:
        """
        Target column name: This is prediction values column.
        Also known as label column name in context of classification tasks.
        """
        return pulumi.get(self, "target_column_name")

    @property
    @pulumi.getter(name="validationData")
    def validation_data(self) -> Optional['outputs.MLTableJobInputResponse']:
        """
        Validation data inputs.
        """
        return pulumi.get(self, "validation_data")


@pulumi.output_type
class TmpfsOptionsResponse(dict):
    """
    Describes the tmpfs options for the container
    """
    def __init__(__self__, *,
                 size: Optional[builtins.int] = None):
        """
        Describes the tmpfs options for the container
        :param builtins.int size: Mention the Tmpfs size
        """
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def size(self) -> Optional[builtins.int]:
        """
        Mention the Tmpfs size
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class TopNFeaturesByAttributionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopNFeaturesByAttributionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopNFeaturesByAttributionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopNFeaturesByAttributionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 top: Optional[builtins.int] = None):
        """
        :param builtins.str filter_type: 
               Expected value is 'TopNByAttribution'.
        :param builtins.int top: The number of top features to include.
        """
        pulumi.set(__self__, "filter_type", 'TopNByAttribution')
        if top is None:
            top = 10
        if top is not None:
            pulumi.set(__self__, "top", top)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        """

        Expected value is 'TopNByAttribution'.
        """
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def top(self) -> Optional[builtins.int]:
        """
        The number of top features to include.
        """
        return pulumi.get(self, "top")


@pulumi.output_type
class TrialComponentResponse(dict):
    """
    Trial component definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentId":
            suggest = "environment_id"
        elif key == "codeId":
            suggest = "code_id"
        elif key == "environmentVariables":
            suggest = "environment_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrialComponentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrialComponentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrialComponentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command: builtins.str,
                 environment_id: builtins.str,
                 code_id: Optional[builtins.str] = None,
                 distribution: Optional[Any] = None,
                 environment_variables: Optional[Mapping[str, builtins.str]] = None,
                 resources: Optional['outputs.JobResourceConfigurationResponse'] = None):
        """
        Trial component definition.
        :param builtins.str command: [Required] The command to execute on startup of the job. eg. "python train.py"
        :param builtins.str environment_id: [Required] The ARM resource ID of the Environment specification for the job.
        :param builtins.str code_id: ARM resource ID of the code asset.
        :param Union['MpiResponse', 'PyTorchResponse', 'TensorFlowResponse'] distribution: Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, or null.
        :param Mapping[str, builtins.str] environment_variables: Environment variables included in the job.
        :param 'JobResourceConfigurationResponse' resources: Compute Resource configuration for the job.
        """
        pulumi.set(__self__, "command", command)
        pulumi.set(__self__, "environment_id", environment_id)
        if code_id is not None:
            pulumi.set(__self__, "code_id", code_id)
        if distribution is not None:
            pulumi.set(__self__, "distribution", distribution)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def command(self) -> builtins.str:
        """
        [Required] The command to execute on startup of the job. eg. "python train.py"
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> builtins.str:
        """
        [Required] The ARM resource ID of the Environment specification for the job.
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="codeId")
    def code_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of the code asset.
        """
        return pulumi.get(self, "code_id")

    @property
    @pulumi.getter
    def distribution(self) -> Optional[Any]:
        """
        Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, or null.
        """
        return pulumi.get(self, "distribution")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Environment variables included in the job.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.JobResourceConfigurationResponse']:
        """
        Compute Resource configuration for the job.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class TritonModelJobInputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobInputType":
            suggest = "job_input_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TritonModelJobInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TritonModelJobInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TritonModelJobInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_input_type: builtins.str,
                 uri: builtins.str,
                 description: Optional[builtins.str] = None,
                 mode: Optional[builtins.str] = None):
        """
        :param builtins.str job_input_type: Enum to determine the Job Input Type.
               Expected value is 'triton_model'.
        :param builtins.str uri: [Required] Input Asset URI.
        :param builtins.str description: Description for the input.
        :param builtins.str mode: Input Asset Delivery Mode.
        """
        pulumi.set(__self__, "job_input_type", 'triton_model')
        pulumi.set(__self__, "uri", uri)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if mode is None:
            mode = 'ReadOnlyMount'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="jobInputType")
    def job_input_type(self) -> builtins.str:
        """
        Enum to determine the Job Input Type.
        Expected value is 'triton_model'.
        """
        return pulumi.get(self, "job_input_type")

    @property
    @pulumi.getter
    def uri(self) -> builtins.str:
        """
        [Required] Input Asset URI.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description for the input.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Input Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class TritonModelJobOutputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobOutputType":
            suggest = "job_output_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TritonModelJobOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TritonModelJobOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TritonModelJobOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_output_type: builtins.str,
                 description: Optional[builtins.str] = None,
                 mode: Optional[builtins.str] = None,
                 uri: Optional[builtins.str] = None):
        """
        :param builtins.str job_output_type: Enum to determine the Job Output Type.
               Expected value is 'triton_model'.
        :param builtins.str description: Description for the output.
        :param builtins.str mode: Output Asset Delivery Mode.
        :param builtins.str uri: Output Asset URI.
        """
        pulumi.set(__self__, "job_output_type", 'triton_model')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if mode is None:
            mode = 'ReadWriteMount'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter(name="jobOutputType")
    def job_output_type(self) -> builtins.str:
        """
        Enum to determine the Job Output Type.
        Expected value is 'triton_model'.
        """
        return pulumi.get(self, "job_output_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description for the output.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Output Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def uri(self) -> Optional[builtins.str]:
        """
        Output Asset URI.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class TruncationSelectionPolicyResponse(dict):
    """
    Defines an early termination policy that cancels a given percentage of runs at each evaluation interval.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyType":
            suggest = "policy_type"
        elif key == "delayEvaluation":
            suggest = "delay_evaluation"
        elif key == "evaluationInterval":
            suggest = "evaluation_interval"
        elif key == "truncationPercentage":
            suggest = "truncation_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TruncationSelectionPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TruncationSelectionPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TruncationSelectionPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_type: builtins.str,
                 delay_evaluation: Optional[builtins.int] = None,
                 evaluation_interval: Optional[builtins.int] = None,
                 truncation_percentage: Optional[builtins.int] = None):
        """
        Defines an early termination policy that cancels a given percentage of runs at each evaluation interval.
        :param builtins.str policy_type: 
               Expected value is 'TruncationSelection'.
        :param builtins.int delay_evaluation: Number of intervals by which to delay the first evaluation.
        :param builtins.int evaluation_interval: Interval (number of runs) between policy evaluations.
        :param builtins.int truncation_percentage: The percentage of runs to cancel at each evaluation interval.
        """
        pulumi.set(__self__, "policy_type", 'TruncationSelection')
        if delay_evaluation is None:
            delay_evaluation = 0
        if delay_evaluation is not None:
            pulumi.set(__self__, "delay_evaluation", delay_evaluation)
        if evaluation_interval is None:
            evaluation_interval = 0
        if evaluation_interval is not None:
            pulumi.set(__self__, "evaluation_interval", evaluation_interval)
        if truncation_percentage is None:
            truncation_percentage = 0
        if truncation_percentage is not None:
            pulumi.set(__self__, "truncation_percentage", truncation_percentage)

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> builtins.str:
        """

        Expected value is 'TruncationSelection'.
        """
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="delayEvaluation")
    def delay_evaluation(self) -> Optional[builtins.int]:
        """
        Number of intervals by which to delay the first evaluation.
        """
        return pulumi.get(self, "delay_evaluation")

    @property
    @pulumi.getter(name="evaluationInterval")
    def evaluation_interval(self) -> Optional[builtins.int]:
        """
        Interval (number of runs) between policy evaluations.
        """
        return pulumi.get(self, "evaluation_interval")

    @property
    @pulumi.getter(name="truncationPercentage")
    def truncation_percentage(self) -> Optional[builtins.int]:
        """
        The percentage of runs to cancel at each evaluation interval.
        """
        return pulumi.get(self, "truncation_percentage")


@pulumi.output_type
class UriFileDataVersionResponse(dict):
    """
    uri-file data version entity
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "dataUri":
            suggest = "data_uri"
        elif key == "isAnonymous":
            suggest = "is_anonymous"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UriFileDataVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UriFileDataVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UriFileDataVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: builtins.str,
                 data_uri: builtins.str,
                 description: Optional[builtins.str] = None,
                 is_anonymous: Optional[builtins.bool] = None,
                 is_archived: Optional[builtins.bool] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        uri-file data version entity
        :param builtins.str data_type: Enum to determine the type of data.
               Expected value is 'uri_file'.
        :param builtins.str data_uri: [Required] Uri of the data. Example: https://go.microsoft.com/fwlink/?linkid=2202330
        :param builtins.str description: The asset description text.
        :param builtins.bool is_anonymous: If the name version are system generated (anonymous registration).
        :param builtins.bool is_archived: Is the asset archived?
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "data_type", 'uri_file')
        pulumi.set(__self__, "data_uri", data_uri)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_anonymous is None:
            is_anonymous = False
        if is_anonymous is not None:
            pulumi.set(__self__, "is_anonymous", is_anonymous)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> builtins.str:
        """
        Enum to determine the type of data.
        Expected value is 'uri_file'.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="dataUri")
    def data_uri(self) -> builtins.str:
        """
        [Required] Uri of the data. Example: https://go.microsoft.com/fwlink/?linkid=2202330
        """
        return pulumi.get(self, "data_uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[builtins.bool]:
        """
        If the name version are system generated (anonymous registration).
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class UriFileJobInputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobInputType":
            suggest = "job_input_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UriFileJobInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UriFileJobInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UriFileJobInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_input_type: builtins.str,
                 uri: builtins.str,
                 description: Optional[builtins.str] = None,
                 mode: Optional[builtins.str] = None):
        """
        :param builtins.str job_input_type: Enum to determine the Job Input Type.
               Expected value is 'uri_file'.
        :param builtins.str uri: [Required] Input Asset URI.
        :param builtins.str description: Description for the input.
        :param builtins.str mode: Input Asset Delivery Mode.
        """
        pulumi.set(__self__, "job_input_type", 'uri_file')
        pulumi.set(__self__, "uri", uri)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if mode is None:
            mode = 'ReadOnlyMount'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="jobInputType")
    def job_input_type(self) -> builtins.str:
        """
        Enum to determine the Job Input Type.
        Expected value is 'uri_file'.
        """
        return pulumi.get(self, "job_input_type")

    @property
    @pulumi.getter
    def uri(self) -> builtins.str:
        """
        [Required] Input Asset URI.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description for the input.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Input Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class UriFileJobOutputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobOutputType":
            suggest = "job_output_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UriFileJobOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UriFileJobOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UriFileJobOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_output_type: builtins.str,
                 description: Optional[builtins.str] = None,
                 mode: Optional[builtins.str] = None,
                 uri: Optional[builtins.str] = None):
        """
        :param builtins.str job_output_type: Enum to determine the Job Output Type.
               Expected value is 'uri_file'.
        :param builtins.str description: Description for the output.
        :param builtins.str mode: Output Asset Delivery Mode.
        :param builtins.str uri: Output Asset URI.
        """
        pulumi.set(__self__, "job_output_type", 'uri_file')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if mode is None:
            mode = 'ReadWriteMount'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter(name="jobOutputType")
    def job_output_type(self) -> builtins.str:
        """
        Enum to determine the Job Output Type.
        Expected value is 'uri_file'.
        """
        return pulumi.get(self, "job_output_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description for the output.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Output Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def uri(self) -> Optional[builtins.str]:
        """
        Output Asset URI.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class UriFolderDataVersionResponse(dict):
    """
    uri-folder data version entity
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "dataUri":
            suggest = "data_uri"
        elif key == "isAnonymous":
            suggest = "is_anonymous"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UriFolderDataVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UriFolderDataVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UriFolderDataVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: builtins.str,
                 data_uri: builtins.str,
                 description: Optional[builtins.str] = None,
                 is_anonymous: Optional[builtins.bool] = None,
                 is_archived: Optional[builtins.bool] = None,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        uri-folder data version entity
        :param builtins.str data_type: Enum to determine the type of data.
               Expected value is 'uri_folder'.
        :param builtins.str data_uri: [Required] Uri of the data. Example: https://go.microsoft.com/fwlink/?linkid=2202330
        :param builtins.str description: The asset description text.
        :param builtins.bool is_anonymous: If the name version are system generated (anonymous registration).
        :param builtins.bool is_archived: Is the asset archived?
        :param Mapping[str, builtins.str] properties: The asset property dictionary.
        :param Mapping[str, builtins.str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "data_type", 'uri_folder')
        pulumi.set(__self__, "data_uri", data_uri)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_anonymous is None:
            is_anonymous = False
        if is_anonymous is not None:
            pulumi.set(__self__, "is_anonymous", is_anonymous)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> builtins.str:
        """
        Enum to determine the type of data.
        Expected value is 'uri_folder'.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="dataUri")
    def data_uri(self) -> builtins.str:
        """
        [Required] Uri of the data. Example: https://go.microsoft.com/fwlink/?linkid=2202330
        """
        return pulumi.get(self, "data_uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[builtins.bool]:
        """
        If the name version are system generated (anonymous registration).
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[builtins.bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class UriFolderJobInputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobInputType":
            suggest = "job_input_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UriFolderJobInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UriFolderJobInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UriFolderJobInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_input_type: builtins.str,
                 uri: builtins.str,
                 description: Optional[builtins.str] = None,
                 mode: Optional[builtins.str] = None):
        """
        :param builtins.str job_input_type: Enum to determine the Job Input Type.
               Expected value is 'uri_folder'.
        :param builtins.str uri: [Required] Input Asset URI.
        :param builtins.str description: Description for the input.
        :param builtins.str mode: Input Asset Delivery Mode.
        """
        pulumi.set(__self__, "job_input_type", 'uri_folder')
        pulumi.set(__self__, "uri", uri)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if mode is None:
            mode = 'ReadOnlyMount'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="jobInputType")
    def job_input_type(self) -> builtins.str:
        """
        Enum to determine the Job Input Type.
        Expected value is 'uri_folder'.
        """
        return pulumi.get(self, "job_input_type")

    @property
    @pulumi.getter
    def uri(self) -> builtins.str:
        """
        [Required] Input Asset URI.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description for the input.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Input Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class UriFolderJobOutputResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobOutputType":
            suggest = "job_output_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UriFolderJobOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UriFolderJobOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UriFolderJobOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_output_type: builtins.str,
                 description: Optional[builtins.str] = None,
                 mode: Optional[builtins.str] = None,
                 uri: Optional[builtins.str] = None):
        """
        :param builtins.str job_output_type: Enum to determine the Job Output Type.
               Expected value is 'uri_folder'.
        :param builtins.str description: Description for the output.
        :param builtins.str mode: Output Asset Delivery Mode.
        :param builtins.str uri: Output Asset URI.
        """
        pulumi.set(__self__, "job_output_type", 'uri_folder')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if mode is None:
            mode = 'ReadWriteMount'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter(name="jobOutputType")
    def job_output_type(self) -> builtins.str:
        """
        Enum to determine the Job Output Type.
        Expected value is 'uri_folder'.
        """
        return pulumi.get(self, "job_output_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description for the output.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Output Asset Delivery Mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def uri(self) -> Optional[builtins.str]:
        """
        Output Asset URI.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class UserAccountCredentialsResponse(dict):
    """
    Settings for user account that gets created on each on the nodes of a compute.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUserName":
            suggest = "admin_user_name"
        elif key == "adminUserPassword":
            suggest = "admin_user_password"
        elif key == "adminUserSshPublicKey":
            suggest = "admin_user_ssh_public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAccountCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAccountCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAccountCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_user_name: builtins.str,
                 admin_user_password: Optional[builtins.str] = None,
                 admin_user_ssh_public_key: Optional[builtins.str] = None):
        """
        Settings for user account that gets created on each on the nodes of a compute.
        :param builtins.str admin_user_name: Name of the administrator user account which can be used to SSH to nodes.
        :param builtins.str admin_user_password: Password of the administrator user account.
        :param builtins.str admin_user_ssh_public_key: SSH public key of the administrator user account.
        """
        pulumi.set(__self__, "admin_user_name", admin_user_name)
        if admin_user_password is not None:
            pulumi.set(__self__, "admin_user_password", admin_user_password)
        if admin_user_ssh_public_key is not None:
            pulumi.set(__self__, "admin_user_ssh_public_key", admin_user_ssh_public_key)

    @property
    @pulumi.getter(name="adminUserName")
    def admin_user_name(self) -> builtins.str:
        """
        Name of the administrator user account which can be used to SSH to nodes.
        """
        return pulumi.get(self, "admin_user_name")

    @property
    @pulumi.getter(name="adminUserPassword")
    def admin_user_password(self) -> Optional[builtins.str]:
        """
        Password of the administrator user account.
        """
        return pulumi.get(self, "admin_user_password")

    @property
    @pulumi.getter(name="adminUserSshPublicKey")
    def admin_user_ssh_public_key(self) -> Optional[builtins.str]:
        """
        SSH public key of the administrator user account.
        """
        return pulumi.get(self, "admin_user_ssh_public_key")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: builtins.str,
                 principal_id: builtins.str,
                 tenant_id: Optional[builtins.str] = None):
        """
        User assigned identity properties
        :param builtins.str client_id: The client ID of the assigned identity.
        :param builtins.str principal_id: The principal ID of the assigned identity.
        :param builtins.str tenant_id: The tenant ID of the user assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> builtins.str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> builtins.str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        """
        The tenant ID of the user assigned identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class UserIdentityResponse(dict):
    """
    User identity configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityType":
            suggest = "identity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_type: builtins.str):
        """
        User identity configuration.
        :param builtins.str identity_type: Enum to determine identity framework.
               Expected value is 'UserIdentity'.
        """
        pulumi.set(__self__, "identity_type", 'UserIdentity')

    @property
    @pulumi.getter(name="identityType")
    def identity_type(self) -> builtins.str:
        """
        Enum to determine identity framework.
        Expected value is 'UserIdentity'.
        """
        return pulumi.get(self, "identity_type")


@pulumi.output_type
class UserInfoResponse(dict):
    """
    User who created.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userAltSecId":
            suggest = "user_alt_sec_id"
        elif key == "userIdp":
            suggest = "user_idp"
        elif key == "userIss":
            suggest = "user_iss"
        elif key == "userName":
            suggest = "user_name"
        elif key == "userObjectId":
            suggest = "user_object_id"
        elif key == "userPuId":
            suggest = "user_pu_id"
        elif key == "userTenantId":
            suggest = "user_tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_alt_sec_id: Optional[builtins.str] = None,
                 user_idp: Optional[builtins.str] = None,
                 user_iss: Optional[builtins.str] = None,
                 user_name: Optional[builtins.str] = None,
                 user_object_id: Optional[builtins.str] = None,
                 user_pu_id: Optional[builtins.str] = None,
                 user_tenant_id: Optional[builtins.str] = None):
        """
        User who created.
        :param builtins.str user_alt_sec_id: A user alternate sec id. This represents the user in a different identity provider system Eg.1:live.com:puid
        :param builtins.str user_idp: A user identity provider. Eg live.com
        :param builtins.str user_iss: The issuer which issued the token for this user.
        :param builtins.str user_name:  A user's full name or a service principal's app ID.
        :param builtins.str user_object_id: A user or service principal's object ID..
        :param builtins.str user_pu_id: A user or service principal's PuID.
        :param builtins.str user_tenant_id: A user or service principal's tenant ID.
        """
        if user_alt_sec_id is not None:
            pulumi.set(__self__, "user_alt_sec_id", user_alt_sec_id)
        if user_idp is not None:
            pulumi.set(__self__, "user_idp", user_idp)
        if user_iss is not None:
            pulumi.set(__self__, "user_iss", user_iss)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)
        if user_object_id is not None:
            pulumi.set(__self__, "user_object_id", user_object_id)
        if user_pu_id is not None:
            pulumi.set(__self__, "user_pu_id", user_pu_id)
        if user_tenant_id is not None:
            pulumi.set(__self__, "user_tenant_id", user_tenant_id)

    @property
    @pulumi.getter(name="userAltSecId")
    def user_alt_sec_id(self) -> Optional[builtins.str]:
        """
        A user alternate sec id. This represents the user in a different identity provider system Eg.1:live.com:puid
        """
        return pulumi.get(self, "user_alt_sec_id")

    @property
    @pulumi.getter(name="userIdp")
    def user_idp(self) -> Optional[builtins.str]:
        """
        A user identity provider. Eg live.com
        """
        return pulumi.get(self, "user_idp")

    @property
    @pulumi.getter(name="userIss")
    def user_iss(self) -> Optional[builtins.str]:
        """
        The issuer which issued the token for this user.
        """
        return pulumi.get(self, "user_iss")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[builtins.str]:
        """
         A user's full name or a service principal's app ID.
        """
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter(name="userObjectId")
    def user_object_id(self) -> Optional[builtins.str]:
        """
        A user or service principal's object ID..
        """
        return pulumi.get(self, "user_object_id")

    @property
    @pulumi.getter(name="userPuId")
    def user_pu_id(self) -> Optional[builtins.str]:
        """
        A user or service principal's PuID.
        """
        return pulumi.get(self, "user_pu_id")

    @property
    @pulumi.getter(name="userTenantId")
    def user_tenant_id(self) -> Optional[builtins.str]:
        """
        A user or service principal's tenant ID.
        """
        return pulumi.get(self, "user_tenant_id")


@pulumi.output_type
class UsernamePasswordAuthTypeWorkspaceConnectionPropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "createdByWorkspaceArmId":
            suggest = "created_by_workspace_arm_id"
        elif key == "expiryTime":
            suggest = "expiry_time"
        elif key == "isSharedToAll":
            suggest = "is_shared_to_all"
        elif key == "sharedUserList":
            suggest = "shared_user_list"
        elif key == "valueFormat":
            suggest = "value_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UsernamePasswordAuthTypeWorkspaceConnectionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UsernamePasswordAuthTypeWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UsernamePasswordAuthTypeWorkspaceConnectionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: builtins.str,
                 created_by_workspace_arm_id: builtins.str,
                 group: builtins.str,
                 category: Optional[builtins.str] = None,
                 credentials: Optional['outputs.WorkspaceConnectionUsernamePasswordResponse'] = None,
                 expiry_time: Optional[builtins.str] = None,
                 is_shared_to_all: Optional[builtins.bool] = None,
                 metadata: Optional[Mapping[str, builtins.str]] = None,
                 shared_user_list: Optional[Sequence[builtins.str]] = None,
                 target: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None,
                 value_format: Optional[builtins.str] = None):
        """
        :param builtins.str auth_type: Authentication type of the connection target
               Expected value is 'UsernamePassword'.
        :param builtins.str group: Group based on connection category
        :param builtins.str category: Category of the connection
        :param Mapping[str, builtins.str] metadata: Store user metadata for this connection
        :param builtins.str value: Value details of the workspace connection.
        :param builtins.str value_format: format for the workspace connection value
        """
        pulumi.set(__self__, "auth_type", 'UsernamePassword')
        pulumi.set(__self__, "created_by_workspace_arm_id", created_by_workspace_arm_id)
        pulumi.set(__self__, "group", group)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if expiry_time is not None:
            pulumi.set(__self__, "expiry_time", expiry_time)
        if is_shared_to_all is not None:
            pulumi.set(__self__, "is_shared_to_all", is_shared_to_all)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if shared_user_list is not None:
            pulumi.set(__self__, "shared_user_list", shared_user_list)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> builtins.str:
        """
        Authentication type of the connection target
        Expected value is 'UsernamePassword'.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="createdByWorkspaceArmId")
    def created_by_workspace_arm_id(self) -> builtins.str:
        return pulumi.get(self, "created_by_workspace_arm_id")

    @property
    @pulumi.getter
    def group(self) -> builtins.str:
        """
        Group based on connection category
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def category(self) -> Optional[builtins.str]:
        """
        Category of the connection
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.WorkspaceConnectionUsernamePasswordResponse']:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="expiryTime")
    def expiry_time(self) -> Optional[builtins.str]:
        return pulumi.get(self, "expiry_time")

    @property
    @pulumi.getter(name="isSharedToAll")
    def is_shared_to_all(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_shared_to_all")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Store user metadata for this connection
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="sharedUserList")
    def shared_user_list(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "shared_user_list")

    @property
    @pulumi.getter
    def target(self) -> Optional[builtins.str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value details of the workspace connection.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[builtins.str]:
        """
        format for the workspace connection value
        """
        return pulumi.get(self, "value_format")


@pulumi.output_type
class VirtualMachineImageResponse(dict):
    """
    Virtual Machine image for Windows AML Compute
    """
    def __init__(__self__, *,
                 id: builtins.str):
        """
        Virtual Machine image for Windows AML Compute
        :param builtins.str id: Virtual Machine image path
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Virtual Machine image path
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class VirtualMachineResponse(dict):
    """
    A Machine Learning compute based on Azure Virtual Machines.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeType":
            suggest = "compute_type"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "isAttachedCompute":
            suggest = "is_attached_compute"
        elif key == "modifiedOn":
            suggest = "modified_on"
        elif key == "provisioningErrors":
            suggest = "provisioning_errors"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "computeLocation":
            suggest = "compute_location"
        elif key == "disableLocalAuth":
            suggest = "disable_local_auth"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_type: builtins.str,
                 created_on: builtins.str,
                 is_attached_compute: builtins.bool,
                 modified_on: builtins.str,
                 provisioning_errors: Sequence['outputs.ErrorResponseResponse'],
                 provisioning_state: builtins.str,
                 compute_location: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 disable_local_auth: Optional[builtins.bool] = None,
                 properties: Optional['outputs.VirtualMachineSchemaResponseProperties'] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        A Machine Learning compute based on Azure Virtual Machines.
        :param builtins.str compute_type: The type of compute
               Expected value is 'VirtualMachine'.
        :param builtins.str created_on: The time at which the compute was created.
        :param builtins.bool is_attached_compute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        :param builtins.str modified_on: The time at which the compute was last modified.
        :param Sequence['ErrorResponseResponse'] provisioning_errors: Errors during provisioning
        :param builtins.str provisioning_state: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        :param builtins.str compute_location: Location for the underlying compute
        :param builtins.str description: The description of the Machine Learning compute.
        :param builtins.bool disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        :param builtins.str resource_id: ARM resource id of the underlying compute
        """
        pulumi.set(__self__, "compute_type", 'VirtualMachine')
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "is_attached_compute", is_attached_compute)
        pulumi.set(__self__, "modified_on", modified_on)
        pulumi.set(__self__, "provisioning_errors", provisioning_errors)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if compute_location is not None:
            pulumi.set(__self__, "compute_location", compute_location)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_local_auth is not None:
            pulumi.set(__self__, "disable_local_auth", disable_local_auth)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> builtins.str:
        """
        The type of compute
        Expected value is 'VirtualMachine'.
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> builtins.str:
        """
        The time at which the compute was created.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="isAttachedCompute")
    def is_attached_compute(self) -> builtins.bool:
        """
        Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
        """
        return pulumi.get(self, "is_attached_compute")

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> builtins.str:
        """
        The time at which the compute was last modified.
        """
        return pulumi.get(self, "modified_on")

    @property
    @pulumi.getter(name="provisioningErrors")
    def provisioning_errors(self) -> Sequence['outputs.ErrorResponseResponse']:
        """
        Errors during provisioning
        """
        return pulumi.get(self, "provisioning_errors")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[builtins.str]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[builtins.bool]:
        """
        Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        """
        return pulumi.get(self, "disable_local_auth")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.VirtualMachineSchemaResponseProperties']:
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class VirtualMachineSchemaResponseProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "administratorAccount":
            suggest = "administrator_account"
        elif key == "isNotebookInstanceCompute":
            suggest = "is_notebook_instance_compute"
        elif key == "notebookServerPort":
            suggest = "notebook_server_port"
        elif key == "sshPort":
            suggest = "ssh_port"
        elif key == "virtualMachineSize":
            suggest = "virtual_machine_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineSchemaResponseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineSchemaResponseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineSchemaResponseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[builtins.str] = None,
                 administrator_account: Optional['outputs.VirtualMachineSshCredentialsResponse'] = None,
                 is_notebook_instance_compute: Optional[builtins.bool] = None,
                 notebook_server_port: Optional[builtins.int] = None,
                 ssh_port: Optional[builtins.int] = None,
                 virtual_machine_size: Optional[builtins.str] = None):
        """
        :param builtins.str address: Public IP address of the virtual machine.
        :param 'VirtualMachineSshCredentialsResponse' administrator_account: Admin credentials for virtual machine
        :param builtins.bool is_notebook_instance_compute: Indicates whether this compute will be used for running notebooks.
        :param builtins.int notebook_server_port: Notebook server port open for ssh connections.
        :param builtins.int ssh_port: Port open for ssh connections.
        :param builtins.str virtual_machine_size: Virtual Machine size
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if administrator_account is not None:
            pulumi.set(__self__, "administrator_account", administrator_account)
        if is_notebook_instance_compute is not None:
            pulumi.set(__self__, "is_notebook_instance_compute", is_notebook_instance_compute)
        if notebook_server_port is not None:
            pulumi.set(__self__, "notebook_server_port", notebook_server_port)
        if ssh_port is not None:
            pulumi.set(__self__, "ssh_port", ssh_port)
        if virtual_machine_size is not None:
            pulumi.set(__self__, "virtual_machine_size", virtual_machine_size)

    @property
    @pulumi.getter
    def address(self) -> Optional[builtins.str]:
        """
        Public IP address of the virtual machine.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="administratorAccount")
    def administrator_account(self) -> Optional['outputs.VirtualMachineSshCredentialsResponse']:
        """
        Admin credentials for virtual machine
        """
        return pulumi.get(self, "administrator_account")

    @property
    @pulumi.getter(name="isNotebookInstanceCompute")
    def is_notebook_instance_compute(self) -> Optional[builtins.bool]:
        """
        Indicates whether this compute will be used for running notebooks.
        """
        return pulumi.get(self, "is_notebook_instance_compute")

    @property
    @pulumi.getter(name="notebookServerPort")
    def notebook_server_port(self) -> Optional[builtins.int]:
        """
        Notebook server port open for ssh connections.
        """
        return pulumi.get(self, "notebook_server_port")

    @property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[builtins.int]:
        """
        Port open for ssh connections.
        """
        return pulumi.get(self, "ssh_port")

    @property
    @pulumi.getter(name="virtualMachineSize")
    def virtual_machine_size(self) -> Optional[builtins.str]:
        """
        Virtual Machine size
        """
        return pulumi.get(self, "virtual_machine_size")


@pulumi.output_type
class VirtualMachineSizeResponse(dict):
    """
    Describes the properties of a VM size.
    """
    def __init__(__self__, *,
                 family: builtins.str,
                 gpus: builtins.int,
                 low_priority_capable: builtins.bool,
                 max_resource_volume_mb: builtins.int,
                 memory_gb: builtins.float,
                 name: builtins.str,
                 os_vhd_size_mb: builtins.int,
                 premium_io: builtins.bool,
                 v_cpus: builtins.int,
                 estimated_vm_prices: Optional['outputs.EstimatedVMPricesResponse'] = None,
                 supported_compute_types: Optional[Sequence[builtins.str]] = None):
        """
        Describes the properties of a VM size.
        :param builtins.str family: The family name of the virtual machine size.
        :param builtins.int gpus: The number of gPUs supported by the virtual machine size.
        :param builtins.bool low_priority_capable: Specifies if the virtual machine size supports low priority VMs.
        :param builtins.int max_resource_volume_mb: The resource volume size, in MB, allowed by the virtual machine size.
        :param builtins.float memory_gb: The amount of memory, in GB, supported by the virtual machine size.
        :param builtins.str name: The name of the virtual machine size.
        :param builtins.int os_vhd_size_mb: The OS VHD disk size, in MB, allowed by the virtual machine size.
        :param builtins.bool premium_io: Specifies if the virtual machine size supports premium IO.
        :param builtins.int v_cpus: The number of vCPUs supported by the virtual machine size.
        :param 'EstimatedVMPricesResponse' estimated_vm_prices: The estimated price information for using a VM.
        :param Sequence[builtins.str] supported_compute_types: Specifies the compute types supported by the virtual machine size.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "gpus", gpus)
        pulumi.set(__self__, "low_priority_capable", low_priority_capable)
        pulumi.set(__self__, "max_resource_volume_mb", max_resource_volume_mb)
        pulumi.set(__self__, "memory_gb", memory_gb)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "os_vhd_size_mb", os_vhd_size_mb)
        pulumi.set(__self__, "premium_io", premium_io)
        pulumi.set(__self__, "v_cpus", v_cpus)
        if estimated_vm_prices is not None:
            pulumi.set(__self__, "estimated_vm_prices", estimated_vm_prices)
        if supported_compute_types is not None:
            pulumi.set(__self__, "supported_compute_types", supported_compute_types)

    @property
    @pulumi.getter
    def family(self) -> builtins.str:
        """
        The family name of the virtual machine size.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def gpus(self) -> builtins.int:
        """
        The number of gPUs supported by the virtual machine size.
        """
        return pulumi.get(self, "gpus")

    @property
    @pulumi.getter(name="lowPriorityCapable")
    def low_priority_capable(self) -> builtins.bool:
        """
        Specifies if the virtual machine size supports low priority VMs.
        """
        return pulumi.get(self, "low_priority_capable")

    @property
    @pulumi.getter(name="maxResourceVolumeMB")
    def max_resource_volume_mb(self) -> builtins.int:
        """
        The resource volume size, in MB, allowed by the virtual machine size.
        """
        return pulumi.get(self, "max_resource_volume_mb")

    @property
    @pulumi.getter(name="memoryGB")
    def memory_gb(self) -> builtins.float:
        """
        The amount of memory, in GB, supported by the virtual machine size.
        """
        return pulumi.get(self, "memory_gb")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the virtual machine size.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="osVhdSizeMB")
    def os_vhd_size_mb(self) -> builtins.int:
        """
        The OS VHD disk size, in MB, allowed by the virtual machine size.
        """
        return pulumi.get(self, "os_vhd_size_mb")

    @property
    @pulumi.getter(name="premiumIO")
    def premium_io(self) -> builtins.bool:
        """
        Specifies if the virtual machine size supports premium IO.
        """
        return pulumi.get(self, "premium_io")

    @property
    @pulumi.getter(name="vCPUs")
    def v_cpus(self) -> builtins.int:
        """
        The number of vCPUs supported by the virtual machine size.
        """
        return pulumi.get(self, "v_cpus")

    @property
    @pulumi.getter(name="estimatedVMPrices")
    def estimated_vm_prices(self) -> Optional['outputs.EstimatedVMPricesResponse']:
        """
        The estimated price information for using a VM.
        """
        return pulumi.get(self, "estimated_vm_prices")

    @property
    @pulumi.getter(name="supportedComputeTypes")
    def supported_compute_types(self) -> Optional[Sequence[builtins.str]]:
        """
        Specifies the compute types supported by the virtual machine size.
        """
        return pulumi.get(self, "supported_compute_types")


@pulumi.output_type
class VirtualMachineSshCredentialsResponse(dict):
    """
    Admin credentials for virtual machine
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKeyData":
            suggest = "private_key_data"
        elif key == "publicKeyData":
            suggest = "public_key_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineSshCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineSshCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineSshCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: Optional[builtins.str] = None,
                 private_key_data: Optional[builtins.str] = None,
                 public_key_data: Optional[builtins.str] = None,
                 username: Optional[builtins.str] = None):
        """
        Admin credentials for virtual machine
        :param builtins.str password: Password of admin account
        :param builtins.str private_key_data: Private key data
        :param builtins.str public_key_data: Public key data
        :param builtins.str username: Username of admin account
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if private_key_data is not None:
            pulumi.set(__self__, "private_key_data", private_key_data)
        if public_key_data is not None:
            pulumi.set(__self__, "public_key_data", public_key_data)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[builtins.str]:
        """
        Password of admin account
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="privateKeyData")
    def private_key_data(self) -> Optional[builtins.str]:
        """
        Private key data
        """
        return pulumi.get(self, "private_key_data")

    @property
    @pulumi.getter(name="publicKeyData")
    def public_key_data(self) -> Optional[builtins.str]:
        """
        Public key data
        """
        return pulumi.get(self, "public_key_data")

    @property
    @pulumi.getter
    def username(self) -> Optional[builtins.str]:
        """
        Username of admin account
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class VolumeDefinitionResponse(dict):
    """
    Describes the volume configuration for the container
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind: Optional['outputs.BindOptionsResponse'] = None,
                 consistency: Optional[builtins.str] = None,
                 read_only: Optional[builtins.bool] = None,
                 source: Optional[builtins.str] = None,
                 target: Optional[builtins.str] = None,
                 tmpfs: Optional['outputs.TmpfsOptionsResponse'] = None,
                 type: Optional[builtins.str] = None,
                 volume: Optional['outputs.VolumeOptionsResponse'] = None):
        """
        Describes the volume configuration for the container
        :param 'BindOptionsResponse' bind: Bind Options of the mount
        :param builtins.str consistency: Consistency of the volume
        :param builtins.bool read_only: Indicate whether to mount volume as readOnly. Default value for this is false.
        :param builtins.str source: Source of the mount. For bind mounts this is the host path.
        :param builtins.str target: Target of the mount. For bind mounts this is the path in the container.
        :param 'TmpfsOptionsResponse' tmpfs: tmpfs option of the mount
        :param builtins.str type: Type of Volume Definition. Possible Values: bind,volume,tmpfs,npipe
        :param 'VolumeOptionsResponse' volume: Volume Options of the mount
        """
        if bind is not None:
            pulumi.set(__self__, "bind", bind)
        if consistency is not None:
            pulumi.set(__self__, "consistency", consistency)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if tmpfs is not None:
            pulumi.set(__self__, "tmpfs", tmpfs)
        if type is None:
            type = 'bind'
        if type is not None:
            pulumi.set(__self__, "type", type)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @property
    @pulumi.getter
    def bind(self) -> Optional['outputs.BindOptionsResponse']:
        """
        Bind Options of the mount
        """
        return pulumi.get(self, "bind")

    @property
    @pulumi.getter
    def consistency(self) -> Optional[builtins.str]:
        """
        Consistency of the volume
        """
        return pulumi.get(self, "consistency")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[builtins.bool]:
        """
        Indicate whether to mount volume as readOnly. Default value for this is false.
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter
    def source(self) -> Optional[builtins.str]:
        """
        Source of the mount. For bind mounts this is the host path.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> Optional[builtins.str]:
        """
        Target of the mount. For bind mounts this is the path in the container.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def tmpfs(self) -> Optional['outputs.TmpfsOptionsResponse']:
        """
        tmpfs option of the mount
        """
        return pulumi.get(self, "tmpfs")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of Volume Definition. Possible Values: bind,volume,tmpfs,npipe
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def volume(self) -> Optional['outputs.VolumeOptionsResponse']:
        """
        Volume Options of the mount
        """
        return pulumi.get(self, "volume")


@pulumi.output_type
class VolumeOptionsResponse(dict):
    """
    Describes the volume options for the container
    """
    def __init__(__self__, *,
                 nocopy: Optional[builtins.bool] = None):
        """
        Describes the volume options for the container
        :param builtins.bool nocopy: Indicate whether volume is nocopy
        """
        if nocopy is not None:
            pulumi.set(__self__, "nocopy", nocopy)

    @property
    @pulumi.getter
    def nocopy(self) -> Optional[builtins.bool]:
        """
        Indicate whether volume is nocopy
        """
        return pulumi.get(self, "nocopy")


@pulumi.output_type
class WorkspaceConnectionAccessKeyResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceConnectionAccessKeyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceConnectionAccessKeyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceConnectionAccessKeyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_id: Optional[builtins.str] = None,
                 secret_access_key: Optional[builtins.str] = None):
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "secret_access_key")


@pulumi.output_type
class WorkspaceConnectionAccountKeyResponse(dict):
    def __init__(__self__, *,
                 key: Optional[builtins.str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "key")


@pulumi.output_type
class WorkspaceConnectionApiKeyResponse(dict):
    """
    Api key object for workspace connection credential.
    """
    def __init__(__self__, *,
                 key: Optional[builtins.str] = None):
        """
        Api key object for workspace connection credential.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "key")


@pulumi.output_type
class WorkspaceConnectionManagedIdentityResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceConnectionManagedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceConnectionManagedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceConnectionManagedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[builtins.str] = None,
                 resource_id: Optional[builtins.str] = None):
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class WorkspaceConnectionOAuth2Response(dict):
    """
    ClientId and ClientSecret are required. Other properties are optional
    depending on each OAuth2 provider's implementation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authUrl":
            suggest = "auth_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "developerToken":
            suggest = "developer_token"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceConnectionOAuth2Response. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceConnectionOAuth2Response.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceConnectionOAuth2Response.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_url: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 developer_token: Optional[builtins.str] = None,
                 password: Optional[builtins.str] = None,
                 refresh_token: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None,
                 username: Optional[builtins.str] = None):
        """
        ClientId and ClientSecret are required. Other properties are optional
        depending on each OAuth2 provider's implementation.
        :param builtins.str auth_url: Required by Concur connection category
        :param builtins.str client_id: Client id in the format of UUID
        :param builtins.str developer_token: Required by GoogleAdWords connection category
        :param builtins.str refresh_token: Required by GoogleBigQuery, GoogleAdWords, Hubspot, QuickBooks, Square, Xero, Zoho
               where user needs to get RefreshToken offline
        :param builtins.str tenant_id: Required by QuickBooks and Xero connection categories
        :param builtins.str username: Concur, ServiceNow auth server AccessToken grant type is 'Password'
               which requires UsernamePassword
        """
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if developer_token is not None:
            pulumi.set(__self__, "developer_token", developer_token)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[builtins.str]:
        """
        Required by Concur connection category
        """
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        Client id in the format of UUID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="developerToken")
    def developer_token(self) -> Optional[builtins.str]:
        """
        Required by GoogleAdWords connection category
        """
        return pulumi.get(self, "developer_token")

    @property
    @pulumi.getter
    def password(self) -> Optional[builtins.str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[builtins.str]:
        """
        Required by GoogleBigQuery, GoogleAdWords, Hubspot, QuickBooks, Square, Xero, Zoho
        where user needs to get RefreshToken offline
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        """
        Required by QuickBooks and Xero connection categories
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def username(self) -> Optional[builtins.str]:
        """
        Concur, ServiceNow auth server AccessToken grant type is 'Password'
        which requires UsernamePassword
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class WorkspaceConnectionPersonalAccessTokenResponse(dict):
    def __init__(__self__, *,
                 pat: Optional[builtins.str] = None):
        if pat is not None:
            pulumi.set(__self__, "pat", pat)

    @property
    @pulumi.getter
    def pat(self) -> Optional[builtins.str]:
        return pulumi.get(self, "pat")


@pulumi.output_type
class WorkspaceConnectionServicePrincipalResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceConnectionServicePrincipalResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceConnectionServicePrincipalResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceConnectionServicePrincipalResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None):
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class WorkspaceConnectionSharedAccessSignatureResponse(dict):
    def __init__(__self__, *,
                 sas: Optional[builtins.str] = None):
        if sas is not None:
            pulumi.set(__self__, "sas", sas)

    @property
    @pulumi.getter
    def sas(self) -> Optional[builtins.str]:
        return pulumi.get(self, "sas")


@pulumi.output_type
class WorkspaceConnectionUsernamePasswordResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityToken":
            suggest = "security_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceConnectionUsernamePasswordResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceConnectionUsernamePasswordResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceConnectionUsernamePasswordResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: Optional[builtins.str] = None,
                 security_token: Optional[builtins.str] = None,
                 username: Optional[builtins.str] = None):
        """
        :param builtins.str security_token: Optional, required by connections like SalesForce for extra security in addition to UsernamePassword
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if security_token is not None:
            pulumi.set(__self__, "security_token", security_token)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[builtins.str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="securityToken")
    def security_token(self) -> Optional[builtins.str]:
        """
        Optional, required by connections like SalesForce for extra security in addition to UsernamePassword
        """
        return pulumi.get(self, "security_token")

    @property
    @pulumi.getter
    def username(self) -> Optional[builtins.str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class WorkspaceHubConfigResponse(dict):
    """
    WorkspaceHub's configuration object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalWorkspaceStorageAccounts":
            suggest = "additional_workspace_storage_accounts"
        elif key == "defaultWorkspaceResourceGroup":
            suggest = "default_workspace_resource_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceHubConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceHubConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceHubConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_workspace_storage_accounts: Optional[Sequence[builtins.str]] = None,
                 default_workspace_resource_group: Optional[builtins.str] = None):
        """
        WorkspaceHub's configuration object.
        """
        if additional_workspace_storage_accounts is not None:
            pulumi.set(__self__, "additional_workspace_storage_accounts", additional_workspace_storage_accounts)
        if default_workspace_resource_group is not None:
            pulumi.set(__self__, "default_workspace_resource_group", default_workspace_resource_group)

    @property
    @pulumi.getter(name="additionalWorkspaceStorageAccounts")
    def additional_workspace_storage_accounts(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "additional_workspace_storage_accounts")

    @property
    @pulumi.getter(name="defaultWorkspaceResourceGroup")
    def default_workspace_resource_group(self) -> Optional[builtins.str]:
        return pulumi.get(self, "default_workspace_resource_group")


