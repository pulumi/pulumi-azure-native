# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from ._enums import *

__all__ = [
    'AKSPropertiesArgs',
    'AKSArgs',
    'AksNetworkingConfigurationArgs',
    'AmlComputePropertiesArgs',
    'AmlComputeArgs',
    'AssignedUserArgs',
    'AutoPausePropertiesArgs',
    'AutoScalePropertiesArgs',
    'ComputeInstancePropertiesArgs',
    'ComputeInstanceSshSettingsArgs',
    'ComputeInstanceArgs',
    'CosmosDbSettingsArgs',
    'DataFactoryArgs',
    'DataLakeAnalyticsPropertiesArgs',
    'DataLakeAnalyticsArgs',
    'DatabricksPropertiesArgs',
    'DatabricksArgs',
    'EncryptionPropertyArgs',
    'HDInsightPropertiesArgs',
    'HDInsightArgs',
    'IdentityForCmkArgs',
    'IdentityArgs',
    'InstanceTypeSchemaResourcesArgs',
    'InstanceTypeSchemaArgs',
    'KeyVaultPropertiesArgs',
    'KubernetesPropertiesArgs',
    'KubernetesArgs',
    'PersonalComputeInstanceSettingsArgs',
    'PrivateLinkServiceConnectionStateArgs',
    'ResourceIdArgs',
    'ScaleSettingsArgs',
    'ScriptReferenceArgs',
    'ScriptsToExecuteArgs',
    'ServiceManagedResourcesSettingsArgs',
    'SetupScriptsArgs',
    'SharedPrivateLinkResourceArgs',
    'SkuArgs',
    'SslConfigurationArgs',
    'SynapseSparkPropertiesArgs',
    'SynapseSparkArgs',
    'UserAccountCredentialsArgs',
    'VirtualMachineImageArgs',
    'VirtualMachinePropertiesArgs',
    'VirtualMachineSshCredentialsArgs',
    'VirtualMachineArgs',
]

@pulumi.input_type
class AKSPropertiesArgs:
    def __init__(__self__, *,
                 agent_count: Optional[pulumi.Input[int]] = None,
                 agent_vm_size: Optional[pulumi.Input[str]] = None,
                 aks_networking_configuration: Optional[pulumi.Input['AksNetworkingConfigurationArgs']] = None,
                 cluster_fqdn: Optional[pulumi.Input[str]] = None,
                 cluster_purpose: Optional[pulumi.Input[Union[str, 'ClusterPurpose']]] = None,
                 load_balancer_subnet: Optional[pulumi.Input[str]] = None,
                 load_balancer_type: Optional[pulumi.Input[Union[str, 'LoadBalancerType']]] = None,
                 ssl_configuration: Optional[pulumi.Input['SslConfigurationArgs']] = None):
        """
        AKS properties
        :param pulumi.Input[int] agent_count: Number of agents
        :param pulumi.Input[str] agent_vm_size: Agent virtual machine size
        :param pulumi.Input['AksNetworkingConfigurationArgs'] aks_networking_configuration: AKS networking configuration for vnet
        :param pulumi.Input[str] cluster_fqdn: Cluster full qualified domain name
        :param pulumi.Input[Union[str, 'ClusterPurpose']] cluster_purpose: Intended usage of the cluster
        :param pulumi.Input[str] load_balancer_subnet: Load Balancer Subnet
        :param pulumi.Input[Union[str, 'LoadBalancerType']] load_balancer_type: Load Balancer Type
        :param pulumi.Input['SslConfigurationArgs'] ssl_configuration: SSL configuration
        """
        AKSPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            agent_count=agent_count,
            agent_vm_size=agent_vm_size,
            aks_networking_configuration=aks_networking_configuration,
            cluster_fqdn=cluster_fqdn,
            cluster_purpose=cluster_purpose,
            load_balancer_subnet=load_balancer_subnet,
            load_balancer_type=load_balancer_type,
            ssl_configuration=ssl_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             agent_count: Optional[pulumi.Input[int]] = None,
             agent_vm_size: Optional[pulumi.Input[str]] = None,
             aks_networking_configuration: Optional[pulumi.Input['AksNetworkingConfigurationArgs']] = None,
             cluster_fqdn: Optional[pulumi.Input[str]] = None,
             cluster_purpose: Optional[pulumi.Input[Union[str, 'ClusterPurpose']]] = None,
             load_balancer_subnet: Optional[pulumi.Input[str]] = None,
             load_balancer_type: Optional[pulumi.Input[Union[str, 'LoadBalancerType']]] = None,
             ssl_configuration: Optional[pulumi.Input['SslConfigurationArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if agent_count is None and 'agentCount' in kwargs:
            agent_count = kwargs['agentCount']
        if agent_vm_size is None and 'agentVmSize' in kwargs:
            agent_vm_size = kwargs['agentVmSize']
        if aks_networking_configuration is None and 'aksNetworkingConfiguration' in kwargs:
            aks_networking_configuration = kwargs['aksNetworkingConfiguration']
        if cluster_fqdn is None and 'clusterFqdn' in kwargs:
            cluster_fqdn = kwargs['clusterFqdn']
        if cluster_purpose is None and 'clusterPurpose' in kwargs:
            cluster_purpose = kwargs['clusterPurpose']
        if load_balancer_subnet is None and 'loadBalancerSubnet' in kwargs:
            load_balancer_subnet = kwargs['loadBalancerSubnet']
        if load_balancer_type is None and 'loadBalancerType' in kwargs:
            load_balancer_type = kwargs['loadBalancerType']
        if ssl_configuration is None and 'sslConfiguration' in kwargs:
            ssl_configuration = kwargs['sslConfiguration']

        if agent_count is not None:
            _setter("agent_count", agent_count)
        if agent_vm_size is not None:
            _setter("agent_vm_size", agent_vm_size)
        if aks_networking_configuration is not None:
            _setter("aks_networking_configuration", aks_networking_configuration)
        if cluster_fqdn is not None:
            _setter("cluster_fqdn", cluster_fqdn)
        if cluster_purpose is None:
            cluster_purpose = 'FastProd'
        if cluster_purpose is not None:
            _setter("cluster_purpose", cluster_purpose)
        if load_balancer_subnet is not None:
            _setter("load_balancer_subnet", load_balancer_subnet)
        if load_balancer_type is None:
            load_balancer_type = 'PublicIp'
        if load_balancer_type is not None:
            _setter("load_balancer_type", load_balancer_type)
        if ssl_configuration is not None:
            _setter("ssl_configuration", ssl_configuration)

    @property
    @pulumi.getter(name="agentCount")
    def agent_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of agents
        """
        return pulumi.get(self, "agent_count")

    @agent_count.setter
    def agent_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "agent_count", value)

    @property
    @pulumi.getter(name="agentVmSize")
    def agent_vm_size(self) -> Optional[pulumi.Input[str]]:
        """
        Agent virtual machine size
        """
        return pulumi.get(self, "agent_vm_size")

    @agent_vm_size.setter
    def agent_vm_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "agent_vm_size", value)

    @property
    @pulumi.getter(name="aksNetworkingConfiguration")
    def aks_networking_configuration(self) -> Optional[pulumi.Input['AksNetworkingConfigurationArgs']]:
        """
        AKS networking configuration for vnet
        """
        return pulumi.get(self, "aks_networking_configuration")

    @aks_networking_configuration.setter
    def aks_networking_configuration(self, value: Optional[pulumi.Input['AksNetworkingConfigurationArgs']]):
        pulumi.set(self, "aks_networking_configuration", value)

    @property
    @pulumi.getter(name="clusterFqdn")
    def cluster_fqdn(self) -> Optional[pulumi.Input[str]]:
        """
        Cluster full qualified domain name
        """
        return pulumi.get(self, "cluster_fqdn")

    @cluster_fqdn.setter
    def cluster_fqdn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_fqdn", value)

    @property
    @pulumi.getter(name="clusterPurpose")
    def cluster_purpose(self) -> Optional[pulumi.Input[Union[str, 'ClusterPurpose']]]:
        """
        Intended usage of the cluster
        """
        return pulumi.get(self, "cluster_purpose")

    @cluster_purpose.setter
    def cluster_purpose(self, value: Optional[pulumi.Input[Union[str, 'ClusterPurpose']]]):
        pulumi.set(self, "cluster_purpose", value)

    @property
    @pulumi.getter(name="loadBalancerSubnet")
    def load_balancer_subnet(self) -> Optional[pulumi.Input[str]]:
        """
        Load Balancer Subnet
        """
        return pulumi.get(self, "load_balancer_subnet")

    @load_balancer_subnet.setter
    def load_balancer_subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_subnet", value)

    @property
    @pulumi.getter(name="loadBalancerType")
    def load_balancer_type(self) -> Optional[pulumi.Input[Union[str, 'LoadBalancerType']]]:
        """
        Load Balancer Type
        """
        return pulumi.get(self, "load_balancer_type")

    @load_balancer_type.setter
    def load_balancer_type(self, value: Optional[pulumi.Input[Union[str, 'LoadBalancerType']]]):
        pulumi.set(self, "load_balancer_type", value)

    @property
    @pulumi.getter(name="sslConfiguration")
    def ssl_configuration(self) -> Optional[pulumi.Input['SslConfigurationArgs']]:
        """
        SSL configuration
        """
        return pulumi.get(self, "ssl_configuration")

    @ssl_configuration.setter
    def ssl_configuration(self, value: Optional[pulumi.Input['SslConfigurationArgs']]):
        pulumi.set(self, "ssl_configuration", value)


@pulumi.input_type
class AKSArgs:
    def __init__(__self__, *,
                 compute_type: pulumi.Input[str],
                 compute_location: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disable_local_auth: Optional[pulumi.Input[bool]] = None,
                 properties: Optional[pulumi.Input['AKSPropertiesArgs']] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        A Machine Learning compute based on AKS.
        :param pulumi.Input[str] compute_type: The type of compute
               Expected value is 'AKS'.
        :param pulumi.Input[str] compute_location: Location for the underlying compute
        :param pulumi.Input[str] description: The description of the Machine Learning compute.
        :param pulumi.Input[bool] disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        :param pulumi.Input['AKSPropertiesArgs'] properties: AKS properties
        :param pulumi.Input[str] resource_id: ARM resource id of the underlying compute
        """
        AKSArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_type=compute_type,
            compute_location=compute_location,
            description=description,
            disable_local_auth=disable_local_auth,
            properties=properties,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_type: Optional[pulumi.Input[str]] = None,
             compute_location: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             disable_local_auth: Optional[pulumi.Input[bool]] = None,
             properties: Optional[pulumi.Input['AKSPropertiesArgs']] = None,
             resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compute_type is None and 'computeType' in kwargs:
            compute_type = kwargs['computeType']
        if compute_type is None:
            raise TypeError("Missing 'compute_type' argument")
        if compute_location is None and 'computeLocation' in kwargs:
            compute_location = kwargs['computeLocation']
        if disable_local_auth is None and 'disableLocalAuth' in kwargs:
            disable_local_auth = kwargs['disableLocalAuth']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        _setter("compute_type", 'AKS')
        if compute_location is not None:
            _setter("compute_location", compute_location)
        if description is not None:
            _setter("description", description)
        if disable_local_auth is not None:
            _setter("disable_local_auth", disable_local_auth)
        if properties is not None:
            _setter("properties", properties)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> pulumi.Input[str]:
        """
        The type of compute
        Expected value is 'AKS'.
        """
        return pulumi.get(self, "compute_type")

    @compute_type.setter
    def compute_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "compute_type", value)

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[pulumi.Input[str]]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @compute_location.setter
    def compute_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compute_location", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        """
        return pulumi.get(self, "disable_local_auth")

    @disable_local_auth.setter
    def disable_local_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_local_auth", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input['AKSPropertiesArgs']]:
        """
        AKS properties
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input['AKSPropertiesArgs']]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class AksNetworkingConfigurationArgs:
    def __init__(__self__, *,
                 dns_service_ip: Optional[pulumi.Input[str]] = None,
                 docker_bridge_cidr: Optional[pulumi.Input[str]] = None,
                 service_cidr: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        Advance configuration for AKS networking
        :param pulumi.Input[str] dns_service_ip: An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range specified in serviceCidr.
        :param pulumi.Input[str] docker_bridge_cidr: A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes service address range.
        :param pulumi.Input[str] service_cidr: A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP ranges.
        :param pulumi.Input[str] subnet_id: Virtual network subnet resource ID the compute nodes belong to
        """
        AksNetworkingConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dns_service_ip=dns_service_ip,
            docker_bridge_cidr=docker_bridge_cidr,
            service_cidr=service_cidr,
            subnet_id=subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dns_service_ip: Optional[pulumi.Input[str]] = None,
             docker_bridge_cidr: Optional[pulumi.Input[str]] = None,
             service_cidr: Optional[pulumi.Input[str]] = None,
             subnet_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if dns_service_ip is None and 'dnsServiceIP' in kwargs:
            dns_service_ip = kwargs['dnsServiceIP']
        if docker_bridge_cidr is None and 'dockerBridgeCidr' in kwargs:
            docker_bridge_cidr = kwargs['dockerBridgeCidr']
        if service_cidr is None and 'serviceCidr' in kwargs:
            service_cidr = kwargs['serviceCidr']
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']

        if dns_service_ip is not None:
            _setter("dns_service_ip", dns_service_ip)
        if docker_bridge_cidr is not None:
            _setter("docker_bridge_cidr", docker_bridge_cidr)
        if service_cidr is not None:
            _setter("service_cidr", service_cidr)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)

    @property
    @pulumi.getter(name="dnsServiceIP")
    def dns_service_ip(self) -> Optional[pulumi.Input[str]]:
        """
        An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range specified in serviceCidr.
        """
        return pulumi.get(self, "dns_service_ip")

    @dns_service_ip.setter
    def dns_service_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_service_ip", value)

    @property
    @pulumi.getter(name="dockerBridgeCidr")
    def docker_bridge_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes service address range.
        """
        return pulumi.get(self, "docker_bridge_cidr")

    @docker_bridge_cidr.setter
    def docker_bridge_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_bridge_cidr", value)

    @property
    @pulumi.getter(name="serviceCidr")
    def service_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP ranges.
        """
        return pulumi.get(self, "service_cidr")

    @service_cidr.setter
    def service_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_cidr", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Virtual network subnet resource ID the compute nodes belong to
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class AmlComputePropertiesArgs:
    def __init__(__self__, *,
                 enable_node_public_ip: Optional[pulumi.Input[bool]] = None,
                 isolated_network: Optional[pulumi.Input[bool]] = None,
                 os_type: Optional[pulumi.Input[Union[str, 'OsType']]] = None,
                 remote_login_port_public_access: Optional[pulumi.Input[Union[str, 'RemoteLoginPortPublicAccess']]] = None,
                 scale_settings: Optional[pulumi.Input['ScaleSettingsArgs']] = None,
                 subnet: Optional[pulumi.Input['ResourceIdArgs']] = None,
                 user_account_credentials: Optional[pulumi.Input['UserAccountCredentialsArgs']] = None,
                 virtual_machine_image: Optional[pulumi.Input['VirtualMachineImageArgs']] = None,
                 vm_priority: Optional[pulumi.Input[Union[str, 'VmPriority']]] = None,
                 vm_size: Optional[pulumi.Input[str]] = None):
        """
        AML Compute properties
        :param pulumi.Input[bool] enable_node_public_ip: Enable or disable node public IP address provisioning. Possible values are: Possible values are: true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will have a private endpoint and no public IPs.
        :param pulumi.Input[bool] isolated_network: Network is isolated or not
        :param pulumi.Input[Union[str, 'OsType']] os_type: Compute OS Type
        :param pulumi.Input[Union[str, 'RemoteLoginPortPublicAccess']] remote_login_port_public_access: State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on all nodes of the cluster. Enabled - Indicates that the public ssh port is open on all nodes of the cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined, else is open all public nodes. It can be default only during cluster creation time, after creation it will be either enabled or disabled.
        :param pulumi.Input['ScaleSettingsArgs'] scale_settings: Scale settings for AML Compute
        :param pulumi.Input['ResourceIdArgs'] subnet: Virtual network subnet resource ID the compute nodes belong to.
        :param pulumi.Input['UserAccountCredentialsArgs'] user_account_credentials: Credentials for an administrator user account that will be created on each compute node.
        :param pulumi.Input['VirtualMachineImageArgs'] virtual_machine_image: Virtual Machine image for AML Compute - windows only
        :param pulumi.Input[Union[str, 'VmPriority']] vm_priority: Virtual Machine priority
        :param pulumi.Input[str] vm_size: Virtual Machine Size
        """
        AmlComputePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable_node_public_ip=enable_node_public_ip,
            isolated_network=isolated_network,
            os_type=os_type,
            remote_login_port_public_access=remote_login_port_public_access,
            scale_settings=scale_settings,
            subnet=subnet,
            user_account_credentials=user_account_credentials,
            virtual_machine_image=virtual_machine_image,
            vm_priority=vm_priority,
            vm_size=vm_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable_node_public_ip: Optional[pulumi.Input[bool]] = None,
             isolated_network: Optional[pulumi.Input[bool]] = None,
             os_type: Optional[pulumi.Input[Union[str, 'OsType']]] = None,
             remote_login_port_public_access: Optional[pulumi.Input[Union[str, 'RemoteLoginPortPublicAccess']]] = None,
             scale_settings: Optional[pulumi.Input['ScaleSettingsArgs']] = None,
             subnet: Optional[pulumi.Input['ResourceIdArgs']] = None,
             user_account_credentials: Optional[pulumi.Input['UserAccountCredentialsArgs']] = None,
             virtual_machine_image: Optional[pulumi.Input['VirtualMachineImageArgs']] = None,
             vm_priority: Optional[pulumi.Input[Union[str, 'VmPriority']]] = None,
             vm_size: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enable_node_public_ip is None and 'enableNodePublicIp' in kwargs:
            enable_node_public_ip = kwargs['enableNodePublicIp']
        if isolated_network is None and 'isolatedNetwork' in kwargs:
            isolated_network = kwargs['isolatedNetwork']
        if os_type is None and 'osType' in kwargs:
            os_type = kwargs['osType']
        if remote_login_port_public_access is None and 'remoteLoginPortPublicAccess' in kwargs:
            remote_login_port_public_access = kwargs['remoteLoginPortPublicAccess']
        if scale_settings is None and 'scaleSettings' in kwargs:
            scale_settings = kwargs['scaleSettings']
        if user_account_credentials is None and 'userAccountCredentials' in kwargs:
            user_account_credentials = kwargs['userAccountCredentials']
        if virtual_machine_image is None and 'virtualMachineImage' in kwargs:
            virtual_machine_image = kwargs['virtualMachineImage']
        if vm_priority is None and 'vmPriority' in kwargs:
            vm_priority = kwargs['vmPriority']
        if vm_size is None and 'vmSize' in kwargs:
            vm_size = kwargs['vmSize']

        if enable_node_public_ip is None:
            enable_node_public_ip = True
        if enable_node_public_ip is not None:
            _setter("enable_node_public_ip", enable_node_public_ip)
        if isolated_network is not None:
            _setter("isolated_network", isolated_network)
        if os_type is None:
            os_type = 'Linux'
        if os_type is not None:
            _setter("os_type", os_type)
        if remote_login_port_public_access is None:
            remote_login_port_public_access = 'NotSpecified'
        if remote_login_port_public_access is not None:
            _setter("remote_login_port_public_access", remote_login_port_public_access)
        if scale_settings is not None:
            _setter("scale_settings", scale_settings)
        if subnet is not None:
            _setter("subnet", subnet)
        if user_account_credentials is not None:
            _setter("user_account_credentials", user_account_credentials)
        if virtual_machine_image is not None:
            _setter("virtual_machine_image", virtual_machine_image)
        if vm_priority is not None:
            _setter("vm_priority", vm_priority)
        if vm_size is not None:
            _setter("vm_size", vm_size)

    @property
    @pulumi.getter(name="enableNodePublicIp")
    def enable_node_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable node public IP address provisioning. Possible values are: Possible values are: true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will have a private endpoint and no public IPs.
        """
        return pulumi.get(self, "enable_node_public_ip")

    @enable_node_public_ip.setter
    def enable_node_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_node_public_ip", value)

    @property
    @pulumi.getter(name="isolatedNetwork")
    def isolated_network(self) -> Optional[pulumi.Input[bool]]:
        """
        Network is isolated or not
        """
        return pulumi.get(self, "isolated_network")

    @isolated_network.setter
    def isolated_network(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "isolated_network", value)

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[pulumi.Input[Union[str, 'OsType']]]:
        """
        Compute OS Type
        """
        return pulumi.get(self, "os_type")

    @os_type.setter
    def os_type(self, value: Optional[pulumi.Input[Union[str, 'OsType']]]):
        pulumi.set(self, "os_type", value)

    @property
    @pulumi.getter(name="remoteLoginPortPublicAccess")
    def remote_login_port_public_access(self) -> Optional[pulumi.Input[Union[str, 'RemoteLoginPortPublicAccess']]]:
        """
        State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on all nodes of the cluster. Enabled - Indicates that the public ssh port is open on all nodes of the cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined, else is open all public nodes. It can be default only during cluster creation time, after creation it will be either enabled or disabled.
        """
        return pulumi.get(self, "remote_login_port_public_access")

    @remote_login_port_public_access.setter
    def remote_login_port_public_access(self, value: Optional[pulumi.Input[Union[str, 'RemoteLoginPortPublicAccess']]]):
        pulumi.set(self, "remote_login_port_public_access", value)

    @property
    @pulumi.getter(name="scaleSettings")
    def scale_settings(self) -> Optional[pulumi.Input['ScaleSettingsArgs']]:
        """
        Scale settings for AML Compute
        """
        return pulumi.get(self, "scale_settings")

    @scale_settings.setter
    def scale_settings(self, value: Optional[pulumi.Input['ScaleSettingsArgs']]):
        pulumi.set(self, "scale_settings", value)

    @property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input['ResourceIdArgs']]:
        """
        Virtual network subnet resource ID the compute nodes belong to.
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input['ResourceIdArgs']]):
        pulumi.set(self, "subnet", value)

    @property
    @pulumi.getter(name="userAccountCredentials")
    def user_account_credentials(self) -> Optional[pulumi.Input['UserAccountCredentialsArgs']]:
        """
        Credentials for an administrator user account that will be created on each compute node.
        """
        return pulumi.get(self, "user_account_credentials")

    @user_account_credentials.setter
    def user_account_credentials(self, value: Optional[pulumi.Input['UserAccountCredentialsArgs']]):
        pulumi.set(self, "user_account_credentials", value)

    @property
    @pulumi.getter(name="virtualMachineImage")
    def virtual_machine_image(self) -> Optional[pulumi.Input['VirtualMachineImageArgs']]:
        """
        Virtual Machine image for AML Compute - windows only
        """
        return pulumi.get(self, "virtual_machine_image")

    @virtual_machine_image.setter
    def virtual_machine_image(self, value: Optional[pulumi.Input['VirtualMachineImageArgs']]):
        pulumi.set(self, "virtual_machine_image", value)

    @property
    @pulumi.getter(name="vmPriority")
    def vm_priority(self) -> Optional[pulumi.Input[Union[str, 'VmPriority']]]:
        """
        Virtual Machine priority
        """
        return pulumi.get(self, "vm_priority")

    @vm_priority.setter
    def vm_priority(self, value: Optional[pulumi.Input[Union[str, 'VmPriority']]]):
        pulumi.set(self, "vm_priority", value)

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> Optional[pulumi.Input[str]]:
        """
        Virtual Machine Size
        """
        return pulumi.get(self, "vm_size")

    @vm_size.setter
    def vm_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_size", value)


@pulumi.input_type
class AmlComputeArgs:
    def __init__(__self__, *,
                 compute_type: pulumi.Input[str],
                 compute_location: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disable_local_auth: Optional[pulumi.Input[bool]] = None,
                 properties: Optional[pulumi.Input['AmlComputePropertiesArgs']] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        An Azure Machine Learning compute.
        :param pulumi.Input[str] compute_type: The type of compute
               Expected value is 'AmlCompute'.
        :param pulumi.Input[str] compute_location: Location for the underlying compute
        :param pulumi.Input[str] description: The description of the Machine Learning compute.
        :param pulumi.Input[bool] disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        :param pulumi.Input['AmlComputePropertiesArgs'] properties: Properties of AmlCompute
        :param pulumi.Input[str] resource_id: ARM resource id of the underlying compute
        """
        AmlComputeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_type=compute_type,
            compute_location=compute_location,
            description=description,
            disable_local_auth=disable_local_auth,
            properties=properties,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_type: Optional[pulumi.Input[str]] = None,
             compute_location: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             disable_local_auth: Optional[pulumi.Input[bool]] = None,
             properties: Optional[pulumi.Input['AmlComputePropertiesArgs']] = None,
             resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compute_type is None and 'computeType' in kwargs:
            compute_type = kwargs['computeType']
        if compute_type is None:
            raise TypeError("Missing 'compute_type' argument")
        if compute_location is None and 'computeLocation' in kwargs:
            compute_location = kwargs['computeLocation']
        if disable_local_auth is None and 'disableLocalAuth' in kwargs:
            disable_local_auth = kwargs['disableLocalAuth']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        _setter("compute_type", 'AmlCompute')
        if compute_location is not None:
            _setter("compute_location", compute_location)
        if description is not None:
            _setter("description", description)
        if disable_local_auth is not None:
            _setter("disable_local_auth", disable_local_auth)
        if properties is not None:
            _setter("properties", properties)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> pulumi.Input[str]:
        """
        The type of compute
        Expected value is 'AmlCompute'.
        """
        return pulumi.get(self, "compute_type")

    @compute_type.setter
    def compute_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "compute_type", value)

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[pulumi.Input[str]]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @compute_location.setter
    def compute_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compute_location", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        """
        return pulumi.get(self, "disable_local_auth")

    @disable_local_auth.setter
    def disable_local_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_local_auth", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input['AmlComputePropertiesArgs']]:
        """
        Properties of AmlCompute
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input['AmlComputePropertiesArgs']]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class AssignedUserArgs:
    def __init__(__self__, *,
                 object_id: pulumi.Input[str],
                 tenant_id: pulumi.Input[str]):
        """
        A user that can be assigned to a compute instance.
        :param pulumi.Input[str] object_id: User’s AAD Object Id.
        :param pulumi.Input[str] tenant_id: User’s AAD Tenant Id.
        """
        AssignedUserArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object_id=object_id,
            tenant_id=tenant_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object_id: Optional[pulumi.Input[str]] = None,
             tenant_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object_id is None and 'objectId' in kwargs:
            object_id = kwargs['objectId']
        if object_id is None:
            raise TypeError("Missing 'object_id' argument")
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_id is None:
            raise TypeError("Missing 'tenant_id' argument")

        _setter("object_id", object_id)
        _setter("tenant_id", tenant_id)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> pulumi.Input[str]:
        """
        User’s AAD Object Id.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        User’s AAD Tenant Id.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class AutoPausePropertiesArgs:
    def __init__(__self__, *,
                 delay_in_minutes: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        Auto pause properties
        """
        AutoPausePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delay_in_minutes=delay_in_minutes,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delay_in_minutes: Optional[pulumi.Input[int]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delay_in_minutes is None and 'delayInMinutes' in kwargs:
            delay_in_minutes = kwargs['delayInMinutes']

        if delay_in_minutes is not None:
            _setter("delay_in_minutes", delay_in_minutes)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter(name="delayInMinutes")
    def delay_in_minutes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "delay_in_minutes")

    @delay_in_minutes.setter
    def delay_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "delay_in_minutes", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class AutoScalePropertiesArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 max_node_count: Optional[pulumi.Input[int]] = None,
                 min_node_count: Optional[pulumi.Input[int]] = None):
        """
        Auto scale properties
        """
        AutoScalePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            max_node_count=max_node_count,
            min_node_count=min_node_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             max_node_count: Optional[pulumi.Input[int]] = None,
             min_node_count: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_node_count is None and 'maxNodeCount' in kwargs:
            max_node_count = kwargs['maxNodeCount']
        if min_node_count is None and 'minNodeCount' in kwargs:
            min_node_count = kwargs['minNodeCount']

        if enabled is not None:
            _setter("enabled", enabled)
        if max_node_count is not None:
            _setter("max_node_count", max_node_count)
        if min_node_count is not None:
            _setter("min_node_count", min_node_count)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_node_count")

    @max_node_count.setter
    def max_node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_node_count", value)

    @property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_node_count")

    @min_node_count.setter
    def min_node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_node_count", value)


@pulumi.input_type
class ComputeInstancePropertiesArgs:
    def __init__(__self__, *,
                 application_sharing_policy: Optional[pulumi.Input[Union[str, 'ApplicationSharingPolicy']]] = None,
                 compute_instance_authorization_type: Optional[pulumi.Input[Union[str, 'ComputeInstanceAuthorizationType']]] = None,
                 personal_compute_instance_settings: Optional[pulumi.Input['PersonalComputeInstanceSettingsArgs']] = None,
                 setup_scripts: Optional[pulumi.Input['SetupScriptsArgs']] = None,
                 ssh_settings: Optional[pulumi.Input['ComputeInstanceSshSettingsArgs']] = None,
                 subnet: Optional[pulumi.Input['ResourceIdArgs']] = None,
                 vm_size: Optional[pulumi.Input[str]] = None):
        """
        Compute Instance properties
        :param pulumi.Input[Union[str, 'ApplicationSharingPolicy']] application_sharing_policy: Policy for sharing applications on this compute instance among users of parent workspace. If Personal, only the creator can access applications on this compute instance. When Shared, any workspace user can access applications on this instance depending on his/her assigned role.
        :param pulumi.Input[Union[str, 'ComputeInstanceAuthorizationType']] compute_instance_authorization_type: The Compute Instance Authorization type. Available values are personal (default).
        :param pulumi.Input['PersonalComputeInstanceSettingsArgs'] personal_compute_instance_settings: Settings for a personal compute instance.
        :param pulumi.Input['SetupScriptsArgs'] setup_scripts: Details of customized scripts to execute for setting up the cluster.
        :param pulumi.Input['ComputeInstanceSshSettingsArgs'] ssh_settings: Specifies policy and settings for SSH access.
        :param pulumi.Input['ResourceIdArgs'] subnet: Virtual network subnet resource ID the compute nodes belong to.
        :param pulumi.Input[str] vm_size: Virtual Machine Size
        """
        ComputeInstancePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_sharing_policy=application_sharing_policy,
            compute_instance_authorization_type=compute_instance_authorization_type,
            personal_compute_instance_settings=personal_compute_instance_settings,
            setup_scripts=setup_scripts,
            ssh_settings=ssh_settings,
            subnet=subnet,
            vm_size=vm_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_sharing_policy: Optional[pulumi.Input[Union[str, 'ApplicationSharingPolicy']]] = None,
             compute_instance_authorization_type: Optional[pulumi.Input[Union[str, 'ComputeInstanceAuthorizationType']]] = None,
             personal_compute_instance_settings: Optional[pulumi.Input['PersonalComputeInstanceSettingsArgs']] = None,
             setup_scripts: Optional[pulumi.Input['SetupScriptsArgs']] = None,
             ssh_settings: Optional[pulumi.Input['ComputeInstanceSshSettingsArgs']] = None,
             subnet: Optional[pulumi.Input['ResourceIdArgs']] = None,
             vm_size: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if application_sharing_policy is None and 'applicationSharingPolicy' in kwargs:
            application_sharing_policy = kwargs['applicationSharingPolicy']
        if compute_instance_authorization_type is None and 'computeInstanceAuthorizationType' in kwargs:
            compute_instance_authorization_type = kwargs['computeInstanceAuthorizationType']
        if personal_compute_instance_settings is None and 'personalComputeInstanceSettings' in kwargs:
            personal_compute_instance_settings = kwargs['personalComputeInstanceSettings']
        if setup_scripts is None and 'setupScripts' in kwargs:
            setup_scripts = kwargs['setupScripts']
        if ssh_settings is None and 'sshSettings' in kwargs:
            ssh_settings = kwargs['sshSettings']
        if vm_size is None and 'vmSize' in kwargs:
            vm_size = kwargs['vmSize']

        if application_sharing_policy is None:
            application_sharing_policy = 'Shared'
        if application_sharing_policy is not None:
            _setter("application_sharing_policy", application_sharing_policy)
        if compute_instance_authorization_type is None:
            compute_instance_authorization_type = 'personal'
        if compute_instance_authorization_type is not None:
            _setter("compute_instance_authorization_type", compute_instance_authorization_type)
        if personal_compute_instance_settings is not None:
            _setter("personal_compute_instance_settings", personal_compute_instance_settings)
        if setup_scripts is not None:
            _setter("setup_scripts", setup_scripts)
        if ssh_settings is not None:
            _setter("ssh_settings", ssh_settings)
        if subnet is not None:
            _setter("subnet", subnet)
        if vm_size is not None:
            _setter("vm_size", vm_size)

    @property
    @pulumi.getter(name="applicationSharingPolicy")
    def application_sharing_policy(self) -> Optional[pulumi.Input[Union[str, 'ApplicationSharingPolicy']]]:
        """
        Policy for sharing applications on this compute instance among users of parent workspace. If Personal, only the creator can access applications on this compute instance. When Shared, any workspace user can access applications on this instance depending on his/her assigned role.
        """
        return pulumi.get(self, "application_sharing_policy")

    @application_sharing_policy.setter
    def application_sharing_policy(self, value: Optional[pulumi.Input[Union[str, 'ApplicationSharingPolicy']]]):
        pulumi.set(self, "application_sharing_policy", value)

    @property
    @pulumi.getter(name="computeInstanceAuthorizationType")
    def compute_instance_authorization_type(self) -> Optional[pulumi.Input[Union[str, 'ComputeInstanceAuthorizationType']]]:
        """
        The Compute Instance Authorization type. Available values are personal (default).
        """
        return pulumi.get(self, "compute_instance_authorization_type")

    @compute_instance_authorization_type.setter
    def compute_instance_authorization_type(self, value: Optional[pulumi.Input[Union[str, 'ComputeInstanceAuthorizationType']]]):
        pulumi.set(self, "compute_instance_authorization_type", value)

    @property
    @pulumi.getter(name="personalComputeInstanceSettings")
    def personal_compute_instance_settings(self) -> Optional[pulumi.Input['PersonalComputeInstanceSettingsArgs']]:
        """
        Settings for a personal compute instance.
        """
        return pulumi.get(self, "personal_compute_instance_settings")

    @personal_compute_instance_settings.setter
    def personal_compute_instance_settings(self, value: Optional[pulumi.Input['PersonalComputeInstanceSettingsArgs']]):
        pulumi.set(self, "personal_compute_instance_settings", value)

    @property
    @pulumi.getter(name="setupScripts")
    def setup_scripts(self) -> Optional[pulumi.Input['SetupScriptsArgs']]:
        """
        Details of customized scripts to execute for setting up the cluster.
        """
        return pulumi.get(self, "setup_scripts")

    @setup_scripts.setter
    def setup_scripts(self, value: Optional[pulumi.Input['SetupScriptsArgs']]):
        pulumi.set(self, "setup_scripts", value)

    @property
    @pulumi.getter(name="sshSettings")
    def ssh_settings(self) -> Optional[pulumi.Input['ComputeInstanceSshSettingsArgs']]:
        """
        Specifies policy and settings for SSH access.
        """
        return pulumi.get(self, "ssh_settings")

    @ssh_settings.setter
    def ssh_settings(self, value: Optional[pulumi.Input['ComputeInstanceSshSettingsArgs']]):
        pulumi.set(self, "ssh_settings", value)

    @property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input['ResourceIdArgs']]:
        """
        Virtual network subnet resource ID the compute nodes belong to.
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input['ResourceIdArgs']]):
        pulumi.set(self, "subnet", value)

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> Optional[pulumi.Input[str]]:
        """
        Virtual Machine Size
        """
        return pulumi.get(self, "vm_size")

    @vm_size.setter
    def vm_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_size", value)


@pulumi.input_type
class ComputeInstanceSshSettingsArgs:
    def __init__(__self__, *,
                 admin_public_key: Optional[pulumi.Input[str]] = None,
                 ssh_public_access: Optional[pulumi.Input[Union[str, 'SshPublicAccess']]] = None):
        """
        Specifies policy and settings for SSH access.
        :param pulumi.Input[str] admin_public_key: Specifies the SSH rsa public key file as a string. Use "ssh-keygen -t rsa -b 2048" to generate your SSH key pairs.
        :param pulumi.Input[Union[str, 'SshPublicAccess']] ssh_public_access: State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on this instance. Enabled - Indicates that the public ssh port is open and accessible according to the VNet/subnet policy if applicable.
        """
        ComputeInstanceSshSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_public_key=admin_public_key,
            ssh_public_access=ssh_public_access,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_public_key: Optional[pulumi.Input[str]] = None,
             ssh_public_access: Optional[pulumi.Input[Union[str, 'SshPublicAccess']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if admin_public_key is None and 'adminPublicKey' in kwargs:
            admin_public_key = kwargs['adminPublicKey']
        if ssh_public_access is None and 'sshPublicAccess' in kwargs:
            ssh_public_access = kwargs['sshPublicAccess']

        if admin_public_key is not None:
            _setter("admin_public_key", admin_public_key)
        if ssh_public_access is None:
            ssh_public_access = 'Disabled'
        if ssh_public_access is not None:
            _setter("ssh_public_access", ssh_public_access)

    @property
    @pulumi.getter(name="adminPublicKey")
    def admin_public_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the SSH rsa public key file as a string. Use "ssh-keygen -t rsa -b 2048" to generate your SSH key pairs.
        """
        return pulumi.get(self, "admin_public_key")

    @admin_public_key.setter
    def admin_public_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_public_key", value)

    @property
    @pulumi.getter(name="sshPublicAccess")
    def ssh_public_access(self) -> Optional[pulumi.Input[Union[str, 'SshPublicAccess']]]:
        """
        State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on this instance. Enabled - Indicates that the public ssh port is open and accessible according to the VNet/subnet policy if applicable.
        """
        return pulumi.get(self, "ssh_public_access")

    @ssh_public_access.setter
    def ssh_public_access(self, value: Optional[pulumi.Input[Union[str, 'SshPublicAccess']]]):
        pulumi.set(self, "ssh_public_access", value)


@pulumi.input_type
class ComputeInstanceArgs:
    def __init__(__self__, *,
                 compute_type: pulumi.Input[str],
                 compute_location: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disable_local_auth: Optional[pulumi.Input[bool]] = None,
                 properties: Optional[pulumi.Input['ComputeInstancePropertiesArgs']] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        An Azure Machine Learning compute instance.
        :param pulumi.Input[str] compute_type: The type of compute
               Expected value is 'ComputeInstance'.
        :param pulumi.Input[str] compute_location: Location for the underlying compute
        :param pulumi.Input[str] description: The description of the Machine Learning compute.
        :param pulumi.Input[bool] disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        :param pulumi.Input['ComputeInstancePropertiesArgs'] properties: Properties of ComputeInstance
        :param pulumi.Input[str] resource_id: ARM resource id of the underlying compute
        """
        ComputeInstanceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_type=compute_type,
            compute_location=compute_location,
            description=description,
            disable_local_auth=disable_local_auth,
            properties=properties,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_type: Optional[pulumi.Input[str]] = None,
             compute_location: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             disable_local_auth: Optional[pulumi.Input[bool]] = None,
             properties: Optional[pulumi.Input['ComputeInstancePropertiesArgs']] = None,
             resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compute_type is None and 'computeType' in kwargs:
            compute_type = kwargs['computeType']
        if compute_type is None:
            raise TypeError("Missing 'compute_type' argument")
        if compute_location is None and 'computeLocation' in kwargs:
            compute_location = kwargs['computeLocation']
        if disable_local_auth is None and 'disableLocalAuth' in kwargs:
            disable_local_auth = kwargs['disableLocalAuth']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        _setter("compute_type", 'ComputeInstance')
        if compute_location is not None:
            _setter("compute_location", compute_location)
        if description is not None:
            _setter("description", description)
        if disable_local_auth is not None:
            _setter("disable_local_auth", disable_local_auth)
        if properties is not None:
            _setter("properties", properties)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> pulumi.Input[str]:
        """
        The type of compute
        Expected value is 'ComputeInstance'.
        """
        return pulumi.get(self, "compute_type")

    @compute_type.setter
    def compute_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "compute_type", value)

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[pulumi.Input[str]]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @compute_location.setter
    def compute_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compute_location", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        """
        return pulumi.get(self, "disable_local_auth")

    @disable_local_auth.setter
    def disable_local_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_local_auth", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input['ComputeInstancePropertiesArgs']]:
        """
        Properties of ComputeInstance
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input['ComputeInstancePropertiesArgs']]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class CosmosDbSettingsArgs:
    def __init__(__self__, *,
                 collections_throughput: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] collections_throughput: The throughput of the collections in cosmosdb database
        """
        CosmosDbSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            collections_throughput=collections_throughput,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             collections_throughput: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if collections_throughput is None and 'collectionsThroughput' in kwargs:
            collections_throughput = kwargs['collectionsThroughput']

        if collections_throughput is not None:
            _setter("collections_throughput", collections_throughput)

    @property
    @pulumi.getter(name="collectionsThroughput")
    def collections_throughput(self) -> Optional[pulumi.Input[int]]:
        """
        The throughput of the collections in cosmosdb database
        """
        return pulumi.get(self, "collections_throughput")

    @collections_throughput.setter
    def collections_throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "collections_throughput", value)


@pulumi.input_type
class DataFactoryArgs:
    def __init__(__self__, *,
                 compute_type: pulumi.Input[str],
                 compute_location: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disable_local_auth: Optional[pulumi.Input[bool]] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        A DataFactory compute.
        :param pulumi.Input[str] compute_type: The type of compute
               Expected value is 'DataFactory'.
        :param pulumi.Input[str] compute_location: Location for the underlying compute
        :param pulumi.Input[str] description: The description of the Machine Learning compute.
        :param pulumi.Input[bool] disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        :param pulumi.Input[str] resource_id: ARM resource id of the underlying compute
        """
        DataFactoryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_type=compute_type,
            compute_location=compute_location,
            description=description,
            disable_local_auth=disable_local_auth,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_type: Optional[pulumi.Input[str]] = None,
             compute_location: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             disable_local_auth: Optional[pulumi.Input[bool]] = None,
             resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compute_type is None and 'computeType' in kwargs:
            compute_type = kwargs['computeType']
        if compute_type is None:
            raise TypeError("Missing 'compute_type' argument")
        if compute_location is None and 'computeLocation' in kwargs:
            compute_location = kwargs['computeLocation']
        if disable_local_auth is None and 'disableLocalAuth' in kwargs:
            disable_local_auth = kwargs['disableLocalAuth']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        _setter("compute_type", 'DataFactory')
        if compute_location is not None:
            _setter("compute_location", compute_location)
        if description is not None:
            _setter("description", description)
        if disable_local_auth is not None:
            _setter("disable_local_auth", disable_local_auth)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> pulumi.Input[str]:
        """
        The type of compute
        Expected value is 'DataFactory'.
        """
        return pulumi.get(self, "compute_type")

    @compute_type.setter
    def compute_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "compute_type", value)

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[pulumi.Input[str]]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @compute_location.setter
    def compute_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compute_location", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        """
        return pulumi.get(self, "disable_local_auth")

    @disable_local_auth.setter
    def disable_local_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_local_auth", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class DataLakeAnalyticsPropertiesArgs:
    def __init__(__self__, *,
                 data_lake_store_account_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_lake_store_account_name: DataLake Store Account Name
        """
        DataLakeAnalyticsPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_lake_store_account_name=data_lake_store_account_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_lake_store_account_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_lake_store_account_name is None and 'dataLakeStoreAccountName' in kwargs:
            data_lake_store_account_name = kwargs['dataLakeStoreAccountName']

        if data_lake_store_account_name is not None:
            _setter("data_lake_store_account_name", data_lake_store_account_name)

    @property
    @pulumi.getter(name="dataLakeStoreAccountName")
    def data_lake_store_account_name(self) -> Optional[pulumi.Input[str]]:
        """
        DataLake Store Account Name
        """
        return pulumi.get(self, "data_lake_store_account_name")

    @data_lake_store_account_name.setter
    def data_lake_store_account_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_lake_store_account_name", value)


@pulumi.input_type
class DataLakeAnalyticsArgs:
    def __init__(__self__, *,
                 compute_type: pulumi.Input[str],
                 compute_location: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disable_local_auth: Optional[pulumi.Input[bool]] = None,
                 properties: Optional[pulumi.Input['DataLakeAnalyticsPropertiesArgs']] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        A DataLakeAnalytics compute.
        :param pulumi.Input[str] compute_type: The type of compute
               Expected value is 'DataLakeAnalytics'.
        :param pulumi.Input[str] compute_location: Location for the underlying compute
        :param pulumi.Input[str] description: The description of the Machine Learning compute.
        :param pulumi.Input[bool] disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        :param pulumi.Input[str] resource_id: ARM resource id of the underlying compute
        """
        DataLakeAnalyticsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_type=compute_type,
            compute_location=compute_location,
            description=description,
            disable_local_auth=disable_local_auth,
            properties=properties,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_type: Optional[pulumi.Input[str]] = None,
             compute_location: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             disable_local_auth: Optional[pulumi.Input[bool]] = None,
             properties: Optional[pulumi.Input['DataLakeAnalyticsPropertiesArgs']] = None,
             resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compute_type is None and 'computeType' in kwargs:
            compute_type = kwargs['computeType']
        if compute_type is None:
            raise TypeError("Missing 'compute_type' argument")
        if compute_location is None and 'computeLocation' in kwargs:
            compute_location = kwargs['computeLocation']
        if disable_local_auth is None and 'disableLocalAuth' in kwargs:
            disable_local_auth = kwargs['disableLocalAuth']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        _setter("compute_type", 'DataLakeAnalytics')
        if compute_location is not None:
            _setter("compute_location", compute_location)
        if description is not None:
            _setter("description", description)
        if disable_local_auth is not None:
            _setter("disable_local_auth", disable_local_auth)
        if properties is not None:
            _setter("properties", properties)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> pulumi.Input[str]:
        """
        The type of compute
        Expected value is 'DataLakeAnalytics'.
        """
        return pulumi.get(self, "compute_type")

    @compute_type.setter
    def compute_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "compute_type", value)

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[pulumi.Input[str]]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @compute_location.setter
    def compute_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compute_location", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        """
        return pulumi.get(self, "disable_local_auth")

    @disable_local_auth.setter
    def disable_local_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_local_auth", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input['DataLakeAnalyticsPropertiesArgs']]:
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input['DataLakeAnalyticsPropertiesArgs']]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class DatabricksPropertiesArgs:
    def __init__(__self__, *,
                 databricks_access_token: Optional[pulumi.Input[str]] = None,
                 workspace_url: Optional[pulumi.Input[str]] = None):
        """
        Properties of Databricks
        :param pulumi.Input[str] databricks_access_token: Databricks access token
        :param pulumi.Input[str] workspace_url: Workspace Url
        """
        DatabricksPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            databricks_access_token=databricks_access_token,
            workspace_url=workspace_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             databricks_access_token: Optional[pulumi.Input[str]] = None,
             workspace_url: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if databricks_access_token is None and 'databricksAccessToken' in kwargs:
            databricks_access_token = kwargs['databricksAccessToken']
        if workspace_url is None and 'workspaceUrl' in kwargs:
            workspace_url = kwargs['workspaceUrl']

        if databricks_access_token is not None:
            _setter("databricks_access_token", databricks_access_token)
        if workspace_url is not None:
            _setter("workspace_url", workspace_url)

    @property
    @pulumi.getter(name="databricksAccessToken")
    def databricks_access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Databricks access token
        """
        return pulumi.get(self, "databricks_access_token")

    @databricks_access_token.setter
    def databricks_access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "databricks_access_token", value)

    @property
    @pulumi.getter(name="workspaceUrl")
    def workspace_url(self) -> Optional[pulumi.Input[str]]:
        """
        Workspace Url
        """
        return pulumi.get(self, "workspace_url")

    @workspace_url.setter
    def workspace_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workspace_url", value)


@pulumi.input_type
class DatabricksArgs:
    def __init__(__self__, *,
                 compute_type: pulumi.Input[str],
                 compute_location: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disable_local_auth: Optional[pulumi.Input[bool]] = None,
                 properties: Optional[pulumi.Input['DatabricksPropertiesArgs']] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        A DataFactory compute.
        :param pulumi.Input[str] compute_type: The type of compute
               Expected value is 'Databricks'.
        :param pulumi.Input[str] compute_location: Location for the underlying compute
        :param pulumi.Input[str] description: The description of the Machine Learning compute.
        :param pulumi.Input[bool] disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        :param pulumi.Input['DatabricksPropertiesArgs'] properties: Properties of Databricks
        :param pulumi.Input[str] resource_id: ARM resource id of the underlying compute
        """
        DatabricksArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_type=compute_type,
            compute_location=compute_location,
            description=description,
            disable_local_auth=disable_local_auth,
            properties=properties,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_type: Optional[pulumi.Input[str]] = None,
             compute_location: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             disable_local_auth: Optional[pulumi.Input[bool]] = None,
             properties: Optional[pulumi.Input['DatabricksPropertiesArgs']] = None,
             resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compute_type is None and 'computeType' in kwargs:
            compute_type = kwargs['computeType']
        if compute_type is None:
            raise TypeError("Missing 'compute_type' argument")
        if compute_location is None and 'computeLocation' in kwargs:
            compute_location = kwargs['computeLocation']
        if disable_local_auth is None and 'disableLocalAuth' in kwargs:
            disable_local_auth = kwargs['disableLocalAuth']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        _setter("compute_type", 'Databricks')
        if compute_location is not None:
            _setter("compute_location", compute_location)
        if description is not None:
            _setter("description", description)
        if disable_local_auth is not None:
            _setter("disable_local_auth", disable_local_auth)
        if properties is not None:
            _setter("properties", properties)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> pulumi.Input[str]:
        """
        The type of compute
        Expected value is 'Databricks'.
        """
        return pulumi.get(self, "compute_type")

    @compute_type.setter
    def compute_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "compute_type", value)

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[pulumi.Input[str]]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @compute_location.setter
    def compute_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compute_location", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        """
        return pulumi.get(self, "disable_local_auth")

    @disable_local_auth.setter
    def disable_local_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_local_auth", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input['DatabricksPropertiesArgs']]:
        """
        Properties of Databricks
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input['DatabricksPropertiesArgs']]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class EncryptionPropertyArgs:
    def __init__(__self__, *,
                 key_vault_properties: pulumi.Input['KeyVaultPropertiesArgs'],
                 status: pulumi.Input[Union[str, 'EncryptionStatus']],
                 cosmos_db_resource_id: Optional[pulumi.Input[str]] = None,
                 identity: Optional[pulumi.Input['IdentityForCmkArgs']] = None,
                 search_account_resource_id: Optional[pulumi.Input[str]] = None,
                 storage_account_resource_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['KeyVaultPropertiesArgs'] key_vault_properties: Customer Key vault properties.
        :param pulumi.Input[Union[str, 'EncryptionStatus']] status: Indicates whether or not the encryption is enabled for the workspace.
        :param pulumi.Input[str] cosmos_db_resource_id: The Bring-Your-Own cosmosdb account that customer brings to store data
        :param pulumi.Input['IdentityForCmkArgs'] identity: The identity that will be used to access the key vault for encryption at rest.
        :param pulumi.Input[str] search_account_resource_id: The Bring-Your-Own search account that customer brings to store index
        :param pulumi.Input[str] storage_account_resource_id: The Bring-Your-Own storage account that customer brings to store data
        """
        EncryptionPropertyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key_vault_properties=key_vault_properties,
            status=status,
            cosmos_db_resource_id=cosmos_db_resource_id,
            identity=identity,
            search_account_resource_id=search_account_resource_id,
            storage_account_resource_id=storage_account_resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key_vault_properties: Optional[pulumi.Input['KeyVaultPropertiesArgs']] = None,
             status: Optional[pulumi.Input[Union[str, 'EncryptionStatus']]] = None,
             cosmos_db_resource_id: Optional[pulumi.Input[str]] = None,
             identity: Optional[pulumi.Input['IdentityForCmkArgs']] = None,
             search_account_resource_id: Optional[pulumi.Input[str]] = None,
             storage_account_resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key_vault_properties is None and 'keyVaultProperties' in kwargs:
            key_vault_properties = kwargs['keyVaultProperties']
        if key_vault_properties is None:
            raise TypeError("Missing 'key_vault_properties' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if cosmos_db_resource_id is None and 'cosmosDbResourceId' in kwargs:
            cosmos_db_resource_id = kwargs['cosmosDbResourceId']
        if search_account_resource_id is None and 'searchAccountResourceId' in kwargs:
            search_account_resource_id = kwargs['searchAccountResourceId']
        if storage_account_resource_id is None and 'storageAccountResourceId' in kwargs:
            storage_account_resource_id = kwargs['storageAccountResourceId']

        _setter("key_vault_properties", key_vault_properties)
        _setter("status", status)
        if cosmos_db_resource_id is not None:
            _setter("cosmos_db_resource_id", cosmos_db_resource_id)
        if identity is not None:
            _setter("identity", identity)
        if search_account_resource_id is not None:
            _setter("search_account_resource_id", search_account_resource_id)
        if storage_account_resource_id is not None:
            _setter("storage_account_resource_id", storage_account_resource_id)

    @property
    @pulumi.getter(name="keyVaultProperties")
    def key_vault_properties(self) -> pulumi.Input['KeyVaultPropertiesArgs']:
        """
        Customer Key vault properties.
        """
        return pulumi.get(self, "key_vault_properties")

    @key_vault_properties.setter
    def key_vault_properties(self, value: pulumi.Input['KeyVaultPropertiesArgs']):
        pulumi.set(self, "key_vault_properties", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[Union[str, 'EncryptionStatus']]:
        """
        Indicates whether or not the encryption is enabled for the workspace.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[Union[str, 'EncryptionStatus']]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="cosmosDbResourceId")
    def cosmos_db_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Bring-Your-Own cosmosdb account that customer brings to store data
        """
        return pulumi.get(self, "cosmos_db_resource_id")

    @cosmos_db_resource_id.setter
    def cosmos_db_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cosmos_db_resource_id", value)

    @property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input['IdentityForCmkArgs']]:
        """
        The identity that will be used to access the key vault for encryption at rest.
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input['IdentityForCmkArgs']]):
        pulumi.set(self, "identity", value)

    @property
    @pulumi.getter(name="searchAccountResourceId")
    def search_account_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Bring-Your-Own search account that customer brings to store index
        """
        return pulumi.get(self, "search_account_resource_id")

    @search_account_resource_id.setter
    def search_account_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_account_resource_id", value)

    @property
    @pulumi.getter(name="storageAccountResourceId")
    def storage_account_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Bring-Your-Own storage account that customer brings to store data
        """
        return pulumi.get(self, "storage_account_resource_id")

    @storage_account_resource_id.setter
    def storage_account_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_resource_id", value)


@pulumi.input_type
class HDInsightPropertiesArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 administrator_account: Optional[pulumi.Input['VirtualMachineSshCredentialsArgs']] = None,
                 ssh_port: Optional[pulumi.Input[int]] = None):
        """
        HDInsight compute properties
        :param pulumi.Input[str] address: Public IP address of the master node of the cluster.
        :param pulumi.Input['VirtualMachineSshCredentialsArgs'] administrator_account: Admin credentials for master node of the cluster
        :param pulumi.Input[int] ssh_port: Port open for ssh connections on the master node of the cluster.
        """
        HDInsightPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            administrator_account=administrator_account,
            ssh_port=ssh_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[pulumi.Input[str]] = None,
             administrator_account: Optional[pulumi.Input['VirtualMachineSshCredentialsArgs']] = None,
             ssh_port: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if administrator_account is None and 'administratorAccount' in kwargs:
            administrator_account = kwargs['administratorAccount']
        if ssh_port is None and 'sshPort' in kwargs:
            ssh_port = kwargs['sshPort']

        if address is not None:
            _setter("address", address)
        if administrator_account is not None:
            _setter("administrator_account", administrator_account)
        if ssh_port is not None:
            _setter("ssh_port", ssh_port)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        Public IP address of the master node of the cluster.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="administratorAccount")
    def administrator_account(self) -> Optional[pulumi.Input['VirtualMachineSshCredentialsArgs']]:
        """
        Admin credentials for master node of the cluster
        """
        return pulumi.get(self, "administrator_account")

    @administrator_account.setter
    def administrator_account(self, value: Optional[pulumi.Input['VirtualMachineSshCredentialsArgs']]):
        pulumi.set(self, "administrator_account", value)

    @property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port open for ssh connections on the master node of the cluster.
        """
        return pulumi.get(self, "ssh_port")

    @ssh_port.setter
    def ssh_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ssh_port", value)


@pulumi.input_type
class HDInsightArgs:
    def __init__(__self__, *,
                 compute_type: pulumi.Input[str],
                 compute_location: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disable_local_auth: Optional[pulumi.Input[bool]] = None,
                 properties: Optional[pulumi.Input['HDInsightPropertiesArgs']] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        A HDInsight compute.
        :param pulumi.Input[str] compute_type: The type of compute
               Expected value is 'HDInsight'.
        :param pulumi.Input[str] compute_location: Location for the underlying compute
        :param pulumi.Input[str] description: The description of the Machine Learning compute.
        :param pulumi.Input[bool] disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        :param pulumi.Input['HDInsightPropertiesArgs'] properties: HDInsight compute properties
        :param pulumi.Input[str] resource_id: ARM resource id of the underlying compute
        """
        HDInsightArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_type=compute_type,
            compute_location=compute_location,
            description=description,
            disable_local_auth=disable_local_auth,
            properties=properties,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_type: Optional[pulumi.Input[str]] = None,
             compute_location: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             disable_local_auth: Optional[pulumi.Input[bool]] = None,
             properties: Optional[pulumi.Input['HDInsightPropertiesArgs']] = None,
             resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compute_type is None and 'computeType' in kwargs:
            compute_type = kwargs['computeType']
        if compute_type is None:
            raise TypeError("Missing 'compute_type' argument")
        if compute_location is None and 'computeLocation' in kwargs:
            compute_location = kwargs['computeLocation']
        if disable_local_auth is None and 'disableLocalAuth' in kwargs:
            disable_local_auth = kwargs['disableLocalAuth']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        _setter("compute_type", 'HDInsight')
        if compute_location is not None:
            _setter("compute_location", compute_location)
        if description is not None:
            _setter("description", description)
        if disable_local_auth is not None:
            _setter("disable_local_auth", disable_local_auth)
        if properties is not None:
            _setter("properties", properties)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> pulumi.Input[str]:
        """
        The type of compute
        Expected value is 'HDInsight'.
        """
        return pulumi.get(self, "compute_type")

    @compute_type.setter
    def compute_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "compute_type", value)

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[pulumi.Input[str]]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @compute_location.setter
    def compute_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compute_location", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        """
        return pulumi.get(self, "disable_local_auth")

    @disable_local_auth.setter
    def disable_local_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_local_auth", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input['HDInsightPropertiesArgs']]:
        """
        HDInsight compute properties
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input['HDInsightPropertiesArgs']]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class IdentityForCmkArgs:
    def __init__(__self__, *,
                 user_assigned_identity: Optional[pulumi.Input[str]] = None):
        """
        Identity that will be used to access key vault for encryption at rest
        :param pulumi.Input[str] user_assigned_identity: The ArmId of the user assigned identity that will be used to access the customer managed key vault
        """
        IdentityForCmkArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            user_assigned_identity=user_assigned_identity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             user_assigned_identity: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if user_assigned_identity is None and 'userAssignedIdentity' in kwargs:
            user_assigned_identity = kwargs['userAssignedIdentity']

        if user_assigned_identity is not None:
            _setter("user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[pulumi.Input[str]]:
        """
        The ArmId of the user assigned identity that will be used to access the customer managed key vault
        """
        return pulumi.get(self, "user_assigned_identity")

    @user_assigned_identity.setter
    def user_assigned_identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity", value)


@pulumi.input_type
class IdentityArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['ResourceIdentityType']] = None,
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Identity for the resource.
        :param pulumi.Input['ResourceIdentityType'] type: The identity type.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: The user assigned identities associated with the resource.
        """
        IdentityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            user_assigned_identities=user_assigned_identities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input['ResourceIdentityType']] = None,
             user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if user_assigned_identities is None and 'userAssignedIdentities' in kwargs:
            user_assigned_identities = kwargs['userAssignedIdentities']

        if type is not None:
            _setter("type", type)
        if user_assigned_identities is not None:
            _setter("user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['ResourceIdentityType']]:
        """
        The identity type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['ResourceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The user assigned identities associated with the resource.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


@pulumi.input_type
class InstanceTypeSchemaResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Resource requests/limits for this instance type
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] limits: Resource limits for this instance type
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] requests: Resource requests for this instance type
        """
        InstanceTypeSchemaResourcesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            limits=limits,
            requests=requests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             limits: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             requests: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if limits is not None:
            _setter("limits", limits)
        if requests is not None:
            _setter("requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Resource limits for this instance type
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Resource requests for this instance type
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class InstanceTypeSchemaArgs:
    def __init__(__self__, *,
                 node_selector: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 resources: Optional[pulumi.Input['InstanceTypeSchemaResourcesArgs']] = None):
        """
        Instance type schema.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] node_selector: Node Selector
        :param pulumi.Input['InstanceTypeSchemaResourcesArgs'] resources: Resource requests/limits for this instance type
        """
        InstanceTypeSchemaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            node_selector=node_selector,
            resources=resources,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             node_selector: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             resources: Optional[pulumi.Input['InstanceTypeSchemaResourcesArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if node_selector is None and 'nodeSelector' in kwargs:
            node_selector = kwargs['nodeSelector']

        if node_selector is not None:
            _setter("node_selector", node_selector)
        if resources is not None:
            _setter("resources", resources)

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Node Selector
        """
        return pulumi.get(self, "node_selector")

    @node_selector.setter
    def node_selector(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "node_selector", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['InstanceTypeSchemaResourcesArgs']]:
        """
        Resource requests/limits for this instance type
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['InstanceTypeSchemaResourcesArgs']]):
        pulumi.set(self, "resources", value)


@pulumi.input_type
class KeyVaultPropertiesArgs:
    def __init__(__self__, *,
                 key_identifier: pulumi.Input[str],
                 key_vault_arm_id: pulumi.Input[str],
                 identity_client_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key_identifier: Key vault uri to access the encryption key.
        :param pulumi.Input[str] key_vault_arm_id: The ArmId of the keyVault where the customer owned encryption key is present.
        :param pulumi.Input[str] identity_client_id: For future use - The client id of the identity which will be used to access key vault.
        """
        KeyVaultPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key_identifier=key_identifier,
            key_vault_arm_id=key_vault_arm_id,
            identity_client_id=identity_client_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key_identifier: Optional[pulumi.Input[str]] = None,
             key_vault_arm_id: Optional[pulumi.Input[str]] = None,
             identity_client_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key_identifier is None and 'keyIdentifier' in kwargs:
            key_identifier = kwargs['keyIdentifier']
        if key_identifier is None:
            raise TypeError("Missing 'key_identifier' argument")
        if key_vault_arm_id is None and 'keyVaultArmId' in kwargs:
            key_vault_arm_id = kwargs['keyVaultArmId']
        if key_vault_arm_id is None:
            raise TypeError("Missing 'key_vault_arm_id' argument")
        if identity_client_id is None and 'identityClientId' in kwargs:
            identity_client_id = kwargs['identityClientId']

        _setter("key_identifier", key_identifier)
        _setter("key_vault_arm_id", key_vault_arm_id)
        if identity_client_id is not None:
            _setter("identity_client_id", identity_client_id)

    @property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> pulumi.Input[str]:
        """
        Key vault uri to access the encryption key.
        """
        return pulumi.get(self, "key_identifier")

    @key_identifier.setter
    def key_identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_identifier", value)

    @property
    @pulumi.getter(name="keyVaultArmId")
    def key_vault_arm_id(self) -> pulumi.Input[str]:
        """
        The ArmId of the keyVault where the customer owned encryption key is present.
        """
        return pulumi.get(self, "key_vault_arm_id")

    @key_vault_arm_id.setter
    def key_vault_arm_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_arm_id", value)

    @property
    @pulumi.getter(name="identityClientId")
    def identity_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        For future use - The client id of the identity which will be used to access key vault.
        """
        return pulumi.get(self, "identity_client_id")

    @identity_client_id.setter
    def identity_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_client_id", value)


@pulumi.input_type
class KubernetesPropertiesArgs:
    def __init__(__self__, *,
                 default_instance_type: Optional[pulumi.Input[str]] = None,
                 extension_instance_release_train: Optional[pulumi.Input[str]] = None,
                 extension_principal_id: Optional[pulumi.Input[str]] = None,
                 instance_types: Optional[pulumi.Input[Mapping[str, pulumi.Input['InstanceTypeSchemaArgs']]]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 relay_connection_string: Optional[pulumi.Input[str]] = None,
                 service_bus_connection_string: Optional[pulumi.Input[str]] = None,
                 vc_name: Optional[pulumi.Input[str]] = None):
        """
        Kubernetes properties
        :param pulumi.Input[str] default_instance_type: Default instance type
        :param pulumi.Input[str] extension_instance_release_train: Extension instance release train.
        :param pulumi.Input[str] extension_principal_id: Extension principal-id.
        :param pulumi.Input[Mapping[str, pulumi.Input['InstanceTypeSchemaArgs']]] instance_types: Instance Type Schema
        :param pulumi.Input[str] namespace: Compute namespace
        :param pulumi.Input[str] relay_connection_string: Relay connection string.
        :param pulumi.Input[str] service_bus_connection_string: ServiceBus connection string.
        :param pulumi.Input[str] vc_name: VC name.
        """
        KubernetesPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_instance_type=default_instance_type,
            extension_instance_release_train=extension_instance_release_train,
            extension_principal_id=extension_principal_id,
            instance_types=instance_types,
            namespace=namespace,
            relay_connection_string=relay_connection_string,
            service_bus_connection_string=service_bus_connection_string,
            vc_name=vc_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_instance_type: Optional[pulumi.Input[str]] = None,
             extension_instance_release_train: Optional[pulumi.Input[str]] = None,
             extension_principal_id: Optional[pulumi.Input[str]] = None,
             instance_types: Optional[pulumi.Input[Mapping[str, pulumi.Input['InstanceTypeSchemaArgs']]]] = None,
             namespace: Optional[pulumi.Input[str]] = None,
             relay_connection_string: Optional[pulumi.Input[str]] = None,
             service_bus_connection_string: Optional[pulumi.Input[str]] = None,
             vc_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_instance_type is None and 'defaultInstanceType' in kwargs:
            default_instance_type = kwargs['defaultInstanceType']
        if extension_instance_release_train is None and 'extensionInstanceReleaseTrain' in kwargs:
            extension_instance_release_train = kwargs['extensionInstanceReleaseTrain']
        if extension_principal_id is None and 'extensionPrincipalId' in kwargs:
            extension_principal_id = kwargs['extensionPrincipalId']
        if instance_types is None and 'instanceTypes' in kwargs:
            instance_types = kwargs['instanceTypes']
        if relay_connection_string is None and 'relayConnectionString' in kwargs:
            relay_connection_string = kwargs['relayConnectionString']
        if service_bus_connection_string is None and 'serviceBusConnectionString' in kwargs:
            service_bus_connection_string = kwargs['serviceBusConnectionString']
        if vc_name is None and 'vcName' in kwargs:
            vc_name = kwargs['vcName']

        if default_instance_type is not None:
            _setter("default_instance_type", default_instance_type)
        if extension_instance_release_train is not None:
            _setter("extension_instance_release_train", extension_instance_release_train)
        if extension_principal_id is not None:
            _setter("extension_principal_id", extension_principal_id)
        if instance_types is not None:
            _setter("instance_types", instance_types)
        if namespace is None:
            namespace = 'default'
        if namespace is not None:
            _setter("namespace", namespace)
        if relay_connection_string is not None:
            _setter("relay_connection_string", relay_connection_string)
        if service_bus_connection_string is not None:
            _setter("service_bus_connection_string", service_bus_connection_string)
        if vc_name is not None:
            _setter("vc_name", vc_name)

    @property
    @pulumi.getter(name="defaultInstanceType")
    def default_instance_type(self) -> Optional[pulumi.Input[str]]:
        """
        Default instance type
        """
        return pulumi.get(self, "default_instance_type")

    @default_instance_type.setter
    def default_instance_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_instance_type", value)

    @property
    @pulumi.getter(name="extensionInstanceReleaseTrain")
    def extension_instance_release_train(self) -> Optional[pulumi.Input[str]]:
        """
        Extension instance release train.
        """
        return pulumi.get(self, "extension_instance_release_train")

    @extension_instance_release_train.setter
    def extension_instance_release_train(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "extension_instance_release_train", value)

    @property
    @pulumi.getter(name="extensionPrincipalId")
    def extension_principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        Extension principal-id.
        """
        return pulumi.get(self, "extension_principal_id")

    @extension_principal_id.setter
    def extension_principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "extension_principal_id", value)

    @property
    @pulumi.getter(name="instanceTypes")
    def instance_types(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['InstanceTypeSchemaArgs']]]]:
        """
        Instance Type Schema
        """
        return pulumi.get(self, "instance_types")

    @instance_types.setter
    def instance_types(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['InstanceTypeSchemaArgs']]]]):
        pulumi.set(self, "instance_types", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Compute namespace
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="relayConnectionString")
    def relay_connection_string(self) -> Optional[pulumi.Input[str]]:
        """
        Relay connection string.
        """
        return pulumi.get(self, "relay_connection_string")

    @relay_connection_string.setter
    def relay_connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relay_connection_string", value)

    @property
    @pulumi.getter(name="serviceBusConnectionString")
    def service_bus_connection_string(self) -> Optional[pulumi.Input[str]]:
        """
        ServiceBus connection string.
        """
        return pulumi.get(self, "service_bus_connection_string")

    @service_bus_connection_string.setter
    def service_bus_connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_bus_connection_string", value)

    @property
    @pulumi.getter(name="vcName")
    def vc_name(self) -> Optional[pulumi.Input[str]]:
        """
        VC name.
        """
        return pulumi.get(self, "vc_name")

    @vc_name.setter
    def vc_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vc_name", value)


@pulumi.input_type
class KubernetesArgs:
    def __init__(__self__, *,
                 compute_type: pulumi.Input[str],
                 compute_location: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disable_local_auth: Optional[pulumi.Input[bool]] = None,
                 properties: Optional[pulumi.Input['KubernetesPropertiesArgs']] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        A Machine Learning compute based on Kubernetes Compute.
        :param pulumi.Input[str] compute_type: The type of compute
               Expected value is 'Kubernetes'.
        :param pulumi.Input[str] compute_location: Location for the underlying compute
        :param pulumi.Input[str] description: The description of the Machine Learning compute.
        :param pulumi.Input[bool] disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        :param pulumi.Input['KubernetesPropertiesArgs'] properties: Properties of Kubernetes
        :param pulumi.Input[str] resource_id: ARM resource id of the underlying compute
        """
        KubernetesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_type=compute_type,
            compute_location=compute_location,
            description=description,
            disable_local_auth=disable_local_auth,
            properties=properties,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_type: Optional[pulumi.Input[str]] = None,
             compute_location: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             disable_local_auth: Optional[pulumi.Input[bool]] = None,
             properties: Optional[pulumi.Input['KubernetesPropertiesArgs']] = None,
             resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compute_type is None and 'computeType' in kwargs:
            compute_type = kwargs['computeType']
        if compute_type is None:
            raise TypeError("Missing 'compute_type' argument")
        if compute_location is None and 'computeLocation' in kwargs:
            compute_location = kwargs['computeLocation']
        if disable_local_auth is None and 'disableLocalAuth' in kwargs:
            disable_local_auth = kwargs['disableLocalAuth']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        _setter("compute_type", 'Kubernetes')
        if compute_location is not None:
            _setter("compute_location", compute_location)
        if description is not None:
            _setter("description", description)
        if disable_local_auth is not None:
            _setter("disable_local_auth", disable_local_auth)
        if properties is not None:
            _setter("properties", properties)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> pulumi.Input[str]:
        """
        The type of compute
        Expected value is 'Kubernetes'.
        """
        return pulumi.get(self, "compute_type")

    @compute_type.setter
    def compute_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "compute_type", value)

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[pulumi.Input[str]]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @compute_location.setter
    def compute_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compute_location", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        """
        return pulumi.get(self, "disable_local_auth")

    @disable_local_auth.setter
    def disable_local_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_local_auth", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input['KubernetesPropertiesArgs']]:
        """
        Properties of Kubernetes
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input['KubernetesPropertiesArgs']]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class PersonalComputeInstanceSettingsArgs:
    def __init__(__self__, *,
                 assigned_user: Optional[pulumi.Input['AssignedUserArgs']] = None):
        """
        Settings for a personal compute instance.
        :param pulumi.Input['AssignedUserArgs'] assigned_user: A user explicitly assigned to a personal compute instance.
        """
        PersonalComputeInstanceSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            assigned_user=assigned_user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             assigned_user: Optional[pulumi.Input['AssignedUserArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if assigned_user is None and 'assignedUser' in kwargs:
            assigned_user = kwargs['assignedUser']

        if assigned_user is not None:
            _setter("assigned_user", assigned_user)

    @property
    @pulumi.getter(name="assignedUser")
    def assigned_user(self) -> Optional[pulumi.Input['AssignedUserArgs']]:
        """
        A user explicitly assigned to a personal compute instance.
        """
        return pulumi.get(self, "assigned_user")

    @assigned_user.setter
    def assigned_user(self, value: Optional[pulumi.Input['AssignedUserArgs']]):
        pulumi.set(self, "assigned_user", value)


@pulumi.input_type
class PrivateLinkServiceConnectionStateArgs:
    def __init__(__self__, *,
                 actions_required: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[Union[str, 'PrivateEndpointServiceConnectionStatus']]] = None):
        """
        A collection of information about the state of the connection between service consumer and provider.
        :param pulumi.Input[str] actions_required: A message indicating if changes on the service provider require any updates on the consumer.
        :param pulumi.Input[str] description: The reason for approval/rejection of the connection.
        :param pulumi.Input[Union[str, 'PrivateEndpointServiceConnectionStatus']] status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        PrivateLinkServiceConnectionStateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions_required=actions_required,
            description=description,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions_required: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             status: Optional[pulumi.Input[Union[str, 'PrivateEndpointServiceConnectionStatus']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions_required is None and 'actionsRequired' in kwargs:
            actions_required = kwargs['actionsRequired']

        if actions_required is not None:
            _setter("actions_required", actions_required)
        if description is not None:
            _setter("description", description)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[pulumi.Input[str]]:
        """
        A message indicating if changes on the service provider require any updates on the consumer.
        """
        return pulumi.get(self, "actions_required")

    @actions_required.setter
    def actions_required(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "actions_required", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The reason for approval/rejection of the connection.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[str, 'PrivateEndpointServiceConnectionStatus']]]:
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[str, 'PrivateEndpointServiceConnectionStatus']]]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class ResourceIdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        Represents a resource ID. For example, for a subnet, it is the resource URL for the subnet.
        :param pulumi.Input[str] id: The ID of the resource
        """
        ResourceIdArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the resource
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class ScaleSettingsArgs:
    def __init__(__self__, *,
                 max_node_count: pulumi.Input[int],
                 min_node_count: Optional[pulumi.Input[int]] = None,
                 node_idle_time_before_scale_down: Optional[pulumi.Input[str]] = None):
        """
        scale settings for AML Compute
        :param pulumi.Input[int] max_node_count: Max number of nodes to use
        :param pulumi.Input[int] min_node_count: Min number of nodes to use
        :param pulumi.Input[str] node_idle_time_before_scale_down: Node Idle Time before scaling down amlCompute. This string needs to be in the RFC Format.
        """
        ScaleSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_node_count=max_node_count,
            min_node_count=min_node_count,
            node_idle_time_before_scale_down=node_idle_time_before_scale_down,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_node_count: Optional[pulumi.Input[int]] = None,
             min_node_count: Optional[pulumi.Input[int]] = None,
             node_idle_time_before_scale_down: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_node_count is None and 'maxNodeCount' in kwargs:
            max_node_count = kwargs['maxNodeCount']
        if max_node_count is None:
            raise TypeError("Missing 'max_node_count' argument")
        if min_node_count is None and 'minNodeCount' in kwargs:
            min_node_count = kwargs['minNodeCount']
        if node_idle_time_before_scale_down is None and 'nodeIdleTimeBeforeScaleDown' in kwargs:
            node_idle_time_before_scale_down = kwargs['nodeIdleTimeBeforeScaleDown']

        _setter("max_node_count", max_node_count)
        if min_node_count is None:
            min_node_count = 0
        if min_node_count is not None:
            _setter("min_node_count", min_node_count)
        if node_idle_time_before_scale_down is not None:
            _setter("node_idle_time_before_scale_down", node_idle_time_before_scale_down)

    @property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> pulumi.Input[int]:
        """
        Max number of nodes to use
        """
        return pulumi.get(self, "max_node_count")

    @max_node_count.setter
    def max_node_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_node_count", value)

    @property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> Optional[pulumi.Input[int]]:
        """
        Min number of nodes to use
        """
        return pulumi.get(self, "min_node_count")

    @min_node_count.setter
    def min_node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_node_count", value)

    @property
    @pulumi.getter(name="nodeIdleTimeBeforeScaleDown")
    def node_idle_time_before_scale_down(self) -> Optional[pulumi.Input[str]]:
        """
        Node Idle Time before scaling down amlCompute. This string needs to be in the RFC Format.
        """
        return pulumi.get(self, "node_idle_time_before_scale_down")

    @node_idle_time_before_scale_down.setter
    def node_idle_time_before_scale_down(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_idle_time_before_scale_down", value)


@pulumi.input_type
class ScriptReferenceArgs:
    def __init__(__self__, *,
                 script_arguments: Optional[pulumi.Input[str]] = None,
                 script_data: Optional[pulumi.Input[str]] = None,
                 script_source: Optional[pulumi.Input[str]] = None,
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        Script reference
        :param pulumi.Input[str] script_arguments: Optional command line arguments passed to the script to run.
        :param pulumi.Input[str] script_data: The location of scripts in the mounted volume.
        :param pulumi.Input[str] script_source: The storage source of the script: inline, workspace.
        :param pulumi.Input[str] timeout: Optional time period passed to timeout command.
        """
        ScriptReferenceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            script_arguments=script_arguments,
            script_data=script_data,
            script_source=script_source,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             script_arguments: Optional[pulumi.Input[str]] = None,
             script_data: Optional[pulumi.Input[str]] = None,
             script_source: Optional[pulumi.Input[str]] = None,
             timeout: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if script_arguments is None and 'scriptArguments' in kwargs:
            script_arguments = kwargs['scriptArguments']
        if script_data is None and 'scriptData' in kwargs:
            script_data = kwargs['scriptData']
        if script_source is None and 'scriptSource' in kwargs:
            script_source = kwargs['scriptSource']

        if script_arguments is not None:
            _setter("script_arguments", script_arguments)
        if script_data is not None:
            _setter("script_data", script_data)
        if script_source is not None:
            _setter("script_source", script_source)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter(name="scriptArguments")
    def script_arguments(self) -> Optional[pulumi.Input[str]]:
        """
        Optional command line arguments passed to the script to run.
        """
        return pulumi.get(self, "script_arguments")

    @script_arguments.setter
    def script_arguments(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "script_arguments", value)

    @property
    @pulumi.getter(name="scriptData")
    def script_data(self) -> Optional[pulumi.Input[str]]:
        """
        The location of scripts in the mounted volume.
        """
        return pulumi.get(self, "script_data")

    @script_data.setter
    def script_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "script_data", value)

    @property
    @pulumi.getter(name="scriptSource")
    def script_source(self) -> Optional[pulumi.Input[str]]:
        """
        The storage source of the script: inline, workspace.
        """
        return pulumi.get(self, "script_source")

    @script_source.setter
    def script_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "script_source", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Optional time period passed to timeout command.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class ScriptsToExecuteArgs:
    def __init__(__self__, *,
                 creation_script: Optional[pulumi.Input['ScriptReferenceArgs']] = None,
                 startup_script: Optional[pulumi.Input['ScriptReferenceArgs']] = None):
        """
        Customized setup scripts
        :param pulumi.Input['ScriptReferenceArgs'] creation_script: Script that's run only once during provision of the compute.
        :param pulumi.Input['ScriptReferenceArgs'] startup_script: Script that's run every time the machine starts.
        """
        ScriptsToExecuteArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            creation_script=creation_script,
            startup_script=startup_script,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             creation_script: Optional[pulumi.Input['ScriptReferenceArgs']] = None,
             startup_script: Optional[pulumi.Input['ScriptReferenceArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if creation_script is None and 'creationScript' in kwargs:
            creation_script = kwargs['creationScript']
        if startup_script is None and 'startupScript' in kwargs:
            startup_script = kwargs['startupScript']

        if creation_script is not None:
            _setter("creation_script", creation_script)
        if startup_script is not None:
            _setter("startup_script", startup_script)

    @property
    @pulumi.getter(name="creationScript")
    def creation_script(self) -> Optional[pulumi.Input['ScriptReferenceArgs']]:
        """
        Script that's run only once during provision of the compute.
        """
        return pulumi.get(self, "creation_script")

    @creation_script.setter
    def creation_script(self, value: Optional[pulumi.Input['ScriptReferenceArgs']]):
        pulumi.set(self, "creation_script", value)

    @property
    @pulumi.getter(name="startupScript")
    def startup_script(self) -> Optional[pulumi.Input['ScriptReferenceArgs']]:
        """
        Script that's run every time the machine starts.
        """
        return pulumi.get(self, "startup_script")

    @startup_script.setter
    def startup_script(self, value: Optional[pulumi.Input['ScriptReferenceArgs']]):
        pulumi.set(self, "startup_script", value)


@pulumi.input_type
class ServiceManagedResourcesSettingsArgs:
    def __init__(__self__, *,
                 cosmos_db: Optional[pulumi.Input['CosmosDbSettingsArgs']] = None):
        """
        :param pulumi.Input['CosmosDbSettingsArgs'] cosmos_db: The settings for the service managed cosmosdb account.
        """
        ServiceManagedResourcesSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cosmos_db=cosmos_db,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cosmos_db: Optional[pulumi.Input['CosmosDbSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cosmos_db is None and 'cosmosDb' in kwargs:
            cosmos_db = kwargs['cosmosDb']

        if cosmos_db is not None:
            _setter("cosmos_db", cosmos_db)

    @property
    @pulumi.getter(name="cosmosDb")
    def cosmos_db(self) -> Optional[pulumi.Input['CosmosDbSettingsArgs']]:
        """
        The settings for the service managed cosmosdb account.
        """
        return pulumi.get(self, "cosmos_db")

    @cosmos_db.setter
    def cosmos_db(self, value: Optional[pulumi.Input['CosmosDbSettingsArgs']]):
        pulumi.set(self, "cosmos_db", value)


@pulumi.input_type
class SetupScriptsArgs:
    def __init__(__self__, *,
                 scripts: Optional[pulumi.Input['ScriptsToExecuteArgs']] = None):
        """
        Details of customized scripts to execute for setting up the cluster.
        :param pulumi.Input['ScriptsToExecuteArgs'] scripts: Customized setup scripts
        """
        SetupScriptsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scripts=scripts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scripts: Optional[pulumi.Input['ScriptsToExecuteArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if scripts is not None:
            _setter("scripts", scripts)

    @property
    @pulumi.getter
    def scripts(self) -> Optional[pulumi.Input['ScriptsToExecuteArgs']]:
        """
        Customized setup scripts
        """
        return pulumi.get(self, "scripts")

    @scripts.setter
    def scripts(self, value: Optional[pulumi.Input['ScriptsToExecuteArgs']]):
        pulumi.set(self, "scripts", value)


@pulumi.input_type
class SharedPrivateLinkResourceArgs:
    def __init__(__self__, *,
                 group_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 private_link_resource_id: Optional[pulumi.Input[str]] = None,
                 request_message: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[Union[str, 'PrivateEndpointServiceConnectionStatus']]] = None):
        """
        :param pulumi.Input[str] group_id: The private link resource group id.
        :param pulumi.Input[str] name: Unique name of the private link.
        :param pulumi.Input[str] private_link_resource_id: The resource id that private link links to.
        :param pulumi.Input[str] request_message: Request message.
        :param pulumi.Input[Union[str, 'PrivateEndpointServiceConnectionStatus']] status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        SharedPrivateLinkResourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_id=group_id,
            name=name,
            private_link_resource_id=private_link_resource_id,
            request_message=request_message,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             private_link_resource_id: Optional[pulumi.Input[str]] = None,
             request_message: Optional[pulumi.Input[str]] = None,
             status: Optional[pulumi.Input[Union[str, 'PrivateEndpointServiceConnectionStatus']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if group_id is None and 'groupId' in kwargs:
            group_id = kwargs['groupId']
        if private_link_resource_id is None and 'privateLinkResourceId' in kwargs:
            private_link_resource_id = kwargs['privateLinkResourceId']
        if request_message is None and 'requestMessage' in kwargs:
            request_message = kwargs['requestMessage']

        if group_id is not None:
            _setter("group_id", group_id)
        if name is not None:
            _setter("name", name)
        if private_link_resource_id is not None:
            _setter("private_link_resource_id", private_link_resource_id)
        if request_message is not None:
            _setter("request_message", request_message)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The private link resource group id.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the private link.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="privateLinkResourceId")
    def private_link_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource id that private link links to.
        """
        return pulumi.get(self, "private_link_resource_id")

    @private_link_resource_id.setter
    def private_link_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_link_resource_id", value)

    @property
    @pulumi.getter(name="requestMessage")
    def request_message(self) -> Optional[pulumi.Input[str]]:
        """
        Request message.
        """
        return pulumi.get(self, "request_message")

    @request_message.setter
    def request_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "request_message", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[str, 'PrivateEndpointServiceConnectionStatus']]]:
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[str, 'PrivateEndpointServiceConnectionStatus']]]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class SkuArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 tier: Optional[pulumi.Input[str]] = None):
        """
        Sku of the resource
        :param pulumi.Input[str] name: Name of the sku
        :param pulumi.Input[str] tier: Tier of the sku like Basic or Enterprise
        """
        SkuArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            tier=tier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             tier: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if tier is not None:
            _setter("tier", tier)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the sku
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input[str]]:
        """
        Tier of the sku like Basic or Enterprise
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tier", value)


@pulumi.input_type
class SslConfigurationArgs:
    def __init__(__self__, *,
                 cert: Optional[pulumi.Input[str]] = None,
                 cname: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 leaf_domain_label: Optional[pulumi.Input[str]] = None,
                 overwrite_existing_domain: Optional[pulumi.Input[bool]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        The ssl configuration for scoring
        :param pulumi.Input[str] cert: Cert data
        :param pulumi.Input[str] cname: CNAME of the cert
        :param pulumi.Input[str] key: Key data
        :param pulumi.Input[str] leaf_domain_label: Leaf domain label of public endpoint
        :param pulumi.Input[bool] overwrite_existing_domain: Indicates whether to overwrite existing domain label.
        :param pulumi.Input[str] status: Enable or disable ssl for scoring
        """
        SslConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cert=cert,
            cname=cname,
            key=key,
            leaf_domain_label=leaf_domain_label,
            overwrite_existing_domain=overwrite_existing_domain,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cert: Optional[pulumi.Input[str]] = None,
             cname: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             leaf_domain_label: Optional[pulumi.Input[str]] = None,
             overwrite_existing_domain: Optional[pulumi.Input[bool]] = None,
             status: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if leaf_domain_label is None and 'leafDomainLabel' in kwargs:
            leaf_domain_label = kwargs['leafDomainLabel']
        if overwrite_existing_domain is None and 'overwriteExistingDomain' in kwargs:
            overwrite_existing_domain = kwargs['overwriteExistingDomain']

        if cert is not None:
            _setter("cert", cert)
        if cname is not None:
            _setter("cname", cname)
        if key is not None:
            _setter("key", key)
        if leaf_domain_label is not None:
            _setter("leaf_domain_label", leaf_domain_label)
        if overwrite_existing_domain is not None:
            _setter("overwrite_existing_domain", overwrite_existing_domain)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter
    def cert(self) -> Optional[pulumi.Input[str]]:
        """
        Cert data
        """
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cert", value)

    @property
    @pulumi.getter
    def cname(self) -> Optional[pulumi.Input[str]]:
        """
        CNAME of the cert
        """
        return pulumi.get(self, "cname")

    @cname.setter
    def cname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cname", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key data
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="leafDomainLabel")
    def leaf_domain_label(self) -> Optional[pulumi.Input[str]]:
        """
        Leaf domain label of public endpoint
        """
        return pulumi.get(self, "leaf_domain_label")

    @leaf_domain_label.setter
    def leaf_domain_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "leaf_domain_label", value)

    @property
    @pulumi.getter(name="overwriteExistingDomain")
    def overwrite_existing_domain(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to overwrite existing domain label.
        """
        return pulumi.get(self, "overwrite_existing_domain")

    @overwrite_existing_domain.setter
    def overwrite_existing_domain(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "overwrite_existing_domain", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Enable or disable ssl for scoring
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class SynapseSparkPropertiesArgs:
    def __init__(__self__, *,
                 auto_pause_properties: Optional[pulumi.Input['AutoPausePropertiesArgs']] = None,
                 auto_scale_properties: Optional[pulumi.Input['AutoScalePropertiesArgs']] = None,
                 node_count: Optional[pulumi.Input[int]] = None,
                 node_size: Optional[pulumi.Input[str]] = None,
                 node_size_family: Optional[pulumi.Input[str]] = None,
                 pool_name: Optional[pulumi.Input[str]] = None,
                 resource_group: Optional[pulumi.Input[str]] = None,
                 spark_version: Optional[pulumi.Input[str]] = None,
                 subscription_id: Optional[pulumi.Input[str]] = None,
                 workspace_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['AutoPausePropertiesArgs'] auto_pause_properties: Auto pause properties.
        :param pulumi.Input['AutoScalePropertiesArgs'] auto_scale_properties: Auto scale properties.
        :param pulumi.Input[int] node_count: The number of compute nodes currently assigned to the compute.
        :param pulumi.Input[str] node_size: Node size.
        :param pulumi.Input[str] node_size_family: Node size family.
        :param pulumi.Input[str] pool_name: Pool name.
        :param pulumi.Input[str] resource_group: Name of the resource group in which workspace is located.
        :param pulumi.Input[str] spark_version: Spark version.
        :param pulumi.Input[str] subscription_id: Azure subscription identifier.
        :param pulumi.Input[str] workspace_name: Name of Azure Machine Learning workspace.
        """
        SynapseSparkPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_pause_properties=auto_pause_properties,
            auto_scale_properties=auto_scale_properties,
            node_count=node_count,
            node_size=node_size,
            node_size_family=node_size_family,
            pool_name=pool_name,
            resource_group=resource_group,
            spark_version=spark_version,
            subscription_id=subscription_id,
            workspace_name=workspace_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_pause_properties: Optional[pulumi.Input['AutoPausePropertiesArgs']] = None,
             auto_scale_properties: Optional[pulumi.Input['AutoScalePropertiesArgs']] = None,
             node_count: Optional[pulumi.Input[int]] = None,
             node_size: Optional[pulumi.Input[str]] = None,
             node_size_family: Optional[pulumi.Input[str]] = None,
             pool_name: Optional[pulumi.Input[str]] = None,
             resource_group: Optional[pulumi.Input[str]] = None,
             spark_version: Optional[pulumi.Input[str]] = None,
             subscription_id: Optional[pulumi.Input[str]] = None,
             workspace_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auto_pause_properties is None and 'autoPauseProperties' in kwargs:
            auto_pause_properties = kwargs['autoPauseProperties']
        if auto_scale_properties is None and 'autoScaleProperties' in kwargs:
            auto_scale_properties = kwargs['autoScaleProperties']
        if node_count is None and 'nodeCount' in kwargs:
            node_count = kwargs['nodeCount']
        if node_size is None and 'nodeSize' in kwargs:
            node_size = kwargs['nodeSize']
        if node_size_family is None and 'nodeSizeFamily' in kwargs:
            node_size_family = kwargs['nodeSizeFamily']
        if pool_name is None and 'poolName' in kwargs:
            pool_name = kwargs['poolName']
        if resource_group is None and 'resourceGroup' in kwargs:
            resource_group = kwargs['resourceGroup']
        if spark_version is None and 'sparkVersion' in kwargs:
            spark_version = kwargs['sparkVersion']
        if subscription_id is None and 'subscriptionId' in kwargs:
            subscription_id = kwargs['subscriptionId']
        if workspace_name is None and 'workspaceName' in kwargs:
            workspace_name = kwargs['workspaceName']

        if auto_pause_properties is not None:
            _setter("auto_pause_properties", auto_pause_properties)
        if auto_scale_properties is not None:
            _setter("auto_scale_properties", auto_scale_properties)
        if node_count is not None:
            _setter("node_count", node_count)
        if node_size is not None:
            _setter("node_size", node_size)
        if node_size_family is not None:
            _setter("node_size_family", node_size_family)
        if pool_name is not None:
            _setter("pool_name", pool_name)
        if resource_group is not None:
            _setter("resource_group", resource_group)
        if spark_version is not None:
            _setter("spark_version", spark_version)
        if subscription_id is not None:
            _setter("subscription_id", subscription_id)
        if workspace_name is not None:
            _setter("workspace_name", workspace_name)

    @property
    @pulumi.getter(name="autoPauseProperties")
    def auto_pause_properties(self) -> Optional[pulumi.Input['AutoPausePropertiesArgs']]:
        """
        Auto pause properties.
        """
        return pulumi.get(self, "auto_pause_properties")

    @auto_pause_properties.setter
    def auto_pause_properties(self, value: Optional[pulumi.Input['AutoPausePropertiesArgs']]):
        pulumi.set(self, "auto_pause_properties", value)

    @property
    @pulumi.getter(name="autoScaleProperties")
    def auto_scale_properties(self) -> Optional[pulumi.Input['AutoScalePropertiesArgs']]:
        """
        Auto scale properties.
        """
        return pulumi.get(self, "auto_scale_properties")

    @auto_scale_properties.setter
    def auto_scale_properties(self, value: Optional[pulumi.Input['AutoScalePropertiesArgs']]):
        pulumi.set(self, "auto_scale_properties", value)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of compute nodes currently assigned to the compute.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_count", value)

    @property
    @pulumi.getter(name="nodeSize")
    def node_size(self) -> Optional[pulumi.Input[str]]:
        """
        Node size.
        """
        return pulumi.get(self, "node_size")

    @node_size.setter
    def node_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_size", value)

    @property
    @pulumi.getter(name="nodeSizeFamily")
    def node_size_family(self) -> Optional[pulumi.Input[str]]:
        """
        Node size family.
        """
        return pulumi.get(self, "node_size_family")

    @node_size_family.setter
    def node_size_family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_size_family", value)

    @property
    @pulumi.getter(name="poolName")
    def pool_name(self) -> Optional[pulumi.Input[str]]:
        """
        Pool name.
        """
        return pulumi.get(self, "pool_name")

    @pool_name.setter
    def pool_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pool_name", value)

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the resource group in which workspace is located.
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_group", value)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> Optional[pulumi.Input[str]]:
        """
        Spark version.
        """
        return pulumi.get(self, "spark_version")

    @spark_version.setter
    def spark_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "spark_version", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[pulumi.Input[str]]:
        """
        Azure subscription identifier.
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter(name="workspaceName")
    def workspace_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of Azure Machine Learning workspace.
        """
        return pulumi.get(self, "workspace_name")

    @workspace_name.setter
    def workspace_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workspace_name", value)


@pulumi.input_type
class SynapseSparkArgs:
    def __init__(__self__, *,
                 compute_type: pulumi.Input[str],
                 compute_location: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disable_local_auth: Optional[pulumi.Input[bool]] = None,
                 properties: Optional[pulumi.Input['SynapseSparkPropertiesArgs']] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        A SynapseSpark compute.
        :param pulumi.Input[str] compute_type: The type of compute
               Expected value is 'SynapseSpark'.
        :param pulumi.Input[str] compute_location: Location for the underlying compute
        :param pulumi.Input[str] description: The description of the Machine Learning compute.
        :param pulumi.Input[bool] disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        :param pulumi.Input[str] resource_id: ARM resource id of the underlying compute
        """
        SynapseSparkArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_type=compute_type,
            compute_location=compute_location,
            description=description,
            disable_local_auth=disable_local_auth,
            properties=properties,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_type: Optional[pulumi.Input[str]] = None,
             compute_location: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             disable_local_auth: Optional[pulumi.Input[bool]] = None,
             properties: Optional[pulumi.Input['SynapseSparkPropertiesArgs']] = None,
             resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compute_type is None and 'computeType' in kwargs:
            compute_type = kwargs['computeType']
        if compute_type is None:
            raise TypeError("Missing 'compute_type' argument")
        if compute_location is None and 'computeLocation' in kwargs:
            compute_location = kwargs['computeLocation']
        if disable_local_auth is None and 'disableLocalAuth' in kwargs:
            disable_local_auth = kwargs['disableLocalAuth']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        _setter("compute_type", 'SynapseSpark')
        if compute_location is not None:
            _setter("compute_location", compute_location)
        if description is not None:
            _setter("description", description)
        if disable_local_auth is not None:
            _setter("disable_local_auth", disable_local_auth)
        if properties is not None:
            _setter("properties", properties)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> pulumi.Input[str]:
        """
        The type of compute
        Expected value is 'SynapseSpark'.
        """
        return pulumi.get(self, "compute_type")

    @compute_type.setter
    def compute_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "compute_type", value)

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[pulumi.Input[str]]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @compute_location.setter
    def compute_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compute_location", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        """
        return pulumi.get(self, "disable_local_auth")

    @disable_local_auth.setter
    def disable_local_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_local_auth", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input['SynapseSparkPropertiesArgs']]:
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input['SynapseSparkPropertiesArgs']]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class UserAccountCredentialsArgs:
    def __init__(__self__, *,
                 admin_user_name: pulumi.Input[str],
                 admin_user_password: Optional[pulumi.Input[str]] = None,
                 admin_user_ssh_public_key: Optional[pulumi.Input[str]] = None):
        """
        Settings for user account that gets created on each on the nodes of a compute.
        :param pulumi.Input[str] admin_user_name: Name of the administrator user account which can be used to SSH to nodes.
        :param pulumi.Input[str] admin_user_password: Password of the administrator user account.
        :param pulumi.Input[str] admin_user_ssh_public_key: SSH public key of the administrator user account.
        """
        UserAccountCredentialsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_user_name=admin_user_name,
            admin_user_password=admin_user_password,
            admin_user_ssh_public_key=admin_user_ssh_public_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_user_name: Optional[pulumi.Input[str]] = None,
             admin_user_password: Optional[pulumi.Input[str]] = None,
             admin_user_ssh_public_key: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if admin_user_name is None and 'adminUserName' in kwargs:
            admin_user_name = kwargs['adminUserName']
        if admin_user_name is None:
            raise TypeError("Missing 'admin_user_name' argument")
        if admin_user_password is None and 'adminUserPassword' in kwargs:
            admin_user_password = kwargs['adminUserPassword']
        if admin_user_ssh_public_key is None and 'adminUserSshPublicKey' in kwargs:
            admin_user_ssh_public_key = kwargs['adminUserSshPublicKey']

        _setter("admin_user_name", admin_user_name)
        if admin_user_password is not None:
            _setter("admin_user_password", admin_user_password)
        if admin_user_ssh_public_key is not None:
            _setter("admin_user_ssh_public_key", admin_user_ssh_public_key)

    @property
    @pulumi.getter(name="adminUserName")
    def admin_user_name(self) -> pulumi.Input[str]:
        """
        Name of the administrator user account which can be used to SSH to nodes.
        """
        return pulumi.get(self, "admin_user_name")

    @admin_user_name.setter
    def admin_user_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_user_name", value)

    @property
    @pulumi.getter(name="adminUserPassword")
    def admin_user_password(self) -> Optional[pulumi.Input[str]]:
        """
        Password of the administrator user account.
        """
        return pulumi.get(self, "admin_user_password")

    @admin_user_password.setter
    def admin_user_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_user_password", value)

    @property
    @pulumi.getter(name="adminUserSshPublicKey")
    def admin_user_ssh_public_key(self) -> Optional[pulumi.Input[str]]:
        """
        SSH public key of the administrator user account.
        """
        return pulumi.get(self, "admin_user_ssh_public_key")

    @admin_user_ssh_public_key.setter
    def admin_user_ssh_public_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_user_ssh_public_key", value)


@pulumi.input_type
class VirtualMachineImageArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        Virtual Machine image for Windows AML Compute
        :param pulumi.Input[str] id: Virtual Machine image path
        """
        VirtualMachineImageArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Virtual Machine image path
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class VirtualMachinePropertiesArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 administrator_account: Optional[pulumi.Input['VirtualMachineSshCredentialsArgs']] = None,
                 is_notebook_instance_compute: Optional[pulumi.Input[bool]] = None,
                 ssh_port: Optional[pulumi.Input[int]] = None,
                 virtual_machine_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: Public IP address of the virtual machine.
        :param pulumi.Input['VirtualMachineSshCredentialsArgs'] administrator_account: Admin credentials for virtual machine
        :param pulumi.Input[bool] is_notebook_instance_compute: Indicates whether this compute will be used for running notebooks.
        :param pulumi.Input[int] ssh_port: Port open for ssh connections.
        :param pulumi.Input[str] virtual_machine_size: Virtual Machine size
        """
        VirtualMachinePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            administrator_account=administrator_account,
            is_notebook_instance_compute=is_notebook_instance_compute,
            ssh_port=ssh_port,
            virtual_machine_size=virtual_machine_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[pulumi.Input[str]] = None,
             administrator_account: Optional[pulumi.Input['VirtualMachineSshCredentialsArgs']] = None,
             is_notebook_instance_compute: Optional[pulumi.Input[bool]] = None,
             ssh_port: Optional[pulumi.Input[int]] = None,
             virtual_machine_size: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if administrator_account is None and 'administratorAccount' in kwargs:
            administrator_account = kwargs['administratorAccount']
        if is_notebook_instance_compute is None and 'isNotebookInstanceCompute' in kwargs:
            is_notebook_instance_compute = kwargs['isNotebookInstanceCompute']
        if ssh_port is None and 'sshPort' in kwargs:
            ssh_port = kwargs['sshPort']
        if virtual_machine_size is None and 'virtualMachineSize' in kwargs:
            virtual_machine_size = kwargs['virtualMachineSize']

        if address is not None:
            _setter("address", address)
        if administrator_account is not None:
            _setter("administrator_account", administrator_account)
        if is_notebook_instance_compute is not None:
            _setter("is_notebook_instance_compute", is_notebook_instance_compute)
        if ssh_port is not None:
            _setter("ssh_port", ssh_port)
        if virtual_machine_size is not None:
            _setter("virtual_machine_size", virtual_machine_size)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        Public IP address of the virtual machine.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="administratorAccount")
    def administrator_account(self) -> Optional[pulumi.Input['VirtualMachineSshCredentialsArgs']]:
        """
        Admin credentials for virtual machine
        """
        return pulumi.get(self, "administrator_account")

    @administrator_account.setter
    def administrator_account(self, value: Optional[pulumi.Input['VirtualMachineSshCredentialsArgs']]):
        pulumi.set(self, "administrator_account", value)

    @property
    @pulumi.getter(name="isNotebookInstanceCompute")
    def is_notebook_instance_compute(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether this compute will be used for running notebooks.
        """
        return pulumi.get(self, "is_notebook_instance_compute")

    @is_notebook_instance_compute.setter
    def is_notebook_instance_compute(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_notebook_instance_compute", value)

    @property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port open for ssh connections.
        """
        return pulumi.get(self, "ssh_port")

    @ssh_port.setter
    def ssh_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ssh_port", value)

    @property
    @pulumi.getter(name="virtualMachineSize")
    def virtual_machine_size(self) -> Optional[pulumi.Input[str]]:
        """
        Virtual Machine size
        """
        return pulumi.get(self, "virtual_machine_size")

    @virtual_machine_size.setter
    def virtual_machine_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_machine_size", value)


@pulumi.input_type
class VirtualMachineSshCredentialsArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[str]] = None,
                 private_key_data: Optional[pulumi.Input[str]] = None,
                 public_key_data: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        Admin credentials for virtual machine
        :param pulumi.Input[str] password: Password of admin account
        :param pulumi.Input[str] private_key_data: Private key data
        :param pulumi.Input[str] public_key_data: Public key data
        :param pulumi.Input[str] username: Username of admin account
        """
        VirtualMachineSshCredentialsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            private_key_data=private_key_data,
            public_key_data=public_key_data,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[pulumi.Input[str]] = None,
             private_key_data: Optional[pulumi.Input[str]] = None,
             public_key_data: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_key_data is None and 'privateKeyData' in kwargs:
            private_key_data = kwargs['privateKeyData']
        if public_key_data is None and 'publicKeyData' in kwargs:
            public_key_data = kwargs['publicKeyData']

        if password is not None:
            _setter("password", password)
        if private_key_data is not None:
            _setter("private_key_data", private_key_data)
        if public_key_data is not None:
            _setter("public_key_data", public_key_data)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password of admin account
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="privateKeyData")
    def private_key_data(self) -> Optional[pulumi.Input[str]]:
        """
        Private key data
        """
        return pulumi.get(self, "private_key_data")

    @private_key_data.setter
    def private_key_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key_data", value)

    @property
    @pulumi.getter(name="publicKeyData")
    def public_key_data(self) -> Optional[pulumi.Input[str]]:
        """
        Public key data
        """
        return pulumi.get(self, "public_key_data")

    @public_key_data.setter
    def public_key_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_key_data", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username of admin account
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class VirtualMachineArgs:
    def __init__(__self__, *,
                 compute_type: pulumi.Input[str],
                 compute_location: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disable_local_auth: Optional[pulumi.Input[bool]] = None,
                 properties: Optional[pulumi.Input['VirtualMachinePropertiesArgs']] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        A Machine Learning compute based on Azure Virtual Machines.
        :param pulumi.Input[str] compute_type: The type of compute
               Expected value is 'VirtualMachine'.
        :param pulumi.Input[str] compute_location: Location for the underlying compute
        :param pulumi.Input[str] description: The description of the Machine Learning compute.
        :param pulumi.Input[bool] disable_local_auth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        :param pulumi.Input[str] resource_id: ARM resource id of the underlying compute
        """
        VirtualMachineArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_type=compute_type,
            compute_location=compute_location,
            description=description,
            disable_local_auth=disable_local_auth,
            properties=properties,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_type: Optional[pulumi.Input[str]] = None,
             compute_location: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             disable_local_auth: Optional[pulumi.Input[bool]] = None,
             properties: Optional[pulumi.Input['VirtualMachinePropertiesArgs']] = None,
             resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compute_type is None and 'computeType' in kwargs:
            compute_type = kwargs['computeType']
        if compute_type is None:
            raise TypeError("Missing 'compute_type' argument")
        if compute_location is None and 'computeLocation' in kwargs:
            compute_location = kwargs['computeLocation']
        if disable_local_auth is None and 'disableLocalAuth' in kwargs:
            disable_local_auth = kwargs['disableLocalAuth']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        _setter("compute_type", 'VirtualMachine')
        if compute_location is not None:
            _setter("compute_location", compute_location)
        if description is not None:
            _setter("description", description)
        if disable_local_auth is not None:
            _setter("disable_local_auth", disable_local_auth)
        if properties is not None:
            _setter("properties", properties)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> pulumi.Input[str]:
        """
        The type of compute
        Expected value is 'VirtualMachine'.
        """
        return pulumi.get(self, "compute_type")

    @compute_type.setter
    def compute_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "compute_type", value)

    @property
    @pulumi.getter(name="computeLocation")
    def compute_location(self) -> Optional[pulumi.Input[str]]:
        """
        Location for the underlying compute
        """
        return pulumi.get(self, "compute_location")

    @compute_location.setter
    def compute_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compute_location", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the Machine Learning compute.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
        """
        return pulumi.get(self, "disable_local_auth")

    @disable_local_auth.setter
    def disable_local_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_local_auth", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input['VirtualMachinePropertiesArgs']]:
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input['VirtualMachinePropertiesArgs']]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM resource id of the underlying compute
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


