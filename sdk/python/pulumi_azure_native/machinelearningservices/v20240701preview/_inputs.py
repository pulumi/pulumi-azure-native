# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'ComputeRuntimeDtoArgs',
    'ComputeRuntimeDtoArgsDict',
    'CosmosDbSettingsArgs',
    'CosmosDbSettingsArgsDict',
    'EncryptionPropertyArgs',
    'EncryptionPropertyArgsDict',
    'FeatureStoreSettingsArgs',
    'FeatureStoreSettingsArgsDict',
    'FqdnOutboundRuleArgs',
    'FqdnOutboundRuleArgsDict',
    'IdentityForCmkArgs',
    'IdentityForCmkArgsDict',
    'KeyVaultPropertiesArgs',
    'KeyVaultPropertiesArgsDict',
    'ManagedNetworkProvisionStatusArgs',
    'ManagedNetworkProvisionStatusArgsDict',
    'ManagedNetworkSettingsArgs',
    'ManagedNetworkSettingsArgsDict',
    'ManagedServiceIdentityArgs',
    'ManagedServiceIdentityArgsDict',
    'PrivateEndpointDestinationArgs',
    'PrivateEndpointDestinationArgsDict',
    'PrivateEndpointOutboundRuleArgs',
    'PrivateEndpointOutboundRuleArgsDict',
    'ServerlessComputeSettingsArgs',
    'ServerlessComputeSettingsArgsDict',
    'ServiceManagedResourcesSettingsArgs',
    'ServiceManagedResourcesSettingsArgsDict',
    'ServiceTagDestinationArgs',
    'ServiceTagDestinationArgsDict',
    'ServiceTagOutboundRuleArgs',
    'ServiceTagOutboundRuleArgsDict',
    'SharedPrivateLinkResourceArgs',
    'SharedPrivateLinkResourceArgsDict',
    'SkuArgs',
    'SkuArgsDict',
    'WorkspaceHubConfigArgs',
    'WorkspaceHubConfigArgsDict',
]

MYPY = False

if not MYPY:
    class ComputeRuntimeDtoArgsDict(TypedDict):
        spark_runtime_version: NotRequired[pulumi.Input[str]]
elif False:
    ComputeRuntimeDtoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeRuntimeDtoArgs:
    def __init__(__self__, *,
                 spark_runtime_version: Optional[pulumi.Input[str]] = None):
        if spark_runtime_version is not None:
            pulumi.set(__self__, "spark_runtime_version", spark_runtime_version)

    @property
    @pulumi.getter(name="sparkRuntimeVersion")
    def spark_runtime_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "spark_runtime_version")

    @spark_runtime_version.setter
    def spark_runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "spark_runtime_version", value)


if not MYPY:
    class CosmosDbSettingsArgsDict(TypedDict):
        collections_throughput: NotRequired[pulumi.Input[int]]
elif False:
    CosmosDbSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CosmosDbSettingsArgs:
    def __init__(__self__, *,
                 collections_throughput: Optional[pulumi.Input[int]] = None):
        if collections_throughput is not None:
            pulumi.set(__self__, "collections_throughput", collections_throughput)

    @property
    @pulumi.getter(name="collectionsThroughput")
    def collections_throughput(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "collections_throughput")

    @collections_throughput.setter
    def collections_throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "collections_throughput", value)


if not MYPY:
    class EncryptionPropertyArgsDict(TypedDict):
        key_vault_properties: pulumi.Input['KeyVaultPropertiesArgsDict']
        """
        KeyVault details to do the encryption
        """
        status: pulumi.Input[Union[str, 'EncryptionStatus']]
        """
        Indicates whether or not the encryption is enabled for the workspace.
        """
        cosmos_db_resource_id: NotRequired[pulumi.Input[str]]
        """
        The byok cosmosdb account that customer brings to store customer's data
        with encryption
        """
        identity: NotRequired[pulumi.Input['IdentityForCmkArgsDict']]
        """
        Identity to be used with the keyVault
        """
        search_account_resource_id: NotRequired[pulumi.Input[str]]
        """
        The byok search account that customer brings to store customer's data
        with encryption
        """
        storage_account_resource_id: NotRequired[pulumi.Input[str]]
        """
        The byok storage account that customer brings to store customer's data
        with encryption
        """
elif False:
    EncryptionPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EncryptionPropertyArgs:
    def __init__(__self__, *,
                 key_vault_properties: pulumi.Input['KeyVaultPropertiesArgs'],
                 status: pulumi.Input[Union[str, 'EncryptionStatus']],
                 cosmos_db_resource_id: Optional[pulumi.Input[str]] = None,
                 identity: Optional[pulumi.Input['IdentityForCmkArgs']] = None,
                 search_account_resource_id: Optional[pulumi.Input[str]] = None,
                 storage_account_resource_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['KeyVaultPropertiesArgs'] key_vault_properties: KeyVault details to do the encryption
        :param pulumi.Input[Union[str, 'EncryptionStatus']] status: Indicates whether or not the encryption is enabled for the workspace.
        :param pulumi.Input[str] cosmos_db_resource_id: The byok cosmosdb account that customer brings to store customer's data
               with encryption
        :param pulumi.Input['IdentityForCmkArgs'] identity: Identity to be used with the keyVault
        :param pulumi.Input[str] search_account_resource_id: The byok search account that customer brings to store customer's data
               with encryption
        :param pulumi.Input[str] storage_account_resource_id: The byok storage account that customer brings to store customer's data
               with encryption
        """
        pulumi.set(__self__, "key_vault_properties", key_vault_properties)
        pulumi.set(__self__, "status", status)
        if cosmos_db_resource_id is not None:
            pulumi.set(__self__, "cosmos_db_resource_id", cosmos_db_resource_id)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if search_account_resource_id is not None:
            pulumi.set(__self__, "search_account_resource_id", search_account_resource_id)
        if storage_account_resource_id is not None:
            pulumi.set(__self__, "storage_account_resource_id", storage_account_resource_id)

    @property
    @pulumi.getter(name="keyVaultProperties")
    def key_vault_properties(self) -> pulumi.Input['KeyVaultPropertiesArgs']:
        """
        KeyVault details to do the encryption
        """
        return pulumi.get(self, "key_vault_properties")

    @key_vault_properties.setter
    def key_vault_properties(self, value: pulumi.Input['KeyVaultPropertiesArgs']):
        pulumi.set(self, "key_vault_properties", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[Union[str, 'EncryptionStatus']]:
        """
        Indicates whether or not the encryption is enabled for the workspace.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[Union[str, 'EncryptionStatus']]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="cosmosDbResourceId")
    def cosmos_db_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The byok cosmosdb account that customer brings to store customer's data
        with encryption
        """
        return pulumi.get(self, "cosmos_db_resource_id")

    @cosmos_db_resource_id.setter
    def cosmos_db_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cosmos_db_resource_id", value)

    @property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input['IdentityForCmkArgs']]:
        """
        Identity to be used with the keyVault
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input['IdentityForCmkArgs']]):
        pulumi.set(self, "identity", value)

    @property
    @pulumi.getter(name="searchAccountResourceId")
    def search_account_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The byok search account that customer brings to store customer's data
        with encryption
        """
        return pulumi.get(self, "search_account_resource_id")

    @search_account_resource_id.setter
    def search_account_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_account_resource_id", value)

    @property
    @pulumi.getter(name="storageAccountResourceId")
    def storage_account_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The byok storage account that customer brings to store customer's data
        with encryption
        """
        return pulumi.get(self, "storage_account_resource_id")

    @storage_account_resource_id.setter
    def storage_account_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_resource_id", value)


if not MYPY:
    class FeatureStoreSettingsArgsDict(TypedDict):
        compute_runtime: NotRequired[pulumi.Input['ComputeRuntimeDtoArgsDict']]
        offline_store_connection_name: NotRequired[pulumi.Input[str]]
        online_store_connection_name: NotRequired[pulumi.Input[str]]
elif False:
    FeatureStoreSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureStoreSettingsArgs:
    def __init__(__self__, *,
                 compute_runtime: Optional[pulumi.Input['ComputeRuntimeDtoArgs']] = None,
                 offline_store_connection_name: Optional[pulumi.Input[str]] = None,
                 online_store_connection_name: Optional[pulumi.Input[str]] = None):
        if compute_runtime is not None:
            pulumi.set(__self__, "compute_runtime", compute_runtime)
        if offline_store_connection_name is not None:
            pulumi.set(__self__, "offline_store_connection_name", offline_store_connection_name)
        if online_store_connection_name is not None:
            pulumi.set(__self__, "online_store_connection_name", online_store_connection_name)

    @property
    @pulumi.getter(name="computeRuntime")
    def compute_runtime(self) -> Optional[pulumi.Input['ComputeRuntimeDtoArgs']]:
        return pulumi.get(self, "compute_runtime")

    @compute_runtime.setter
    def compute_runtime(self, value: Optional[pulumi.Input['ComputeRuntimeDtoArgs']]):
        pulumi.set(self, "compute_runtime", value)

    @property
    @pulumi.getter(name="offlineStoreConnectionName")
    def offline_store_connection_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "offline_store_connection_name")

    @offline_store_connection_name.setter
    def offline_store_connection_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "offline_store_connection_name", value)

    @property
    @pulumi.getter(name="onlineStoreConnectionName")
    def online_store_connection_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "online_store_connection_name")

    @online_store_connection_name.setter
    def online_store_connection_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "online_store_connection_name", value)


if not MYPY:
    class FqdnOutboundRuleArgsDict(TypedDict):
        """
        FQDN Outbound Rule for the managed network of a machine learning workspace.
        """
        type: pulumi.Input[str]
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        Expected value is 'FQDN'.
        """
        category: NotRequired[pulumi.Input[Union[str, 'RuleCategory']]]
        """
        Category of a managed network Outbound Rule of a machine learning workspace.
        """
        destination: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[Union[str, 'RuleStatus']]]
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        """
elif False:
    FqdnOutboundRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FqdnOutboundRuleArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 category: Optional[pulumi.Input[Union[str, 'RuleCategory']]] = None,
                 destination: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[Union[str, 'RuleStatus']]] = None):
        """
        FQDN Outbound Rule for the managed network of a machine learning workspace.
        :param pulumi.Input[str] type: Type of a managed network Outbound Rule of a machine learning workspace.
               Expected value is 'FQDN'.
        :param pulumi.Input[Union[str, 'RuleCategory']] category: Category of a managed network Outbound Rule of a machine learning workspace.
        :param pulumi.Input[Union[str, 'RuleStatus']] status: Type of a managed network Outbound Rule of a machine learning workspace.
        """
        pulumi.set(__self__, "type", 'FQDN')
        if category is not None:
            pulumi.set(__self__, "category", category)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        Expected value is 'FQDN'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[Union[str, 'RuleCategory']]]:
        """
        Category of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[Union[str, 'RuleCategory']]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[str, 'RuleStatus']]]:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[str, 'RuleStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class IdentityForCmkArgsDict(TypedDict):
        """
        Identity object used for encryption.
        """
        user_assigned_identity: NotRequired[pulumi.Input[str]]
        """
        UserAssignedIdentity to be used to fetch the encryption key from keyVault
        """
elif False:
    IdentityForCmkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityForCmkArgs:
    def __init__(__self__, *,
                 user_assigned_identity: Optional[pulumi.Input[str]] = None):
        """
        Identity object used for encryption.
        :param pulumi.Input[str] user_assigned_identity: UserAssignedIdentity to be used to fetch the encryption key from keyVault
        """
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[pulumi.Input[str]]:
        """
        UserAssignedIdentity to be used to fetch the encryption key from keyVault
        """
        return pulumi.get(self, "user_assigned_identity")

    @user_assigned_identity.setter
    def user_assigned_identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity", value)


if not MYPY:
    class KeyVaultPropertiesArgsDict(TypedDict):
        """
        Customer Key vault properties.
        """
        key_identifier: pulumi.Input[str]
        """
        KeyVault key identifier to encrypt the data
        """
        key_vault_arm_id: pulumi.Input[str]
        """
        KeyVault Arm Id that contains the data encryption key
        """
        identity_client_id: NotRequired[pulumi.Input[str]]
        """
        Currently, we support only SystemAssigned MSI.
        We need this when we support UserAssignedIdentities
        """
elif False:
    KeyVaultPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeyVaultPropertiesArgs:
    def __init__(__self__, *,
                 key_identifier: pulumi.Input[str],
                 key_vault_arm_id: pulumi.Input[str],
                 identity_client_id: Optional[pulumi.Input[str]] = None):
        """
        Customer Key vault properties.
        :param pulumi.Input[str] key_identifier: KeyVault key identifier to encrypt the data
        :param pulumi.Input[str] key_vault_arm_id: KeyVault Arm Id that contains the data encryption key
        :param pulumi.Input[str] identity_client_id: Currently, we support only SystemAssigned MSI.
               We need this when we support UserAssignedIdentities
        """
        pulumi.set(__self__, "key_identifier", key_identifier)
        pulumi.set(__self__, "key_vault_arm_id", key_vault_arm_id)
        if identity_client_id is not None:
            pulumi.set(__self__, "identity_client_id", identity_client_id)

    @property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> pulumi.Input[str]:
        """
        KeyVault key identifier to encrypt the data
        """
        return pulumi.get(self, "key_identifier")

    @key_identifier.setter
    def key_identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_identifier", value)

    @property
    @pulumi.getter(name="keyVaultArmId")
    def key_vault_arm_id(self) -> pulumi.Input[str]:
        """
        KeyVault Arm Id that contains the data encryption key
        """
        return pulumi.get(self, "key_vault_arm_id")

    @key_vault_arm_id.setter
    def key_vault_arm_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_arm_id", value)

    @property
    @pulumi.getter(name="identityClientId")
    def identity_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Currently, we support only SystemAssigned MSI.
        We need this when we support UserAssignedIdentities
        """
        return pulumi.get(self, "identity_client_id")

    @identity_client_id.setter
    def identity_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_client_id", value)


if not MYPY:
    class ManagedNetworkProvisionStatusArgsDict(TypedDict):
        """
        Status of the Provisioning for the managed network of a machine learning workspace.
        """
        spark_ready: NotRequired[pulumi.Input[bool]]
        status: NotRequired[pulumi.Input[Union[str, 'ManagedNetworkStatus']]]
        """
        Status for the managed network of a machine learning workspace.
        """
elif False:
    ManagedNetworkProvisionStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedNetworkProvisionStatusArgs:
    def __init__(__self__, *,
                 spark_ready: Optional[pulumi.Input[bool]] = None,
                 status: Optional[pulumi.Input[Union[str, 'ManagedNetworkStatus']]] = None):
        """
        Status of the Provisioning for the managed network of a machine learning workspace.
        :param pulumi.Input[Union[str, 'ManagedNetworkStatus']] status: Status for the managed network of a machine learning workspace.
        """
        if spark_ready is not None:
            pulumi.set(__self__, "spark_ready", spark_ready)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="sparkReady")
    def spark_ready(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "spark_ready")

    @spark_ready.setter
    def spark_ready(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "spark_ready", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[str, 'ManagedNetworkStatus']]]:
        """
        Status for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[str, 'ManagedNetworkStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ManagedNetworkSettingsArgsDict(TypedDict):
        """
        Managed Network settings for a machine learning workspace.
        """
        isolation_mode: NotRequired[pulumi.Input[Union[str, 'IsolationMode']]]
        """
        Isolation mode for the managed network of a machine learning workspace.
        """
        outbound_rules: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Union['FqdnOutboundRuleArgsDict', 'PrivateEndpointOutboundRuleArgsDict', 'ServiceTagOutboundRuleArgsDict']]]]]
        status: NotRequired[pulumi.Input['ManagedNetworkProvisionStatusArgsDict']]
        """
        Status of the Provisioning for the managed network of a machine learning workspace.
        """
elif False:
    ManagedNetworkSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedNetworkSettingsArgs:
    def __init__(__self__, *,
                 isolation_mode: Optional[pulumi.Input[Union[str, 'IsolationMode']]] = None,
                 outbound_rules: Optional[pulumi.Input[Mapping[str, pulumi.Input[Union['FqdnOutboundRuleArgs', 'PrivateEndpointOutboundRuleArgs', 'ServiceTagOutboundRuleArgs']]]]] = None,
                 status: Optional[pulumi.Input['ManagedNetworkProvisionStatusArgs']] = None):
        """
        Managed Network settings for a machine learning workspace.
        :param pulumi.Input[Union[str, 'IsolationMode']] isolation_mode: Isolation mode for the managed network of a machine learning workspace.
        :param pulumi.Input['ManagedNetworkProvisionStatusArgs'] status: Status of the Provisioning for the managed network of a machine learning workspace.
        """
        if isolation_mode is not None:
            pulumi.set(__self__, "isolation_mode", isolation_mode)
        if outbound_rules is not None:
            pulumi.set(__self__, "outbound_rules", outbound_rules)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="isolationMode")
    def isolation_mode(self) -> Optional[pulumi.Input[Union[str, 'IsolationMode']]]:
        """
        Isolation mode for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "isolation_mode")

    @isolation_mode.setter
    def isolation_mode(self, value: Optional[pulumi.Input[Union[str, 'IsolationMode']]]):
        pulumi.set(self, "isolation_mode", value)

    @property
    @pulumi.getter(name="outboundRules")
    def outbound_rules(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Union['FqdnOutboundRuleArgs', 'PrivateEndpointOutboundRuleArgs', 'ServiceTagOutboundRuleArgs']]]]]:
        return pulumi.get(self, "outbound_rules")

    @outbound_rules.setter
    def outbound_rules(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Union['FqdnOutboundRuleArgs', 'PrivateEndpointOutboundRuleArgs', 'ServiceTagOutboundRuleArgs']]]]]):
        pulumi.set(self, "outbound_rules", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['ManagedNetworkProvisionStatusArgs']]:
        """
        Status of the Provisioning for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['ManagedNetworkProvisionStatusArgs']]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ManagedServiceIdentityArgsDict(TypedDict):
        """
        Managed service identity (system assigned and/or user assigned identities)
        """
        type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    ManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param pulumi.Input[Union[str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class PrivateEndpointDestinationArgsDict(TypedDict):
        """
        Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        """
        service_resource_id: NotRequired[pulumi.Input[str]]
        spark_enabled: NotRequired[pulumi.Input[bool]]
        spark_status: NotRequired[pulumi.Input[Union[str, 'RuleStatus']]]
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        """
        subresource_target: NotRequired[pulumi.Input[str]]
elif False:
    PrivateEndpointDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateEndpointDestinationArgs:
    def __init__(__self__, *,
                 service_resource_id: Optional[pulumi.Input[str]] = None,
                 spark_enabled: Optional[pulumi.Input[bool]] = None,
                 spark_status: Optional[pulumi.Input[Union[str, 'RuleStatus']]] = None,
                 subresource_target: Optional[pulumi.Input[str]] = None):
        """
        Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        :param pulumi.Input[Union[str, 'RuleStatus']] spark_status: Type of a managed network Outbound Rule of a machine learning workspace.
        """
        if service_resource_id is not None:
            pulumi.set(__self__, "service_resource_id", service_resource_id)
        if spark_enabled is not None:
            pulumi.set(__self__, "spark_enabled", spark_enabled)
        if spark_status is not None:
            pulumi.set(__self__, "spark_status", spark_status)
        if subresource_target is not None:
            pulumi.set(__self__, "subresource_target", subresource_target)

    @property
    @pulumi.getter(name="serviceResourceId")
    def service_resource_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_resource_id")

    @service_resource_id.setter
    def service_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_resource_id", value)

    @property
    @pulumi.getter(name="sparkEnabled")
    def spark_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "spark_enabled")

    @spark_enabled.setter
    def spark_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "spark_enabled", value)

    @property
    @pulumi.getter(name="sparkStatus")
    def spark_status(self) -> Optional[pulumi.Input[Union[str, 'RuleStatus']]]:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "spark_status")

    @spark_status.setter
    def spark_status(self, value: Optional[pulumi.Input[Union[str, 'RuleStatus']]]):
        pulumi.set(self, "spark_status", value)

    @property
    @pulumi.getter(name="subresourceTarget")
    def subresource_target(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "subresource_target")

    @subresource_target.setter
    def subresource_target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subresource_target", value)


if not MYPY:
    class PrivateEndpointOutboundRuleArgsDict(TypedDict):
        """
        Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        """
        type: pulumi.Input[str]
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        Expected value is 'PrivateEndpoint'.
        """
        category: NotRequired[pulumi.Input[Union[str, 'RuleCategory']]]
        """
        Category of a managed network Outbound Rule of a machine learning workspace.
        """
        destination: NotRequired[pulumi.Input['PrivateEndpointDestinationArgsDict']]
        """
        Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        """
        fqdns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        status: NotRequired[pulumi.Input[Union[str, 'RuleStatus']]]
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        """
elif False:
    PrivateEndpointOutboundRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateEndpointOutboundRuleArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 category: Optional[pulumi.Input[Union[str, 'RuleCategory']]] = None,
                 destination: Optional[pulumi.Input['PrivateEndpointDestinationArgs']] = None,
                 fqdns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 status: Optional[pulumi.Input[Union[str, 'RuleStatus']]] = None):
        """
        Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        :param pulumi.Input[str] type: Type of a managed network Outbound Rule of a machine learning workspace.
               Expected value is 'PrivateEndpoint'.
        :param pulumi.Input[Union[str, 'RuleCategory']] category: Category of a managed network Outbound Rule of a machine learning workspace.
        :param pulumi.Input['PrivateEndpointDestinationArgs'] destination: Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        :param pulumi.Input[Union[str, 'RuleStatus']] status: Type of a managed network Outbound Rule of a machine learning workspace.
        """
        pulumi.set(__self__, "type", 'PrivateEndpoint')
        if category is not None:
            pulumi.set(__self__, "category", category)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        Expected value is 'PrivateEndpoint'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[Union[str, 'RuleCategory']]]:
        """
        Category of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[Union[str, 'RuleCategory']]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input['PrivateEndpointDestinationArgs']]:
        """
        Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input['PrivateEndpointDestinationArgs']]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "fqdns")

    @fqdns.setter
    def fqdns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fqdns", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[str, 'RuleStatus']]]:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[str, 'RuleStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ServerlessComputeSettingsArgsDict(TypedDict):
        serverless_compute_custom_subnet: NotRequired[pulumi.Input[str]]
        """
        The resource ID of an existing virtual network subnet in which serverless compute nodes should be deployed
        """
        serverless_compute_no_public_ip: NotRequired[pulumi.Input[bool]]
        """
        The flag to signal if serverless compute nodes deployed in custom vNet would have no public IP addresses for a workspace with private endpoint
        """
elif False:
    ServerlessComputeSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessComputeSettingsArgs:
    def __init__(__self__, *,
                 serverless_compute_custom_subnet: Optional[pulumi.Input[str]] = None,
                 serverless_compute_no_public_ip: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] serverless_compute_custom_subnet: The resource ID of an existing virtual network subnet in which serverless compute nodes should be deployed
        :param pulumi.Input[bool] serverless_compute_no_public_ip: The flag to signal if serverless compute nodes deployed in custom vNet would have no public IP addresses for a workspace with private endpoint
        """
        if serverless_compute_custom_subnet is not None:
            pulumi.set(__self__, "serverless_compute_custom_subnet", serverless_compute_custom_subnet)
        if serverless_compute_no_public_ip is not None:
            pulumi.set(__self__, "serverless_compute_no_public_ip", serverless_compute_no_public_ip)

    @property
    @pulumi.getter(name="serverlessComputeCustomSubnet")
    def serverless_compute_custom_subnet(self) -> Optional[pulumi.Input[str]]:
        """
        The resource ID of an existing virtual network subnet in which serverless compute nodes should be deployed
        """
        return pulumi.get(self, "serverless_compute_custom_subnet")

    @serverless_compute_custom_subnet.setter
    def serverless_compute_custom_subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "serverless_compute_custom_subnet", value)

    @property
    @pulumi.getter(name="serverlessComputeNoPublicIP")
    def serverless_compute_no_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag to signal if serverless compute nodes deployed in custom vNet would have no public IP addresses for a workspace with private endpoint
        """
        return pulumi.get(self, "serverless_compute_no_public_ip")

    @serverless_compute_no_public_ip.setter
    def serverless_compute_no_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "serverless_compute_no_public_ip", value)


if not MYPY:
    class ServiceManagedResourcesSettingsArgsDict(TypedDict):
        cosmos_db: NotRequired[pulumi.Input['CosmosDbSettingsArgsDict']]
elif False:
    ServiceManagedResourcesSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceManagedResourcesSettingsArgs:
    def __init__(__self__, *,
                 cosmos_db: Optional[pulumi.Input['CosmosDbSettingsArgs']] = None):
        if cosmos_db is not None:
            pulumi.set(__self__, "cosmos_db", cosmos_db)

    @property
    @pulumi.getter(name="cosmosDb")
    def cosmos_db(self) -> Optional[pulumi.Input['CosmosDbSettingsArgs']]:
        return pulumi.get(self, "cosmos_db")

    @cosmos_db.setter
    def cosmos_db(self, value: Optional[pulumi.Input['CosmosDbSettingsArgs']]):
        pulumi.set(self, "cosmos_db", value)


if not MYPY:
    class ServiceTagDestinationArgsDict(TypedDict):
        """
        Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
        """
        action: NotRequired[pulumi.Input[Union[str, 'RuleAction']]]
        """
        The action enum for networking rule.
        """
        address_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Optional, if provided, the ServiceTag property will be ignored.
        """
        port_ranges: NotRequired[pulumi.Input[str]]
        protocol: NotRequired[pulumi.Input[str]]
        service_tag: NotRequired[pulumi.Input[str]]
elif False:
    ServiceTagDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTagDestinationArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[Union[str, 'RuleAction']]] = None,
                 address_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 port_ranges: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None):
        """
        Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
        :param pulumi.Input[Union[str, 'RuleAction']] action: The action enum for networking rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] address_prefixes: Optional, if provided, the ServiceTag property will be ignored.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if address_prefixes is not None:
            pulumi.set(__self__, "address_prefixes", address_prefixes)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[Union[str, 'RuleAction']]]:
        """
        The action enum for networking rule.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[Union[str, 'RuleAction']]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional, if provided, the ServiceTag property will be ignored.
        """
        return pulumi.get(self, "address_prefixes")

    @address_prefixes.setter
    def address_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "address_prefixes", value)

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "port_ranges")

    @port_ranges.setter
    def port_ranges(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_ranges", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)


if not MYPY:
    class ServiceTagOutboundRuleArgsDict(TypedDict):
        """
        Service Tag Outbound Rule for the managed network of a machine learning workspace.
        """
        type: pulumi.Input[str]
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        Expected value is 'ServiceTag'.
        """
        category: NotRequired[pulumi.Input[Union[str, 'RuleCategory']]]
        """
        Category of a managed network Outbound Rule of a machine learning workspace.
        """
        destination: NotRequired[pulumi.Input['ServiceTagDestinationArgsDict']]
        """
        Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
        """
        status: NotRequired[pulumi.Input[Union[str, 'RuleStatus']]]
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        """
elif False:
    ServiceTagOutboundRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTagOutboundRuleArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 category: Optional[pulumi.Input[Union[str, 'RuleCategory']]] = None,
                 destination: Optional[pulumi.Input['ServiceTagDestinationArgs']] = None,
                 status: Optional[pulumi.Input[Union[str, 'RuleStatus']]] = None):
        """
        Service Tag Outbound Rule for the managed network of a machine learning workspace.
        :param pulumi.Input[str] type: Type of a managed network Outbound Rule of a machine learning workspace.
               Expected value is 'ServiceTag'.
        :param pulumi.Input[Union[str, 'RuleCategory']] category: Category of a managed network Outbound Rule of a machine learning workspace.
        :param pulumi.Input['ServiceTagDestinationArgs'] destination: Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
        :param pulumi.Input[Union[str, 'RuleStatus']] status: Type of a managed network Outbound Rule of a machine learning workspace.
        """
        pulumi.set(__self__, "type", 'ServiceTag')
        if category is not None:
            pulumi.set(__self__, "category", category)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        Expected value is 'ServiceTag'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[Union[str, 'RuleCategory']]]:
        """
        Category of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[Union[str, 'RuleCategory']]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input['ServiceTagDestinationArgs']]:
        """
        Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input['ServiceTagDestinationArgs']]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[str, 'RuleStatus']]]:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[str, 'RuleStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class SharedPrivateLinkResourceArgsDict(TypedDict):
        group_id: NotRequired[pulumi.Input[str]]
        """
        group id of the private link
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Unique name of the private link
        """
        private_link_resource_id: NotRequired[pulumi.Input[str]]
        """
        the resource id that private link links to
        """
        request_message: NotRequired[pulumi.Input[str]]
        """
        Request message
        """
        status: NotRequired[pulumi.Input[Union[str, 'EndpointServiceConnectionStatus']]]
        """
        Connection status of the service consumer with the service provider
        Possible state transitions
        Pending -> Approved (Service provider approves the connection request)
        Pending -> Rejected (Service provider rejects the connection request)
        Pending -> Disconnected (Service provider deletes the connection)
        Approved -> Rejected (Service provider rejects the approved connection)
        Approved -> Disconnected (Service provider deletes the connection)
        Rejected -> Pending (Service consumer re-initiates the connection request that was rejected)
        Rejected -> Disconnected (Service provider deletes the connection)
        """
elif False:
    SharedPrivateLinkResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SharedPrivateLinkResourceArgs:
    def __init__(__self__, *,
                 group_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 private_link_resource_id: Optional[pulumi.Input[str]] = None,
                 request_message: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[Union[str, 'EndpointServiceConnectionStatus']]] = None):
        """
        :param pulumi.Input[str] group_id: group id of the private link
        :param pulumi.Input[str] name: Unique name of the private link
        :param pulumi.Input[str] private_link_resource_id: the resource id that private link links to
        :param pulumi.Input[str] request_message: Request message
        :param pulumi.Input[Union[str, 'EndpointServiceConnectionStatus']] status: Connection status of the service consumer with the service provider
               Possible state transitions
               Pending -> Approved (Service provider approves the connection request)
               Pending -> Rejected (Service provider rejects the connection request)
               Pending -> Disconnected (Service provider deletes the connection)
               Approved -> Rejected (Service provider rejects the approved connection)
               Approved -> Disconnected (Service provider deletes the connection)
               Rejected -> Pending (Service consumer re-initiates the connection request that was rejected)
               Rejected -> Disconnected (Service provider deletes the connection)
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_link_resource_id is not None:
            pulumi.set(__self__, "private_link_resource_id", private_link_resource_id)
        if request_message is not None:
            pulumi.set(__self__, "request_message", request_message)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[str]]:
        """
        group id of the private link
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the private link
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="privateLinkResourceId")
    def private_link_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        the resource id that private link links to
        """
        return pulumi.get(self, "private_link_resource_id")

    @private_link_resource_id.setter
    def private_link_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_link_resource_id", value)

    @property
    @pulumi.getter(name="requestMessage")
    def request_message(self) -> Optional[pulumi.Input[str]]:
        """
        Request message
        """
        return pulumi.get(self, "request_message")

    @request_message.setter
    def request_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "request_message", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[str, 'EndpointServiceConnectionStatus']]]:
        """
        Connection status of the service consumer with the service provider
        Possible state transitions
        Pending -> Approved (Service provider approves the connection request)
        Pending -> Rejected (Service provider rejects the connection request)
        Pending -> Disconnected (Service provider deletes the connection)
        Approved -> Rejected (Service provider rejects the approved connection)
        Approved -> Disconnected (Service provider deletes the connection)
        Rejected -> Pending (Service consumer re-initiates the connection request that was rejected)
        Rejected -> Disconnected (Service provider deletes the connection)
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[str, 'EndpointServiceConnectionStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class SkuArgsDict(TypedDict):
        """
        The resource model definition representing SKU
        """
        name: pulumi.Input[str]
        """
        The name of the SKU. Ex - P3. It is typically a letter+number code
        """
        capacity: NotRequired[pulumi.Input[int]]
        """
        If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        """
        family: NotRequired[pulumi.Input[str]]
        """
        If the service has different generations of hardware, for the same SKU, then that can be captured here.
        """
        size: NotRequired[pulumi.Input[str]]
        """
        The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        """
        tier: NotRequired[pulumi.Input['SkuTier']]
        """
        This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
elif False:
    SkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SkuArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 capacity: Optional[pulumi.Input[int]] = None,
                 family: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[str]] = None,
                 tier: Optional[pulumi.Input['SkuTier']] = None):
        """
        The resource model definition representing SKU
        :param pulumi.Input[str] name: The name of the SKU. Ex - P3. It is typically a letter+number code
        :param pulumi.Input[int] capacity: If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        :param pulumi.Input[str] family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
        :param pulumi.Input[str] size: The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        :param pulumi.Input['SkuTier'] tier: This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the SKU. Ex - P3. It is typically a letter+number code
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[int]]:
        """
        If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input[str]]:
        """
        If the service has different generations of hardware, for the same SKU, then that can be captured here.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input['SkuTier']]:
        """
        This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input['SkuTier']]):
        pulumi.set(self, "tier", value)


if not MYPY:
    class WorkspaceHubConfigArgsDict(TypedDict):
        """
        WorkspaceHub's configuration object.
        """
        additional_workspace_storage_accounts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        default_workspace_resource_group: NotRequired[pulumi.Input[str]]
elif False:
    WorkspaceHubConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceHubConfigArgs:
    def __init__(__self__, *,
                 additional_workspace_storage_accounts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 default_workspace_resource_group: Optional[pulumi.Input[str]] = None):
        """
        WorkspaceHub's configuration object.
        """
        if additional_workspace_storage_accounts is not None:
            pulumi.set(__self__, "additional_workspace_storage_accounts", additional_workspace_storage_accounts)
        if default_workspace_resource_group is not None:
            pulumi.set(__self__, "default_workspace_resource_group", default_workspace_resource_group)

    @property
    @pulumi.getter(name="additionalWorkspaceStorageAccounts")
    def additional_workspace_storage_accounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "additional_workspace_storage_accounts")

    @additional_workspace_storage_accounts.setter
    def additional_workspace_storage_accounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "additional_workspace_storage_accounts", value)

    @property
    @pulumi.getter(name="defaultWorkspaceResourceGroup")
    def default_workspace_resource_group(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "default_workspace_resource_group")

    @default_workspace_resource_group.setter
    def default_workspace_resource_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_workspace_resource_group", value)


