# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AccountApiKeysResponse',
    'ComputeRuntimeDtoResponse',
    'CosmosDbSettingsResponse',
    'EncryptionPropertyResponse',
    'EndpointModelDeprecationPropertiesResponse',
    'EndpointModelPropertiesResponse',
    'EndpointModelSkuCapacityPropertiesResponse',
    'EndpointModelSkuPropertiesResponse',
    'EndpointModelSkuRateLimitPropertiesResponse',
    'EndpointModelSkuRateLimitRulePatternPropertiesResponse',
    'EndpointModelSkuRateLimitRulePropertiesResponse',
    'FeatureStoreSettingsResponse',
    'FqdnOutboundRuleResponse',
    'IdentityForCmkResponse',
    'KeyVaultPropertiesResponse',
    'ListNotebookKeysResultResponse',
    'ManagedNetworkProvisionStatusResponse',
    'ManagedNetworkSettingsResponse',
    'ManagedServiceIdentityResponse',
    'NotebookPreparationErrorResponse',
    'NotebookResourceInfoResponse',
    'PasswordResponse',
    'PrivateEndpointConnectionResponse',
    'PrivateEndpointDestinationResponse',
    'PrivateEndpointOutboundRuleResponse',
    'PrivateLinkServiceConnectionStateResponse',
    'RegistryListCredentialsResultResponse',
    'ServerlessComputeSettingsResponse',
    'ServiceManagedResourcesSettingsResponse',
    'ServiceTagDestinationResponse',
    'ServiceTagOutboundRuleResponse',
    'SharedPrivateLinkResourceResponse',
    'SkuResponse',
    'SystemDataResponse',
    'UserAssignedIdentityResponse',
    'WorkspaceHubConfigResponse',
    'WorkspacePrivateEndpointResourceResponse',
]

@pulumi.output_type
class AccountApiKeysResponse(dict):
    def __init__(__self__, *,
                 key1: Optional[str] = None,
                 key2: Optional[str] = None):
        if key1 is not None:
            pulumi.set(__self__, "key1", key1)
        if key2 is not None:
            pulumi.set(__self__, "key2", key2)

    @property
    @pulumi.getter
    def key1(self) -> Optional[str]:
        return pulumi.get(self, "key1")

    @property
    @pulumi.getter
    def key2(self) -> Optional[str]:
        return pulumi.get(self, "key2")


@pulumi.output_type
class ComputeRuntimeDtoResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sparkRuntimeVersion":
            suggest = "spark_runtime_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeRuntimeDtoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeRuntimeDtoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeRuntimeDtoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 spark_runtime_version: Optional[str] = None):
        if spark_runtime_version is not None:
            pulumi.set(__self__, "spark_runtime_version", spark_runtime_version)

    @property
    @pulumi.getter(name="sparkRuntimeVersion")
    def spark_runtime_version(self) -> Optional[str]:
        return pulumi.get(self, "spark_runtime_version")


@pulumi.output_type
class CosmosDbSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionsThroughput":
            suggest = "collections_throughput"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CosmosDbSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CosmosDbSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CosmosDbSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collections_throughput: Optional[int] = None):
        if collections_throughput is not None:
            pulumi.set(__self__, "collections_throughput", collections_throughput)

    @property
    @pulumi.getter(name="collectionsThroughput")
    def collections_throughput(self) -> Optional[int]:
        return pulumi.get(self, "collections_throughput")


@pulumi.output_type
class EncryptionPropertyResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultProperties":
            suggest = "key_vault_properties"
        elif key == "cosmosDbResourceId":
            suggest = "cosmos_db_resource_id"
        elif key == "searchAccountResourceId":
            suggest = "search_account_resource_id"
        elif key == "storageAccountResourceId":
            suggest = "storage_account_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionPropertyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionPropertyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionPropertyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_properties: 'outputs.KeyVaultPropertiesResponse',
                 status: str,
                 cosmos_db_resource_id: Optional[str] = None,
                 identity: Optional['outputs.IdentityForCmkResponse'] = None,
                 search_account_resource_id: Optional[str] = None,
                 storage_account_resource_id: Optional[str] = None):
        """
        :param 'KeyVaultPropertiesResponse' key_vault_properties: KeyVault details to do the encryption
        :param str status: Indicates whether or not the encryption is enabled for the workspace.
        :param str cosmos_db_resource_id: The byok cosmosdb account that customer brings to store customer's data
               with encryption
        :param 'IdentityForCmkResponse' identity: Identity to be used with the keyVault
        :param str search_account_resource_id: The byok search account that customer brings to store customer's data
               with encryption
        :param str storage_account_resource_id: The byok storage account that customer brings to store customer's data
               with encryption
        """
        pulumi.set(__self__, "key_vault_properties", key_vault_properties)
        pulumi.set(__self__, "status", status)
        if cosmos_db_resource_id is not None:
            pulumi.set(__self__, "cosmos_db_resource_id", cosmos_db_resource_id)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if search_account_resource_id is not None:
            pulumi.set(__self__, "search_account_resource_id", search_account_resource_id)
        if storage_account_resource_id is not None:
            pulumi.set(__self__, "storage_account_resource_id", storage_account_resource_id)

    @property
    @pulumi.getter(name="keyVaultProperties")
    def key_vault_properties(self) -> 'outputs.KeyVaultPropertiesResponse':
        """
        KeyVault details to do the encryption
        """
        return pulumi.get(self, "key_vault_properties")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Indicates whether or not the encryption is enabled for the workspace.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="cosmosDbResourceId")
    def cosmos_db_resource_id(self) -> Optional[str]:
        """
        The byok cosmosdb account that customer brings to store customer's data
        with encryption
        """
        return pulumi.get(self, "cosmos_db_resource_id")

    @property
    @pulumi.getter
    def identity(self) -> Optional['outputs.IdentityForCmkResponse']:
        """
        Identity to be used with the keyVault
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter(name="searchAccountResourceId")
    def search_account_resource_id(self) -> Optional[str]:
        """
        The byok search account that customer brings to store customer's data
        with encryption
        """
        return pulumi.get(self, "search_account_resource_id")

    @property
    @pulumi.getter(name="storageAccountResourceId")
    def storage_account_resource_id(self) -> Optional[str]:
        """
        The byok storage account that customer brings to store customer's data
        with encryption
        """
        return pulumi.get(self, "storage_account_resource_id")


@pulumi.output_type
class EndpointModelDeprecationPropertiesResponse(dict):
    def __init__(__self__, *,
                 fine_tune: Optional[str] = None,
                 inference: Optional[str] = None):
        """
        :param str fine_tune: The datetime of deprecation of the fineTune Model.
        :param str inference: The datetime of deprecation of the inference Model.
        """
        if fine_tune is not None:
            pulumi.set(__self__, "fine_tune", fine_tune)
        if inference is not None:
            pulumi.set(__self__, "inference", inference)

    @property
    @pulumi.getter(name="fineTune")
    def fine_tune(self) -> Optional[str]:
        """
        The datetime of deprecation of the fineTune Model.
        """
        return pulumi.get(self, "fine_tune")

    @property
    @pulumi.getter
    def inference(self) -> Optional[str]:
        """
        The datetime of deprecation of the inference Model.
        """
        return pulumi.get(self, "inference")


@pulumi.output_type
class EndpointModelPropertiesResponse(dict):
    """
    Endpoint Model properties.
    """
    def __init__(__self__, *,
                 system_data: 'outputs.SystemDataResponse',
                 capabilities: Optional[Mapping[str, str]] = None,
                 deprecation: Optional['outputs.EndpointModelDeprecationPropertiesResponse'] = None,
                 finetune_capabilities: Optional[Mapping[str, str]] = None,
                 format: Optional[str] = None,
                 is_default_version: Optional[bool] = None,
                 lifecycle_status: Optional[str] = None,
                 max_capacity: Optional[int] = None,
                 name: Optional[str] = None,
                 skus: Optional[Sequence['outputs.EndpointModelSkuPropertiesResponse']] = None,
                 version: Optional[str] = None):
        """
        Endpoint Model properties.
        :param 'SystemDataResponse' system_data: Metadata pertaining to creation and last modification of the resource.
        :param Mapping[str, str] capabilities: The capabilities.
        :param Mapping[str, str] finetune_capabilities: The capabilities for finetune models.
        :param str format: Deployment model format.
        :param bool is_default_version: If the model is default version.
        :param str lifecycle_status: Model lifecycle status.
        :param int max_capacity: The max capacity.
        :param str name: Deployment model name.
        :param Sequence['EndpointModelSkuPropertiesResponse'] skus: The list of Model Sku.
        :param str version: Optional. Deployment model version. If version is not specified, a default version will be assigned. The default version is different for different models and might change when there is new version available for a model. Default version for a model could be found from list models API.
        """
        pulumi.set(__self__, "system_data", system_data)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if deprecation is not None:
            pulumi.set(__self__, "deprecation", deprecation)
        if finetune_capabilities is not None:
            pulumi.set(__self__, "finetune_capabilities", finetune_capabilities)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if is_default_version is not None:
            pulumi.set(__self__, "is_default_version", is_default_version)
        if lifecycle_status is not None:
            pulumi.set(__self__, "lifecycle_status", lifecycle_status)
        if max_capacity is not None:
            pulumi.set(__self__, "max_capacity", max_capacity)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if skus is not None:
            pulumi.set(__self__, "skus", skus)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Metadata pertaining to creation and last modification of the resource.
        """
        return pulumi.get(self, "system_data")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[Mapping[str, str]]:
        """
        The capabilities.
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def deprecation(self) -> Optional['outputs.EndpointModelDeprecationPropertiesResponse']:
        return pulumi.get(self, "deprecation")

    @property
    @pulumi.getter(name="finetuneCapabilities")
    def finetune_capabilities(self) -> Optional[Mapping[str, str]]:
        """
        The capabilities for finetune models.
        """
        return pulumi.get(self, "finetune_capabilities")

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        """
        Deployment model format.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="isDefaultVersion")
    def is_default_version(self) -> Optional[bool]:
        """
        If the model is default version.
        """
        return pulumi.get(self, "is_default_version")

    @property
    @pulumi.getter(name="lifecycleStatus")
    def lifecycle_status(self) -> Optional[str]:
        """
        Model lifecycle status.
        """
        return pulumi.get(self, "lifecycle_status")

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[int]:
        """
        The max capacity.
        """
        return pulumi.get(self, "max_capacity")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Deployment model name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def skus(self) -> Optional[Sequence['outputs.EndpointModelSkuPropertiesResponse']]:
        """
        The list of Model Sku.
        """
        return pulumi.get(self, "skus")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Optional. Deployment model version. If version is not specified, a default version will be assigned. The default version is different for different models and might change when there is new version available for a model. Default version for a model could be found from list models API.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class EndpointModelSkuCapacityPropertiesResponse(dict):
    def __init__(__self__, *,
                 default: Optional[int] = None,
                 maximum: Optional[int] = None):
        """
        :param int default: The default capacity.
        :param int maximum: The maximum capacity.
        """
        if default is not None:
            pulumi.set(__self__, "default", default)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)

    @property
    @pulumi.getter
    def default(self) -> Optional[int]:
        """
        The default capacity.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def maximum(self) -> Optional[int]:
        """
        The maximum capacity.
        """
        return pulumi.get(self, "maximum")


@pulumi.output_type
class EndpointModelSkuPropertiesResponse(dict):
    def __init__(__self__, *,
                 capacity: Optional['outputs.EndpointModelSkuCapacityPropertiesResponse'] = None,
                 connection_ids: Optional[Sequence[str]] = None,
                 deprecation_date: Optional[str] = None,
                 name: Optional[str] = None,
                 rate_limits: Optional[Sequence['outputs.EndpointModelSkuRateLimitPropertiesResponse']] = None,
                 usage_name: Optional[str] = None):
        """
        :param Sequence[str] connection_ids: The list of ARM id for the connection support this SKU.
        :param str deprecation_date: The datetime of deprecation of the model SKU.
        :param str name: The name of the model SKU.
        :param str usage_name: The usage name of the model SKU.
        """
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if connection_ids is not None:
            pulumi.set(__self__, "connection_ids", connection_ids)
        if deprecation_date is not None:
            pulumi.set(__self__, "deprecation_date", deprecation_date)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if rate_limits is not None:
            pulumi.set(__self__, "rate_limits", rate_limits)
        if usage_name is not None:
            pulumi.set(__self__, "usage_name", usage_name)

    @property
    @pulumi.getter
    def capacity(self) -> Optional['outputs.EndpointModelSkuCapacityPropertiesResponse']:
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter(name="connectionIds")
    def connection_ids(self) -> Optional[Sequence[str]]:
        """
        The list of ARM id for the connection support this SKU.
        """
        return pulumi.get(self, "connection_ids")

    @property
    @pulumi.getter(name="deprecationDate")
    def deprecation_date(self) -> Optional[str]:
        """
        The datetime of deprecation of the model SKU.
        """
        return pulumi.get(self, "deprecation_date")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the model SKU.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="rateLimits")
    def rate_limits(self) -> Optional[Sequence['outputs.EndpointModelSkuRateLimitPropertiesResponse']]:
        return pulumi.get(self, "rate_limits")

    @property
    @pulumi.getter(name="usageName")
    def usage_name(self) -> Optional[str]:
        """
        The usage name of the model SKU.
        """
        return pulumi.get(self, "usage_name")


@pulumi.output_type
class EndpointModelSkuRateLimitPropertiesResponse(dict):
    def __init__(__self__, *,
                 count: Optional[float] = None,
                 renewal_period: Optional[float] = None,
                 rules: Optional[Sequence['outputs.EndpointModelSkuRateLimitRulePropertiesResponse']] = None):
        """
        :param float count: The count value of Call Rate Limit.
        :param float renewal_period: The renewal period in seconds of Call Rate Limit.
        :param Sequence['EndpointModelSkuRateLimitRulePropertiesResponse'] rules: The call rate limit for the model.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if renewal_period is not None:
            pulumi.set(__self__, "renewal_period", renewal_period)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def count(self) -> Optional[float]:
        """
        The count value of Call Rate Limit.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="renewalPeriod")
    def renewal_period(self) -> Optional[float]:
        """
        The renewal period in seconds of Call Rate Limit.
        """
        return pulumi.get(self, "renewal_period")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.EndpointModelSkuRateLimitRulePropertiesResponse']]:
        """
        The call rate limit for the model.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class EndpointModelSkuRateLimitRulePatternPropertiesResponse(dict):
    def __init__(__self__, *,
                 method: Optional[str] = None,
                 path: Optional[str] = None):
        if method is not None:
            pulumi.set(__self__, "method", method)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class EndpointModelSkuRateLimitRulePropertiesResponse(dict):
    def __init__(__self__, *,
                 count: Optional[float] = None,
                 dynamic_throttling_enabled: Optional[bool] = None,
                 key: Optional[str] = None,
                 match_patterns: Optional[Sequence['outputs.EndpointModelSkuRateLimitRulePatternPropertiesResponse']] = None,
                 min_count: Optional[float] = None,
                 renewal_period: Optional[float] = None):
        """
        :param bool dynamic_throttling_enabled: If the dynamic throttling is enabled.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if dynamic_throttling_enabled is not None:
            pulumi.set(__self__, "dynamic_throttling_enabled", dynamic_throttling_enabled)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_patterns is not None:
            pulumi.set(__self__, "match_patterns", match_patterns)
        if min_count is not None:
            pulumi.set(__self__, "min_count", min_count)
        if renewal_period is not None:
            pulumi.set(__self__, "renewal_period", renewal_period)

    @property
    @pulumi.getter
    def count(self) -> Optional[float]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="dynamicThrottlingEnabled")
    def dynamic_throttling_enabled(self) -> Optional[bool]:
        """
        If the dynamic throttling is enabled.
        """
        return pulumi.get(self, "dynamic_throttling_enabled")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Optional[Sequence['outputs.EndpointModelSkuRateLimitRulePatternPropertiesResponse']]:
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="minCount")
    def min_count(self) -> Optional[float]:
        return pulumi.get(self, "min_count")

    @property
    @pulumi.getter(name="renewalPeriod")
    def renewal_period(self) -> Optional[float]:
        return pulumi.get(self, "renewal_period")


@pulumi.output_type
class FeatureStoreSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeRuntime":
            suggest = "compute_runtime"
        elif key == "offlineStoreConnectionName":
            suggest = "offline_store_connection_name"
        elif key == "onlineStoreConnectionName":
            suggest = "online_store_connection_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureStoreSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureStoreSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureStoreSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_runtime: Optional['outputs.ComputeRuntimeDtoResponse'] = None,
                 offline_store_connection_name: Optional[str] = None,
                 online_store_connection_name: Optional[str] = None):
        if compute_runtime is not None:
            pulumi.set(__self__, "compute_runtime", compute_runtime)
        if offline_store_connection_name is not None:
            pulumi.set(__self__, "offline_store_connection_name", offline_store_connection_name)
        if online_store_connection_name is not None:
            pulumi.set(__self__, "online_store_connection_name", online_store_connection_name)

    @property
    @pulumi.getter(name="computeRuntime")
    def compute_runtime(self) -> Optional['outputs.ComputeRuntimeDtoResponse']:
        return pulumi.get(self, "compute_runtime")

    @property
    @pulumi.getter(name="offlineStoreConnectionName")
    def offline_store_connection_name(self) -> Optional[str]:
        return pulumi.get(self, "offline_store_connection_name")

    @property
    @pulumi.getter(name="onlineStoreConnectionName")
    def online_store_connection_name(self) -> Optional[str]:
        return pulumi.get(self, "online_store_connection_name")


@pulumi.output_type
class FqdnOutboundRuleResponse(dict):
    """
    FQDN Outbound Rule for the managed network of a machine learning workspace.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parentRuleNames":
            suggest = "parent_rule_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FqdnOutboundRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FqdnOutboundRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FqdnOutboundRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parent_rule_names: Sequence[str],
                 type: str,
                 category: Optional[str] = None,
                 destination: Optional[str] = None,
                 status: Optional[str] = None):
        """
        FQDN Outbound Rule for the managed network of a machine learning workspace.
        :param str type: Type of a managed network Outbound Rule of a machine learning workspace.
               Expected value is 'FQDN'.
        :param str category: Category of a managed network Outbound Rule of a machine learning workspace.
        :param str status: Type of a managed network Outbound Rule of a machine learning workspace.
        """
        pulumi.set(__self__, "parent_rule_names", parent_rule_names)
        pulumi.set(__self__, "type", 'FQDN')
        if category is not None:
            pulumi.set(__self__, "category", category)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="parentRuleNames")
    def parent_rule_names(self) -> Sequence[str]:
        return pulumi.get(self, "parent_rule_names")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        Expected value is 'FQDN'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        Category of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class IdentityForCmkResponse(dict):
    """
    Identity object used for encryption.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userAssignedIdentity":
            suggest = "user_assigned_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityForCmkResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityForCmkResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityForCmkResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_assigned_identity: Optional[str] = None):
        """
        Identity object used for encryption.
        :param str user_assigned_identity: UserAssignedIdentity to be used to fetch the encryption key from keyVault
        """
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[str]:
        """
        UserAssignedIdentity to be used to fetch the encryption key from keyVault
        """
        return pulumi.get(self, "user_assigned_identity")


@pulumi.output_type
class KeyVaultPropertiesResponse(dict):
    """
    Customer Key vault properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyIdentifier":
            suggest = "key_identifier"
        elif key == "keyVaultArmId":
            suggest = "key_vault_arm_id"
        elif key == "identityClientId":
            suggest = "identity_client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyVaultPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyVaultPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyVaultPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_identifier: str,
                 key_vault_arm_id: str,
                 identity_client_id: Optional[str] = None):
        """
        Customer Key vault properties.
        :param str key_identifier: KeyVault key identifier to encrypt the data
        :param str key_vault_arm_id: KeyVault Arm Id that contains the data encryption key
        :param str identity_client_id: Currently, we support only SystemAssigned MSI.
               We need this when we support UserAssignedIdentities
        """
        pulumi.set(__self__, "key_identifier", key_identifier)
        pulumi.set(__self__, "key_vault_arm_id", key_vault_arm_id)
        if identity_client_id is not None:
            pulumi.set(__self__, "identity_client_id", identity_client_id)

    @property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> str:
        """
        KeyVault key identifier to encrypt the data
        """
        return pulumi.get(self, "key_identifier")

    @property
    @pulumi.getter(name="keyVaultArmId")
    def key_vault_arm_id(self) -> str:
        """
        KeyVault Arm Id that contains the data encryption key
        """
        return pulumi.get(self, "key_vault_arm_id")

    @property
    @pulumi.getter(name="identityClientId")
    def identity_client_id(self) -> Optional[str]:
        """
        Currently, we support only SystemAssigned MSI.
        We need this when we support UserAssignedIdentities
        """
        return pulumi.get(self, "identity_client_id")


@pulumi.output_type
class ListNotebookKeysResultResponse(dict):
    def __init__(__self__, *,
                 primary_access_key: str,
                 secondary_access_key: str):
        """
        :param str primary_access_key: The primary access key of the Notebook
        :param str secondary_access_key: The secondary access key of the Notebook
        """
        pulumi.set(__self__, "primary_access_key", primary_access_key)
        pulumi.set(__self__, "secondary_access_key", secondary_access_key)

    @property
    @pulumi.getter(name="primaryAccessKey")
    def primary_access_key(self) -> str:
        """
        The primary access key of the Notebook
        """
        return pulumi.get(self, "primary_access_key")

    @property
    @pulumi.getter(name="secondaryAccessKey")
    def secondary_access_key(self) -> str:
        """
        The secondary access key of the Notebook
        """
        return pulumi.get(self, "secondary_access_key")


@pulumi.output_type
class ManagedNetworkProvisionStatusResponse(dict):
    """
    Status of the Provisioning for the managed network of a machine learning workspace.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sparkReady":
            suggest = "spark_ready"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedNetworkProvisionStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedNetworkProvisionStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedNetworkProvisionStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 spark_ready: Optional[bool] = None,
                 status: Optional[str] = None):
        """
        Status of the Provisioning for the managed network of a machine learning workspace.
        :param str status: Status for the managed network of a machine learning workspace.
        """
        if spark_ready is not None:
            pulumi.set(__self__, "spark_ready", spark_ready)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="sparkReady")
    def spark_ready(self) -> Optional[bool]:
        return pulumi.get(self, "spark_ready")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ManagedNetworkSettingsResponse(dict):
    """
    Managed Network settings for a machine learning workspace.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "changeableIsolationModes":
            suggest = "changeable_isolation_modes"
        elif key == "networkId":
            suggest = "network_id"
        elif key == "isolationMode":
            suggest = "isolation_mode"
        elif key == "outboundRules":
            suggest = "outbound_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedNetworkSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedNetworkSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedNetworkSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 changeable_isolation_modes: Sequence[str],
                 network_id: str,
                 isolation_mode: Optional[str] = None,
                 outbound_rules: Optional[Mapping[str, Any]] = None,
                 status: Optional['outputs.ManagedNetworkProvisionStatusResponse'] = None):
        """
        Managed Network settings for a machine learning workspace.
        :param str isolation_mode: Isolation mode for the managed network of a machine learning workspace.
        :param 'ManagedNetworkProvisionStatusResponse' status: Status of the Provisioning for the managed network of a machine learning workspace.
        """
        pulumi.set(__self__, "changeable_isolation_modes", changeable_isolation_modes)
        pulumi.set(__self__, "network_id", network_id)
        if isolation_mode is not None:
            pulumi.set(__self__, "isolation_mode", isolation_mode)
        if outbound_rules is not None:
            pulumi.set(__self__, "outbound_rules", outbound_rules)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="changeableIsolationModes")
    def changeable_isolation_modes(self) -> Sequence[str]:
        return pulumi.get(self, "changeable_isolation_modes")

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> str:
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter(name="isolationMode")
    def isolation_mode(self) -> Optional[str]:
        """
        Isolation mode for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "isolation_mode")

    @property
    @pulumi.getter(name="outboundRules")
    def outbound_rules(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "outbound_rules")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.ManagedNetworkProvisionStatusResponse']:
        """
        Status of the Provisioning for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity (system assigned and/or user assigned identities)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class NotebookPreparationErrorResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotebookPreparationErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotebookPreparationErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotebookPreparationErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_message: Optional[str] = None,
                 status_code: Optional[int] = None):
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[str]:
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        return pulumi.get(self, "status_code")


@pulumi.output_type
class NotebookResourceInfoResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isPrivateLinkEnabled":
            suggest = "is_private_link_enabled"
        elif key == "notebookPreparationError":
            suggest = "notebook_preparation_error"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotebookResourceInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotebookResourceInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotebookResourceInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: Optional[str] = None,
                 is_private_link_enabled: Optional[bool] = None,
                 notebook_preparation_error: Optional['outputs.NotebookPreparationErrorResponse'] = None,
                 resource_id: Optional[str] = None):
        """
        :param 'NotebookPreparationErrorResponse' notebook_preparation_error: The error that occurs when preparing notebook.
        :param str resource_id: the data plane resourceId that used to initialize notebook component
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if is_private_link_enabled is not None:
            pulumi.set(__self__, "is_private_link_enabled", is_private_link_enabled)
        if notebook_preparation_error is not None:
            pulumi.set(__self__, "notebook_preparation_error", notebook_preparation_error)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[str]:
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="isPrivateLinkEnabled")
    def is_private_link_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_private_link_enabled")

    @property
    @pulumi.getter(name="notebookPreparationError")
    def notebook_preparation_error(self) -> Optional['outputs.NotebookPreparationErrorResponse']:
        """
        The error that occurs when preparing notebook.
        """
        return pulumi.get(self, "notebook_preparation_error")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        the data plane resourceId that used to initialize notebook component
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class PasswordResponse(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class PrivateEndpointConnectionResponse(dict):
    """
    The Private Endpoint Connection resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemData":
            suggest = "system_data"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"
        elif key == "privateLinkServiceConnectionState":
            suggest = "private_link_service_connection_state"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 name: str,
                 system_data: 'outputs.SystemDataResponse',
                 type: str,
                 identity: Optional['outputs.ManagedServiceIdentityResponse'] = None,
                 location: Optional[str] = None,
                 private_endpoint: Optional['outputs.WorkspacePrivateEndpointResourceResponse'] = None,
                 private_link_service_connection_state: Optional['outputs.PrivateLinkServiceConnectionStateResponse'] = None,
                 provisioning_state: Optional[str] = None,
                 sku: Optional['outputs.SkuResponse'] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        The Private Endpoint Connection resource.
        :param str id: Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        :param str name: The name of the resource
        :param 'SystemDataResponse' system_data: Azure Resource Manager metadata containing createdBy and modifiedBy information.
        :param str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param 'ManagedServiceIdentityResponse' identity: Managed service identity (system assigned and/or user assigned identities)
        :param str location: Same as workspace location.
        :param 'WorkspacePrivateEndpointResourceResponse' private_endpoint: The Private Endpoint resource.
        :param 'PrivateLinkServiceConnectionStateResponse' private_link_service_connection_state: The connection state.
        :param str provisioning_state: The current provisioning state.
        :param 'SkuResponse' sku: Optional. This field is required to be implemented by the RP because AML is supporting more than one tier
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "system_data", system_data)
        pulumi.set(__self__, "type", type)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if private_link_service_connection_state is not None:
            pulumi.set(__self__, "private_link_service_connection_state", private_link_service_connection_state)
        if provisioning_state is not None:
            pulumi.set(__self__, "provisioning_state", provisioning_state)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Azure Resource Manager metadata containing createdBy and modifiedBy information.
        """
        return pulumi.get(self, "system_data")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def identity(self) -> Optional['outputs.ManagedServiceIdentityResponse']:
        """
        Managed service identity (system assigned and/or user assigned identities)
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Same as workspace location.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.WorkspacePrivateEndpointResourceResponse']:
        """
        The Private Endpoint resource.
        """
        return pulumi.get(self, "private_endpoint")

    @property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> Optional['outputs.PrivateLinkServiceConnectionStateResponse']:
        """
        The connection state.
        """
        return pulumi.get(self, "private_link_service_connection_state")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        The current provisioning state.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def sku(self) -> Optional['outputs.SkuResponse']:
        """
        Optional. This field is required to be implemented by the RP because AML is supporting more than one tier
        """
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class PrivateEndpointDestinationResponse(dict):
    """
    Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceResourceId":
            suggest = "service_resource_id"
        elif key == "sparkEnabled":
            suggest = "spark_enabled"
        elif key == "sparkStatus":
            suggest = "spark_status"
        elif key == "subresourceTarget":
            suggest = "subresource_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_resource_id: Optional[str] = None,
                 spark_enabled: Optional[bool] = None,
                 spark_status: Optional[str] = None,
                 subresource_target: Optional[str] = None):
        """
        Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        :param str spark_status: Type of a managed network Outbound Rule of a machine learning workspace.
        """
        if service_resource_id is not None:
            pulumi.set(__self__, "service_resource_id", service_resource_id)
        if spark_enabled is not None:
            pulumi.set(__self__, "spark_enabled", spark_enabled)
        if spark_status is not None:
            pulumi.set(__self__, "spark_status", spark_status)
        if subresource_target is not None:
            pulumi.set(__self__, "subresource_target", subresource_target)

    @property
    @pulumi.getter(name="serviceResourceId")
    def service_resource_id(self) -> Optional[str]:
        return pulumi.get(self, "service_resource_id")

    @property
    @pulumi.getter(name="sparkEnabled")
    def spark_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "spark_enabled")

    @property
    @pulumi.getter(name="sparkStatus")
    def spark_status(self) -> Optional[str]:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "spark_status")

    @property
    @pulumi.getter(name="subresourceTarget")
    def subresource_target(self) -> Optional[str]:
        return pulumi.get(self, "subresource_target")


@pulumi.output_type
class PrivateEndpointOutboundRuleResponse(dict):
    """
    Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parentRuleNames":
            suggest = "parent_rule_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointOutboundRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointOutboundRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointOutboundRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parent_rule_names: Sequence[str],
                 type: str,
                 category: Optional[str] = None,
                 destination: Optional['outputs.PrivateEndpointDestinationResponse'] = None,
                 fqdns: Optional[Sequence[str]] = None,
                 status: Optional[str] = None):
        """
        Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        :param str type: Type of a managed network Outbound Rule of a machine learning workspace.
               Expected value is 'PrivateEndpoint'.
        :param str category: Category of a managed network Outbound Rule of a machine learning workspace.
        :param 'PrivateEndpointDestinationResponse' destination: Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        :param str status: Type of a managed network Outbound Rule of a machine learning workspace.
        """
        pulumi.set(__self__, "parent_rule_names", parent_rule_names)
        pulumi.set(__self__, "type", 'PrivateEndpoint')
        if category is not None:
            pulumi.set(__self__, "category", category)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="parentRuleNames")
    def parent_rule_names(self) -> Sequence[str]:
        return pulumi.get(self, "parent_rule_names")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        Expected value is 'PrivateEndpoint'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        Category of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.PrivateEndpointDestinationResponse']:
        """
        Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "fqdns")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class PrivateLinkServiceConnectionStateResponse(dict):
    """
    A collection of information about the state of the connection between service consumer and provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsRequired":
            suggest = "actions_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkServiceConnectionStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_required: Optional[str] = None,
                 description: Optional[str] = None,
                 status: Optional[str] = None):
        """
        A collection of information about the state of the connection between service consumer and provider.
        :param str actions_required: Some RP chose "None". Other RPs use this for region expansion.
        :param str description: User-defined message that, per NRP doc, may be used for approval-related message.
        :param str status: Connection status of the service consumer with the service provider
               Possible state transitions
               Pending -> Approved (Service provider approves the connection request)
               Pending -> Rejected (Service provider rejects the connection request)
               Pending -> Disconnected (Service provider deletes the connection)
               Approved -> Rejected (Service provider rejects the approved connection)
               Approved -> Disconnected (Service provider deletes the connection)
               Rejected -> Pending (Service consumer re-initiates the connection request that was rejected)
               Rejected -> Disconnected (Service provider deletes the connection)
        """
        if actions_required is not None:
            pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[str]:
        """
        Some RP chose "None". Other RPs use this for region expansion.
        """
        return pulumi.get(self, "actions_required")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        User-defined message that, per NRP doc, may be used for approval-related message.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Connection status of the service consumer with the service provider
        Possible state transitions
        Pending -> Approved (Service provider approves the connection request)
        Pending -> Rejected (Service provider rejects the connection request)
        Pending -> Disconnected (Service provider deletes the connection)
        Approved -> Rejected (Service provider rejects the approved connection)
        Approved -> Disconnected (Service provider deletes the connection)
        Rejected -> Pending (Service consumer re-initiates the connection request that was rejected)
        Rejected -> Disconnected (Service provider deletes the connection)
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class RegistryListCredentialsResultResponse(dict):
    def __init__(__self__, *,
                 location: str,
                 username: str,
                 passwords: Optional[Sequence['outputs.PasswordResponse']] = None):
        """
        :param str location: The location of the workspace ACR
        :param str username: The username of the workspace ACR
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "username", username)
        if passwords is not None:
            pulumi.set(__self__, "passwords", passwords)

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The location of the workspace ACR
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username of the workspace ACR
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def passwords(self) -> Optional[Sequence['outputs.PasswordResponse']]:
        return pulumi.get(self, "passwords")


@pulumi.output_type
class ServerlessComputeSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverlessComputeCustomSubnet":
            suggest = "serverless_compute_custom_subnet"
        elif key == "serverlessComputeNoPublicIP":
            suggest = "serverless_compute_no_public_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessComputeSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessComputeSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessComputeSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 serverless_compute_custom_subnet: Optional[str] = None,
                 serverless_compute_no_public_ip: Optional[bool] = None):
        """
        :param str serverless_compute_custom_subnet: The resource ID of an existing virtual network subnet in which serverless compute nodes should be deployed
        :param bool serverless_compute_no_public_ip: The flag to signal if serverless compute nodes deployed in custom vNet would have no public IP addresses for a workspace with private endpoint
        """
        if serverless_compute_custom_subnet is not None:
            pulumi.set(__self__, "serverless_compute_custom_subnet", serverless_compute_custom_subnet)
        if serverless_compute_no_public_ip is not None:
            pulumi.set(__self__, "serverless_compute_no_public_ip", serverless_compute_no_public_ip)

    @property
    @pulumi.getter(name="serverlessComputeCustomSubnet")
    def serverless_compute_custom_subnet(self) -> Optional[str]:
        """
        The resource ID of an existing virtual network subnet in which serverless compute nodes should be deployed
        """
        return pulumi.get(self, "serverless_compute_custom_subnet")

    @property
    @pulumi.getter(name="serverlessComputeNoPublicIP")
    def serverless_compute_no_public_ip(self) -> Optional[bool]:
        """
        The flag to signal if serverless compute nodes deployed in custom vNet would have no public IP addresses for a workspace with private endpoint
        """
        return pulumi.get(self, "serverless_compute_no_public_ip")


@pulumi.output_type
class ServiceManagedResourcesSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cosmosDb":
            suggest = "cosmos_db"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceManagedResourcesSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceManagedResourcesSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceManagedResourcesSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cosmos_db: Optional['outputs.CosmosDbSettingsResponse'] = None):
        if cosmos_db is not None:
            pulumi.set(__self__, "cosmos_db", cosmos_db)

    @property
    @pulumi.getter(name="cosmosDb")
    def cosmos_db(self) -> Optional['outputs.CosmosDbSettingsResponse']:
        return pulumi.get(self, "cosmos_db")


@pulumi.output_type
class ServiceTagDestinationResponse(dict):
    """
    Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPrefixes":
            suggest = "address_prefixes"
        elif key == "portRanges":
            suggest = "port_ranges"
        elif key == "serviceTag":
            suggest = "service_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceTagDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceTagDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceTagDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 address_prefixes: Optional[Sequence[str]] = None,
                 port_ranges: Optional[str] = None,
                 protocol: Optional[str] = None,
                 service_tag: Optional[str] = None):
        """
        Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
        :param str action: The action enum for networking rule.
        :param Sequence[str] address_prefixes: Optional, if provided, the ServiceTag property will be ignored.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if address_prefixes is not None:
            pulumi.set(__self__, "address_prefixes", address_prefixes)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action enum for networking rule.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Optional[Sequence[str]]:
        """
        Optional, if provided, the ServiceTag property will be ignored.
        """
        return pulumi.get(self, "address_prefixes")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[str]:
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        return pulumi.get(self, "service_tag")


@pulumi.output_type
class ServiceTagOutboundRuleResponse(dict):
    """
    Service Tag Outbound Rule for the managed network of a machine learning workspace.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parentRuleNames":
            suggest = "parent_rule_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceTagOutboundRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceTagOutboundRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceTagOutboundRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parent_rule_names: Sequence[str],
                 type: str,
                 category: Optional[str] = None,
                 destination: Optional['outputs.ServiceTagDestinationResponse'] = None,
                 status: Optional[str] = None):
        """
        Service Tag Outbound Rule for the managed network of a machine learning workspace.
        :param str type: Type of a managed network Outbound Rule of a machine learning workspace.
               Expected value is 'ServiceTag'.
        :param str category: Category of a managed network Outbound Rule of a machine learning workspace.
        :param 'ServiceTagDestinationResponse' destination: Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
        :param str status: Type of a managed network Outbound Rule of a machine learning workspace.
        """
        pulumi.set(__self__, "parent_rule_names", parent_rule_names)
        pulumi.set(__self__, "type", 'ServiceTag')
        if category is not None:
            pulumi.set(__self__, "category", category)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="parentRuleNames")
    def parent_rule_names(self) -> Sequence[str]:
        return pulumi.get(self, "parent_rule_names")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        Expected value is 'ServiceTag'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        Category of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.ServiceTagDestinationResponse']:
        """
        Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SharedPrivateLinkResourceResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"
        elif key == "privateLinkResourceId":
            suggest = "private_link_resource_id"
        elif key == "requestMessage":
            suggest = "request_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SharedPrivateLinkResourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SharedPrivateLinkResourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SharedPrivateLinkResourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_id: Optional[str] = None,
                 name: Optional[str] = None,
                 private_link_resource_id: Optional[str] = None,
                 request_message: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str group_id: group id of the private link
        :param str name: Unique name of the private link
        :param str private_link_resource_id: the resource id that private link links to
        :param str request_message: Request message
        :param str status: Connection status of the service consumer with the service provider
               Possible state transitions
               Pending -> Approved (Service provider approves the connection request)
               Pending -> Rejected (Service provider rejects the connection request)
               Pending -> Disconnected (Service provider deletes the connection)
               Approved -> Rejected (Service provider rejects the approved connection)
               Approved -> Disconnected (Service provider deletes the connection)
               Rejected -> Pending (Service consumer re-initiates the connection request that was rejected)
               Rejected -> Disconnected (Service provider deletes the connection)
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_link_resource_id is not None:
            pulumi.set(__self__, "private_link_resource_id", private_link_resource_id)
        if request_message is not None:
            pulumi.set(__self__, "request_message", request_message)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        group id of the private link
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique name of the private link
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateLinkResourceId")
    def private_link_resource_id(self) -> Optional[str]:
        """
        the resource id that private link links to
        """
        return pulumi.get(self, "private_link_resource_id")

    @property
    @pulumi.getter(name="requestMessage")
    def request_message(self) -> Optional[str]:
        """
        Request message
        """
        return pulumi.get(self, "request_message")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Connection status of the service consumer with the service provider
        Possible state transitions
        Pending -> Approved (Service provider approves the connection request)
        Pending -> Rejected (Service provider rejects the connection request)
        Pending -> Disconnected (Service provider deletes the connection)
        Approved -> Rejected (Service provider rejects the approved connection)
        Approved -> Disconnected (Service provider deletes the connection)
        Rejected -> Pending (Service consumer re-initiates the connection request that was rejected)
        Rejected -> Disconnected (Service provider deletes the connection)
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SkuResponse(dict):
    """
    The resource model definition representing SKU
    """
    def __init__(__self__, *,
                 name: str,
                 capacity: Optional[int] = None,
                 family: Optional[str] = None,
                 size: Optional[str] = None,
                 tier: Optional[str] = None):
        """
        The resource model definition representing SKU
        :param str name: The name of the SKU. Ex - P3. It is typically a letter+number code
        :param int capacity: If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        :param str family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
        :param str size: The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        :param str tier: This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the SKU. Ex - P3. It is typically a letter+number code
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def capacity(self) -> Optional[int]:
        """
        If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def family(self) -> Optional[str]:
        """
        If the service has different generations of hardware, for the same SKU, then that can be captured here.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        """
        The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        """
        This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str):
        """
        User assigned identity properties
        :param str client_id: The client ID of the assigned identity.
        :param str principal_id: The principal ID of the assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class WorkspaceHubConfigResponse(dict):
    """
    WorkspaceHub's configuration object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalWorkspaceStorageAccounts":
            suggest = "additional_workspace_storage_accounts"
        elif key == "defaultWorkspaceResourceGroup":
            suggest = "default_workspace_resource_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceHubConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceHubConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceHubConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_workspace_storage_accounts: Optional[Sequence[str]] = None,
                 default_workspace_resource_group: Optional[str] = None):
        """
        WorkspaceHub's configuration object.
        """
        if additional_workspace_storage_accounts is not None:
            pulumi.set(__self__, "additional_workspace_storage_accounts", additional_workspace_storage_accounts)
        if default_workspace_resource_group is not None:
            pulumi.set(__self__, "default_workspace_resource_group", default_workspace_resource_group)

    @property
    @pulumi.getter(name="additionalWorkspaceStorageAccounts")
    def additional_workspace_storage_accounts(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "additional_workspace_storage_accounts")

    @property
    @pulumi.getter(name="defaultWorkspaceResourceGroup")
    def default_workspace_resource_group(self) -> Optional[str]:
        return pulumi.get(self, "default_workspace_resource_group")


@pulumi.output_type
class WorkspacePrivateEndpointResourceResponse(dict):
    """
    The Private Endpoint resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetArmId":
            suggest = "subnet_arm_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspacePrivateEndpointResourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspacePrivateEndpointResourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspacePrivateEndpointResourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 subnet_arm_id: str):
        """
        The Private Endpoint resource.
        :param str id: e.g. /subscriptions/{networkSubscriptionId}/resourceGroups/{rgName}/providers/Microsoft.Network/privateEndpoints/{privateEndpointName}
        :param str subnet_arm_id: The subnetId that the private endpoint is connected to.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "subnet_arm_id", subnet_arm_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        e.g. /subscriptions/{networkSubscriptionId}/resourceGroups/{rgName}/providers/Microsoft.Network/privateEndpoints/{privateEndpointName}
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="subnetArmId")
    def subnet_arm_id(self) -> str:
        """
        The subnetId that the private endpoint is connected to.
        """
        return pulumi.get(self, "subnet_arm_id")


