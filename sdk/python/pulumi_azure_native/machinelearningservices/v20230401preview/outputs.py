# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AllNodesResponse',
    'AmlTokenResponse',
    'AutoDeleteSettingResponse',
    'AzureDevOpsWebhookResponse',
    'ComputeRuntimeDtoResponse',
    'CosmosDbSettingsResponse',
    'EncryptionKeyVaultPropertiesResponse',
    'EncryptionPropertyResponse',
    'FeatureStoreSettingsResponse',
    'FeatureWindowResponse',
    'FeaturesetContainerResponse',
    'FeaturesetJobResponse',
    'FeaturesetSpecificationResponse',
    'FeaturesetVersionResponse',
    'FeaturestoreEntityContainerResponse',
    'FeaturestoreEntityVersionResponse',
    'FqdnOutboundRuleResponse',
    'IdentityForCmkResponse',
    'IndexColumnResponse',
    'JobServiceResponse',
    'LabelCategoryResponse',
    'LabelClassResponse',
    'LabelingDataConfigurationResponse',
    'LabelingJobImagePropertiesResponse',
    'LabelingJobInstructionsResponse',
    'LabelingJobResponse',
    'LabelingJobTextPropertiesResponse',
    'ListNotebookKeysResultResponse',
    'MLAssistConfigurationDisabledResponse',
    'MLAssistConfigurationEnabledResponse',
    'ManagedIdentityResponse',
    'ManagedNetworkProvisionStatusResponse',
    'ManagedNetworkSettingsResponse',
    'ManagedServiceIdentityResponse',
    'MaterializationComputeResourceResponse',
    'MaterializationSettingsResponse',
    'NotebookPreparationErrorResponse',
    'NotebookResourceInfoResponse',
    'NotificationSettingResponse',
    'PasswordResponse',
    'PrivateEndpointConnectionResponse',
    'PrivateEndpointDestinationResponse',
    'PrivateEndpointOutboundRuleResponse',
    'PrivateEndpointResponse',
    'PrivateLinkServiceConnectionStateResponse',
    'ProgressMetricsResponse',
    'RecurrenceScheduleResponse',
    'RecurrenceTriggerResponse',
    'RegistryListCredentialsResultResponse',
    'SecretConfigurationResponse',
    'ServiceManagedResourcesSettingsResponse',
    'ServiceTagDestinationResponse',
    'ServiceTagOutboundRuleResponse',
    'SharedPrivateLinkResourceResponse',
    'SkuResponse',
    'StatusMessageResponse',
    'SystemDataResponse',
    'UserAssignedIdentityResponse',
    'UserIdentityResponse',
]

@pulumi.output_type
class AllNodesResponse(dict):
    """
    All nodes means the service will be running on all of the nodes of the job
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodesValueType":
            suggest = "nodes_value_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AllNodesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AllNodesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AllNodesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nodes_value_type: str):
        """
        All nodes means the service will be running on all of the nodes of the job
        :param str nodes_value_type: The enumerated types for the nodes value
               Expected value is 'All'.
        """
        pulumi.set(__self__, "nodes_value_type", 'All')

    @property
    @pulumi.getter(name="nodesValueType")
    def nodes_value_type(self) -> str:
        """
        The enumerated types for the nodes value
        Expected value is 'All'.
        """
        return pulumi.get(self, "nodes_value_type")


@pulumi.output_type
class AmlTokenResponse(dict):
    """
    AML Token identity configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityType":
            suggest = "identity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmlTokenResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmlTokenResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmlTokenResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_type: str):
        """
        AML Token identity configuration.
        :param str identity_type: Enum to determine identity framework.
               Expected value is 'AMLToken'.
        """
        pulumi.set(__self__, "identity_type", 'AMLToken')

    @property
    @pulumi.getter(name="identityType")
    def identity_type(self) -> str:
        """
        Enum to determine identity framework.
        Expected value is 'AMLToken'.
        """
        return pulumi.get(self, "identity_type")


@pulumi.output_type
class AutoDeleteSettingResponse(dict):
    def __init__(__self__, *,
                 condition: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str condition: When to check if an asset is expired
        :param str value: Expiration condition value.
        """
        if condition is None:
            condition = 'CreatedGreaterThan'
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        When to check if an asset is expired
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Expiration condition value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AzureDevOpsWebhookResponse(dict):
    """
    Webhook details specific for Azure DevOps
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "webhookType":
            suggest = "webhook_type"
        elif key == "eventType":
            suggest = "event_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureDevOpsWebhookResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureDevOpsWebhookResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureDevOpsWebhookResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 webhook_type: str,
                 event_type: Optional[str] = None):
        """
        Webhook details specific for Azure DevOps
        :param str webhook_type: Enum to determine the webhook callback service type.
               Expected value is 'AzureDevOps'.
        :param str event_type: Send callback on a specified notification event
        """
        pulumi.set(__self__, "webhook_type", 'AzureDevOps')
        if event_type is not None:
            pulumi.set(__self__, "event_type", event_type)

    @property
    @pulumi.getter(name="webhookType")
    def webhook_type(self) -> str:
        """
        Enum to determine the webhook callback service type.
        Expected value is 'AzureDevOps'.
        """
        return pulumi.get(self, "webhook_type")

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> Optional[str]:
        """
        Send callback on a specified notification event
        """
        return pulumi.get(self, "event_type")


@pulumi.output_type
class ComputeRuntimeDtoResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sparkRuntimeVersion":
            suggest = "spark_runtime_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeRuntimeDtoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeRuntimeDtoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeRuntimeDtoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 spark_runtime_version: Optional[str] = None):
        if spark_runtime_version is not None:
            pulumi.set(__self__, "spark_runtime_version", spark_runtime_version)

    @property
    @pulumi.getter(name="sparkRuntimeVersion")
    def spark_runtime_version(self) -> Optional[str]:
        return pulumi.get(self, "spark_runtime_version")


@pulumi.output_type
class CosmosDbSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionsThroughput":
            suggest = "collections_throughput"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CosmosDbSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CosmosDbSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CosmosDbSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collections_throughput: Optional[int] = None):
        """
        :param int collections_throughput: The throughput of the collections in cosmosdb database
        """
        if collections_throughput is not None:
            pulumi.set(__self__, "collections_throughput", collections_throughput)

    @property
    @pulumi.getter(name="collectionsThroughput")
    def collections_throughput(self) -> Optional[int]:
        """
        The throughput of the collections in cosmosdb database
        """
        return pulumi.get(self, "collections_throughput")


@pulumi.output_type
class EncryptionKeyVaultPropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyIdentifier":
            suggest = "key_identifier"
        elif key == "keyVaultArmId":
            suggest = "key_vault_arm_id"
        elif key == "identityClientId":
            suggest = "identity_client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionKeyVaultPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionKeyVaultPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionKeyVaultPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_identifier: str,
                 key_vault_arm_id: str,
                 identity_client_id: Optional[str] = None):
        """
        :param str key_identifier: Key vault uri to access the encryption key.
        :param str key_vault_arm_id: The ArmId of the keyVault where the customer owned encryption key is present.
        :param str identity_client_id: For future use - The client id of the identity which will be used to access key vault.
        """
        pulumi.set(__self__, "key_identifier", key_identifier)
        pulumi.set(__self__, "key_vault_arm_id", key_vault_arm_id)
        if identity_client_id is not None:
            pulumi.set(__self__, "identity_client_id", identity_client_id)

    @property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> str:
        """
        Key vault uri to access the encryption key.
        """
        return pulumi.get(self, "key_identifier")

    @property
    @pulumi.getter(name="keyVaultArmId")
    def key_vault_arm_id(self) -> str:
        """
        The ArmId of the keyVault where the customer owned encryption key is present.
        """
        return pulumi.get(self, "key_vault_arm_id")

    @property
    @pulumi.getter(name="identityClientId")
    def identity_client_id(self) -> Optional[str]:
        """
        For future use - The client id of the identity which will be used to access key vault.
        """
        return pulumi.get(self, "identity_client_id")


@pulumi.output_type
class EncryptionPropertyResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultProperties":
            suggest = "key_vault_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionPropertyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionPropertyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionPropertyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_properties: 'outputs.EncryptionKeyVaultPropertiesResponse',
                 status: str,
                 identity: Optional['outputs.IdentityForCmkResponse'] = None):
        """
        :param 'EncryptionKeyVaultPropertiesResponse' key_vault_properties: Customer Key vault properties.
        :param str status: Indicates whether or not the encryption is enabled for the workspace.
        :param 'IdentityForCmkResponse' identity: The identity that will be used to access the key vault for encryption at rest.
        """
        pulumi.set(__self__, "key_vault_properties", key_vault_properties)
        pulumi.set(__self__, "status", status)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)

    @property
    @pulumi.getter(name="keyVaultProperties")
    def key_vault_properties(self) -> 'outputs.EncryptionKeyVaultPropertiesResponse':
        """
        Customer Key vault properties.
        """
        return pulumi.get(self, "key_vault_properties")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Indicates whether or not the encryption is enabled for the workspace.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def identity(self) -> Optional['outputs.IdentityForCmkResponse']:
        """
        The identity that will be used to access the key vault for encryption at rest.
        """
        return pulumi.get(self, "identity")


@pulumi.output_type
class FeatureStoreSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeRuntime":
            suggest = "compute_runtime"
        elif key == "offlineStoreConnectionName":
            suggest = "offline_store_connection_name"
        elif key == "onlineStoreConnectionName":
            suggest = "online_store_connection_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureStoreSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureStoreSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureStoreSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_runtime: Optional['outputs.ComputeRuntimeDtoResponse'] = None,
                 offline_store_connection_name: Optional[str] = None,
                 online_store_connection_name: Optional[str] = None):
        if compute_runtime is not None:
            pulumi.set(__self__, "compute_runtime", compute_runtime)
        if offline_store_connection_name is not None:
            pulumi.set(__self__, "offline_store_connection_name", offline_store_connection_name)
        if online_store_connection_name is not None:
            pulumi.set(__self__, "online_store_connection_name", online_store_connection_name)

    @property
    @pulumi.getter(name="computeRuntime")
    def compute_runtime(self) -> Optional['outputs.ComputeRuntimeDtoResponse']:
        return pulumi.get(self, "compute_runtime")

    @property
    @pulumi.getter(name="offlineStoreConnectionName")
    def offline_store_connection_name(self) -> Optional[str]:
        return pulumi.get(self, "offline_store_connection_name")

    @property
    @pulumi.getter(name="onlineStoreConnectionName")
    def online_store_connection_name(self) -> Optional[str]:
        return pulumi.get(self, "online_store_connection_name")


@pulumi.output_type
class FeatureWindowResponse(dict):
    """
    Specifies the feature window
    """
    def __init__(__self__, *,
                 feature_window_end: Optional[str] = None,
                 feature_window_start: Optional[str] = None):
        """
        Specifies the feature window
        :param str feature_window_end: Specifies the feature window end time
        :param str feature_window_start: Specifies the feature window start time
        """
        if feature_window_end is not None:
            pulumi.set(__self__, "feature_window_end", feature_window_end)
        if feature_window_start is not None:
            pulumi.set(__self__, "feature_window_start", feature_window_start)

    @property
    @pulumi.getter(name="featureWindowEnd")
    def feature_window_end(self) -> Optional[str]:
        """
        Specifies the feature window end time
        """
        return pulumi.get(self, "feature_window_end")

    @property
    @pulumi.getter(name="featureWindowStart")
    def feature_window_start(self) -> Optional[str]:
        """
        Specifies the feature window start time
        """
        return pulumi.get(self, "feature_window_start")


@pulumi.output_type
class FeaturesetContainerResponse(dict):
    """
    Dto object representing feature set
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latestVersion":
            suggest = "latest_version"
        elif key == "nextVersion":
            suggest = "next_version"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeaturesetContainerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeaturesetContainerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeaturesetContainerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latest_version: str,
                 next_version: str,
                 provisioning_state: str,
                 description: Optional[str] = None,
                 is_archived: Optional[bool] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Dto object representing feature set
        :param str latest_version: The latest version inside this container.
        :param str next_version: The next auto incremental version
        :param str provisioning_state: Provisioning state for the featureset container.
        :param str description: The asset description text.
        :param bool is_archived: Is the asset archived?
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "latest_version", latest_version)
        pulumi.set(__self__, "next_version", next_version)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> str:
        """
        The latest version inside this container.
        """
        return pulumi.get(self, "latest_version")

    @property
    @pulumi.getter(name="nextVersion")
    def next_version(self) -> str:
        """
        The next auto incremental version
        """
        return pulumi.get(self, "next_version")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning state for the featureset container.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class FeaturesetJobResponse(dict):
    """
    Dto object representing the feature set job
    """
    def __init__(__self__, *,
                 created_date: Optional[str] = None,
                 display_name: Optional[str] = None,
                 duration: Optional[str] = None,
                 experiment_id: Optional[str] = None,
                 feature_window: Optional['outputs.FeatureWindowResponse'] = None,
                 job_id: Optional[str] = None,
                 status: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 type: Optional[str] = None):
        """
        Dto object representing the feature set job
        :param str created_date: Specifies the created date
        :param str display_name: Specifies the display name
        :param str duration: Specifies the duration
        :param str experiment_id: Specifies the experiment id
        :param 'FeatureWindowResponse' feature_window: Specifies the backfill feature window to be materialized
        :param str job_id: Specifies the job id
        :param str status: Specifies the job status
        :param Mapping[str, str] tags: Specifies the tags if any
        :param str type: Specifies the feature store job type
        """
        if created_date is not None:
            pulumi.set(__self__, "created_date", created_date)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if experiment_id is not None:
            pulumi.set(__self__, "experiment_id", experiment_id)
        if feature_window is not None:
            pulumi.set(__self__, "feature_window", feature_window)
        if job_id is not None:
            pulumi.set(__self__, "job_id", job_id)
        if status is None:
            status = 'Unknown'
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is None:
            type = 'RecurrentMaterialization'
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> Optional[str]:
        """
        Specifies the created date
        """
        return pulumi.get(self, "created_date")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Specifies the display name
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        Specifies the duration
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="experimentId")
    def experiment_id(self) -> Optional[str]:
        """
        Specifies the experiment id
        """
        return pulumi.get(self, "experiment_id")

    @property
    @pulumi.getter(name="featureWindow")
    def feature_window(self) -> Optional['outputs.FeatureWindowResponse']:
        """
        Specifies the backfill feature window to be materialized
        """
        return pulumi.get(self, "feature_window")

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> Optional[str]:
        """
        Specifies the job id
        """
        return pulumi.get(self, "job_id")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Specifies the job status
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Specifies the tags if any
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Specifies the feature store job type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FeaturesetSpecificationResponse(dict):
    """
    Dto object representing specification
    """
    def __init__(__self__, *,
                 path: Optional[str] = None):
        """
        Dto object representing specification
        :param str path: Specifies the spec path
        """
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Specifies the spec path
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class FeaturesetVersionResponse(dict):
    """
    Dto object representing feature set version
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "autoDeleteSetting":
            suggest = "auto_delete_setting"
        elif key == "isAnonymous":
            suggest = "is_anonymous"
        elif key == "isArchived":
            suggest = "is_archived"
        elif key == "materializationSettings":
            suggest = "materialization_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeaturesetVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeaturesetVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeaturesetVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 auto_delete_setting: Optional['outputs.AutoDeleteSettingResponse'] = None,
                 description: Optional[str] = None,
                 entities: Optional[Sequence[str]] = None,
                 is_anonymous: Optional[bool] = None,
                 is_archived: Optional[bool] = None,
                 materialization_settings: Optional['outputs.MaterializationSettingsResponse'] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 specification: Optional['outputs.FeaturesetSpecificationResponse'] = None,
                 stage: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Dto object representing feature set version
        :param str provisioning_state: Provisioning state for the featureset version container.
        :param 'AutoDeleteSettingResponse' auto_delete_setting: Specifies the lifecycle setting of managed data asset.
        :param str description: The asset description text.
        :param Sequence[str] entities: Specifies list of entities
        :param bool is_anonymous: If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
        :param bool is_archived: Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
        :param 'MaterializationSettingsResponse' materialization_settings: Specifies the materialization settings
        :param Mapping[str, str] properties: The asset property dictionary.
        :param 'FeaturesetSpecificationResponse' specification: Specifies the feature spec details
        :param str stage: Specifies the asset stage
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if auto_delete_setting is not None:
            pulumi.set(__self__, "auto_delete_setting", auto_delete_setting)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if is_anonymous is None:
            is_anonymous = False
        if is_anonymous is not None:
            pulumi.set(__self__, "is_anonymous", is_anonymous)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if materialization_settings is not None:
            pulumi.set(__self__, "materialization_settings", materialization_settings)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if specification is not None:
            pulumi.set(__self__, "specification", specification)
        if stage is not None:
            pulumi.set(__self__, "stage", stage)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning state for the featureset version container.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="autoDeleteSetting")
    def auto_delete_setting(self) -> Optional['outputs.AutoDeleteSettingResponse']:
        """
        Specifies the lifecycle setting of managed data asset.
        """
        return pulumi.get(self, "auto_delete_setting")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def entities(self) -> Optional[Sequence[str]]:
        """
        Specifies list of entities
        """
        return pulumi.get(self, "entities")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[bool]:
        """
        If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[bool]:
        """
        Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter(name="materializationSettings")
    def materialization_settings(self) -> Optional['outputs.MaterializationSettingsResponse']:
        """
        Specifies the materialization settings
        """
        return pulumi.get(self, "materialization_settings")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def specification(self) -> Optional['outputs.FeaturesetSpecificationResponse']:
        """
        Specifies the feature spec details
        """
        return pulumi.get(self, "specification")

    @property
    @pulumi.getter
    def stage(self) -> Optional[str]:
        """
        Specifies the asset stage
        """
        return pulumi.get(self, "stage")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class FeaturestoreEntityContainerResponse(dict):
    """
    Dto object representing feature entity
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latestVersion":
            suggest = "latest_version"
        elif key == "nextVersion":
            suggest = "next_version"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeaturestoreEntityContainerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeaturestoreEntityContainerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeaturestoreEntityContainerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latest_version: str,
                 next_version: str,
                 provisioning_state: str,
                 description: Optional[str] = None,
                 is_archived: Optional[bool] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Dto object representing feature entity
        :param str latest_version: The latest version inside this container.
        :param str next_version: The next auto incremental version
        :param str provisioning_state: Provisioning state for the featurestore entity container.
        :param str description: The asset description text.
        :param bool is_archived: Is the asset archived?
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "latest_version", latest_version)
        pulumi.set(__self__, "next_version", next_version)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> str:
        """
        The latest version inside this container.
        """
        return pulumi.get(self, "latest_version")

    @property
    @pulumi.getter(name="nextVersion")
    def next_version(self) -> str:
        """
        The next auto incremental version
        """
        return pulumi.get(self, "next_version")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning state for the featurestore entity container.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class FeaturestoreEntityVersionResponse(dict):
    """
    Dto object representing feature entity version
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "autoDeleteSetting":
            suggest = "auto_delete_setting"
        elif key == "indexColumns":
            suggest = "index_columns"
        elif key == "isAnonymous":
            suggest = "is_anonymous"
        elif key == "isArchived":
            suggest = "is_archived"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeaturestoreEntityVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeaturestoreEntityVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeaturestoreEntityVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 auto_delete_setting: Optional['outputs.AutoDeleteSettingResponse'] = None,
                 description: Optional[str] = None,
                 index_columns: Optional[Sequence['outputs.IndexColumnResponse']] = None,
                 is_anonymous: Optional[bool] = None,
                 is_archived: Optional[bool] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 stage: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Dto object representing feature entity version
        :param str provisioning_state: Provisioning state for the featurestore entity version.
        :param 'AutoDeleteSettingResponse' auto_delete_setting: Specifies the lifecycle setting of managed data asset.
        :param str description: The asset description text.
        :param Sequence['IndexColumnResponse'] index_columns: Specifies index columns
        :param bool is_anonymous: If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
        :param bool is_archived: Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
        :param Mapping[str, str] properties: The asset property dictionary.
        :param str stage: Specifies the asset stage
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if auto_delete_setting is not None:
            pulumi.set(__self__, "auto_delete_setting", auto_delete_setting)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if index_columns is not None:
            pulumi.set(__self__, "index_columns", index_columns)
        if is_anonymous is None:
            is_anonymous = False
        if is_anonymous is not None:
            pulumi.set(__self__, "is_anonymous", is_anonymous)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if stage is not None:
            pulumi.set(__self__, "stage", stage)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning state for the featurestore entity version.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="autoDeleteSetting")
    def auto_delete_setting(self) -> Optional['outputs.AutoDeleteSettingResponse']:
        """
        Specifies the lifecycle setting of managed data asset.
        """
        return pulumi.get(self, "auto_delete_setting")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="indexColumns")
    def index_columns(self) -> Optional[Sequence['outputs.IndexColumnResponse']]:
        """
        Specifies index columns
        """
        return pulumi.get(self, "index_columns")

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[bool]:
        """
        If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
        """
        return pulumi.get(self, "is_anonymous")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[bool]:
        """
        Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def stage(self) -> Optional[str]:
        """
        Specifies the asset stage
        """
        return pulumi.get(self, "stage")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class FqdnOutboundRuleResponse(dict):
    """
    FQDN Outbound Rule for the managed network of a machine learning workspace.
    """
    def __init__(__self__, *,
                 type: str,
                 category: Optional[str] = None,
                 destination: Optional[str] = None,
                 status: Optional[str] = None):
        """
        FQDN Outbound Rule for the managed network of a machine learning workspace.
        :param str type: Type of a managed network Outbound Rule of a machine learning workspace.
               Expected value is 'FQDN'.
        :param str category: Category of a managed network Outbound Rule of a machine learning workspace.
        :param str status: Status of a managed network Outbound Rule of a machine learning workspace.
        """
        pulumi.set(__self__, "type", 'FQDN')
        if category is not None:
            pulumi.set(__self__, "category", category)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        Expected value is 'FQDN'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        Category of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class IdentityForCmkResponse(dict):
    """
    Identity that will be used to access key vault for encryption at rest
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userAssignedIdentity":
            suggest = "user_assigned_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityForCmkResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityForCmkResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityForCmkResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_assigned_identity: Optional[str] = None):
        """
        Identity that will be used to access key vault for encryption at rest
        :param str user_assigned_identity: The ArmId of the user assigned identity that will be used to access the customer managed key vault
        """
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[str]:
        """
        The ArmId of the user assigned identity that will be used to access the customer managed key vault
        """
        return pulumi.get(self, "user_assigned_identity")


@pulumi.output_type
class IndexColumnResponse(dict):
    """
    Dto object representing index column
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"
        elif key == "dataType":
            suggest = "data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IndexColumnResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IndexColumnResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IndexColumnResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: Optional[str] = None,
                 data_type: Optional[str] = None):
        """
        Dto object representing index column
        :param str column_name: Specifies the column name
        :param str data_type: Specifies the data type
        """
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)
        if data_type is None:
            data_type = 'String'
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[str]:
        """
        Specifies the column name
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[str]:
        """
        Specifies the data type
        """
        return pulumi.get(self, "data_type")


@pulumi.output_type
class JobServiceResponse(dict):
    """
    Job endpoint definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"
        elif key == "jobServiceType":
            suggest = "job_service_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobServiceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobServiceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobServiceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_message: str,
                 status: str,
                 endpoint: Optional[str] = None,
                 job_service_type: Optional[str] = None,
                 nodes: Optional['outputs.AllNodesResponse'] = None,
                 port: Optional[int] = None,
                 properties: Optional[Mapping[str, str]] = None):
        """
        Job endpoint definition
        :param str error_message: Any error in the service.
        :param str status: Status of endpoint.
        :param str endpoint: Url for endpoint.
        :param str job_service_type: Endpoint type.
        :param 'AllNodesResponse' nodes: Nodes that user would like to start the service on.
               If Nodes is not set or set to null, the service will only be started on leader node.
        :param int port: Port for endpoint set by user.
        :param Mapping[str, str] properties: Additional properties to set on the endpoint.
        """
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "status", status)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if job_service_type is not None:
            pulumi.set(__self__, "job_service_type", job_service_type)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        """
        Any error in the service.
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of endpoint.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        Url for endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="jobServiceType")
    def job_service_type(self) -> Optional[str]:
        """
        Endpoint type.
        """
        return pulumi.get(self, "job_service_type")

    @property
    @pulumi.getter
    def nodes(self) -> Optional['outputs.AllNodesResponse']:
        """
        Nodes that user would like to start the service on.
        If Nodes is not set or set to null, the service will only be started on leader node.
        """
        return pulumi.get(self, "nodes")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port for endpoint set by user.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        Additional properties to set on the endpoint.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class LabelCategoryResponse(dict):
    """
    Label category definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "multiSelect":
            suggest = "multi_select"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LabelCategoryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LabelCategoryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LabelCategoryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classes: Optional[Mapping[str, 'outputs.LabelClassResponse']] = None,
                 display_name: Optional[str] = None,
                 multi_select: Optional[str] = None):
        """
        Label category definition
        :param Mapping[str, 'LabelClassResponse'] classes: Dictionary of label classes in this category.
        :param str display_name: Display name of the label category.
        :param str multi_select: Indicates whether it is allowed to select multiple classes in this category.
        """
        if classes is not None:
            pulumi.set(__self__, "classes", classes)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if multi_select is None:
            multi_select = 'Disabled'
        if multi_select is not None:
            pulumi.set(__self__, "multi_select", multi_select)

    @property
    @pulumi.getter
    def classes(self) -> Optional[Mapping[str, 'outputs.LabelClassResponse']]:
        """
        Dictionary of label classes in this category.
        """
        return pulumi.get(self, "classes")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Display name of the label category.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="multiSelect")
    def multi_select(self) -> Optional[str]:
        """
        Indicates whether it is allowed to select multiple classes in this category.
        """
        return pulumi.get(self, "multi_select")


@pulumi.output_type
class LabelClassResponse(dict):
    """
    Label class definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LabelClassResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LabelClassResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LabelClassResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 subclasses: Optional[Mapping[str, 'outputs.LabelClassResponse']] = None):
        """
        Label class definition
        :param str display_name: Display name of the label class.
        :param Mapping[str, 'LabelClassResponse'] subclasses: Dictionary of subclasses of the label class.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if subclasses is not None:
            pulumi.set(__self__, "subclasses", subclasses)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Display name of the label class.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def subclasses(self) -> Optional[Mapping[str, 'outputs.LabelClassResponse']]:
        """
        Dictionary of subclasses of the label class.
        """
        return pulumi.get(self, "subclasses")


@pulumi.output_type
class LabelingDataConfigurationResponse(dict):
    """
    Labeling data configuration definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataId":
            suggest = "data_id"
        elif key == "incrementalDataRefresh":
            suggest = "incremental_data_refresh"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LabelingDataConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LabelingDataConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LabelingDataConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_id: Optional[str] = None,
                 incremental_data_refresh: Optional[str] = None):
        """
        Labeling data configuration definition
        :param str data_id: Resource Id of the data asset to perform labeling.
        :param str incremental_data_refresh: Indicates whether to enable incremental data refresh.
        """
        if data_id is not None:
            pulumi.set(__self__, "data_id", data_id)
        if incremental_data_refresh is None:
            incremental_data_refresh = 'Disabled'
        if incremental_data_refresh is not None:
            pulumi.set(__self__, "incremental_data_refresh", incremental_data_refresh)

    @property
    @pulumi.getter(name="dataId")
    def data_id(self) -> Optional[str]:
        """
        Resource Id of the data asset to perform labeling.
        """
        return pulumi.get(self, "data_id")

    @property
    @pulumi.getter(name="incrementalDataRefresh")
    def incremental_data_refresh(self) -> Optional[str]:
        """
        Indicates whether to enable incremental data refresh.
        """
        return pulumi.get(self, "incremental_data_refresh")


@pulumi.output_type
class LabelingJobImagePropertiesResponse(dict):
    """
    Properties of a labeling job for image data
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mediaType":
            suggest = "media_type"
        elif key == "annotationType":
            suggest = "annotation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LabelingJobImagePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LabelingJobImagePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LabelingJobImagePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 media_type: str,
                 annotation_type: Optional[str] = None):
        """
        Properties of a labeling job for image data
        :param str media_type: Media type of data asset.
               Expected value is 'Image'.
        :param str annotation_type: Annotation type of image labeling job.
        """
        pulumi.set(__self__, "media_type", 'Image')
        if annotation_type is None:
            annotation_type = 'Classification'
        if annotation_type is not None:
            pulumi.set(__self__, "annotation_type", annotation_type)

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> str:
        """
        Media type of data asset.
        Expected value is 'Image'.
        """
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter(name="annotationType")
    def annotation_type(self) -> Optional[str]:
        """
        Annotation type of image labeling job.
        """
        return pulumi.get(self, "annotation_type")


@pulumi.output_type
class LabelingJobInstructionsResponse(dict):
    """
    Instructions for labeling job
    """
    def __init__(__self__, *,
                 uri: Optional[str] = None):
        """
        Instructions for labeling job
        :param str uri: The link to a page with detailed labeling instructions for labelers.
        """
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        The link to a page with detailed labeling instructions for labelers.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class LabelingJobResponse(dict):
    """
    Labeling job definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdDateTime":
            suggest = "created_date_time"
        elif key == "jobType":
            suggest = "job_type"
        elif key == "progressMetrics":
            suggest = "progress_metrics"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "statusMessages":
            suggest = "status_messages"
        elif key == "componentId":
            suggest = "component_id"
        elif key == "computeId":
            suggest = "compute_id"
        elif key == "dataConfiguration":
            suggest = "data_configuration"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "experimentName":
            suggest = "experiment_name"
        elif key == "isArchived":
            suggest = "is_archived"
        elif key == "jobInstructions":
            suggest = "job_instructions"
        elif key == "labelCategories":
            suggest = "label_categories"
        elif key == "labelingJobMediaProperties":
            suggest = "labeling_job_media_properties"
        elif key == "mlAssistConfiguration":
            suggest = "ml_assist_configuration"
        elif key == "notificationSetting":
            suggest = "notification_setting"
        elif key == "secretsConfiguration":
            suggest = "secrets_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LabelingJobResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LabelingJobResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LabelingJobResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_date_time: str,
                 job_type: str,
                 progress_metrics: 'outputs.ProgressMetricsResponse',
                 project_id: str,
                 provisioning_state: str,
                 status: str,
                 status_messages: Sequence['outputs.StatusMessageResponse'],
                 component_id: Optional[str] = None,
                 compute_id: Optional[str] = None,
                 data_configuration: Optional['outputs.LabelingDataConfigurationResponse'] = None,
                 description: Optional[str] = None,
                 display_name: Optional[str] = None,
                 experiment_name: Optional[str] = None,
                 identity: Optional[Any] = None,
                 is_archived: Optional[bool] = None,
                 job_instructions: Optional['outputs.LabelingJobInstructionsResponse'] = None,
                 label_categories: Optional[Mapping[str, 'outputs.LabelCategoryResponse']] = None,
                 labeling_job_media_properties: Optional[Any] = None,
                 ml_assist_configuration: Optional[Any] = None,
                 notification_setting: Optional['outputs.NotificationSettingResponse'] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 secrets_configuration: Optional[Mapping[str, 'outputs.SecretConfigurationResponse']] = None,
                 services: Optional[Mapping[str, 'outputs.JobServiceResponse']] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Labeling job definition
        :param str created_date_time: Created time of the job in UTC timezone.
        :param str job_type: Enum to determine the type of job.
               Expected value is 'Labeling'.
        :param 'ProgressMetricsResponse' progress_metrics: Progress metrics of the job.
        :param str project_id: Internal id of the job(Previously called project).
        :param str provisioning_state: Specifies the labeling job provisioning state.
        :param str status: Status of the job.
        :param Sequence['StatusMessageResponse'] status_messages: Status messages of the job.
        :param str component_id: ARM resource ID of the component resource.
        :param str compute_id: ARM resource ID of the compute resource.
        :param 'LabelingDataConfigurationResponse' data_configuration: Configuration of data used in the job.
        :param str description: The asset description text.
        :param str display_name: Display name of job.
        :param str experiment_name: The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        :param Union['AmlTokenResponse', 'ManagedIdentityResponse', 'UserIdentityResponse'] identity: Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
               Defaults to AmlToken if null.
        :param bool is_archived: Is the asset archived?
        :param 'LabelingJobInstructionsResponse' job_instructions: Labeling instructions of the job.
        :param Mapping[str, 'LabelCategoryResponse'] label_categories: Label categories of the job.
        :param Union['LabelingJobImagePropertiesResponse', 'LabelingJobTextPropertiesResponse'] labeling_job_media_properties: Media type specific properties in the job.
        :param Union['MLAssistConfigurationDisabledResponse', 'MLAssistConfigurationEnabledResponse'] ml_assist_configuration: Configuration of MLAssist feature in the job.
        :param 'NotificationSettingResponse' notification_setting: Notification setting for the job
        :param Mapping[str, str] properties: The asset property dictionary.
        :param Mapping[str, 'SecretConfigurationResponse'] secrets_configuration: Configuration for secrets to be made available during runtime.
        :param Mapping[str, 'JobServiceResponse'] services: List of JobEndpoints.
               For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        :param Mapping[str, str] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "created_date_time", created_date_time)
        pulumi.set(__self__, "job_type", 'Labeling')
        pulumi.set(__self__, "progress_metrics", progress_metrics)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_messages", status_messages)
        if component_id is not None:
            pulumi.set(__self__, "component_id", component_id)
        if compute_id is not None:
            pulumi.set(__self__, "compute_id", compute_id)
        if data_configuration is not None:
            pulumi.set(__self__, "data_configuration", data_configuration)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if experiment_name is None:
            experiment_name = 'Default'
        if experiment_name is not None:
            pulumi.set(__self__, "experiment_name", experiment_name)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if job_instructions is not None:
            pulumi.set(__self__, "job_instructions", job_instructions)
        if label_categories is not None:
            pulumi.set(__self__, "label_categories", label_categories)
        if labeling_job_media_properties is not None:
            pulumi.set(__self__, "labeling_job_media_properties", labeling_job_media_properties)
        if ml_assist_configuration is not None:
            pulumi.set(__self__, "ml_assist_configuration", ml_assist_configuration)
        if notification_setting is not None:
            pulumi.set(__self__, "notification_setting", notification_setting)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if secrets_configuration is not None:
            pulumi.set(__self__, "secrets_configuration", secrets_configuration)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="createdDateTime")
    def created_date_time(self) -> str:
        """
        Created time of the job in UTC timezone.
        """
        return pulumi.get(self, "created_date_time")

    @property
    @pulumi.getter(name="jobType")
    def job_type(self) -> str:
        """
        Enum to determine the type of job.
        Expected value is 'Labeling'.
        """
        return pulumi.get(self, "job_type")

    @property
    @pulumi.getter(name="progressMetrics")
    def progress_metrics(self) -> 'outputs.ProgressMetricsResponse':
        """
        Progress metrics of the job.
        """
        return pulumi.get(self, "progress_metrics")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Internal id of the job(Previously called project).
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Specifies the labeling job provisioning state.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the job.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusMessages")
    def status_messages(self) -> Sequence['outputs.StatusMessageResponse']:
        """
        Status messages of the job.
        """
        return pulumi.get(self, "status_messages")

    @property
    @pulumi.getter(name="componentId")
    def component_id(self) -> Optional[str]:
        """
        ARM resource ID of the component resource.
        """
        return pulumi.get(self, "component_id")

    @property
    @pulumi.getter(name="computeId")
    def compute_id(self) -> Optional[str]:
        """
        ARM resource ID of the compute resource.
        """
        return pulumi.get(self, "compute_id")

    @property
    @pulumi.getter(name="dataConfiguration")
    def data_configuration(self) -> Optional['outputs.LabelingDataConfigurationResponse']:
        """
        Configuration of data used in the job.
        """
        return pulumi.get(self, "data_configuration")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Display name of job.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="experimentName")
    def experiment_name(self) -> Optional[str]:
        """
        The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        """
        return pulumi.get(self, "experiment_name")

    @property
    @pulumi.getter
    def identity(self) -> Optional[Any]:
        """
        Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
        Defaults to AmlToken if null.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[bool]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @property
    @pulumi.getter(name="jobInstructions")
    def job_instructions(self) -> Optional['outputs.LabelingJobInstructionsResponse']:
        """
        Labeling instructions of the job.
        """
        return pulumi.get(self, "job_instructions")

    @property
    @pulumi.getter(name="labelCategories")
    def label_categories(self) -> Optional[Mapping[str, 'outputs.LabelCategoryResponse']]:
        """
        Label categories of the job.
        """
        return pulumi.get(self, "label_categories")

    @property
    @pulumi.getter(name="labelingJobMediaProperties")
    def labeling_job_media_properties(self) -> Optional[Any]:
        """
        Media type specific properties in the job.
        """
        return pulumi.get(self, "labeling_job_media_properties")

    @property
    @pulumi.getter(name="mlAssistConfiguration")
    def ml_assist_configuration(self) -> Optional[Any]:
        """
        Configuration of MLAssist feature in the job.
        """
        return pulumi.get(self, "ml_assist_configuration")

    @property
    @pulumi.getter(name="notificationSetting")
    def notification_setting(self) -> Optional['outputs.NotificationSettingResponse']:
        """
        Notification setting for the job
        """
        return pulumi.get(self, "notification_setting")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="secretsConfiguration")
    def secrets_configuration(self) -> Optional[Mapping[str, 'outputs.SecretConfigurationResponse']]:
        """
        Configuration for secrets to be made available during runtime.
        """
        return pulumi.get(self, "secrets_configuration")

    @property
    @pulumi.getter
    def services(self) -> Optional[Mapping[str, 'outputs.JobServiceResponse']]:
        """
        List of JobEndpoints.
        For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class LabelingJobTextPropertiesResponse(dict):
    """
    Properties of a labeling job for text data
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mediaType":
            suggest = "media_type"
        elif key == "annotationType":
            suggest = "annotation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LabelingJobTextPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LabelingJobTextPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LabelingJobTextPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 media_type: str,
                 annotation_type: Optional[str] = None):
        """
        Properties of a labeling job for text data
        :param str media_type: Media type of data asset.
               Expected value is 'Text'.
        :param str annotation_type: Annotation type of text labeling job.
        """
        pulumi.set(__self__, "media_type", 'Text')
        if annotation_type is None:
            annotation_type = 'Classification'
        if annotation_type is not None:
            pulumi.set(__self__, "annotation_type", annotation_type)

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> str:
        """
        Media type of data asset.
        Expected value is 'Text'.
        """
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter(name="annotationType")
    def annotation_type(self) -> Optional[str]:
        """
        Annotation type of text labeling job.
        """
        return pulumi.get(self, "annotation_type")


@pulumi.output_type
class ListNotebookKeysResultResponse(dict):
    def __init__(__self__, *,
                 primary_access_key: str,
                 secondary_access_key: str):
        pulumi.set(__self__, "primary_access_key", primary_access_key)
        pulumi.set(__self__, "secondary_access_key", secondary_access_key)

    @property
    @pulumi.getter(name="primaryAccessKey")
    def primary_access_key(self) -> str:
        return pulumi.get(self, "primary_access_key")

    @property
    @pulumi.getter(name="secondaryAccessKey")
    def secondary_access_key(self) -> str:
        return pulumi.get(self, "secondary_access_key")


@pulumi.output_type
class MLAssistConfigurationDisabledResponse(dict):
    """
    Labeling MLAssist configuration definition when MLAssist is disabled
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mlAssist":
            suggest = "ml_assist"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLAssistConfigurationDisabledResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLAssistConfigurationDisabledResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLAssistConfigurationDisabledResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ml_assist: str):
        """
        Labeling MLAssist configuration definition when MLAssist is disabled
        :param str ml_assist: 
               Expected value is 'Disabled'.
        """
        pulumi.set(__self__, "ml_assist", 'Disabled')

    @property
    @pulumi.getter(name="mlAssist")
    def ml_assist(self) -> str:
        """

        Expected value is 'Disabled'.
        """
        return pulumi.get(self, "ml_assist")


@pulumi.output_type
class MLAssistConfigurationEnabledResponse(dict):
    """
    Labeling MLAssist configuration definition when MLAssist is enabled
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inferencingComputeBinding":
            suggest = "inferencing_compute_binding"
        elif key == "mlAssist":
            suggest = "ml_assist"
        elif key == "trainingComputeBinding":
            suggest = "training_compute_binding"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MLAssistConfigurationEnabledResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MLAssistConfigurationEnabledResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MLAssistConfigurationEnabledResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inferencing_compute_binding: str,
                 ml_assist: str,
                 training_compute_binding: str):
        """
        Labeling MLAssist configuration definition when MLAssist is enabled
        :param str inferencing_compute_binding: [Required] AML compute binding used in inferencing.
        :param str ml_assist: 
               Expected value is 'Enabled'.
        :param str training_compute_binding: [Required] AML compute binding used in training.
        """
        pulumi.set(__self__, "inferencing_compute_binding", inferencing_compute_binding)
        pulumi.set(__self__, "ml_assist", 'Enabled')
        pulumi.set(__self__, "training_compute_binding", training_compute_binding)

    @property
    @pulumi.getter(name="inferencingComputeBinding")
    def inferencing_compute_binding(self) -> str:
        """
        [Required] AML compute binding used in inferencing.
        """
        return pulumi.get(self, "inferencing_compute_binding")

    @property
    @pulumi.getter(name="mlAssist")
    def ml_assist(self) -> str:
        """

        Expected value is 'Enabled'.
        """
        return pulumi.get(self, "ml_assist")

    @property
    @pulumi.getter(name="trainingComputeBinding")
    def training_compute_binding(self) -> str:
        """
        [Required] AML compute binding used in training.
        """
        return pulumi.get(self, "training_compute_binding")


@pulumi.output_type
class ManagedIdentityResponse(dict):
    """
    Managed identity configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityType":
            suggest = "identity_type"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_type: str,
                 client_id: Optional[str] = None,
                 object_id: Optional[str] = None,
                 resource_id: Optional[str] = None):
        """
        Managed identity configuration.
        :param str identity_type: Enum to determine identity framework.
               Expected value is 'Managed'.
        :param str client_id: Specifies a user-assigned identity by client ID. For system-assigned, do not set this field.
        :param str object_id: Specifies a user-assigned identity by object ID. For system-assigned, do not set this field.
        :param str resource_id: Specifies a user-assigned identity by ARM resource ID. For system-assigned, do not set this field.
        """
        pulumi.set(__self__, "identity_type", 'Managed')
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="identityType")
    def identity_type(self) -> str:
        """
        Enum to determine identity framework.
        Expected value is 'Managed'.
        """
        return pulumi.get(self, "identity_type")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        Specifies a user-assigned identity by client ID. For system-assigned, do not set this field.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[str]:
        """
        Specifies a user-assigned identity by object ID. For system-assigned, do not set this field.
        """
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        Specifies a user-assigned identity by ARM resource ID. For system-assigned, do not set this field.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class ManagedNetworkProvisionStatusResponse(dict):
    """
    Status of the Provisioning for the managed network of a machine learning workspace.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sparkReady":
            suggest = "spark_ready"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedNetworkProvisionStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedNetworkProvisionStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedNetworkProvisionStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 spark_ready: Optional[bool] = None,
                 status: Optional[str] = None):
        """
        Status of the Provisioning for the managed network of a machine learning workspace.
        :param str status: Status for the managed network of a machine learning workspace.
        """
        if spark_ready is not None:
            pulumi.set(__self__, "spark_ready", spark_ready)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="sparkReady")
    def spark_ready(self) -> Optional[bool]:
        return pulumi.get(self, "spark_ready")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ManagedNetworkSettingsResponse(dict):
    """
    Managed Network settings for a machine learning workspace.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "isolationMode":
            suggest = "isolation_mode"
        elif key == "outboundRules":
            suggest = "outbound_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedNetworkSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedNetworkSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedNetworkSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: str,
                 isolation_mode: Optional[str] = None,
                 outbound_rules: Optional[Mapping[str, Any]] = None,
                 status: Optional['outputs.ManagedNetworkProvisionStatusResponse'] = None):
        """
        Managed Network settings for a machine learning workspace.
        :param str isolation_mode: Isolation mode for the managed network of a machine learning workspace.
        :param 'ManagedNetworkProvisionStatusResponse' status: Status of the Provisioning for the managed network of a machine learning workspace.
        """
        pulumi.set(__self__, "network_id", network_id)
        if isolation_mode is not None:
            pulumi.set(__self__, "isolation_mode", isolation_mode)
        if outbound_rules is not None:
            pulumi.set(__self__, "outbound_rules", outbound_rules)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> str:
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter(name="isolationMode")
    def isolation_mode(self) -> Optional[str]:
        """
        Isolation mode for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "isolation_mode")

    @property
    @pulumi.getter(name="outboundRules")
    def outbound_rules(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "outbound_rules")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.ManagedNetworkProvisionStatusResponse']:
        """
        Status of the Provisioning for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity (system assigned and/or user assigned identities)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class MaterializationComputeResourceResponse(dict):
    """
    Dto object representing compute resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceType":
            suggest = "instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaterializationComputeResourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaterializationComputeResourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaterializationComputeResourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_type: Optional[str] = None):
        """
        Dto object representing compute resource
        :param str instance_type: Specifies the instance type
        """
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        Specifies the instance type
        """
        return pulumi.get(self, "instance_type")


@pulumi.output_type
class MaterializationSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sparkConfiguration":
            suggest = "spark_configuration"
        elif key == "storeType":
            suggest = "store_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaterializationSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaterializationSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaterializationSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notification: Optional['outputs.NotificationSettingResponse'] = None,
                 resource: Optional['outputs.MaterializationComputeResourceResponse'] = None,
                 schedule: Optional['outputs.RecurrenceTriggerResponse'] = None,
                 spark_configuration: Optional[Mapping[str, str]] = None,
                 store_type: Optional[str] = None):
        """
        :param 'NotificationSettingResponse' notification: Specifies the notification details
        :param 'MaterializationComputeResourceResponse' resource: Specifies the compute resource settings
        :param 'RecurrenceTriggerResponse' schedule: Specifies the schedule details
        :param Mapping[str, str] spark_configuration: Specifies the spark compute settings
        :param str store_type: Specifies the stores to which materialization should happen
        """
        if notification is not None:
            pulumi.set(__self__, "notification", notification)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if spark_configuration is not None:
            pulumi.set(__self__, "spark_configuration", spark_configuration)
        if store_type is None:
            store_type = 'None'
        if store_type is not None:
            pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter
    def notification(self) -> Optional['outputs.NotificationSettingResponse']:
        """
        Specifies the notification details
        """
        return pulumi.get(self, "notification")

    @property
    @pulumi.getter
    def resource(self) -> Optional['outputs.MaterializationComputeResourceResponse']:
        """
        Specifies the compute resource settings
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def schedule(self) -> Optional['outputs.RecurrenceTriggerResponse']:
        """
        Specifies the schedule details
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="sparkConfiguration")
    def spark_configuration(self) -> Optional[Mapping[str, str]]:
        """
        Specifies the spark compute settings
        """
        return pulumi.get(self, "spark_configuration")

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> Optional[str]:
        """
        Specifies the stores to which materialization should happen
        """
        return pulumi.get(self, "store_type")


@pulumi.output_type
class NotebookPreparationErrorResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotebookPreparationErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotebookPreparationErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotebookPreparationErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_message: Optional[str] = None,
                 status_code: Optional[int] = None):
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[str]:
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[int]:
        return pulumi.get(self, "status_code")


@pulumi.output_type
class NotebookResourceInfoResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notebookPreparationError":
            suggest = "notebook_preparation_error"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotebookResourceInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotebookResourceInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotebookResourceInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: Optional[str] = None,
                 notebook_preparation_error: Optional['outputs.NotebookPreparationErrorResponse'] = None,
                 resource_id: Optional[str] = None):
        """
        :param 'NotebookPreparationErrorResponse' notebook_preparation_error: The error that occurs when preparing notebook.
        :param str resource_id: the data plane resourceId that used to initialize notebook component
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if notebook_preparation_error is not None:
            pulumi.set(__self__, "notebook_preparation_error", notebook_preparation_error)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[str]:
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="notebookPreparationError")
    def notebook_preparation_error(self) -> Optional['outputs.NotebookPreparationErrorResponse']:
        """
        The error that occurs when preparing notebook.
        """
        return pulumi.get(self, "notebook_preparation_error")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        the data plane resourceId that used to initialize notebook component
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class NotificationSettingResponse(dict):
    """
    Configuration for notification.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailOn":
            suggest = "email_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationSettingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationSettingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationSettingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_on: Optional[Sequence[str]] = None,
                 emails: Optional[Sequence[str]] = None,
                 webhooks: Optional[Mapping[str, 'outputs.AzureDevOpsWebhookResponse']] = None):
        """
        Configuration for notification.
        :param Sequence[str] email_on: Send email notification to user on specified notification type
        :param Sequence[str] emails: This is the email recipient list which has a limitation of 499 characters in total concat with comma separator
        :param Mapping[str, 'AzureDevOpsWebhookResponse'] webhooks: Send webhook callback to a service. Key is a user-provided name for the webhook.
        """
        if email_on is not None:
            pulumi.set(__self__, "email_on", email_on)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if webhooks is not None:
            pulumi.set(__self__, "webhooks", webhooks)

    @property
    @pulumi.getter(name="emailOn")
    def email_on(self) -> Optional[Sequence[str]]:
        """
        Send email notification to user on specified notification type
        """
        return pulumi.get(self, "email_on")

    @property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[str]]:
        """
        This is the email recipient list which has a limitation of 499 characters in total concat with comma separator
        """
        return pulumi.get(self, "emails")

    @property
    @pulumi.getter
    def webhooks(self) -> Optional[Mapping[str, 'outputs.AzureDevOpsWebhookResponse']]:
        """
        Send webhook callback to a service. Key is a user-provided name for the webhook.
        """
        return pulumi.get(self, "webhooks")


@pulumi.output_type
class PasswordResponse(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class PrivateEndpointConnectionResponse(dict):
    """
    The Private Endpoint Connection resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateLinkServiceConnectionState":
            suggest = "private_link_service_connection_state"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "systemData":
            suggest = "system_data"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 name: str,
                 private_link_service_connection_state: 'outputs.PrivateLinkServiceConnectionStateResponse',
                 provisioning_state: str,
                 system_data: 'outputs.SystemDataResponse',
                 type: str,
                 identity: Optional['outputs.ManagedServiceIdentityResponse'] = None,
                 location: Optional[str] = None,
                 private_endpoint: Optional['outputs.PrivateEndpointResponse'] = None,
                 sku: Optional['outputs.SkuResponse'] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        The Private Endpoint Connection resource.
        :param str id: Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        :param str name: The name of the resource
        :param 'PrivateLinkServiceConnectionStateResponse' private_link_service_connection_state: A collection of information about the state of the connection between service consumer and provider.
        :param str provisioning_state: The provisioning state of the private endpoint connection resource.
        :param 'SystemDataResponse' system_data: Azure Resource Manager metadata containing createdBy and modifiedBy information.
        :param str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param 'ManagedServiceIdentityResponse' identity: The identity of the resource.
        :param str location: Specifies the location of the resource.
        :param 'PrivateEndpointResponse' private_endpoint: The resource of private end point.
        :param 'SkuResponse' sku: The sku of the workspace.
        :param Mapping[str, str] tags: Contains resource tags defined as key/value pairs.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_link_service_connection_state", private_link_service_connection_state)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "system_data", system_data)
        pulumi.set(__self__, "type", type)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> 'outputs.PrivateLinkServiceConnectionStateResponse':
        """
        A collection of information about the state of the connection between service consumer and provider.
        """
        return pulumi.get(self, "private_link_service_connection_state")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the private endpoint connection resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Azure Resource Manager metadata containing createdBy and modifiedBy information.
        """
        return pulumi.get(self, "system_data")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def identity(self) -> Optional['outputs.ManagedServiceIdentityResponse']:
        """
        The identity of the resource.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Specifies the location of the resource.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.PrivateEndpointResponse']:
        """
        The resource of private end point.
        """
        return pulumi.get(self, "private_endpoint")

    @property
    @pulumi.getter
    def sku(self) -> Optional['outputs.SkuResponse']:
        """
        The sku of the workspace.
        """
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Contains resource tags defined as key/value pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class PrivateEndpointDestinationResponse(dict):
    """
    Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceResourceId":
            suggest = "service_resource_id"
        elif key == "sparkEnabled":
            suggest = "spark_enabled"
        elif key == "sparkStatus":
            suggest = "spark_status"
        elif key == "subresourceTarget":
            suggest = "subresource_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_resource_id: Optional[str] = None,
                 spark_enabled: Optional[bool] = None,
                 spark_status: Optional[str] = None,
                 subresource_target: Optional[str] = None):
        """
        Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        :param str spark_status: Status of a managed network Outbound Rule of a machine learning workspace.
        """
        if service_resource_id is not None:
            pulumi.set(__self__, "service_resource_id", service_resource_id)
        if spark_enabled is not None:
            pulumi.set(__self__, "spark_enabled", spark_enabled)
        if spark_status is not None:
            pulumi.set(__self__, "spark_status", spark_status)
        if subresource_target is not None:
            pulumi.set(__self__, "subresource_target", subresource_target)

    @property
    @pulumi.getter(name="serviceResourceId")
    def service_resource_id(self) -> Optional[str]:
        return pulumi.get(self, "service_resource_id")

    @property
    @pulumi.getter(name="sparkEnabled")
    def spark_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "spark_enabled")

    @property
    @pulumi.getter(name="sparkStatus")
    def spark_status(self) -> Optional[str]:
        """
        Status of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "spark_status")

    @property
    @pulumi.getter(name="subresourceTarget")
    def subresource_target(self) -> Optional[str]:
        return pulumi.get(self, "subresource_target")


@pulumi.output_type
class PrivateEndpointOutboundRuleResponse(dict):
    """
    Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
    """
    def __init__(__self__, *,
                 type: str,
                 category: Optional[str] = None,
                 destination: Optional['outputs.PrivateEndpointDestinationResponse'] = None,
                 status: Optional[str] = None):
        """
        Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        :param str type: Type of a managed network Outbound Rule of a machine learning workspace.
               Expected value is 'PrivateEndpoint'.
        :param str category: Category of a managed network Outbound Rule of a machine learning workspace.
        :param 'PrivateEndpointDestinationResponse' destination: Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        :param str status: Status of a managed network Outbound Rule of a machine learning workspace.
        """
        pulumi.set(__self__, "type", 'PrivateEndpoint')
        if category is not None:
            pulumi.set(__self__, "category", category)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        Expected value is 'PrivateEndpoint'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        Category of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.PrivateEndpointDestinationResponse']:
        """
        Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class PrivateEndpointResponse(dict):
    """
    The Private Endpoint resource.
    """
    def __init__(__self__, *,
                 id: str):
        """
        The Private Endpoint resource.
        :param str id: The ARM identifier for Private Endpoint
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ARM identifier for Private Endpoint
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrivateLinkServiceConnectionStateResponse(dict):
    """
    A collection of information about the state of the connection between service consumer and provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsRequired":
            suggest = "actions_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkServiceConnectionStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_required: Optional[str] = None,
                 description: Optional[str] = None,
                 status: Optional[str] = None):
        """
        A collection of information about the state of the connection between service consumer and provider.
        :param str actions_required: A message indicating if changes on the service provider require any updates on the consumer.
        :param str description: The reason for approval/rejection of the connection.
        :param str status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        if actions_required is not None:
            pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[str]:
        """
        A message indicating if changes on the service provider require any updates on the consumer.
        """
        return pulumi.get(self, "actions_required")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The reason for approval/rejection of the connection.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ProgressMetricsResponse(dict):
    """
    Progress metrics definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "completedDatapointCount":
            suggest = "completed_datapoint_count"
        elif key == "incrementalDataLastRefreshDateTime":
            suggest = "incremental_data_last_refresh_date_time"
        elif key == "skippedDatapointCount":
            suggest = "skipped_datapoint_count"
        elif key == "totalDatapointCount":
            suggest = "total_datapoint_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProgressMetricsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProgressMetricsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProgressMetricsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 completed_datapoint_count: float,
                 incremental_data_last_refresh_date_time: str,
                 skipped_datapoint_count: float,
                 total_datapoint_count: float):
        """
        Progress metrics definition
        :param float completed_datapoint_count: The completed datapoint count.
        :param str incremental_data_last_refresh_date_time: The time of last successful incremental data refresh in UTC.
        :param float skipped_datapoint_count: The skipped datapoint count.
        :param float total_datapoint_count: The total datapoint count.
        """
        pulumi.set(__self__, "completed_datapoint_count", completed_datapoint_count)
        pulumi.set(__self__, "incremental_data_last_refresh_date_time", incremental_data_last_refresh_date_time)
        pulumi.set(__self__, "skipped_datapoint_count", skipped_datapoint_count)
        pulumi.set(__self__, "total_datapoint_count", total_datapoint_count)

    @property
    @pulumi.getter(name="completedDatapointCount")
    def completed_datapoint_count(self) -> float:
        """
        The completed datapoint count.
        """
        return pulumi.get(self, "completed_datapoint_count")

    @property
    @pulumi.getter(name="incrementalDataLastRefreshDateTime")
    def incremental_data_last_refresh_date_time(self) -> str:
        """
        The time of last successful incremental data refresh in UTC.
        """
        return pulumi.get(self, "incremental_data_last_refresh_date_time")

    @property
    @pulumi.getter(name="skippedDatapointCount")
    def skipped_datapoint_count(self) -> float:
        """
        The skipped datapoint count.
        """
        return pulumi.get(self, "skipped_datapoint_count")

    @property
    @pulumi.getter(name="totalDatapointCount")
    def total_datapoint_count(self) -> float:
        """
        The total datapoint count.
        """
        return pulumi.get(self, "total_datapoint_count")


@pulumi.output_type
class RecurrenceScheduleResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monthDays":
            suggest = "month_days"
        elif key == "weekDays":
            suggest = "week_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecurrenceScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecurrenceScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecurrenceScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hours: Sequence[int],
                 minutes: Sequence[int],
                 month_days: Optional[Sequence[int]] = None,
                 week_days: Optional[Sequence[str]] = None):
        """
        :param Sequence[int] hours: [Required] List of hours for the schedule.
        :param Sequence[int] minutes: [Required] List of minutes for the schedule.
        :param Sequence[int] month_days: List of month days for the schedule
        :param Sequence[str] week_days: List of days for the schedule.
        """
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)
        if month_days is not None:
            pulumi.set(__self__, "month_days", month_days)
        if week_days is not None:
            pulumi.set(__self__, "week_days", week_days)

    @property
    @pulumi.getter
    def hours(self) -> Sequence[int]:
        """
        [Required] List of hours for the schedule.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Sequence[int]:
        """
        [Required] List of minutes for the schedule.
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter(name="monthDays")
    def month_days(self) -> Optional[Sequence[int]]:
        """
        List of month days for the schedule
        """
        return pulumi.get(self, "month_days")

    @property
    @pulumi.getter(name="weekDays")
    def week_days(self) -> Optional[Sequence[str]]:
        """
        List of days for the schedule.
        """
        return pulumi.get(self, "week_days")


@pulumi.output_type
class RecurrenceTriggerResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "triggerType":
            suggest = "trigger_type"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecurrenceTriggerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecurrenceTriggerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecurrenceTriggerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency: str,
                 interval: int,
                 trigger_type: str,
                 end_time: Optional[str] = None,
                 schedule: Optional['outputs.RecurrenceScheduleResponse'] = None,
                 start_time: Optional[str] = None,
                 time_zone: Optional[str] = None):
        """
        :param str frequency: [Required] The frequency to trigger schedule.
        :param int interval: [Required] Specifies schedule interval in conjunction with frequency
        :param str trigger_type: 
               Expected value is 'Recurrence'.
        :param str end_time: Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer https://en.wikipedia.org/wiki/ISO_8601.
               Recommented format would be "2022-06-01T00:00:01"
               If not present, the schedule will run indefinitely
        :param 'RecurrenceScheduleResponse' schedule: The recurrence schedule.
        :param str start_time: Specifies start time of schedule in ISO 8601 format, but without a UTC offset.
        :param str time_zone: Specifies time zone in which the schedule runs.
               TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
        """
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "trigger_type", 'Recurrence')
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if time_zone is None:
            time_zone = 'UTC'
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def frequency(self) -> str:
        """
        [Required] The frequency to trigger schedule.
        """
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter
    def interval(self) -> int:
        """
        [Required] Specifies schedule interval in conjunction with frequency
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> str:
        """

        Expected value is 'Recurrence'.
        """
        return pulumi.get(self, "trigger_type")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer https://en.wikipedia.org/wiki/ISO_8601.
        Recommented format would be "2022-06-01T00:00:01"
        If not present, the schedule will run indefinitely
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter
    def schedule(self) -> Optional['outputs.RecurrenceScheduleResponse']:
        """
        The recurrence schedule.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        Specifies start time of schedule in ISO 8601 format, but without a UTC offset.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        Specifies time zone in which the schedule runs.
        TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class RegistryListCredentialsResultResponse(dict):
    def __init__(__self__, *,
                 location: str,
                 username: str,
                 passwords: Optional[Sequence['outputs.PasswordResponse']] = None):
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "username", username)
        if passwords is not None:
            pulumi.set(__self__, "passwords", passwords)

    @property
    @pulumi.getter
    def location(self) -> str:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def passwords(self) -> Optional[Sequence['outputs.PasswordResponse']]:
        return pulumi.get(self, "passwords")


@pulumi.output_type
class SecretConfigurationResponse(dict):
    """
    Secret Configuration definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceSecretName":
            suggest = "workspace_secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: Optional[str] = None,
                 workspace_secret_name: Optional[str] = None):
        """
        Secret Configuration definition.
        :param str uri: Secret Uri.
               Sample Uri : https://myvault.vault.azure.net/secrets/mysecretname/secretversion
        :param str workspace_secret_name: Name of secret in workspace key vault.
        """
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if workspace_secret_name is not None:
            pulumi.set(__self__, "workspace_secret_name", workspace_secret_name)

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        Secret Uri.
        Sample Uri : https://myvault.vault.azure.net/secrets/mysecretname/secretversion
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="workspaceSecretName")
    def workspace_secret_name(self) -> Optional[str]:
        """
        Name of secret in workspace key vault.
        """
        return pulumi.get(self, "workspace_secret_name")


@pulumi.output_type
class ServiceManagedResourcesSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cosmosDb":
            suggest = "cosmos_db"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceManagedResourcesSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceManagedResourcesSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceManagedResourcesSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cosmos_db: Optional['outputs.CosmosDbSettingsResponse'] = None):
        """
        :param 'CosmosDbSettingsResponse' cosmos_db: The settings for the service managed cosmosdb account.
        """
        if cosmos_db is not None:
            pulumi.set(__self__, "cosmos_db", cosmos_db)

    @property
    @pulumi.getter(name="cosmosDb")
    def cosmos_db(self) -> Optional['outputs.CosmosDbSettingsResponse']:
        """
        The settings for the service managed cosmosdb account.
        """
        return pulumi.get(self, "cosmos_db")


@pulumi.output_type
class ServiceTagDestinationResponse(dict):
    """
    Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRanges":
            suggest = "port_ranges"
        elif key == "serviceTag":
            suggest = "service_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceTagDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceTagDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceTagDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_ranges: Optional[str] = None,
                 protocol: Optional[str] = None,
                 service_tag: Optional[str] = None):
        """
        Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
        """
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[str]:
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[str]:
        return pulumi.get(self, "service_tag")


@pulumi.output_type
class ServiceTagOutboundRuleResponse(dict):
    """
    Service Tag Outbound Rule for the managed network of a machine learning workspace.
    """
    def __init__(__self__, *,
                 type: str,
                 category: Optional[str] = None,
                 destination: Optional['outputs.ServiceTagDestinationResponse'] = None,
                 status: Optional[str] = None):
        """
        Service Tag Outbound Rule for the managed network of a machine learning workspace.
        :param str type: Type of a managed network Outbound Rule of a machine learning workspace.
               Expected value is 'ServiceTag'.
        :param str category: Category of a managed network Outbound Rule of a machine learning workspace.
        :param 'ServiceTagDestinationResponse' destination: Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
        :param str status: Status of a managed network Outbound Rule of a machine learning workspace.
        """
        pulumi.set(__self__, "type", 'ServiceTag')
        if category is not None:
            pulumi.set(__self__, "category", category)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        Expected value is 'ServiceTag'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        Category of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.ServiceTagDestinationResponse']:
        """
        Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SharedPrivateLinkResourceResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"
        elif key == "privateLinkResourceId":
            suggest = "private_link_resource_id"
        elif key == "requestMessage":
            suggest = "request_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SharedPrivateLinkResourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SharedPrivateLinkResourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SharedPrivateLinkResourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_id: Optional[str] = None,
                 name: Optional[str] = None,
                 private_link_resource_id: Optional[str] = None,
                 request_message: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str group_id: The private link resource group id.
        :param str name: Unique name of the private link.
        :param str private_link_resource_id: The resource id that private link links to.
        :param str request_message: Request message.
        :param str status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_link_resource_id is not None:
            pulumi.set(__self__, "private_link_resource_id", private_link_resource_id)
        if request_message is not None:
            pulumi.set(__self__, "request_message", request_message)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        The private link resource group id.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique name of the private link.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateLinkResourceId")
    def private_link_resource_id(self) -> Optional[str]:
        """
        The resource id that private link links to.
        """
        return pulumi.get(self, "private_link_resource_id")

    @property
    @pulumi.getter(name="requestMessage")
    def request_message(self) -> Optional[str]:
        """
        Request message.
        """
        return pulumi.get(self, "request_message")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SkuResponse(dict):
    """
    The resource model definition representing SKU
    """
    def __init__(__self__, *,
                 name: str,
                 capacity: Optional[int] = None,
                 family: Optional[str] = None,
                 size: Optional[str] = None,
                 tier: Optional[str] = None):
        """
        The resource model definition representing SKU
        :param str name: The name of the SKU. Ex - P3. It is typically a letter+number code
        :param int capacity: If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        :param str family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
        :param str size: The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        :param str tier: This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the SKU. Ex - P3. It is typically a letter+number code
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def capacity(self) -> Optional[int]:
        """
        If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def family(self) -> Optional[str]:
        """
        If the service has different generations of hardware, for the same SKU, then that can be captured here.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        """
        The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        """
        This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class StatusMessageResponse(dict):
    """
    Active message associated with project
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdDateTime":
            suggest = "created_date_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatusMessageResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatusMessageResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatusMessageResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code: str,
                 created_date_time: str,
                 level: str,
                 message: str):
        """
        Active message associated with project
        :param str code: Service-defined message code.
        :param str created_date_time: Time in UTC at which the message was created.
        :param str level: Severity level of message.
        :param str message: A human-readable representation of the message code.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "created_date_time", created_date_time)
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> str:
        """
        Service-defined message code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="createdDateTime")
    def created_date_time(self) -> str:
        """
        Time in UTC at which the message was created.
        """
        return pulumi.get(self, "created_date_time")

    @property
    @pulumi.getter
    def level(self) -> str:
        """
        Severity level of message.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        A human-readable representation of the message code.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str):
        """
        User assigned identity properties
        :param str client_id: The client ID of the assigned identity.
        :param str principal_id: The principal ID of the assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class UserIdentityResponse(dict):
    """
    User identity configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityType":
            suggest = "identity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_type: str):
        """
        User identity configuration.
        :param str identity_type: Enum to determine identity framework.
               Expected value is 'UserIdentity'.
        """
        pulumi.set(__self__, "identity_type", 'UserIdentity')

    @property
    @pulumi.getter(name="identityType")
    def identity_type(self) -> str:
        """
        Enum to determine identity framework.
        Expected value is 'UserIdentity'.
        """
        return pulumi.get(self, "identity_type")


