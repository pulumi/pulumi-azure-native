# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'AllNodesArgs',
    'AllNodesArgsDict',
    'AmlTokenArgs',
    'AmlTokenArgsDict',
    'AutoDeleteSettingArgs',
    'AutoDeleteSettingArgsDict',
    'AzureDevOpsWebhookArgs',
    'AzureDevOpsWebhookArgsDict',
    'ComputeRuntimeDtoArgs',
    'ComputeRuntimeDtoArgsDict',
    'CosmosDbSettingsArgs',
    'CosmosDbSettingsArgsDict',
    'EncryptionKeyVaultPropertiesArgs',
    'EncryptionKeyVaultPropertiesArgsDict',
    'EncryptionPropertyArgs',
    'EncryptionPropertyArgsDict',
    'FeatureStoreSettingsArgs',
    'FeatureStoreSettingsArgsDict',
    'FeaturesetContainerArgs',
    'FeaturesetContainerArgsDict',
    'FeaturesetSpecificationArgs',
    'FeaturesetSpecificationArgsDict',
    'FeaturesetVersionArgs',
    'FeaturesetVersionArgsDict',
    'FeaturestoreEntityContainerArgs',
    'FeaturestoreEntityContainerArgsDict',
    'FeaturestoreEntityVersionArgs',
    'FeaturestoreEntityVersionArgsDict',
    'FqdnOutboundRuleArgs',
    'FqdnOutboundRuleArgsDict',
    'IdentityForCmkArgs',
    'IdentityForCmkArgsDict',
    'IndexColumnArgs',
    'IndexColumnArgsDict',
    'JobServiceArgs',
    'JobServiceArgsDict',
    'LabelCategoryArgs',
    'LabelCategoryArgsDict',
    'LabelClassArgs',
    'LabelClassArgsDict',
    'LabelingDataConfigurationArgs',
    'LabelingDataConfigurationArgsDict',
    'LabelingJobImagePropertiesArgs',
    'LabelingJobImagePropertiesArgsDict',
    'LabelingJobInstructionsArgs',
    'LabelingJobInstructionsArgsDict',
    'LabelingJobTextPropertiesArgs',
    'LabelingJobTextPropertiesArgsDict',
    'LabelingJobArgs',
    'LabelingJobArgsDict',
    'MLAssistConfigurationDisabledArgs',
    'MLAssistConfigurationDisabledArgsDict',
    'MLAssistConfigurationEnabledArgs',
    'MLAssistConfigurationEnabledArgsDict',
    'ManagedIdentityArgs',
    'ManagedIdentityArgsDict',
    'ManagedNetworkProvisionStatusArgs',
    'ManagedNetworkProvisionStatusArgsDict',
    'ManagedNetworkSettingsArgs',
    'ManagedNetworkSettingsArgsDict',
    'ManagedServiceIdentityArgs',
    'ManagedServiceIdentityArgsDict',
    'MaterializationComputeResourceArgs',
    'MaterializationComputeResourceArgsDict',
    'MaterializationSettingsArgs',
    'MaterializationSettingsArgsDict',
    'NotificationSettingArgs',
    'NotificationSettingArgsDict',
    'PrivateEndpointDestinationArgs',
    'PrivateEndpointDestinationArgsDict',
    'PrivateEndpointOutboundRuleArgs',
    'PrivateEndpointOutboundRuleArgsDict',
    'RecurrenceScheduleArgs',
    'RecurrenceScheduleArgsDict',
    'RecurrenceTriggerArgs',
    'RecurrenceTriggerArgsDict',
    'SecretConfigurationArgs',
    'SecretConfigurationArgsDict',
    'ServiceManagedResourcesSettingsArgs',
    'ServiceManagedResourcesSettingsArgsDict',
    'ServiceTagDestinationArgs',
    'ServiceTagDestinationArgsDict',
    'ServiceTagOutboundRuleArgs',
    'ServiceTagOutboundRuleArgsDict',
    'SharedPrivateLinkResourceArgs',
    'SharedPrivateLinkResourceArgsDict',
    'SkuArgs',
    'SkuArgsDict',
    'UserIdentityArgs',
    'UserIdentityArgsDict',
]

MYPY = False

if not MYPY:
    class AllNodesArgsDict(TypedDict):
        """
        All nodes means the service will be running on all of the nodes of the job
        """
        nodes_value_type: pulumi.Input[str]
        """
        The enumerated types for the nodes value
        Expected value is 'All'.
        """
elif False:
    AllNodesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AllNodesArgs:
    def __init__(__self__, *,
                 nodes_value_type: pulumi.Input[str]):
        """
        All nodes means the service will be running on all of the nodes of the job
        :param pulumi.Input[str] nodes_value_type: The enumerated types for the nodes value
               Expected value is 'All'.
        """
        pulumi.set(__self__, "nodes_value_type", 'All')

    @property
    @pulumi.getter(name="nodesValueType")
    def nodes_value_type(self) -> pulumi.Input[str]:
        """
        The enumerated types for the nodes value
        Expected value is 'All'.
        """
        return pulumi.get(self, "nodes_value_type")

    @nodes_value_type.setter
    def nodes_value_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "nodes_value_type", value)


if not MYPY:
    class AmlTokenArgsDict(TypedDict):
        """
        AML Token identity configuration.
        """
        identity_type: pulumi.Input[str]
        """
        Enum to determine identity framework.
        Expected value is 'AMLToken'.
        """
elif False:
    AmlTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AmlTokenArgs:
    def __init__(__self__, *,
                 identity_type: pulumi.Input[str]):
        """
        AML Token identity configuration.
        :param pulumi.Input[str] identity_type: Enum to determine identity framework.
               Expected value is 'AMLToken'.
        """
        pulumi.set(__self__, "identity_type", 'AMLToken')

    @property
    @pulumi.getter(name="identityType")
    def identity_type(self) -> pulumi.Input[str]:
        """
        Enum to determine identity framework.
        Expected value is 'AMLToken'.
        """
        return pulumi.get(self, "identity_type")

    @identity_type.setter
    def identity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_type", value)


if not MYPY:
    class AutoDeleteSettingArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input[Union[str, 'AutoDeleteCondition']]]
        """
        When to check if an asset is expired
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Expiration condition value.
        """
elif False:
    AutoDeleteSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoDeleteSettingArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[Union[str, 'AutoDeleteCondition']]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Union[str, 'AutoDeleteCondition']] condition: When to check if an asset is expired
        :param pulumi.Input[str] value: Expiration condition value.
        """
        if condition is None:
            condition = 'CreatedGreaterThan'
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[Union[str, 'AutoDeleteCondition']]]:
        """
        When to check if an asset is expired
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[Union[str, 'AutoDeleteCondition']]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Expiration condition value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AzureDevOpsWebhookArgsDict(TypedDict):
        """
        Webhook details specific for Azure DevOps
        """
        webhook_type: pulumi.Input[str]
        """
        Enum to determine the webhook callback service type.
        Expected value is 'AzureDevOps'.
        """
        event_type: NotRequired[pulumi.Input[str]]
        """
        Send callback on a specified notification event
        """
elif False:
    AzureDevOpsWebhookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureDevOpsWebhookArgs:
    def __init__(__self__, *,
                 webhook_type: pulumi.Input[str],
                 event_type: Optional[pulumi.Input[str]] = None):
        """
        Webhook details specific for Azure DevOps
        :param pulumi.Input[str] webhook_type: Enum to determine the webhook callback service type.
               Expected value is 'AzureDevOps'.
        :param pulumi.Input[str] event_type: Send callback on a specified notification event
        """
        pulumi.set(__self__, "webhook_type", 'AzureDevOps')
        if event_type is not None:
            pulumi.set(__self__, "event_type", event_type)

    @property
    @pulumi.getter(name="webhookType")
    def webhook_type(self) -> pulumi.Input[str]:
        """
        Enum to determine the webhook callback service type.
        Expected value is 'AzureDevOps'.
        """
        return pulumi.get(self, "webhook_type")

    @webhook_type.setter
    def webhook_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "webhook_type", value)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> Optional[pulumi.Input[str]]:
        """
        Send callback on a specified notification event
        """
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_type", value)


if not MYPY:
    class ComputeRuntimeDtoArgsDict(TypedDict):
        spark_runtime_version: NotRequired[pulumi.Input[str]]
elif False:
    ComputeRuntimeDtoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeRuntimeDtoArgs:
    def __init__(__self__, *,
                 spark_runtime_version: Optional[pulumi.Input[str]] = None):
        if spark_runtime_version is not None:
            pulumi.set(__self__, "spark_runtime_version", spark_runtime_version)

    @property
    @pulumi.getter(name="sparkRuntimeVersion")
    def spark_runtime_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "spark_runtime_version")

    @spark_runtime_version.setter
    def spark_runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "spark_runtime_version", value)


if not MYPY:
    class CosmosDbSettingsArgsDict(TypedDict):
        collections_throughput: NotRequired[pulumi.Input[int]]
        """
        The throughput of the collections in cosmosdb database
        """
elif False:
    CosmosDbSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CosmosDbSettingsArgs:
    def __init__(__self__, *,
                 collections_throughput: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] collections_throughput: The throughput of the collections in cosmosdb database
        """
        if collections_throughput is not None:
            pulumi.set(__self__, "collections_throughput", collections_throughput)

    @property
    @pulumi.getter(name="collectionsThroughput")
    def collections_throughput(self) -> Optional[pulumi.Input[int]]:
        """
        The throughput of the collections in cosmosdb database
        """
        return pulumi.get(self, "collections_throughput")

    @collections_throughput.setter
    def collections_throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "collections_throughput", value)


if not MYPY:
    class EncryptionKeyVaultPropertiesArgsDict(TypedDict):
        key_identifier: pulumi.Input[str]
        """
        Key vault uri to access the encryption key.
        """
        key_vault_arm_id: pulumi.Input[str]
        """
        The ArmId of the keyVault where the customer owned encryption key is present.
        """
        identity_client_id: NotRequired[pulumi.Input[str]]
        """
        For future use - The client id of the identity which will be used to access key vault.
        """
elif False:
    EncryptionKeyVaultPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EncryptionKeyVaultPropertiesArgs:
    def __init__(__self__, *,
                 key_identifier: pulumi.Input[str],
                 key_vault_arm_id: pulumi.Input[str],
                 identity_client_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key_identifier: Key vault uri to access the encryption key.
        :param pulumi.Input[str] key_vault_arm_id: The ArmId of the keyVault where the customer owned encryption key is present.
        :param pulumi.Input[str] identity_client_id: For future use - The client id of the identity which will be used to access key vault.
        """
        pulumi.set(__self__, "key_identifier", key_identifier)
        pulumi.set(__self__, "key_vault_arm_id", key_vault_arm_id)
        if identity_client_id is not None:
            pulumi.set(__self__, "identity_client_id", identity_client_id)

    @property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> pulumi.Input[str]:
        """
        Key vault uri to access the encryption key.
        """
        return pulumi.get(self, "key_identifier")

    @key_identifier.setter
    def key_identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_identifier", value)

    @property
    @pulumi.getter(name="keyVaultArmId")
    def key_vault_arm_id(self) -> pulumi.Input[str]:
        """
        The ArmId of the keyVault where the customer owned encryption key is present.
        """
        return pulumi.get(self, "key_vault_arm_id")

    @key_vault_arm_id.setter
    def key_vault_arm_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_arm_id", value)

    @property
    @pulumi.getter(name="identityClientId")
    def identity_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        For future use - The client id of the identity which will be used to access key vault.
        """
        return pulumi.get(self, "identity_client_id")

    @identity_client_id.setter
    def identity_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_client_id", value)


if not MYPY:
    class EncryptionPropertyArgsDict(TypedDict):
        key_vault_properties: pulumi.Input['EncryptionKeyVaultPropertiesArgsDict']
        """
        Customer Key vault properties.
        """
        status: pulumi.Input[Union[str, 'EncryptionStatus']]
        """
        Indicates whether or not the encryption is enabled for the workspace.
        """
        identity: NotRequired[pulumi.Input['IdentityForCmkArgsDict']]
        """
        The identity that will be used to access the key vault for encryption at rest.
        """
elif False:
    EncryptionPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EncryptionPropertyArgs:
    def __init__(__self__, *,
                 key_vault_properties: pulumi.Input['EncryptionKeyVaultPropertiesArgs'],
                 status: pulumi.Input[Union[str, 'EncryptionStatus']],
                 identity: Optional[pulumi.Input['IdentityForCmkArgs']] = None):
        """
        :param pulumi.Input['EncryptionKeyVaultPropertiesArgs'] key_vault_properties: Customer Key vault properties.
        :param pulumi.Input[Union[str, 'EncryptionStatus']] status: Indicates whether or not the encryption is enabled for the workspace.
        :param pulumi.Input['IdentityForCmkArgs'] identity: The identity that will be used to access the key vault for encryption at rest.
        """
        pulumi.set(__self__, "key_vault_properties", key_vault_properties)
        pulumi.set(__self__, "status", status)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)

    @property
    @pulumi.getter(name="keyVaultProperties")
    def key_vault_properties(self) -> pulumi.Input['EncryptionKeyVaultPropertiesArgs']:
        """
        Customer Key vault properties.
        """
        return pulumi.get(self, "key_vault_properties")

    @key_vault_properties.setter
    def key_vault_properties(self, value: pulumi.Input['EncryptionKeyVaultPropertiesArgs']):
        pulumi.set(self, "key_vault_properties", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[Union[str, 'EncryptionStatus']]:
        """
        Indicates whether or not the encryption is enabled for the workspace.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[Union[str, 'EncryptionStatus']]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input['IdentityForCmkArgs']]:
        """
        The identity that will be used to access the key vault for encryption at rest.
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input['IdentityForCmkArgs']]):
        pulumi.set(self, "identity", value)


if not MYPY:
    class FeatureStoreSettingsArgsDict(TypedDict):
        compute_runtime: NotRequired[pulumi.Input['ComputeRuntimeDtoArgsDict']]
        offline_store_connection_name: NotRequired[pulumi.Input[str]]
        online_store_connection_name: NotRequired[pulumi.Input[str]]
elif False:
    FeatureStoreSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureStoreSettingsArgs:
    def __init__(__self__, *,
                 compute_runtime: Optional[pulumi.Input['ComputeRuntimeDtoArgs']] = None,
                 offline_store_connection_name: Optional[pulumi.Input[str]] = None,
                 online_store_connection_name: Optional[pulumi.Input[str]] = None):
        if compute_runtime is not None:
            pulumi.set(__self__, "compute_runtime", compute_runtime)
        if offline_store_connection_name is not None:
            pulumi.set(__self__, "offline_store_connection_name", offline_store_connection_name)
        if online_store_connection_name is not None:
            pulumi.set(__self__, "online_store_connection_name", online_store_connection_name)

    @property
    @pulumi.getter(name="computeRuntime")
    def compute_runtime(self) -> Optional[pulumi.Input['ComputeRuntimeDtoArgs']]:
        return pulumi.get(self, "compute_runtime")

    @compute_runtime.setter
    def compute_runtime(self, value: Optional[pulumi.Input['ComputeRuntimeDtoArgs']]):
        pulumi.set(self, "compute_runtime", value)

    @property
    @pulumi.getter(name="offlineStoreConnectionName")
    def offline_store_connection_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "offline_store_connection_name")

    @offline_store_connection_name.setter
    def offline_store_connection_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "offline_store_connection_name", value)

    @property
    @pulumi.getter(name="onlineStoreConnectionName")
    def online_store_connection_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "online_store_connection_name")

    @online_store_connection_name.setter
    def online_store_connection_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "online_store_connection_name", value)


if not MYPY:
    class FeaturesetContainerArgsDict(TypedDict):
        """
        Dto object representing feature set
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The asset description text.
        """
        is_archived: NotRequired[pulumi.Input[bool]]
        """
        Is the asset archived?
        """
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The asset property dictionary.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
elif False:
    FeaturesetContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeaturesetContainerArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 is_archived: Optional[pulumi.Input[bool]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Dto object representing feature set
        :param pulumi.Input[str] description: The asset description text.
        :param pulumi.Input[bool] is_archived: Is the asset archived?
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] properties: The asset property dictionary.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @is_archived.setter
    def is_archived(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_archived", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class FeaturesetSpecificationArgsDict(TypedDict):
        """
        Dto object representing specification
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Specifies the spec path
        """
elif False:
    FeaturesetSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeaturesetSpecificationArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[str]] = None):
        """
        Dto object representing specification
        :param pulumi.Input[str] path: Specifies the spec path
        """
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the spec path
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class FeaturesetVersionArgsDict(TypedDict):
        """
        Dto object representing feature set version
        """
        auto_delete_setting: NotRequired[pulumi.Input['AutoDeleteSettingArgsDict']]
        """
        Specifies the lifecycle setting of managed data asset.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The asset description text.
        """
        entities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies list of entities
        """
        is_anonymous: NotRequired[pulumi.Input[bool]]
        """
        If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
        """
        is_archived: NotRequired[pulumi.Input[bool]]
        """
        Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
        """
        materialization_settings: NotRequired[pulumi.Input['MaterializationSettingsArgsDict']]
        """
        Specifies the materialization settings
        """
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The asset property dictionary.
        """
        specification: NotRequired[pulumi.Input['FeaturesetSpecificationArgsDict']]
        """
        Specifies the feature spec details
        """
        stage: NotRequired[pulumi.Input[str]]
        """
        Specifies the asset stage
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
elif False:
    FeaturesetVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeaturesetVersionArgs:
    def __init__(__self__, *,
                 auto_delete_setting: Optional[pulumi.Input['AutoDeleteSettingArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 entities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 is_anonymous: Optional[pulumi.Input[bool]] = None,
                 is_archived: Optional[pulumi.Input[bool]] = None,
                 materialization_settings: Optional[pulumi.Input['MaterializationSettingsArgs']] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 specification: Optional[pulumi.Input['FeaturesetSpecificationArgs']] = None,
                 stage: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Dto object representing feature set version
        :param pulumi.Input['AutoDeleteSettingArgs'] auto_delete_setting: Specifies the lifecycle setting of managed data asset.
        :param pulumi.Input[str] description: The asset description text.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] entities: Specifies list of entities
        :param pulumi.Input[bool] is_anonymous: If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
        :param pulumi.Input[bool] is_archived: Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
        :param pulumi.Input['MaterializationSettingsArgs'] materialization_settings: Specifies the materialization settings
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] properties: The asset property dictionary.
        :param pulumi.Input['FeaturesetSpecificationArgs'] specification: Specifies the feature spec details
        :param pulumi.Input[str] stage: Specifies the asset stage
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        if auto_delete_setting is not None:
            pulumi.set(__self__, "auto_delete_setting", auto_delete_setting)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if is_anonymous is None:
            is_anonymous = False
        if is_anonymous is not None:
            pulumi.set(__self__, "is_anonymous", is_anonymous)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if materialization_settings is not None:
            pulumi.set(__self__, "materialization_settings", materialization_settings)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if specification is not None:
            pulumi.set(__self__, "specification", specification)
        if stage is not None:
            pulumi.set(__self__, "stage", stage)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="autoDeleteSetting")
    def auto_delete_setting(self) -> Optional[pulumi.Input['AutoDeleteSettingArgs']]:
        """
        Specifies the lifecycle setting of managed data asset.
        """
        return pulumi.get(self, "auto_delete_setting")

    @auto_delete_setting.setter
    def auto_delete_setting(self, value: Optional[pulumi.Input['AutoDeleteSettingArgs']]):
        pulumi.set(self, "auto_delete_setting", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def entities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies list of entities
        """
        return pulumi.get(self, "entities")

    @entities.setter
    def entities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "entities", value)

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[pulumi.Input[bool]]:
        """
        If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
        """
        return pulumi.get(self, "is_anonymous")

    @is_anonymous.setter
    def is_anonymous(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_anonymous", value)

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
        """
        return pulumi.get(self, "is_archived")

    @is_archived.setter
    def is_archived(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_archived", value)

    @property
    @pulumi.getter(name="materializationSettings")
    def materialization_settings(self) -> Optional[pulumi.Input['MaterializationSettingsArgs']]:
        """
        Specifies the materialization settings
        """
        return pulumi.get(self, "materialization_settings")

    @materialization_settings.setter
    def materialization_settings(self, value: Optional[pulumi.Input['MaterializationSettingsArgs']]):
        pulumi.set(self, "materialization_settings", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def specification(self) -> Optional[pulumi.Input['FeaturesetSpecificationArgs']]:
        """
        Specifies the feature spec details
        """
        return pulumi.get(self, "specification")

    @specification.setter
    def specification(self, value: Optional[pulumi.Input['FeaturesetSpecificationArgs']]):
        pulumi.set(self, "specification", value)

    @property
    @pulumi.getter
    def stage(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the asset stage
        """
        return pulumi.get(self, "stage")

    @stage.setter
    def stage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stage", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class FeaturestoreEntityContainerArgsDict(TypedDict):
        """
        Dto object representing feature entity
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The asset description text.
        """
        is_archived: NotRequired[pulumi.Input[bool]]
        """
        Is the asset archived?
        """
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The asset property dictionary.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
elif False:
    FeaturestoreEntityContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeaturestoreEntityContainerArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 is_archived: Optional[pulumi.Input[bool]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Dto object representing feature entity
        :param pulumi.Input[str] description: The asset description text.
        :param pulumi.Input[bool] is_archived: Is the asset archived?
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] properties: The asset property dictionary.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @is_archived.setter
    def is_archived(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_archived", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class FeaturestoreEntityVersionArgsDict(TypedDict):
        """
        Dto object representing feature entity version
        """
        auto_delete_setting: NotRequired[pulumi.Input['AutoDeleteSettingArgsDict']]
        """
        Specifies the lifecycle setting of managed data asset.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The asset description text.
        """
        index_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['IndexColumnArgsDict']]]]
        """
        Specifies index columns
        """
        is_anonymous: NotRequired[pulumi.Input[bool]]
        """
        If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
        """
        is_archived: NotRequired[pulumi.Input[bool]]
        """
        Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
        """
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The asset property dictionary.
        """
        stage: NotRequired[pulumi.Input[str]]
        """
        Specifies the asset stage
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
elif False:
    FeaturestoreEntityVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeaturestoreEntityVersionArgs:
    def __init__(__self__, *,
                 auto_delete_setting: Optional[pulumi.Input['AutoDeleteSettingArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 index_columns: Optional[pulumi.Input[Sequence[pulumi.Input['IndexColumnArgs']]]] = None,
                 is_anonymous: Optional[pulumi.Input[bool]] = None,
                 is_archived: Optional[pulumi.Input[bool]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 stage: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Dto object representing feature entity version
        :param pulumi.Input['AutoDeleteSettingArgs'] auto_delete_setting: Specifies the lifecycle setting of managed data asset.
        :param pulumi.Input[str] description: The asset description text.
        :param pulumi.Input[Sequence[pulumi.Input['IndexColumnArgs']]] index_columns: Specifies index columns
        :param pulumi.Input[bool] is_anonymous: If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
        :param pulumi.Input[bool] is_archived: Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] properties: The asset property dictionary.
        :param pulumi.Input[str] stage: Specifies the asset stage
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        if auto_delete_setting is not None:
            pulumi.set(__self__, "auto_delete_setting", auto_delete_setting)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if index_columns is not None:
            pulumi.set(__self__, "index_columns", index_columns)
        if is_anonymous is None:
            is_anonymous = False
        if is_anonymous is not None:
            pulumi.set(__self__, "is_anonymous", is_anonymous)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if stage is not None:
            pulumi.set(__self__, "stage", stage)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="autoDeleteSetting")
    def auto_delete_setting(self) -> Optional[pulumi.Input['AutoDeleteSettingArgs']]:
        """
        Specifies the lifecycle setting of managed data asset.
        """
        return pulumi.get(self, "auto_delete_setting")

    @auto_delete_setting.setter
    def auto_delete_setting(self, value: Optional[pulumi.Input['AutoDeleteSettingArgs']]):
        pulumi.set(self, "auto_delete_setting", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="indexColumns")
    def index_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IndexColumnArgs']]]]:
        """
        Specifies index columns
        """
        return pulumi.get(self, "index_columns")

    @index_columns.setter
    def index_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IndexColumnArgs']]]]):
        pulumi.set(self, "index_columns", value)

    @property
    @pulumi.getter(name="isAnonymous")
    def is_anonymous(self) -> Optional[pulumi.Input[bool]]:
        """
        If the name version are system generated (anonymous registration). For types where Stage is defined, when Stage is provided it will be used to populate IsAnonymous
        """
        return pulumi.get(self, "is_anonymous")

    @is_anonymous.setter
    def is_anonymous(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_anonymous", value)

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the asset archived? For types where Stage is defined, when Stage is provided it will be used to populate IsArchived
        """
        return pulumi.get(self, "is_archived")

    @is_archived.setter
    def is_archived(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_archived", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def stage(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the asset stage
        """
        return pulumi.get(self, "stage")

    @stage.setter
    def stage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stage", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class FqdnOutboundRuleArgsDict(TypedDict):
        """
        FQDN Outbound Rule for the managed network of a machine learning workspace.
        """
        type: pulumi.Input[str]
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        Expected value is 'FQDN'.
        """
        category: NotRequired[pulumi.Input[Union[str, 'RuleCategory']]]
        """
        Category of a managed network Outbound Rule of a machine learning workspace.
        """
        destination: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[Union[str, 'RuleStatus']]]
        """
        Status of a managed network Outbound Rule of a machine learning workspace.
        """
elif False:
    FqdnOutboundRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FqdnOutboundRuleArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 category: Optional[pulumi.Input[Union[str, 'RuleCategory']]] = None,
                 destination: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[Union[str, 'RuleStatus']]] = None):
        """
        FQDN Outbound Rule for the managed network of a machine learning workspace.
        :param pulumi.Input[str] type: Type of a managed network Outbound Rule of a machine learning workspace.
               Expected value is 'FQDN'.
        :param pulumi.Input[Union[str, 'RuleCategory']] category: Category of a managed network Outbound Rule of a machine learning workspace.
        :param pulumi.Input[Union[str, 'RuleStatus']] status: Status of a managed network Outbound Rule of a machine learning workspace.
        """
        pulumi.set(__self__, "type", 'FQDN')
        if category is not None:
            pulumi.set(__self__, "category", category)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        Expected value is 'FQDN'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[Union[str, 'RuleCategory']]]:
        """
        Category of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[Union[str, 'RuleCategory']]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[str, 'RuleStatus']]]:
        """
        Status of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[str, 'RuleStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class IdentityForCmkArgsDict(TypedDict):
        """
        Identity that will be used to access key vault for encryption at rest
        """
        user_assigned_identity: NotRequired[pulumi.Input[str]]
        """
        The ArmId of the user assigned identity that will be used to access the customer managed key vault
        """
elif False:
    IdentityForCmkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityForCmkArgs:
    def __init__(__self__, *,
                 user_assigned_identity: Optional[pulumi.Input[str]] = None):
        """
        Identity that will be used to access key vault for encryption at rest
        :param pulumi.Input[str] user_assigned_identity: The ArmId of the user assigned identity that will be used to access the customer managed key vault
        """
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[pulumi.Input[str]]:
        """
        The ArmId of the user assigned identity that will be used to access the customer managed key vault
        """
        return pulumi.get(self, "user_assigned_identity")

    @user_assigned_identity.setter
    def user_assigned_identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity", value)


if not MYPY:
    class IndexColumnArgsDict(TypedDict):
        """
        Dto object representing index column
        """
        column_name: NotRequired[pulumi.Input[str]]
        """
        Specifies the column name
        """
        data_type: NotRequired[pulumi.Input[Union[str, 'FeatureDataType']]]
        """
        Specifies the data type
        """
elif False:
    IndexColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexColumnArgs:
    def __init__(__self__, *,
                 column_name: Optional[pulumi.Input[str]] = None,
                 data_type: Optional[pulumi.Input[Union[str, 'FeatureDataType']]] = None):
        """
        Dto object representing index column
        :param pulumi.Input[str] column_name: Specifies the column name
        :param pulumi.Input[Union[str, 'FeatureDataType']] data_type: Specifies the data type
        """
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)
        if data_type is None:
            data_type = 'String'
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the column name
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[Union[str, 'FeatureDataType']]]:
        """
        Specifies the data type
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[Union[str, 'FeatureDataType']]]):
        pulumi.set(self, "data_type", value)


if not MYPY:
    class JobServiceArgsDict(TypedDict):
        """
        Job endpoint definition
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        Url for endpoint.
        """
        job_service_type: NotRequired[pulumi.Input[str]]
        """
        Endpoint type.
        """
        nodes: NotRequired[pulumi.Input['AllNodesArgsDict']]
        """
        Nodes that user would like to start the service on.
        If Nodes is not set or set to null, the service will only be started on leader node.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port for endpoint set by user.
        """
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional properties to set on the endpoint.
        """
elif False:
    JobServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobServiceArgs:
    def __init__(__self__, *,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 job_service_type: Optional[pulumi.Input[str]] = None,
                 nodes: Optional[pulumi.Input['AllNodesArgs']] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Job endpoint definition
        :param pulumi.Input[str] endpoint: Url for endpoint.
        :param pulumi.Input[str] job_service_type: Endpoint type.
        :param pulumi.Input['AllNodesArgs'] nodes: Nodes that user would like to start the service on.
               If Nodes is not set or set to null, the service will only be started on leader node.
        :param pulumi.Input[int] port: Port for endpoint set by user.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] properties: Additional properties to set on the endpoint.
        """
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if job_service_type is not None:
            pulumi.set(__self__, "job_service_type", job_service_type)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Url for endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="jobServiceType")
    def job_service_type(self) -> Optional[pulumi.Input[str]]:
        """
        Endpoint type.
        """
        return pulumi.get(self, "job_service_type")

    @job_service_type.setter
    def job_service_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "job_service_type", value)

    @property
    @pulumi.getter
    def nodes(self) -> Optional[pulumi.Input['AllNodesArgs']]:
        """
        Nodes that user would like to start the service on.
        If Nodes is not set or set to null, the service will only be started on leader node.
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: Optional[pulumi.Input['AllNodesArgs']]):
        pulumi.set(self, "nodes", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port for endpoint set by user.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional properties to set on the endpoint.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class LabelCategoryArgsDict(TypedDict):
        """
        Label category definition
        """
        classes: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['LabelClassArgsDict']]]]
        """
        Dictionary of label classes in this category.
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        Display name of the label category.
        """
        multi_select: NotRequired[pulumi.Input[Union[str, 'MultiSelect']]]
        """
        Indicates whether it is allowed to select multiple classes in this category.
        """
elif False:
    LabelCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LabelCategoryArgs:
    def __init__(__self__, *,
                 classes: Optional[pulumi.Input[Mapping[str, pulumi.Input['LabelClassArgs']]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 multi_select: Optional[pulumi.Input[Union[str, 'MultiSelect']]] = None):
        """
        Label category definition
        :param pulumi.Input[Mapping[str, pulumi.Input['LabelClassArgs']]] classes: Dictionary of label classes in this category.
        :param pulumi.Input[str] display_name: Display name of the label category.
        :param pulumi.Input[Union[str, 'MultiSelect']] multi_select: Indicates whether it is allowed to select multiple classes in this category.
        """
        if classes is not None:
            pulumi.set(__self__, "classes", classes)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if multi_select is None:
            multi_select = 'Disabled'
        if multi_select is not None:
            pulumi.set(__self__, "multi_select", multi_select)

    @property
    @pulumi.getter
    def classes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['LabelClassArgs']]]]:
        """
        Dictionary of label classes in this category.
        """
        return pulumi.get(self, "classes")

    @classes.setter
    def classes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['LabelClassArgs']]]]):
        pulumi.set(self, "classes", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Display name of the label category.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="multiSelect")
    def multi_select(self) -> Optional[pulumi.Input[Union[str, 'MultiSelect']]]:
        """
        Indicates whether it is allowed to select multiple classes in this category.
        """
        return pulumi.get(self, "multi_select")

    @multi_select.setter
    def multi_select(self, value: Optional[pulumi.Input[Union[str, 'MultiSelect']]]):
        pulumi.set(self, "multi_select", value)


if not MYPY:
    class LabelClassArgsDict(TypedDict):
        """
        Label class definition
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        Display name of the label class.
        """
        subclasses: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['LabelClassArgsDict']]]]
        """
        Dictionary of subclasses of the label class.
        """
elif False:
    LabelClassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LabelClassArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 subclasses: Optional[pulumi.Input[Mapping[str, pulumi.Input['LabelClassArgs']]]] = None):
        """
        Label class definition
        :param pulumi.Input[str] display_name: Display name of the label class.
        :param pulumi.Input[Mapping[str, pulumi.Input['LabelClassArgs']]] subclasses: Dictionary of subclasses of the label class.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if subclasses is not None:
            pulumi.set(__self__, "subclasses", subclasses)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Display name of the label class.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def subclasses(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['LabelClassArgs']]]]:
        """
        Dictionary of subclasses of the label class.
        """
        return pulumi.get(self, "subclasses")

    @subclasses.setter
    def subclasses(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['LabelClassArgs']]]]):
        pulumi.set(self, "subclasses", value)


if not MYPY:
    class LabelingDataConfigurationArgsDict(TypedDict):
        """
        Labeling data configuration definition
        """
        data_id: NotRequired[pulumi.Input[str]]
        """
        Resource Id of the data asset to perform labeling.
        """
        incremental_data_refresh: NotRequired[pulumi.Input[Union[str, 'IncrementalDataRefresh']]]
        """
        Indicates whether to enable incremental data refresh.
        """
elif False:
    LabelingDataConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LabelingDataConfigurationArgs:
    def __init__(__self__, *,
                 data_id: Optional[pulumi.Input[str]] = None,
                 incremental_data_refresh: Optional[pulumi.Input[Union[str, 'IncrementalDataRefresh']]] = None):
        """
        Labeling data configuration definition
        :param pulumi.Input[str] data_id: Resource Id of the data asset to perform labeling.
        :param pulumi.Input[Union[str, 'IncrementalDataRefresh']] incremental_data_refresh: Indicates whether to enable incremental data refresh.
        """
        if data_id is not None:
            pulumi.set(__self__, "data_id", data_id)
        if incremental_data_refresh is None:
            incremental_data_refresh = 'Disabled'
        if incremental_data_refresh is not None:
            pulumi.set(__self__, "incremental_data_refresh", incremental_data_refresh)

    @property
    @pulumi.getter(name="dataId")
    def data_id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource Id of the data asset to perform labeling.
        """
        return pulumi.get(self, "data_id")

    @data_id.setter
    def data_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_id", value)

    @property
    @pulumi.getter(name="incrementalDataRefresh")
    def incremental_data_refresh(self) -> Optional[pulumi.Input[Union[str, 'IncrementalDataRefresh']]]:
        """
        Indicates whether to enable incremental data refresh.
        """
        return pulumi.get(self, "incremental_data_refresh")

    @incremental_data_refresh.setter
    def incremental_data_refresh(self, value: Optional[pulumi.Input[Union[str, 'IncrementalDataRefresh']]]):
        pulumi.set(self, "incremental_data_refresh", value)


if not MYPY:
    class LabelingJobImagePropertiesArgsDict(TypedDict):
        """
        Properties of a labeling job for image data
        """
        media_type: pulumi.Input[str]
        """
        Media type of data asset.
        Expected value is 'Image'.
        """
        annotation_type: NotRequired[pulumi.Input[Union[str, 'ImageAnnotationType']]]
        """
        Annotation type of image labeling job.
        """
elif False:
    LabelingJobImagePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LabelingJobImagePropertiesArgs:
    def __init__(__self__, *,
                 media_type: pulumi.Input[str],
                 annotation_type: Optional[pulumi.Input[Union[str, 'ImageAnnotationType']]] = None):
        """
        Properties of a labeling job for image data
        :param pulumi.Input[str] media_type: Media type of data asset.
               Expected value is 'Image'.
        :param pulumi.Input[Union[str, 'ImageAnnotationType']] annotation_type: Annotation type of image labeling job.
        """
        pulumi.set(__self__, "media_type", 'Image')
        if annotation_type is None:
            annotation_type = 'Classification'
        if annotation_type is not None:
            pulumi.set(__self__, "annotation_type", annotation_type)

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> pulumi.Input[str]:
        """
        Media type of data asset.
        Expected value is 'Image'.
        """
        return pulumi.get(self, "media_type")

    @media_type.setter
    def media_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "media_type", value)

    @property
    @pulumi.getter(name="annotationType")
    def annotation_type(self) -> Optional[pulumi.Input[Union[str, 'ImageAnnotationType']]]:
        """
        Annotation type of image labeling job.
        """
        return pulumi.get(self, "annotation_type")

    @annotation_type.setter
    def annotation_type(self, value: Optional[pulumi.Input[Union[str, 'ImageAnnotationType']]]):
        pulumi.set(self, "annotation_type", value)


if not MYPY:
    class LabelingJobInstructionsArgsDict(TypedDict):
        """
        Instructions for labeling job
        """
        uri: NotRequired[pulumi.Input[str]]
        """
        The link to a page with detailed labeling instructions for labelers.
        """
elif False:
    LabelingJobInstructionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LabelingJobInstructionsArgs:
    def __init__(__self__, *,
                 uri: Optional[pulumi.Input[str]] = None):
        """
        Instructions for labeling job
        :param pulumi.Input[str] uri: The link to a page with detailed labeling instructions for labelers.
        """
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        """
        The link to a page with detailed labeling instructions for labelers.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class LabelingJobTextPropertiesArgsDict(TypedDict):
        """
        Properties of a labeling job for text data
        """
        media_type: pulumi.Input[str]
        """
        Media type of data asset.
        Expected value is 'Text'.
        """
        annotation_type: NotRequired[pulumi.Input[Union[str, 'TextAnnotationType']]]
        """
        Annotation type of text labeling job.
        """
elif False:
    LabelingJobTextPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LabelingJobTextPropertiesArgs:
    def __init__(__self__, *,
                 media_type: pulumi.Input[str],
                 annotation_type: Optional[pulumi.Input[Union[str, 'TextAnnotationType']]] = None):
        """
        Properties of a labeling job for text data
        :param pulumi.Input[str] media_type: Media type of data asset.
               Expected value is 'Text'.
        :param pulumi.Input[Union[str, 'TextAnnotationType']] annotation_type: Annotation type of text labeling job.
        """
        pulumi.set(__self__, "media_type", 'Text')
        if annotation_type is None:
            annotation_type = 'Classification'
        if annotation_type is not None:
            pulumi.set(__self__, "annotation_type", annotation_type)

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> pulumi.Input[str]:
        """
        Media type of data asset.
        Expected value is 'Text'.
        """
        return pulumi.get(self, "media_type")

    @media_type.setter
    def media_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "media_type", value)

    @property
    @pulumi.getter(name="annotationType")
    def annotation_type(self) -> Optional[pulumi.Input[Union[str, 'TextAnnotationType']]]:
        """
        Annotation type of text labeling job.
        """
        return pulumi.get(self, "annotation_type")

    @annotation_type.setter
    def annotation_type(self, value: Optional[pulumi.Input[Union[str, 'TextAnnotationType']]]):
        pulumi.set(self, "annotation_type", value)


if not MYPY:
    class LabelingJobArgsDict(TypedDict):
        """
        Labeling job definition
        """
        job_type: pulumi.Input[str]
        """
        Enum to determine the type of job.
        Expected value is 'Labeling'.
        """
        component_id: NotRequired[pulumi.Input[str]]
        """
        ARM resource ID of the component resource.
        """
        compute_id: NotRequired[pulumi.Input[str]]
        """
        ARM resource ID of the compute resource.
        """
        data_configuration: NotRequired[pulumi.Input['LabelingDataConfigurationArgsDict']]
        """
        Configuration of data used in the job.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The asset description text.
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        Display name of job.
        """
        experiment_name: NotRequired[pulumi.Input[str]]
        """
        The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        """
        identity: NotRequired[pulumi.Input[Union['AmlTokenArgsDict', 'ManagedIdentityArgsDict', 'UserIdentityArgsDict']]]
        """
        Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
        Defaults to AmlToken if null.
        """
        is_archived: NotRequired[pulumi.Input[bool]]
        """
        Is the asset archived?
        """
        job_instructions: NotRequired[pulumi.Input['LabelingJobInstructionsArgsDict']]
        """
        Labeling instructions of the job.
        """
        label_categories: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['LabelCategoryArgsDict']]]]
        """
        Label categories of the job.
        """
        labeling_job_media_properties: NotRequired[pulumi.Input[Union['LabelingJobImagePropertiesArgsDict', 'LabelingJobTextPropertiesArgsDict']]]
        """
        Media type specific properties in the job.
        """
        ml_assist_configuration: NotRequired[pulumi.Input[Union['MLAssistConfigurationDisabledArgsDict', 'MLAssistConfigurationEnabledArgsDict']]]
        """
        Configuration of MLAssist feature in the job.
        """
        notification_setting: NotRequired[pulumi.Input['NotificationSettingArgsDict']]
        """
        Notification setting for the job
        """
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The asset property dictionary.
        """
        secrets_configuration: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['SecretConfigurationArgsDict']]]]
        """
        Configuration for secrets to be made available during runtime.
        """
        services: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['JobServiceArgsDict']]]]
        """
        List of JobEndpoints.
        For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
elif False:
    LabelingJobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LabelingJobArgs:
    def __init__(__self__, *,
                 job_type: pulumi.Input[str],
                 component_id: Optional[pulumi.Input[str]] = None,
                 compute_id: Optional[pulumi.Input[str]] = None,
                 data_configuration: Optional[pulumi.Input['LabelingDataConfigurationArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 experiment_name: Optional[pulumi.Input[str]] = None,
                 identity: Optional[pulumi.Input[Union['AmlTokenArgs', 'ManagedIdentityArgs', 'UserIdentityArgs']]] = None,
                 is_archived: Optional[pulumi.Input[bool]] = None,
                 job_instructions: Optional[pulumi.Input['LabelingJobInstructionsArgs']] = None,
                 label_categories: Optional[pulumi.Input[Mapping[str, pulumi.Input['LabelCategoryArgs']]]] = None,
                 labeling_job_media_properties: Optional[pulumi.Input[Union['LabelingJobImagePropertiesArgs', 'LabelingJobTextPropertiesArgs']]] = None,
                 ml_assist_configuration: Optional[pulumi.Input[Union['MLAssistConfigurationDisabledArgs', 'MLAssistConfigurationEnabledArgs']]] = None,
                 notification_setting: Optional[pulumi.Input['NotificationSettingArgs']] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secrets_configuration: Optional[pulumi.Input[Mapping[str, pulumi.Input['SecretConfigurationArgs']]]] = None,
                 services: Optional[pulumi.Input[Mapping[str, pulumi.Input['JobServiceArgs']]]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Labeling job definition
        :param pulumi.Input[str] job_type: Enum to determine the type of job.
               Expected value is 'Labeling'.
        :param pulumi.Input[str] component_id: ARM resource ID of the component resource.
        :param pulumi.Input[str] compute_id: ARM resource ID of the compute resource.
        :param pulumi.Input['LabelingDataConfigurationArgs'] data_configuration: Configuration of data used in the job.
        :param pulumi.Input[str] description: The asset description text.
        :param pulumi.Input[str] display_name: Display name of job.
        :param pulumi.Input[str] experiment_name: The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        :param pulumi.Input[Union['AmlTokenArgs', 'ManagedIdentityArgs', 'UserIdentityArgs']] identity: Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
               Defaults to AmlToken if null.
        :param pulumi.Input[bool] is_archived: Is the asset archived?
        :param pulumi.Input['LabelingJobInstructionsArgs'] job_instructions: Labeling instructions of the job.
        :param pulumi.Input[Mapping[str, pulumi.Input['LabelCategoryArgs']]] label_categories: Label categories of the job.
        :param pulumi.Input[Union['LabelingJobImagePropertiesArgs', 'LabelingJobTextPropertiesArgs']] labeling_job_media_properties: Media type specific properties in the job.
        :param pulumi.Input[Union['MLAssistConfigurationDisabledArgs', 'MLAssistConfigurationEnabledArgs']] ml_assist_configuration: Configuration of MLAssist feature in the job.
        :param pulumi.Input['NotificationSettingArgs'] notification_setting: Notification setting for the job
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] properties: The asset property dictionary.
        :param pulumi.Input[Mapping[str, pulumi.Input['SecretConfigurationArgs']]] secrets_configuration: Configuration for secrets to be made available during runtime.
        :param pulumi.Input[Mapping[str, pulumi.Input['JobServiceArgs']]] services: List of JobEndpoints.
               For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: Tag dictionary. Tags can be added, removed, and updated.
        """
        pulumi.set(__self__, "job_type", 'Labeling')
        if component_id is not None:
            pulumi.set(__self__, "component_id", component_id)
        if compute_id is not None:
            pulumi.set(__self__, "compute_id", compute_id)
        if data_configuration is not None:
            pulumi.set(__self__, "data_configuration", data_configuration)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if experiment_name is None:
            experiment_name = 'Default'
        if experiment_name is not None:
            pulumi.set(__self__, "experiment_name", experiment_name)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if is_archived is None:
            is_archived = False
        if is_archived is not None:
            pulumi.set(__self__, "is_archived", is_archived)
        if job_instructions is not None:
            pulumi.set(__self__, "job_instructions", job_instructions)
        if label_categories is not None:
            pulumi.set(__self__, "label_categories", label_categories)
        if labeling_job_media_properties is not None:
            pulumi.set(__self__, "labeling_job_media_properties", labeling_job_media_properties)
        if ml_assist_configuration is not None:
            pulumi.set(__self__, "ml_assist_configuration", ml_assist_configuration)
        if notification_setting is not None:
            pulumi.set(__self__, "notification_setting", notification_setting)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if secrets_configuration is not None:
            pulumi.set(__self__, "secrets_configuration", secrets_configuration)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="jobType")
    def job_type(self) -> pulumi.Input[str]:
        """
        Enum to determine the type of job.
        Expected value is 'Labeling'.
        """
        return pulumi.get(self, "job_type")

    @job_type.setter
    def job_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "job_type", value)

    @property
    @pulumi.getter(name="componentId")
    def component_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM resource ID of the component resource.
        """
        return pulumi.get(self, "component_id")

    @component_id.setter
    def component_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "component_id", value)

    @property
    @pulumi.getter(name="computeId")
    def compute_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM resource ID of the compute resource.
        """
        return pulumi.get(self, "compute_id")

    @compute_id.setter
    def compute_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compute_id", value)

    @property
    @pulumi.getter(name="dataConfiguration")
    def data_configuration(self) -> Optional[pulumi.Input['LabelingDataConfigurationArgs']]:
        """
        Configuration of data used in the job.
        """
        return pulumi.get(self, "data_configuration")

    @data_configuration.setter
    def data_configuration(self, value: Optional[pulumi.Input['LabelingDataConfigurationArgs']]):
        pulumi.set(self, "data_configuration", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The asset description text.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Display name of job.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="experimentName")
    def experiment_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
        """
        return pulumi.get(self, "experiment_name")

    @experiment_name.setter
    def experiment_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "experiment_name", value)

    @property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input[Union['AmlTokenArgs', 'ManagedIdentityArgs', 'UserIdentityArgs']]]:
        """
        Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
        Defaults to AmlToken if null.
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input[Union['AmlTokenArgs', 'ManagedIdentityArgs', 'UserIdentityArgs']]]):
        pulumi.set(self, "identity", value)

    @property
    @pulumi.getter(name="isArchived")
    def is_archived(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the asset archived?
        """
        return pulumi.get(self, "is_archived")

    @is_archived.setter
    def is_archived(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_archived", value)

    @property
    @pulumi.getter(name="jobInstructions")
    def job_instructions(self) -> Optional[pulumi.Input['LabelingJobInstructionsArgs']]:
        """
        Labeling instructions of the job.
        """
        return pulumi.get(self, "job_instructions")

    @job_instructions.setter
    def job_instructions(self, value: Optional[pulumi.Input['LabelingJobInstructionsArgs']]):
        pulumi.set(self, "job_instructions", value)

    @property
    @pulumi.getter(name="labelCategories")
    def label_categories(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['LabelCategoryArgs']]]]:
        """
        Label categories of the job.
        """
        return pulumi.get(self, "label_categories")

    @label_categories.setter
    def label_categories(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['LabelCategoryArgs']]]]):
        pulumi.set(self, "label_categories", value)

    @property
    @pulumi.getter(name="labelingJobMediaProperties")
    def labeling_job_media_properties(self) -> Optional[pulumi.Input[Union['LabelingJobImagePropertiesArgs', 'LabelingJobTextPropertiesArgs']]]:
        """
        Media type specific properties in the job.
        """
        return pulumi.get(self, "labeling_job_media_properties")

    @labeling_job_media_properties.setter
    def labeling_job_media_properties(self, value: Optional[pulumi.Input[Union['LabelingJobImagePropertiesArgs', 'LabelingJobTextPropertiesArgs']]]):
        pulumi.set(self, "labeling_job_media_properties", value)

    @property
    @pulumi.getter(name="mlAssistConfiguration")
    def ml_assist_configuration(self) -> Optional[pulumi.Input[Union['MLAssistConfigurationDisabledArgs', 'MLAssistConfigurationEnabledArgs']]]:
        """
        Configuration of MLAssist feature in the job.
        """
        return pulumi.get(self, "ml_assist_configuration")

    @ml_assist_configuration.setter
    def ml_assist_configuration(self, value: Optional[pulumi.Input[Union['MLAssistConfigurationDisabledArgs', 'MLAssistConfigurationEnabledArgs']]]):
        pulumi.set(self, "ml_assist_configuration", value)

    @property
    @pulumi.getter(name="notificationSetting")
    def notification_setting(self) -> Optional[pulumi.Input['NotificationSettingArgs']]:
        """
        Notification setting for the job
        """
        return pulumi.get(self, "notification_setting")

    @notification_setting.setter
    def notification_setting(self, value: Optional[pulumi.Input['NotificationSettingArgs']]):
        pulumi.set(self, "notification_setting", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The asset property dictionary.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="secretsConfiguration")
    def secrets_configuration(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['SecretConfigurationArgs']]]]:
        """
        Configuration for secrets to be made available during runtime.
        """
        return pulumi.get(self, "secrets_configuration")

    @secrets_configuration.setter
    def secrets_configuration(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['SecretConfigurationArgs']]]]):
        pulumi.set(self, "secrets_configuration", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['JobServiceArgs']]]]:
        """
        List of JobEndpoints.
        For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['JobServiceArgs']]]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Tag dictionary. Tags can be added, removed, and updated.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class MLAssistConfigurationDisabledArgsDict(TypedDict):
        """
        Labeling MLAssist configuration definition when MLAssist is disabled
        """
        ml_assist: pulumi.Input[str]
        """

        Expected value is 'Disabled'.
        """
elif False:
    MLAssistConfigurationDisabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MLAssistConfigurationDisabledArgs:
    def __init__(__self__, *,
                 ml_assist: pulumi.Input[str]):
        """
        Labeling MLAssist configuration definition when MLAssist is disabled
        :param pulumi.Input[str] ml_assist: 
               Expected value is 'Disabled'.
        """
        pulumi.set(__self__, "ml_assist", 'Disabled')

    @property
    @pulumi.getter(name="mlAssist")
    def ml_assist(self) -> pulumi.Input[str]:
        """

        Expected value is 'Disabled'.
        """
        return pulumi.get(self, "ml_assist")

    @ml_assist.setter
    def ml_assist(self, value: pulumi.Input[str]):
        pulumi.set(self, "ml_assist", value)


if not MYPY:
    class MLAssistConfigurationEnabledArgsDict(TypedDict):
        """
        Labeling MLAssist configuration definition when MLAssist is enabled
        """
        inferencing_compute_binding: pulumi.Input[str]
        """
        [Required] AML compute binding used in inferencing.
        """
        ml_assist: pulumi.Input[str]
        """

        Expected value is 'Enabled'.
        """
        training_compute_binding: pulumi.Input[str]
        """
        [Required] AML compute binding used in training.
        """
elif False:
    MLAssistConfigurationEnabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MLAssistConfigurationEnabledArgs:
    def __init__(__self__, *,
                 inferencing_compute_binding: pulumi.Input[str],
                 ml_assist: pulumi.Input[str],
                 training_compute_binding: pulumi.Input[str]):
        """
        Labeling MLAssist configuration definition when MLAssist is enabled
        :param pulumi.Input[str] inferencing_compute_binding: [Required] AML compute binding used in inferencing.
        :param pulumi.Input[str] ml_assist: 
               Expected value is 'Enabled'.
        :param pulumi.Input[str] training_compute_binding: [Required] AML compute binding used in training.
        """
        pulumi.set(__self__, "inferencing_compute_binding", inferencing_compute_binding)
        pulumi.set(__self__, "ml_assist", 'Enabled')
        pulumi.set(__self__, "training_compute_binding", training_compute_binding)

    @property
    @pulumi.getter(name="inferencingComputeBinding")
    def inferencing_compute_binding(self) -> pulumi.Input[str]:
        """
        [Required] AML compute binding used in inferencing.
        """
        return pulumi.get(self, "inferencing_compute_binding")

    @inferencing_compute_binding.setter
    def inferencing_compute_binding(self, value: pulumi.Input[str]):
        pulumi.set(self, "inferencing_compute_binding", value)

    @property
    @pulumi.getter(name="mlAssist")
    def ml_assist(self) -> pulumi.Input[str]:
        """

        Expected value is 'Enabled'.
        """
        return pulumi.get(self, "ml_assist")

    @ml_assist.setter
    def ml_assist(self, value: pulumi.Input[str]):
        pulumi.set(self, "ml_assist", value)

    @property
    @pulumi.getter(name="trainingComputeBinding")
    def training_compute_binding(self) -> pulumi.Input[str]:
        """
        [Required] AML compute binding used in training.
        """
        return pulumi.get(self, "training_compute_binding")

    @training_compute_binding.setter
    def training_compute_binding(self, value: pulumi.Input[str]):
        pulumi.set(self, "training_compute_binding", value)


if not MYPY:
    class ManagedIdentityArgsDict(TypedDict):
        """
        Managed identity configuration.
        """
        identity_type: pulumi.Input[str]
        """
        Enum to determine identity framework.
        Expected value is 'Managed'.
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        Specifies a user-assigned identity by client ID. For system-assigned, do not set this field.
        """
        object_id: NotRequired[pulumi.Input[str]]
        """
        Specifies a user-assigned identity by object ID. For system-assigned, do not set this field.
        """
        resource_id: NotRequired[pulumi.Input[str]]
        """
        Specifies a user-assigned identity by ARM resource ID. For system-assigned, do not set this field.
        """
elif False:
    ManagedIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedIdentityArgs:
    def __init__(__self__, *,
                 identity_type: pulumi.Input[str],
                 client_id: Optional[pulumi.Input[str]] = None,
                 object_id: Optional[pulumi.Input[str]] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        Managed identity configuration.
        :param pulumi.Input[str] identity_type: Enum to determine identity framework.
               Expected value is 'Managed'.
        :param pulumi.Input[str] client_id: Specifies a user-assigned identity by client ID. For system-assigned, do not set this field.
        :param pulumi.Input[str] object_id: Specifies a user-assigned identity by object ID. For system-assigned, do not set this field.
        :param pulumi.Input[str] resource_id: Specifies a user-assigned identity by ARM resource ID. For system-assigned, do not set this field.
        """
        pulumi.set(__self__, "identity_type", 'Managed')
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="identityType")
    def identity_type(self) -> pulumi.Input[str]:
        """
        Enum to determine identity framework.
        Expected value is 'Managed'.
        """
        return pulumi.get(self, "identity_type")

    @identity_type.setter
    def identity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_type", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a user-assigned identity by client ID. For system-assigned, do not set this field.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a user-assigned identity by object ID. For system-assigned, do not set this field.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a user-assigned identity by ARM resource ID. For system-assigned, do not set this field.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


if not MYPY:
    class ManagedNetworkProvisionStatusArgsDict(TypedDict):
        """
        Status of the Provisioning for the managed network of a machine learning workspace.
        """
        spark_ready: NotRequired[pulumi.Input[bool]]
        status: NotRequired[pulumi.Input[Union[str, 'ManagedNetworkStatus']]]
        """
        Status for the managed network of a machine learning workspace.
        """
elif False:
    ManagedNetworkProvisionStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedNetworkProvisionStatusArgs:
    def __init__(__self__, *,
                 spark_ready: Optional[pulumi.Input[bool]] = None,
                 status: Optional[pulumi.Input[Union[str, 'ManagedNetworkStatus']]] = None):
        """
        Status of the Provisioning for the managed network of a machine learning workspace.
        :param pulumi.Input[Union[str, 'ManagedNetworkStatus']] status: Status for the managed network of a machine learning workspace.
        """
        if spark_ready is not None:
            pulumi.set(__self__, "spark_ready", spark_ready)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="sparkReady")
    def spark_ready(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "spark_ready")

    @spark_ready.setter
    def spark_ready(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "spark_ready", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[str, 'ManagedNetworkStatus']]]:
        """
        Status for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[str, 'ManagedNetworkStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ManagedNetworkSettingsArgsDict(TypedDict):
        """
        Managed Network settings for a machine learning workspace.
        """
        isolation_mode: NotRequired[pulumi.Input[Union[str, 'IsolationMode']]]
        """
        Isolation mode for the managed network of a machine learning workspace.
        """
        outbound_rules: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Union['FqdnOutboundRuleArgsDict', 'PrivateEndpointOutboundRuleArgsDict', 'ServiceTagOutboundRuleArgsDict']]]]]
        status: NotRequired[pulumi.Input['ManagedNetworkProvisionStatusArgsDict']]
        """
        Status of the Provisioning for the managed network of a machine learning workspace.
        """
elif False:
    ManagedNetworkSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedNetworkSettingsArgs:
    def __init__(__self__, *,
                 isolation_mode: Optional[pulumi.Input[Union[str, 'IsolationMode']]] = None,
                 outbound_rules: Optional[pulumi.Input[Mapping[str, pulumi.Input[Union['FqdnOutboundRuleArgs', 'PrivateEndpointOutboundRuleArgs', 'ServiceTagOutboundRuleArgs']]]]] = None,
                 status: Optional[pulumi.Input['ManagedNetworkProvisionStatusArgs']] = None):
        """
        Managed Network settings for a machine learning workspace.
        :param pulumi.Input[Union[str, 'IsolationMode']] isolation_mode: Isolation mode for the managed network of a machine learning workspace.
        :param pulumi.Input['ManagedNetworkProvisionStatusArgs'] status: Status of the Provisioning for the managed network of a machine learning workspace.
        """
        if isolation_mode is not None:
            pulumi.set(__self__, "isolation_mode", isolation_mode)
        if outbound_rules is not None:
            pulumi.set(__self__, "outbound_rules", outbound_rules)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="isolationMode")
    def isolation_mode(self) -> Optional[pulumi.Input[Union[str, 'IsolationMode']]]:
        """
        Isolation mode for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "isolation_mode")

    @isolation_mode.setter
    def isolation_mode(self, value: Optional[pulumi.Input[Union[str, 'IsolationMode']]]):
        pulumi.set(self, "isolation_mode", value)

    @property
    @pulumi.getter(name="outboundRules")
    def outbound_rules(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Union['FqdnOutboundRuleArgs', 'PrivateEndpointOutboundRuleArgs', 'ServiceTagOutboundRuleArgs']]]]]:
        return pulumi.get(self, "outbound_rules")

    @outbound_rules.setter
    def outbound_rules(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Union['FqdnOutboundRuleArgs', 'PrivateEndpointOutboundRuleArgs', 'ServiceTagOutboundRuleArgs']]]]]):
        pulumi.set(self, "outbound_rules", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['ManagedNetworkProvisionStatusArgs']]:
        """
        Status of the Provisioning for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['ManagedNetworkProvisionStatusArgs']]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ManagedServiceIdentityArgsDict(TypedDict):
        """
        Managed service identity (system assigned and/or user assigned identities)
        """
        type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    ManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param pulumi.Input[Union[str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class MaterializationComputeResourceArgsDict(TypedDict):
        """
        Dto object representing compute resource
        """
        instance_type: NotRequired[pulumi.Input[str]]
        """
        Specifies the instance type
        """
elif False:
    MaterializationComputeResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaterializationComputeResourceArgs:
    def __init__(__self__, *,
                 instance_type: Optional[pulumi.Input[str]] = None):
        """
        Dto object representing compute resource
        :param pulumi.Input[str] instance_type: Specifies the instance type
        """
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the instance type
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_type", value)


if not MYPY:
    class MaterializationSettingsArgsDict(TypedDict):
        notification: NotRequired[pulumi.Input['NotificationSettingArgsDict']]
        """
        Specifies the notification details
        """
        resource: NotRequired[pulumi.Input['MaterializationComputeResourceArgsDict']]
        """
        Specifies the compute resource settings
        """
        schedule: NotRequired[pulumi.Input['RecurrenceTriggerArgsDict']]
        """
        Specifies the schedule details
        """
        spark_configuration: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Specifies the spark compute settings
        """
        store_type: NotRequired[pulumi.Input[Union[str, 'MaterializationStoreType']]]
        """
        Specifies the stores to which materialization should happen
        """
elif False:
    MaterializationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaterializationSettingsArgs:
    def __init__(__self__, *,
                 notification: Optional[pulumi.Input['NotificationSettingArgs']] = None,
                 resource: Optional[pulumi.Input['MaterializationComputeResourceArgs']] = None,
                 schedule: Optional[pulumi.Input['RecurrenceTriggerArgs']] = None,
                 spark_configuration: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 store_type: Optional[pulumi.Input[Union[str, 'MaterializationStoreType']]] = None):
        """
        :param pulumi.Input['NotificationSettingArgs'] notification: Specifies the notification details
        :param pulumi.Input['MaterializationComputeResourceArgs'] resource: Specifies the compute resource settings
        :param pulumi.Input['RecurrenceTriggerArgs'] schedule: Specifies the schedule details
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] spark_configuration: Specifies the spark compute settings
        :param pulumi.Input[Union[str, 'MaterializationStoreType']] store_type: Specifies the stores to which materialization should happen
        """
        if notification is not None:
            pulumi.set(__self__, "notification", notification)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if spark_configuration is not None:
            pulumi.set(__self__, "spark_configuration", spark_configuration)
        if store_type is None:
            store_type = 'None'
        if store_type is not None:
            pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter
    def notification(self) -> Optional[pulumi.Input['NotificationSettingArgs']]:
        """
        Specifies the notification details
        """
        return pulumi.get(self, "notification")

    @notification.setter
    def notification(self, value: Optional[pulumi.Input['NotificationSettingArgs']]):
        pulumi.set(self, "notification", value)

    @property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input['MaterializationComputeResourceArgs']]:
        """
        Specifies the compute resource settings
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input['MaterializationComputeResourceArgs']]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['RecurrenceTriggerArgs']]:
        """
        Specifies the schedule details
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['RecurrenceTriggerArgs']]):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="sparkConfiguration")
    def spark_configuration(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies the spark compute settings
        """
        return pulumi.get(self, "spark_configuration")

    @spark_configuration.setter
    def spark_configuration(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "spark_configuration", value)

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> Optional[pulumi.Input[Union[str, 'MaterializationStoreType']]]:
        """
        Specifies the stores to which materialization should happen
        """
        return pulumi.get(self, "store_type")

    @store_type.setter
    def store_type(self, value: Optional[pulumi.Input[Union[str, 'MaterializationStoreType']]]):
        pulumi.set(self, "store_type", value)


if not MYPY:
    class NotificationSettingArgsDict(TypedDict):
        """
        Configuration for notification.
        """
        email_on: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'EmailNotificationEnableType']]]]]
        """
        Send email notification to user on specified notification type
        """
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        This is the email recipient list which has a limitation of 499 characters in total concat with comma separator
        """
        webhooks: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['AzureDevOpsWebhookArgsDict']]]]
        """
        Send webhook callback to a service. Key is a user-provided name for the webhook.
        """
elif False:
    NotificationSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationSettingArgs:
    def __init__(__self__, *,
                 email_on: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'EmailNotificationEnableType']]]]] = None,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 webhooks: Optional[pulumi.Input[Mapping[str, pulumi.Input['AzureDevOpsWebhookArgs']]]] = None):
        """
        Configuration for notification.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'EmailNotificationEnableType']]]] email_on: Send email notification to user on specified notification type
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: This is the email recipient list which has a limitation of 499 characters in total concat with comma separator
        :param pulumi.Input[Mapping[str, pulumi.Input['AzureDevOpsWebhookArgs']]] webhooks: Send webhook callback to a service. Key is a user-provided name for the webhook.
        """
        if email_on is not None:
            pulumi.set(__self__, "email_on", email_on)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if webhooks is not None:
            pulumi.set(__self__, "webhooks", webhooks)

    @property
    @pulumi.getter(name="emailOn")
    def email_on(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'EmailNotificationEnableType']]]]]:
        """
        Send email notification to user on specified notification type
        """
        return pulumi.get(self, "email_on")

    @email_on.setter
    def email_on(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'EmailNotificationEnableType']]]]]):
        pulumi.set(self, "email_on", value)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        This is the email recipient list which has a limitation of 499 characters in total concat with comma separator
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def webhooks(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['AzureDevOpsWebhookArgs']]]]:
        """
        Send webhook callback to a service. Key is a user-provided name for the webhook.
        """
        return pulumi.get(self, "webhooks")

    @webhooks.setter
    def webhooks(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['AzureDevOpsWebhookArgs']]]]):
        pulumi.set(self, "webhooks", value)


if not MYPY:
    class PrivateEndpointDestinationArgsDict(TypedDict):
        """
        Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        """
        service_resource_id: NotRequired[pulumi.Input[str]]
        spark_enabled: NotRequired[pulumi.Input[bool]]
        spark_status: NotRequired[pulumi.Input[Union[str, 'RuleStatus']]]
        """
        Status of a managed network Outbound Rule of a machine learning workspace.
        """
        subresource_target: NotRequired[pulumi.Input[str]]
elif False:
    PrivateEndpointDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateEndpointDestinationArgs:
    def __init__(__self__, *,
                 service_resource_id: Optional[pulumi.Input[str]] = None,
                 spark_enabled: Optional[pulumi.Input[bool]] = None,
                 spark_status: Optional[pulumi.Input[Union[str, 'RuleStatus']]] = None,
                 subresource_target: Optional[pulumi.Input[str]] = None):
        """
        Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        :param pulumi.Input[Union[str, 'RuleStatus']] spark_status: Status of a managed network Outbound Rule of a machine learning workspace.
        """
        if service_resource_id is not None:
            pulumi.set(__self__, "service_resource_id", service_resource_id)
        if spark_enabled is not None:
            pulumi.set(__self__, "spark_enabled", spark_enabled)
        if spark_status is not None:
            pulumi.set(__self__, "spark_status", spark_status)
        if subresource_target is not None:
            pulumi.set(__self__, "subresource_target", subresource_target)

    @property
    @pulumi.getter(name="serviceResourceId")
    def service_resource_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_resource_id")

    @service_resource_id.setter
    def service_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_resource_id", value)

    @property
    @pulumi.getter(name="sparkEnabled")
    def spark_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "spark_enabled")

    @spark_enabled.setter
    def spark_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "spark_enabled", value)

    @property
    @pulumi.getter(name="sparkStatus")
    def spark_status(self) -> Optional[pulumi.Input[Union[str, 'RuleStatus']]]:
        """
        Status of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "spark_status")

    @spark_status.setter
    def spark_status(self, value: Optional[pulumi.Input[Union[str, 'RuleStatus']]]):
        pulumi.set(self, "spark_status", value)

    @property
    @pulumi.getter(name="subresourceTarget")
    def subresource_target(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "subresource_target")

    @subresource_target.setter
    def subresource_target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subresource_target", value)


if not MYPY:
    class PrivateEndpointOutboundRuleArgsDict(TypedDict):
        """
        Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        """
        type: pulumi.Input[str]
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        Expected value is 'PrivateEndpoint'.
        """
        category: NotRequired[pulumi.Input[Union[str, 'RuleCategory']]]
        """
        Category of a managed network Outbound Rule of a machine learning workspace.
        """
        destination: NotRequired[pulumi.Input['PrivateEndpointDestinationArgsDict']]
        """
        Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        """
        status: NotRequired[pulumi.Input[Union[str, 'RuleStatus']]]
        """
        Status of a managed network Outbound Rule of a machine learning workspace.
        """
elif False:
    PrivateEndpointOutboundRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateEndpointOutboundRuleArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 category: Optional[pulumi.Input[Union[str, 'RuleCategory']]] = None,
                 destination: Optional[pulumi.Input['PrivateEndpointDestinationArgs']] = None,
                 status: Optional[pulumi.Input[Union[str, 'RuleStatus']]] = None):
        """
        Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        :param pulumi.Input[str] type: Type of a managed network Outbound Rule of a machine learning workspace.
               Expected value is 'PrivateEndpoint'.
        :param pulumi.Input[Union[str, 'RuleCategory']] category: Category of a managed network Outbound Rule of a machine learning workspace.
        :param pulumi.Input['PrivateEndpointDestinationArgs'] destination: Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        :param pulumi.Input[Union[str, 'RuleStatus']] status: Status of a managed network Outbound Rule of a machine learning workspace.
        """
        pulumi.set(__self__, "type", 'PrivateEndpoint')
        if category is not None:
            pulumi.set(__self__, "category", category)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        Expected value is 'PrivateEndpoint'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[Union[str, 'RuleCategory']]]:
        """
        Category of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[Union[str, 'RuleCategory']]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input['PrivateEndpointDestinationArgs']]:
        """
        Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input['PrivateEndpointDestinationArgs']]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[str, 'RuleStatus']]]:
        """
        Status of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[str, 'RuleStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class RecurrenceScheduleArgsDict(TypedDict):
        hours: pulumi.Input[Sequence[pulumi.Input[int]]]
        """
        [Required] List of hours for the schedule.
        """
        minutes: pulumi.Input[Sequence[pulumi.Input[int]]]
        """
        [Required] List of minutes for the schedule.
        """
        month_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        List of month days for the schedule
        """
        week_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'WeekDay']]]]]
        """
        List of days for the schedule.
        """
elif False:
    RecurrenceScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecurrenceScheduleArgs:
    def __init__(__self__, *,
                 hours: pulumi.Input[Sequence[pulumi.Input[int]]],
                 minutes: pulumi.Input[Sequence[pulumi.Input[int]]],
                 month_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 week_days: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'WeekDay']]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours: [Required] List of hours for the schedule.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] minutes: [Required] List of minutes for the schedule.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] month_days: List of month days for the schedule
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'WeekDay']]]] week_days: List of days for the schedule.
        """
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)
        if month_days is not None:
            pulumi.set(__self__, "month_days", month_days)
        if week_days is not None:
            pulumi.set(__self__, "week_days", week_days)

    @property
    @pulumi.getter
    def hours(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        [Required] List of hours for the schedule.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        [Required] List of minutes for the schedule.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter(name="monthDays")
    def month_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        List of month days for the schedule
        """
        return pulumi.get(self, "month_days")

    @month_days.setter
    def month_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "month_days", value)

    @property
    @pulumi.getter(name="weekDays")
    def week_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'WeekDay']]]]]:
        """
        List of days for the schedule.
        """
        return pulumi.get(self, "week_days")

    @week_days.setter
    def week_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'WeekDay']]]]]):
        pulumi.set(self, "week_days", value)


if not MYPY:
    class RecurrenceTriggerArgsDict(TypedDict):
        frequency: pulumi.Input[Union[str, 'RecurrenceFrequency']]
        """
        [Required] The frequency to trigger schedule.
        """
        interval: pulumi.Input[int]
        """
        [Required] Specifies schedule interval in conjunction with frequency
        """
        trigger_type: pulumi.Input[str]
        """

        Expected value is 'Recurrence'.
        """
        end_time: NotRequired[pulumi.Input[str]]
        """
        Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer https://en.wikipedia.org/wiki/ISO_8601.
        Recommented format would be "2022-06-01T00:00:01"
        If not present, the schedule will run indefinitely
        """
        schedule: NotRequired[pulumi.Input['RecurrenceScheduleArgsDict']]
        """
        The recurrence schedule.
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        Specifies start time of schedule in ISO 8601 format, but without a UTC offset.
        """
        time_zone: NotRequired[pulumi.Input[str]]
        """
        Specifies time zone in which the schedule runs.
        TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
        """
elif False:
    RecurrenceTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecurrenceTriggerArgs:
    def __init__(__self__, *,
                 frequency: pulumi.Input[Union[str, 'RecurrenceFrequency']],
                 interval: pulumi.Input[int],
                 trigger_type: pulumi.Input[str],
                 end_time: Optional[pulumi.Input[str]] = None,
                 schedule: Optional[pulumi.Input['RecurrenceScheduleArgs']] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Union[str, 'RecurrenceFrequency']] frequency: [Required] The frequency to trigger schedule.
        :param pulumi.Input[int] interval: [Required] Specifies schedule interval in conjunction with frequency
        :param pulumi.Input[str] trigger_type: 
               Expected value is 'Recurrence'.
        :param pulumi.Input[str] end_time: Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer https://en.wikipedia.org/wiki/ISO_8601.
               Recommented format would be "2022-06-01T00:00:01"
               If not present, the schedule will run indefinitely
        :param pulumi.Input['RecurrenceScheduleArgs'] schedule: The recurrence schedule.
        :param pulumi.Input[str] start_time: Specifies start time of schedule in ISO 8601 format, but without a UTC offset.
        :param pulumi.Input[str] time_zone: Specifies time zone in which the schedule runs.
               TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
        """
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "trigger_type", 'Recurrence')
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if time_zone is None:
            time_zone = 'UTC'
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def frequency(self) -> pulumi.Input[Union[str, 'RecurrenceFrequency']]:
        """
        [Required] The frequency to trigger schedule.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: pulumi.Input[Union[str, 'RecurrenceFrequency']]):
        pulumi.set(self, "frequency", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[int]:
        """
        [Required] Specifies schedule interval in conjunction with frequency
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> pulumi.Input[str]:
        """

        Expected value is 'Recurrence'.
        """
        return pulumi.get(self, "trigger_type")

    @trigger_type.setter
    def trigger_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "trigger_type", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies end time of schedule in ISO 8601, but without a UTC offset. Refer https://en.wikipedia.org/wiki/ISO_8601.
        Recommented format would be "2022-06-01T00:00:01"
        If not present, the schedule will run indefinitely
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['RecurrenceScheduleArgs']]:
        """
        The recurrence schedule.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['RecurrenceScheduleArgs']]):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies start time of schedule in ISO 8601 format, but without a UTC offset.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies time zone in which the schedule runs.
        TimeZone should follow Windows time zone format. Refer: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class SecretConfigurationArgsDict(TypedDict):
        """
        Secret Configuration definition.
        """
        uri: NotRequired[pulumi.Input[str]]
        """
        Secret Uri.
        Sample Uri : https://myvault.vault.azure.net/secrets/mysecretname/secretversion
        """
        workspace_secret_name: NotRequired[pulumi.Input[str]]
        """
        Name of secret in workspace key vault.
        """
elif False:
    SecretConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretConfigurationArgs:
    def __init__(__self__, *,
                 uri: Optional[pulumi.Input[str]] = None,
                 workspace_secret_name: Optional[pulumi.Input[str]] = None):
        """
        Secret Configuration definition.
        :param pulumi.Input[str] uri: Secret Uri.
               Sample Uri : https://myvault.vault.azure.net/secrets/mysecretname/secretversion
        :param pulumi.Input[str] workspace_secret_name: Name of secret in workspace key vault.
        """
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if workspace_secret_name is not None:
            pulumi.set(__self__, "workspace_secret_name", workspace_secret_name)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        """
        Secret Uri.
        Sample Uri : https://myvault.vault.azure.net/secrets/mysecretname/secretversion
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="workspaceSecretName")
    def workspace_secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of secret in workspace key vault.
        """
        return pulumi.get(self, "workspace_secret_name")

    @workspace_secret_name.setter
    def workspace_secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workspace_secret_name", value)


if not MYPY:
    class ServiceManagedResourcesSettingsArgsDict(TypedDict):
        cosmos_db: NotRequired[pulumi.Input['CosmosDbSettingsArgsDict']]
        """
        The settings for the service managed cosmosdb account.
        """
elif False:
    ServiceManagedResourcesSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceManagedResourcesSettingsArgs:
    def __init__(__self__, *,
                 cosmos_db: Optional[pulumi.Input['CosmosDbSettingsArgs']] = None):
        """
        :param pulumi.Input['CosmosDbSettingsArgs'] cosmos_db: The settings for the service managed cosmosdb account.
        """
        if cosmos_db is not None:
            pulumi.set(__self__, "cosmos_db", cosmos_db)

    @property
    @pulumi.getter(name="cosmosDb")
    def cosmos_db(self) -> Optional[pulumi.Input['CosmosDbSettingsArgs']]:
        """
        The settings for the service managed cosmosdb account.
        """
        return pulumi.get(self, "cosmos_db")

    @cosmos_db.setter
    def cosmos_db(self, value: Optional[pulumi.Input['CosmosDbSettingsArgs']]):
        pulumi.set(self, "cosmos_db", value)


if not MYPY:
    class ServiceTagDestinationArgsDict(TypedDict):
        """
        Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
        """
        port_ranges: NotRequired[pulumi.Input[str]]
        protocol: NotRequired[pulumi.Input[str]]
        service_tag: NotRequired[pulumi.Input[str]]
elif False:
    ServiceTagDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTagDestinationArgs:
    def __init__(__self__, *,
                 port_ranges: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 service_tag: Optional[pulumi.Input[str]] = None):
        """
        Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
        """
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if service_tag is not None:
            pulumi.set(__self__, "service_tag", service_tag)

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "port_ranges")

    @port_ranges.setter
    def port_ranges(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_ranges", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="serviceTag")
    def service_tag(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_tag")

    @service_tag.setter
    def service_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tag", value)


if not MYPY:
    class ServiceTagOutboundRuleArgsDict(TypedDict):
        """
        Service Tag Outbound Rule for the managed network of a machine learning workspace.
        """
        type: pulumi.Input[str]
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        Expected value is 'ServiceTag'.
        """
        category: NotRequired[pulumi.Input[Union[str, 'RuleCategory']]]
        """
        Category of a managed network Outbound Rule of a machine learning workspace.
        """
        destination: NotRequired[pulumi.Input['ServiceTagDestinationArgsDict']]
        """
        Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
        """
        status: NotRequired[pulumi.Input[Union[str, 'RuleStatus']]]
        """
        Status of a managed network Outbound Rule of a machine learning workspace.
        """
elif False:
    ServiceTagOutboundRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTagOutboundRuleArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 category: Optional[pulumi.Input[Union[str, 'RuleCategory']]] = None,
                 destination: Optional[pulumi.Input['ServiceTagDestinationArgs']] = None,
                 status: Optional[pulumi.Input[Union[str, 'RuleStatus']]] = None):
        """
        Service Tag Outbound Rule for the managed network of a machine learning workspace.
        :param pulumi.Input[str] type: Type of a managed network Outbound Rule of a machine learning workspace.
               Expected value is 'ServiceTag'.
        :param pulumi.Input[Union[str, 'RuleCategory']] category: Category of a managed network Outbound Rule of a machine learning workspace.
        :param pulumi.Input['ServiceTagDestinationArgs'] destination: Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
        :param pulumi.Input[Union[str, 'RuleStatus']] status: Status of a managed network Outbound Rule of a machine learning workspace.
        """
        pulumi.set(__self__, "type", 'ServiceTag')
        if category is not None:
            pulumi.set(__self__, "category", category)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of a managed network Outbound Rule of a machine learning workspace.
        Expected value is 'ServiceTag'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[Union[str, 'RuleCategory']]]:
        """
        Category of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[Union[str, 'RuleCategory']]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input['ServiceTagDestinationArgs']]:
        """
        Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input['ServiceTagDestinationArgs']]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[str, 'RuleStatus']]]:
        """
        Status of a managed network Outbound Rule of a machine learning workspace.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[str, 'RuleStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class SharedPrivateLinkResourceArgsDict(TypedDict):
        group_id: NotRequired[pulumi.Input[str]]
        """
        The private link resource group id.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Unique name of the private link.
        """
        private_link_resource_id: NotRequired[pulumi.Input[str]]
        """
        The resource id that private link links to.
        """
        request_message: NotRequired[pulumi.Input[str]]
        """
        Request message.
        """
        status: NotRequired[pulumi.Input[Union[str, 'PrivateEndpointServiceConnectionStatus']]]
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
elif False:
    SharedPrivateLinkResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SharedPrivateLinkResourceArgs:
    def __init__(__self__, *,
                 group_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 private_link_resource_id: Optional[pulumi.Input[str]] = None,
                 request_message: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[Union[str, 'PrivateEndpointServiceConnectionStatus']]] = None):
        """
        :param pulumi.Input[str] group_id: The private link resource group id.
        :param pulumi.Input[str] name: Unique name of the private link.
        :param pulumi.Input[str] private_link_resource_id: The resource id that private link links to.
        :param pulumi.Input[str] request_message: Request message.
        :param pulumi.Input[Union[str, 'PrivateEndpointServiceConnectionStatus']] status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_link_resource_id is not None:
            pulumi.set(__self__, "private_link_resource_id", private_link_resource_id)
        if request_message is not None:
            pulumi.set(__self__, "request_message", request_message)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The private link resource group id.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the private link.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="privateLinkResourceId")
    def private_link_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource id that private link links to.
        """
        return pulumi.get(self, "private_link_resource_id")

    @private_link_resource_id.setter
    def private_link_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_link_resource_id", value)

    @property
    @pulumi.getter(name="requestMessage")
    def request_message(self) -> Optional[pulumi.Input[str]]:
        """
        Request message.
        """
        return pulumi.get(self, "request_message")

    @request_message.setter
    def request_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "request_message", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[str, 'PrivateEndpointServiceConnectionStatus']]]:
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[str, 'PrivateEndpointServiceConnectionStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class SkuArgsDict(TypedDict):
        """
        The resource model definition representing SKU
        """
        name: pulumi.Input[str]
        """
        The name of the SKU. Ex - P3. It is typically a letter+number code
        """
        capacity: NotRequired[pulumi.Input[int]]
        """
        If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        """
        family: NotRequired[pulumi.Input[str]]
        """
        If the service has different generations of hardware, for the same SKU, then that can be captured here.
        """
        size: NotRequired[pulumi.Input[str]]
        """
        The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        """
        tier: NotRequired[pulumi.Input['SkuTier']]
        """
        This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
elif False:
    SkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SkuArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 capacity: Optional[pulumi.Input[int]] = None,
                 family: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[str]] = None,
                 tier: Optional[pulumi.Input['SkuTier']] = None):
        """
        The resource model definition representing SKU
        :param pulumi.Input[str] name: The name of the SKU. Ex - P3. It is typically a letter+number code
        :param pulumi.Input[int] capacity: If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        :param pulumi.Input[str] family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
        :param pulumi.Input[str] size: The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        :param pulumi.Input['SkuTier'] tier: This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the SKU. Ex - P3. It is typically a letter+number code
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[int]]:
        """
        If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input[str]]:
        """
        If the service has different generations of hardware, for the same SKU, then that can be captured here.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input['SkuTier']]:
        """
        This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input['SkuTier']]):
        pulumi.set(self, "tier", value)


if not MYPY:
    class UserIdentityArgsDict(TypedDict):
        """
        User identity configuration.
        """
        identity_type: pulumi.Input[str]
        """
        Enum to determine identity framework.
        Expected value is 'UserIdentity'.
        """
elif False:
    UserIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserIdentityArgs:
    def __init__(__self__, *,
                 identity_type: pulumi.Input[str]):
        """
        User identity configuration.
        :param pulumi.Input[str] identity_type: Enum to determine identity framework.
               Expected value is 'UserIdentity'.
        """
        pulumi.set(__self__, "identity_type", 'UserIdentity')

    @property
    @pulumi.getter(name="identityType")
    def identity_type(self) -> pulumi.Input[str]:
        """
        Enum to determine identity framework.
        Expected value is 'UserIdentity'.
        """
        return pulumi.get(self, "identity_type")

    @identity_type.setter
    def identity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_type", value)


