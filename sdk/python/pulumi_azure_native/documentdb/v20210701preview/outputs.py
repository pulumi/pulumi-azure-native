# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'CertificateResponse',
    'ClusterResourceResponseProperties',
    'ManagedServiceIdentityResponse',
    'ManagedServiceIdentityResponseUserAssignedIdentities',
    'SeedNodeResponse',
]

@pulumi.output_type
class CertificateResponse(dict):
    def __init__(__self__, *,
                 pem: Optional[str] = None):
        """
        :param str pem: PEM formatted public key.
        """
        if pem is not None:
            pulumi.set(__self__, "pem", pem)

    @property
    @pulumi.getter
    def pem(self) -> Optional[str]:
        """
        PEM formatted public key.
        """
        return pulumi.get(self, "pem")


@pulumi.output_type
class ClusterResourceResponseProperties(dict):
    """
    Properties of a managed Cassandra cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gossipCertificates":
            suggest = "gossip_certificates"
        elif key == "seedNodes":
            suggest = "seed_nodes"
        elif key == "authenticationMethod":
            suggest = "authentication_method"
        elif key == "cassandraVersion":
            suggest = "cassandra_version"
        elif key == "clientCertificates":
            suggest = "client_certificates"
        elif key == "clusterNameOverride":
            suggest = "cluster_name_override"
        elif key == "delegatedManagementSubnetId":
            suggest = "delegated_management_subnet_id"
        elif key == "externalGossipCertificates":
            suggest = "external_gossip_certificates"
        elif key == "externalSeedNodes":
            suggest = "external_seed_nodes"
        elif key == "hoursBetweenBackups":
            suggest = "hours_between_backups"
        elif key == "prometheusEndpoint":
            suggest = "prometheus_endpoint"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "repairEnabled":
            suggest = "repair_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterResourceResponseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterResourceResponseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterResourceResponseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gossip_certificates: Sequence['outputs.CertificateResponse'],
                 seed_nodes: Sequence['outputs.SeedNodeResponse'],
                 authentication_method: Optional[str] = None,
                 cassandra_version: Optional[str] = None,
                 client_certificates: Optional[Sequence['outputs.CertificateResponse']] = None,
                 cluster_name_override: Optional[str] = None,
                 delegated_management_subnet_id: Optional[str] = None,
                 external_gossip_certificates: Optional[Sequence['outputs.CertificateResponse']] = None,
                 external_seed_nodes: Optional[Sequence['outputs.SeedNodeResponse']] = None,
                 hours_between_backups: Optional[int] = None,
                 prometheus_endpoint: Optional['outputs.SeedNodeResponse'] = None,
                 provisioning_state: Optional[str] = None,
                 repair_enabled: Optional[bool] = None):
        """
        Properties of a managed Cassandra cluster.
        :param Sequence['CertificateResponse'] gossip_certificates: List of TLS certificates that unmanaged nodes must trust for gossip with managed nodes. All managed nodes will present TLS client certificates that are verifiable using one of the certificates provided in this property.
        :param Sequence['SeedNodeResponse'] seed_nodes: List of IP addresses of seed nodes in the managed data centers. These should be added to the seed node lists of all unmanaged nodes.
        :param str authentication_method: Which authentication method Cassandra should use to authenticate clients. 'None' turns off authentication, so should not be used except in emergencies. 'Cassandra' is the default password based authentication. The default is 'Cassandra'.
        :param str cassandra_version: Which version of Cassandra should this cluster converge to running (e.g., 3.11). When updated, the cluster may take some time to migrate to the new version.
        :param Sequence['CertificateResponse'] client_certificates: List of TLS certificates used to authorize clients connecting to the cluster. All connections are TLS encrypted whether clientCertificates is set or not, but if clientCertificates is set, the managed Cassandra cluster will reject all connections not bearing a TLS client certificate that can be validated from one or more of the public certificates in this property.
        :param str cluster_name_override: If you need to set the clusterName property in cassandra.yaml to something besides the resource name of the cluster, set the value to use on this property.
        :param str delegated_management_subnet_id: Resource id of a subnet that this cluster's management service should have its network interface attached to. The subnet must be routable to all subnets that will be delegated to data centers. The resource id must be of the form '/subscriptions/<subscription id>/resourceGroups/<resource group>/providers/Microsoft.Network/virtualNetworks/<virtual network>/subnets/<subnet>'
        :param Sequence['CertificateResponse'] external_gossip_certificates: List of TLS certificates used to authorize gossip from unmanaged data centers. The TLS certificates of all nodes in unmanaged data centers must be verifiable using one of the certificates provided in this property.
        :param Sequence['SeedNodeResponse'] external_seed_nodes: List of IP addresses of seed nodes in unmanaged data centers. These will be added to the seed node lists of all managed nodes.
        :param int hours_between_backups: Number of hours to wait between taking a backup of the cluster. To disable backups, set this property to 0.
        :param 'SeedNodeResponse' prometheus_endpoint: Hostname or IP address where the Prometheus endpoint containing data about the managed Cassandra nodes can be reached.
        :param str provisioning_state: The status of the resource at the time the operation was called.
        :param bool repair_enabled: Should automatic repairs run on this cluster? If omitted, this is true, and should stay true unless you are running a hybrid cluster where you are already doing your own repairs.
        """
        pulumi.set(__self__, "gossip_certificates", gossip_certificates)
        pulumi.set(__self__, "seed_nodes", seed_nodes)
        if authentication_method is not None:
            pulumi.set(__self__, "authentication_method", authentication_method)
        if cassandra_version is not None:
            pulumi.set(__self__, "cassandra_version", cassandra_version)
        if client_certificates is not None:
            pulumi.set(__self__, "client_certificates", client_certificates)
        if cluster_name_override is not None:
            pulumi.set(__self__, "cluster_name_override", cluster_name_override)
        if delegated_management_subnet_id is not None:
            pulumi.set(__self__, "delegated_management_subnet_id", delegated_management_subnet_id)
        if external_gossip_certificates is not None:
            pulumi.set(__self__, "external_gossip_certificates", external_gossip_certificates)
        if external_seed_nodes is not None:
            pulumi.set(__self__, "external_seed_nodes", external_seed_nodes)
        if hours_between_backups is not None:
            pulumi.set(__self__, "hours_between_backups", hours_between_backups)
        if prometheus_endpoint is not None:
            pulumi.set(__self__, "prometheus_endpoint", prometheus_endpoint)
        if provisioning_state is not None:
            pulumi.set(__self__, "provisioning_state", provisioning_state)
        if repair_enabled is not None:
            pulumi.set(__self__, "repair_enabled", repair_enabled)

    @property
    @pulumi.getter(name="gossipCertificates")
    def gossip_certificates(self) -> Sequence['outputs.CertificateResponse']:
        """
        List of TLS certificates that unmanaged nodes must trust for gossip with managed nodes. All managed nodes will present TLS client certificates that are verifiable using one of the certificates provided in this property.
        """
        return pulumi.get(self, "gossip_certificates")

    @property
    @pulumi.getter(name="seedNodes")
    def seed_nodes(self) -> Sequence['outputs.SeedNodeResponse']:
        """
        List of IP addresses of seed nodes in the managed data centers. These should be added to the seed node lists of all unmanaged nodes.
        """
        return pulumi.get(self, "seed_nodes")

    @property
    @pulumi.getter(name="authenticationMethod")
    def authentication_method(self) -> Optional[str]:
        """
        Which authentication method Cassandra should use to authenticate clients. 'None' turns off authentication, so should not be used except in emergencies. 'Cassandra' is the default password based authentication. The default is 'Cassandra'.
        """
        return pulumi.get(self, "authentication_method")

    @property
    @pulumi.getter(name="cassandraVersion")
    def cassandra_version(self) -> Optional[str]:
        """
        Which version of Cassandra should this cluster converge to running (e.g., 3.11). When updated, the cluster may take some time to migrate to the new version.
        """
        return pulumi.get(self, "cassandra_version")

    @property
    @pulumi.getter(name="clientCertificates")
    def client_certificates(self) -> Optional[Sequence['outputs.CertificateResponse']]:
        """
        List of TLS certificates used to authorize clients connecting to the cluster. All connections are TLS encrypted whether clientCertificates is set or not, but if clientCertificates is set, the managed Cassandra cluster will reject all connections not bearing a TLS client certificate that can be validated from one or more of the public certificates in this property.
        """
        return pulumi.get(self, "client_certificates")

    @property
    @pulumi.getter(name="clusterNameOverride")
    def cluster_name_override(self) -> Optional[str]:
        """
        If you need to set the clusterName property in cassandra.yaml to something besides the resource name of the cluster, set the value to use on this property.
        """
        return pulumi.get(self, "cluster_name_override")

    @property
    @pulumi.getter(name="delegatedManagementSubnetId")
    def delegated_management_subnet_id(self) -> Optional[str]:
        """
        Resource id of a subnet that this cluster's management service should have its network interface attached to. The subnet must be routable to all subnets that will be delegated to data centers. The resource id must be of the form '/subscriptions/<subscription id>/resourceGroups/<resource group>/providers/Microsoft.Network/virtualNetworks/<virtual network>/subnets/<subnet>'
        """
        return pulumi.get(self, "delegated_management_subnet_id")

    @property
    @pulumi.getter(name="externalGossipCertificates")
    def external_gossip_certificates(self) -> Optional[Sequence['outputs.CertificateResponse']]:
        """
        List of TLS certificates used to authorize gossip from unmanaged data centers. The TLS certificates of all nodes in unmanaged data centers must be verifiable using one of the certificates provided in this property.
        """
        return pulumi.get(self, "external_gossip_certificates")

    @property
    @pulumi.getter(name="externalSeedNodes")
    def external_seed_nodes(self) -> Optional[Sequence['outputs.SeedNodeResponse']]:
        """
        List of IP addresses of seed nodes in unmanaged data centers. These will be added to the seed node lists of all managed nodes.
        """
        return pulumi.get(self, "external_seed_nodes")

    @property
    @pulumi.getter(name="hoursBetweenBackups")
    def hours_between_backups(self) -> Optional[int]:
        """
        Number of hours to wait between taking a backup of the cluster. To disable backups, set this property to 0.
        """
        return pulumi.get(self, "hours_between_backups")

    @property
    @pulumi.getter(name="prometheusEndpoint")
    def prometheus_endpoint(self) -> Optional['outputs.SeedNodeResponse']:
        """
        Hostname or IP address where the Prometheus endpoint containing data about the managed Cassandra nodes can be reached.
        """
        return pulumi.get(self, "prometheus_endpoint")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        The status of the resource at the time the operation was called.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="repairEnabled")
    def repair_enabled(self) -> Optional[bool]:
        """
        Should automatic repairs run on this cluster? If omitted, this is true, and should stay true unless you are running a hybrid cluster where you are already doing your own repairs.
        """
        return pulumi.get(self, "repair_enabled")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Identity for the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: Optional[str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.ManagedServiceIdentityResponseUserAssignedIdentities']] = None):
        """
        Identity for the resource.
        :param str principal_id: The principal id of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str tenant_id: The tenant id of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str type: The type of identity used for the resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the service.
        :param Mapping[str, 'ManagedServiceIdentityResponseUserAssignedIdentities'] user_assigned_identities: The list of user identities associated with resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal id of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant id of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of identity used for the resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.ManagedServiceIdentityResponseUserAssignedIdentities']]:
        """
        The list of user identities associated with resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class ManagedServiceIdentityResponseUserAssignedIdentities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponseUserAssignedIdentities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponseUserAssignedIdentities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponseUserAssignedIdentities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str):
        """
        :param str client_id: The client id of user assigned identity.
        :param str principal_id: The principal id of user assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client id of user assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal id of user assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class SeedNodeResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SeedNodeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SeedNodeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SeedNodeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: Optional[str] = None):
        """
        :param str ip_address: IP address of this seed node.
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        IP address of this seed node.
        """
        return pulumi.get(self, "ip_address")


