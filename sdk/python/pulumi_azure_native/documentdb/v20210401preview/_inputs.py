# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from ._enums import *

__all__ = [
    'ApiPropertiesArgs',
    'CapabilityArgs',
    'ConsistencyPolicyArgs',
    'ContinuousModeBackupPolicyArgs',
    'CorsPolicyArgs',
    'DatabaseRestoreResourceArgs',
    'DefaultRequestDatabaseAccountCreateUpdatePropertiesArgs',
    'IpAddressOrRangeArgs',
    'LocationArgs',
    'ManagedServiceIdentityArgs',
    'PeriodicModeBackupPolicyArgs',
    'PeriodicModePropertiesArgs',
    'RestoreParametersArgs',
    'RestoreReqeustDatabaseAccountCreateUpdatePropertiesArgs',
    'VirtualNetworkRuleArgs',
]

@pulumi.input_type
class ApiPropertiesArgs:
    def __init__(__self__, *,
                 server_version: Optional[pulumi.Input[Union[str, 'ServerVersion']]] = None):
        """
        :param pulumi.Input[Union[str, 'ServerVersion']] server_version: Describes the ServerVersion of an a MongoDB account.
        """
        ApiPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            server_version=server_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             server_version: Optional[pulumi.Input[Union[str, 'ServerVersion']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if server_version is None and 'serverVersion' in kwargs:
            server_version = kwargs['serverVersion']

        if server_version is not None:
            _setter("server_version", server_version)

    @property
    @pulumi.getter(name="serverVersion")
    def server_version(self) -> Optional[pulumi.Input[Union[str, 'ServerVersion']]]:
        """
        Describes the ServerVersion of an a MongoDB account.
        """
        return pulumi.get(self, "server_version")

    @server_version.setter
    def server_version(self, value: Optional[pulumi.Input[Union[str, 'ServerVersion']]]):
        pulumi.set(self, "server_version", value)


@pulumi.input_type
class CapabilityArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Cosmos DB capability object
        :param pulumi.Input[str] name: Name of the Cosmos DB capability. For example, "name": "EnableCassandra". Current values also include "EnableTable" and "EnableGremlin".
        """
        CapabilityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Cosmos DB capability. For example, "name": "EnableCassandra". Current values also include "EnableTable" and "EnableGremlin".
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ConsistencyPolicyArgs:
    def __init__(__self__, *,
                 default_consistency_level: pulumi.Input['DefaultConsistencyLevel'],
                 max_interval_in_seconds: Optional[pulumi.Input[int]] = None,
                 max_staleness_prefix: Optional[pulumi.Input[float]] = None):
        """
        The consistency policy for the Cosmos DB database account.
        :param pulumi.Input['DefaultConsistencyLevel'] default_consistency_level: The default consistency level and configuration settings of the Cosmos DB account.
        :param pulumi.Input[int] max_interval_in_seconds: When used with the Bounded Staleness consistency level, this value represents the time amount of staleness (in seconds) tolerated. Accepted range for this value is 5 - 86400. Required when defaultConsistencyPolicy is set to 'BoundedStaleness'.
        :param pulumi.Input[float] max_staleness_prefix: When used with the Bounded Staleness consistency level, this value represents the number of stale requests tolerated. Accepted range for this value is 1 – 2,147,483,647. Required when defaultConsistencyPolicy is set to 'BoundedStaleness'.
        """
        ConsistencyPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_consistency_level=default_consistency_level,
            max_interval_in_seconds=max_interval_in_seconds,
            max_staleness_prefix=max_staleness_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_consistency_level: Optional[pulumi.Input['DefaultConsistencyLevel']] = None,
             max_interval_in_seconds: Optional[pulumi.Input[int]] = None,
             max_staleness_prefix: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_consistency_level is None and 'defaultConsistencyLevel' in kwargs:
            default_consistency_level = kwargs['defaultConsistencyLevel']
        if default_consistency_level is None:
            raise TypeError("Missing 'default_consistency_level' argument")
        if max_interval_in_seconds is None and 'maxIntervalInSeconds' in kwargs:
            max_interval_in_seconds = kwargs['maxIntervalInSeconds']
        if max_staleness_prefix is None and 'maxStalenessPrefix' in kwargs:
            max_staleness_prefix = kwargs['maxStalenessPrefix']

        _setter("default_consistency_level", default_consistency_level)
        if max_interval_in_seconds is not None:
            _setter("max_interval_in_seconds", max_interval_in_seconds)
        if max_staleness_prefix is not None:
            _setter("max_staleness_prefix", max_staleness_prefix)

    @property
    @pulumi.getter(name="defaultConsistencyLevel")
    def default_consistency_level(self) -> pulumi.Input['DefaultConsistencyLevel']:
        """
        The default consistency level and configuration settings of the Cosmos DB account.
        """
        return pulumi.get(self, "default_consistency_level")

    @default_consistency_level.setter
    def default_consistency_level(self, value: pulumi.Input['DefaultConsistencyLevel']):
        pulumi.set(self, "default_consistency_level", value)

    @property
    @pulumi.getter(name="maxIntervalInSeconds")
    def max_interval_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        When used with the Bounded Staleness consistency level, this value represents the time amount of staleness (in seconds) tolerated. Accepted range for this value is 5 - 86400. Required when defaultConsistencyPolicy is set to 'BoundedStaleness'.
        """
        return pulumi.get(self, "max_interval_in_seconds")

    @max_interval_in_seconds.setter
    def max_interval_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_interval_in_seconds", value)

    @property
    @pulumi.getter(name="maxStalenessPrefix")
    def max_staleness_prefix(self) -> Optional[pulumi.Input[float]]:
        """
        When used with the Bounded Staleness consistency level, this value represents the number of stale requests tolerated. Accepted range for this value is 1 – 2,147,483,647. Required when defaultConsistencyPolicy is set to 'BoundedStaleness'.
        """
        return pulumi.get(self, "max_staleness_prefix")

    @max_staleness_prefix.setter
    def max_staleness_prefix(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_staleness_prefix", value)


@pulumi.input_type
class ContinuousModeBackupPolicyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        The object representing continuous mode backup policy.
        :param pulumi.Input[str] type: Describes the mode of backups.
               Expected value is 'Continuous'.
        """
        ContinuousModeBackupPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("type", 'Continuous')

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Describes the mode of backups.
        Expected value is 'Continuous'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class CorsPolicyArgs:
    def __init__(__self__, *,
                 allowed_origins: pulumi.Input[str],
                 allowed_headers: Optional[pulumi.Input[str]] = None,
                 allowed_methods: Optional[pulumi.Input[str]] = None,
                 exposed_headers: Optional[pulumi.Input[str]] = None,
                 max_age_in_seconds: Optional[pulumi.Input[float]] = None):
        """
        The CORS policy for the Cosmos DB database account.
        :param pulumi.Input[str] allowed_origins: The origin domains that are permitted to make a request against the service via CORS.
        :param pulumi.Input[str] allowed_headers: The request headers that the origin domain may specify on the CORS request.
        :param pulumi.Input[str] allowed_methods: The methods (HTTP request verbs) that the origin domain may use for a CORS request.
        :param pulumi.Input[str] exposed_headers: The response headers that may be sent in the response to the CORS request and exposed by the browser to the request issuer.
        :param pulumi.Input[float] max_age_in_seconds: The maximum amount time that a browser should cache the preflight OPTIONS request.
        """
        CorsPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_origins=allowed_origins,
            allowed_headers=allowed_headers,
            allowed_methods=allowed_methods,
            exposed_headers=exposed_headers,
            max_age_in_seconds=max_age_in_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_origins: Optional[pulumi.Input[str]] = None,
             allowed_headers: Optional[pulumi.Input[str]] = None,
             allowed_methods: Optional[pulumi.Input[str]] = None,
             exposed_headers: Optional[pulumi.Input[str]] = None,
             max_age_in_seconds: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allowed_origins is None and 'allowedOrigins' in kwargs:
            allowed_origins = kwargs['allowedOrigins']
        if allowed_origins is None:
            raise TypeError("Missing 'allowed_origins' argument")
        if allowed_headers is None and 'allowedHeaders' in kwargs:
            allowed_headers = kwargs['allowedHeaders']
        if allowed_methods is None and 'allowedMethods' in kwargs:
            allowed_methods = kwargs['allowedMethods']
        if exposed_headers is None and 'exposedHeaders' in kwargs:
            exposed_headers = kwargs['exposedHeaders']
        if max_age_in_seconds is None and 'maxAgeInSeconds' in kwargs:
            max_age_in_seconds = kwargs['maxAgeInSeconds']

        _setter("allowed_origins", allowed_origins)
        if allowed_headers is not None:
            _setter("allowed_headers", allowed_headers)
        if allowed_methods is not None:
            _setter("allowed_methods", allowed_methods)
        if exposed_headers is not None:
            _setter("exposed_headers", exposed_headers)
        if max_age_in_seconds is not None:
            _setter("max_age_in_seconds", max_age_in_seconds)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[str]:
        """
        The origin domains that are permitted to make a request against the service via CORS.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[str]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[str]]:
        """
        The request headers that the origin domain may specify on the CORS request.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allowed_headers", value)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[pulumi.Input[str]]:
        """
        The methods (HTTP request verbs) that the origin domain may use for a CORS request.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allowed_methods", value)

    @property
    @pulumi.getter(name="exposedHeaders")
    def exposed_headers(self) -> Optional[pulumi.Input[str]]:
        """
        The response headers that may be sent in the response to the CORS request and exposed by the browser to the request issuer.
        """
        return pulumi.get(self, "exposed_headers")

    @exposed_headers.setter
    def exposed_headers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exposed_headers", value)

    @property
    @pulumi.getter(name="maxAgeInSeconds")
    def max_age_in_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        The maximum amount time that a browser should cache the preflight OPTIONS request.
        """
        return pulumi.get(self, "max_age_in_seconds")

    @max_age_in_seconds.setter
    def max_age_in_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_age_in_seconds", value)


@pulumi.input_type
class DatabaseRestoreResourceArgs:
    def __init__(__self__, *,
                 collection_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 database_name: Optional[pulumi.Input[str]] = None):
        """
        Specific Databases to restore.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] collection_names: The names of the collections available for restore.
        :param pulumi.Input[str] database_name: The name of the database available for restore.
        """
        DatabaseRestoreResourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            collection_names=collection_names,
            database_name=database_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             collection_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             database_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if collection_names is None and 'collectionNames' in kwargs:
            collection_names = kwargs['collectionNames']
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']

        if collection_names is not None:
            _setter("collection_names", collection_names)
        if database_name is not None:
            _setter("database_name", database_name)

    @property
    @pulumi.getter(name="collectionNames")
    def collection_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The names of the collections available for restore.
        """
        return pulumi.get(self, "collection_names")

    @collection_names.setter
    def collection_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "collection_names", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the database available for restore.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_name", value)


@pulumi.input_type
class DefaultRequestDatabaseAccountCreateUpdatePropertiesArgs:
    def __init__(__self__, *,
                 create_mode: Optional[pulumi.Input[str]] = None,
                 database_account_offer_type: pulumi.Input['DatabaseAccountOfferType'],
                 locations: pulumi.Input[Sequence[pulumi.Input['LocationArgs']]],
                 api_properties: Optional[pulumi.Input['ApiPropertiesArgs']] = None,
                 backup_policy: Optional[pulumi.Input[Union['ContinuousModeBackupPolicyArgs', 'PeriodicModeBackupPolicyArgs']]] = None,
                 capabilities: Optional[pulumi.Input[Sequence[pulumi.Input['CapabilityArgs']]]] = None,
                 connector_offer: Optional[pulumi.Input[Union[str, 'ConnectorOffer']]] = None,
                 consistency_policy: Optional[pulumi.Input['ConsistencyPolicyArgs']] = None,
                 cors: Optional[pulumi.Input[Sequence[pulumi.Input['CorsPolicyArgs']]]] = None,
                 default_identity: Optional[pulumi.Input[str]] = None,
                 disable_key_based_metadata_write_access: Optional[pulumi.Input[bool]] = None,
                 enable_analytical_storage: Optional[pulumi.Input[bool]] = None,
                 enable_automatic_failover: Optional[pulumi.Input[bool]] = None,
                 enable_cassandra_connector: Optional[pulumi.Input[bool]] = None,
                 enable_free_tier: Optional[pulumi.Input[bool]] = None,
                 enable_multiple_write_locations: Optional[pulumi.Input[bool]] = None,
                 ip_rules: Optional[pulumi.Input[Sequence[pulumi.Input['IpAddressOrRangeArgs']]]] = None,
                 is_virtual_network_filter_enabled: Optional[pulumi.Input[bool]] = None,
                 key_vault_key_uri: Optional[pulumi.Input[str]] = None,
                 network_acl_bypass: Optional[pulumi.Input['NetworkAclBypass']] = None,
                 network_acl_bypass_resource_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 public_network_access: Optional[pulumi.Input[Union[str, 'PublicNetworkAccess']]] = None,
                 virtual_network_rules: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkRuleArgs']]]] = None):
        """
        Properties for non-restore Azure Cosmos DB database account requests.
        :param pulumi.Input[str] create_mode: Enum to indicate the mode of account creation.
               Expected value is 'Default'.
        :param pulumi.Input['DatabaseAccountOfferType'] database_account_offer_type: The offer type for the database
        :param pulumi.Input[Sequence[pulumi.Input['LocationArgs']]] locations: An array that contains the georeplication locations enabled for the Cosmos DB account.
        :param pulumi.Input['ApiPropertiesArgs'] api_properties: API specific properties. Currently, supported only for MongoDB API.
        :param pulumi.Input[Union['ContinuousModeBackupPolicyArgs', 'PeriodicModeBackupPolicyArgs']] backup_policy: The object representing the policy for taking backups on an account.
        :param pulumi.Input[Sequence[pulumi.Input['CapabilityArgs']]] capabilities: List of Cosmos DB capabilities for the account
        :param pulumi.Input[Union[str, 'ConnectorOffer']] connector_offer: The cassandra connector offer type for the Cosmos DB database C* account.
        :param pulumi.Input['ConsistencyPolicyArgs'] consistency_policy: The consistency policy for the Cosmos DB account.
        :param pulumi.Input[Sequence[pulumi.Input['CorsPolicyArgs']]] cors: The CORS policy for the Cosmos DB database account.
        :param pulumi.Input[str] default_identity: The default identity for accessing key vault used in features like customer managed keys. The default identity needs to be explicitly set by the users. It can be "FirstPartyIdentity", "SystemAssignedIdentity" and more.
        :param pulumi.Input[bool] disable_key_based_metadata_write_access: Disable write operations on metadata resources (databases, containers, throughput) via account keys
        :param pulumi.Input[bool] enable_analytical_storage: Flag to indicate whether to enable storage analytics.
        :param pulumi.Input[bool] enable_automatic_failover: Enables automatic failover of the write region in the rare event that the region is unavailable due to an outage. Automatic failover will result in a new write region for the account and is chosen based on the failover priorities configured for the account.
        :param pulumi.Input[bool] enable_cassandra_connector: Enables the cassandra connector on the Cosmos DB C* account
        :param pulumi.Input[bool] enable_free_tier: Flag to indicate whether Free Tier is enabled.
        :param pulumi.Input[bool] enable_multiple_write_locations: Enables the account to write in multiple locations
        :param pulumi.Input[Sequence[pulumi.Input['IpAddressOrRangeArgs']]] ip_rules: List of IpRules.
        :param pulumi.Input[bool] is_virtual_network_filter_enabled: Flag to indicate whether to enable/disable Virtual Network ACL rules.
        :param pulumi.Input[str] key_vault_key_uri: The URI of the key vault
        :param pulumi.Input['NetworkAclBypass'] network_acl_bypass: Indicates what services are allowed to bypass firewall checks.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] network_acl_bypass_resource_ids: An array that contains the Resource Ids for Network Acl Bypass for the Cosmos DB account.
        :param pulumi.Input[Union[str, 'PublicNetworkAccess']] public_network_access: Whether requests from Public Network are allowed
        :param pulumi.Input[Sequence[pulumi.Input['VirtualNetworkRuleArgs']]] virtual_network_rules: List of Virtual Network ACL rules configured for the Cosmos DB account.
        """
        DefaultRequestDatabaseAccountCreateUpdatePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create_mode=create_mode,
            database_account_offer_type=database_account_offer_type,
            locations=locations,
            api_properties=api_properties,
            backup_policy=backup_policy,
            capabilities=capabilities,
            connector_offer=connector_offer,
            consistency_policy=consistency_policy,
            cors=cors,
            default_identity=default_identity,
            disable_key_based_metadata_write_access=disable_key_based_metadata_write_access,
            enable_analytical_storage=enable_analytical_storage,
            enable_automatic_failover=enable_automatic_failover,
            enable_cassandra_connector=enable_cassandra_connector,
            enable_free_tier=enable_free_tier,
            enable_multiple_write_locations=enable_multiple_write_locations,
            ip_rules=ip_rules,
            is_virtual_network_filter_enabled=is_virtual_network_filter_enabled,
            key_vault_key_uri=key_vault_key_uri,
            network_acl_bypass=network_acl_bypass,
            network_acl_bypass_resource_ids=network_acl_bypass_resource_ids,
            public_network_access=public_network_access,
            virtual_network_rules=virtual_network_rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create_mode: Optional[pulumi.Input[str]] = None,
             database_account_offer_type: Optional[pulumi.Input['DatabaseAccountOfferType']] = None,
             locations: Optional[pulumi.Input[Sequence[pulumi.Input['LocationArgs']]]] = None,
             api_properties: Optional[pulumi.Input['ApiPropertiesArgs']] = None,
             backup_policy: Optional[pulumi.Input[Union['ContinuousModeBackupPolicyArgs', 'PeriodicModeBackupPolicyArgs']]] = None,
             capabilities: Optional[pulumi.Input[Sequence[pulumi.Input['CapabilityArgs']]]] = None,
             connector_offer: Optional[pulumi.Input[Union[str, 'ConnectorOffer']]] = None,
             consistency_policy: Optional[pulumi.Input['ConsistencyPolicyArgs']] = None,
             cors: Optional[pulumi.Input[Sequence[pulumi.Input['CorsPolicyArgs']]]] = None,
             default_identity: Optional[pulumi.Input[str]] = None,
             disable_key_based_metadata_write_access: Optional[pulumi.Input[bool]] = None,
             enable_analytical_storage: Optional[pulumi.Input[bool]] = None,
             enable_automatic_failover: Optional[pulumi.Input[bool]] = None,
             enable_cassandra_connector: Optional[pulumi.Input[bool]] = None,
             enable_free_tier: Optional[pulumi.Input[bool]] = None,
             enable_multiple_write_locations: Optional[pulumi.Input[bool]] = None,
             ip_rules: Optional[pulumi.Input[Sequence[pulumi.Input['IpAddressOrRangeArgs']]]] = None,
             is_virtual_network_filter_enabled: Optional[pulumi.Input[bool]] = None,
             key_vault_key_uri: Optional[pulumi.Input[str]] = None,
             network_acl_bypass: Optional[pulumi.Input['NetworkAclBypass']] = None,
             network_acl_bypass_resource_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             public_network_access: Optional[pulumi.Input[Union[str, 'PublicNetworkAccess']]] = None,
             virtual_network_rules: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkRuleArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if create_mode is None and 'createMode' in kwargs:
            create_mode = kwargs['createMode']
        if database_account_offer_type is None and 'databaseAccountOfferType' in kwargs:
            database_account_offer_type = kwargs['databaseAccountOfferType']
        if database_account_offer_type is None:
            raise TypeError("Missing 'database_account_offer_type' argument")
        if locations is None:
            raise TypeError("Missing 'locations' argument")
        if api_properties is None and 'apiProperties' in kwargs:
            api_properties = kwargs['apiProperties']
        if backup_policy is None and 'backupPolicy' in kwargs:
            backup_policy = kwargs['backupPolicy']
        if connector_offer is None and 'connectorOffer' in kwargs:
            connector_offer = kwargs['connectorOffer']
        if consistency_policy is None and 'consistencyPolicy' in kwargs:
            consistency_policy = kwargs['consistencyPolicy']
        if default_identity is None and 'defaultIdentity' in kwargs:
            default_identity = kwargs['defaultIdentity']
        if disable_key_based_metadata_write_access is None and 'disableKeyBasedMetadataWriteAccess' in kwargs:
            disable_key_based_metadata_write_access = kwargs['disableKeyBasedMetadataWriteAccess']
        if enable_analytical_storage is None and 'enableAnalyticalStorage' in kwargs:
            enable_analytical_storage = kwargs['enableAnalyticalStorage']
        if enable_automatic_failover is None and 'enableAutomaticFailover' in kwargs:
            enable_automatic_failover = kwargs['enableAutomaticFailover']
        if enable_cassandra_connector is None and 'enableCassandraConnector' in kwargs:
            enable_cassandra_connector = kwargs['enableCassandraConnector']
        if enable_free_tier is None and 'enableFreeTier' in kwargs:
            enable_free_tier = kwargs['enableFreeTier']
        if enable_multiple_write_locations is None and 'enableMultipleWriteLocations' in kwargs:
            enable_multiple_write_locations = kwargs['enableMultipleWriteLocations']
        if ip_rules is None and 'ipRules' in kwargs:
            ip_rules = kwargs['ipRules']
        if is_virtual_network_filter_enabled is None and 'isVirtualNetworkFilterEnabled' in kwargs:
            is_virtual_network_filter_enabled = kwargs['isVirtualNetworkFilterEnabled']
        if key_vault_key_uri is None and 'keyVaultKeyUri' in kwargs:
            key_vault_key_uri = kwargs['keyVaultKeyUri']
        if network_acl_bypass is None and 'networkAclBypass' in kwargs:
            network_acl_bypass = kwargs['networkAclBypass']
        if network_acl_bypass_resource_ids is None and 'networkAclBypassResourceIds' in kwargs:
            network_acl_bypass_resource_ids = kwargs['networkAclBypassResourceIds']
        if public_network_access is None and 'publicNetworkAccess' in kwargs:
            public_network_access = kwargs['publicNetworkAccess']
        if virtual_network_rules is None and 'virtualNetworkRules' in kwargs:
            virtual_network_rules = kwargs['virtualNetworkRules']

        if create_mode is None:
            create_mode = 'Default'
        _setter("create_mode", 'Default')
        _setter("database_account_offer_type", database_account_offer_type)
        _setter("locations", locations)
        if api_properties is not None:
            _setter("api_properties", api_properties)
        if backup_policy is not None:
            _setter("backup_policy", backup_policy)
        if capabilities is not None:
            _setter("capabilities", capabilities)
        if connector_offer is not None:
            _setter("connector_offer", connector_offer)
        if consistency_policy is not None:
            _setter("consistency_policy", consistency_policy)
        if cors is not None:
            _setter("cors", cors)
        if default_identity is not None:
            _setter("default_identity", default_identity)
        if disable_key_based_metadata_write_access is not None:
            _setter("disable_key_based_metadata_write_access", disable_key_based_metadata_write_access)
        if enable_analytical_storage is not None:
            _setter("enable_analytical_storage", enable_analytical_storage)
        if enable_automatic_failover is not None:
            _setter("enable_automatic_failover", enable_automatic_failover)
        if enable_cassandra_connector is not None:
            _setter("enable_cassandra_connector", enable_cassandra_connector)
        if enable_free_tier is not None:
            _setter("enable_free_tier", enable_free_tier)
        if enable_multiple_write_locations is not None:
            _setter("enable_multiple_write_locations", enable_multiple_write_locations)
        if ip_rules is not None:
            _setter("ip_rules", ip_rules)
        if is_virtual_network_filter_enabled is not None:
            _setter("is_virtual_network_filter_enabled", is_virtual_network_filter_enabled)
        if key_vault_key_uri is not None:
            _setter("key_vault_key_uri", key_vault_key_uri)
        if network_acl_bypass is not None:
            _setter("network_acl_bypass", network_acl_bypass)
        if network_acl_bypass_resource_ids is not None:
            _setter("network_acl_bypass_resource_ids", network_acl_bypass_resource_ids)
        if public_network_access is not None:
            _setter("public_network_access", public_network_access)
        if virtual_network_rules is not None:
            _setter("virtual_network_rules", virtual_network_rules)

    @property
    @pulumi.getter(name="createMode")
    def create_mode(self) -> pulumi.Input[str]:
        """
        Enum to indicate the mode of account creation.
        Expected value is 'Default'.
        """
        return pulumi.get(self, "create_mode")

    @create_mode.setter
    def create_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "create_mode", value)

    @property
    @pulumi.getter(name="databaseAccountOfferType")
    def database_account_offer_type(self) -> pulumi.Input['DatabaseAccountOfferType']:
        """
        The offer type for the database
        """
        return pulumi.get(self, "database_account_offer_type")

    @database_account_offer_type.setter
    def database_account_offer_type(self, value: pulumi.Input['DatabaseAccountOfferType']):
        pulumi.set(self, "database_account_offer_type", value)

    @property
    @pulumi.getter
    def locations(self) -> pulumi.Input[Sequence[pulumi.Input['LocationArgs']]]:
        """
        An array that contains the georeplication locations enabled for the Cosmos DB account.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: pulumi.Input[Sequence[pulumi.Input['LocationArgs']]]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter(name="apiProperties")
    def api_properties(self) -> Optional[pulumi.Input['ApiPropertiesArgs']]:
        """
        API specific properties. Currently, supported only for MongoDB API.
        """
        return pulumi.get(self, "api_properties")

    @api_properties.setter
    def api_properties(self, value: Optional[pulumi.Input['ApiPropertiesArgs']]):
        pulumi.set(self, "api_properties", value)

    @property
    @pulumi.getter(name="backupPolicy")
    def backup_policy(self) -> Optional[pulumi.Input[Union['ContinuousModeBackupPolicyArgs', 'PeriodicModeBackupPolicyArgs']]]:
        """
        The object representing the policy for taking backups on an account.
        """
        return pulumi.get(self, "backup_policy")

    @backup_policy.setter
    def backup_policy(self, value: Optional[pulumi.Input[Union['ContinuousModeBackupPolicyArgs', 'PeriodicModeBackupPolicyArgs']]]):
        pulumi.set(self, "backup_policy", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CapabilityArgs']]]]:
        """
        List of Cosmos DB capabilities for the account
        """
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CapabilityArgs']]]]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter(name="connectorOffer")
    def connector_offer(self) -> Optional[pulumi.Input[Union[str, 'ConnectorOffer']]]:
        """
        The cassandra connector offer type for the Cosmos DB database C* account.
        """
        return pulumi.get(self, "connector_offer")

    @connector_offer.setter
    def connector_offer(self, value: Optional[pulumi.Input[Union[str, 'ConnectorOffer']]]):
        pulumi.set(self, "connector_offer", value)

    @property
    @pulumi.getter(name="consistencyPolicy")
    def consistency_policy(self) -> Optional[pulumi.Input['ConsistencyPolicyArgs']]:
        """
        The consistency policy for the Cosmos DB account.
        """
        return pulumi.get(self, "consistency_policy")

    @consistency_policy.setter
    def consistency_policy(self, value: Optional[pulumi.Input['ConsistencyPolicyArgs']]):
        pulumi.set(self, "consistency_policy", value)

    @property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CorsPolicyArgs']]]]:
        """
        The CORS policy for the Cosmos DB database account.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CorsPolicyArgs']]]]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="defaultIdentity")
    def default_identity(self) -> Optional[pulumi.Input[str]]:
        """
        The default identity for accessing key vault used in features like customer managed keys. The default identity needs to be explicitly set by the users. It can be "FirstPartyIdentity", "SystemAssignedIdentity" and more.
        """
        return pulumi.get(self, "default_identity")

    @default_identity.setter
    def default_identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_identity", value)

    @property
    @pulumi.getter(name="disableKeyBasedMetadataWriteAccess")
    def disable_key_based_metadata_write_access(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable write operations on metadata resources (databases, containers, throughput) via account keys
        """
        return pulumi.get(self, "disable_key_based_metadata_write_access")

    @disable_key_based_metadata_write_access.setter
    def disable_key_based_metadata_write_access(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_key_based_metadata_write_access", value)

    @property
    @pulumi.getter(name="enableAnalyticalStorage")
    def enable_analytical_storage(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag to indicate whether to enable storage analytics.
        """
        return pulumi.get(self, "enable_analytical_storage")

    @enable_analytical_storage.setter
    def enable_analytical_storage(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_analytical_storage", value)

    @property
    @pulumi.getter(name="enableAutomaticFailover")
    def enable_automatic_failover(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables automatic failover of the write region in the rare event that the region is unavailable due to an outage. Automatic failover will result in a new write region for the account and is chosen based on the failover priorities configured for the account.
        """
        return pulumi.get(self, "enable_automatic_failover")

    @enable_automatic_failover.setter
    def enable_automatic_failover(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_automatic_failover", value)

    @property
    @pulumi.getter(name="enableCassandraConnector")
    def enable_cassandra_connector(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables the cassandra connector on the Cosmos DB C* account
        """
        return pulumi.get(self, "enable_cassandra_connector")

    @enable_cassandra_connector.setter
    def enable_cassandra_connector(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_cassandra_connector", value)

    @property
    @pulumi.getter(name="enableFreeTier")
    def enable_free_tier(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag to indicate whether Free Tier is enabled.
        """
        return pulumi.get(self, "enable_free_tier")

    @enable_free_tier.setter
    def enable_free_tier(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_free_tier", value)

    @property
    @pulumi.getter(name="enableMultipleWriteLocations")
    def enable_multiple_write_locations(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables the account to write in multiple locations
        """
        return pulumi.get(self, "enable_multiple_write_locations")

    @enable_multiple_write_locations.setter
    def enable_multiple_write_locations(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_multiple_write_locations", value)

    @property
    @pulumi.getter(name="ipRules")
    def ip_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IpAddressOrRangeArgs']]]]:
        """
        List of IpRules.
        """
        return pulumi.get(self, "ip_rules")

    @ip_rules.setter
    def ip_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IpAddressOrRangeArgs']]]]):
        pulumi.set(self, "ip_rules", value)

    @property
    @pulumi.getter(name="isVirtualNetworkFilterEnabled")
    def is_virtual_network_filter_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag to indicate whether to enable/disable Virtual Network ACL rules.
        """
        return pulumi.get(self, "is_virtual_network_filter_enabled")

    @is_virtual_network_filter_enabled.setter
    def is_virtual_network_filter_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_virtual_network_filter_enabled", value)

    @property
    @pulumi.getter(name="keyVaultKeyUri")
    def key_vault_key_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The URI of the key vault
        """
        return pulumi.get(self, "key_vault_key_uri")

    @key_vault_key_uri.setter
    def key_vault_key_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_vault_key_uri", value)

    @property
    @pulumi.getter(name="networkAclBypass")
    def network_acl_bypass(self) -> Optional[pulumi.Input['NetworkAclBypass']]:
        """
        Indicates what services are allowed to bypass firewall checks.
        """
        return pulumi.get(self, "network_acl_bypass")

    @network_acl_bypass.setter
    def network_acl_bypass(self, value: Optional[pulumi.Input['NetworkAclBypass']]):
        pulumi.set(self, "network_acl_bypass", value)

    @property
    @pulumi.getter(name="networkAclBypassResourceIds")
    def network_acl_bypass_resource_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array that contains the Resource Ids for Network Acl Bypass for the Cosmos DB account.
        """
        return pulumi.get(self, "network_acl_bypass_resource_ids")

    @network_acl_bypass_resource_ids.setter
    def network_acl_bypass_resource_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "network_acl_bypass_resource_ids", value)

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[pulumi.Input[Union[str, 'PublicNetworkAccess']]]:
        """
        Whether requests from Public Network are allowed
        """
        return pulumi.get(self, "public_network_access")

    @public_network_access.setter
    def public_network_access(self, value: Optional[pulumi.Input[Union[str, 'PublicNetworkAccess']]]):
        pulumi.set(self, "public_network_access", value)

    @property
    @pulumi.getter(name="virtualNetworkRules")
    def virtual_network_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkRuleArgs']]]]:
        """
        List of Virtual Network ACL rules configured for the Cosmos DB account.
        """
        return pulumi.get(self, "virtual_network_rules")

    @virtual_network_rules.setter
    def virtual_network_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkRuleArgs']]]]):
        pulumi.set(self, "virtual_network_rules", value)


@pulumi.input_type
class IpAddressOrRangeArgs:
    def __init__(__self__, *,
                 ip_address_or_range: Optional[pulumi.Input[str]] = None):
        """
        IpAddressOrRange object
        :param pulumi.Input[str] ip_address_or_range: A single IPv4 address or a single IPv4 address range in CIDR format. Provided IPs must be well-formatted and cannot be contained in one of the following ranges: 10.0.0.0/8, 100.64.0.0/10, 172.16.0.0/12, 192.168.0.0/16, since these are not enforceable by the IP address filter. Example of valid inputs: “23.40.210.245” or “23.40.210.0/8”.
        """
        IpAddressOrRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_address_or_range=ip_address_or_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_address_or_range: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_address_or_range is None and 'ipAddressOrRange' in kwargs:
            ip_address_or_range = kwargs['ipAddressOrRange']

        if ip_address_or_range is not None:
            _setter("ip_address_or_range", ip_address_or_range)

    @property
    @pulumi.getter(name="ipAddressOrRange")
    def ip_address_or_range(self) -> Optional[pulumi.Input[str]]:
        """
        A single IPv4 address or a single IPv4 address range in CIDR format. Provided IPs must be well-formatted and cannot be contained in one of the following ranges: 10.0.0.0/8, 100.64.0.0/10, 172.16.0.0/12, 192.168.0.0/16, since these are not enforceable by the IP address filter. Example of valid inputs: “23.40.210.245” or “23.40.210.0/8”.
        """
        return pulumi.get(self, "ip_address_or_range")

    @ip_address_or_range.setter
    def ip_address_or_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address_or_range", value)


@pulumi.input_type
class LocationArgs:
    def __init__(__self__, *,
                 failover_priority: Optional[pulumi.Input[int]] = None,
                 is_zone_redundant: Optional[pulumi.Input[bool]] = None,
                 location_name: Optional[pulumi.Input[str]] = None):
        """
        A region in which the Azure Cosmos DB database account is deployed.
        :param pulumi.Input[int] failover_priority: The failover priority of the region. A failover priority of 0 indicates a write region. The maximum value for a failover priority = (total number of regions - 1). Failover priority values must be unique for each of the regions in which the database account exists.
        :param pulumi.Input[bool] is_zone_redundant: Flag to indicate whether or not this region is an AvailabilityZone region
        :param pulumi.Input[str] location_name: The name of the region.
        """
        LocationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failover_priority=failover_priority,
            is_zone_redundant=is_zone_redundant,
            location_name=location_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failover_priority: Optional[pulumi.Input[int]] = None,
             is_zone_redundant: Optional[pulumi.Input[bool]] = None,
             location_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if failover_priority is None and 'failoverPriority' in kwargs:
            failover_priority = kwargs['failoverPriority']
        if is_zone_redundant is None and 'isZoneRedundant' in kwargs:
            is_zone_redundant = kwargs['isZoneRedundant']
        if location_name is None and 'locationName' in kwargs:
            location_name = kwargs['locationName']

        if failover_priority is not None:
            _setter("failover_priority", failover_priority)
        if is_zone_redundant is not None:
            _setter("is_zone_redundant", is_zone_redundant)
        if location_name is not None:
            _setter("location_name", location_name)

    @property
    @pulumi.getter(name="failoverPriority")
    def failover_priority(self) -> Optional[pulumi.Input[int]]:
        """
        The failover priority of the region. A failover priority of 0 indicates a write region. The maximum value for a failover priority = (total number of regions - 1). Failover priority values must be unique for each of the regions in which the database account exists.
        """
        return pulumi.get(self, "failover_priority")

    @failover_priority.setter
    def failover_priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failover_priority", value)

    @property
    @pulumi.getter(name="isZoneRedundant")
    def is_zone_redundant(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag to indicate whether or not this region is an AvailabilityZone region
        """
        return pulumi.get(self, "is_zone_redundant")

    @is_zone_redundant.setter
    def is_zone_redundant(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_zone_redundant", value)

    @property
    @pulumi.getter(name="locationName")
    def location_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the region.
        """
        return pulumi.get(self, "location_name")

    @location_name.setter
    def location_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location_name", value)


@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['ResourceIdentityType']] = None,
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Identity for the resource.
        :param pulumi.Input['ResourceIdentityType'] type: The type of identity used for the resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the service.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: The list of user identities associated with resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        ManagedServiceIdentityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            user_assigned_identities=user_assigned_identities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input['ResourceIdentityType']] = None,
             user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if user_assigned_identities is None and 'userAssignedIdentities' in kwargs:
            user_assigned_identities = kwargs['userAssignedIdentities']

        if type is not None:
            _setter("type", type)
        if user_assigned_identities is not None:
            _setter("user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['ResourceIdentityType']]:
        """
        The type of identity used for the resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the service.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['ResourceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of user identities associated with resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


@pulumi.input_type
class PeriodicModeBackupPolicyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 periodic_mode_properties: Optional[pulumi.Input['PeriodicModePropertiesArgs']] = None):
        """
        The object representing periodic mode backup policy.
        :param pulumi.Input[str] type: Describes the mode of backups.
               Expected value is 'Periodic'.
        :param pulumi.Input['PeriodicModePropertiesArgs'] periodic_mode_properties: Configuration values for periodic mode backup
        """
        PeriodicModeBackupPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            periodic_mode_properties=periodic_mode_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             periodic_mode_properties: Optional[pulumi.Input['PeriodicModePropertiesArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if periodic_mode_properties is None and 'periodicModeProperties' in kwargs:
            periodic_mode_properties = kwargs['periodicModeProperties']

        _setter("type", 'Periodic')
        if periodic_mode_properties is not None:
            _setter("periodic_mode_properties", periodic_mode_properties)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Describes the mode of backups.
        Expected value is 'Periodic'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="periodicModeProperties")
    def periodic_mode_properties(self) -> Optional[pulumi.Input['PeriodicModePropertiesArgs']]:
        """
        Configuration values for periodic mode backup
        """
        return pulumi.get(self, "periodic_mode_properties")

    @periodic_mode_properties.setter
    def periodic_mode_properties(self, value: Optional[pulumi.Input['PeriodicModePropertiesArgs']]):
        pulumi.set(self, "periodic_mode_properties", value)


@pulumi.input_type
class PeriodicModePropertiesArgs:
    def __init__(__self__, *,
                 backup_interval_in_minutes: Optional[pulumi.Input[int]] = None,
                 backup_retention_interval_in_hours: Optional[pulumi.Input[int]] = None,
                 backup_storage_redundancy: Optional[pulumi.Input[Union[str, 'BackupStorageRedundancy']]] = None):
        """
        Configuration values for periodic mode backup
        :param pulumi.Input[int] backup_interval_in_minutes: An integer representing the interval in minutes between two backups
        :param pulumi.Input[int] backup_retention_interval_in_hours: An integer representing the time (in hours) that each backup is retained
        :param pulumi.Input[Union[str, 'BackupStorageRedundancy']] backup_storage_redundancy: Enum to indicate type of backup residency
        """
        PeriodicModePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_interval_in_minutes=backup_interval_in_minutes,
            backup_retention_interval_in_hours=backup_retention_interval_in_hours,
            backup_storage_redundancy=backup_storage_redundancy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_interval_in_minutes: Optional[pulumi.Input[int]] = None,
             backup_retention_interval_in_hours: Optional[pulumi.Input[int]] = None,
             backup_storage_redundancy: Optional[pulumi.Input[Union[str, 'BackupStorageRedundancy']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if backup_interval_in_minutes is None and 'backupIntervalInMinutes' in kwargs:
            backup_interval_in_minutes = kwargs['backupIntervalInMinutes']
        if backup_retention_interval_in_hours is None and 'backupRetentionIntervalInHours' in kwargs:
            backup_retention_interval_in_hours = kwargs['backupRetentionIntervalInHours']
        if backup_storage_redundancy is None and 'backupStorageRedundancy' in kwargs:
            backup_storage_redundancy = kwargs['backupStorageRedundancy']

        if backup_interval_in_minutes is not None:
            _setter("backup_interval_in_minutes", backup_interval_in_minutes)
        if backup_retention_interval_in_hours is not None:
            _setter("backup_retention_interval_in_hours", backup_retention_interval_in_hours)
        if backup_storage_redundancy is not None:
            _setter("backup_storage_redundancy", backup_storage_redundancy)

    @property
    @pulumi.getter(name="backupIntervalInMinutes")
    def backup_interval_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        An integer representing the interval in minutes between two backups
        """
        return pulumi.get(self, "backup_interval_in_minutes")

    @backup_interval_in_minutes.setter
    def backup_interval_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "backup_interval_in_minutes", value)

    @property
    @pulumi.getter(name="backupRetentionIntervalInHours")
    def backup_retention_interval_in_hours(self) -> Optional[pulumi.Input[int]]:
        """
        An integer representing the time (in hours) that each backup is retained
        """
        return pulumi.get(self, "backup_retention_interval_in_hours")

    @backup_retention_interval_in_hours.setter
    def backup_retention_interval_in_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "backup_retention_interval_in_hours", value)

    @property
    @pulumi.getter(name="backupStorageRedundancy")
    def backup_storage_redundancy(self) -> Optional[pulumi.Input[Union[str, 'BackupStorageRedundancy']]]:
        """
        Enum to indicate type of backup residency
        """
        return pulumi.get(self, "backup_storage_redundancy")

    @backup_storage_redundancy.setter
    def backup_storage_redundancy(self, value: Optional[pulumi.Input[Union[str, 'BackupStorageRedundancy']]]):
        pulumi.set(self, "backup_storage_redundancy", value)


@pulumi.input_type
class RestoreParametersArgs:
    def __init__(__self__, *,
                 databases_to_restore: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseRestoreResourceArgs']]]] = None,
                 restore_mode: Optional[pulumi.Input[Union[str, 'RestoreMode']]] = None,
                 restore_source: Optional[pulumi.Input[str]] = None,
                 restore_timestamp_in_utc: Optional[pulumi.Input[str]] = None):
        """
        Parameters to indicate the information about the restore.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseRestoreResourceArgs']]] databases_to_restore: List of specific databases available for restore.
        :param pulumi.Input[Union[str, 'RestoreMode']] restore_mode: Describes the mode of the restore.
        :param pulumi.Input[str] restore_source: The id of the restorable database account from which the restore has to be initiated. For example: /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}
        :param pulumi.Input[str] restore_timestamp_in_utc: Time to which the account has to be restored (ISO-8601 format).
        """
        RestoreParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            databases_to_restore=databases_to_restore,
            restore_mode=restore_mode,
            restore_source=restore_source,
            restore_timestamp_in_utc=restore_timestamp_in_utc,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             databases_to_restore: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseRestoreResourceArgs']]]] = None,
             restore_mode: Optional[pulumi.Input[Union[str, 'RestoreMode']]] = None,
             restore_source: Optional[pulumi.Input[str]] = None,
             restore_timestamp_in_utc: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if databases_to_restore is None and 'databasesToRestore' in kwargs:
            databases_to_restore = kwargs['databasesToRestore']
        if restore_mode is None and 'restoreMode' in kwargs:
            restore_mode = kwargs['restoreMode']
        if restore_source is None and 'restoreSource' in kwargs:
            restore_source = kwargs['restoreSource']
        if restore_timestamp_in_utc is None and 'restoreTimestampInUtc' in kwargs:
            restore_timestamp_in_utc = kwargs['restoreTimestampInUtc']

        if databases_to_restore is not None:
            _setter("databases_to_restore", databases_to_restore)
        if restore_mode is not None:
            _setter("restore_mode", restore_mode)
        if restore_source is not None:
            _setter("restore_source", restore_source)
        if restore_timestamp_in_utc is not None:
            _setter("restore_timestamp_in_utc", restore_timestamp_in_utc)

    @property
    @pulumi.getter(name="databasesToRestore")
    def databases_to_restore(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseRestoreResourceArgs']]]]:
        """
        List of specific databases available for restore.
        """
        return pulumi.get(self, "databases_to_restore")

    @databases_to_restore.setter
    def databases_to_restore(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseRestoreResourceArgs']]]]):
        pulumi.set(self, "databases_to_restore", value)

    @property
    @pulumi.getter(name="restoreMode")
    def restore_mode(self) -> Optional[pulumi.Input[Union[str, 'RestoreMode']]]:
        """
        Describes the mode of the restore.
        """
        return pulumi.get(self, "restore_mode")

    @restore_mode.setter
    def restore_mode(self, value: Optional[pulumi.Input[Union[str, 'RestoreMode']]]):
        pulumi.set(self, "restore_mode", value)

    @property
    @pulumi.getter(name="restoreSource")
    def restore_source(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the restorable database account from which the restore has to be initiated. For example: /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}
        """
        return pulumi.get(self, "restore_source")

    @restore_source.setter
    def restore_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "restore_source", value)

    @property
    @pulumi.getter(name="restoreTimestampInUtc")
    def restore_timestamp_in_utc(self) -> Optional[pulumi.Input[str]]:
        """
        Time to which the account has to be restored (ISO-8601 format).
        """
        return pulumi.get(self, "restore_timestamp_in_utc")

    @restore_timestamp_in_utc.setter
    def restore_timestamp_in_utc(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "restore_timestamp_in_utc", value)


@pulumi.input_type
class RestoreReqeustDatabaseAccountCreateUpdatePropertiesArgs:
    def __init__(__self__, *,
                 create_mode: Optional[pulumi.Input[str]] = None,
                 database_account_offer_type: pulumi.Input['DatabaseAccountOfferType'],
                 locations: pulumi.Input[Sequence[pulumi.Input['LocationArgs']]],
                 api_properties: Optional[pulumi.Input['ApiPropertiesArgs']] = None,
                 backup_policy: Optional[pulumi.Input[Union['ContinuousModeBackupPolicyArgs', 'PeriodicModeBackupPolicyArgs']]] = None,
                 capabilities: Optional[pulumi.Input[Sequence[pulumi.Input['CapabilityArgs']]]] = None,
                 connector_offer: Optional[pulumi.Input[Union[str, 'ConnectorOffer']]] = None,
                 consistency_policy: Optional[pulumi.Input['ConsistencyPolicyArgs']] = None,
                 cors: Optional[pulumi.Input[Sequence[pulumi.Input['CorsPolicyArgs']]]] = None,
                 default_identity: Optional[pulumi.Input[str]] = None,
                 disable_key_based_metadata_write_access: Optional[pulumi.Input[bool]] = None,
                 enable_analytical_storage: Optional[pulumi.Input[bool]] = None,
                 enable_automatic_failover: Optional[pulumi.Input[bool]] = None,
                 enable_cassandra_connector: Optional[pulumi.Input[bool]] = None,
                 enable_free_tier: Optional[pulumi.Input[bool]] = None,
                 enable_multiple_write_locations: Optional[pulumi.Input[bool]] = None,
                 ip_rules: Optional[pulumi.Input[Sequence[pulumi.Input['IpAddressOrRangeArgs']]]] = None,
                 is_virtual_network_filter_enabled: Optional[pulumi.Input[bool]] = None,
                 key_vault_key_uri: Optional[pulumi.Input[str]] = None,
                 network_acl_bypass: Optional[pulumi.Input['NetworkAclBypass']] = None,
                 network_acl_bypass_resource_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 public_network_access: Optional[pulumi.Input[Union[str, 'PublicNetworkAccess']]] = None,
                 restore_parameters: Optional[pulumi.Input['RestoreParametersArgs']] = None,
                 virtual_network_rules: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkRuleArgs']]]] = None):
        """
        Properties to restore Azure Cosmos DB database account.
        :param pulumi.Input[str] create_mode: Enum to indicate the mode of account creation.
               Expected value is 'Restore'.
        :param pulumi.Input['DatabaseAccountOfferType'] database_account_offer_type: The offer type for the database
        :param pulumi.Input[Sequence[pulumi.Input['LocationArgs']]] locations: An array that contains the georeplication locations enabled for the Cosmos DB account.
        :param pulumi.Input['ApiPropertiesArgs'] api_properties: API specific properties. Currently, supported only for MongoDB API.
        :param pulumi.Input[Union['ContinuousModeBackupPolicyArgs', 'PeriodicModeBackupPolicyArgs']] backup_policy: The object representing the policy for taking backups on an account.
        :param pulumi.Input[Sequence[pulumi.Input['CapabilityArgs']]] capabilities: List of Cosmos DB capabilities for the account
        :param pulumi.Input[Union[str, 'ConnectorOffer']] connector_offer: The cassandra connector offer type for the Cosmos DB database C* account.
        :param pulumi.Input['ConsistencyPolicyArgs'] consistency_policy: The consistency policy for the Cosmos DB account.
        :param pulumi.Input[Sequence[pulumi.Input['CorsPolicyArgs']]] cors: The CORS policy for the Cosmos DB database account.
        :param pulumi.Input[str] default_identity: The default identity for accessing key vault used in features like customer managed keys. The default identity needs to be explicitly set by the users. It can be "FirstPartyIdentity", "SystemAssignedIdentity" and more.
        :param pulumi.Input[bool] disable_key_based_metadata_write_access: Disable write operations on metadata resources (databases, containers, throughput) via account keys
        :param pulumi.Input[bool] enable_analytical_storage: Flag to indicate whether to enable storage analytics.
        :param pulumi.Input[bool] enable_automatic_failover: Enables automatic failover of the write region in the rare event that the region is unavailable due to an outage. Automatic failover will result in a new write region for the account and is chosen based on the failover priorities configured for the account.
        :param pulumi.Input[bool] enable_cassandra_connector: Enables the cassandra connector on the Cosmos DB C* account
        :param pulumi.Input[bool] enable_free_tier: Flag to indicate whether Free Tier is enabled.
        :param pulumi.Input[bool] enable_multiple_write_locations: Enables the account to write in multiple locations
        :param pulumi.Input[Sequence[pulumi.Input['IpAddressOrRangeArgs']]] ip_rules: List of IpRules.
        :param pulumi.Input[bool] is_virtual_network_filter_enabled: Flag to indicate whether to enable/disable Virtual Network ACL rules.
        :param pulumi.Input[str] key_vault_key_uri: The URI of the key vault
        :param pulumi.Input['NetworkAclBypass'] network_acl_bypass: Indicates what services are allowed to bypass firewall checks.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] network_acl_bypass_resource_ids: An array that contains the Resource Ids for Network Acl Bypass for the Cosmos DB account.
        :param pulumi.Input[Union[str, 'PublicNetworkAccess']] public_network_access: Whether requests from Public Network are allowed
        :param pulumi.Input['RestoreParametersArgs'] restore_parameters: Parameters to indicate the information about the restore.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualNetworkRuleArgs']]] virtual_network_rules: List of Virtual Network ACL rules configured for the Cosmos DB account.
        """
        RestoreReqeustDatabaseAccountCreateUpdatePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create_mode=create_mode,
            database_account_offer_type=database_account_offer_type,
            locations=locations,
            api_properties=api_properties,
            backup_policy=backup_policy,
            capabilities=capabilities,
            connector_offer=connector_offer,
            consistency_policy=consistency_policy,
            cors=cors,
            default_identity=default_identity,
            disable_key_based_metadata_write_access=disable_key_based_metadata_write_access,
            enable_analytical_storage=enable_analytical_storage,
            enable_automatic_failover=enable_automatic_failover,
            enable_cassandra_connector=enable_cassandra_connector,
            enable_free_tier=enable_free_tier,
            enable_multiple_write_locations=enable_multiple_write_locations,
            ip_rules=ip_rules,
            is_virtual_network_filter_enabled=is_virtual_network_filter_enabled,
            key_vault_key_uri=key_vault_key_uri,
            network_acl_bypass=network_acl_bypass,
            network_acl_bypass_resource_ids=network_acl_bypass_resource_ids,
            public_network_access=public_network_access,
            restore_parameters=restore_parameters,
            virtual_network_rules=virtual_network_rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create_mode: Optional[pulumi.Input[str]] = None,
             database_account_offer_type: Optional[pulumi.Input['DatabaseAccountOfferType']] = None,
             locations: Optional[pulumi.Input[Sequence[pulumi.Input['LocationArgs']]]] = None,
             api_properties: Optional[pulumi.Input['ApiPropertiesArgs']] = None,
             backup_policy: Optional[pulumi.Input[Union['ContinuousModeBackupPolicyArgs', 'PeriodicModeBackupPolicyArgs']]] = None,
             capabilities: Optional[pulumi.Input[Sequence[pulumi.Input['CapabilityArgs']]]] = None,
             connector_offer: Optional[pulumi.Input[Union[str, 'ConnectorOffer']]] = None,
             consistency_policy: Optional[pulumi.Input['ConsistencyPolicyArgs']] = None,
             cors: Optional[pulumi.Input[Sequence[pulumi.Input['CorsPolicyArgs']]]] = None,
             default_identity: Optional[pulumi.Input[str]] = None,
             disable_key_based_metadata_write_access: Optional[pulumi.Input[bool]] = None,
             enable_analytical_storage: Optional[pulumi.Input[bool]] = None,
             enable_automatic_failover: Optional[pulumi.Input[bool]] = None,
             enable_cassandra_connector: Optional[pulumi.Input[bool]] = None,
             enable_free_tier: Optional[pulumi.Input[bool]] = None,
             enable_multiple_write_locations: Optional[pulumi.Input[bool]] = None,
             ip_rules: Optional[pulumi.Input[Sequence[pulumi.Input['IpAddressOrRangeArgs']]]] = None,
             is_virtual_network_filter_enabled: Optional[pulumi.Input[bool]] = None,
             key_vault_key_uri: Optional[pulumi.Input[str]] = None,
             network_acl_bypass: Optional[pulumi.Input['NetworkAclBypass']] = None,
             network_acl_bypass_resource_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             public_network_access: Optional[pulumi.Input[Union[str, 'PublicNetworkAccess']]] = None,
             restore_parameters: Optional[pulumi.Input['RestoreParametersArgs']] = None,
             virtual_network_rules: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkRuleArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if create_mode is None and 'createMode' in kwargs:
            create_mode = kwargs['createMode']
        if database_account_offer_type is None and 'databaseAccountOfferType' in kwargs:
            database_account_offer_type = kwargs['databaseAccountOfferType']
        if database_account_offer_type is None:
            raise TypeError("Missing 'database_account_offer_type' argument")
        if locations is None:
            raise TypeError("Missing 'locations' argument")
        if api_properties is None and 'apiProperties' in kwargs:
            api_properties = kwargs['apiProperties']
        if backup_policy is None and 'backupPolicy' in kwargs:
            backup_policy = kwargs['backupPolicy']
        if connector_offer is None and 'connectorOffer' in kwargs:
            connector_offer = kwargs['connectorOffer']
        if consistency_policy is None and 'consistencyPolicy' in kwargs:
            consistency_policy = kwargs['consistencyPolicy']
        if default_identity is None and 'defaultIdentity' in kwargs:
            default_identity = kwargs['defaultIdentity']
        if disable_key_based_metadata_write_access is None and 'disableKeyBasedMetadataWriteAccess' in kwargs:
            disable_key_based_metadata_write_access = kwargs['disableKeyBasedMetadataWriteAccess']
        if enable_analytical_storage is None and 'enableAnalyticalStorage' in kwargs:
            enable_analytical_storage = kwargs['enableAnalyticalStorage']
        if enable_automatic_failover is None and 'enableAutomaticFailover' in kwargs:
            enable_automatic_failover = kwargs['enableAutomaticFailover']
        if enable_cassandra_connector is None and 'enableCassandraConnector' in kwargs:
            enable_cassandra_connector = kwargs['enableCassandraConnector']
        if enable_free_tier is None and 'enableFreeTier' in kwargs:
            enable_free_tier = kwargs['enableFreeTier']
        if enable_multiple_write_locations is None and 'enableMultipleWriteLocations' in kwargs:
            enable_multiple_write_locations = kwargs['enableMultipleWriteLocations']
        if ip_rules is None and 'ipRules' in kwargs:
            ip_rules = kwargs['ipRules']
        if is_virtual_network_filter_enabled is None and 'isVirtualNetworkFilterEnabled' in kwargs:
            is_virtual_network_filter_enabled = kwargs['isVirtualNetworkFilterEnabled']
        if key_vault_key_uri is None and 'keyVaultKeyUri' in kwargs:
            key_vault_key_uri = kwargs['keyVaultKeyUri']
        if network_acl_bypass is None and 'networkAclBypass' in kwargs:
            network_acl_bypass = kwargs['networkAclBypass']
        if network_acl_bypass_resource_ids is None and 'networkAclBypassResourceIds' in kwargs:
            network_acl_bypass_resource_ids = kwargs['networkAclBypassResourceIds']
        if public_network_access is None and 'publicNetworkAccess' in kwargs:
            public_network_access = kwargs['publicNetworkAccess']
        if restore_parameters is None and 'restoreParameters' in kwargs:
            restore_parameters = kwargs['restoreParameters']
        if virtual_network_rules is None and 'virtualNetworkRules' in kwargs:
            virtual_network_rules = kwargs['virtualNetworkRules']

        if create_mode is None:
            create_mode = 'Default'
        _setter("create_mode", 'Restore')
        _setter("database_account_offer_type", database_account_offer_type)
        _setter("locations", locations)
        if api_properties is not None:
            _setter("api_properties", api_properties)
        if backup_policy is not None:
            _setter("backup_policy", backup_policy)
        if capabilities is not None:
            _setter("capabilities", capabilities)
        if connector_offer is not None:
            _setter("connector_offer", connector_offer)
        if consistency_policy is not None:
            _setter("consistency_policy", consistency_policy)
        if cors is not None:
            _setter("cors", cors)
        if default_identity is not None:
            _setter("default_identity", default_identity)
        if disable_key_based_metadata_write_access is not None:
            _setter("disable_key_based_metadata_write_access", disable_key_based_metadata_write_access)
        if enable_analytical_storage is not None:
            _setter("enable_analytical_storage", enable_analytical_storage)
        if enable_automatic_failover is not None:
            _setter("enable_automatic_failover", enable_automatic_failover)
        if enable_cassandra_connector is not None:
            _setter("enable_cassandra_connector", enable_cassandra_connector)
        if enable_free_tier is not None:
            _setter("enable_free_tier", enable_free_tier)
        if enable_multiple_write_locations is not None:
            _setter("enable_multiple_write_locations", enable_multiple_write_locations)
        if ip_rules is not None:
            _setter("ip_rules", ip_rules)
        if is_virtual_network_filter_enabled is not None:
            _setter("is_virtual_network_filter_enabled", is_virtual_network_filter_enabled)
        if key_vault_key_uri is not None:
            _setter("key_vault_key_uri", key_vault_key_uri)
        if network_acl_bypass is not None:
            _setter("network_acl_bypass", network_acl_bypass)
        if network_acl_bypass_resource_ids is not None:
            _setter("network_acl_bypass_resource_ids", network_acl_bypass_resource_ids)
        if public_network_access is not None:
            _setter("public_network_access", public_network_access)
        if restore_parameters is not None:
            _setter("restore_parameters", restore_parameters)
        if virtual_network_rules is not None:
            _setter("virtual_network_rules", virtual_network_rules)

    @property
    @pulumi.getter(name="createMode")
    def create_mode(self) -> pulumi.Input[str]:
        """
        Enum to indicate the mode of account creation.
        Expected value is 'Restore'.
        """
        return pulumi.get(self, "create_mode")

    @create_mode.setter
    def create_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "create_mode", value)

    @property
    @pulumi.getter(name="databaseAccountOfferType")
    def database_account_offer_type(self) -> pulumi.Input['DatabaseAccountOfferType']:
        """
        The offer type for the database
        """
        return pulumi.get(self, "database_account_offer_type")

    @database_account_offer_type.setter
    def database_account_offer_type(self, value: pulumi.Input['DatabaseAccountOfferType']):
        pulumi.set(self, "database_account_offer_type", value)

    @property
    @pulumi.getter
    def locations(self) -> pulumi.Input[Sequence[pulumi.Input['LocationArgs']]]:
        """
        An array that contains the georeplication locations enabled for the Cosmos DB account.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: pulumi.Input[Sequence[pulumi.Input['LocationArgs']]]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter(name="apiProperties")
    def api_properties(self) -> Optional[pulumi.Input['ApiPropertiesArgs']]:
        """
        API specific properties. Currently, supported only for MongoDB API.
        """
        return pulumi.get(self, "api_properties")

    @api_properties.setter
    def api_properties(self, value: Optional[pulumi.Input['ApiPropertiesArgs']]):
        pulumi.set(self, "api_properties", value)

    @property
    @pulumi.getter(name="backupPolicy")
    def backup_policy(self) -> Optional[pulumi.Input[Union['ContinuousModeBackupPolicyArgs', 'PeriodicModeBackupPolicyArgs']]]:
        """
        The object representing the policy for taking backups on an account.
        """
        return pulumi.get(self, "backup_policy")

    @backup_policy.setter
    def backup_policy(self, value: Optional[pulumi.Input[Union['ContinuousModeBackupPolicyArgs', 'PeriodicModeBackupPolicyArgs']]]):
        pulumi.set(self, "backup_policy", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CapabilityArgs']]]]:
        """
        List of Cosmos DB capabilities for the account
        """
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CapabilityArgs']]]]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter(name="connectorOffer")
    def connector_offer(self) -> Optional[pulumi.Input[Union[str, 'ConnectorOffer']]]:
        """
        The cassandra connector offer type for the Cosmos DB database C* account.
        """
        return pulumi.get(self, "connector_offer")

    @connector_offer.setter
    def connector_offer(self, value: Optional[pulumi.Input[Union[str, 'ConnectorOffer']]]):
        pulumi.set(self, "connector_offer", value)

    @property
    @pulumi.getter(name="consistencyPolicy")
    def consistency_policy(self) -> Optional[pulumi.Input['ConsistencyPolicyArgs']]:
        """
        The consistency policy for the Cosmos DB account.
        """
        return pulumi.get(self, "consistency_policy")

    @consistency_policy.setter
    def consistency_policy(self, value: Optional[pulumi.Input['ConsistencyPolicyArgs']]):
        pulumi.set(self, "consistency_policy", value)

    @property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CorsPolicyArgs']]]]:
        """
        The CORS policy for the Cosmos DB database account.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CorsPolicyArgs']]]]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="defaultIdentity")
    def default_identity(self) -> Optional[pulumi.Input[str]]:
        """
        The default identity for accessing key vault used in features like customer managed keys. The default identity needs to be explicitly set by the users. It can be "FirstPartyIdentity", "SystemAssignedIdentity" and more.
        """
        return pulumi.get(self, "default_identity")

    @default_identity.setter
    def default_identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_identity", value)

    @property
    @pulumi.getter(name="disableKeyBasedMetadataWriteAccess")
    def disable_key_based_metadata_write_access(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable write operations on metadata resources (databases, containers, throughput) via account keys
        """
        return pulumi.get(self, "disable_key_based_metadata_write_access")

    @disable_key_based_metadata_write_access.setter
    def disable_key_based_metadata_write_access(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_key_based_metadata_write_access", value)

    @property
    @pulumi.getter(name="enableAnalyticalStorage")
    def enable_analytical_storage(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag to indicate whether to enable storage analytics.
        """
        return pulumi.get(self, "enable_analytical_storage")

    @enable_analytical_storage.setter
    def enable_analytical_storage(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_analytical_storage", value)

    @property
    @pulumi.getter(name="enableAutomaticFailover")
    def enable_automatic_failover(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables automatic failover of the write region in the rare event that the region is unavailable due to an outage. Automatic failover will result in a new write region for the account and is chosen based on the failover priorities configured for the account.
        """
        return pulumi.get(self, "enable_automatic_failover")

    @enable_automatic_failover.setter
    def enable_automatic_failover(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_automatic_failover", value)

    @property
    @pulumi.getter(name="enableCassandraConnector")
    def enable_cassandra_connector(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables the cassandra connector on the Cosmos DB C* account
        """
        return pulumi.get(self, "enable_cassandra_connector")

    @enable_cassandra_connector.setter
    def enable_cassandra_connector(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_cassandra_connector", value)

    @property
    @pulumi.getter(name="enableFreeTier")
    def enable_free_tier(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag to indicate whether Free Tier is enabled.
        """
        return pulumi.get(self, "enable_free_tier")

    @enable_free_tier.setter
    def enable_free_tier(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_free_tier", value)

    @property
    @pulumi.getter(name="enableMultipleWriteLocations")
    def enable_multiple_write_locations(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables the account to write in multiple locations
        """
        return pulumi.get(self, "enable_multiple_write_locations")

    @enable_multiple_write_locations.setter
    def enable_multiple_write_locations(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_multiple_write_locations", value)

    @property
    @pulumi.getter(name="ipRules")
    def ip_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IpAddressOrRangeArgs']]]]:
        """
        List of IpRules.
        """
        return pulumi.get(self, "ip_rules")

    @ip_rules.setter
    def ip_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IpAddressOrRangeArgs']]]]):
        pulumi.set(self, "ip_rules", value)

    @property
    @pulumi.getter(name="isVirtualNetworkFilterEnabled")
    def is_virtual_network_filter_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag to indicate whether to enable/disable Virtual Network ACL rules.
        """
        return pulumi.get(self, "is_virtual_network_filter_enabled")

    @is_virtual_network_filter_enabled.setter
    def is_virtual_network_filter_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_virtual_network_filter_enabled", value)

    @property
    @pulumi.getter(name="keyVaultKeyUri")
    def key_vault_key_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The URI of the key vault
        """
        return pulumi.get(self, "key_vault_key_uri")

    @key_vault_key_uri.setter
    def key_vault_key_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_vault_key_uri", value)

    @property
    @pulumi.getter(name="networkAclBypass")
    def network_acl_bypass(self) -> Optional[pulumi.Input['NetworkAclBypass']]:
        """
        Indicates what services are allowed to bypass firewall checks.
        """
        return pulumi.get(self, "network_acl_bypass")

    @network_acl_bypass.setter
    def network_acl_bypass(self, value: Optional[pulumi.Input['NetworkAclBypass']]):
        pulumi.set(self, "network_acl_bypass", value)

    @property
    @pulumi.getter(name="networkAclBypassResourceIds")
    def network_acl_bypass_resource_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array that contains the Resource Ids for Network Acl Bypass for the Cosmos DB account.
        """
        return pulumi.get(self, "network_acl_bypass_resource_ids")

    @network_acl_bypass_resource_ids.setter
    def network_acl_bypass_resource_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "network_acl_bypass_resource_ids", value)

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[pulumi.Input[Union[str, 'PublicNetworkAccess']]]:
        """
        Whether requests from Public Network are allowed
        """
        return pulumi.get(self, "public_network_access")

    @public_network_access.setter
    def public_network_access(self, value: Optional[pulumi.Input[Union[str, 'PublicNetworkAccess']]]):
        pulumi.set(self, "public_network_access", value)

    @property
    @pulumi.getter(name="restoreParameters")
    def restore_parameters(self) -> Optional[pulumi.Input['RestoreParametersArgs']]:
        """
        Parameters to indicate the information about the restore.
        """
        return pulumi.get(self, "restore_parameters")

    @restore_parameters.setter
    def restore_parameters(self, value: Optional[pulumi.Input['RestoreParametersArgs']]):
        pulumi.set(self, "restore_parameters", value)

    @property
    @pulumi.getter(name="virtualNetworkRules")
    def virtual_network_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkRuleArgs']]]]:
        """
        List of Virtual Network ACL rules configured for the Cosmos DB account.
        """
        return pulumi.get(self, "virtual_network_rules")

    @virtual_network_rules.setter
    def virtual_network_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualNetworkRuleArgs']]]]):
        pulumi.set(self, "virtual_network_rules", value)


@pulumi.input_type
class VirtualNetworkRuleArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 ignore_missing_v_net_service_endpoint: Optional[pulumi.Input[bool]] = None):
        """
        Virtual Network ACL Rule object
        :param pulumi.Input[str] id: Resource ID of a subnet, for example: /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
        :param pulumi.Input[bool] ignore_missing_v_net_service_endpoint: Create firewall rule before the virtual network has vnet service endpoint enabled.
        """
        VirtualNetworkRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            ignore_missing_v_net_service_endpoint=ignore_missing_v_net_service_endpoint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             ignore_missing_v_net_service_endpoint: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ignore_missing_v_net_service_endpoint is None and 'ignoreMissingVNetServiceEndpoint' in kwargs:
            ignore_missing_v_net_service_endpoint = kwargs['ignoreMissingVNetServiceEndpoint']

        if id is not None:
            _setter("id", id)
        if ignore_missing_v_net_service_endpoint is not None:
            _setter("ignore_missing_v_net_service_endpoint", ignore_missing_v_net_service_endpoint)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID of a subnet, for example: /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="ignoreMissingVNetServiceEndpoint")
    def ignore_missing_v_net_service_endpoint(self) -> Optional[pulumi.Input[bool]]:
        """
        Create firewall rule before the virtual network has vnet service endpoint enabled.
        """
        return pulumi.get(self, "ignore_missing_v_net_service_endpoint")

    @ignore_missing_v_net_service_endpoint.setter
    def ignore_missing_v_net_service_endpoint(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_missing_v_net_service_endpoint", value)


