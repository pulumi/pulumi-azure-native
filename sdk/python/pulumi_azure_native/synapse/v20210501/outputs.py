# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AutoPausePropertiesResponse',
    'AutoScalePropertiesResponse',
    'CspWorkspaceAdminPropertiesResponse',
    'CustomerManagedKeyDetailsResponse',
    'DataLakeStorageAccountDetailsResponse',
    'DynamicExecutorAllocationResponse',
    'EncryptionDetailsResponse',
    'KekIdentityPropertiesResponse',
    'LibraryInfoResponse',
    'LibraryRequirementsResponse',
    'ManagedIdentityResponse',
    'ManagedVirtualNetworkSettingsResponse',
    'PrivateEndpointConnectionResponse',
    'PrivateEndpointResponse',
    'PrivateLinkServiceConnectionStateResponse',
    'PurviewConfigurationResponse',
    'SkuResponse',
    'UserAssignedManagedIdentityResponse',
    'VirtualNetworkProfileResponse',
    'WorkspaceKeyDetailsResponse',
    'WorkspaceRepositoryConfigurationResponse',
]

@pulumi.output_type
class AutoPausePropertiesResponse(dict):
    """
    Auto-pausing properties of a Big Data pool powered by Apache Spark
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayInMinutes":
            suggest = "delay_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoPausePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoPausePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoPausePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay_in_minutes: Optional[int] = None,
                 enabled: Optional[bool] = None):
        """
        Auto-pausing properties of a Big Data pool powered by Apache Spark
        :param int delay_in_minutes: Number of minutes of idle time before the Big Data pool is automatically paused.
        :param bool enabled: Whether auto-pausing is enabled for the Big Data pool.
        """
        if delay_in_minutes is not None:
            pulumi.set(__self__, "delay_in_minutes", delay_in_minutes)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="delayInMinutes")
    def delay_in_minutes(self) -> Optional[int]:
        """
        Number of minutes of idle time before the Big Data pool is automatically paused.
        """
        return pulumi.get(self, "delay_in_minutes")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether auto-pausing is enabled for the Big Data pool.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class AutoScalePropertiesResponse(dict):
    """
    Auto-scaling properties of a Big Data pool powered by Apache Spark
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxNodeCount":
            suggest = "max_node_count"
        elif key == "minNodeCount":
            suggest = "min_node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 max_node_count: Optional[int] = None,
                 min_node_count: Optional[int] = None):
        """
        Auto-scaling properties of a Big Data pool powered by Apache Spark
        :param bool enabled: Whether automatic scaling is enabled for the Big Data pool.
        :param int max_node_count: The maximum number of nodes the Big Data pool can support.
        :param int min_node_count: The minimum number of nodes the Big Data pool can support.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_node_count is not None:
            pulumi.set(__self__, "max_node_count", max_node_count)
        if min_node_count is not None:
            pulumi.set(__self__, "min_node_count", min_node_count)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether automatic scaling is enabled for the Big Data pool.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> Optional[int]:
        """
        The maximum number of nodes the Big Data pool can support.
        """
        return pulumi.get(self, "max_node_count")

    @property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> Optional[int]:
        """
        The minimum number of nodes the Big Data pool can support.
        """
        return pulumi.get(self, "min_node_count")


@pulumi.output_type
class CspWorkspaceAdminPropertiesResponse(dict):
    """
    Initial workspace AAD admin properties for a CSP subscription
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialWorkspaceAdminObjectId":
            suggest = "initial_workspace_admin_object_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CspWorkspaceAdminPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CspWorkspaceAdminPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CspWorkspaceAdminPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_workspace_admin_object_id: Optional[str] = None):
        """
        Initial workspace AAD admin properties for a CSP subscription
        :param str initial_workspace_admin_object_id: AAD object ID of initial workspace admin
        """
        if initial_workspace_admin_object_id is not None:
            pulumi.set(__self__, "initial_workspace_admin_object_id", initial_workspace_admin_object_id)

    @property
    @pulumi.getter(name="initialWorkspaceAdminObjectId")
    def initial_workspace_admin_object_id(self) -> Optional[str]:
        """
        AAD object ID of initial workspace admin
        """
        return pulumi.get(self, "initial_workspace_admin_object_id")


@pulumi.output_type
class CustomerManagedKeyDetailsResponse(dict):
    """
    Details of the customer managed key associated with the workspace
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kekIdentity":
            suggest = "kek_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomerManagedKeyDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomerManagedKeyDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomerManagedKeyDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: str,
                 kek_identity: Optional['outputs.KekIdentityPropertiesResponse'] = None,
                 key: Optional['outputs.WorkspaceKeyDetailsResponse'] = None):
        """
        Details of the customer managed key associated with the workspace
        :param str status: The customer managed key status on the workspace
        :param 'KekIdentityPropertiesResponse' kek_identity: Key encryption key
        :param 'WorkspaceKeyDetailsResponse' key: The key object of the workspace
        """
        pulumi.set(__self__, "status", status)
        if kek_identity is not None:
            pulumi.set(__self__, "kek_identity", kek_identity)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The customer managed key status on the workspace
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="kekIdentity")
    def kek_identity(self) -> Optional['outputs.KekIdentityPropertiesResponse']:
        """
        Key encryption key
        """
        return pulumi.get(self, "kek_identity")

    @property
    @pulumi.getter
    def key(self) -> Optional['outputs.WorkspaceKeyDetailsResponse']:
        """
        The key object of the workspace
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class DataLakeStorageAccountDetailsResponse(dict):
    """
    Details of the data lake storage account associated with the workspace
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountUrl":
            suggest = "account_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeStorageAccountDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeStorageAccountDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeStorageAccountDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_url: Optional[str] = None,
                 filesystem: Optional[str] = None):
        """
        Details of the data lake storage account associated with the workspace
        :param str account_url: Account URL
        :param str filesystem: Filesystem name
        """
        if account_url is not None:
            pulumi.set(__self__, "account_url", account_url)
        if filesystem is not None:
            pulumi.set(__self__, "filesystem", filesystem)

    @property
    @pulumi.getter(name="accountUrl")
    def account_url(self) -> Optional[str]:
        """
        Account URL
        """
        return pulumi.get(self, "account_url")

    @property
    @pulumi.getter
    def filesystem(self) -> Optional[str]:
        """
        Filesystem name
        """
        return pulumi.get(self, "filesystem")


@pulumi.output_type
class DynamicExecutorAllocationResponse(dict):
    """
    Dynamic Executor Allocation Properties
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        Dynamic Executor Allocation Properties
        :param bool enabled: Indicates whether Dynamic Executor Allocation is enabled or not.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Indicates whether Dynamic Executor Allocation is enabled or not.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class EncryptionDetailsResponse(dict):
    """
    Details of the encryption associated with the workspace
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleEncryptionEnabled":
            suggest = "double_encryption_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_encryption_enabled: bool,
                 cmk: Optional['outputs.CustomerManagedKeyDetailsResponse'] = None):
        """
        Details of the encryption associated with the workspace
        :param bool double_encryption_enabled: Double Encryption enabled
        :param 'CustomerManagedKeyDetailsResponse' cmk: Customer Managed Key Details
        """
        pulumi.set(__self__, "double_encryption_enabled", double_encryption_enabled)
        if cmk is not None:
            pulumi.set(__self__, "cmk", cmk)

    @property
    @pulumi.getter(name="doubleEncryptionEnabled")
    def double_encryption_enabled(self) -> bool:
        """
        Double Encryption enabled
        """
        return pulumi.get(self, "double_encryption_enabled")

    @property
    @pulumi.getter
    def cmk(self) -> Optional['outputs.CustomerManagedKeyDetailsResponse']:
        """
        Customer Managed Key Details
        """
        return pulumi.get(self, "cmk")


@pulumi.output_type
class KekIdentityPropertiesResponse(dict):
    """
    Key encryption key properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useSystemAssignedIdentity":
            suggest = "use_system_assigned_identity"
        elif key == "userAssignedIdentity":
            suggest = "user_assigned_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KekIdentityPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KekIdentityPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KekIdentityPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 use_system_assigned_identity: Optional[Any] = None,
                 user_assigned_identity: Optional[str] = None):
        """
        Key encryption key properties
        :param Any use_system_assigned_identity: Boolean specifying whether to use system assigned identity or not
        :param str user_assigned_identity: User assigned identity resource Id
        """
        if use_system_assigned_identity is not None:
            pulumi.set(__self__, "use_system_assigned_identity", use_system_assigned_identity)
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter(name="useSystemAssignedIdentity")
    def use_system_assigned_identity(self) -> Optional[Any]:
        """
        Boolean specifying whether to use system assigned identity or not
        """
        return pulumi.get(self, "use_system_assigned_identity")

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[str]:
        """
        User assigned identity resource Id
        """
        return pulumi.get(self, "user_assigned_identity")


@pulumi.output_type
class LibraryInfoResponse(dict):
    """
    Library/package information of a Big Data pool powered by Apache Spark
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "creatorId":
            suggest = "creator_id"
        elif key == "provisioningStatus":
            suggest = "provisioning_status"
        elif key == "uploadedTimestamp":
            suggest = "uploaded_timestamp"
        elif key == "containerName":
            suggest = "container_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LibraryInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LibraryInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LibraryInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 creator_id: str,
                 provisioning_status: str,
                 uploaded_timestamp: str,
                 container_name: Optional[str] = None,
                 name: Optional[str] = None,
                 path: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Library/package information of a Big Data pool powered by Apache Spark
        :param str creator_id: Creator Id of the library/package.
        :param str provisioning_status: Provisioning status of the library/package.
        :param str uploaded_timestamp: The last update time of the library.
        :param str container_name: Storage blob container name.
        :param str name: Name of the library.
        :param str path: Storage blob path of library.
        :param str type: Type of the library.
        """
        pulumi.set(__self__, "creator_id", creator_id)
        pulumi.set(__self__, "provisioning_status", provisioning_status)
        pulumi.set(__self__, "uploaded_timestamp", uploaded_timestamp)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="creatorId")
    def creator_id(self) -> str:
        """
        Creator Id of the library/package.
        """
        return pulumi.get(self, "creator_id")

    @property
    @pulumi.getter(name="provisioningStatus")
    def provisioning_status(self) -> str:
        """
        Provisioning status of the library/package.
        """
        return pulumi.get(self, "provisioning_status")

    @property
    @pulumi.getter(name="uploadedTimestamp")
    def uploaded_timestamp(self) -> str:
        """
        The last update time of the library.
        """
        return pulumi.get(self, "uploaded_timestamp")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        """
        Storage blob container name.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the library.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Storage blob path of library.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the library.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LibraryRequirementsResponse(dict):
    """
    Library requirements for a Big Data pool powered by Apache Spark
    """
    def __init__(__self__, *,
                 time: str,
                 content: Optional[str] = None,
                 filename: Optional[str] = None):
        """
        Library requirements for a Big Data pool powered by Apache Spark
        :param str time: The last update time of the library requirements file.
        :param str content: The library requirements.
        :param str filename: The filename of the library requirements file.
        """
        pulumi.set(__self__, "time", time)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def time(self) -> str:
        """
        The last update time of the library requirements file.
        """
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        The library requirements.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def filename(self) -> Optional[str]:
        """
        The filename of the library requirements file.
        """
        return pulumi.get(self, "filename")


@pulumi.output_type
class ManagedIdentityResponse(dict):
    """
    The workspace managed identity
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: Optional[str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedManagedIdentityResponse']] = None):
        """
        The workspace managed identity
        :param str principal_id: The principal ID of the workspace managed identity
        :param str tenant_id: The tenant ID of the workspace managed identity
        :param str type: The type of managed identity for the workspace
        :param Mapping[str, 'UserAssignedManagedIdentityResponse'] user_assigned_identities: The user assigned managed identities.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of the workspace managed identity
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of the workspace managed identity
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of managed identity for the workspace
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedManagedIdentityResponse']]:
        """
        The user assigned managed identities.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class ManagedVirtualNetworkSettingsResponse(dict):
    """
    Managed Virtual Network Settings
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedAadTenantIdsForLinking":
            suggest = "allowed_aad_tenant_ids_for_linking"
        elif key == "linkedAccessCheckOnTargetResource":
            suggest = "linked_access_check_on_target_resource"
        elif key == "preventDataExfiltration":
            suggest = "prevent_data_exfiltration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedVirtualNetworkSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedVirtualNetworkSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedVirtualNetworkSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_aad_tenant_ids_for_linking: Optional[Sequence[str]] = None,
                 linked_access_check_on_target_resource: Optional[bool] = None,
                 prevent_data_exfiltration: Optional[bool] = None):
        """
        Managed Virtual Network Settings
        :param Sequence[str] allowed_aad_tenant_ids_for_linking: Allowed Aad Tenant Ids For Linking
        :param bool linked_access_check_on_target_resource: Linked Access Check On Target Resource
        :param bool prevent_data_exfiltration: Prevent Data Exfiltration
        """
        if allowed_aad_tenant_ids_for_linking is not None:
            pulumi.set(__self__, "allowed_aad_tenant_ids_for_linking", allowed_aad_tenant_ids_for_linking)
        if linked_access_check_on_target_resource is not None:
            pulumi.set(__self__, "linked_access_check_on_target_resource", linked_access_check_on_target_resource)
        if prevent_data_exfiltration is not None:
            pulumi.set(__self__, "prevent_data_exfiltration", prevent_data_exfiltration)

    @property
    @pulumi.getter(name="allowedAadTenantIdsForLinking")
    def allowed_aad_tenant_ids_for_linking(self) -> Optional[Sequence[str]]:
        """
        Allowed Aad Tenant Ids For Linking
        """
        return pulumi.get(self, "allowed_aad_tenant_ids_for_linking")

    @property
    @pulumi.getter(name="linkedAccessCheckOnTargetResource")
    def linked_access_check_on_target_resource(self) -> Optional[bool]:
        """
        Linked Access Check On Target Resource
        """
        return pulumi.get(self, "linked_access_check_on_target_resource")

    @property
    @pulumi.getter(name="preventDataExfiltration")
    def prevent_data_exfiltration(self) -> Optional[bool]:
        """
        Prevent Data Exfiltration
        """
        return pulumi.get(self, "prevent_data_exfiltration")


@pulumi.output_type
class PrivateEndpointConnectionResponse(dict):
    """
    A private endpoint connection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"
        elif key == "privateLinkServiceConnectionState":
            suggest = "private_link_service_connection_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 name: str,
                 provisioning_state: str,
                 type: str,
                 private_endpoint: Optional['outputs.PrivateEndpointResponse'] = None,
                 private_link_service_connection_state: Optional['outputs.PrivateLinkServiceConnectionStateResponse'] = None):
        """
        A private endpoint connection
        :param str id: Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        :param str name: The name of the resource
        :param str provisioning_state: Provisioning state of the private endpoint connection.
        :param str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param 'PrivateEndpointResponse' private_endpoint: The private endpoint which the connection belongs to.
        :param 'PrivateLinkServiceConnectionStateResponse' private_link_service_connection_state: Connection state of the private endpoint connection.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "type", type)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if private_link_service_connection_state is not None:
            pulumi.set(__self__, "private_link_service_connection_state", private_link_service_connection_state)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning state of the private endpoint connection.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.PrivateEndpointResponse']:
        """
        The private endpoint which the connection belongs to.
        """
        return pulumi.get(self, "private_endpoint")

    @property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> Optional['outputs.PrivateLinkServiceConnectionStateResponse']:
        """
        Connection state of the private endpoint connection.
        """
        return pulumi.get(self, "private_link_service_connection_state")


@pulumi.output_type
class PrivateEndpointResponse(dict):
    """
    Private endpoint details
    """
    def __init__(__self__, *,
                 id: str):
        """
        Private endpoint details
        :param str id: Resource id of the private endpoint.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Resource id of the private endpoint.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrivateLinkServiceConnectionStateResponse(dict):
    """
    Connection state details of the private endpoint
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsRequired":
            suggest = "actions_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkServiceConnectionStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_required: str,
                 description: Optional[str] = None,
                 status: Optional[str] = None):
        """
        Connection state details of the private endpoint
        :param str actions_required: The actions required for private link service connection.
        :param str description: The private link service connection description.
        :param str status: The private link service connection status.
        """
        pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> str:
        """
        The actions required for private link service connection.
        """
        return pulumi.get(self, "actions_required")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The private link service connection description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The private link service connection status.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class PurviewConfigurationResponse(dict):
    """
    Purview Configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "purviewResourceId":
            suggest = "purview_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PurviewConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PurviewConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PurviewConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 purview_resource_id: Optional[str] = None):
        """
        Purview Configuration
        :param str purview_resource_id: Purview Resource ID
        """
        if purview_resource_id is not None:
            pulumi.set(__self__, "purview_resource_id", purview_resource_id)

    @property
    @pulumi.getter(name="purviewResourceId")
    def purview_resource_id(self) -> Optional[str]:
        """
        Purview Resource ID
        """
        return pulumi.get(self, "purview_resource_id")


@pulumi.output_type
class SkuResponse(dict):
    """
    SQL pool SKU
    """
    def __init__(__self__, *,
                 capacity: Optional[int] = None,
                 name: Optional[str] = None,
                 tier: Optional[str] = None):
        """
        SQL pool SKU
        :param int capacity: If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        :param str name: The SKU name
        :param str tier: The service tier
        """
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[int]:
        """
        If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The SKU name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        """
        The service tier
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class UserAssignedManagedIdentityResponse(dict):
    """
    User Assigned Managed Identity
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedManagedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedManagedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedManagedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str):
        """
        User Assigned Managed Identity
        :param str client_id: The client ID.
        :param str principal_id: The principal ID.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class VirtualNetworkProfileResponse(dict):
    """
    Virtual Network Profile
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeSubnetId":
            suggest = "compute_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_subnet_id: Optional[str] = None):
        """
        Virtual Network Profile
        :param str compute_subnet_id: Subnet ID used for computes in workspace
        """
        if compute_subnet_id is not None:
            pulumi.set(__self__, "compute_subnet_id", compute_subnet_id)

    @property
    @pulumi.getter(name="computeSubnetId")
    def compute_subnet_id(self) -> Optional[str]:
        """
        Subnet ID used for computes in workspace
        """
        return pulumi.get(self, "compute_subnet_id")


@pulumi.output_type
class WorkspaceKeyDetailsResponse(dict):
    """
    Details of the customer managed key associated with the workspace
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultUrl":
            suggest = "key_vault_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceKeyDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceKeyDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceKeyDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_url: Optional[str] = None,
                 name: Optional[str] = None):
        """
        Details of the customer managed key associated with the workspace
        :param str key_vault_url: Workspace Key sub-resource key vault url
        :param str name: Workspace Key sub-resource name
        """
        if key_vault_url is not None:
            pulumi.set(__self__, "key_vault_url", key_vault_url)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="keyVaultUrl")
    def key_vault_url(self) -> Optional[str]:
        """
        Workspace Key sub-resource key vault url
        """
        return pulumi.get(self, "key_vault_url")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Workspace Key sub-resource name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkspaceRepositoryConfigurationResponse(dict):
    """
    Git integration settings
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountName":
            suggest = "account_name"
        elif key == "collaborationBranch":
            suggest = "collaboration_branch"
        elif key == "hostName":
            suggest = "host_name"
        elif key == "lastCommitId":
            suggest = "last_commit_id"
        elif key == "projectName":
            suggest = "project_name"
        elif key == "repositoryName":
            suggest = "repository_name"
        elif key == "rootFolder":
            suggest = "root_folder"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceRepositoryConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceRepositoryConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceRepositoryConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_name: Optional[str] = None,
                 collaboration_branch: Optional[str] = None,
                 host_name: Optional[str] = None,
                 last_commit_id: Optional[str] = None,
                 project_name: Optional[str] = None,
                 repository_name: Optional[str] = None,
                 root_folder: Optional[str] = None,
                 tenant_id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Git integration settings
        :param str account_name: Account name
        :param str collaboration_branch: Collaboration branch
        :param str host_name: GitHub Enterprise host name. For example: https://github.mydomain.com
        :param str last_commit_id: The last commit ID
        :param str project_name: VSTS project name
        :param str repository_name: Repository name
        :param str root_folder: Root folder to use in the repository
        :param str tenant_id: The VSTS tenant ID
        :param str type: Type of workspace repositoryID configuration. Example WorkspaceVSTSConfiguration, WorkspaceGitHubConfiguration
        """
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if collaboration_branch is not None:
            pulumi.set(__self__, "collaboration_branch", collaboration_branch)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if project_name is not None:
            pulumi.set(__self__, "project_name", project_name)
        if repository_name is not None:
            pulumi.set(__self__, "repository_name", repository_name)
        if root_folder is not None:
            pulumi.set(__self__, "root_folder", root_folder)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[str]:
        """
        Account name
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="collaborationBranch")
    def collaboration_branch(self) -> Optional[str]:
        """
        Collaboration branch
        """
        return pulumi.get(self, "collaboration_branch")

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[str]:
        """
        GitHub Enterprise host name. For example: https://github.mydomain.com
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[str]:
        """
        The last commit ID
        """
        return pulumi.get(self, "last_commit_id")

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> Optional[str]:
        """
        VSTS project name
        """
        return pulumi.get(self, "project_name")

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> Optional[str]:
        """
        Repository name
        """
        return pulumi.get(self, "repository_name")

    @property
    @pulumi.getter(name="rootFolder")
    def root_folder(self) -> Optional[str]:
        """
        Root folder to use in the repository
        """
        return pulumi.get(self, "root_folder")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The VSTS tenant ID
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of workspace repositoryID configuration. Example WorkspaceVSTSConfiguration, WorkspaceGitHubConfiguration
        """
        return pulumi.get(self, "type")


