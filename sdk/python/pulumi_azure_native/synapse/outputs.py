# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AutoPausePropertiesResponse',
    'AutoScalePropertiesResponse',
    'AzureSkuResponse',
    'CmdkeySetupResponse',
    'ComponentSetupResponse',
    'CspWorkspaceAdminPropertiesResponse',
    'CustomerManagedKeyDetailsResponse',
    'DataLakeStorageAccountDetailsResponse',
    'DatabaseStatisticsResponse',
    'DynamicExecutorAllocationResponse',
    'EncryptionDetailsResponse',
    'EntityReferenceResponse',
    'EnvironmentVariableSetupResponse',
    'FollowerDatabaseDefinitionResponse',
    'IntegrationRuntimeComputePropertiesResponse',
    'IntegrationRuntimeCustomSetupScriptPropertiesResponse',
    'IntegrationRuntimeCustomerVirtualNetworkResponse',
    'IntegrationRuntimeDataFlowPropertiesResponse',
    'IntegrationRuntimeDataProxyPropertiesResponse',
    'IntegrationRuntimeSsisCatalogInfoResponse',
    'IntegrationRuntimeSsisPropertiesResponse',
    'IntegrationRuntimeVNetPropertiesResponse',
    'KekIdentityPropertiesResponse',
    'LanguageExtensionResponse',
    'LanguageExtensionsListResponse',
    'LibraryInfoResponse',
    'LibraryRequirementsResponse',
    'LinkedIntegrationRuntimeKeyAuthorizationResponse',
    'LinkedIntegrationRuntimeRbacAuthorizationResponse',
    'LinkedIntegrationRuntimeResponse',
    'ManagedIdentityResponse',
    'ManagedIntegrationRuntimeErrorResponse',
    'ManagedIntegrationRuntimeNodeResponse',
    'ManagedIntegrationRuntimeOperationResultResponse',
    'ManagedIntegrationRuntimeResponse',
    'ManagedIntegrationRuntimeStatusResponse',
    'ManagedVirtualNetworkSettingsResponse',
    'OptimizedAutoscaleResponse',
    'PrivateEndpointConnectionForPrivateLinkHubBasicResponse',
    'PrivateEndpointConnectionResponse',
    'PrivateEndpointResponse',
    'PrivateLinkServiceConnectionStateResponse',
    'PurviewConfigurationResponse',
    'SecureStringResponse',
    'SelfHostedIntegrationRuntimeNodeResponse',
    'SelfHostedIntegrationRuntimeResponse',
    'SelfHostedIntegrationRuntimeStatusResponse',
    'SkuResponse',
    'SparkConfigPropertiesResponse',
    'SqlPoolVulnerabilityAssessmentRuleBaselineItemResponse',
    'SsisEnvironmentReferenceResponse',
    'SsisEnvironmentResponse',
    'SsisFolderResponse',
    'SsisPackageResponse',
    'SsisParameterResponse',
    'SsisProjectResponse',
    'SsisVariableResponse',
    'SystemDataResponse',
    'TableLevelSharingPropertiesResponse',
    'UserAssignedManagedIdentityResponse',
    'VirtualNetworkProfileResponse',
    'VulnerabilityAssessmentRecurringScansPropertiesResponse',
    'WorkspaceKeyDetailsResponse',
    'WorkspaceRepositoryConfigurationResponse',
]

@pulumi.output_type
class AutoPausePropertiesResponse(dict):
    """
    Auto-pausing properties of a Big Data pool powered by Apache Spark
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayInMinutes":
            suggest = "delay_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoPausePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoPausePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoPausePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay_in_minutes: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        Auto-pausing properties of a Big Data pool powered by Apache Spark
        :param _builtins.int delay_in_minutes: Number of minutes of idle time before the Big Data pool is automatically paused.
        :param _builtins.bool enabled: Whether auto-pausing is enabled for the Big Data pool.
        """
        if delay_in_minutes is not None:
            pulumi.set(__self__, "delay_in_minutes", delay_in_minutes)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="delayInMinutes")
    def delay_in_minutes(self) -> Optional[_builtins.int]:
        """
        Number of minutes of idle time before the Big Data pool is automatically paused.
        """
        return pulumi.get(self, "delay_in_minutes")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether auto-pausing is enabled for the Big Data pool.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class AutoScalePropertiesResponse(dict):
    """
    Auto-scaling properties of a Big Data pool powered by Apache Spark
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxNodeCount":
            suggest = "max_node_count"
        elif key == "minNodeCount":
            suggest = "min_node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 max_node_count: Optional[_builtins.int] = None,
                 min_node_count: Optional[_builtins.int] = None):
        """
        Auto-scaling properties of a Big Data pool powered by Apache Spark
        :param _builtins.bool enabled: Whether automatic scaling is enabled for the Big Data pool.
        :param _builtins.int max_node_count: The maximum number of nodes the Big Data pool can support.
        :param _builtins.int min_node_count: The minimum number of nodes the Big Data pool can support.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_node_count is not None:
            pulumi.set(__self__, "max_node_count", max_node_count)
        if min_node_count is not None:
            pulumi.set(__self__, "min_node_count", min_node_count)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether automatic scaling is enabled for the Big Data pool.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> Optional[_builtins.int]:
        """
        The maximum number of nodes the Big Data pool can support.
        """
        return pulumi.get(self, "max_node_count")

    @_builtins.property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> Optional[_builtins.int]:
        """
        The minimum number of nodes the Big Data pool can support.
        """
        return pulumi.get(self, "min_node_count")


@pulumi.output_type
class AzureSkuResponse(dict):
    """
    Azure SKU definition.
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 size: _builtins.str,
                 capacity: Optional[_builtins.int] = None):
        """
        Azure SKU definition.
        :param _builtins.str name: SKU name.
        :param _builtins.str size: SKU size.
        :param _builtins.int capacity: The number of instances of the cluster.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        SKU name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        SKU size.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> Optional[_builtins.int]:
        """
        The number of instances of the cluster.
        """
        return pulumi.get(self, "capacity")


@pulumi.output_type
class CmdkeySetupResponse(dict):
    """
    The custom setup of running cmdkey commands.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetName":
            suggest = "target_name"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CmdkeySetupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CmdkeySetupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CmdkeySetupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: 'outputs.SecureStringResponse',
                 target_name: Any,
                 type: _builtins.str,
                 user_name: Any):
        """
        The custom setup of running cmdkey commands.
        :param 'SecureStringResponse' password: The password of data source access.
        :param Any target_name: The server name of data source access.
        :param _builtins.str type: The type of custom setup.
               Expected value is 'CmdkeySetup'.
        :param Any user_name: The user name of data source access.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "target_name", target_name)
        pulumi.set(__self__, "type", 'CmdkeySetup')
        pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter
    def password(self) -> 'outputs.SecureStringResponse':
        """
        The password of data source access.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="targetName")
    def target_name(self) -> Any:
        """
        The server name of data source access.
        """
        return pulumi.get(self, "target_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of custom setup.
        Expected value is 'CmdkeySetup'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Any:
        """
        The user name of data source access.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class ComponentSetupResponse(dict):
    """
    The custom setup of installing 3rd party components.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "componentName":
            suggest = "component_name"
        elif key == "licenseKey":
            suggest = "license_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComponentSetupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComponentSetupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComponentSetupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component_name: _builtins.str,
                 type: _builtins.str,
                 license_key: Optional['outputs.SecureStringResponse'] = None):
        """
        The custom setup of installing 3rd party components.
        :param _builtins.str component_name: The name of the 3rd party component.
        :param _builtins.str type: The type of custom setup.
               Expected value is 'ComponentSetup'.
        :param 'SecureStringResponse' license_key: The license key to activate the component.
        """
        pulumi.set(__self__, "component_name", component_name)
        pulumi.set(__self__, "type", 'ComponentSetup')
        if license_key is not None:
            pulumi.set(__self__, "license_key", license_key)

    @_builtins.property
    @pulumi.getter(name="componentName")
    def component_name(self) -> _builtins.str:
        """
        The name of the 3rd party component.
        """
        return pulumi.get(self, "component_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of custom setup.
        Expected value is 'ComponentSetup'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="licenseKey")
    def license_key(self) -> Optional['outputs.SecureStringResponse']:
        """
        The license key to activate the component.
        """
        return pulumi.get(self, "license_key")


@pulumi.output_type
class CspWorkspaceAdminPropertiesResponse(dict):
    """
    Initial workspace AAD admin properties for a CSP subscription
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialWorkspaceAdminObjectId":
            suggest = "initial_workspace_admin_object_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CspWorkspaceAdminPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CspWorkspaceAdminPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CspWorkspaceAdminPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_workspace_admin_object_id: Optional[_builtins.str] = None):
        """
        Initial workspace AAD admin properties for a CSP subscription
        :param _builtins.str initial_workspace_admin_object_id: AAD object ID of initial workspace admin
        """
        if initial_workspace_admin_object_id is not None:
            pulumi.set(__self__, "initial_workspace_admin_object_id", initial_workspace_admin_object_id)

    @_builtins.property
    @pulumi.getter(name="initialWorkspaceAdminObjectId")
    def initial_workspace_admin_object_id(self) -> Optional[_builtins.str]:
        """
        AAD object ID of initial workspace admin
        """
        return pulumi.get(self, "initial_workspace_admin_object_id")


@pulumi.output_type
class CustomerManagedKeyDetailsResponse(dict):
    """
    Details of the customer managed key associated with the workspace
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kekIdentity":
            suggest = "kek_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomerManagedKeyDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomerManagedKeyDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomerManagedKeyDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: _builtins.str,
                 kek_identity: Optional['outputs.KekIdentityPropertiesResponse'] = None,
                 key: Optional['outputs.WorkspaceKeyDetailsResponse'] = None):
        """
        Details of the customer managed key associated with the workspace
        :param _builtins.str status: The customer managed key status on the workspace
        :param 'KekIdentityPropertiesResponse' kek_identity: Key encryption key
        :param 'WorkspaceKeyDetailsResponse' key: The key object of the workspace
        """
        pulumi.set(__self__, "status", status)
        if kek_identity is not None:
            pulumi.set(__self__, "kek_identity", kek_identity)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The customer managed key status on the workspace
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="kekIdentity")
    def kek_identity(self) -> Optional['outputs.KekIdentityPropertiesResponse']:
        """
        Key encryption key
        """
        return pulumi.get(self, "kek_identity")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional['outputs.WorkspaceKeyDetailsResponse']:
        """
        The key object of the workspace
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class DataLakeStorageAccountDetailsResponse(dict):
    """
    Details of the data lake storage account associated with the workspace
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountUrl":
            suggest = "account_url"
        elif key == "createManagedPrivateEndpoint":
            suggest = "create_managed_private_endpoint"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeStorageAccountDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeStorageAccountDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeStorageAccountDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_url: Optional[_builtins.str] = None,
                 create_managed_private_endpoint: Optional[_builtins.bool] = None,
                 filesystem: Optional[_builtins.str] = None,
                 resource_id: Optional[_builtins.str] = None):
        """
        Details of the data lake storage account associated with the workspace
        :param _builtins.str account_url: Account URL
        :param _builtins.bool create_managed_private_endpoint: Create managed private endpoint to this storage account or not
        :param _builtins.str filesystem: Filesystem name
        :param _builtins.str resource_id: ARM resource Id of this storage account
        """
        if account_url is not None:
            pulumi.set(__self__, "account_url", account_url)
        if create_managed_private_endpoint is not None:
            pulumi.set(__self__, "create_managed_private_endpoint", create_managed_private_endpoint)
        if filesystem is not None:
            pulumi.set(__self__, "filesystem", filesystem)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @_builtins.property
    @pulumi.getter(name="accountUrl")
    def account_url(self) -> Optional[_builtins.str]:
        """
        Account URL
        """
        return pulumi.get(self, "account_url")

    @_builtins.property
    @pulumi.getter(name="createManagedPrivateEndpoint")
    def create_managed_private_endpoint(self) -> Optional[_builtins.bool]:
        """
        Create managed private endpoint to this storage account or not
        """
        return pulumi.get(self, "create_managed_private_endpoint")

    @_builtins.property
    @pulumi.getter
    def filesystem(self) -> Optional[_builtins.str]:
        """
        Filesystem name
        """
        return pulumi.get(self, "filesystem")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[_builtins.str]:
        """
        ARM resource Id of this storage account
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class DatabaseStatisticsResponse(dict):
    """
    A class that contains database statistics information.
    """
    def __init__(__self__, *,
                 size: Optional[_builtins.float] = None):
        """
        A class that contains database statistics information.
        :param _builtins.float size: The database size - the total size of compressed data and index in bytes.
        """
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.float]:
        """
        The database size - the total size of compressed data and index in bytes.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class DynamicExecutorAllocationResponse(dict):
    """
    Dynamic Executor Allocation Properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxExecutors":
            suggest = "max_executors"
        elif key == "minExecutors":
            suggest = "min_executors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DynamicExecutorAllocationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DynamicExecutorAllocationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DynamicExecutorAllocationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 max_executors: Optional[_builtins.int] = None,
                 min_executors: Optional[_builtins.int] = None):
        """
        Dynamic Executor Allocation Properties
        :param _builtins.bool enabled: Indicates whether Dynamic Executor Allocation is enabled or not.
        :param _builtins.int max_executors: The maximum number of executors alloted
        :param _builtins.int min_executors: The minimum number of executors alloted
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_executors is not None:
            pulumi.set(__self__, "max_executors", max_executors)
        if min_executors is not None:
            pulumi.set(__self__, "min_executors", min_executors)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether Dynamic Executor Allocation is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxExecutors")
    def max_executors(self) -> Optional[_builtins.int]:
        """
        The maximum number of executors alloted
        """
        return pulumi.get(self, "max_executors")

    @_builtins.property
    @pulumi.getter(name="minExecutors")
    def min_executors(self) -> Optional[_builtins.int]:
        """
        The minimum number of executors alloted
        """
        return pulumi.get(self, "min_executors")


@pulumi.output_type
class EncryptionDetailsResponse(dict):
    """
    Details of the encryption associated with the workspace
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleEncryptionEnabled":
            suggest = "double_encryption_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_encryption_enabled: _builtins.bool,
                 cmk: Optional['outputs.CustomerManagedKeyDetailsResponse'] = None):
        """
        Details of the encryption associated with the workspace
        :param _builtins.bool double_encryption_enabled: Double Encryption enabled
        :param 'CustomerManagedKeyDetailsResponse' cmk: Customer Managed Key Details
        """
        pulumi.set(__self__, "double_encryption_enabled", double_encryption_enabled)
        if cmk is not None:
            pulumi.set(__self__, "cmk", cmk)

    @_builtins.property
    @pulumi.getter(name="doubleEncryptionEnabled")
    def double_encryption_enabled(self) -> _builtins.bool:
        """
        Double Encryption enabled
        """
        return pulumi.get(self, "double_encryption_enabled")

    @_builtins.property
    @pulumi.getter
    def cmk(self) -> Optional['outputs.CustomerManagedKeyDetailsResponse']:
        """
        Customer Managed Key Details
        """
        return pulumi.get(self, "cmk")


@pulumi.output_type
class EntityReferenceResponse(dict):
    """
    The entity reference.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referenceName":
            suggest = "reference_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EntityReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EntityReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EntityReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reference_name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        The entity reference.
        :param _builtins.str reference_name: The name of this referenced entity.
        :param _builtins.str type: The type of this referenced entity.
        """
        if reference_name is not None:
            pulumi.set(__self__, "reference_name", reference_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> Optional[_builtins.str]:
        """
        The name of this referenced entity.
        """
        return pulumi.get(self, "reference_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of this referenced entity.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EnvironmentVariableSetupResponse(dict):
    """
    The custom setup of setting environment variable.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "variableName":
            suggest = "variable_name"
        elif key == "variableValue":
            suggest = "variable_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentVariableSetupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentVariableSetupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentVariableSetupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 variable_name: _builtins.str,
                 variable_value: _builtins.str):
        """
        The custom setup of setting environment variable.
        :param _builtins.str type: The type of custom setup.
               Expected value is 'EnvironmentVariableSetup'.
        :param _builtins.str variable_name: The name of the environment variable.
        :param _builtins.str variable_value: The value of the environment variable.
        """
        pulumi.set(__self__, "type", 'EnvironmentVariableSetup')
        pulumi.set(__self__, "variable_name", variable_name)
        pulumi.set(__self__, "variable_value", variable_value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of custom setup.
        Expected value is 'EnvironmentVariableSetup'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="variableName")
    def variable_name(self) -> _builtins.str:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "variable_name")

    @_builtins.property
    @pulumi.getter(name="variableValue")
    def variable_value(self) -> _builtins.str:
        """
        The value of the environment variable.
        """
        return pulumi.get(self, "variable_value")


@pulumi.output_type
class FollowerDatabaseDefinitionResponse(dict):
    """
    A class representing follower database request.
    """
    def __init__(__self__, *,
                 attached_database_configuration_name: _builtins.str,
                 database_name: _builtins.str,
                 kusto_pool_resource_id: _builtins.str):
        """
        A class representing follower database request.
        :param _builtins.str attached_database_configuration_name: Resource name of the attached database configuration in the follower cluster.
        :param _builtins.str database_name: The database name owned by this cluster that was followed. * in case following all databases.
        :param _builtins.str kusto_pool_resource_id: Resource id of the cluster that follows a database owned by this cluster.
        """
        pulumi.set(__self__, "attached_database_configuration_name", attached_database_configuration_name)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "kusto_pool_resource_id", kusto_pool_resource_id)

    @_builtins.property
    @pulumi.getter(name="attachedDatabaseConfigurationName")
    def attached_database_configuration_name(self) -> _builtins.str:
        """
        Resource name of the attached database configuration in the follower cluster.
        """
        return pulumi.get(self, "attached_database_configuration_name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        The database name owned by this cluster that was followed. * in case following all databases.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="kustoPoolResourceId")
    def kusto_pool_resource_id(self) -> _builtins.str:
        """
        Resource id of the cluster that follows a database owned by this cluster.
        """
        return pulumi.get(self, "kusto_pool_resource_id")


@pulumi.output_type
class IntegrationRuntimeComputePropertiesResponse(dict):
    """
    The compute resource properties for managed integration runtime.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataFlowProperties":
            suggest = "data_flow_properties"
        elif key == "maxParallelExecutionsPerNode":
            suggest = "max_parallel_executions_per_node"
        elif key == "nodeSize":
            suggest = "node_size"
        elif key == "numberOfNodes":
            suggest = "number_of_nodes"
        elif key == "vNetProperties":
            suggest = "v_net_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeComputePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeComputePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeComputePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_flow_properties: Optional['outputs.IntegrationRuntimeDataFlowPropertiesResponse'] = None,
                 location: Optional[_builtins.str] = None,
                 max_parallel_executions_per_node: Optional[_builtins.int] = None,
                 node_size: Optional[_builtins.str] = None,
                 number_of_nodes: Optional[_builtins.int] = None,
                 v_net_properties: Optional['outputs.IntegrationRuntimeVNetPropertiesResponse'] = None):
        """
        The compute resource properties for managed integration runtime.
        :param 'IntegrationRuntimeDataFlowPropertiesResponse' data_flow_properties: Data flow properties for managed integration runtime.
        :param _builtins.str location: The location for managed integration runtime. The supported regions could be found on https://docs.microsoft.com/en-us/azure/data-factory/data-factory-data-movement-activities
        :param _builtins.int max_parallel_executions_per_node: Maximum parallel executions count per node for managed integration runtime.
        :param _builtins.str node_size: The node size requirement to managed integration runtime.
        :param _builtins.int number_of_nodes: The required number of nodes for managed integration runtime.
        :param 'IntegrationRuntimeVNetPropertiesResponse' v_net_properties: VNet properties for managed integration runtime.
        """
        if data_flow_properties is not None:
            pulumi.set(__self__, "data_flow_properties", data_flow_properties)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if max_parallel_executions_per_node is not None:
            pulumi.set(__self__, "max_parallel_executions_per_node", max_parallel_executions_per_node)
        if node_size is not None:
            pulumi.set(__self__, "node_size", node_size)
        if number_of_nodes is not None:
            pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        if v_net_properties is not None:
            pulumi.set(__self__, "v_net_properties", v_net_properties)

    @_builtins.property
    @pulumi.getter(name="dataFlowProperties")
    def data_flow_properties(self) -> Optional['outputs.IntegrationRuntimeDataFlowPropertiesResponse']:
        """
        Data flow properties for managed integration runtime.
        """
        return pulumi.get(self, "data_flow_properties")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        The location for managed integration runtime. The supported regions could be found on https://docs.microsoft.com/en-us/azure/data-factory/data-factory-data-movement-activities
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="maxParallelExecutionsPerNode")
    def max_parallel_executions_per_node(self) -> Optional[_builtins.int]:
        """
        Maximum parallel executions count per node for managed integration runtime.
        """
        return pulumi.get(self, "max_parallel_executions_per_node")

    @_builtins.property
    @pulumi.getter(name="nodeSize")
    def node_size(self) -> Optional[_builtins.str]:
        """
        The node size requirement to managed integration runtime.
        """
        return pulumi.get(self, "node_size")

    @_builtins.property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> Optional[_builtins.int]:
        """
        The required number of nodes for managed integration runtime.
        """
        return pulumi.get(self, "number_of_nodes")

    @_builtins.property
    @pulumi.getter(name="vNetProperties")
    def v_net_properties(self) -> Optional['outputs.IntegrationRuntimeVNetPropertiesResponse']:
        """
        VNet properties for managed integration runtime.
        """
        return pulumi.get(self, "v_net_properties")


@pulumi.output_type
class IntegrationRuntimeCustomSetupScriptPropertiesResponse(dict):
    """
    Custom setup script properties for a managed dedicated integration runtime.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blobContainerUri":
            suggest = "blob_container_uri"
        elif key == "sasToken":
            suggest = "sas_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeCustomSetupScriptPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeCustomSetupScriptPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeCustomSetupScriptPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blob_container_uri: Optional[_builtins.str] = None,
                 sas_token: Optional['outputs.SecureStringResponse'] = None):
        """
        Custom setup script properties for a managed dedicated integration runtime.
        :param _builtins.str blob_container_uri: The URI of the Azure blob container that contains the custom setup script.
        :param 'SecureStringResponse' sas_token: The SAS token of the Azure blob container.
        """
        if blob_container_uri is not None:
            pulumi.set(__self__, "blob_container_uri", blob_container_uri)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)

    @_builtins.property
    @pulumi.getter(name="blobContainerUri")
    def blob_container_uri(self) -> Optional[_builtins.str]:
        """
        The URI of the Azure blob container that contains the custom setup script.
        """
        return pulumi.get(self, "blob_container_uri")

    @_builtins.property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional['outputs.SecureStringResponse']:
        """
        The SAS token of the Azure blob container.
        """
        return pulumi.get(self, "sas_token")


@pulumi.output_type
class IntegrationRuntimeCustomerVirtualNetworkResponse(dict):
    """
    The definition and properties of virtual network to which Azure-SSIS integration runtime will join.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeCustomerVirtualNetworkResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeCustomerVirtualNetworkResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeCustomerVirtualNetworkResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: Optional[_builtins.str] = None):
        """
        The definition and properties of virtual network to which Azure-SSIS integration runtime will join.
        :param _builtins.str subnet_id: The ID of subnet to which Azure-SSIS integration runtime will join.
        """
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of subnet to which Azure-SSIS integration runtime will join.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class IntegrationRuntimeDataFlowPropertiesResponse(dict):
    """
    Data flow properties for managed integration runtime.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeType":
            suggest = "compute_type"
        elif key == "coreCount":
            suggest = "core_count"
        elif key == "timeToLive":
            suggest = "time_to_live"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeDataFlowPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeDataFlowPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeDataFlowPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_type: Optional[_builtins.str] = None,
                 core_count: Optional[_builtins.int] = None,
                 time_to_live: Optional[_builtins.int] = None):
        """
        Data flow properties for managed integration runtime.
        :param _builtins.str compute_type: Compute type of the cluster which will execute data flow job.
        :param _builtins.int core_count: Core count of the cluster which will execute data flow job. Supported values are: 8, 16, 32, 48, 80, 144 and 272.
        :param _builtins.int time_to_live: Time to live (in minutes) setting of the cluster which will execute data flow job.
        """
        if compute_type is not None:
            pulumi.set(__self__, "compute_type", compute_type)
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if time_to_live is not None:
            pulumi.set(__self__, "time_to_live", time_to_live)

    @_builtins.property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> Optional[_builtins.str]:
        """
        Compute type of the cluster which will execute data flow job.
        """
        return pulumi.get(self, "compute_type")

    @_builtins.property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[_builtins.int]:
        """
        Core count of the cluster which will execute data flow job. Supported values are: 8, 16, 32, 48, 80, 144 and 272.
        """
        return pulumi.get(self, "core_count")

    @_builtins.property
    @pulumi.getter(name="timeToLive")
    def time_to_live(self) -> Optional[_builtins.int]:
        """
        Time to live (in minutes) setting of the cluster which will execute data flow job.
        """
        return pulumi.get(self, "time_to_live")


@pulumi.output_type
class IntegrationRuntimeDataProxyPropertiesResponse(dict):
    """
    Data proxy properties for a managed dedicated integration runtime.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectVia":
            suggest = "connect_via"
        elif key == "stagingLinkedService":
            suggest = "staging_linked_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeDataProxyPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeDataProxyPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeDataProxyPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connect_via: Optional['outputs.EntityReferenceResponse'] = None,
                 path: Optional[_builtins.str] = None,
                 staging_linked_service: Optional['outputs.EntityReferenceResponse'] = None):
        """
        Data proxy properties for a managed dedicated integration runtime.
        :param 'EntityReferenceResponse' connect_via: The self-hosted integration runtime reference.
        :param _builtins.str path: The path to contain the staged data in the Blob storage.
        :param 'EntityReferenceResponse' staging_linked_service: The staging linked service reference.
        """
        if connect_via is not None:
            pulumi.set(__self__, "connect_via", connect_via)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if staging_linked_service is not None:
            pulumi.set(__self__, "staging_linked_service", staging_linked_service)

    @_builtins.property
    @pulumi.getter(name="connectVia")
    def connect_via(self) -> Optional['outputs.EntityReferenceResponse']:
        """
        The self-hosted integration runtime reference.
        """
        return pulumi.get(self, "connect_via")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        The path to contain the staged data in the Blob storage.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="stagingLinkedService")
    def staging_linked_service(self) -> Optional['outputs.EntityReferenceResponse']:
        """
        The staging linked service reference.
        """
        return pulumi.get(self, "staging_linked_service")


@pulumi.output_type
class IntegrationRuntimeSsisCatalogInfoResponse(dict):
    """
    Catalog information for managed dedicated integration runtime.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogAdminPassword":
            suggest = "catalog_admin_password"
        elif key == "catalogAdminUserName":
            suggest = "catalog_admin_user_name"
        elif key == "catalogPricingTier":
            suggest = "catalog_pricing_tier"
        elif key == "catalogServerEndpoint":
            suggest = "catalog_server_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisCatalogInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisCatalogInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisCatalogInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_admin_password: Optional['outputs.SecureStringResponse'] = None,
                 catalog_admin_user_name: Optional[_builtins.str] = None,
                 catalog_pricing_tier: Optional[_builtins.str] = None,
                 catalog_server_endpoint: Optional[_builtins.str] = None):
        """
        Catalog information for managed dedicated integration runtime.
        :param 'SecureStringResponse' catalog_admin_password: The password of the administrator user account of the catalog database.
        :param _builtins.str catalog_admin_user_name: The administrator user name of catalog database.
        :param _builtins.str catalog_pricing_tier: The pricing tier for the catalog database. The valid values could be found in https://azure.microsoft.com/en-us/pricing/details/sql-database/
        :param _builtins.str catalog_server_endpoint: The catalog database server URL.
        """
        if catalog_admin_password is not None:
            pulumi.set(__self__, "catalog_admin_password", catalog_admin_password)
        if catalog_admin_user_name is not None:
            pulumi.set(__self__, "catalog_admin_user_name", catalog_admin_user_name)
        if catalog_pricing_tier is not None:
            pulumi.set(__self__, "catalog_pricing_tier", catalog_pricing_tier)
        if catalog_server_endpoint is not None:
            pulumi.set(__self__, "catalog_server_endpoint", catalog_server_endpoint)

    @_builtins.property
    @pulumi.getter(name="catalogAdminPassword")
    def catalog_admin_password(self) -> Optional['outputs.SecureStringResponse']:
        """
        The password of the administrator user account of the catalog database.
        """
        return pulumi.get(self, "catalog_admin_password")

    @_builtins.property
    @pulumi.getter(name="catalogAdminUserName")
    def catalog_admin_user_name(self) -> Optional[_builtins.str]:
        """
        The administrator user name of catalog database.
        """
        return pulumi.get(self, "catalog_admin_user_name")

    @_builtins.property
    @pulumi.getter(name="catalogPricingTier")
    def catalog_pricing_tier(self) -> Optional[_builtins.str]:
        """
        The pricing tier for the catalog database. The valid values could be found in https://azure.microsoft.com/en-us/pricing/details/sql-database/
        """
        return pulumi.get(self, "catalog_pricing_tier")

    @_builtins.property
    @pulumi.getter(name="catalogServerEndpoint")
    def catalog_server_endpoint(self) -> Optional[_builtins.str]:
        """
        The catalog database server URL.
        """
        return pulumi.get(self, "catalog_server_endpoint")


@pulumi.output_type
class IntegrationRuntimeSsisPropertiesResponse(dict):
    """
    SSIS properties for managed integration runtime.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogInfo":
            suggest = "catalog_info"
        elif key == "customSetupScriptProperties":
            suggest = "custom_setup_script_properties"
        elif key == "dataProxyProperties":
            suggest = "data_proxy_properties"
        elif key == "expressCustomSetupProperties":
            suggest = "express_custom_setup_properties"
        elif key == "licenseType":
            suggest = "license_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeSsisPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeSsisPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeSsisPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_info: Optional['outputs.IntegrationRuntimeSsisCatalogInfoResponse'] = None,
                 custom_setup_script_properties: Optional['outputs.IntegrationRuntimeCustomSetupScriptPropertiesResponse'] = None,
                 data_proxy_properties: Optional['outputs.IntegrationRuntimeDataProxyPropertiesResponse'] = None,
                 edition: Optional[_builtins.str] = None,
                 express_custom_setup_properties: Optional[Sequence[Any]] = None,
                 license_type: Optional[_builtins.str] = None):
        """
        SSIS properties for managed integration runtime.
        :param 'IntegrationRuntimeSsisCatalogInfoResponse' catalog_info: Catalog information for managed dedicated integration runtime.
        :param 'IntegrationRuntimeCustomSetupScriptPropertiesResponse' custom_setup_script_properties: Custom setup script properties for a managed dedicated integration runtime.
        :param 'IntegrationRuntimeDataProxyPropertiesResponse' data_proxy_properties: Data proxy properties for a managed dedicated integration runtime.
        :param _builtins.str edition: The edition for the SSIS Integration Runtime
        :param Sequence[Union['CmdkeySetupResponse', 'ComponentSetupResponse', 'EnvironmentVariableSetupResponse']] express_custom_setup_properties: Custom setup without script properties for a SSIS integration runtime.
        :param _builtins.str license_type: License type for bringing your own license scenario.
        """
        if catalog_info is not None:
            pulumi.set(__self__, "catalog_info", catalog_info)
        if custom_setup_script_properties is not None:
            pulumi.set(__self__, "custom_setup_script_properties", custom_setup_script_properties)
        if data_proxy_properties is not None:
            pulumi.set(__self__, "data_proxy_properties", data_proxy_properties)
        if edition is not None:
            pulumi.set(__self__, "edition", edition)
        if express_custom_setup_properties is not None:
            pulumi.set(__self__, "express_custom_setup_properties", express_custom_setup_properties)
        if license_type is not None:
            pulumi.set(__self__, "license_type", license_type)

    @_builtins.property
    @pulumi.getter(name="catalogInfo")
    def catalog_info(self) -> Optional['outputs.IntegrationRuntimeSsisCatalogInfoResponse']:
        """
        Catalog information for managed dedicated integration runtime.
        """
        return pulumi.get(self, "catalog_info")

    @_builtins.property
    @pulumi.getter(name="customSetupScriptProperties")
    def custom_setup_script_properties(self) -> Optional['outputs.IntegrationRuntimeCustomSetupScriptPropertiesResponse']:
        """
        Custom setup script properties for a managed dedicated integration runtime.
        """
        return pulumi.get(self, "custom_setup_script_properties")

    @_builtins.property
    @pulumi.getter(name="dataProxyProperties")
    def data_proxy_properties(self) -> Optional['outputs.IntegrationRuntimeDataProxyPropertiesResponse']:
        """
        Data proxy properties for a managed dedicated integration runtime.
        """
        return pulumi.get(self, "data_proxy_properties")

    @_builtins.property
    @pulumi.getter
    def edition(self) -> Optional[_builtins.str]:
        """
        The edition for the SSIS Integration Runtime
        """
        return pulumi.get(self, "edition")

    @_builtins.property
    @pulumi.getter(name="expressCustomSetupProperties")
    def express_custom_setup_properties(self) -> Optional[Sequence[Any]]:
        """
        Custom setup without script properties for a SSIS integration runtime.
        """
        return pulumi.get(self, "express_custom_setup_properties")

    @_builtins.property
    @pulumi.getter(name="licenseType")
    def license_type(self) -> Optional[_builtins.str]:
        """
        License type for bringing your own license scenario.
        """
        return pulumi.get(self, "license_type")


@pulumi.output_type
class IntegrationRuntimeVNetPropertiesResponse(dict):
    """
    VNet properties for managed integration runtime.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicIPs":
            suggest = "public_ips"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "vNetId":
            suggest = "v_net_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationRuntimeVNetPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationRuntimeVNetPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationRuntimeVNetPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_ips: Optional[Sequence[_builtins.str]] = None,
                 subnet: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 v_net_id: Optional[_builtins.str] = None):
        """
        VNet properties for managed integration runtime.
        :param Sequence[_builtins.str] public_ips: Resource IDs of the public IP addresses that this integration runtime will use.
        :param _builtins.str subnet: The name of the subnet this integration runtime will join.
        :param _builtins.str subnet_id: The ID of subnet, to which this Azure-SSIS integration runtime will be joined.
        :param _builtins.str v_net_id: The ID of the VNet that this integration runtime will join.
        """
        if public_ips is not None:
            pulumi.set(__self__, "public_ips", public_ips)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if v_net_id is not None:
            pulumi.set(__self__, "v_net_id", v_net_id)

    @_builtins.property
    @pulumi.getter(name="publicIPs")
    def public_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        Resource IDs of the public IP addresses that this integration runtime will use.
        """
        return pulumi.get(self, "public_ips")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[_builtins.str]:
        """
        The name of the subnet this integration runtime will join.
        """
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of subnet, to which this Azure-SSIS integration runtime will be joined.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="vNetId")
    def v_net_id(self) -> Optional[_builtins.str]:
        """
        The ID of the VNet that this integration runtime will join.
        """
        return pulumi.get(self, "v_net_id")


@pulumi.output_type
class KekIdentityPropertiesResponse(dict):
    """
    Key encryption key properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useSystemAssignedIdentity":
            suggest = "use_system_assigned_identity"
        elif key == "userAssignedIdentity":
            suggest = "user_assigned_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KekIdentityPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KekIdentityPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KekIdentityPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 use_system_assigned_identity: Optional[Any] = None,
                 user_assigned_identity: Optional[_builtins.str] = None):
        """
        Key encryption key properties
        :param Any use_system_assigned_identity: Boolean specifying whether to use system assigned identity or not
        :param _builtins.str user_assigned_identity: User assigned identity resource Id
        """
        if use_system_assigned_identity is not None:
            pulumi.set(__self__, "use_system_assigned_identity", use_system_assigned_identity)
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @_builtins.property
    @pulumi.getter(name="useSystemAssignedIdentity")
    def use_system_assigned_identity(self) -> Optional[Any]:
        """
        Boolean specifying whether to use system assigned identity or not
        """
        return pulumi.get(self, "use_system_assigned_identity")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[_builtins.str]:
        """
        User assigned identity resource Id
        """
        return pulumi.get(self, "user_assigned_identity")


@pulumi.output_type
class LanguageExtensionResponse(dict):
    """
    The language extension object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "languageExtensionName":
            suggest = "language_extension_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LanguageExtensionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LanguageExtensionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LanguageExtensionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 language_extension_name: Optional[_builtins.str] = None):
        """
        The language extension object.
        :param _builtins.str language_extension_name: The language extension name.
        """
        if language_extension_name is not None:
            pulumi.set(__self__, "language_extension_name", language_extension_name)

    @_builtins.property
    @pulumi.getter(name="languageExtensionName")
    def language_extension_name(self) -> Optional[_builtins.str]:
        """
        The language extension name.
        """
        return pulumi.get(self, "language_extension_name")


@pulumi.output_type
class LanguageExtensionsListResponse(dict):
    """
    The list of language extension objects.
    """
    def __init__(__self__, *,
                 value: Optional[Sequence['outputs.LanguageExtensionResponse']] = None):
        """
        The list of language extension objects.
        :param Sequence['LanguageExtensionResponse'] value: The list of language extensions.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[Sequence['outputs.LanguageExtensionResponse']]:
        """
        The list of language extensions.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LibraryInfoResponse(dict):
    """
    Library/package information of a Big Data pool powered by Apache Spark
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "creatorId":
            suggest = "creator_id"
        elif key == "provisioningStatus":
            suggest = "provisioning_status"
        elif key == "uploadedTimestamp":
            suggest = "uploaded_timestamp"
        elif key == "containerName":
            suggest = "container_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LibraryInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LibraryInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LibraryInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 creator_id: _builtins.str,
                 provisioning_status: _builtins.str,
                 uploaded_timestamp: _builtins.str,
                 container_name: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        Library/package information of a Big Data pool powered by Apache Spark
        :param _builtins.str creator_id: Creator Id of the library/package.
        :param _builtins.str provisioning_status: Provisioning status of the library/package.
        :param _builtins.str uploaded_timestamp: The last update time of the library.
        :param _builtins.str container_name: Storage blob container name.
        :param _builtins.str name: Name of the library.
        :param _builtins.str path: Storage blob path of library.
        :param _builtins.str type: Type of the library.
        """
        pulumi.set(__self__, "creator_id", creator_id)
        pulumi.set(__self__, "provisioning_status", provisioning_status)
        pulumi.set(__self__, "uploaded_timestamp", uploaded_timestamp)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="creatorId")
    def creator_id(self) -> _builtins.str:
        """
        Creator Id of the library/package.
        """
        return pulumi.get(self, "creator_id")

    @_builtins.property
    @pulumi.getter(name="provisioningStatus")
    def provisioning_status(self) -> _builtins.str:
        """
        Provisioning status of the library/package.
        """
        return pulumi.get(self, "provisioning_status")

    @_builtins.property
    @pulumi.getter(name="uploadedTimestamp")
    def uploaded_timestamp(self) -> _builtins.str:
        """
        The last update time of the library.
        """
        return pulumi.get(self, "uploaded_timestamp")

    @_builtins.property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[_builtins.str]:
        """
        Storage blob container name.
        """
        return pulumi.get(self, "container_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the library.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Storage blob path of library.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the library.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LibraryRequirementsResponse(dict):
    """
    Library requirements for a Big Data pool powered by Apache Spark
    """
    def __init__(__self__, *,
                 time: _builtins.str,
                 content: Optional[_builtins.str] = None,
                 filename: Optional[_builtins.str] = None):
        """
        Library requirements for a Big Data pool powered by Apache Spark
        :param _builtins.str time: The last update time of the library requirements file.
        :param _builtins.str content: The library requirements.
        :param _builtins.str filename: The filename of the library requirements file.
        """
        pulumi.set(__self__, "time", time)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.str:
        """
        The last update time of the library requirements file.
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        """
        The library requirements.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter
    def filename(self) -> Optional[_builtins.str]:
        """
        The filename of the library requirements file.
        """
        return pulumi.get(self, "filename")


@pulumi.output_type
class LinkedIntegrationRuntimeKeyAuthorizationResponse(dict):
    """
    The key authorization type integration runtime.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationType":
            suggest = "authorization_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedIntegrationRuntimeKeyAuthorizationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedIntegrationRuntimeKeyAuthorizationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedIntegrationRuntimeKeyAuthorizationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_type: _builtins.str,
                 key: 'outputs.SecureStringResponse'):
        """
        The key authorization type integration runtime.
        :param _builtins.str authorization_type: The authorization type for integration runtime sharing.
               Expected value is 'Key'.
        :param 'SecureStringResponse' key: The key used for authorization.
        """
        pulumi.set(__self__, "authorization_type", 'Key')
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter(name="authorizationType")
    def authorization_type(self) -> _builtins.str:
        """
        The authorization type for integration runtime sharing.
        Expected value is 'Key'.
        """
        return pulumi.get(self, "authorization_type")

    @_builtins.property
    @pulumi.getter
    def key(self) -> 'outputs.SecureStringResponse':
        """
        The key used for authorization.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class LinkedIntegrationRuntimeRbacAuthorizationResponse(dict):
    """
    The role based access control (RBAC) authorization type integration runtime.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationType":
            suggest = "authorization_type"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedIntegrationRuntimeRbacAuthorizationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedIntegrationRuntimeRbacAuthorizationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedIntegrationRuntimeRbacAuthorizationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_type: _builtins.str,
                 resource_id: _builtins.str):
        """
        The role based access control (RBAC) authorization type integration runtime.
        :param _builtins.str authorization_type: The authorization type for integration runtime sharing.
               Expected value is 'RBAC'.
        :param _builtins.str resource_id: The resource identifier of the integration runtime to be shared.
        """
        pulumi.set(__self__, "authorization_type", 'RBAC')
        pulumi.set(__self__, "resource_id", resource_id)

    @_builtins.property
    @pulumi.getter(name="authorizationType")
    def authorization_type(self) -> _builtins.str:
        """
        The authorization type for integration runtime sharing.
        Expected value is 'RBAC'.
        """
        return pulumi.get(self, "authorization_type")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        The resource identifier of the integration runtime to be shared.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class LinkedIntegrationRuntimeResponse(dict):
    """
    The linked integration runtime information.
    """
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 data_factory_location: _builtins.str,
                 data_factory_name: _builtins.str,
                 name: _builtins.str,
                 subscription_id: _builtins.str):
        """
        The linked integration runtime information.
        :param _builtins.str create_time: The creating time of the linked integration runtime.
        :param _builtins.str data_factory_location: The location of the workspace for which the linked integration runtime belong to.
        :param _builtins.str data_factory_name: The name of the workspace for which the linked integration runtime belong to.
        :param _builtins.str name: The name of the linked integration runtime.
        :param _builtins.str subscription_id: The subscription ID for which the linked integration runtime belong to.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "data_factory_location", data_factory_location)
        pulumi.set(__self__, "data_factory_name", data_factory_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subscription_id", subscription_id)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The creating time of the linked integration runtime.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="dataFactoryLocation")
    def data_factory_location(self) -> _builtins.str:
        """
        The location of the workspace for which the linked integration runtime belong to.
        """
        return pulumi.get(self, "data_factory_location")

    @_builtins.property
    @pulumi.getter(name="dataFactoryName")
    def data_factory_name(self) -> _builtins.str:
        """
        The name of the workspace for which the linked integration runtime belong to.
        """
        return pulumi.get(self, "data_factory_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the linked integration runtime.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        """
        The subscription ID for which the linked integration runtime belong to.
        """
        return pulumi.get(self, "subscription_id")


@pulumi.output_type
class ManagedIdentityResponse(dict):
    """
    The workspace managed identity
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: _builtins.str,
                 tenant_id: _builtins.str,
                 type: Optional[_builtins.str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedManagedIdentityResponse']] = None):
        """
        The workspace managed identity
        :param _builtins.str principal_id: The principal ID of the workspace managed identity
        :param _builtins.str tenant_id: The tenant ID of the workspace managed identity
        :param _builtins.str type: The type of managed identity for the workspace
        :param Mapping[str, 'UserAssignedManagedIdentityResponse'] user_assigned_identities: The user assigned managed identities.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The principal ID of the workspace managed identity
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The tenant ID of the workspace managed identity
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of managed identity for the workspace
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedManagedIdentityResponse']]:
        """
        The user assigned managed identities.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class ManagedIntegrationRuntimeErrorResponse(dict):
    """
    Error definition for managed integration runtime.
    """
    def __init__(__self__, *,
                 code: _builtins.str,
                 message: _builtins.str,
                 parameters: Sequence[_builtins.str],
                 time: _builtins.str):
        """
        Error definition for managed integration runtime.
        :param _builtins.str code: Error code.
        :param _builtins.str message: Error message.
        :param Sequence[_builtins.str] parameters: Managed integration runtime error parameters.
        :param _builtins.str time: The time when the error occurred.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "time", time)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.str:
        """
        Error code.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        Error message.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Sequence[_builtins.str]:
        """
        Managed integration runtime error parameters.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.str:
        """
        The time when the error occurred.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class ManagedIntegrationRuntimeNodeResponse(dict):
    """
    Properties of integration runtime node.
    """
    def __init__(__self__, *,
                 node_id: _builtins.str,
                 status: _builtins.str,
                 errors: Optional[Sequence['outputs.ManagedIntegrationRuntimeErrorResponse']] = None):
        """
        Properties of integration runtime node.
        :param _builtins.str node_id: The managed integration runtime node id.
        :param _builtins.str status: The managed integration runtime node status.
        :param Sequence['ManagedIntegrationRuntimeErrorResponse'] errors: The errors that occurred on this integration runtime node.
        """
        pulumi.set(__self__, "node_id", node_id)
        pulumi.set(__self__, "status", status)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> _builtins.str:
        """
        The managed integration runtime node id.
        """
        return pulumi.get(self, "node_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The managed integration runtime node status.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.ManagedIntegrationRuntimeErrorResponse']]:
        """
        The errors that occurred on this integration runtime node.
        """
        return pulumi.get(self, "errors")


@pulumi.output_type
class ManagedIntegrationRuntimeOperationResultResponse(dict):
    """
    Properties of managed integration runtime operation result.
    """
    def __init__(__self__, *,
                 activity_id: _builtins.str,
                 error_code: _builtins.str,
                 parameters: Sequence[_builtins.str],
                 result: _builtins.str,
                 start_time: _builtins.str,
                 type: _builtins.str):
        """
        Properties of managed integration runtime operation result.
        :param _builtins.str activity_id: The activity id for the operation request.
        :param _builtins.str error_code: The error code.
        :param Sequence[_builtins.str] parameters: Managed integration runtime error parameters.
        :param _builtins.str result: The operation result.
        :param _builtins.str start_time: The start time of the operation.
        :param _builtins.str type: The operation type. Could be start or stop.
        """
        pulumi.set(__self__, "activity_id", activity_id)
        pulumi.set(__self__, "error_code", error_code)
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "result", result)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="activityId")
    def activity_id(self) -> _builtins.str:
        """
        The activity id for the operation request.
        """
        return pulumi.get(self, "activity_id")

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> _builtins.str:
        """
        The error code.
        """
        return pulumi.get(self, "error_code")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Sequence[_builtins.str]:
        """
        Managed integration runtime error parameters.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def result(self) -> _builtins.str:
        """
        The operation result.
        """
        return pulumi.get(self, "result")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The start time of the operation.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The operation type. Could be start or stop.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ManagedIntegrationRuntimeResponse(dict):
    """
    Managed integration runtime, including managed elastic and managed dedicated integration runtimes.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "computeProperties":
            suggest = "compute_properties"
        elif key == "customerVirtualNetwork":
            suggest = "customer_virtual_network"
        elif key == "referenceName":
            suggest = "reference_name"
        elif key == "ssisProperties":
            suggest = "ssis_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedIntegrationRuntimeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedIntegrationRuntimeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedIntegrationRuntimeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: _builtins.str,
                 type: _builtins.str,
                 compute_properties: Optional['outputs.IntegrationRuntimeComputePropertiesResponse'] = None,
                 customer_virtual_network: Optional['outputs.IntegrationRuntimeCustomerVirtualNetworkResponse'] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 reference_name: Optional[_builtins.str] = None,
                 ssis_properties: Optional['outputs.IntegrationRuntimeSsisPropertiesResponse'] = None):
        """
        Managed integration runtime, including managed elastic and managed dedicated integration runtimes.
        :param _builtins.str provisioning_state: Integration runtime state, only valid for managed dedicated integration runtime.
        :param _builtins.str type: The type of integration runtime.
               Expected value is 'Managed'.
        :param 'IntegrationRuntimeComputePropertiesResponse' compute_properties: The compute resource for managed integration runtime.
        :param 'IntegrationRuntimeCustomerVirtualNetworkResponse' customer_virtual_network: The name of virtual network to which Azure-SSIS integration runtime will join
        :param _builtins.str description: Integration runtime description.
        :param _builtins.str id: The id of the managed virtual network.
        :param _builtins.str reference_name: The reference name of the managed virtual network
        :param 'IntegrationRuntimeSsisPropertiesResponse' ssis_properties: SSIS properties for managed integration runtime.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "type", 'Managed')
        if compute_properties is not None:
            pulumi.set(__self__, "compute_properties", compute_properties)
        if customer_virtual_network is not None:
            pulumi.set(__self__, "customer_virtual_network", customer_virtual_network)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if reference_name is not None:
            pulumi.set(__self__, "reference_name", reference_name)
        if ssis_properties is not None:
            pulumi.set(__self__, "ssis_properties", ssis_properties)

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Integration runtime state, only valid for managed dedicated integration runtime.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of integration runtime.
        Expected value is 'Managed'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="computeProperties")
    def compute_properties(self) -> Optional['outputs.IntegrationRuntimeComputePropertiesResponse']:
        """
        The compute resource for managed integration runtime.
        """
        return pulumi.get(self, "compute_properties")

    @_builtins.property
    @pulumi.getter(name="customerVirtualNetwork")
    def customer_virtual_network(self) -> Optional['outputs.IntegrationRuntimeCustomerVirtualNetworkResponse']:
        """
        The name of virtual network to which Azure-SSIS integration runtime will join
        """
        return pulumi.get(self, "customer_virtual_network")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Integration runtime description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The id of the managed virtual network.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> Optional[_builtins.str]:
        """
        The reference name of the managed virtual network
        """
        return pulumi.get(self, "reference_name")

    @_builtins.property
    @pulumi.getter(name="ssisProperties")
    def ssis_properties(self) -> Optional['outputs.IntegrationRuntimeSsisPropertiesResponse']:
        """
        SSIS properties for managed integration runtime.
        """
        return pulumi.get(self, "ssis_properties")


@pulumi.output_type
class ManagedIntegrationRuntimeStatusResponse(dict):
    """
    Managed integration runtime status.
    """
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 data_factory_name: _builtins.str,
                 last_operation: 'outputs.ManagedIntegrationRuntimeOperationResultResponse',
                 nodes: Sequence['outputs.ManagedIntegrationRuntimeNodeResponse'],
                 other_errors: Sequence['outputs.ManagedIntegrationRuntimeErrorResponse'],
                 state: _builtins.str,
                 type: _builtins.str):
        """
        Managed integration runtime status.
        :param _builtins.str create_time: The time at which the integration runtime was created, in ISO8601 format.
        :param _builtins.str data_factory_name: The workspace name which the integration runtime belong to.
        :param 'ManagedIntegrationRuntimeOperationResultResponse' last_operation: The last operation result that occurred on this integration runtime.
        :param Sequence['ManagedIntegrationRuntimeNodeResponse'] nodes: The list of nodes for managed integration runtime.
        :param Sequence['ManagedIntegrationRuntimeErrorResponse'] other_errors: The errors that occurred on this integration runtime.
        :param _builtins.str state: The state of integration runtime.
        :param _builtins.str type: The type of integration runtime.
               Expected value is 'Managed'.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "data_factory_name", data_factory_name)
        pulumi.set(__self__, "last_operation", last_operation)
        pulumi.set(__self__, "nodes", nodes)
        pulumi.set(__self__, "other_errors", other_errors)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "type", 'Managed')

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The time at which the integration runtime was created, in ISO8601 format.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="dataFactoryName")
    def data_factory_name(self) -> _builtins.str:
        """
        The workspace name which the integration runtime belong to.
        """
        return pulumi.get(self, "data_factory_name")

    @_builtins.property
    @pulumi.getter(name="lastOperation")
    def last_operation(self) -> 'outputs.ManagedIntegrationRuntimeOperationResultResponse':
        """
        The last operation result that occurred on this integration runtime.
        """
        return pulumi.get(self, "last_operation")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Sequence['outputs.ManagedIntegrationRuntimeNodeResponse']:
        """
        The list of nodes for managed integration runtime.
        """
        return pulumi.get(self, "nodes")

    @_builtins.property
    @pulumi.getter(name="otherErrors")
    def other_errors(self) -> Sequence['outputs.ManagedIntegrationRuntimeErrorResponse']:
        """
        The errors that occurred on this integration runtime.
        """
        return pulumi.get(self, "other_errors")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of integration runtime.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of integration runtime.
        Expected value is 'Managed'.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ManagedVirtualNetworkSettingsResponse(dict):
    """
    Managed Virtual Network Settings
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedAadTenantIdsForLinking":
            suggest = "allowed_aad_tenant_ids_for_linking"
        elif key == "linkedAccessCheckOnTargetResource":
            suggest = "linked_access_check_on_target_resource"
        elif key == "preventDataExfiltration":
            suggest = "prevent_data_exfiltration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedVirtualNetworkSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedVirtualNetworkSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedVirtualNetworkSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_aad_tenant_ids_for_linking: Optional[Sequence[_builtins.str]] = None,
                 linked_access_check_on_target_resource: Optional[_builtins.bool] = None,
                 prevent_data_exfiltration: Optional[_builtins.bool] = None):
        """
        Managed Virtual Network Settings
        :param Sequence[_builtins.str] allowed_aad_tenant_ids_for_linking: Allowed Aad Tenant Ids For Linking
        :param _builtins.bool linked_access_check_on_target_resource: Linked Access Check On Target Resource
        :param _builtins.bool prevent_data_exfiltration: Prevent Data Exfiltration
        """
        if allowed_aad_tenant_ids_for_linking is not None:
            pulumi.set(__self__, "allowed_aad_tenant_ids_for_linking", allowed_aad_tenant_ids_for_linking)
        if linked_access_check_on_target_resource is not None:
            pulumi.set(__self__, "linked_access_check_on_target_resource", linked_access_check_on_target_resource)
        if prevent_data_exfiltration is not None:
            pulumi.set(__self__, "prevent_data_exfiltration", prevent_data_exfiltration)

    @_builtins.property
    @pulumi.getter(name="allowedAadTenantIdsForLinking")
    def allowed_aad_tenant_ids_for_linking(self) -> Optional[Sequence[_builtins.str]]:
        """
        Allowed Aad Tenant Ids For Linking
        """
        return pulumi.get(self, "allowed_aad_tenant_ids_for_linking")

    @_builtins.property
    @pulumi.getter(name="linkedAccessCheckOnTargetResource")
    def linked_access_check_on_target_resource(self) -> Optional[_builtins.bool]:
        """
        Linked Access Check On Target Resource
        """
        return pulumi.get(self, "linked_access_check_on_target_resource")

    @_builtins.property
    @pulumi.getter(name="preventDataExfiltration")
    def prevent_data_exfiltration(self) -> Optional[_builtins.bool]:
        """
        Prevent Data Exfiltration
        """
        return pulumi.get(self, "prevent_data_exfiltration")


@pulumi.output_type
class OptimizedAutoscaleResponse(dict):
    """
    A class that contains the optimized auto scale definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OptimizedAutoscaleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OptimizedAutoscaleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OptimizedAutoscaleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_enabled: _builtins.bool,
                 maximum: _builtins.int,
                 minimum: _builtins.int,
                 version: _builtins.int):
        """
        A class that contains the optimized auto scale definition.
        :param _builtins.bool is_enabled: A boolean value that indicate if the optimized autoscale feature is enabled or not.
        :param _builtins.int maximum: Maximum allowed instances count.
        :param _builtins.int minimum: Minimum allowed instances count.
        :param _builtins.int version: The version of the template defined, for instance 1.
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "maximum", maximum)
        pulumi.set(__self__, "minimum", minimum)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        """
        A boolean value that indicate if the optimized autoscale feature is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> _builtins.int:
        """
        Maximum allowed instances count.
        """
        return pulumi.get(self, "maximum")

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> _builtins.int:
        """
        Minimum allowed instances count.
        """
        return pulumi.get(self, "minimum")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.int:
        """
        The version of the template defined, for instance 1.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class PrivateEndpointConnectionForPrivateLinkHubBasicResponse(dict):
    """
    Private Endpoint Connection For Private Link Hub - Basic
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"
        elif key == "privateLinkServiceConnectionState":
            suggest = "private_link_service_connection_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointConnectionForPrivateLinkHubBasicResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointConnectionForPrivateLinkHubBasicResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointConnectionForPrivateLinkHubBasicResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 provisioning_state: _builtins.str,
                 private_endpoint: Optional['outputs.PrivateEndpointResponse'] = None,
                 private_link_service_connection_state: Optional['outputs.PrivateLinkServiceConnectionStateResponse'] = None):
        """
        Private Endpoint Connection For Private Link Hub - Basic
        :param _builtins.str id: identifier
        :param _builtins.str provisioning_state: Provisioning state of the private endpoint connection.
        :param 'PrivateEndpointResponse' private_endpoint: The private endpoint which the connection belongs to.
        :param 'PrivateLinkServiceConnectionStateResponse' private_link_service_connection_state: Connection state of the private endpoint connection.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if private_link_service_connection_state is not None:
            pulumi.set(__self__, "private_link_service_connection_state", private_link_service_connection_state)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        identifier
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the private endpoint connection.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.PrivateEndpointResponse']:
        """
        The private endpoint which the connection belongs to.
        """
        return pulumi.get(self, "private_endpoint")

    @_builtins.property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> Optional['outputs.PrivateLinkServiceConnectionStateResponse']:
        """
        Connection state of the private endpoint connection.
        """
        return pulumi.get(self, "private_link_service_connection_state")


@pulumi.output_type
class PrivateEndpointConnectionResponse(dict):
    """
    A private endpoint connection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"
        elif key == "privateLinkServiceConnectionState":
            suggest = "private_link_service_connection_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 provisioning_state: _builtins.str,
                 type: _builtins.str,
                 private_endpoint: Optional['outputs.PrivateEndpointResponse'] = None,
                 private_link_service_connection_state: Optional['outputs.PrivateLinkServiceConnectionStateResponse'] = None):
        """
        A private endpoint connection
        :param _builtins.str id: Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        :param _builtins.str name: The name of the resource
        :param _builtins.str provisioning_state: Provisioning state of the private endpoint connection.
        :param _builtins.str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param 'PrivateEndpointResponse' private_endpoint: The private endpoint which the connection belongs to.
        :param 'PrivateLinkServiceConnectionStateResponse' private_link_service_connection_state: Connection state of the private endpoint connection.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "type", type)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if private_link_service_connection_state is not None:
            pulumi.set(__self__, "private_link_service_connection_state", private_link_service_connection_state)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the private endpoint connection.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.PrivateEndpointResponse']:
        """
        The private endpoint which the connection belongs to.
        """
        return pulumi.get(self, "private_endpoint")

    @_builtins.property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> Optional['outputs.PrivateLinkServiceConnectionStateResponse']:
        """
        Connection state of the private endpoint connection.
        """
        return pulumi.get(self, "private_link_service_connection_state")


@pulumi.output_type
class PrivateEndpointResponse(dict):
    """
    Private endpoint details
    """
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        Private endpoint details
        :param _builtins.str id: Resource id of the private endpoint.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Resource id of the private endpoint.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrivateLinkServiceConnectionStateResponse(dict):
    """
    Connection state details of the private endpoint
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsRequired":
            suggest = "actions_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkServiceConnectionStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_required: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        Connection state details of the private endpoint
        :param _builtins.str actions_required: The actions required for private link service connection.
        :param _builtins.str description: The private link service connection description.
        :param _builtins.str status: The private link service connection status.
        """
        pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> _builtins.str:
        """
        The actions required for private link service connection.
        """
        return pulumi.get(self, "actions_required")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The private link service connection description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The private link service connection status.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class PurviewConfigurationResponse(dict):
    """
    Purview Configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "purviewResourceId":
            suggest = "purview_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PurviewConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PurviewConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PurviewConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 purview_resource_id: Optional[_builtins.str] = None):
        """
        Purview Configuration
        :param _builtins.str purview_resource_id: Purview Resource ID
        """
        if purview_resource_id is not None:
            pulumi.set(__self__, "purview_resource_id", purview_resource_id)

    @_builtins.property
    @pulumi.getter(name="purviewResourceId")
    def purview_resource_id(self) -> Optional[_builtins.str]:
        """
        Purview Resource ID
        """
        return pulumi.get(self, "purview_resource_id")


@pulumi.output_type
class SecureStringResponse(dict):
    """
    Azure Synapse secure string definition. The string value will be masked with asterisks '*' during Get or List API calls.
    """
    def __init__(__self__, *,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        Azure Synapse secure string definition. The string value will be masked with asterisks '*' during Get or List API calls.
        :param _builtins.str type: Type of the secret.
               Expected value is 'SecureString'.
        :param _builtins.str value: Value of secure string.
        """
        pulumi.set(__self__, "type", 'SecureString')
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the secret.
        Expected value is 'SecureString'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of secure string.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SelfHostedIntegrationRuntimeNodeResponse(dict):
    """
    Properties of Self-hosted integration runtime node.
    """
    def __init__(__self__, *,
                 capabilities: Mapping[str, _builtins.str],
                 concurrent_jobs_limit: _builtins.int,
                 expiry_time: _builtins.str,
                 host_service_uri: _builtins.str,
                 is_active_dispatcher: _builtins.bool,
                 last_connect_time: _builtins.str,
                 last_end_update_time: _builtins.str,
                 last_start_time: _builtins.str,
                 last_start_update_time: _builtins.str,
                 last_stop_time: _builtins.str,
                 last_update_result: _builtins.str,
                 machine_name: _builtins.str,
                 max_concurrent_jobs: _builtins.int,
                 node_name: _builtins.str,
                 register_time: _builtins.str,
                 status: _builtins.str,
                 version: _builtins.str,
                 version_status: _builtins.str):
        """
        Properties of Self-hosted integration runtime node.
        :param Mapping[str, _builtins.str] capabilities: The integration runtime capabilities dictionary
        :param _builtins.int concurrent_jobs_limit: Maximum concurrent jobs on the integration runtime node.
        :param _builtins.str expiry_time: The time at which the integration runtime will expire in ISO8601 format.
        :param _builtins.str host_service_uri: URI for the host machine of the integration runtime.
        :param _builtins.bool is_active_dispatcher: Indicates whether this node is the active dispatcher for integration runtime requests.
        :param _builtins.str last_connect_time: The most recent time at which the integration runtime was connected in ISO8601 format.
        :param _builtins.str last_end_update_time: The last time for the integration runtime node update end.
        :param _builtins.str last_start_time: The time the node last started up.
        :param _builtins.str last_start_update_time: The last time for the integration runtime node update start.
        :param _builtins.str last_stop_time: The integration runtime node last stop time.
        :param _builtins.str last_update_result: The result of the last integration runtime node update.
        :param _builtins.str machine_name: Machine name of the integration runtime node.
        :param _builtins.int max_concurrent_jobs: The maximum concurrent jobs in this integration runtime.
        :param _builtins.str node_name: Name of the integration runtime node.
        :param _builtins.str register_time: The time at which the integration runtime node was registered in ISO8601 format.
        :param _builtins.str status: Status of the integration runtime node.
        :param _builtins.str version: Version of the integration runtime node.
        :param _builtins.str version_status: Status of the integration runtime node version.
        """
        pulumi.set(__self__, "capabilities", capabilities)
        pulumi.set(__self__, "concurrent_jobs_limit", concurrent_jobs_limit)
        pulumi.set(__self__, "expiry_time", expiry_time)
        pulumi.set(__self__, "host_service_uri", host_service_uri)
        pulumi.set(__self__, "is_active_dispatcher", is_active_dispatcher)
        pulumi.set(__self__, "last_connect_time", last_connect_time)
        pulumi.set(__self__, "last_end_update_time", last_end_update_time)
        pulumi.set(__self__, "last_start_time", last_start_time)
        pulumi.set(__self__, "last_start_update_time", last_start_update_time)
        pulumi.set(__self__, "last_stop_time", last_stop_time)
        pulumi.set(__self__, "last_update_result", last_update_result)
        pulumi.set(__self__, "machine_name", machine_name)
        pulumi.set(__self__, "max_concurrent_jobs", max_concurrent_jobs)
        pulumi.set(__self__, "node_name", node_name)
        pulumi.set(__self__, "register_time", register_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "version_status", version_status)

    @_builtins.property
    @pulumi.getter
    def capabilities(self) -> Mapping[str, _builtins.str]:
        """
        The integration runtime capabilities dictionary
        """
        return pulumi.get(self, "capabilities")

    @_builtins.property
    @pulumi.getter(name="concurrentJobsLimit")
    def concurrent_jobs_limit(self) -> _builtins.int:
        """
        Maximum concurrent jobs on the integration runtime node.
        """
        return pulumi.get(self, "concurrent_jobs_limit")

    @_builtins.property
    @pulumi.getter(name="expiryTime")
    def expiry_time(self) -> _builtins.str:
        """
        The time at which the integration runtime will expire in ISO8601 format.
        """
        return pulumi.get(self, "expiry_time")

    @_builtins.property
    @pulumi.getter(name="hostServiceUri")
    def host_service_uri(self) -> _builtins.str:
        """
        URI for the host machine of the integration runtime.
        """
        return pulumi.get(self, "host_service_uri")

    @_builtins.property
    @pulumi.getter(name="isActiveDispatcher")
    def is_active_dispatcher(self) -> _builtins.bool:
        """
        Indicates whether this node is the active dispatcher for integration runtime requests.
        """
        return pulumi.get(self, "is_active_dispatcher")

    @_builtins.property
    @pulumi.getter(name="lastConnectTime")
    def last_connect_time(self) -> _builtins.str:
        """
        The most recent time at which the integration runtime was connected in ISO8601 format.
        """
        return pulumi.get(self, "last_connect_time")

    @_builtins.property
    @pulumi.getter(name="lastEndUpdateTime")
    def last_end_update_time(self) -> _builtins.str:
        """
        The last time for the integration runtime node update end.
        """
        return pulumi.get(self, "last_end_update_time")

    @_builtins.property
    @pulumi.getter(name="lastStartTime")
    def last_start_time(self) -> _builtins.str:
        """
        The time the node last started up.
        """
        return pulumi.get(self, "last_start_time")

    @_builtins.property
    @pulumi.getter(name="lastStartUpdateTime")
    def last_start_update_time(self) -> _builtins.str:
        """
        The last time for the integration runtime node update start.
        """
        return pulumi.get(self, "last_start_update_time")

    @_builtins.property
    @pulumi.getter(name="lastStopTime")
    def last_stop_time(self) -> _builtins.str:
        """
        The integration runtime node last stop time.
        """
        return pulumi.get(self, "last_stop_time")

    @_builtins.property
    @pulumi.getter(name="lastUpdateResult")
    def last_update_result(self) -> _builtins.str:
        """
        The result of the last integration runtime node update.
        """
        return pulumi.get(self, "last_update_result")

    @_builtins.property
    @pulumi.getter(name="machineName")
    def machine_name(self) -> _builtins.str:
        """
        Machine name of the integration runtime node.
        """
        return pulumi.get(self, "machine_name")

    @_builtins.property
    @pulumi.getter(name="maxConcurrentJobs")
    def max_concurrent_jobs(self) -> _builtins.int:
        """
        The maximum concurrent jobs in this integration runtime.
        """
        return pulumi.get(self, "max_concurrent_jobs")

    @_builtins.property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> _builtins.str:
        """
        Name of the integration runtime node.
        """
        return pulumi.get(self, "node_name")

    @_builtins.property
    @pulumi.getter(name="registerTime")
    def register_time(self) -> _builtins.str:
        """
        The time at which the integration runtime node was registered in ISO8601 format.
        """
        return pulumi.get(self, "register_time")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Status of the integration runtime node.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of the integration runtime node.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="versionStatus")
    def version_status(self) -> _builtins.str:
        """
        Status of the integration runtime node version.
        """
        return pulumi.get(self, "version_status")


@pulumi.output_type
class SelfHostedIntegrationRuntimeResponse(dict):
    """
    Self-hosted integration runtime.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedInfo":
            suggest = "linked_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SelfHostedIntegrationRuntimeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SelfHostedIntegrationRuntimeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SelfHostedIntegrationRuntimeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 linked_info: Optional[Any] = None):
        """
        Self-hosted integration runtime.
        :param _builtins.str type: The type of integration runtime.
               Expected value is 'SelfHosted'.
        :param _builtins.str description: Integration runtime description.
        :param Union['LinkedIntegrationRuntimeKeyAuthorizationResponse', 'LinkedIntegrationRuntimeRbacAuthorizationResponse'] linked_info: Linked integration runtime type from data factory
        """
        pulumi.set(__self__, "type", 'SelfHosted')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if linked_info is not None:
            pulumi.set(__self__, "linked_info", linked_info)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of integration runtime.
        Expected value is 'SelfHosted'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Integration runtime description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="linkedInfo")
    def linked_info(self) -> Optional[Any]:
        """
        Linked integration runtime type from data factory
        """
        return pulumi.get(self, "linked_info")


@pulumi.output_type
class SelfHostedIntegrationRuntimeStatusResponse(dict):
    """
    Self-hosted integration runtime status.
    """
    def __init__(__self__, *,
                 auto_update: _builtins.str,
                 auto_update_eta: _builtins.str,
                 capabilities: Mapping[str, _builtins.str],
                 create_time: _builtins.str,
                 data_factory_name: _builtins.str,
                 internal_channel_encryption: _builtins.str,
                 latest_version: _builtins.str,
                 local_time_zone_offset: _builtins.str,
                 node_communication_channel_encryption_mode: _builtins.str,
                 pushed_version: _builtins.str,
                 scheduled_update_date: _builtins.str,
                 service_urls: Sequence[_builtins.str],
                 state: _builtins.str,
                 task_queue_id: _builtins.str,
                 type: _builtins.str,
                 update_delay_offset: _builtins.str,
                 version: _builtins.str,
                 version_status: _builtins.str,
                 links: Optional[Sequence['outputs.LinkedIntegrationRuntimeResponse']] = None,
                 nodes: Optional[Sequence['outputs.SelfHostedIntegrationRuntimeNodeResponse']] = None):
        """
        Self-hosted integration runtime status.
        :param _builtins.str auto_update: Whether Self-hosted integration runtime auto update has been turned on.
        :param _builtins.str auto_update_eta: The estimated time when the self-hosted integration runtime will be updated.
        :param Mapping[str, _builtins.str] capabilities: Object with additional information about integration runtime capabilities.
        :param _builtins.str create_time: The time at which the integration runtime was created, in ISO8601 format.
        :param _builtins.str data_factory_name: The workspace name which the integration runtime belong to.
        :param _builtins.str internal_channel_encryption: It is used to set the encryption mode for node-node communication channel (when more than 2 self-hosted integration runtime nodes exist).
        :param _builtins.str latest_version: The latest version on download center.
        :param _builtins.str local_time_zone_offset: The local time zone offset in hours.
        :param _builtins.str node_communication_channel_encryption_mode: The node communication Channel encryption mode
        :param _builtins.str pushed_version: The version that the integration runtime is going to update to.
        :param _builtins.str scheduled_update_date: The date at which the integration runtime will be scheduled to update, in ISO8601 format.
        :param Sequence[_builtins.str] service_urls: The URLs for the services used in integration runtime backend service.
        :param _builtins.str state: The state of integration runtime.
        :param _builtins.str task_queue_id: The task queue id of the integration runtime.
        :param _builtins.str type: The type of integration runtime.
               Expected value is 'SelfHosted'.
        :param _builtins.str update_delay_offset: The time in the date scheduled by service to update the integration runtime, e.g., PT03H is 3 hours
        :param _builtins.str version: Version of the integration runtime.
        :param _builtins.str version_status: Status of the integration runtime version.
        :param Sequence['LinkedIntegrationRuntimeResponse'] links: The list of linked integration runtimes that are created to share with this integration runtime.
        :param Sequence['SelfHostedIntegrationRuntimeNodeResponse'] nodes: The list of nodes for this integration runtime.
        """
        pulumi.set(__self__, "auto_update", auto_update)
        pulumi.set(__self__, "auto_update_eta", auto_update_eta)
        pulumi.set(__self__, "capabilities", capabilities)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "data_factory_name", data_factory_name)
        pulumi.set(__self__, "internal_channel_encryption", internal_channel_encryption)
        pulumi.set(__self__, "latest_version", latest_version)
        pulumi.set(__self__, "local_time_zone_offset", local_time_zone_offset)
        pulumi.set(__self__, "node_communication_channel_encryption_mode", node_communication_channel_encryption_mode)
        pulumi.set(__self__, "pushed_version", pushed_version)
        pulumi.set(__self__, "scheduled_update_date", scheduled_update_date)
        pulumi.set(__self__, "service_urls", service_urls)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "task_queue_id", task_queue_id)
        pulumi.set(__self__, "type", 'SelfHosted')
        pulumi.set(__self__, "update_delay_offset", update_delay_offset)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "version_status", version_status)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)

    @_builtins.property
    @pulumi.getter(name="autoUpdate")
    def auto_update(self) -> _builtins.str:
        """
        Whether Self-hosted integration runtime auto update has been turned on.
        """
        return pulumi.get(self, "auto_update")

    @_builtins.property
    @pulumi.getter(name="autoUpdateETA")
    def auto_update_eta(self) -> _builtins.str:
        """
        The estimated time when the self-hosted integration runtime will be updated.
        """
        return pulumi.get(self, "auto_update_eta")

    @_builtins.property
    @pulumi.getter
    def capabilities(self) -> Mapping[str, _builtins.str]:
        """
        Object with additional information about integration runtime capabilities.
        """
        return pulumi.get(self, "capabilities")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The time at which the integration runtime was created, in ISO8601 format.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="dataFactoryName")
    def data_factory_name(self) -> _builtins.str:
        """
        The workspace name which the integration runtime belong to.
        """
        return pulumi.get(self, "data_factory_name")

    @_builtins.property
    @pulumi.getter(name="internalChannelEncryption")
    def internal_channel_encryption(self) -> _builtins.str:
        """
        It is used to set the encryption mode for node-node communication channel (when more than 2 self-hosted integration runtime nodes exist).
        """
        return pulumi.get(self, "internal_channel_encryption")

    @_builtins.property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> _builtins.str:
        """
        The latest version on download center.
        """
        return pulumi.get(self, "latest_version")

    @_builtins.property
    @pulumi.getter(name="localTimeZoneOffset")
    def local_time_zone_offset(self) -> _builtins.str:
        """
        The local time zone offset in hours.
        """
        return pulumi.get(self, "local_time_zone_offset")

    @_builtins.property
    @pulumi.getter(name="nodeCommunicationChannelEncryptionMode")
    def node_communication_channel_encryption_mode(self) -> _builtins.str:
        """
        The node communication Channel encryption mode
        """
        return pulumi.get(self, "node_communication_channel_encryption_mode")

    @_builtins.property
    @pulumi.getter(name="pushedVersion")
    def pushed_version(self) -> _builtins.str:
        """
        The version that the integration runtime is going to update to.
        """
        return pulumi.get(self, "pushed_version")

    @_builtins.property
    @pulumi.getter(name="scheduledUpdateDate")
    def scheduled_update_date(self) -> _builtins.str:
        """
        The date at which the integration runtime will be scheduled to update, in ISO8601 format.
        """
        return pulumi.get(self, "scheduled_update_date")

    @_builtins.property
    @pulumi.getter(name="serviceUrls")
    def service_urls(self) -> Sequence[_builtins.str]:
        """
        The URLs for the services used in integration runtime backend service.
        """
        return pulumi.get(self, "service_urls")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of integration runtime.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="taskQueueId")
    def task_queue_id(self) -> _builtins.str:
        """
        The task queue id of the integration runtime.
        """
        return pulumi.get(self, "task_queue_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of integration runtime.
        Expected value is 'SelfHosted'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="updateDelayOffset")
    def update_delay_offset(self) -> _builtins.str:
        """
        The time in the date scheduled by service to update the integration runtime, e.g., PT03H is 3 hours
        """
        return pulumi.get(self, "update_delay_offset")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of the integration runtime.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="versionStatus")
    def version_status(self) -> _builtins.str:
        """
        Status of the integration runtime version.
        """
        return pulumi.get(self, "version_status")

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['outputs.LinkedIntegrationRuntimeResponse']]:
        """
        The list of linked integration runtimes that are created to share with this integration runtime.
        """
        return pulumi.get(self, "links")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Optional[Sequence['outputs.SelfHostedIntegrationRuntimeNodeResponse']]:
        """
        The list of nodes for this integration runtime.
        """
        return pulumi.get(self, "nodes")


@pulumi.output_type
class SkuResponse(dict):
    """
    SQL pool SKU
    """
    def __init__(__self__, *,
                 capacity: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 tier: Optional[_builtins.str] = None):
        """
        SQL pool SKU
        :param _builtins.int capacity: If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        :param _builtins.str name: The SKU name
        :param _builtins.str tier: The service tier
        """
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> Optional[_builtins.int]:
        """
        If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        """
        return pulumi.get(self, "capacity")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The SKU name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tier(self) -> Optional[_builtins.str]:
        """
        The service tier
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class SparkConfigPropertiesResponse(dict):
    """
    SparkConfig Properties for a Big Data pool powered by Apache Spark
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationType":
            suggest = "configuration_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkConfigPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkConfigPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkConfigPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time: _builtins.str,
                 configuration_type: Optional[_builtins.str] = None,
                 content: Optional[_builtins.str] = None,
                 filename: Optional[_builtins.str] = None):
        """
        SparkConfig Properties for a Big Data pool powered by Apache Spark
        :param _builtins.str time: The last update time of the spark config properties file.
        :param _builtins.str configuration_type: The type of the spark config properties file.
        :param _builtins.str content: The spark config properties.
        :param _builtins.str filename: The filename of the spark config properties file.
        """
        pulumi.set(__self__, "time", time)
        if configuration_type is not None:
            pulumi.set(__self__, "configuration_type", configuration_type)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.str:
        """
        The last update time of the spark config properties file.
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="configurationType")
    def configuration_type(self) -> Optional[_builtins.str]:
        """
        The type of the spark config properties file.
        """
        return pulumi.get(self, "configuration_type")

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        """
        The spark config properties.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter
    def filename(self) -> Optional[_builtins.str]:
        """
        The filename of the spark config properties file.
        """
        return pulumi.get(self, "filename")


@pulumi.output_type
class SqlPoolVulnerabilityAssessmentRuleBaselineItemResponse(dict):
    """
    Properties for an Sql pool vulnerability assessment rule baseline's result.
    """
    def __init__(__self__, *,
                 result: Sequence[_builtins.str]):
        """
        Properties for an Sql pool vulnerability assessment rule baseline's result.
        :param Sequence[_builtins.str] result: The rule baseline result
        """
        pulumi.set(__self__, "result", result)

    @_builtins.property
    @pulumi.getter
    def result(self) -> Sequence[_builtins.str]:
        """
        The rule baseline result
        """
        return pulumi.get(self, "result")


@pulumi.output_type
class SsisEnvironmentReferenceResponse(dict):
    """
    Ssis environment reference.
    """
    def __init__(__self__, *,
                 environment_folder_name: Optional[_builtins.str] = None,
                 environment_name: Optional[_builtins.str] = None,
                 id: Optional[_builtins.float] = None,
                 reference_type: Optional[_builtins.str] = None):
        """
        Ssis environment reference.
        :param _builtins.str environment_folder_name: Environment folder name.
        :param _builtins.str environment_name: Environment name.
        :param _builtins.float id: Environment reference id.
        :param _builtins.str reference_type: Reference type
        """
        if environment_folder_name is not None:
            pulumi.set(__self__, "environment_folder_name", environment_folder_name)
        if environment_name is not None:
            pulumi.set(__self__, "environment_name", environment_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if reference_type is not None:
            pulumi.set(__self__, "reference_type", reference_type)

    @_builtins.property
    @pulumi.getter(name="environmentFolderName")
    def environment_folder_name(self) -> Optional[_builtins.str]:
        """
        Environment folder name.
        """
        return pulumi.get(self, "environment_folder_name")

    @_builtins.property
    @pulumi.getter(name="environmentName")
    def environment_name(self) -> Optional[_builtins.str]:
        """
        Environment name.
        """
        return pulumi.get(self, "environment_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Environment reference id.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="referenceType")
    def reference_type(self) -> Optional[_builtins.str]:
        """
        Reference type
        """
        return pulumi.get(self, "reference_type")


@pulumi.output_type
class SsisEnvironmentResponse(dict):
    """
    Ssis environment.
    """
    def __init__(__self__, *,
                 type: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 folder_id: Optional[_builtins.float] = None,
                 id: Optional[_builtins.float] = None,
                 name: Optional[_builtins.str] = None,
                 variables: Optional[Sequence['outputs.SsisVariableResponse']] = None):
        """
        Ssis environment.
        :param _builtins.str type: The type of SSIS object metadata.
               Expected value is 'Environment'.
        :param _builtins.str description: Metadata description.
        :param _builtins.float folder_id: Folder id which contains environment.
        :param _builtins.float id: Metadata id.
        :param _builtins.str name: Metadata name.
        :param Sequence['SsisVariableResponse'] variables: Variable in environment
        """
        pulumi.set(__self__, "type", 'Environment')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of SSIS object metadata.
        Expected value is 'Environment'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Metadata description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[_builtins.float]:
        """
        Folder id which contains environment.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Metadata id.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Metadata name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[Sequence['outputs.SsisVariableResponse']]:
        """
        Variable in environment
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class SsisFolderResponse(dict):
    """
    Ssis folder.
    """
    def __init__(__self__, *,
                 type: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.float] = None,
                 name: Optional[_builtins.str] = None):
        """
        Ssis folder.
        :param _builtins.str type: The type of SSIS object metadata.
               Expected value is 'Folder'.
        :param _builtins.str description: Metadata description.
        :param _builtins.float id: Metadata id.
        :param _builtins.str name: Metadata name.
        """
        pulumi.set(__self__, "type", 'Folder')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of SSIS object metadata.
        Expected value is 'Folder'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Metadata description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Metadata id.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Metadata name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SsisPackageResponse(dict):
    """
    Ssis Package.
    """
    def __init__(__self__, *,
                 type: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 folder_id: Optional[_builtins.float] = None,
                 id: Optional[_builtins.float] = None,
                 name: Optional[_builtins.str] = None,
                 parameters: Optional[Sequence['outputs.SsisParameterResponse']] = None,
                 project_id: Optional[_builtins.float] = None,
                 project_version: Optional[_builtins.float] = None):
        """
        Ssis Package.
        :param _builtins.str type: The type of SSIS object metadata.
               Expected value is 'Package'.
        :param _builtins.str description: Metadata description.
        :param _builtins.float folder_id: Folder id which contains package.
        :param _builtins.float id: Metadata id.
        :param _builtins.str name: Metadata name.
        :param Sequence['SsisParameterResponse'] parameters: Parameters in package
        :param _builtins.float project_id: Project id which contains package.
        :param _builtins.float project_version: Project version which contains package.
        """
        pulumi.set(__self__, "type", 'Package')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if project_version is not None:
            pulumi.set(__self__, "project_version", project_version)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of SSIS object metadata.
        Expected value is 'Package'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Metadata description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[_builtins.float]:
        """
        Folder id which contains package.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Metadata id.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Metadata name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.SsisParameterResponse']]:
        """
        Parameters in package
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.float]:
        """
        Project id which contains package.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="projectVersion")
    def project_version(self) -> Optional[_builtins.float]:
        """
        Project version which contains package.
        """
        return pulumi.get(self, "project_version")


@pulumi.output_type
class SsisParameterResponse(dict):
    """
    Ssis parameter.
    """
    def __init__(__self__, *,
                 data_type: Optional[_builtins.str] = None,
                 default_value: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 design_default_value: Optional[_builtins.str] = None,
                 id: Optional[_builtins.float] = None,
                 name: Optional[_builtins.str] = None,
                 required: Optional[_builtins.bool] = None,
                 sensitive: Optional[_builtins.bool] = None,
                 sensitive_default_value: Optional[_builtins.str] = None,
                 value_set: Optional[_builtins.bool] = None,
                 value_type: Optional[_builtins.str] = None,
                 variable: Optional[_builtins.str] = None):
        """
        Ssis parameter.
        :param _builtins.str data_type: Parameter type.
        :param _builtins.str default_value: Default value of parameter.
        :param _builtins.str description: Parameter description.
        :param _builtins.str design_default_value: Design default value of parameter.
        :param _builtins.float id: Parameter id.
        :param _builtins.str name: Parameter name.
        :param _builtins.bool required: Whether parameter is required.
        :param _builtins.bool sensitive: Whether parameter is sensitive.
        :param _builtins.str sensitive_default_value: Default sensitive value of parameter.
        :param _builtins.bool value_set: Parameter value set.
        :param _builtins.str value_type: Parameter value type.
        :param _builtins.str variable: Parameter reference variable.
        """
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if design_default_value is not None:
            pulumi.set(__self__, "design_default_value", design_default_value)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if sensitive is not None:
            pulumi.set(__self__, "sensitive", sensitive)
        if sensitive_default_value is not None:
            pulumi.set(__self__, "sensitive_default_value", sensitive_default_value)
        if value_set is not None:
            pulumi.set(__self__, "value_set", value_set)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)
        if variable is not None:
            pulumi.set(__self__, "variable", variable)

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        Parameter type.
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[_builtins.str]:
        """
        Default value of parameter.
        """
        return pulumi.get(self, "default_value")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Parameter description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="designDefaultValue")
    def design_default_value(self) -> Optional[_builtins.str]:
        """
        Design default value of parameter.
        """
        return pulumi.get(self, "design_default_value")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Parameter id.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Parameter name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        """
        Whether parameter is required.
        """
        return pulumi.get(self, "required")

    @_builtins.property
    @pulumi.getter
    def sensitive(self) -> Optional[_builtins.bool]:
        """
        Whether parameter is sensitive.
        """
        return pulumi.get(self, "sensitive")

    @_builtins.property
    @pulumi.getter(name="sensitiveDefaultValue")
    def sensitive_default_value(self) -> Optional[_builtins.str]:
        """
        Default sensitive value of parameter.
        """
        return pulumi.get(self, "sensitive_default_value")

    @_builtins.property
    @pulumi.getter(name="valueSet")
    def value_set(self) -> Optional[_builtins.bool]:
        """
        Parameter value set.
        """
        return pulumi.get(self, "value_set")

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[_builtins.str]:
        """
        Parameter value type.
        """
        return pulumi.get(self, "value_type")

    @_builtins.property
    @pulumi.getter
    def variable(self) -> Optional[_builtins.str]:
        """
        Parameter reference variable.
        """
        return pulumi.get(self, "variable")


@pulumi.output_type
class SsisProjectResponse(dict):
    """
    Ssis project.
    """
    def __init__(__self__, *,
                 type: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 environment_refs: Optional[Sequence['outputs.SsisEnvironmentReferenceResponse']] = None,
                 folder_id: Optional[_builtins.float] = None,
                 id: Optional[_builtins.float] = None,
                 name: Optional[_builtins.str] = None,
                 parameters: Optional[Sequence['outputs.SsisParameterResponse']] = None,
                 version: Optional[_builtins.float] = None):
        """
        Ssis project.
        :param _builtins.str type: The type of SSIS object metadata.
               Expected value is 'Project'.
        :param _builtins.str description: Metadata description.
        :param Sequence['SsisEnvironmentReferenceResponse'] environment_refs: Environment reference in project
        :param _builtins.float folder_id: Folder id which contains project.
        :param _builtins.float id: Metadata id.
        :param _builtins.str name: Metadata name.
        :param Sequence['SsisParameterResponse'] parameters: Parameters in project
        :param _builtins.float version: Project version.
        """
        pulumi.set(__self__, "type", 'Project')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if environment_refs is not None:
            pulumi.set(__self__, "environment_refs", environment_refs)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of SSIS object metadata.
        Expected value is 'Project'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Metadata description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="environmentRefs")
    def environment_refs(self) -> Optional[Sequence['outputs.SsisEnvironmentReferenceResponse']]:
        """
        Environment reference in project
        """
        return pulumi.get(self, "environment_refs")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[_builtins.float]:
        """
        Folder id which contains project.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Metadata id.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Metadata name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.SsisParameterResponse']]:
        """
        Parameters in project
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.float]:
        """
        Project version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SsisVariableResponse(dict):
    """
    Ssis variable.
    """
    def __init__(__self__, *,
                 data_type: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.float] = None,
                 name: Optional[_builtins.str] = None,
                 sensitive: Optional[_builtins.bool] = None,
                 sensitive_value: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        Ssis variable.
        :param _builtins.str data_type: Variable type.
        :param _builtins.str description: Variable description.
        :param _builtins.float id: Variable id.
        :param _builtins.str name: Variable name.
        :param _builtins.bool sensitive: Whether variable is sensitive.
        :param _builtins.str sensitive_value: Variable sensitive value.
        :param _builtins.str value: Variable value.
        """
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sensitive is not None:
            pulumi.set(__self__, "sensitive", sensitive)
        if sensitive_value is not None:
            pulumi.set(__self__, "sensitive_value", sensitive_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        Variable type.
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Variable description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.float]:
        """
        Variable id.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Variable name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def sensitive(self) -> Optional[_builtins.bool]:
        """
        Whether variable is sensitive.
        """
        return pulumi.get(self, "sensitive")

    @_builtins.property
    @pulumi.getter(name="sensitiveValue")
    def sensitive_value(self) -> Optional[_builtins.str]:
        """
        Variable sensitive value.
        """
        return pulumi.get(self, "sensitive_value")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Variable value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 created_by_type: Optional[_builtins.str] = None,
                 last_modified_at: Optional[_builtins.str] = None,
                 last_modified_by: Optional[_builtins.str] = None,
                 last_modified_by_type: Optional[_builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param _builtins.str created_at: The timestamp of resource creation (UTC).
        :param _builtins.str created_by: The identity that created the resource.
        :param _builtins.str created_by_type: The type of identity that created the resource.
        :param _builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param _builtins.str last_modified_by: The identity that last modified the resource.
        :param _builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @_builtins.property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @_builtins.property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[_builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @_builtins.property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TableLevelSharingPropertiesResponse(dict):
    """
    Tables that will be included and excluded in the follower database
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalTablesToExclude":
            suggest = "external_tables_to_exclude"
        elif key == "externalTablesToInclude":
            suggest = "external_tables_to_include"
        elif key == "materializedViewsToExclude":
            suggest = "materialized_views_to_exclude"
        elif key == "materializedViewsToInclude":
            suggest = "materialized_views_to_include"
        elif key == "tablesToExclude":
            suggest = "tables_to_exclude"
        elif key == "tablesToInclude":
            suggest = "tables_to_include"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableLevelSharingPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableLevelSharingPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableLevelSharingPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external_tables_to_exclude: Optional[Sequence[_builtins.str]] = None,
                 external_tables_to_include: Optional[Sequence[_builtins.str]] = None,
                 materialized_views_to_exclude: Optional[Sequence[_builtins.str]] = None,
                 materialized_views_to_include: Optional[Sequence[_builtins.str]] = None,
                 tables_to_exclude: Optional[Sequence[_builtins.str]] = None,
                 tables_to_include: Optional[Sequence[_builtins.str]] = None):
        """
        Tables that will be included and excluded in the follower database
        :param Sequence[_builtins.str] external_tables_to_exclude: List of external tables exclude from the follower database
        :param Sequence[_builtins.str] external_tables_to_include: List of external tables to include in the follower database
        :param Sequence[_builtins.str] materialized_views_to_exclude: List of materialized views exclude from the follower database
        :param Sequence[_builtins.str] materialized_views_to_include: List of materialized views to include in the follower database
        :param Sequence[_builtins.str] tables_to_exclude: List of tables to exclude from the follower database
        :param Sequence[_builtins.str] tables_to_include: List of tables to include in the follower database
        """
        if external_tables_to_exclude is not None:
            pulumi.set(__self__, "external_tables_to_exclude", external_tables_to_exclude)
        if external_tables_to_include is not None:
            pulumi.set(__self__, "external_tables_to_include", external_tables_to_include)
        if materialized_views_to_exclude is not None:
            pulumi.set(__self__, "materialized_views_to_exclude", materialized_views_to_exclude)
        if materialized_views_to_include is not None:
            pulumi.set(__self__, "materialized_views_to_include", materialized_views_to_include)
        if tables_to_exclude is not None:
            pulumi.set(__self__, "tables_to_exclude", tables_to_exclude)
        if tables_to_include is not None:
            pulumi.set(__self__, "tables_to_include", tables_to_include)

    @_builtins.property
    @pulumi.getter(name="externalTablesToExclude")
    def external_tables_to_exclude(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of external tables exclude from the follower database
        """
        return pulumi.get(self, "external_tables_to_exclude")

    @_builtins.property
    @pulumi.getter(name="externalTablesToInclude")
    def external_tables_to_include(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of external tables to include in the follower database
        """
        return pulumi.get(self, "external_tables_to_include")

    @_builtins.property
    @pulumi.getter(name="materializedViewsToExclude")
    def materialized_views_to_exclude(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of materialized views exclude from the follower database
        """
        return pulumi.get(self, "materialized_views_to_exclude")

    @_builtins.property
    @pulumi.getter(name="materializedViewsToInclude")
    def materialized_views_to_include(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of materialized views to include in the follower database
        """
        return pulumi.get(self, "materialized_views_to_include")

    @_builtins.property
    @pulumi.getter(name="tablesToExclude")
    def tables_to_exclude(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of tables to exclude from the follower database
        """
        return pulumi.get(self, "tables_to_exclude")

    @_builtins.property
    @pulumi.getter(name="tablesToInclude")
    def tables_to_include(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of tables to include in the follower database
        """
        return pulumi.get(self, "tables_to_include")


@pulumi.output_type
class UserAssignedManagedIdentityResponse(dict):
    """
    User Assigned Managed Identity
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedManagedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedManagedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedManagedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 principal_id: _builtins.str):
        """
        User Assigned Managed Identity
        :param _builtins.str client_id: The client ID.
        :param _builtins.str principal_id: The principal ID.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The client ID.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The principal ID.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class VirtualNetworkProfileResponse(dict):
    """
    Virtual Network Profile
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeSubnetId":
            suggest = "compute_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_subnet_id: Optional[_builtins.str] = None):
        """
        Virtual Network Profile
        :param _builtins.str compute_subnet_id: Subnet ID used for computes in workspace
        """
        if compute_subnet_id is not None:
            pulumi.set(__self__, "compute_subnet_id", compute_subnet_id)

    @_builtins.property
    @pulumi.getter(name="computeSubnetId")
    def compute_subnet_id(self) -> Optional[_builtins.str]:
        """
        Subnet ID used for computes in workspace
        """
        return pulumi.get(self, "compute_subnet_id")


@pulumi.output_type
class VulnerabilityAssessmentRecurringScansPropertiesResponse(dict):
    """
    Properties of a Vulnerability Assessment recurring scans.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailSubscriptionAdmins":
            suggest = "email_subscription_admins"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VulnerabilityAssessmentRecurringScansPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VulnerabilityAssessmentRecurringScansPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VulnerabilityAssessmentRecurringScansPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_subscription_admins: Optional[_builtins.bool] = None,
                 emails: Optional[Sequence[_builtins.str]] = None,
                 is_enabled: Optional[_builtins.bool] = None):
        """
        Properties of a Vulnerability Assessment recurring scans.
        :param _builtins.bool email_subscription_admins: Specifies that the schedule scan notification will be is sent to the subscription administrators.
        :param Sequence[_builtins.str] emails: Specifies an array of e-mail addresses to which the scan notification is sent.
        :param _builtins.bool is_enabled: Recurring scans state.
        """
        if email_subscription_admins is None:
            email_subscription_admins = True
        if email_subscription_admins is not None:
            pulumi.set(__self__, "email_subscription_admins", email_subscription_admins)
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @_builtins.property
    @pulumi.getter(name="emailSubscriptionAdmins")
    def email_subscription_admins(self) -> Optional[_builtins.bool]:
        """
        Specifies that the schedule scan notification will be is sent to the subscription administrators.
        """
        return pulumi.get(self, "email_subscription_admins")

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies an array of e-mail addresses to which the scan notification is sent.
        """
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[_builtins.bool]:
        """
        Recurring scans state.
        """
        return pulumi.get(self, "is_enabled")


@pulumi.output_type
class WorkspaceKeyDetailsResponse(dict):
    """
    Details of the customer managed key associated with the workspace
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultUrl":
            suggest = "key_vault_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceKeyDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceKeyDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceKeyDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_url: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        Details of the customer managed key associated with the workspace
        :param _builtins.str key_vault_url: Workspace Key sub-resource key vault url
        :param _builtins.str name: Workspace Key sub-resource name
        """
        if key_vault_url is not None:
            pulumi.set(__self__, "key_vault_url", key_vault_url)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="keyVaultUrl")
    def key_vault_url(self) -> Optional[_builtins.str]:
        """
        Workspace Key sub-resource key vault url
        """
        return pulumi.get(self, "key_vault_url")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Workspace Key sub-resource name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WorkspaceRepositoryConfigurationResponse(dict):
    """
    Git integration settings
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountName":
            suggest = "account_name"
        elif key == "collaborationBranch":
            suggest = "collaboration_branch"
        elif key == "hostName":
            suggest = "host_name"
        elif key == "lastCommitId":
            suggest = "last_commit_id"
        elif key == "projectName":
            suggest = "project_name"
        elif key == "repositoryName":
            suggest = "repository_name"
        elif key == "rootFolder":
            suggest = "root_folder"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceRepositoryConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceRepositoryConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceRepositoryConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_name: Optional[_builtins.str] = None,
                 collaboration_branch: Optional[_builtins.str] = None,
                 host_name: Optional[_builtins.str] = None,
                 last_commit_id: Optional[_builtins.str] = None,
                 project_name: Optional[_builtins.str] = None,
                 repository_name: Optional[_builtins.str] = None,
                 root_folder: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        Git integration settings
        :param _builtins.str account_name: Account name
        :param _builtins.str collaboration_branch: Collaboration branch
        :param _builtins.str host_name: GitHub Enterprise host name. For example: `https://github.mydomain.com`
        :param _builtins.str last_commit_id: The last commit ID
        :param _builtins.str project_name: VSTS project name
        :param _builtins.str repository_name: Repository name
        :param _builtins.str root_folder: Root folder to use in the repository
        :param _builtins.str tenant_id: The VSTS tenant ID
        :param _builtins.str type: Type of workspace repositoryID configuration. Example WorkspaceVSTSConfiguration, WorkspaceGitHubConfiguration
        """
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if collaboration_branch is not None:
            pulumi.set(__self__, "collaboration_branch", collaboration_branch)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if project_name is not None:
            pulumi.set(__self__, "project_name", project_name)
        if repository_name is not None:
            pulumi.set(__self__, "repository_name", repository_name)
        if root_folder is not None:
            pulumi.set(__self__, "root_folder", root_folder)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[_builtins.str]:
        """
        Account name
        """
        return pulumi.get(self, "account_name")

    @_builtins.property
    @pulumi.getter(name="collaborationBranch")
    def collaboration_branch(self) -> Optional[_builtins.str]:
        """
        Collaboration branch
        """
        return pulumi.get(self, "collaboration_branch")

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[_builtins.str]:
        """
        GitHub Enterprise host name. For example: `https://github.mydomain.com`
        """
        return pulumi.get(self, "host_name")

    @_builtins.property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[_builtins.str]:
        """
        The last commit ID
        """
        return pulumi.get(self, "last_commit_id")

    @_builtins.property
    @pulumi.getter(name="projectName")
    def project_name(self) -> Optional[_builtins.str]:
        """
        VSTS project name
        """
        return pulumi.get(self, "project_name")

    @_builtins.property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> Optional[_builtins.str]:
        """
        Repository name
        """
        return pulumi.get(self, "repository_name")

    @_builtins.property
    @pulumi.getter(name="rootFolder")
    def root_folder(self) -> Optional[_builtins.str]:
        """
        Root folder to use in the repository
        """
        return pulumi.get(self, "root_folder")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        The VSTS tenant ID
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of workspace repositoryID configuration. Example WorkspaceVSTSConfiguration, WorkspaceGitHubConfiguration
        """
        return pulumi.get(self, "type")


