# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'AddRemoveIncrementalNamedPartitionScalingMechanismArgs',
    'AddRemoveIncrementalNamedPartitionScalingMechanismArgsDict',
    'ApplicationHealthPolicyArgs',
    'ApplicationHealthPolicyArgsDict',
    'ApplicationTypeVersionsCleanupPolicyArgs',
    'ApplicationTypeVersionsCleanupPolicyArgsDict',
    'ApplicationUpgradePolicyArgs',
    'ApplicationUpgradePolicyArgsDict',
    'ApplicationUserAssignedIdentityArgs',
    'ApplicationUserAssignedIdentityArgsDict',
    'AveragePartitionLoadScalingTriggerArgs',
    'AveragePartitionLoadScalingTriggerArgsDict',
    'AverageServiceLoadScalingTriggerArgs',
    'AverageServiceLoadScalingTriggerArgsDict',
    'AzureActiveDirectoryArgs',
    'AzureActiveDirectoryArgsDict',
    'ClientCertificateArgs',
    'ClientCertificateArgsDict',
    'EndpointRangeDescriptionArgs',
    'EndpointRangeDescriptionArgsDict',
    'FrontendConfigurationArgs',
    'FrontendConfigurationArgsDict',
    'IPTagArgs',
    'IPTagArgsDict',
    'LoadBalancingRuleArgs',
    'LoadBalancingRuleArgsDict',
    'ManagedIdentityArgs',
    'ManagedIdentityArgsDict',
    'NamedPartitionSchemeArgs',
    'NamedPartitionSchemeArgsDict',
    'NetworkSecurityRuleArgs',
    'NetworkSecurityRuleArgsDict',
    'NodeTypeSkuArgs',
    'NodeTypeSkuArgsDict',
    'PartitionInstanceCountScaleMechanismArgs',
    'PartitionInstanceCountScaleMechanismArgsDict',
    'RollingUpgradeMonitoringPolicyArgs',
    'RollingUpgradeMonitoringPolicyArgsDict',
    'ScalingPolicyArgs',
    'ScalingPolicyArgsDict',
    'ServiceCorrelationArgs',
    'ServiceCorrelationArgsDict',
    'ServiceEndpointArgs',
    'ServiceEndpointArgsDict',
    'ServiceLoadMetricArgs',
    'ServiceLoadMetricArgsDict',
    'ServicePlacementInvalidDomainPolicyArgs',
    'ServicePlacementInvalidDomainPolicyArgsDict',
    'ServicePlacementNonPartiallyPlaceServicePolicyArgs',
    'ServicePlacementNonPartiallyPlaceServicePolicyArgsDict',
    'ServicePlacementPreferPrimaryDomainPolicyArgs',
    'ServicePlacementPreferPrimaryDomainPolicyArgsDict',
    'ServicePlacementRequireDomainDistributionPolicyArgs',
    'ServicePlacementRequireDomainDistributionPolicyArgsDict',
    'ServicePlacementRequiredDomainPolicyArgs',
    'ServicePlacementRequiredDomainPolicyArgsDict',
    'ServiceTypeHealthPolicyArgs',
    'ServiceTypeHealthPolicyArgsDict',
    'SettingsParameterDescriptionArgs',
    'SettingsParameterDescriptionArgsDict',
    'SettingsSectionDescriptionArgs',
    'SettingsSectionDescriptionArgsDict',
    'SingletonPartitionSchemeArgs',
    'SingletonPartitionSchemeArgsDict',
    'SkuArgs',
    'SkuArgsDict',
    'StatefulServicePropertiesArgs',
    'StatefulServicePropertiesArgsDict',
    'StatelessServicePropertiesArgs',
    'StatelessServicePropertiesArgsDict',
    'SubResourceArgs',
    'SubResourceArgsDict',
    'SubnetArgs',
    'SubnetArgsDict',
    'UniformInt64RangePartitionSchemeArgs',
    'UniformInt64RangePartitionSchemeArgsDict',
    'VMSSExtensionArgs',
    'VMSSExtensionArgsDict',
    'VaultCertificateArgs',
    'VaultCertificateArgsDict',
    'VaultSecretGroupArgs',
    'VaultSecretGroupArgsDict',
    'VmImagePlanArgs',
    'VmImagePlanArgsDict',
    'VmManagedIdentityArgs',
    'VmManagedIdentityArgsDict',
    'VmssDataDiskArgs',
    'VmssDataDiskArgsDict',
]

MYPY = False

if not MYPY:
    class AddRemoveIncrementalNamedPartitionScalingMechanismArgsDict(TypedDict):
        """
        Represents a scaling mechanism for adding or removing named partitions of a stateless service. Partition names are in the format '0','1'...'N-1'.
        """
        kind: pulumi.Input[str]
        """
        Enumerates the ways that a service can be partitioned.
        Expected value is 'AddRemoveIncrementalNamedPartition'.
        """
        max_partition_count: pulumi.Input[int]
        """
        Maximum number of named partitions of the service.
        """
        min_partition_count: pulumi.Input[int]
        """
        Minimum number of named partitions of the service.
        """
        scale_increment: pulumi.Input[int]
        """
        The number of instances to add or remove during a scaling operation.
        """
elif False:
    AddRemoveIncrementalNamedPartitionScalingMechanismArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddRemoveIncrementalNamedPartitionScalingMechanismArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 max_partition_count: pulumi.Input[int],
                 min_partition_count: pulumi.Input[int],
                 scale_increment: pulumi.Input[int]):
        """
        Represents a scaling mechanism for adding or removing named partitions of a stateless service. Partition names are in the format '0','1'...'N-1'.
        :param pulumi.Input[str] kind: Enumerates the ways that a service can be partitioned.
               Expected value is 'AddRemoveIncrementalNamedPartition'.
        :param pulumi.Input[int] max_partition_count: Maximum number of named partitions of the service.
        :param pulumi.Input[int] min_partition_count: Minimum number of named partitions of the service.
        :param pulumi.Input[int] scale_increment: The number of instances to add or remove during a scaling operation.
        """
        pulumi.set(__self__, "kind", 'AddRemoveIncrementalNamedPartition')
        pulumi.set(__self__, "max_partition_count", max_partition_count)
        pulumi.set(__self__, "min_partition_count", min_partition_count)
        pulumi.set(__self__, "scale_increment", scale_increment)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        Enumerates the ways that a service can be partitioned.
        Expected value is 'AddRemoveIncrementalNamedPartition'.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="maxPartitionCount")
    def max_partition_count(self) -> pulumi.Input[int]:
        """
        Maximum number of named partitions of the service.
        """
        return pulumi.get(self, "max_partition_count")

    @max_partition_count.setter
    def max_partition_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_partition_count", value)

    @property
    @pulumi.getter(name="minPartitionCount")
    def min_partition_count(self) -> pulumi.Input[int]:
        """
        Minimum number of named partitions of the service.
        """
        return pulumi.get(self, "min_partition_count")

    @min_partition_count.setter
    def min_partition_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_partition_count", value)

    @property
    @pulumi.getter(name="scaleIncrement")
    def scale_increment(self) -> pulumi.Input[int]:
        """
        The number of instances to add or remove during a scaling operation.
        """
        return pulumi.get(self, "scale_increment")

    @scale_increment.setter
    def scale_increment(self, value: pulumi.Input[int]):
        pulumi.set(self, "scale_increment", value)


if not MYPY:
    class ApplicationHealthPolicyArgsDict(TypedDict):
        """
        Defines a health policy used to evaluate the health of an application or one of its children entities.
        """
        consider_warning_as_error: pulumi.Input[bool]
        """
        Indicates whether warnings are treated with the same severity as errors.
        """
        max_percent_unhealthy_deployed_applications: pulumi.Input[int]
        """
        The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
        The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
        This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
        The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
        """
        default_service_type_health_policy: NotRequired[pulumi.Input['ServiceTypeHealthPolicyArgsDict']]
        """
        The health policy used by default to evaluate the health of a service type.
        """
        service_type_health_policy_map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['ServiceTypeHealthPolicyArgsDict']]]]
        """
        The map with service type health policy per service type name. The map is empty by default.
        """
elif False:
    ApplicationHealthPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationHealthPolicyArgs:
    def __init__(__self__, *,
                 consider_warning_as_error: pulumi.Input[bool],
                 max_percent_unhealthy_deployed_applications: pulumi.Input[int],
                 default_service_type_health_policy: Optional[pulumi.Input['ServiceTypeHealthPolicyArgs']] = None,
                 service_type_health_policy_map: Optional[pulumi.Input[Mapping[str, pulumi.Input['ServiceTypeHealthPolicyArgs']]]] = None):
        """
        Defines a health policy used to evaluate the health of an application or one of its children entities.

        :param pulumi.Input[bool] consider_warning_as_error: Indicates whether warnings are treated with the same severity as errors.
        :param pulumi.Input[int] max_percent_unhealthy_deployed_applications: The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
               The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
               This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
               The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
        :param pulumi.Input['ServiceTypeHealthPolicyArgs'] default_service_type_health_policy: The health policy used by default to evaluate the health of a service type.
        :param pulumi.Input[Mapping[str, pulumi.Input['ServiceTypeHealthPolicyArgs']]] service_type_health_policy_map: The map with service type health policy per service type name. The map is empty by default.
        """
        pulumi.set(__self__, "consider_warning_as_error", consider_warning_as_error)
        pulumi.set(__self__, "max_percent_unhealthy_deployed_applications", max_percent_unhealthy_deployed_applications)
        if default_service_type_health_policy is not None:
            pulumi.set(__self__, "default_service_type_health_policy", default_service_type_health_policy)
        if service_type_health_policy_map is not None:
            pulumi.set(__self__, "service_type_health_policy_map", service_type_health_policy_map)

    @property
    @pulumi.getter(name="considerWarningAsError")
    def consider_warning_as_error(self) -> pulumi.Input[bool]:
        """
        Indicates whether warnings are treated with the same severity as errors.
        """
        return pulumi.get(self, "consider_warning_as_error")

    @consider_warning_as_error.setter
    def consider_warning_as_error(self, value: pulumi.Input[bool]):
        pulumi.set(self, "consider_warning_as_error", value)

    @property
    @pulumi.getter(name="maxPercentUnhealthyDeployedApplications")
    def max_percent_unhealthy_deployed_applications(self) -> pulumi.Input[int]:
        """
        The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100.
        The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error.
        This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster.
        The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.
        """
        return pulumi.get(self, "max_percent_unhealthy_deployed_applications")

    @max_percent_unhealthy_deployed_applications.setter
    def max_percent_unhealthy_deployed_applications(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_percent_unhealthy_deployed_applications", value)

    @property
    @pulumi.getter(name="defaultServiceTypeHealthPolicy")
    def default_service_type_health_policy(self) -> Optional[pulumi.Input['ServiceTypeHealthPolicyArgs']]:
        """
        The health policy used by default to evaluate the health of a service type.
        """
        return pulumi.get(self, "default_service_type_health_policy")

    @default_service_type_health_policy.setter
    def default_service_type_health_policy(self, value: Optional[pulumi.Input['ServiceTypeHealthPolicyArgs']]):
        pulumi.set(self, "default_service_type_health_policy", value)

    @property
    @pulumi.getter(name="serviceTypeHealthPolicyMap")
    def service_type_health_policy_map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ServiceTypeHealthPolicyArgs']]]]:
        """
        The map with service type health policy per service type name. The map is empty by default.
        """
        return pulumi.get(self, "service_type_health_policy_map")

    @service_type_health_policy_map.setter
    def service_type_health_policy_map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ServiceTypeHealthPolicyArgs']]]]):
        pulumi.set(self, "service_type_health_policy_map", value)


if not MYPY:
    class ApplicationTypeVersionsCleanupPolicyArgsDict(TypedDict):
        """
        The policy used to clean up unused versions. When the policy is not specified explicitly, the default unused application versions to keep will be 3.
        """
        max_unused_versions_to_keep: pulumi.Input[int]
        """
        Number of unused versions per application type to keep.
        """
elif False:
    ApplicationTypeVersionsCleanupPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationTypeVersionsCleanupPolicyArgs:
    def __init__(__self__, *,
                 max_unused_versions_to_keep: pulumi.Input[int]):
        """
        The policy used to clean up unused versions. When the policy is not specified explicitly, the default unused application versions to keep will be 3.
        :param pulumi.Input[int] max_unused_versions_to_keep: Number of unused versions per application type to keep.
        """
        pulumi.set(__self__, "max_unused_versions_to_keep", max_unused_versions_to_keep)

    @property
    @pulumi.getter(name="maxUnusedVersionsToKeep")
    def max_unused_versions_to_keep(self) -> pulumi.Input[int]:
        """
        Number of unused versions per application type to keep.
        """
        return pulumi.get(self, "max_unused_versions_to_keep")

    @max_unused_versions_to_keep.setter
    def max_unused_versions_to_keep(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_unused_versions_to_keep", value)


if not MYPY:
    class ApplicationUpgradePolicyArgsDict(TypedDict):
        """
        Describes the policy for a monitored application upgrade.
        """
        application_health_policy: NotRequired[pulumi.Input['ApplicationHealthPolicyArgsDict']]
        """
        Defines a health policy used to evaluate the health of an application or one of its children entities.
        """
        force_restart: NotRequired[pulumi.Input[bool]]
        """
        If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
        """
        instance_close_delay_duration: NotRequired[pulumi.Input[float]]
        """
        Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
        """
        recreate_application: NotRequired[pulumi.Input[bool]]
        """
        Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
        """
        rolling_upgrade_monitoring_policy: NotRequired[pulumi.Input['RollingUpgradeMonitoringPolicyArgsDict']]
        """
        The policy used for monitoring the application upgrade
        """
        upgrade_mode: NotRequired[pulumi.Input[Union[str, 'RollingUpgradeMode']]]
        """
        The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
        """
        upgrade_replica_set_check_timeout: NotRequired[pulumi.Input[float]]
        """
        The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
        """
elif False:
    ApplicationUpgradePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationUpgradePolicyArgs:
    def __init__(__self__, *,
                 application_health_policy: Optional[pulumi.Input['ApplicationHealthPolicyArgs']] = None,
                 force_restart: Optional[pulumi.Input[bool]] = None,
                 instance_close_delay_duration: Optional[pulumi.Input[float]] = None,
                 recreate_application: Optional[pulumi.Input[bool]] = None,
                 rolling_upgrade_monitoring_policy: Optional[pulumi.Input['RollingUpgradeMonitoringPolicyArgs']] = None,
                 upgrade_mode: Optional[pulumi.Input[Union[str, 'RollingUpgradeMode']]] = None,
                 upgrade_replica_set_check_timeout: Optional[pulumi.Input[float]] = None):
        """
        Describes the policy for a monitored application upgrade.
        :param pulumi.Input['ApplicationHealthPolicyArgs'] application_health_policy: Defines a health policy used to evaluate the health of an application or one of its children entities.
        :param pulumi.Input[bool] force_restart: If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
        :param pulumi.Input[float] instance_close_delay_duration: Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
        :param pulumi.Input[bool] recreate_application: Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
        :param pulumi.Input['RollingUpgradeMonitoringPolicyArgs'] rolling_upgrade_monitoring_policy: The policy used for monitoring the application upgrade
        :param pulumi.Input[Union[str, 'RollingUpgradeMode']] upgrade_mode: The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
        :param pulumi.Input[float] upgrade_replica_set_check_timeout: The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
        """
        if application_health_policy is not None:
            pulumi.set(__self__, "application_health_policy", application_health_policy)
        if force_restart is not None:
            pulumi.set(__self__, "force_restart", force_restart)
        if instance_close_delay_duration is not None:
            pulumi.set(__self__, "instance_close_delay_duration", instance_close_delay_duration)
        if recreate_application is not None:
            pulumi.set(__self__, "recreate_application", recreate_application)
        if rolling_upgrade_monitoring_policy is not None:
            pulumi.set(__self__, "rolling_upgrade_monitoring_policy", rolling_upgrade_monitoring_policy)
        if upgrade_mode is not None:
            pulumi.set(__self__, "upgrade_mode", upgrade_mode)
        if upgrade_replica_set_check_timeout is not None:
            pulumi.set(__self__, "upgrade_replica_set_check_timeout", upgrade_replica_set_check_timeout)

    @property
    @pulumi.getter(name="applicationHealthPolicy")
    def application_health_policy(self) -> Optional[pulumi.Input['ApplicationHealthPolicyArgs']]:
        """
        Defines a health policy used to evaluate the health of an application or one of its children entities.
        """
        return pulumi.get(self, "application_health_policy")

    @application_health_policy.setter
    def application_health_policy(self, value: Optional[pulumi.Input['ApplicationHealthPolicyArgs']]):
        pulumi.set(self, "application_health_policy", value)

    @property
    @pulumi.getter(name="forceRestart")
    def force_restart(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
        """
        return pulumi.get(self, "force_restart")

    @force_restart.setter
    def force_restart(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_restart", value)

    @property
    @pulumi.getter(name="instanceCloseDelayDuration")
    def instance_close_delay_duration(self) -> Optional[pulumi.Input[float]]:
        """
        Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description.
        """
        return pulumi.get(self, "instance_close_delay_duration")

    @instance_close_delay_duration.setter
    def instance_close_delay_duration(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "instance_close_delay_duration", value)

    @property
    @pulumi.getter(name="recreateApplication")
    def recreate_application(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether the application should be recreated on update. If value=true, the rest of the upgrade policy parameters are not allowed.
        """
        return pulumi.get(self, "recreate_application")

    @recreate_application.setter
    def recreate_application(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "recreate_application", value)

    @property
    @pulumi.getter(name="rollingUpgradeMonitoringPolicy")
    def rolling_upgrade_monitoring_policy(self) -> Optional[pulumi.Input['RollingUpgradeMonitoringPolicyArgs']]:
        """
        The policy used for monitoring the application upgrade
        """
        return pulumi.get(self, "rolling_upgrade_monitoring_policy")

    @rolling_upgrade_monitoring_policy.setter
    def rolling_upgrade_monitoring_policy(self, value: Optional[pulumi.Input['RollingUpgradeMonitoringPolicyArgs']]):
        pulumi.set(self, "rolling_upgrade_monitoring_policy", value)

    @property
    @pulumi.getter(name="upgradeMode")
    def upgrade_mode(self) -> Optional[pulumi.Input[Union[str, 'RollingUpgradeMode']]]:
        """
        The mode used to monitor health during a rolling upgrade. The values are Monitored, and UnmonitoredAuto.
        """
        return pulumi.get(self, "upgrade_mode")

    @upgrade_mode.setter
    def upgrade_mode(self, value: Optional[pulumi.Input[Union[str, 'RollingUpgradeMode']]]):
        pulumi.set(self, "upgrade_mode", value)

    @property
    @pulumi.getter(name="upgradeReplicaSetCheckTimeout")
    def upgrade_replica_set_check_timeout(self) -> Optional[pulumi.Input[float]]:
        """
        The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
        """
        return pulumi.get(self, "upgrade_replica_set_check_timeout")

    @upgrade_replica_set_check_timeout.setter
    def upgrade_replica_set_check_timeout(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "upgrade_replica_set_check_timeout", value)


if not MYPY:
    class ApplicationUserAssignedIdentityArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The friendly name of user assigned identity.
        """
        principal_id: pulumi.Input[str]
        """
        The principal id of user assigned identity.
        """
elif False:
    ApplicationUserAssignedIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationUserAssignedIdentityArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 principal_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The friendly name of user assigned identity.
        :param pulumi.Input[str] principal_id: The principal id of user assigned identity.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The friendly name of user assigned identity.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> pulumi.Input[str]:
        """
        The principal id of user assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "principal_id", value)


if not MYPY:
    class AveragePartitionLoadScalingTriggerArgsDict(TypedDict):
        """
        Represents a scaling trigger related to an average load of a metric/resource of a partition.
        """
        kind: pulumi.Input[str]
        """
        Enumerates the ways that a service can be partitioned.
        Expected value is 'AveragePartitionLoadTrigger'.
        """
        lower_load_threshold: pulumi.Input[float]
        """
        The lower limit of the load below which a scale in operation should be performed.
        """
        metric_name: pulumi.Input[str]
        """
        The name of the metric for which usage should be tracked.
        """
        scale_interval: pulumi.Input[str]
        """
        The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
        """
        upper_load_threshold: pulumi.Input[float]
        """
        The upper limit of the load beyond which a scale out operation should be performed.
        """
elif False:
    AveragePartitionLoadScalingTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AveragePartitionLoadScalingTriggerArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 lower_load_threshold: pulumi.Input[float],
                 metric_name: pulumi.Input[str],
                 scale_interval: pulumi.Input[str],
                 upper_load_threshold: pulumi.Input[float]):
        """
        Represents a scaling trigger related to an average load of a metric/resource of a partition.
        :param pulumi.Input[str] kind: Enumerates the ways that a service can be partitioned.
               Expected value is 'AveragePartitionLoadTrigger'.
        :param pulumi.Input[float] lower_load_threshold: The lower limit of the load below which a scale in operation should be performed.
        :param pulumi.Input[str] metric_name: The name of the metric for which usage should be tracked.
        :param pulumi.Input[str] scale_interval: The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
        :param pulumi.Input[float] upper_load_threshold: The upper limit of the load beyond which a scale out operation should be performed.
        """
        pulumi.set(__self__, "kind", 'AveragePartitionLoadTrigger')
        pulumi.set(__self__, "lower_load_threshold", lower_load_threshold)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "scale_interval", scale_interval)
        pulumi.set(__self__, "upper_load_threshold", upper_load_threshold)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        Enumerates the ways that a service can be partitioned.
        Expected value is 'AveragePartitionLoadTrigger'.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="lowerLoadThreshold")
    def lower_load_threshold(self) -> pulumi.Input[float]:
        """
        The lower limit of the load below which a scale in operation should be performed.
        """
        return pulumi.get(self, "lower_load_threshold")

    @lower_load_threshold.setter
    def lower_load_threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "lower_load_threshold", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        The name of the metric for which usage should be tracked.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="scaleInterval")
    def scale_interval(self) -> pulumi.Input[str]:
        """
        The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
        """
        return pulumi.get(self, "scale_interval")

    @scale_interval.setter
    def scale_interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "scale_interval", value)

    @property
    @pulumi.getter(name="upperLoadThreshold")
    def upper_load_threshold(self) -> pulumi.Input[float]:
        """
        The upper limit of the load beyond which a scale out operation should be performed.
        """
        return pulumi.get(self, "upper_load_threshold")

    @upper_load_threshold.setter
    def upper_load_threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "upper_load_threshold", value)


if not MYPY:
    class AverageServiceLoadScalingTriggerArgsDict(TypedDict):
        """
        Represents a scaling policy related to an average load of a metric/resource of a service.
        """
        kind: pulumi.Input[str]
        """
        Enumerates the ways that a service can be partitioned.
        Expected value is 'AverageServiceLoadTrigger'.
        """
        lower_load_threshold: pulumi.Input[float]
        """
        The lower limit of the load below which a scale in operation should be performed.
        """
        metric_name: pulumi.Input[str]
        """
        The name of the metric for which usage should be tracked.
        """
        scale_interval: pulumi.Input[str]
        """
        The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
        """
        upper_load_threshold: pulumi.Input[float]
        """
        The upper limit of the load beyond which a scale out operation should be performed.
        """
        use_only_primary_load: pulumi.Input[bool]
        """
        Flag determines whether only the load of primary replica should be considered for scaling. If set to true, then trigger will only consider the load of primary replicas of stateful service. If set to false, trigger will consider load of all replicas. This parameter cannot be set to true for stateless service.
        """
elif False:
    AverageServiceLoadScalingTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AverageServiceLoadScalingTriggerArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 lower_load_threshold: pulumi.Input[float],
                 metric_name: pulumi.Input[str],
                 scale_interval: pulumi.Input[str],
                 upper_load_threshold: pulumi.Input[float],
                 use_only_primary_load: pulumi.Input[bool]):
        """
        Represents a scaling policy related to an average load of a metric/resource of a service.
        :param pulumi.Input[str] kind: Enumerates the ways that a service can be partitioned.
               Expected value is 'AverageServiceLoadTrigger'.
        :param pulumi.Input[float] lower_load_threshold: The lower limit of the load below which a scale in operation should be performed.
        :param pulumi.Input[str] metric_name: The name of the metric for which usage should be tracked.
        :param pulumi.Input[str] scale_interval: The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
        :param pulumi.Input[float] upper_load_threshold: The upper limit of the load beyond which a scale out operation should be performed.
        :param pulumi.Input[bool] use_only_primary_load: Flag determines whether only the load of primary replica should be considered for scaling. If set to true, then trigger will only consider the load of primary replicas of stateful service. If set to false, trigger will consider load of all replicas. This parameter cannot be set to true for stateless service.
        """
        pulumi.set(__self__, "kind", 'AverageServiceLoadTrigger')
        pulumi.set(__self__, "lower_load_threshold", lower_load_threshold)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "scale_interval", scale_interval)
        pulumi.set(__self__, "upper_load_threshold", upper_load_threshold)
        pulumi.set(__self__, "use_only_primary_load", use_only_primary_load)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        Enumerates the ways that a service can be partitioned.
        Expected value is 'AverageServiceLoadTrigger'.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="lowerLoadThreshold")
    def lower_load_threshold(self) -> pulumi.Input[float]:
        """
        The lower limit of the load below which a scale in operation should be performed.
        """
        return pulumi.get(self, "lower_load_threshold")

    @lower_load_threshold.setter
    def lower_load_threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "lower_load_threshold", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        The name of the metric for which usage should be tracked.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="scaleInterval")
    def scale_interval(self) -> pulumi.Input[str]:
        """
        The period in seconds on which a decision is made whether to scale or not. This property should come in ISO 8601 format "hh:mm:ss".
        """
        return pulumi.get(self, "scale_interval")

    @scale_interval.setter
    def scale_interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "scale_interval", value)

    @property
    @pulumi.getter(name="upperLoadThreshold")
    def upper_load_threshold(self) -> pulumi.Input[float]:
        """
        The upper limit of the load beyond which a scale out operation should be performed.
        """
        return pulumi.get(self, "upper_load_threshold")

    @upper_load_threshold.setter
    def upper_load_threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "upper_load_threshold", value)

    @property
    @pulumi.getter(name="useOnlyPrimaryLoad")
    def use_only_primary_load(self) -> pulumi.Input[bool]:
        """
        Flag determines whether only the load of primary replica should be considered for scaling. If set to true, then trigger will only consider the load of primary replicas of stateful service. If set to false, trigger will consider load of all replicas. This parameter cannot be set to true for stateless service.
        """
        return pulumi.get(self, "use_only_primary_load")

    @use_only_primary_load.setter
    def use_only_primary_load(self, value: pulumi.Input[bool]):
        pulumi.set(self, "use_only_primary_load", value)


if not MYPY:
    class AzureActiveDirectoryArgsDict(TypedDict):
        """
        The settings to enable AAD authentication on the cluster.
        """
        client_application: NotRequired[pulumi.Input[str]]
        """
        Azure active directory client application id.
        """
        cluster_application: NotRequired[pulumi.Input[str]]
        """
        Azure active directory cluster application id.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        Azure active directory tenant id.
        """
elif False:
    AzureActiveDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureActiveDirectoryArgs:
    def __init__(__self__, *,
                 client_application: Optional[pulumi.Input[str]] = None,
                 cluster_application: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        The settings to enable AAD authentication on the cluster.
        :param pulumi.Input[str] client_application: Azure active directory client application id.
        :param pulumi.Input[str] cluster_application: Azure active directory cluster application id.
        :param pulumi.Input[str] tenant_id: Azure active directory tenant id.
        """
        if client_application is not None:
            pulumi.set(__self__, "client_application", client_application)
        if cluster_application is not None:
            pulumi.set(__self__, "cluster_application", cluster_application)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientApplication")
    def client_application(self) -> Optional[pulumi.Input[str]]:
        """
        Azure active directory client application id.
        """
        return pulumi.get(self, "client_application")

    @client_application.setter
    def client_application(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_application", value)

    @property
    @pulumi.getter(name="clusterApplication")
    def cluster_application(self) -> Optional[pulumi.Input[str]]:
        """
        Azure active directory cluster application id.
        """
        return pulumi.get(self, "cluster_application")

    @cluster_application.setter
    def cluster_application(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_application", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        Azure active directory tenant id.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class ClientCertificateArgsDict(TypedDict):
        """
        Client certificate definition.
        """
        is_admin: pulumi.Input[bool]
        """
        Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
        """
        common_name: NotRequired[pulumi.Input[str]]
        """
        Certificate common name.
        """
        issuer_thumbprint: NotRequired[pulumi.Input[str]]
        """
        Issuer thumbprint for the certificate. Only used together with CommonName.
        """
        thumbprint: NotRequired[pulumi.Input[str]]
        """
        Certificate thumbprint.
        """
elif False:
    ClientCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientCertificateArgs:
    def __init__(__self__, *,
                 is_admin: pulumi.Input[bool],
                 common_name: Optional[pulumi.Input[str]] = None,
                 issuer_thumbprint: Optional[pulumi.Input[str]] = None,
                 thumbprint: Optional[pulumi.Input[str]] = None):
        """
        Client certificate definition.
        :param pulumi.Input[bool] is_admin: Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
        :param pulumi.Input[str] common_name: Certificate common name.
        :param pulumi.Input[str] issuer_thumbprint: Issuer thumbprint for the certificate. Only used together with CommonName.
        :param pulumi.Input[str] thumbprint: Certificate thumbprint.
        """
        pulumi.set(__self__, "is_admin", is_admin)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if issuer_thumbprint is not None:
            pulumi.set(__self__, "issuer_thumbprint", issuer_thumbprint)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)

    @property
    @pulumi.getter(name="isAdmin")
    def is_admin(self) -> pulumi.Input[bool]:
        """
        Indicates if the client certificate has admin access to the cluster. Non admin clients can perform only read only operations on the cluster.
        """
        return pulumi.get(self, "is_admin")

    @is_admin.setter
    def is_admin(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_admin", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate common name.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="issuerThumbprint")
    def issuer_thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        Issuer thumbprint for the certificate. Only used together with CommonName.
        """
        return pulumi.get(self, "issuer_thumbprint")

    @issuer_thumbprint.setter
    def issuer_thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer_thumbprint", value)

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate thumbprint.
        """
        return pulumi.get(self, "thumbprint")

    @thumbprint.setter
    def thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thumbprint", value)


if not MYPY:
    class EndpointRangeDescriptionArgsDict(TypedDict):
        """
        Port range details
        """
        end_port: pulumi.Input[int]
        """
        End port of a range of ports
        """
        start_port: pulumi.Input[int]
        """
        Starting port of a range of ports
        """
elif False:
    EndpointRangeDescriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointRangeDescriptionArgs:
    def __init__(__self__, *,
                 end_port: pulumi.Input[int],
                 start_port: pulumi.Input[int]):
        """
        Port range details
        :param pulumi.Input[int] end_port: End port of a range of ports
        :param pulumi.Input[int] start_port: Starting port of a range of ports
        """
        pulumi.set(__self__, "end_port", end_port)
        pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> pulumi.Input[int]:
        """
        End port of a range of ports
        """
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> pulumi.Input[int]:
        """
        Starting port of a range of ports
        """
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class FrontendConfigurationArgsDict(TypedDict):
        """
        Describes the frontend configurations for the node type.
        """
        application_gateway_backend_address_pool_id: NotRequired[pulumi.Input[str]]
        """
        The resource Id of application gateway backend address pool. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/applicationGateways/<applicationGatewayName>/backendAddressPools/<backendAddressPoolName>'.
        """
        ip_address_type: NotRequired[pulumi.Input[Union[str, 'IPAddressType']]]
        """
        The IP address type of this frontend configuration. If omitted the default value is IPv4.
        """
        load_balancer_backend_address_pool_id: NotRequired[pulumi.Input[str]]
        """
        The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/backendAddressPools/<backendAddressPoolName>'.
        """
        load_balancer_inbound_nat_pool_id: NotRequired[pulumi.Input[str]]
        """
        The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/inboundNatPools/<inboundNatPoolName>'.
        """
elif False:
    FrontendConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontendConfigurationArgs:
    def __init__(__self__, *,
                 application_gateway_backend_address_pool_id: Optional[pulumi.Input[str]] = None,
                 ip_address_type: Optional[pulumi.Input[Union[str, 'IPAddressType']]] = None,
                 load_balancer_backend_address_pool_id: Optional[pulumi.Input[str]] = None,
                 load_balancer_inbound_nat_pool_id: Optional[pulumi.Input[str]] = None):
        """
        Describes the frontend configurations for the node type.
        :param pulumi.Input[str] application_gateway_backend_address_pool_id: The resource Id of application gateway backend address pool. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/applicationGateways/<applicationGatewayName>/backendAddressPools/<backendAddressPoolName>'.
        :param pulumi.Input[Union[str, 'IPAddressType']] ip_address_type: The IP address type of this frontend configuration. If omitted the default value is IPv4.
        :param pulumi.Input[str] load_balancer_backend_address_pool_id: The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/backendAddressPools/<backendAddressPoolName>'.
        :param pulumi.Input[str] load_balancer_inbound_nat_pool_id: The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/inboundNatPools/<inboundNatPoolName>'.
        """
        if application_gateway_backend_address_pool_id is not None:
            pulumi.set(__self__, "application_gateway_backend_address_pool_id", application_gateway_backend_address_pool_id)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)
        if load_balancer_backend_address_pool_id is not None:
            pulumi.set(__self__, "load_balancer_backend_address_pool_id", load_balancer_backend_address_pool_id)
        if load_balancer_inbound_nat_pool_id is not None:
            pulumi.set(__self__, "load_balancer_inbound_nat_pool_id", load_balancer_inbound_nat_pool_id)

    @property
    @pulumi.getter(name="applicationGatewayBackendAddressPoolId")
    def application_gateway_backend_address_pool_id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource Id of application gateway backend address pool. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/applicationGateways/<applicationGatewayName>/backendAddressPools/<backendAddressPoolName>'.
        """
        return pulumi.get(self, "application_gateway_backend_address_pool_id")

    @application_gateway_backend_address_pool_id.setter
    def application_gateway_backend_address_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_gateway_backend_address_pool_id", value)

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[pulumi.Input[Union[str, 'IPAddressType']]]:
        """
        The IP address type of this frontend configuration. If omitted the default value is IPv4.
        """
        return pulumi.get(self, "ip_address_type")

    @ip_address_type.setter
    def ip_address_type(self, value: Optional[pulumi.Input[Union[str, 'IPAddressType']]]):
        pulumi.set(self, "ip_address_type", value)

    @property
    @pulumi.getter(name="loadBalancerBackendAddressPoolId")
    def load_balancer_backend_address_pool_id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource Id of the Load Balancer backend address pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/backendAddressPools/<backendAddressPoolName>'.
        """
        return pulumi.get(self, "load_balancer_backend_address_pool_id")

    @load_balancer_backend_address_pool_id.setter
    def load_balancer_backend_address_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_backend_address_pool_id", value)

    @property
    @pulumi.getter(name="loadBalancerInboundNatPoolId")
    def load_balancer_inbound_nat_pool_id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource Id of the Load Balancer inbound NAT pool that the VM instances of the node type are associated with. The format of the resource Id is '/subscriptions/<subscriptionId>/resourceGroups/<resourceGroupName>/providers/Microsoft.Network/loadBalancers/<loadBalancerName>/inboundNatPools/<inboundNatPoolName>'.
        """
        return pulumi.get(self, "load_balancer_inbound_nat_pool_id")

    @load_balancer_inbound_nat_pool_id.setter
    def load_balancer_inbound_nat_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_inbound_nat_pool_id", value)


if not MYPY:
    class IPTagArgsDict(TypedDict):
        """
        IPTag associated with the object.
        """
        ip_tag_type: pulumi.Input[str]
        """
        The IP tag type.
        """
        tag: pulumi.Input[str]
        """
        The value of the IP tag.
        """
elif False:
    IPTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPTagArgs:
    def __init__(__self__, *,
                 ip_tag_type: pulumi.Input[str],
                 tag: pulumi.Input[str]):
        """
        IPTag associated with the object.
        :param pulumi.Input[str] ip_tag_type: The IP tag type.
        :param pulumi.Input[str] tag: The value of the IP tag.
        """
        pulumi.set(__self__, "ip_tag_type", ip_tag_type)
        pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="ipTagType")
    def ip_tag_type(self) -> pulumi.Input[str]:
        """
        The IP tag type.
        """
        return pulumi.get(self, "ip_tag_type")

    @ip_tag_type.setter
    def ip_tag_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_tag_type", value)

    @property
    @pulumi.getter
    def tag(self) -> pulumi.Input[str]:
        """
        The value of the IP tag.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: pulumi.Input[str]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class LoadBalancingRuleArgsDict(TypedDict):
        """
        Describes a load balancing rule.
        """
        backend_port: pulumi.Input[int]
        """
        The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
        """
        frontend_port: pulumi.Input[int]
        """
        The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 1 and 65534.
        """
        probe_protocol: pulumi.Input[Union[str, 'ProbeProtocol']]
        """
        the reference to the load balancer probe used by the load balancing rule.
        """
        protocol: pulumi.Input[Union[str, 'Protocol']]
        """
        The reference to the transport protocol used by the load balancing rule.
        """
        load_distribution: NotRequired[pulumi.Input[str]]
        """
        The load distribution policy for this rule.
        """
        probe_port: NotRequired[pulumi.Input[int]]
        """
        The prob port used by the load balancing rule. Acceptable values are between 1 and 65535.
        """
        probe_request_path: NotRequired[pulumi.Input[str]]
        """
        The probe request path. Only supported for HTTP/HTTPS probes.
        """
elif False:
    LoadBalancingRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancingRuleArgs:
    def __init__(__self__, *,
                 backend_port: pulumi.Input[int],
                 frontend_port: pulumi.Input[int],
                 probe_protocol: pulumi.Input[Union[str, 'ProbeProtocol']],
                 protocol: pulumi.Input[Union[str, 'Protocol']],
                 load_distribution: Optional[pulumi.Input[str]] = None,
                 probe_port: Optional[pulumi.Input[int]] = None,
                 probe_request_path: Optional[pulumi.Input[str]] = None):
        """
        Describes a load balancing rule.
        :param pulumi.Input[int] backend_port: The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
        :param pulumi.Input[int] frontend_port: The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 1 and 65534.
        :param pulumi.Input[Union[str, 'ProbeProtocol']] probe_protocol: the reference to the load balancer probe used by the load balancing rule.
        :param pulumi.Input[Union[str, 'Protocol']] protocol: The reference to the transport protocol used by the load balancing rule.
        :param pulumi.Input[str] load_distribution: The load distribution policy for this rule.
        :param pulumi.Input[int] probe_port: The prob port used by the load balancing rule. Acceptable values are between 1 and 65535.
        :param pulumi.Input[str] probe_request_path: The probe request path. Only supported for HTTP/HTTPS probes.
        """
        pulumi.set(__self__, "backend_port", backend_port)
        pulumi.set(__self__, "frontend_port", frontend_port)
        pulumi.set(__self__, "probe_protocol", probe_protocol)
        pulumi.set(__self__, "protocol", protocol)
        if load_distribution is not None:
            pulumi.set(__self__, "load_distribution", load_distribution)
        if probe_port is not None:
            pulumi.set(__self__, "probe_port", probe_port)
        if probe_request_path is not None:
            pulumi.set(__self__, "probe_request_path", probe_request_path)

    @property
    @pulumi.getter(name="backendPort")
    def backend_port(self) -> pulumi.Input[int]:
        """
        The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
        """
        return pulumi.get(self, "backend_port")

    @backend_port.setter
    def backend_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "backend_port", value)

    @property
    @pulumi.getter(name="frontendPort")
    def frontend_port(self) -> pulumi.Input[int]:
        """
        The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 1 and 65534.
        """
        return pulumi.get(self, "frontend_port")

    @frontend_port.setter
    def frontend_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "frontend_port", value)

    @property
    @pulumi.getter(name="probeProtocol")
    def probe_protocol(self) -> pulumi.Input[Union[str, 'ProbeProtocol']]:
        """
        the reference to the load balancer probe used by the load balancing rule.
        """
        return pulumi.get(self, "probe_protocol")

    @probe_protocol.setter
    def probe_protocol(self, value: pulumi.Input[Union[str, 'ProbeProtocol']]):
        pulumi.set(self, "probe_protocol", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[Union[str, 'Protocol']]:
        """
        The reference to the transport protocol used by the load balancing rule.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[Union[str, 'Protocol']]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="loadDistribution")
    def load_distribution(self) -> Optional[pulumi.Input[str]]:
        """
        The load distribution policy for this rule.
        """
        return pulumi.get(self, "load_distribution")

    @load_distribution.setter
    def load_distribution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_distribution", value)

    @property
    @pulumi.getter(name="probePort")
    def probe_port(self) -> Optional[pulumi.Input[int]]:
        """
        The prob port used by the load balancing rule. Acceptable values are between 1 and 65535.
        """
        return pulumi.get(self, "probe_port")

    @probe_port.setter
    def probe_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "probe_port", value)

    @property
    @pulumi.getter(name="probeRequestPath")
    def probe_request_path(self) -> Optional[pulumi.Input[str]]:
        """
        The probe request path. Only supported for HTTP/HTTPS probes.
        """
        return pulumi.get(self, "probe_request_path")

    @probe_request_path.setter
    def probe_request_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "probe_request_path", value)


if not MYPY:
    class ManagedIdentityArgsDict(TypedDict):
        """
        Describes the managed identities for an Azure resource.
        """
        type: NotRequired[pulumi.Input['ManagedIdentityType']]
        """
        The type of managed identity for the resource.
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
        '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
elif False:
    ManagedIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedIdentityArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['ManagedIdentityType']] = None,
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Describes the managed identities for an Azure resource.
        :param pulumi.Input['ManagedIdentityType'] type: The type of managed identity for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
               '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['ManagedIdentityType']]:
        """
        The type of managed identity for the resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['ManagedIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
        '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class NamedPartitionSchemeArgsDict(TypedDict):
        """
        Describes the named partition scheme of the service.
        """
        names: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Array for the names of the partitions.
        """
        partition_scheme: pulumi.Input[str]
        """
        Enumerates the ways that a service can be partitioned.
        Expected value is 'Named'.
        """
elif False:
    NamedPartitionSchemeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamedPartitionSchemeArgs:
    def __init__(__self__, *,
                 names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 partition_scheme: pulumi.Input[str]):
        """
        Describes the named partition scheme of the service.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] names: Array for the names of the partitions.
        :param pulumi.Input[str] partition_scheme: Enumerates the ways that a service can be partitioned.
               Expected value is 'Named'.
        """
        pulumi.set(__self__, "names", names)
        pulumi.set(__self__, "partition_scheme", 'Named')

    @property
    @pulumi.getter
    def names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Array for the names of the partitions.
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "names", value)

    @property
    @pulumi.getter(name="partitionScheme")
    def partition_scheme(self) -> pulumi.Input[str]:
        """
        Enumerates the ways that a service can be partitioned.
        Expected value is 'Named'.
        """
        return pulumi.get(self, "partition_scheme")

    @partition_scheme.setter
    def partition_scheme(self, value: pulumi.Input[str]):
        pulumi.set(self, "partition_scheme", value)


if not MYPY:
    class NetworkSecurityRuleArgsDict(TypedDict):
        """
        Describes a network security rule.
        """
        access: pulumi.Input[Union[str, 'Access']]
        """
        The network traffic is allowed or denied.
        """
        direction: pulumi.Input[Union[str, 'Direction']]
        """
        Network security rule direction.
        """
        name: pulumi.Input[str]
        """
        Network security rule name.
        """
        priority: pulumi.Input[int]
        """
        The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
        """
        protocol: pulumi.Input[Union[str, 'NsgProtocol']]
        """
        Network protocol this rule applies to.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Network security rule description.
        """
        destination_address_prefix: NotRequired[pulumi.Input[str]]
        """
        The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
        """
        destination_address_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The destination address prefixes. CIDR or destination IP ranges.
        """
        destination_port_range: NotRequired[pulumi.Input[str]]
        """
        he destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
        """
        destination_port_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The destination port ranges.
        """
        source_address_prefix: NotRequired[pulumi.Input[str]]
        """
        The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from.
        """
        source_address_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The CIDR or source IP ranges.
        """
        source_port_range: NotRequired[pulumi.Input[str]]
        """
        The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
        """
        source_port_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The source port ranges.
        """
elif False:
    NetworkSecurityRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleArgs:
    def __init__(__self__, *,
                 access: pulumi.Input[Union[str, 'Access']],
                 direction: pulumi.Input[Union[str, 'Direction']],
                 name: pulumi.Input[str],
                 priority: pulumi.Input[int],
                 protocol: pulumi.Input[Union[str, 'NsgProtocol']],
                 description: Optional[pulumi.Input[str]] = None,
                 destination_address_prefix: Optional[pulumi.Input[str]] = None,
                 destination_address_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 destination_port_range: Optional[pulumi.Input[str]] = None,
                 destination_port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 source_address_prefix: Optional[pulumi.Input[str]] = None,
                 source_address_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 source_port_range: Optional[pulumi.Input[str]] = None,
                 source_port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Describes a network security rule.
        :param pulumi.Input[Union[str, 'Access']] access: The network traffic is allowed or denied.
        :param pulumi.Input[Union[str, 'Direction']] direction: Network security rule direction.
        :param pulumi.Input[str] name: Network security rule name.
        :param pulumi.Input[int] priority: The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
        :param pulumi.Input[Union[str, 'NsgProtocol']] protocol: Network protocol this rule applies to.
        :param pulumi.Input[str] description: Network security rule description.
        :param pulumi.Input[str] destination_address_prefix: The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_address_prefixes: The destination address prefixes. CIDR or destination IP ranges.
        :param pulumi.Input[str] destination_port_range: he destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_port_ranges: The destination port ranges.
        :param pulumi.Input[str] source_address_prefix: The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_address_prefixes: The CIDR or source IP ranges.
        :param pulumi.Input[str] source_port_range: The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_port_ranges: The source port ranges.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "protocol", protocol)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_address_prefix is not None:
            pulumi.set(__self__, "destination_address_prefix", destination_address_prefix)
        if destination_address_prefixes is not None:
            pulumi.set(__self__, "destination_address_prefixes", destination_address_prefixes)
        if destination_port_range is not None:
            pulumi.set(__self__, "destination_port_range", destination_port_range)
        if destination_port_ranges is not None:
            pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        if source_address_prefix is not None:
            pulumi.set(__self__, "source_address_prefix", source_address_prefix)
        if source_address_prefixes is not None:
            pulumi.set(__self__, "source_address_prefixes", source_address_prefixes)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)
        if source_port_ranges is not None:
            pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @property
    @pulumi.getter
    def access(self) -> pulumi.Input[Union[str, 'Access']]:
        """
        The network traffic is allowed or denied.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: pulumi.Input[Union[str, 'Access']]):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input[Union[str, 'Direction']]:
        """
        Network security rule direction.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[Union[str, 'Direction']]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Network security rule name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        The priority of the rule. The value can be in the range 1000 to 3000. Values outside this range are reserved for Service Fabric ManagerCluster Resource Provider. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[Union[str, 'NsgProtocol']]:
        """
        Network protocol this rule applies to.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[Union[str, 'NsgProtocol']]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Network security rule description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="destinationAddressPrefix")
    def destination_address_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
        """
        return pulumi.get(self, "destination_address_prefix")

    @destination_address_prefix.setter
    def destination_address_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_address_prefix", value)

    @property
    @pulumi.getter(name="destinationAddressPrefixes")
    def destination_address_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The destination address prefixes. CIDR or destination IP ranges.
        """
        return pulumi.get(self, "destination_address_prefixes")

    @destination_address_prefixes.setter
    def destination_address_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_address_prefixes", value)

    @property
    @pulumi.getter(name="destinationPortRange")
    def destination_port_range(self) -> Optional[pulumi.Input[str]]:
        """
        he destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
        """
        return pulumi.get(self, "destination_port_range")

    @destination_port_range.setter
    def destination_port_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_port_range", value)

    @property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The destination port ranges.
        """
        return pulumi.get(self, "destination_port_ranges")

    @destination_port_ranges.setter
    def destination_port_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_port_ranges", value)

    @property
    @pulumi.getter(name="sourceAddressPrefix")
    def source_address_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from.
        """
        return pulumi.get(self, "source_address_prefix")

    @source_address_prefix.setter
    def source_address_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_address_prefix", value)

    @property
    @pulumi.getter(name="sourceAddressPrefixes")
    def source_address_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The CIDR or source IP ranges.
        """
        return pulumi.get(self, "source_address_prefixes")

    @source_address_prefixes.setter
    def source_address_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_address_prefixes", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input[str]]:
        """
        The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
        """
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_port_range", value)

    @property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The source port ranges.
        """
        return pulumi.get(self, "source_port_ranges")

    @source_port_ranges.setter
    def source_port_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_port_ranges", value)


if not MYPY:
    class NodeTypeSkuArgsDict(TypedDict):
        """
        Describes a node type sku.
        """
        capacity: pulumi.Input[int]
        """
        The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
        """
        tier: NotRequired[pulumi.Input[str]]
        """
        Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
        """
elif False:
    NodeTypeSkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeTypeSkuArgs:
    def __init__(__self__, *,
                 capacity: pulumi.Input[int],
                 name: Optional[pulumi.Input[str]] = None,
                 tier: Optional[pulumi.Input[str]] = None):
        """
        Describes a node type sku.
        :param pulumi.Input[int] capacity: The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
        :param pulumi.Input[str] name: The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
        :param pulumi.Input[str] tier: Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
        """
        pulumi.set(__self__, "capacity", capacity)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def capacity(self) -> pulumi.Input[int]:
        """
        The number of nodes in the node type.<br /><br />If present in request it will override properties.vmInstanceCount.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: pulumi.Input[int]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The sku name. <br /><br />Name is internally generated and is used in auto-scale scenarios.<br /> Property does not allow to be changed to other values than generated.<br /> To avoid deployment errors please omit the property.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the tier of the node type. <br /><br /> Possible Values:<br /> **Standard**
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tier", value)


if not MYPY:
    class PartitionInstanceCountScaleMechanismArgsDict(TypedDict):
        """
        Represents a scaling mechanism for adding or removing instances of stateless service partition.
        """
        kind: pulumi.Input[str]
        """
        Enumerates the ways that a service can be partitioned.
        Expected value is 'ScalePartitionInstanceCount'.
        """
        max_instance_count: pulumi.Input[int]
        """
        Maximum number of instances of the partition.
        """
        min_instance_count: pulumi.Input[int]
        """
        Minimum number of instances of the partition.
        """
        scale_increment: pulumi.Input[int]
        """
        The number of instances to add or remove during a scaling operation.
        """
elif False:
    PartitionInstanceCountScaleMechanismArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PartitionInstanceCountScaleMechanismArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 max_instance_count: pulumi.Input[int],
                 min_instance_count: pulumi.Input[int],
                 scale_increment: pulumi.Input[int]):
        """
        Represents a scaling mechanism for adding or removing instances of stateless service partition.
        :param pulumi.Input[str] kind: Enumerates the ways that a service can be partitioned.
               Expected value is 'ScalePartitionInstanceCount'.
        :param pulumi.Input[int] max_instance_count: Maximum number of instances of the partition.
        :param pulumi.Input[int] min_instance_count: Minimum number of instances of the partition.
        :param pulumi.Input[int] scale_increment: The number of instances to add or remove during a scaling operation.
        """
        pulumi.set(__self__, "kind", 'ScalePartitionInstanceCount')
        pulumi.set(__self__, "max_instance_count", max_instance_count)
        pulumi.set(__self__, "min_instance_count", min_instance_count)
        pulumi.set(__self__, "scale_increment", scale_increment)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        Enumerates the ways that a service can be partitioned.
        Expected value is 'ScalePartitionInstanceCount'.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> pulumi.Input[int]:
        """
        Maximum number of instances of the partition.
        """
        return pulumi.get(self, "max_instance_count")

    @max_instance_count.setter
    def max_instance_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_instance_count", value)

    @property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> pulumi.Input[int]:
        """
        Minimum number of instances of the partition.
        """
        return pulumi.get(self, "min_instance_count")

    @min_instance_count.setter
    def min_instance_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_instance_count", value)

    @property
    @pulumi.getter(name="scaleIncrement")
    def scale_increment(self) -> pulumi.Input[int]:
        """
        The number of instances to add or remove during a scaling operation.
        """
        return pulumi.get(self, "scale_increment")

    @scale_increment.setter
    def scale_increment(self, value: pulumi.Input[int]):
        pulumi.set(self, "scale_increment", value)


if not MYPY:
    class RollingUpgradeMonitoringPolicyArgsDict(TypedDict):
        """
        The policy used for monitoring the application upgrade
        """
        failure_action: pulumi.Input[Union[str, 'FailureAction']]
        """
        The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
        """
        health_check_retry_timeout: pulumi.Input[str]
        """
        The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
        """
        health_check_stable_duration: pulumi.Input[str]
        """
        The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
        """
        health_check_wait_duration: pulumi.Input[str]
        """
        The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
        """
        upgrade_domain_timeout: pulumi.Input[str]
        """
        The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
        """
        upgrade_timeout: pulumi.Input[str]
        """
        The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
        """
elif False:
    RollingUpgradeMonitoringPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RollingUpgradeMonitoringPolicyArgs:
    def __init__(__self__, *,
                 failure_action: pulumi.Input[Union[str, 'FailureAction']],
                 health_check_retry_timeout: pulumi.Input[str],
                 health_check_stable_duration: pulumi.Input[str],
                 health_check_wait_duration: pulumi.Input[str],
                 upgrade_domain_timeout: pulumi.Input[str],
                 upgrade_timeout: pulumi.Input[str]):
        """
        The policy used for monitoring the application upgrade
        :param pulumi.Input[Union[str, 'FailureAction']] failure_action: The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
        :param pulumi.Input[str] health_check_retry_timeout: The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
        :param pulumi.Input[str] health_check_stable_duration: The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
        :param pulumi.Input[str] health_check_wait_duration: The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
        :param pulumi.Input[str] upgrade_domain_timeout: The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
        :param pulumi.Input[str] upgrade_timeout: The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
        """
        pulumi.set(__self__, "failure_action", failure_action)
        pulumi.set(__self__, "health_check_retry_timeout", health_check_retry_timeout)
        pulumi.set(__self__, "health_check_stable_duration", health_check_stable_duration)
        pulumi.set(__self__, "health_check_wait_duration", health_check_wait_duration)
        pulumi.set(__self__, "upgrade_domain_timeout", upgrade_domain_timeout)
        pulumi.set(__self__, "upgrade_timeout", upgrade_timeout)

    @property
    @pulumi.getter(name="failureAction")
    def failure_action(self) -> pulumi.Input[Union[str, 'FailureAction']]:
        """
        The compensating action to perform when a Monitored upgrade encounters monitoring policy or health policy violations. Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start rolling back automatically. Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
        """
        return pulumi.get(self, "failure_action")

    @failure_action.setter
    def failure_action(self, value: pulumi.Input[Union[str, 'FailureAction']]):
        pulumi.set(self, "failure_action", value)

    @property
    @pulumi.getter(name="healthCheckRetryTimeout")
    def health_check_retry_timeout(self) -> pulumi.Input[str]:
        """
        The amount of time to retry health evaluation when the application or cluster is unhealthy before FailureAction is executed. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
        """
        return pulumi.get(self, "health_check_retry_timeout")

    @health_check_retry_timeout.setter
    def health_check_retry_timeout(self, value: pulumi.Input[str]):
        pulumi.set(self, "health_check_retry_timeout", value)

    @property
    @pulumi.getter(name="healthCheckStableDuration")
    def health_check_stable_duration(self) -> pulumi.Input[str]:
        """
        The amount of time that the application or cluster must remain healthy before the upgrade proceeds to the next upgrade domain. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
        """
        return pulumi.get(self, "health_check_stable_duration")

    @health_check_stable_duration.setter
    def health_check_stable_duration(self, value: pulumi.Input[str]):
        pulumi.set(self, "health_check_stable_duration", value)

    @property
    @pulumi.getter(name="healthCheckWaitDuration")
    def health_check_wait_duration(self) -> pulumi.Input[str]:
        """
        The amount of time to wait after completing an upgrade domain before applying health policies. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
        """
        return pulumi.get(self, "health_check_wait_duration")

    @health_check_wait_duration.setter
    def health_check_wait_duration(self, value: pulumi.Input[str]):
        pulumi.set(self, "health_check_wait_duration", value)

    @property
    @pulumi.getter(name="upgradeDomainTimeout")
    def upgrade_domain_timeout(self) -> pulumi.Input[str]:
        """
        The amount of time each upgrade domain has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
        """
        return pulumi.get(self, "upgrade_domain_timeout")

    @upgrade_domain_timeout.setter
    def upgrade_domain_timeout(self, value: pulumi.Input[str]):
        pulumi.set(self, "upgrade_domain_timeout", value)

    @property
    @pulumi.getter(name="upgradeTimeout")
    def upgrade_timeout(self) -> pulumi.Input[str]:
        """
        The amount of time the overall upgrade has to complete before FailureAction is executed. Cannot be larger than 12 hours. It is interpreted as a string representing an ISO 8601 duration with following format "hh:mm:ss.fff".
        """
        return pulumi.get(self, "upgrade_timeout")

    @upgrade_timeout.setter
    def upgrade_timeout(self, value: pulumi.Input[str]):
        pulumi.set(self, "upgrade_timeout", value)


if not MYPY:
    class ScalingPolicyArgsDict(TypedDict):
        """
        Specifies a metric to load balance a service during runtime.
        """
        scaling_mechanism: pulumi.Input[Union['AddRemoveIncrementalNamedPartitionScalingMechanismArgsDict', 'PartitionInstanceCountScaleMechanismArgsDict']]
        """
        Specifies the mechanism associated with this scaling policy
        """
        scaling_trigger: pulumi.Input[Union['AveragePartitionLoadScalingTriggerArgsDict', 'AverageServiceLoadScalingTriggerArgsDict']]
        """
        Specifies the trigger associated with this scaling policy.
        """
elif False:
    ScalingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScalingPolicyArgs:
    def __init__(__self__, *,
                 scaling_mechanism: pulumi.Input[Union['AddRemoveIncrementalNamedPartitionScalingMechanismArgs', 'PartitionInstanceCountScaleMechanismArgs']],
                 scaling_trigger: pulumi.Input[Union['AveragePartitionLoadScalingTriggerArgs', 'AverageServiceLoadScalingTriggerArgs']]):
        """
        Specifies a metric to load balance a service during runtime.
        :param pulumi.Input[Union['AddRemoveIncrementalNamedPartitionScalingMechanismArgs', 'PartitionInstanceCountScaleMechanismArgs']] scaling_mechanism: Specifies the mechanism associated with this scaling policy
        :param pulumi.Input[Union['AveragePartitionLoadScalingTriggerArgs', 'AverageServiceLoadScalingTriggerArgs']] scaling_trigger: Specifies the trigger associated with this scaling policy.
        """
        pulumi.set(__self__, "scaling_mechanism", scaling_mechanism)
        pulumi.set(__self__, "scaling_trigger", scaling_trigger)

    @property
    @pulumi.getter(name="scalingMechanism")
    def scaling_mechanism(self) -> pulumi.Input[Union['AddRemoveIncrementalNamedPartitionScalingMechanismArgs', 'PartitionInstanceCountScaleMechanismArgs']]:
        """
        Specifies the mechanism associated with this scaling policy
        """
        return pulumi.get(self, "scaling_mechanism")

    @scaling_mechanism.setter
    def scaling_mechanism(self, value: pulumi.Input[Union['AddRemoveIncrementalNamedPartitionScalingMechanismArgs', 'PartitionInstanceCountScaleMechanismArgs']]):
        pulumi.set(self, "scaling_mechanism", value)

    @property
    @pulumi.getter(name="scalingTrigger")
    def scaling_trigger(self) -> pulumi.Input[Union['AveragePartitionLoadScalingTriggerArgs', 'AverageServiceLoadScalingTriggerArgs']]:
        """
        Specifies the trigger associated with this scaling policy.
        """
        return pulumi.get(self, "scaling_trigger")

    @scaling_trigger.setter
    def scaling_trigger(self, value: pulumi.Input[Union['AveragePartitionLoadScalingTriggerArgs', 'AverageServiceLoadScalingTriggerArgs']]):
        pulumi.set(self, "scaling_trigger", value)


if not MYPY:
    class ServiceCorrelationArgsDict(TypedDict):
        """
        Creates a particular correlation between services.
        """
        scheme: pulumi.Input[Union[str, 'ServiceCorrelationScheme']]
        """
        The ServiceCorrelationScheme which describes the relationship between this service and the service specified via ServiceName.
        """
        service_name: pulumi.Input[str]
        """
        The Arm Resource ID of the service that the correlation relationship is established with.
        """
elif False:
    ServiceCorrelationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceCorrelationArgs:
    def __init__(__self__, *,
                 scheme: pulumi.Input[Union[str, 'ServiceCorrelationScheme']],
                 service_name: pulumi.Input[str]):
        """
        Creates a particular correlation between services.
        :param pulumi.Input[Union[str, 'ServiceCorrelationScheme']] scheme: The ServiceCorrelationScheme which describes the relationship between this service and the service specified via ServiceName.
        :param pulumi.Input[str] service_name: The Arm Resource ID of the service that the correlation relationship is established with.
        """
        pulumi.set(__self__, "scheme", scheme)
        pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def scheme(self) -> pulumi.Input[Union[str, 'ServiceCorrelationScheme']]:
        """
        The ServiceCorrelationScheme which describes the relationship between this service and the service specified via ServiceName.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: pulumi.Input[Union[str, 'ServiceCorrelationScheme']]):
        pulumi.set(self, "scheme", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> pulumi.Input[str]:
        """
        The Arm Resource ID of the service that the correlation relationship is established with.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class ServiceEndpointArgsDict(TypedDict):
        """
        The service endpoint properties.
        """
        service: pulumi.Input[str]
        """
        The type of the endpoint service.
        """
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of locations.
        """
elif False:
    ServiceEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEndpointArgs:
    def __init__(__self__, *,
                 service: pulumi.Input[str],
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The service endpoint properties.
        :param pulumi.Input[str] service: The type of the endpoint service.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] locations: A list of locations.
        """
        pulumi.set(__self__, "service", service)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        The type of the endpoint service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of locations.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class ServiceLoadMetricArgsDict(TypedDict):
        """
        Specifies a metric to load balance a service during runtime.
        """
        name: pulumi.Input[str]
        """
        The name of the metric. If the service chooses to report load during runtime, the load metric name should match the name that is specified in Name exactly. Note that metric names are case sensitive.
        """
        default_load: NotRequired[pulumi.Input[int]]
        """
        Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric.
        """
        primary_default_load: NotRequired[pulumi.Input[int]]
        """
        Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Primary replica.
        """
        secondary_default_load: NotRequired[pulumi.Input[int]]
        """
        Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Secondary replica.
        """
        weight: NotRequired[pulumi.Input[Union[str, 'ServiceLoadMetricWeight']]]
        """
        The service load metric relative weight, compared to other metrics configured for this service, as a number.
        """
elif False:
    ServiceLoadMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceLoadMetricArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 default_load: Optional[pulumi.Input[int]] = None,
                 primary_default_load: Optional[pulumi.Input[int]] = None,
                 secondary_default_load: Optional[pulumi.Input[int]] = None,
                 weight: Optional[pulumi.Input[Union[str, 'ServiceLoadMetricWeight']]] = None):
        """
        Specifies a metric to load balance a service during runtime.
        :param pulumi.Input[str] name: The name of the metric. If the service chooses to report load during runtime, the load metric name should match the name that is specified in Name exactly. Note that metric names are case sensitive.
        :param pulumi.Input[int] default_load: Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric.
        :param pulumi.Input[int] primary_default_load: Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Primary replica.
        :param pulumi.Input[int] secondary_default_load: Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Secondary replica.
        :param pulumi.Input[Union[str, 'ServiceLoadMetricWeight']] weight: The service load metric relative weight, compared to other metrics configured for this service, as a number.
        """
        pulumi.set(__self__, "name", name)
        if default_load is not None:
            pulumi.set(__self__, "default_load", default_load)
        if primary_default_load is not None:
            pulumi.set(__self__, "primary_default_load", primary_default_load)
        if secondary_default_load is not None:
            pulumi.set(__self__, "secondary_default_load", secondary_default_load)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the metric. If the service chooses to report load during runtime, the load metric name should match the name that is specified in Name exactly. Note that metric names are case sensitive.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="defaultLoad")
    def default_load(self) -> Optional[pulumi.Input[int]]:
        """
        Used only for Stateless services. The default amount of load, as a number, that this service creates for this metric.
        """
        return pulumi.get(self, "default_load")

    @default_load.setter
    def default_load(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default_load", value)

    @property
    @pulumi.getter(name="primaryDefaultLoad")
    def primary_default_load(self) -> Optional[pulumi.Input[int]]:
        """
        Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Primary replica.
        """
        return pulumi.get(self, "primary_default_load")

    @primary_default_load.setter
    def primary_default_load(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "primary_default_load", value)

    @property
    @pulumi.getter(name="secondaryDefaultLoad")
    def secondary_default_load(self) -> Optional[pulumi.Input[int]]:
        """
        Used only for Stateful services. The default amount of load, as a number, that this service creates for this metric when it is a Secondary replica.
        """
        return pulumi.get(self, "secondary_default_load")

    @secondary_default_load.setter
    def secondary_default_load(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "secondary_default_load", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[Union[str, 'ServiceLoadMetricWeight']]]:
        """
        The service load metric relative weight, compared to other metrics configured for this service, as a number.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[Union[str, 'ServiceLoadMetricWeight']]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class ServicePlacementInvalidDomainPolicyArgsDict(TypedDict):
        """
        Describes the policy to be used for placement of a Service Fabric service where a particular fault or upgrade domain should not be used for placement of the instances or replicas of that service.
        """
        domain_name: pulumi.Input[str]
        """
        The name of the domain that should not be used for placement.
        """
        type: pulumi.Input[str]
        """
        The type of placement policy for a service fabric service. Following are the possible values.
        Expected value is 'InvalidDomain'.
        """
elif False:
    ServicePlacementInvalidDomainPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServicePlacementInvalidDomainPolicyArgs:
    def __init__(__self__, *,
                 domain_name: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        Describes the policy to be used for placement of a Service Fabric service where a particular fault or upgrade domain should not be used for placement of the instances or replicas of that service.
        :param pulumi.Input[str] domain_name: The name of the domain that should not be used for placement.
        :param pulumi.Input[str] type: The type of placement policy for a service fabric service. Following are the possible values.
               Expected value is 'InvalidDomain'.
        """
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "type", 'InvalidDomain')

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[str]:
        """
        The name of the domain that should not be used for placement.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of placement policy for a service fabric service. Following are the possible values.
        Expected value is 'InvalidDomain'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServicePlacementNonPartiallyPlaceServicePolicyArgsDict(TypedDict):
        """
        The name of the domain that should used for placement as per this policy.
        """
        type: pulumi.Input[str]
        """
        The type of placement policy for a service fabric service. Following are the possible values.
        Expected value is 'NonPartiallyPlaceService'.
        """
elif False:
    ServicePlacementNonPartiallyPlaceServicePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServicePlacementNonPartiallyPlaceServicePolicyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        The name of the domain that should used for placement as per this policy.
        :param pulumi.Input[str] type: The type of placement policy for a service fabric service. Following are the possible values.
               Expected value is 'NonPartiallyPlaceService'.
        """
        pulumi.set(__self__, "type", 'NonPartiallyPlaceService')

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of placement policy for a service fabric service. Following are the possible values.
        Expected value is 'NonPartiallyPlaceService'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServicePlacementPreferPrimaryDomainPolicyArgsDict(TypedDict):
        """
        Describes the policy to be used for placement of a Service Fabric service where the service's 
        Primary replicas should optimally be placed in a particular domain.

        This placement policy is usually used with fault domains in scenarios where the Service Fabric
        cluster is geographically distributed in order to indicate that a service's primary replica should
        be located in a particular fault domain, which in geo-distributed scenarios usually aligns with regional
        or datacenter boundaries. Note that since this is an optimization it is possible that the Primary replica
        may not end up located in this domain due to failures, capacity limits, or other constraints.
        """
        domain_name: pulumi.Input[str]
        """
        The name of the domain that should used for placement as per this policy.
        """
        type: pulumi.Input[str]
        """
        The type of placement policy for a service fabric service. Following are the possible values.
        Expected value is 'PreferredPrimaryDomain'.
        """
elif False:
    ServicePlacementPreferPrimaryDomainPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServicePlacementPreferPrimaryDomainPolicyArgs:
    def __init__(__self__, *,
                 domain_name: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        Describes the policy to be used for placement of a Service Fabric service where the service's 
        Primary replicas should optimally be placed in a particular domain.

        This placement policy is usually used with fault domains in scenarios where the Service Fabric
        cluster is geographically distributed in order to indicate that a service's primary replica should
        be located in a particular fault domain, which in geo-distributed scenarios usually aligns with regional
        or datacenter boundaries. Note that since this is an optimization it is possible that the Primary replica
        may not end up located in this domain due to failures, capacity limits, or other constraints.

        :param pulumi.Input[str] domain_name: The name of the domain that should used for placement as per this policy.
        :param pulumi.Input[str] type: The type of placement policy for a service fabric service. Following are the possible values.
               Expected value is 'PreferredPrimaryDomain'.
        """
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "type", 'PreferredPrimaryDomain')

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[str]:
        """
        The name of the domain that should used for placement as per this policy.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of placement policy for a service fabric service. Following are the possible values.
        Expected value is 'PreferredPrimaryDomain'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServicePlacementRequireDomainDistributionPolicyArgsDict(TypedDict):
        """
        Describes the policy to be used for placement of a Service Fabric service where two replicas
        from the same partition should never be placed in the same fault or upgrade domain.

        While this is not common it can expose the service to an increased risk of concurrent failures
        due to unplanned outages or other cases of subsequent/concurrent failures. As an example, consider
        a case where replicas are deployed across different data center, with one replica per location.
        In the event that one of the datacenters goes offline, normally the replica that was placed in that
        datacenter will be packed into one of the remaining datacenters. If this is not desirable then this
        policy should be set.
        """
        domain_name: pulumi.Input[str]
        """
        The name of the domain that should used for placement as per this policy.
        """
        type: pulumi.Input[str]
        """
        The type of placement policy for a service fabric service. Following are the possible values.
        Expected value is 'RequiredDomainDistribution'.
        """
elif False:
    ServicePlacementRequireDomainDistributionPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServicePlacementRequireDomainDistributionPolicyArgs:
    def __init__(__self__, *,
                 domain_name: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        Describes the policy to be used for placement of a Service Fabric service where two replicas
        from the same partition should never be placed in the same fault or upgrade domain.

        While this is not common it can expose the service to an increased risk of concurrent failures
        due to unplanned outages or other cases of subsequent/concurrent failures. As an example, consider
        a case where replicas are deployed across different data center, with one replica per location.
        In the event that one of the datacenters goes offline, normally the replica that was placed in that
        datacenter will be packed into one of the remaining datacenters. If this is not desirable then this
        policy should be set.

        :param pulumi.Input[str] domain_name: The name of the domain that should used for placement as per this policy.
        :param pulumi.Input[str] type: The type of placement policy for a service fabric service. Following are the possible values.
               Expected value is 'RequiredDomainDistribution'.
        """
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "type", 'RequiredDomainDistribution')

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[str]:
        """
        The name of the domain that should used for placement as per this policy.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of placement policy for a service fabric service. Following are the possible values.
        Expected value is 'RequiredDomainDistribution'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServicePlacementRequiredDomainPolicyArgsDict(TypedDict):
        """
        Describes the policy to be used for placement of a Service Fabric service where the instances or replicas of that service must be placed in a particular domain.
        """
        domain_name: pulumi.Input[str]
        """
        The name of the domain that should used for placement as per this policy.
        """
        type: pulumi.Input[str]
        """
        The type of placement policy for a service fabric service. Following are the possible values.
        Expected value is 'RequiredDomain'.
        """
elif False:
    ServicePlacementRequiredDomainPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServicePlacementRequiredDomainPolicyArgs:
    def __init__(__self__, *,
                 domain_name: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        Describes the policy to be used for placement of a Service Fabric service where the instances or replicas of that service must be placed in a particular domain.
        :param pulumi.Input[str] domain_name: The name of the domain that should used for placement as per this policy.
        :param pulumi.Input[str] type: The type of placement policy for a service fabric service. Following are the possible values.
               Expected value is 'RequiredDomain'.
        """
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "type", 'RequiredDomain')

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[str]:
        """
        The name of the domain that should used for placement as per this policy.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of placement policy for a service fabric service. Following are the possible values.
        Expected value is 'RequiredDomain'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceTypeHealthPolicyArgsDict(TypedDict):
        """
        Represents the health policy used to evaluate the health of services belonging to a service type.
        """
        max_percent_unhealthy_partitions_per_service: pulumi.Input[int]
        """
        The maximum allowed percentage of unhealthy partitions per service.

        The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
        If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
        The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
        The computation rounds up to tolerate one failure on small numbers of partitions.
        """
        max_percent_unhealthy_replicas_per_partition: pulumi.Input[int]
        """
        The maximum allowed percentage of unhealthy replicas per partition.

        The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
        If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
        The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
        The computation rounds up to tolerate one failure on small numbers of replicas.
        """
        max_percent_unhealthy_services: pulumi.Input[int]
        """
        The maximum allowed percentage of unhealthy services.

        The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
        If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
        This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
        The computation rounds up to tolerate one failure on small numbers of services.
        """
elif False:
    ServiceTypeHealthPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceTypeHealthPolicyArgs:
    def __init__(__self__, *,
                 max_percent_unhealthy_partitions_per_service: pulumi.Input[int],
                 max_percent_unhealthy_replicas_per_partition: pulumi.Input[int],
                 max_percent_unhealthy_services: pulumi.Input[int]):
        """
        Represents the health policy used to evaluate the health of services belonging to a service type.

        :param pulumi.Input[int] max_percent_unhealthy_partitions_per_service: The maximum allowed percentage of unhealthy partitions per service.
               
               The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
               If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
               The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
               The computation rounds up to tolerate one failure on small numbers of partitions.
        :param pulumi.Input[int] max_percent_unhealthy_replicas_per_partition: The maximum allowed percentage of unhealthy replicas per partition.
               
               The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
               If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
               The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
               The computation rounds up to tolerate one failure on small numbers of replicas.
        :param pulumi.Input[int] max_percent_unhealthy_services: The maximum allowed percentage of unhealthy services.
               
               The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
               If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
               This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
               The computation rounds up to tolerate one failure on small numbers of services.
        """
        pulumi.set(__self__, "max_percent_unhealthy_partitions_per_service", max_percent_unhealthy_partitions_per_service)
        pulumi.set(__self__, "max_percent_unhealthy_replicas_per_partition", max_percent_unhealthy_replicas_per_partition)
        pulumi.set(__self__, "max_percent_unhealthy_services", max_percent_unhealthy_services)

    @property
    @pulumi.getter(name="maxPercentUnhealthyPartitionsPerService")
    def max_percent_unhealthy_partitions_per_service(self) -> pulumi.Input[int]:
        """
        The maximum allowed percentage of unhealthy partitions per service.

        The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error.
        If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning.
        The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service.
        The computation rounds up to tolerate one failure on small numbers of partitions.
        """
        return pulumi.get(self, "max_percent_unhealthy_partitions_per_service")

    @max_percent_unhealthy_partitions_per_service.setter
    def max_percent_unhealthy_partitions_per_service(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_percent_unhealthy_partitions_per_service", value)

    @property
    @pulumi.getter(name="maxPercentUnhealthyReplicasPerPartition")
    def max_percent_unhealthy_replicas_per_partition(self) -> pulumi.Input[int]:
        """
        The maximum allowed percentage of unhealthy replicas per partition.

        The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error.
        If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning.
        The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition.
        The computation rounds up to tolerate one failure on small numbers of replicas.
        """
        return pulumi.get(self, "max_percent_unhealthy_replicas_per_partition")

    @max_percent_unhealthy_replicas_per_partition.setter
    def max_percent_unhealthy_replicas_per_partition(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_percent_unhealthy_replicas_per_partition", value)

    @property
    @pulumi.getter(name="maxPercentUnhealthyServices")
    def max_percent_unhealthy_services(self) -> pulumi.Input[int]:
        """
        The maximum allowed percentage of unhealthy services.

        The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error.
        If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning.
        This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type.
        The computation rounds up to tolerate one failure on small numbers of services.
        """
        return pulumi.get(self, "max_percent_unhealthy_services")

    @max_percent_unhealthy_services.setter
    def max_percent_unhealthy_services(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_percent_unhealthy_services", value)


if not MYPY:
    class SettingsParameterDescriptionArgsDict(TypedDict):
        """
        Describes a parameter in fabric settings of the cluster.
        """
        name: pulumi.Input[str]
        """
        The parameter name of fabric setting.
        """
        value: pulumi.Input[str]
        """
        The parameter value of fabric setting.
        """
elif False:
    SettingsParameterDescriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingsParameterDescriptionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        Describes a parameter in fabric settings of the cluster.
        :param pulumi.Input[str] name: The parameter name of fabric setting.
        :param pulumi.Input[str] value: The parameter value of fabric setting.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The parameter name of fabric setting.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The parameter value of fabric setting.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SettingsSectionDescriptionArgsDict(TypedDict):
        """
        Describes a section in the fabric settings of the cluster.
        """
        name: pulumi.Input[str]
        """
        The section name of the fabric settings.
        """
        parameters: pulumi.Input[Sequence[pulumi.Input['SettingsParameterDescriptionArgsDict']]]
        """
        The collection of parameters in the section.
        """
elif False:
    SettingsSectionDescriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingsSectionDescriptionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input[Sequence[pulumi.Input['SettingsParameterDescriptionArgs']]]):
        """
        Describes a section in the fabric settings of the cluster.
        :param pulumi.Input[str] name: The section name of the fabric settings.
        :param pulumi.Input[Sequence[pulumi.Input['SettingsParameterDescriptionArgs']]] parameters: The collection of parameters in the section.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The section name of the fabric settings.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input[Sequence[pulumi.Input['SettingsParameterDescriptionArgs']]]:
        """
        The collection of parameters in the section.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input[Sequence[pulumi.Input['SettingsParameterDescriptionArgs']]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class SingletonPartitionSchemeArgsDict(TypedDict):
        """
        Describes the partition scheme of a singleton-partitioned, or non-partitioned service.
        """
        partition_scheme: pulumi.Input[str]
        """
        Enumerates the ways that a service can be partitioned.
        Expected value is 'Singleton'.
        """
elif False:
    SingletonPartitionSchemeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SingletonPartitionSchemeArgs:
    def __init__(__self__, *,
                 partition_scheme: pulumi.Input[str]):
        """
        Describes the partition scheme of a singleton-partitioned, or non-partitioned service.
        :param pulumi.Input[str] partition_scheme: Enumerates the ways that a service can be partitioned.
               Expected value is 'Singleton'.
        """
        pulumi.set(__self__, "partition_scheme", 'Singleton')

    @property
    @pulumi.getter(name="partitionScheme")
    def partition_scheme(self) -> pulumi.Input[str]:
        """
        Enumerates the ways that a service can be partitioned.
        Expected value is 'Singleton'.
        """
        return pulumi.get(self, "partition_scheme")

    @partition_scheme.setter
    def partition_scheme(self, value: pulumi.Input[str]):
        pulumi.set(self, "partition_scheme", value)


if not MYPY:
    class SkuArgsDict(TypedDict):
        """
        Service Fabric managed cluster Sku definition
        """
        name: pulumi.Input[Union[str, 'SkuName']]
        """
        Sku Name.
        """
elif False:
    SkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SkuArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[Union[str, 'SkuName']]):
        """
        Service Fabric managed cluster Sku definition
        :param pulumi.Input[Union[str, 'SkuName']] name: Sku Name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[Union[str, 'SkuName']]:
        """
        Sku Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[Union[str, 'SkuName']]):
        pulumi.set(self, "name", value)


if not MYPY:
    class StatefulServicePropertiesArgsDict(TypedDict):
        """
        The properties of a stateful service resource.
        """
        partition_description: pulumi.Input[Union['NamedPartitionSchemeArgsDict', 'SingletonPartitionSchemeArgsDict', 'UniformInt64RangePartitionSchemeArgsDict']]
        """
        Describes how the service is partitioned.
        """
        service_kind: pulumi.Input[str]
        """
        The kind of service (Stateless or Stateful).
        Expected value is 'Stateful'.
        """
        service_type_name: pulumi.Input[str]
        """
        The name of the service type
        """
        correlation_scheme: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceCorrelationArgsDict']]]]
        """
        A list that describes the correlation of the service with other services.
        """
        default_move_cost: NotRequired[pulumi.Input[Union[str, 'MoveCost']]]
        """
        Specifies the move cost for the service.
        """
        has_persisted_state: NotRequired[pulumi.Input[bool]]
        """
        A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not it is false.
        """
        min_replica_set_size: NotRequired[pulumi.Input[int]]
        """
        The minimum replica set size as a number.
        """
        placement_constraints: NotRequired[pulumi.Input[str]]
        """
        The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
        """
        quorum_loss_wait_duration: NotRequired[pulumi.Input[str]]
        """
        The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format "hh:mm:ss".
        """
        replica_restart_wait_duration: NotRequired[pulumi.Input[str]]
        """
        The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format "hh:mm:ss".
        """
        scaling_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScalingPolicyArgsDict']]]]
        """
        Scaling policies for this service.
        """
        service_dns_name: NotRequired[pulumi.Input[str]]
        """
        Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service endpoints for application layer protocols (e.g., HTTP).
        When updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
        When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the name being unresolvable.
        """
        service_load_metrics: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceLoadMetricArgsDict']]]]
        """
        The service load metrics is given as an array of ServiceLoadMetric objects.
        """
        service_package_activation_mode: NotRequired[pulumi.Input[Union[str, 'ServicePackageActivationMode']]]
        """
        The activation Mode of the service package
        """
        service_placement_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union['ServicePlacementInvalidDomainPolicyArgsDict', 'ServicePlacementNonPartiallyPlaceServicePolicyArgsDict', 'ServicePlacementPreferPrimaryDomainPolicyArgsDict', 'ServicePlacementRequireDomainDistributionPolicyArgsDict', 'ServicePlacementRequiredDomainPolicyArgsDict']]]]]
        """
        A list that describes the correlation of the service with other services.
        """
        service_placement_time_limit: NotRequired[pulumi.Input[str]]
        """
        The duration for which replicas can stay InBuild before reporting that build is stuck, represented in ISO 8601 format "hh:mm:ss".
        """
        stand_by_replica_keep_duration: NotRequired[pulumi.Input[str]]
        """
        The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format "hh:mm:ss".
        """
        target_replica_set_size: NotRequired[pulumi.Input[int]]
        """
        The target replica set size as a number.
        """
elif False:
    StatefulServicePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulServicePropertiesArgs:
    def __init__(__self__, *,
                 partition_description: pulumi.Input[Union['NamedPartitionSchemeArgs', 'SingletonPartitionSchemeArgs', 'UniformInt64RangePartitionSchemeArgs']],
                 service_kind: pulumi.Input[str],
                 service_type_name: pulumi.Input[str],
                 correlation_scheme: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceCorrelationArgs']]]] = None,
                 default_move_cost: Optional[pulumi.Input[Union[str, 'MoveCost']]] = None,
                 has_persisted_state: Optional[pulumi.Input[bool]] = None,
                 min_replica_set_size: Optional[pulumi.Input[int]] = None,
                 placement_constraints: Optional[pulumi.Input[str]] = None,
                 quorum_loss_wait_duration: Optional[pulumi.Input[str]] = None,
                 replica_restart_wait_duration: Optional[pulumi.Input[str]] = None,
                 scaling_policies: Optional[pulumi.Input[Sequence[pulumi.Input['ScalingPolicyArgs']]]] = None,
                 service_dns_name: Optional[pulumi.Input[str]] = None,
                 service_load_metrics: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceLoadMetricArgs']]]] = None,
                 service_package_activation_mode: Optional[pulumi.Input[Union[str, 'ServicePackageActivationMode']]] = None,
                 service_placement_policies: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ServicePlacementInvalidDomainPolicyArgs', 'ServicePlacementNonPartiallyPlaceServicePolicyArgs', 'ServicePlacementPreferPrimaryDomainPolicyArgs', 'ServicePlacementRequireDomainDistributionPolicyArgs', 'ServicePlacementRequiredDomainPolicyArgs']]]]] = None,
                 service_placement_time_limit: Optional[pulumi.Input[str]] = None,
                 stand_by_replica_keep_duration: Optional[pulumi.Input[str]] = None,
                 target_replica_set_size: Optional[pulumi.Input[int]] = None):
        """
        The properties of a stateful service resource.
        :param pulumi.Input[Union['NamedPartitionSchemeArgs', 'SingletonPartitionSchemeArgs', 'UniformInt64RangePartitionSchemeArgs']] partition_description: Describes how the service is partitioned.
        :param pulumi.Input[str] service_kind: The kind of service (Stateless or Stateful).
               Expected value is 'Stateful'.
        :param pulumi.Input[str] service_type_name: The name of the service type
        :param pulumi.Input[Sequence[pulumi.Input['ServiceCorrelationArgs']]] correlation_scheme: A list that describes the correlation of the service with other services.
        :param pulumi.Input[Union[str, 'MoveCost']] default_move_cost: Specifies the move cost for the service.
        :param pulumi.Input[bool] has_persisted_state: A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not it is false.
        :param pulumi.Input[int] min_replica_set_size: The minimum replica set size as a number.
        :param pulumi.Input[str] placement_constraints: The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
        :param pulumi.Input[str] quorum_loss_wait_duration: The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format "hh:mm:ss".
        :param pulumi.Input[str] replica_restart_wait_duration: The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format "hh:mm:ss".
        :param pulumi.Input[Sequence[pulumi.Input['ScalingPolicyArgs']]] scaling_policies: Scaling policies for this service.
        :param pulumi.Input[str] service_dns_name: Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service endpoints for application layer protocols (e.g., HTTP).
               When updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
               When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the name being unresolvable.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceLoadMetricArgs']]] service_load_metrics: The service load metrics is given as an array of ServiceLoadMetric objects.
        :param pulumi.Input[Union[str, 'ServicePackageActivationMode']] service_package_activation_mode: The activation Mode of the service package
        :param pulumi.Input[Sequence[pulumi.Input[Union['ServicePlacementInvalidDomainPolicyArgs', 'ServicePlacementNonPartiallyPlaceServicePolicyArgs', 'ServicePlacementPreferPrimaryDomainPolicyArgs', 'ServicePlacementRequireDomainDistributionPolicyArgs', 'ServicePlacementRequiredDomainPolicyArgs']]]] service_placement_policies: A list that describes the correlation of the service with other services.
        :param pulumi.Input[str] service_placement_time_limit: The duration for which replicas can stay InBuild before reporting that build is stuck, represented in ISO 8601 format "hh:mm:ss".
        :param pulumi.Input[str] stand_by_replica_keep_duration: The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format "hh:mm:ss".
        :param pulumi.Input[int] target_replica_set_size: The target replica set size as a number.
        """
        pulumi.set(__self__, "partition_description", partition_description)
        pulumi.set(__self__, "service_kind", 'Stateful')
        pulumi.set(__self__, "service_type_name", service_type_name)
        if correlation_scheme is not None:
            pulumi.set(__self__, "correlation_scheme", correlation_scheme)
        if default_move_cost is not None:
            pulumi.set(__self__, "default_move_cost", default_move_cost)
        if has_persisted_state is not None:
            pulumi.set(__self__, "has_persisted_state", has_persisted_state)
        if min_replica_set_size is not None:
            pulumi.set(__self__, "min_replica_set_size", min_replica_set_size)
        if placement_constraints is not None:
            pulumi.set(__self__, "placement_constraints", placement_constraints)
        if quorum_loss_wait_duration is not None:
            pulumi.set(__self__, "quorum_loss_wait_duration", quorum_loss_wait_duration)
        if replica_restart_wait_duration is not None:
            pulumi.set(__self__, "replica_restart_wait_duration", replica_restart_wait_duration)
        if scaling_policies is not None:
            pulumi.set(__self__, "scaling_policies", scaling_policies)
        if service_dns_name is not None:
            pulumi.set(__self__, "service_dns_name", service_dns_name)
        if service_load_metrics is not None:
            pulumi.set(__self__, "service_load_metrics", service_load_metrics)
        if service_package_activation_mode is not None:
            pulumi.set(__self__, "service_package_activation_mode", service_package_activation_mode)
        if service_placement_policies is not None:
            pulumi.set(__self__, "service_placement_policies", service_placement_policies)
        if service_placement_time_limit is not None:
            pulumi.set(__self__, "service_placement_time_limit", service_placement_time_limit)
        if stand_by_replica_keep_duration is not None:
            pulumi.set(__self__, "stand_by_replica_keep_duration", stand_by_replica_keep_duration)
        if target_replica_set_size is not None:
            pulumi.set(__self__, "target_replica_set_size", target_replica_set_size)

    @property
    @pulumi.getter(name="partitionDescription")
    def partition_description(self) -> pulumi.Input[Union['NamedPartitionSchemeArgs', 'SingletonPartitionSchemeArgs', 'UniformInt64RangePartitionSchemeArgs']]:
        """
        Describes how the service is partitioned.
        """
        return pulumi.get(self, "partition_description")

    @partition_description.setter
    def partition_description(self, value: pulumi.Input[Union['NamedPartitionSchemeArgs', 'SingletonPartitionSchemeArgs', 'UniformInt64RangePartitionSchemeArgs']]):
        pulumi.set(self, "partition_description", value)

    @property
    @pulumi.getter(name="serviceKind")
    def service_kind(self) -> pulumi.Input[str]:
        """
        The kind of service (Stateless or Stateful).
        Expected value is 'Stateful'.
        """
        return pulumi.get(self, "service_kind")

    @service_kind.setter
    def service_kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_kind", value)

    @property
    @pulumi.getter(name="serviceTypeName")
    def service_type_name(self) -> pulumi.Input[str]:
        """
        The name of the service type
        """
        return pulumi.get(self, "service_type_name")

    @service_type_name.setter
    def service_type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_type_name", value)

    @property
    @pulumi.getter(name="correlationScheme")
    def correlation_scheme(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceCorrelationArgs']]]]:
        """
        A list that describes the correlation of the service with other services.
        """
        return pulumi.get(self, "correlation_scheme")

    @correlation_scheme.setter
    def correlation_scheme(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceCorrelationArgs']]]]):
        pulumi.set(self, "correlation_scheme", value)

    @property
    @pulumi.getter(name="defaultMoveCost")
    def default_move_cost(self) -> Optional[pulumi.Input[Union[str, 'MoveCost']]]:
        """
        Specifies the move cost for the service.
        """
        return pulumi.get(self, "default_move_cost")

    @default_move_cost.setter
    def default_move_cost(self, value: Optional[pulumi.Input[Union[str, 'MoveCost']]]):
        pulumi.set(self, "default_move_cost", value)

    @property
    @pulumi.getter(name="hasPersistedState")
    def has_persisted_state(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag indicating whether this is a persistent service which stores states on the local disk. If it is then the value of this property is true, if not it is false.
        """
        return pulumi.get(self, "has_persisted_state")

    @has_persisted_state.setter
    def has_persisted_state(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "has_persisted_state", value)

    @property
    @pulumi.getter(name="minReplicaSetSize")
    def min_replica_set_size(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum replica set size as a number.
        """
        return pulumi.get(self, "min_replica_set_size")

    @min_replica_set_size.setter
    def min_replica_set_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_replica_set_size", value)

    @property
    @pulumi.getter(name="placementConstraints")
    def placement_constraints(self) -> Optional[pulumi.Input[str]]:
        """
        The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
        """
        return pulumi.get(self, "placement_constraints")

    @placement_constraints.setter
    def placement_constraints(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "placement_constraints", value)

    @property
    @pulumi.getter(name="quorumLossWaitDuration")
    def quorum_loss_wait_duration(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum duration for which a partition is allowed to be in a state of quorum loss, represented in ISO 8601 format "hh:mm:ss".
        """
        return pulumi.get(self, "quorum_loss_wait_duration")

    @quorum_loss_wait_duration.setter
    def quorum_loss_wait_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quorum_loss_wait_duration", value)

    @property
    @pulumi.getter(name="replicaRestartWaitDuration")
    def replica_restart_wait_duration(self) -> Optional[pulumi.Input[str]]:
        """
        The duration between when a replica goes down and when a new replica is created, represented in ISO 8601 format "hh:mm:ss".
        """
        return pulumi.get(self, "replica_restart_wait_duration")

    @replica_restart_wait_duration.setter
    def replica_restart_wait_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replica_restart_wait_duration", value)

    @property
    @pulumi.getter(name="scalingPolicies")
    def scaling_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScalingPolicyArgs']]]]:
        """
        Scaling policies for this service.
        """
        return pulumi.get(self, "scaling_policies")

    @scaling_policies.setter
    def scaling_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScalingPolicyArgs']]]]):
        pulumi.set(self, "scaling_policies", value)

    @property
    @pulumi.getter(name="serviceDnsName")
    def service_dns_name(self) -> Optional[pulumi.Input[str]]:
        """
        Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service endpoints for application layer protocols (e.g., HTTP).
        When updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
        When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the name being unresolvable.
        """
        return pulumi.get(self, "service_dns_name")

    @service_dns_name.setter
    def service_dns_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_dns_name", value)

    @property
    @pulumi.getter(name="serviceLoadMetrics")
    def service_load_metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceLoadMetricArgs']]]]:
        """
        The service load metrics is given as an array of ServiceLoadMetric objects.
        """
        return pulumi.get(self, "service_load_metrics")

    @service_load_metrics.setter
    def service_load_metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceLoadMetricArgs']]]]):
        pulumi.set(self, "service_load_metrics", value)

    @property
    @pulumi.getter(name="servicePackageActivationMode")
    def service_package_activation_mode(self) -> Optional[pulumi.Input[Union[str, 'ServicePackageActivationMode']]]:
        """
        The activation Mode of the service package
        """
        return pulumi.get(self, "service_package_activation_mode")

    @service_package_activation_mode.setter
    def service_package_activation_mode(self, value: Optional[pulumi.Input[Union[str, 'ServicePackageActivationMode']]]):
        pulumi.set(self, "service_package_activation_mode", value)

    @property
    @pulumi.getter(name="servicePlacementPolicies")
    def service_placement_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['ServicePlacementInvalidDomainPolicyArgs', 'ServicePlacementNonPartiallyPlaceServicePolicyArgs', 'ServicePlacementPreferPrimaryDomainPolicyArgs', 'ServicePlacementRequireDomainDistributionPolicyArgs', 'ServicePlacementRequiredDomainPolicyArgs']]]]]:
        """
        A list that describes the correlation of the service with other services.
        """
        return pulumi.get(self, "service_placement_policies")

    @service_placement_policies.setter
    def service_placement_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ServicePlacementInvalidDomainPolicyArgs', 'ServicePlacementNonPartiallyPlaceServicePolicyArgs', 'ServicePlacementPreferPrimaryDomainPolicyArgs', 'ServicePlacementRequireDomainDistributionPolicyArgs', 'ServicePlacementRequiredDomainPolicyArgs']]]]]):
        pulumi.set(self, "service_placement_policies", value)

    @property
    @pulumi.getter(name="servicePlacementTimeLimit")
    def service_placement_time_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The duration for which replicas can stay InBuild before reporting that build is stuck, represented in ISO 8601 format "hh:mm:ss".
        """
        return pulumi.get(self, "service_placement_time_limit")

    @service_placement_time_limit.setter
    def service_placement_time_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_placement_time_limit", value)

    @property
    @pulumi.getter(name="standByReplicaKeepDuration")
    def stand_by_replica_keep_duration(self) -> Optional[pulumi.Input[str]]:
        """
        The definition on how long StandBy replicas should be maintained before being removed, represented in ISO 8601 format "hh:mm:ss".
        """
        return pulumi.get(self, "stand_by_replica_keep_duration")

    @stand_by_replica_keep_duration.setter
    def stand_by_replica_keep_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stand_by_replica_keep_duration", value)

    @property
    @pulumi.getter(name="targetReplicaSetSize")
    def target_replica_set_size(self) -> Optional[pulumi.Input[int]]:
        """
        The target replica set size as a number.
        """
        return pulumi.get(self, "target_replica_set_size")

    @target_replica_set_size.setter
    def target_replica_set_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_replica_set_size", value)


if not MYPY:
    class StatelessServicePropertiesArgsDict(TypedDict):
        """
        The properties of a stateless service resource.
        """
        instance_count: pulumi.Input[int]
        """
        The instance count.
        """
        partition_description: pulumi.Input[Union['NamedPartitionSchemeArgsDict', 'SingletonPartitionSchemeArgsDict', 'UniformInt64RangePartitionSchemeArgsDict']]
        """
        Describes how the service is partitioned.
        """
        service_kind: pulumi.Input[str]
        """
        The kind of service (Stateless or Stateful).
        Expected value is 'Stateless'.
        """
        service_type_name: pulumi.Input[str]
        """
        The name of the service type
        """
        correlation_scheme: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceCorrelationArgsDict']]]]
        """
        A list that describes the correlation of the service with other services.
        """
        default_move_cost: NotRequired[pulumi.Input[Union[str, 'MoveCost']]]
        """
        Specifies the move cost for the service.
        """
        min_instance_count: NotRequired[pulumi.Input[int]]
        """
        MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
        """
        min_instance_percentage: NotRequired[pulumi.Input[int]]
        """
        MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
        """
        placement_constraints: NotRequired[pulumi.Input[str]]
        """
        The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
        """
        scaling_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScalingPolicyArgsDict']]]]
        """
        Scaling policies for this service.
        """
        service_dns_name: NotRequired[pulumi.Input[str]]
        """
        Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service endpoints for application layer protocols (e.g., HTTP).
        When updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
        When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the name being unresolvable.
        """
        service_load_metrics: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceLoadMetricArgsDict']]]]
        """
        The service load metrics is given as an array of ServiceLoadMetric objects.
        """
        service_package_activation_mode: NotRequired[pulumi.Input[Union[str, 'ServicePackageActivationMode']]]
        """
        The activation Mode of the service package
        """
        service_placement_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union['ServicePlacementInvalidDomainPolicyArgsDict', 'ServicePlacementNonPartiallyPlaceServicePolicyArgsDict', 'ServicePlacementPreferPrimaryDomainPolicyArgsDict', 'ServicePlacementRequireDomainDistributionPolicyArgsDict', 'ServicePlacementRequiredDomainPolicyArgsDict']]]]]
        """
        A list that describes the correlation of the service with other services.
        """
elif False:
    StatelessServicePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatelessServicePropertiesArgs:
    def __init__(__self__, *,
                 instance_count: pulumi.Input[int],
                 partition_description: pulumi.Input[Union['NamedPartitionSchemeArgs', 'SingletonPartitionSchemeArgs', 'UniformInt64RangePartitionSchemeArgs']],
                 service_kind: pulumi.Input[str],
                 service_type_name: pulumi.Input[str],
                 correlation_scheme: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceCorrelationArgs']]]] = None,
                 default_move_cost: Optional[pulumi.Input[Union[str, 'MoveCost']]] = None,
                 min_instance_count: Optional[pulumi.Input[int]] = None,
                 min_instance_percentage: Optional[pulumi.Input[int]] = None,
                 placement_constraints: Optional[pulumi.Input[str]] = None,
                 scaling_policies: Optional[pulumi.Input[Sequence[pulumi.Input['ScalingPolicyArgs']]]] = None,
                 service_dns_name: Optional[pulumi.Input[str]] = None,
                 service_load_metrics: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceLoadMetricArgs']]]] = None,
                 service_package_activation_mode: Optional[pulumi.Input[Union[str, 'ServicePackageActivationMode']]] = None,
                 service_placement_policies: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ServicePlacementInvalidDomainPolicyArgs', 'ServicePlacementNonPartiallyPlaceServicePolicyArgs', 'ServicePlacementPreferPrimaryDomainPolicyArgs', 'ServicePlacementRequireDomainDistributionPolicyArgs', 'ServicePlacementRequiredDomainPolicyArgs']]]]] = None):
        """
        The properties of a stateless service resource.
        :param pulumi.Input[int] instance_count: The instance count.
        :param pulumi.Input[Union['NamedPartitionSchemeArgs', 'SingletonPartitionSchemeArgs', 'UniformInt64RangePartitionSchemeArgs']] partition_description: Describes how the service is partitioned.
        :param pulumi.Input[str] service_kind: The kind of service (Stateless or Stateful).
               Expected value is 'Stateless'.
        :param pulumi.Input[str] service_type_name: The name of the service type
        :param pulumi.Input[Sequence[pulumi.Input['ServiceCorrelationArgs']]] correlation_scheme: A list that describes the correlation of the service with other services.
        :param pulumi.Input[Union[str, 'MoveCost']] default_move_cost: Specifies the move cost for the service.
        :param pulumi.Input[int] min_instance_count: MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
        :param pulumi.Input[int] min_instance_percentage: MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
        :param pulumi.Input[str] placement_constraints: The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
        :param pulumi.Input[Sequence[pulumi.Input['ScalingPolicyArgs']]] scaling_policies: Scaling policies for this service.
        :param pulumi.Input[str] service_dns_name: Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service endpoints for application layer protocols (e.g., HTTP).
               When updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
               When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the name being unresolvable.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceLoadMetricArgs']]] service_load_metrics: The service load metrics is given as an array of ServiceLoadMetric objects.
        :param pulumi.Input[Union[str, 'ServicePackageActivationMode']] service_package_activation_mode: The activation Mode of the service package
        :param pulumi.Input[Sequence[pulumi.Input[Union['ServicePlacementInvalidDomainPolicyArgs', 'ServicePlacementNonPartiallyPlaceServicePolicyArgs', 'ServicePlacementPreferPrimaryDomainPolicyArgs', 'ServicePlacementRequireDomainDistributionPolicyArgs', 'ServicePlacementRequiredDomainPolicyArgs']]]] service_placement_policies: A list that describes the correlation of the service with other services.
        """
        pulumi.set(__self__, "instance_count", instance_count)
        pulumi.set(__self__, "partition_description", partition_description)
        pulumi.set(__self__, "service_kind", 'Stateless')
        pulumi.set(__self__, "service_type_name", service_type_name)
        if correlation_scheme is not None:
            pulumi.set(__self__, "correlation_scheme", correlation_scheme)
        if default_move_cost is not None:
            pulumi.set(__self__, "default_move_cost", default_move_cost)
        if min_instance_count is not None:
            pulumi.set(__self__, "min_instance_count", min_instance_count)
        if min_instance_percentage is not None:
            pulumi.set(__self__, "min_instance_percentage", min_instance_percentage)
        if placement_constraints is not None:
            pulumi.set(__self__, "placement_constraints", placement_constraints)
        if scaling_policies is not None:
            pulumi.set(__self__, "scaling_policies", scaling_policies)
        if service_dns_name is not None:
            pulumi.set(__self__, "service_dns_name", service_dns_name)
        if service_load_metrics is not None:
            pulumi.set(__self__, "service_load_metrics", service_load_metrics)
        if service_package_activation_mode is not None:
            pulumi.set(__self__, "service_package_activation_mode", service_package_activation_mode)
        if service_placement_policies is not None:
            pulumi.set(__self__, "service_placement_policies", service_placement_policies)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> pulumi.Input[int]:
        """
        The instance count.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="partitionDescription")
    def partition_description(self) -> pulumi.Input[Union['NamedPartitionSchemeArgs', 'SingletonPartitionSchemeArgs', 'UniformInt64RangePartitionSchemeArgs']]:
        """
        Describes how the service is partitioned.
        """
        return pulumi.get(self, "partition_description")

    @partition_description.setter
    def partition_description(self, value: pulumi.Input[Union['NamedPartitionSchemeArgs', 'SingletonPartitionSchemeArgs', 'UniformInt64RangePartitionSchemeArgs']]):
        pulumi.set(self, "partition_description", value)

    @property
    @pulumi.getter(name="serviceKind")
    def service_kind(self) -> pulumi.Input[str]:
        """
        The kind of service (Stateless or Stateful).
        Expected value is 'Stateless'.
        """
        return pulumi.get(self, "service_kind")

    @service_kind.setter
    def service_kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_kind", value)

    @property
    @pulumi.getter(name="serviceTypeName")
    def service_type_name(self) -> pulumi.Input[str]:
        """
        The name of the service type
        """
        return pulumi.get(self, "service_type_name")

    @service_type_name.setter
    def service_type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_type_name", value)

    @property
    @pulumi.getter(name="correlationScheme")
    def correlation_scheme(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceCorrelationArgs']]]]:
        """
        A list that describes the correlation of the service with other services.
        """
        return pulumi.get(self, "correlation_scheme")

    @correlation_scheme.setter
    def correlation_scheme(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceCorrelationArgs']]]]):
        pulumi.set(self, "correlation_scheme", value)

    @property
    @pulumi.getter(name="defaultMoveCost")
    def default_move_cost(self) -> Optional[pulumi.Input[Union[str, 'MoveCost']]]:
        """
        Specifies the move cost for the service.
        """
        return pulumi.get(self, "default_move_cost")

    @default_move_cost.setter
    def default_move_cost(self, value: Optional[pulumi.Input[Union[str, 'MoveCost']]]):
        pulumi.set(self, "default_move_cost", value)

    @property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
        """
        return pulumi.get(self, "min_instance_count")

    @min_instance_count.setter
    def min_instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_instance_count", value)

    @property
    @pulumi.getter(name="minInstancePercentage")
    def min_instance_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
        """
        return pulumi.get(self, "min_instance_percentage")

    @min_instance_percentage.setter
    def min_instance_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_instance_percentage", value)

    @property
    @pulumi.getter(name="placementConstraints")
    def placement_constraints(self) -> Optional[pulumi.Input[str]]:
        """
        The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: "NodeColor == blue)".
        """
        return pulumi.get(self, "placement_constraints")

    @placement_constraints.setter
    def placement_constraints(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "placement_constraints", value)

    @property
    @pulumi.getter(name="scalingPolicies")
    def scaling_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScalingPolicyArgs']]]]:
        """
        Scaling policies for this service.
        """
        return pulumi.get(self, "scaling_policies")

    @scaling_policies.setter
    def scaling_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScalingPolicyArgs']]]]):
        pulumi.set(self, "scaling_policies", value)

    @property
    @pulumi.getter(name="serviceDnsName")
    def service_dns_name(self) -> Optional[pulumi.Input[str]]:
        """
        Dns name used for the service. If this is specified, then the DNS name can be used to return the IP addresses of service endpoints for application layer protocols (e.g., HTTP).
        When updating serviceDnsName, old name may be temporarily resolvable. However, rely on new name.
        When removing serviceDnsName, removed name may temporarily be resolvable. Do not rely on the name being unresolvable.
        """
        return pulumi.get(self, "service_dns_name")

    @service_dns_name.setter
    def service_dns_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_dns_name", value)

    @property
    @pulumi.getter(name="serviceLoadMetrics")
    def service_load_metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceLoadMetricArgs']]]]:
        """
        The service load metrics is given as an array of ServiceLoadMetric objects.
        """
        return pulumi.get(self, "service_load_metrics")

    @service_load_metrics.setter
    def service_load_metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceLoadMetricArgs']]]]):
        pulumi.set(self, "service_load_metrics", value)

    @property
    @pulumi.getter(name="servicePackageActivationMode")
    def service_package_activation_mode(self) -> Optional[pulumi.Input[Union[str, 'ServicePackageActivationMode']]]:
        """
        The activation Mode of the service package
        """
        return pulumi.get(self, "service_package_activation_mode")

    @service_package_activation_mode.setter
    def service_package_activation_mode(self, value: Optional[pulumi.Input[Union[str, 'ServicePackageActivationMode']]]):
        pulumi.set(self, "service_package_activation_mode", value)

    @property
    @pulumi.getter(name="servicePlacementPolicies")
    def service_placement_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['ServicePlacementInvalidDomainPolicyArgs', 'ServicePlacementNonPartiallyPlaceServicePolicyArgs', 'ServicePlacementPreferPrimaryDomainPolicyArgs', 'ServicePlacementRequireDomainDistributionPolicyArgs', 'ServicePlacementRequiredDomainPolicyArgs']]]]]:
        """
        A list that describes the correlation of the service with other services.
        """
        return pulumi.get(self, "service_placement_policies")

    @service_placement_policies.setter
    def service_placement_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ServicePlacementInvalidDomainPolicyArgs', 'ServicePlacementNonPartiallyPlaceServicePolicyArgs', 'ServicePlacementPreferPrimaryDomainPolicyArgs', 'ServicePlacementRequireDomainDistributionPolicyArgs', 'ServicePlacementRequiredDomainPolicyArgs']]]]]):
        pulumi.set(self, "service_placement_policies", value)


if not MYPY:
    class SubResourceArgsDict(TypedDict):
        """
        Azure resource identifier.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Sub-resource ID. Both absolute resource ID and a relative resource ID are accepted.
        An absolute ID starts with /subscriptions/ and contains the entire ID of the parent resource and the ID of the sub-resource in the end.
        A relative ID replaces the ID of the parent resource with a token '$self', followed by the sub-resource ID itself.
        Example of a relative ID: $self/frontEndConfigurations/my-frontend.
        """
elif False:
    SubResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubResourceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        Azure resource identifier.
        :param pulumi.Input[str] id: Sub-resource ID. Both absolute resource ID and a relative resource ID are accepted.
               An absolute ID starts with /subscriptions/ and contains the entire ID of the parent resource and the ID of the sub-resource in the end.
               A relative ID replaces the ID of the parent resource with a token '$self', followed by the sub-resource ID itself.
               Example of a relative ID: $self/frontEndConfigurations/my-frontend.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Sub-resource ID. Both absolute resource ID and a relative resource ID are accepted.
        An absolute ID starts with /subscriptions/ and contains the entire ID of the parent resource and the ID of the sub-resource in the end.
        A relative ID replaces the ID of the parent resource with a token '$self', followed by the sub-resource ID itself.
        Example of a relative ID: $self/frontEndConfigurations/my-frontend.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class SubnetArgsDict(TypedDict):
        """
        Describes a Subnet.
        """
        name: pulumi.Input[str]
        """
        Subnet name.
        """
        enable_ipv6: NotRequired[pulumi.Input[bool]]
        """
        Indicates wether to enable Ipv6 or not. If not provided, it will take the same configuration as the cluster.
        """
        network_security_group_id: NotRequired[pulumi.Input[str]]
        """
        Full resource id for the network security group.
        """
        private_endpoint_network_policies: NotRequired[pulumi.Input[Union[str, 'PrivateEndpointNetworkPolicies']]]
        """
        Enable or Disable apply network policies on private end point in the subnet.
        """
        private_link_service_network_policies: NotRequired[pulumi.Input[Union[str, 'PrivateLinkServiceNetworkPolicies']]]
        """
        Enable or Disable apply network policies on private link service in the subnet.
        """
elif False:
    SubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 enable_ipv6: Optional[pulumi.Input[bool]] = None,
                 network_security_group_id: Optional[pulumi.Input[str]] = None,
                 private_endpoint_network_policies: Optional[pulumi.Input[Union[str, 'PrivateEndpointNetworkPolicies']]] = None,
                 private_link_service_network_policies: Optional[pulumi.Input[Union[str, 'PrivateLinkServiceNetworkPolicies']]] = None):
        """
        Describes a Subnet.
        :param pulumi.Input[str] name: Subnet name.
        :param pulumi.Input[bool] enable_ipv6: Indicates wether to enable Ipv6 or not. If not provided, it will take the same configuration as the cluster.
        :param pulumi.Input[str] network_security_group_id: Full resource id for the network security group.
        :param pulumi.Input[Union[str, 'PrivateEndpointNetworkPolicies']] private_endpoint_network_policies: Enable or Disable apply network policies on private end point in the subnet.
        :param pulumi.Input[Union[str, 'PrivateLinkServiceNetworkPolicies']] private_link_service_network_policies: Enable or Disable apply network policies on private link service in the subnet.
        """
        pulumi.set(__self__, "name", name)
        if enable_ipv6 is not None:
            pulumi.set(__self__, "enable_ipv6", enable_ipv6)
        if network_security_group_id is not None:
            pulumi.set(__self__, "network_security_group_id", network_security_group_id)
        if private_endpoint_network_policies is not None:
            pulumi.set(__self__, "private_endpoint_network_policies", private_endpoint_network_policies)
        if private_link_service_network_policies is not None:
            pulumi.set(__self__, "private_link_service_network_policies", private_link_service_network_policies)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Subnet name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="enableIpv6")
    def enable_ipv6(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates wether to enable Ipv6 or not. If not provided, it will take the same configuration as the cluster.
        """
        return pulumi.get(self, "enable_ipv6")

    @enable_ipv6.setter
    def enable_ipv6(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_ipv6", value)

    @property
    @pulumi.getter(name="networkSecurityGroupId")
    def network_security_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Full resource id for the network security group.
        """
        return pulumi.get(self, "network_security_group_id")

    @network_security_group_id.setter
    def network_security_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_security_group_id", value)

    @property
    @pulumi.getter(name="privateEndpointNetworkPolicies")
    def private_endpoint_network_policies(self) -> Optional[pulumi.Input[Union[str, 'PrivateEndpointNetworkPolicies']]]:
        """
        Enable or Disable apply network policies on private end point in the subnet.
        """
        return pulumi.get(self, "private_endpoint_network_policies")

    @private_endpoint_network_policies.setter
    def private_endpoint_network_policies(self, value: Optional[pulumi.Input[Union[str, 'PrivateEndpointNetworkPolicies']]]):
        pulumi.set(self, "private_endpoint_network_policies", value)

    @property
    @pulumi.getter(name="privateLinkServiceNetworkPolicies")
    def private_link_service_network_policies(self) -> Optional[pulumi.Input[Union[str, 'PrivateLinkServiceNetworkPolicies']]]:
        """
        Enable or Disable apply network policies on private link service in the subnet.
        """
        return pulumi.get(self, "private_link_service_network_policies")

    @private_link_service_network_policies.setter
    def private_link_service_network_policies(self, value: Optional[pulumi.Input[Union[str, 'PrivateLinkServiceNetworkPolicies']]]):
        pulumi.set(self, "private_link_service_network_policies", value)


if not MYPY:
    class UniformInt64RangePartitionSchemeArgsDict(TypedDict):
        """
        Describes a partitioning scheme where an integer range is allocated evenly across a number of partitions.
        """
        count: pulumi.Input[int]
        """
        The number of partitions.
        """
        high_key: pulumi.Input[float]
        """
        The upper bound of the partition key range that
        should be split between the partition Count
        """
        low_key: pulumi.Input[float]
        """
        The lower bound of the partition key range that
        should be split between the partition Count
        """
        partition_scheme: pulumi.Input[str]
        """
        Enumerates the ways that a service can be partitioned.
        Expected value is 'UniformInt64Range'.
        """
elif False:
    UniformInt64RangePartitionSchemeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UniformInt64RangePartitionSchemeArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 high_key: pulumi.Input[float],
                 low_key: pulumi.Input[float],
                 partition_scheme: pulumi.Input[str]):
        """
        Describes a partitioning scheme where an integer range is allocated evenly across a number of partitions.
        :param pulumi.Input[int] count: The number of partitions.
        :param pulumi.Input[float] high_key: The upper bound of the partition key range that
               should be split between the partition Count
        :param pulumi.Input[float] low_key: The lower bound of the partition key range that
               should be split between the partition Count
        :param pulumi.Input[str] partition_scheme: Enumerates the ways that a service can be partitioned.
               Expected value is 'UniformInt64Range'.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "high_key", high_key)
        pulumi.set(__self__, "low_key", low_key)
        pulumi.set(__self__, "partition_scheme", 'UniformInt64Range')

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The number of partitions.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter(name="highKey")
    def high_key(self) -> pulumi.Input[float]:
        """
        The upper bound of the partition key range that
        should be split between the partition Count
        """
        return pulumi.get(self, "high_key")

    @high_key.setter
    def high_key(self, value: pulumi.Input[float]):
        pulumi.set(self, "high_key", value)

    @property
    @pulumi.getter(name="lowKey")
    def low_key(self) -> pulumi.Input[float]:
        """
        The lower bound of the partition key range that
        should be split between the partition Count
        """
        return pulumi.get(self, "low_key")

    @low_key.setter
    def low_key(self, value: pulumi.Input[float]):
        pulumi.set(self, "low_key", value)

    @property
    @pulumi.getter(name="partitionScheme")
    def partition_scheme(self) -> pulumi.Input[str]:
        """
        Enumerates the ways that a service can be partitioned.
        Expected value is 'UniformInt64Range'.
        """
        return pulumi.get(self, "partition_scheme")

    @partition_scheme.setter
    def partition_scheme(self, value: pulumi.Input[str]):
        pulumi.set(self, "partition_scheme", value)


if not MYPY:
    class VMSSExtensionArgsDict(TypedDict):
        """
        Specifies set of extensions that should be installed onto the virtual machines.
        """
        name: pulumi.Input[str]
        """
        The name of the extension.
        """
        publisher: pulumi.Input[str]
        """
        The name of the extension handler publisher.
        """
        type: pulumi.Input[str]
        """
        Specifies the type of the extension; an example is "CustomScriptExtension".
        """
        type_handler_version: pulumi.Input[str]
        """
        Specifies the version of the script handler.
        """
        auto_upgrade_minor_version: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
        """
        enable_automatic_upgrade: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the extension should be automatically upgraded by the platform if there is a newer version of the extension available.
        """
        force_update_tag: NotRequired[pulumi.Input[str]]
        """
        If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
        """
        protected_settings: NotRequired[Any]
        """
        The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
        """
        provision_after_extensions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Collection of extension names after which this extension needs to be provisioned.
        """
        settings: NotRequired[Any]
        """
        Json formatted public settings for the extension.
        """
elif False:
    VMSSExtensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VMSSExtensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 publisher: pulumi.Input[str],
                 type: pulumi.Input[str],
                 type_handler_version: pulumi.Input[str],
                 auto_upgrade_minor_version: Optional[pulumi.Input[bool]] = None,
                 enable_automatic_upgrade: Optional[pulumi.Input[bool]] = None,
                 force_update_tag: Optional[pulumi.Input[str]] = None,
                 protected_settings: Optional[Any] = None,
                 provision_after_extensions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 settings: Optional[Any] = None):
        """
        Specifies set of extensions that should be installed onto the virtual machines.
        :param pulumi.Input[str] name: The name of the extension.
        :param pulumi.Input[str] publisher: The name of the extension handler publisher.
        :param pulumi.Input[str] type: Specifies the type of the extension; an example is "CustomScriptExtension".
        :param pulumi.Input[str] type_handler_version: Specifies the version of the script handler.
        :param pulumi.Input[bool] auto_upgrade_minor_version: Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
        :param pulumi.Input[bool] enable_automatic_upgrade: Indicates whether the extension should be automatically upgraded by the platform if there is a newer version of the extension available.
        :param pulumi.Input[str] force_update_tag: If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
        :param Any protected_settings: The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] provision_after_extensions: Collection of extension names after which this extension needs to be provisioned.
        :param Any settings: Json formatted public settings for the extension.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "type_handler_version", type_handler_version)
        if auto_upgrade_minor_version is not None:
            pulumi.set(__self__, "auto_upgrade_minor_version", auto_upgrade_minor_version)
        if enable_automatic_upgrade is not None:
            pulumi.set(__self__, "enable_automatic_upgrade", enable_automatic_upgrade)
        if force_update_tag is not None:
            pulumi.set(__self__, "force_update_tag", force_update_tag)
        if protected_settings is not None:
            pulumi.set(__self__, "protected_settings", protected_settings)
        if provision_after_extensions is not None:
            pulumi.set(__self__, "provision_after_extensions", provision_after_extensions)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the extension.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        The name of the extension handler publisher.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of the extension; an example is "CustomScriptExtension".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="typeHandlerVersion")
    def type_handler_version(self) -> pulumi.Input[str]:
        """
        Specifies the version of the script handler.
        """
        return pulumi.get(self, "type_handler_version")

    @type_handler_version.setter
    def type_handler_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_handler_version", value)

    @property
    @pulumi.getter(name="autoUpgradeMinorVersion")
    def auto_upgrade_minor_version(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
        """
        return pulumi.get(self, "auto_upgrade_minor_version")

    @auto_upgrade_minor_version.setter
    def auto_upgrade_minor_version(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_upgrade_minor_version", value)

    @property
    @pulumi.getter(name="enableAutomaticUpgrade")
    def enable_automatic_upgrade(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the extension should be automatically upgraded by the platform if there is a newer version of the extension available.
        """
        return pulumi.get(self, "enable_automatic_upgrade")

    @enable_automatic_upgrade.setter
    def enable_automatic_upgrade(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_automatic_upgrade", value)

    @property
    @pulumi.getter(name="forceUpdateTag")
    def force_update_tag(self) -> Optional[pulumi.Input[str]]:
        """
        If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
        """
        return pulumi.get(self, "force_update_tag")

    @force_update_tag.setter
    def force_update_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "force_update_tag", value)

    @property
    @pulumi.getter(name="protectedSettings")
    def protected_settings(self) -> Optional[Any]:
        """
        The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
        """
        return pulumi.get(self, "protected_settings")

    @protected_settings.setter
    def protected_settings(self, value: Optional[Any]):
        pulumi.set(self, "protected_settings", value)

    @property
    @pulumi.getter(name="provisionAfterExtensions")
    def provision_after_extensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Collection of extension names after which this extension needs to be provisioned.
        """
        return pulumi.get(self, "provision_after_extensions")

    @provision_after_extensions.setter
    def provision_after_extensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "provision_after_extensions", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[Any]:
        """
        Json formatted public settings for the extension.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[Any]):
        pulumi.set(self, "settings", value)


if not MYPY:
    class VaultCertificateArgsDict(TypedDict):
        """
        Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
        """
        certificate_store: pulumi.Input[str]
        """
        For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name <UppercaseThumbprint>.crt for the X509 certificate file and <UppercaseThumbprint>.prv for private key. Both of these files are .pem formatted.
        """
        certificate_url: pulumi.Input[str]
        """
        This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
        """
elif False:
    VaultCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultCertificateArgs:
    def __init__(__self__, *,
                 certificate_store: pulumi.Input[str],
                 certificate_url: pulumi.Input[str]):
        """
        Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
        :param pulumi.Input[str] certificate_store: For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name <UppercaseThumbprint>.crt for the X509 certificate file and <UppercaseThumbprint>.prv for private key. Both of these files are .pem formatted.
        :param pulumi.Input[str] certificate_url: This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
        """
        pulumi.set(__self__, "certificate_store", certificate_store)
        pulumi.set(__self__, "certificate_url", certificate_url)

    @property
    @pulumi.getter(name="certificateStore")
    def certificate_store(self) -> pulumi.Input[str]:
        """
        For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name <UppercaseThumbprint>.crt for the X509 certificate file and <UppercaseThumbprint>.prv for private key. Both of these files are .pem formatted.
        """
        return pulumi.get(self, "certificate_store")

    @certificate_store.setter
    def certificate_store(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_store", value)

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> pulumi.Input[str]:
        """
        This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
        """
        return pulumi.get(self, "certificate_url")

    @certificate_url.setter
    def certificate_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_url", value)


if not MYPY:
    class VaultSecretGroupArgsDict(TypedDict):
        """
        Specifies set of certificates that should be installed onto the virtual machines.
        """
        source_vault: pulumi.Input['SubResourceArgsDict']
        """
        The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
        """
        vault_certificates: pulumi.Input[Sequence[pulumi.Input['VaultCertificateArgsDict']]]
        """
        The list of key vault references in SourceVault which contain certificates.
        """
elif False:
    VaultSecretGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultSecretGroupArgs:
    def __init__(__self__, *,
                 source_vault: pulumi.Input['SubResourceArgs'],
                 vault_certificates: pulumi.Input[Sequence[pulumi.Input['VaultCertificateArgs']]]):
        """
        Specifies set of certificates that should be installed onto the virtual machines.
        :param pulumi.Input['SubResourceArgs'] source_vault: The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
        :param pulumi.Input[Sequence[pulumi.Input['VaultCertificateArgs']]] vault_certificates: The list of key vault references in SourceVault which contain certificates.
        """
        pulumi.set(__self__, "source_vault", source_vault)
        pulumi.set(__self__, "vault_certificates", vault_certificates)

    @property
    @pulumi.getter(name="sourceVault")
    def source_vault(self) -> pulumi.Input['SubResourceArgs']:
        """
        The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
        """
        return pulumi.get(self, "source_vault")

    @source_vault.setter
    def source_vault(self, value: pulumi.Input['SubResourceArgs']):
        pulumi.set(self, "source_vault", value)

    @property
    @pulumi.getter(name="vaultCertificates")
    def vault_certificates(self) -> pulumi.Input[Sequence[pulumi.Input['VaultCertificateArgs']]]:
        """
        The list of key vault references in SourceVault which contain certificates.
        """
        return pulumi.get(self, "vault_certificates")

    @vault_certificates.setter
    def vault_certificates(self, value: pulumi.Input[Sequence[pulumi.Input['VaultCertificateArgs']]]):
        pulumi.set(self, "vault_certificates", value)


if not MYPY:
    class VmImagePlanArgsDict(TypedDict):
        """
        Specifies information about the marketplace image used to create the virtual machine. This element is only used for marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic use. In the Azure portal, find the marketplace image that you want to use and then click Want to deploy programmatically, Get Started ->. Enter any required information and then click Save.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The plan ID.
        """
        product: NotRequired[pulumi.Input[str]]
        """
        Specifies the product of the image from the marketplace. This is the same value as Offer under the imageReference element.
        """
        promotion_code: NotRequired[pulumi.Input[str]]
        """
        The promotion code.
        """
        publisher: NotRequired[pulumi.Input[str]]
        """
        The publisher ID.
        """
elif False:
    VmImagePlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmImagePlanArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 product: Optional[pulumi.Input[str]] = None,
                 promotion_code: Optional[pulumi.Input[str]] = None,
                 publisher: Optional[pulumi.Input[str]] = None):
        """
        Specifies information about the marketplace image used to create the virtual machine. This element is only used for marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic use. In the Azure portal, find the marketplace image that you want to use and then click Want to deploy programmatically, Get Started ->. Enter any required information and then click Save.
        :param pulumi.Input[str] name: The plan ID.
        :param pulumi.Input[str] product: Specifies the product of the image from the marketplace. This is the same value as Offer under the imageReference element.
        :param pulumi.Input[str] promotion_code: The promotion code.
        :param pulumi.Input[str] publisher: The publisher ID.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if product is not None:
            pulumi.set(__self__, "product", product)
        if promotion_code is not None:
            pulumi.set(__self__, "promotion_code", promotion_code)
        if publisher is not None:
            pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The plan ID.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def product(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the product of the image from the marketplace. This is the same value as Offer under the imageReference element.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter(name="promotionCode")
    def promotion_code(self) -> Optional[pulumi.Input[str]]:
        """
        The promotion code.
        """
        return pulumi.get(self, "promotion_code")

    @promotion_code.setter
    def promotion_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "promotion_code", value)

    @property
    @pulumi.getter
    def publisher(self) -> Optional[pulumi.Input[str]]:
        """
        The publisher ID.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "publisher", value)


if not MYPY:
    class VmManagedIdentityArgsDict(TypedDict):
        """
        Identities for the virtual machine scale set under the node type.
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
elif False:
    VmManagedIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmManagedIdentityArgs:
    def __init__(__self__, *,
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Identities for the virtual machine scale set under the node type.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of user identities associated with the virtual machine scale set under the node type. Each entry will be an ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class VmssDataDiskArgsDict(TypedDict):
        """
        Managed data disk description.
        """
        disk_letter: pulumi.Input[str]
        """
        Managed data disk letter. It can not use the reserved letter C or D and it can not change after created.
        """
        disk_size_gb: pulumi.Input[int]
        """
        Disk size for each vm in the node type in GBs.
        """
        disk_type: pulumi.Input[Union[str, 'DiskType']]
        """
        Managed data disk type. Specifies the storage account type for the managed disk
        """
        lun: pulumi.Input[int]
        """
        Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM. Lun 0 is reserved for the service fabric data disk.
        """
elif False:
    VmssDataDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmssDataDiskArgs:
    def __init__(__self__, *,
                 disk_letter: pulumi.Input[str],
                 disk_size_gb: pulumi.Input[int],
                 disk_type: pulumi.Input[Union[str, 'DiskType']],
                 lun: pulumi.Input[int]):
        """
        Managed data disk description.
        :param pulumi.Input[str] disk_letter: Managed data disk letter. It can not use the reserved letter C or D and it can not change after created.
        :param pulumi.Input[int] disk_size_gb: Disk size for each vm in the node type in GBs.
        :param pulumi.Input[Union[str, 'DiskType']] disk_type: Managed data disk type. Specifies the storage account type for the managed disk
        :param pulumi.Input[int] lun: Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM. Lun 0 is reserved for the service fabric data disk.
        """
        pulumi.set(__self__, "disk_letter", disk_letter)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "disk_type", disk_type)
        pulumi.set(__self__, "lun", lun)

    @property
    @pulumi.getter(name="diskLetter")
    def disk_letter(self) -> pulumi.Input[str]:
        """
        Managed data disk letter. It can not use the reserved letter C or D and it can not change after created.
        """
        return pulumi.get(self, "disk_letter")

    @disk_letter.setter
    def disk_letter(self, value: pulumi.Input[str]):
        pulumi.set(self, "disk_letter", value)

    @property
    @pulumi.getter(name="diskSizeGB")
    def disk_size_gb(self) -> pulumi.Input[int]:
        """
        Disk size for each vm in the node type in GBs.
        """
        return pulumi.get(self, "disk_size_gb")

    @disk_size_gb.setter
    def disk_size_gb(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size_gb", value)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> pulumi.Input[Union[str, 'DiskType']]:
        """
        Managed data disk type. Specifies the storage account type for the managed disk
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: pulumi.Input[Union[str, 'DiskType']]):
        pulumi.set(self, "disk_type", value)

    @property
    @pulumi.getter
    def lun(self) -> pulumi.Input[int]:
        """
        Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM. Lun 0 is reserved for the service fabric data disk.
        """
        return pulumi.get(self, "lun")

    @lun.setter
    def lun(self, value: pulumi.Input[int]):
        pulumi.set(self, "lun", value)


