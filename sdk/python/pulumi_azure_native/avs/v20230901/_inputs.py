# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'AvailabilityPropertiesArgs',
    'AvailabilityPropertiesArgsDict',
    'DiskPoolVolumeArgs',
    'DiskPoolVolumeArgsDict',
    'ElasticSanVolumeArgs',
    'ElasticSanVolumeArgsDict',
    'EncryptionKeyVaultPropertiesArgs',
    'EncryptionKeyVaultPropertiesArgsDict',
    'EncryptionArgs',
    'EncryptionArgsDict',
    'IdentitySourceArgs',
    'IdentitySourceArgsDict',
    'ManagementClusterArgs',
    'ManagementClusterArgsDict',
    'NetAppVolumeArgs',
    'NetAppVolumeArgsDict',
    'PSCredentialExecutionParameterArgs',
    'PSCredentialExecutionParameterArgsDict',
    'ScriptSecureStringExecutionParameterArgs',
    'ScriptSecureStringExecutionParameterArgsDict',
    'ScriptStringExecutionParameterArgs',
    'ScriptStringExecutionParameterArgsDict',
    'SkuArgs',
    'SkuArgsDict',
    'SystemAssignedServiceIdentityArgs',
    'SystemAssignedServiceIdentityArgsDict',
    'WorkloadNetworkSegmentSubnetArgs',
    'WorkloadNetworkSegmentSubnetArgsDict',
]

MYPY = False

if not MYPY:
    class AvailabilityPropertiesArgsDict(TypedDict):
        """
        The properties describing private cloud availability zone distribution
        """
        secondary_zone: NotRequired[pulumi.Input[int]]
        """
        The secondary availability zone for the private cloud
        """
        strategy: NotRequired[pulumi.Input[Union[str, 'AvailabilityStrategy']]]
        """
        The availability strategy for the private cloud
        """
        zone: NotRequired[pulumi.Input[int]]
        """
        The primary availability zone for the private cloud
        """
elif False:
    AvailabilityPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AvailabilityPropertiesArgs:
    def __init__(__self__, *,
                 secondary_zone: Optional[pulumi.Input[int]] = None,
                 strategy: Optional[pulumi.Input[Union[str, 'AvailabilityStrategy']]] = None,
                 zone: Optional[pulumi.Input[int]] = None):
        """
        The properties describing private cloud availability zone distribution
        :param pulumi.Input[int] secondary_zone: The secondary availability zone for the private cloud
        :param pulumi.Input[Union[str, 'AvailabilityStrategy']] strategy: The availability strategy for the private cloud
        :param pulumi.Input[int] zone: The primary availability zone for the private cloud
        """
        if secondary_zone is not None:
            pulumi.set(__self__, "secondary_zone", secondary_zone)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="secondaryZone")
    def secondary_zone(self) -> Optional[pulumi.Input[int]]:
        """
        The secondary availability zone for the private cloud
        """
        return pulumi.get(self, "secondary_zone")

    @secondary_zone.setter
    def secondary_zone(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "secondary_zone", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[Union[str, 'AvailabilityStrategy']]]:
        """
        The availability strategy for the private cloud
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[Union[str, 'AvailabilityStrategy']]]):
        pulumi.set(self, "strategy", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[int]]:
        """
        The primary availability zone for the private cloud
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class DiskPoolVolumeArgsDict(TypedDict):
        """
        An iSCSI volume from Microsoft.StoragePool provider
        """
        lun_name: pulumi.Input[str]
        """
        Name of the LUN to be used for datastore
        """
        target_id: pulumi.Input[str]
        """
        Azure resource ID of the iSCSI target
        """
        mount_option: NotRequired[pulumi.Input[Union[str, 'MountOptionEnum']]]
        """
        Mode that describes whether the LUN has to be mounted as a datastore or
        attached as a LUN
        """
elif False:
    DiskPoolVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiskPoolVolumeArgs:
    def __init__(__self__, *,
                 lun_name: pulumi.Input[str],
                 target_id: pulumi.Input[str],
                 mount_option: Optional[pulumi.Input[Union[str, 'MountOptionEnum']]] = None):
        """
        An iSCSI volume from Microsoft.StoragePool provider
        :param pulumi.Input[str] lun_name: Name of the LUN to be used for datastore
        :param pulumi.Input[str] target_id: Azure resource ID of the iSCSI target
        :param pulumi.Input[Union[str, 'MountOptionEnum']] mount_option: Mode that describes whether the LUN has to be mounted as a datastore or
               attached as a LUN
        """
        pulumi.set(__self__, "lun_name", lun_name)
        pulumi.set(__self__, "target_id", target_id)
        if mount_option is None:
            mount_option = 'MOUNT'
        if mount_option is not None:
            pulumi.set(__self__, "mount_option", mount_option)

    @property
    @pulumi.getter(name="lunName")
    def lun_name(self) -> pulumi.Input[str]:
        """
        Name of the LUN to be used for datastore
        """
        return pulumi.get(self, "lun_name")

    @lun_name.setter
    def lun_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "lun_name", value)

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> pulumi.Input[str]:
        """
        Azure resource ID of the iSCSI target
        """
        return pulumi.get(self, "target_id")

    @target_id.setter
    def target_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_id", value)

    @property
    @pulumi.getter(name="mountOption")
    def mount_option(self) -> Optional[pulumi.Input[Union[str, 'MountOptionEnum']]]:
        """
        Mode that describes whether the LUN has to be mounted as a datastore or
        attached as a LUN
        """
        return pulumi.get(self, "mount_option")

    @mount_option.setter
    def mount_option(self, value: Optional[pulumi.Input[Union[str, 'MountOptionEnum']]]):
        pulumi.set(self, "mount_option", value)


if not MYPY:
    class ElasticSanVolumeArgsDict(TypedDict):
        """
        An Elastic SAN volume from Microsoft.ElasticSan provider
        """
        target_id: pulumi.Input[str]
        """
        Azure resource ID of the Elastic SAN Volume
        """
elif False:
    ElasticSanVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElasticSanVolumeArgs:
    def __init__(__self__, *,
                 target_id: pulumi.Input[str]):
        """
        An Elastic SAN volume from Microsoft.ElasticSan provider
        :param pulumi.Input[str] target_id: Azure resource ID of the Elastic SAN Volume
        """
        pulumi.set(__self__, "target_id", target_id)

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> pulumi.Input[str]:
        """
        Azure resource ID of the Elastic SAN Volume
        """
        return pulumi.get(self, "target_id")

    @target_id.setter
    def target_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_id", value)


if not MYPY:
    class EncryptionKeyVaultPropertiesArgsDict(TypedDict):
        """
        An Encryption Key
        """
        key_name: NotRequired[pulumi.Input[str]]
        """
        The name of the key.
        """
        key_vault_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the vault.
        """
        key_version: NotRequired[pulumi.Input[str]]
        """
        The version of the key.
        """
elif False:
    EncryptionKeyVaultPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EncryptionKeyVaultPropertiesArgs:
    def __init__(__self__, *,
                 key_name: Optional[pulumi.Input[str]] = None,
                 key_vault_url: Optional[pulumi.Input[str]] = None,
                 key_version: Optional[pulumi.Input[str]] = None):
        """
        An Encryption Key
        :param pulumi.Input[str] key_name: The name of the key.
        :param pulumi.Input[str] key_vault_url: The URL of the vault.
        :param pulumi.Input[str] key_version: The version of the key.
        """
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if key_vault_url is not None:
            pulumi.set(__self__, "key_vault_url", key_vault_url)
        if key_version is not None:
            pulumi.set(__self__, "key_version", key_version)

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the key.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_name", value)

    @property
    @pulumi.getter(name="keyVaultUrl")
    def key_vault_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the vault.
        """
        return pulumi.get(self, "key_vault_url")

    @key_vault_url.setter
    def key_vault_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_vault_url", value)

    @property
    @pulumi.getter(name="keyVersion")
    def key_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the key.
        """
        return pulumi.get(self, "key_version")

    @key_version.setter
    def key_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_version", value)


if not MYPY:
    class EncryptionArgsDict(TypedDict):
        """
        The properties of customer managed encryption key
        """
        key_vault_properties: NotRequired[pulumi.Input['EncryptionKeyVaultPropertiesArgsDict']]
        """
        The key vault where the encryption key is stored
        """
        status: NotRequired[pulumi.Input[Union[str, 'EncryptionState']]]
        """
        Status of customer managed encryption key
        """
elif False:
    EncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EncryptionArgs:
    def __init__(__self__, *,
                 key_vault_properties: Optional[pulumi.Input['EncryptionKeyVaultPropertiesArgs']] = None,
                 status: Optional[pulumi.Input[Union[str, 'EncryptionState']]] = None):
        """
        The properties of customer managed encryption key
        :param pulumi.Input['EncryptionKeyVaultPropertiesArgs'] key_vault_properties: The key vault where the encryption key is stored
        :param pulumi.Input[Union[str, 'EncryptionState']] status: Status of customer managed encryption key
        """
        if key_vault_properties is not None:
            pulumi.set(__self__, "key_vault_properties", key_vault_properties)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="keyVaultProperties")
    def key_vault_properties(self) -> Optional[pulumi.Input['EncryptionKeyVaultPropertiesArgs']]:
        """
        The key vault where the encryption key is stored
        """
        return pulumi.get(self, "key_vault_properties")

    @key_vault_properties.setter
    def key_vault_properties(self, value: Optional[pulumi.Input['EncryptionKeyVaultPropertiesArgs']]):
        pulumi.set(self, "key_vault_properties", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[str, 'EncryptionState']]]:
        """
        Status of customer managed encryption key
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[str, 'EncryptionState']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class IdentitySourceArgsDict(TypedDict):
        """
        vCenter Single Sign On Identity Source
        """
        alias: NotRequired[pulumi.Input[str]]
        """
        The domain's NetBIOS name
        """
        base_group_dn: NotRequired[pulumi.Input[str]]
        """
        The base distinguished name for groups
        """
        base_user_dn: NotRequired[pulumi.Input[str]]
        """
        The base distinguished name for users
        """
        domain: NotRequired[pulumi.Input[str]]
        """
        The domain's dns name
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the identity source
        """
        password: NotRequired[pulumi.Input[str]]
        """
        The password of the Active Directory user with a minimum of read-only access to
        Base DN for users and groups.
        """
        primary_server: NotRequired[pulumi.Input[str]]
        """
        Primary server URL
        """
        secondary_server: NotRequired[pulumi.Input[str]]
        """
        Secondary server URL
        """
        ssl: NotRequired[pulumi.Input[Union[str, 'SslEnum']]]
        """
        Protect LDAP communication using SSL certificate (LDAPS)
        """
        username: NotRequired[pulumi.Input[str]]
        """
        The ID of an Active Directory user with a minimum of read-only access to Base
        DN for users and group
        """
elif False:
    IdentitySourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentitySourceArgs:
    def __init__(__self__, *,
                 alias: Optional[pulumi.Input[str]] = None,
                 base_group_dn: Optional[pulumi.Input[str]] = None,
                 base_user_dn: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 primary_server: Optional[pulumi.Input[str]] = None,
                 secondary_server: Optional[pulumi.Input[str]] = None,
                 ssl: Optional[pulumi.Input[Union[str, 'SslEnum']]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        vCenter Single Sign On Identity Source
        :param pulumi.Input[str] alias: The domain's NetBIOS name
        :param pulumi.Input[str] base_group_dn: The base distinguished name for groups
        :param pulumi.Input[str] base_user_dn: The base distinguished name for users
        :param pulumi.Input[str] domain: The domain's dns name
        :param pulumi.Input[str] name: The name of the identity source
        :param pulumi.Input[str] password: The password of the Active Directory user with a minimum of read-only access to
               Base DN for users and groups.
        :param pulumi.Input[str] primary_server: Primary server URL
        :param pulumi.Input[str] secondary_server: Secondary server URL
        :param pulumi.Input[Union[str, 'SslEnum']] ssl: Protect LDAP communication using SSL certificate (LDAPS)
        :param pulumi.Input[str] username: The ID of an Active Directory user with a minimum of read-only access to Base
               DN for users and group
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if base_group_dn is not None:
            pulumi.set(__self__, "base_group_dn", base_group_dn)
        if base_user_dn is not None:
            pulumi.set(__self__, "base_user_dn", base_user_dn)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if primary_server is not None:
            pulumi.set(__self__, "primary_server", primary_server)
        if secondary_server is not None:
            pulumi.set(__self__, "secondary_server", secondary_server)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        The domain's NetBIOS name
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="baseGroupDN")
    def base_group_dn(self) -> Optional[pulumi.Input[str]]:
        """
        The base distinguished name for groups
        """
        return pulumi.get(self, "base_group_dn")

    @base_group_dn.setter
    def base_group_dn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_group_dn", value)

    @property
    @pulumi.getter(name="baseUserDN")
    def base_user_dn(self) -> Optional[pulumi.Input[str]]:
        """
        The base distinguished name for users
        """
        return pulumi.get(self, "base_user_dn")

    @base_user_dn.setter
    def base_user_dn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_user_dn", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        The domain's dns name
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the identity source
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password of the Active Directory user with a minimum of read-only access to
        Base DN for users and groups.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="primaryServer")
    def primary_server(self) -> Optional[pulumi.Input[str]]:
        """
        Primary server URL
        """
        return pulumi.get(self, "primary_server")

    @primary_server.setter
    def primary_server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_server", value)

    @property
    @pulumi.getter(name="secondaryServer")
    def secondary_server(self) -> Optional[pulumi.Input[str]]:
        """
        Secondary server URL
        """
        return pulumi.get(self, "secondary_server")

    @secondary_server.setter
    def secondary_server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secondary_server", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[Union[str, 'SslEnum']]]:
        """
        Protect LDAP communication using SSL certificate (LDAPS)
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[Union[str, 'SslEnum']]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of an Active Directory user with a minimum of read-only access to Base
        DN for users and group
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ManagementClusterArgsDict(TypedDict):
        """
        The properties of a management cluster
        """
        cluster_size: NotRequired[pulumi.Input[int]]
        """
        The cluster size
        """
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The hosts
        """
        vsan_datastore_name: NotRequired[pulumi.Input[str]]
        """
        Name of the vsan datastore associated with the cluster
        """
elif False:
    ManagementClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementClusterArgs:
    def __init__(__self__, *,
                 cluster_size: Optional[pulumi.Input[int]] = None,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vsan_datastore_name: Optional[pulumi.Input[str]] = None):
        """
        The properties of a management cluster
        :param pulumi.Input[int] cluster_size: The cluster size
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hosts: The hosts
        :param pulumi.Input[str] vsan_datastore_name: Name of the vsan datastore associated with the cluster
        """
        if cluster_size is not None:
            pulumi.set(__self__, "cluster_size", cluster_size)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if vsan_datastore_name is not None:
            pulumi.set(__self__, "vsan_datastore_name", vsan_datastore_name)

    @property
    @pulumi.getter(name="clusterSize")
    def cluster_size(self) -> Optional[pulumi.Input[int]]:
        """
        The cluster size
        """
        return pulumi.get(self, "cluster_size")

    @cluster_size.setter
    def cluster_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_size", value)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The hosts
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter(name="vsanDatastoreName")
    def vsan_datastore_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the vsan datastore associated with the cluster
        """
        return pulumi.get(self, "vsan_datastore_name")

    @vsan_datastore_name.setter
    def vsan_datastore_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vsan_datastore_name", value)


if not MYPY:
    class NetAppVolumeArgsDict(TypedDict):
        """
        An Azure NetApp Files volume from Microsoft.NetApp provider
        """
        id: pulumi.Input[str]
        """
        Azure resource ID of the NetApp volume
        """
elif False:
    NetAppVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetAppVolumeArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        An Azure NetApp Files volume from Microsoft.NetApp provider
        :param pulumi.Input[str] id: Azure resource ID of the NetApp volume
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Azure resource ID of the NetApp volume
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PSCredentialExecutionParameterArgsDict(TypedDict):
        """
        a powershell credential object
        """
        name: pulumi.Input[str]
        """
        The parameter name
        """
        type: pulumi.Input[str]
        """
        script execution parameter type
        Expected value is 'Credential'.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        password for login
        """
        username: NotRequired[pulumi.Input[str]]
        """
        username for login
        """
elif False:
    PSCredentialExecutionParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PSCredentialExecutionParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        a powershell credential object
        :param pulumi.Input[str] name: The parameter name
        :param pulumi.Input[str] type: script execution parameter type
               Expected value is 'Credential'.
        :param pulumi.Input[str] password: password for login
        :param pulumi.Input[str] username: username for login
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'Credential')
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The parameter name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        script execution parameter type
        Expected value is 'Credential'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        password for login
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        username for login
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ScriptSecureStringExecutionParameterArgsDict(TypedDict):
        """
        a plain text value execution parameter
        """
        name: pulumi.Input[str]
        """
        The parameter name
        """
        type: pulumi.Input[str]
        """
        script execution parameter type
        Expected value is 'SecureValue'.
        """
        secure_value: NotRequired[pulumi.Input[str]]
        """
        A secure value for the passed parameter, not to be stored in logs
        """
elif False:
    ScriptSecureStringExecutionParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScriptSecureStringExecutionParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 secure_value: Optional[pulumi.Input[str]] = None):
        """
        a plain text value execution parameter
        :param pulumi.Input[str] name: The parameter name
        :param pulumi.Input[str] type: script execution parameter type
               Expected value is 'SecureValue'.
        :param pulumi.Input[str] secure_value: A secure value for the passed parameter, not to be stored in logs
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'SecureValue')
        if secure_value is not None:
            pulumi.set(__self__, "secure_value", secure_value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The parameter name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        script execution parameter type
        Expected value is 'SecureValue'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="secureValue")
    def secure_value(self) -> Optional[pulumi.Input[str]]:
        """
        A secure value for the passed parameter, not to be stored in logs
        """
        return pulumi.get(self, "secure_value")

    @secure_value.setter
    def secure_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secure_value", value)


if not MYPY:
    class ScriptStringExecutionParameterArgsDict(TypedDict):
        """
        a plain text value execution parameter
        """
        name: pulumi.Input[str]
        """
        The parameter name
        """
        type: pulumi.Input[str]
        """
        script execution parameter type
        Expected value is 'Value'.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value for the passed parameter
        """
elif False:
    ScriptStringExecutionParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScriptStringExecutionParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        a plain text value execution parameter
        :param pulumi.Input[str] name: The parameter name
        :param pulumi.Input[str] type: script execution parameter type
               Expected value is 'Value'.
        :param pulumi.Input[str] value: The value for the passed parameter
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'Value')
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The parameter name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        script execution parameter type
        Expected value is 'Value'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value for the passed parameter
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SkuArgsDict(TypedDict):
        """
        The resource model definition representing SKU
        """
        name: pulumi.Input[str]
        """
        The name of the SKU. E.g. P3. It is typically a letter+number code
        """
        capacity: NotRequired[pulumi.Input[int]]
        """
        If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        """
        family: NotRequired[pulumi.Input[str]]
        """
        If the service has different generations of hardware, for the same SKU, then that can be captured here.
        """
        size: NotRequired[pulumi.Input[str]]
        """
        The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        """
        tier: NotRequired[pulumi.Input['SkuTier']]
        """
        This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
elif False:
    SkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SkuArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 capacity: Optional[pulumi.Input[int]] = None,
                 family: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[str]] = None,
                 tier: Optional[pulumi.Input['SkuTier']] = None):
        """
        The resource model definition representing SKU
        :param pulumi.Input[str] name: The name of the SKU. E.g. P3. It is typically a letter+number code
        :param pulumi.Input[int] capacity: If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        :param pulumi.Input[str] family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
        :param pulumi.Input[str] size: The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        :param pulumi.Input['SkuTier'] tier: This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the SKU. E.g. P3. It is typically a letter+number code
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[int]]:
        """
        If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input[str]]:
        """
        If the service has different generations of hardware, for the same SKU, then that can be captured here.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input['SkuTier']]:
        """
        This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input['SkuTier']]):
        pulumi.set(self, "tier", value)


if not MYPY:
    class SystemAssignedServiceIdentityArgsDict(TypedDict):
        """
        Managed service identity (either system assigned, or none)
        """
        type: pulumi.Input[Union[str, 'SystemAssignedServiceIdentityType']]
        """
        Type of managed service identity (either system assigned, or none).
        """
elif False:
    SystemAssignedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemAssignedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'SystemAssignedServiceIdentityType']]):
        """
        Managed service identity (either system assigned, or none)
        :param pulumi.Input[Union[str, 'SystemAssignedServiceIdentityType']] type: Type of managed service identity (either system assigned, or none).
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'SystemAssignedServiceIdentityType']]:
        """
        Type of managed service identity (either system assigned, or none).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'SystemAssignedServiceIdentityType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WorkloadNetworkSegmentSubnetArgsDict(TypedDict):
        """
        Subnet configuration for segment
        """
        dhcp_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        DHCP Range assigned for subnet.
        """
        gateway_address: NotRequired[pulumi.Input[str]]
        """
        Gateway address.
        """
elif False:
    WorkloadNetworkSegmentSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadNetworkSegmentSubnetArgs:
    def __init__(__self__, *,
                 dhcp_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gateway_address: Optional[pulumi.Input[str]] = None):
        """
        Subnet configuration for segment
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dhcp_ranges: DHCP Range assigned for subnet.
        :param pulumi.Input[str] gateway_address: Gateway address.
        """
        if dhcp_ranges is not None:
            pulumi.set(__self__, "dhcp_ranges", dhcp_ranges)
        if gateway_address is not None:
            pulumi.set(__self__, "gateway_address", gateway_address)

    @property
    @pulumi.getter(name="dhcpRanges")
    def dhcp_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        DHCP Range assigned for subnet.
        """
        return pulumi.get(self, "dhcp_ranges")

    @dhcp_ranges.setter
    def dhcp_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dhcp_ranges", value)

    @property
    @pulumi.getter(name="gatewayAddress")
    def gateway_address(self) -> Optional[pulumi.Input[str]]:
        """
        Gateway address.
        """
        return pulumi.get(self, "gateway_address")

    @gateway_address.setter
    def gateway_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway_address", value)


