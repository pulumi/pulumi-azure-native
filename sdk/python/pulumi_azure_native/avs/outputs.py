# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AvailabilityPropertiesResponse',
    'CircuitResponse',
    'ClusterZoneResponse',
    'DiskPoolVolumeResponse',
    'ElasticSanVolumeResponse',
    'EncryptionKeyVaultPropertiesResponse',
    'EncryptionResponse',
    'EndpointsResponse',
    'IdentitySourceResponse',
    'ManagementClusterResponse',
    'NetAppVolumeResponse',
    'PSCredentialExecutionParameterResponse',
    'ScriptSecureStringExecutionParameterResponse',
    'ScriptStringExecutionParameterResponse',
    'SkuResponse',
    'SystemAssignedServiceIdentityResponse',
    'SystemDataResponse',
    'WorkloadNetworkSegmentPortVifResponse',
    'WorkloadNetworkSegmentSubnetResponse',
]

@pulumi.output_type
class AvailabilityPropertiesResponse(dict):
    """
    The properties describing private cloud availability zone distribution
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secondaryZone":
            suggest = "secondary_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AvailabilityPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AvailabilityPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AvailabilityPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secondary_zone: Optional[_builtins.int] = None,
                 strategy: Optional[_builtins.str] = None,
                 zone: Optional[_builtins.int] = None):
        """
        The properties describing private cloud availability zone distribution
        :param _builtins.int secondary_zone: The secondary availability zone for the private cloud
        :param _builtins.str strategy: The availability strategy for the private cloud
        :param _builtins.int zone: The primary availability zone for the private cloud
        """
        if secondary_zone is not None:
            pulumi.set(__self__, "secondary_zone", secondary_zone)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="secondaryZone")
    def secondary_zone(self) -> Optional[_builtins.int]:
        """
        The secondary availability zone for the private cloud
        """
        return pulumi.get(self, "secondary_zone")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        The availability strategy for the private cloud
        """
        return pulumi.get(self, "strategy")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[_builtins.int]:
        """
        The primary availability zone for the private cloud
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class CircuitResponse(dict):
    """
    An ExpressRoute Circuit
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expressRouteID":
            suggest = "express_route_id"
        elif key == "expressRoutePrivatePeeringID":
            suggest = "express_route_private_peering_id"
        elif key == "primarySubnet":
            suggest = "primary_subnet"
        elif key == "secondarySubnet":
            suggest = "secondary_subnet"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CircuitResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CircuitResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CircuitResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 express_route_id: _builtins.str,
                 express_route_private_peering_id: _builtins.str,
                 primary_subnet: _builtins.str,
                 secondary_subnet: _builtins.str):
        """
        An ExpressRoute Circuit
        :param _builtins.str express_route_id: Identifier of the ExpressRoute Circuit (Microsoft Colo only)
        :param _builtins.str express_route_private_peering_id: ExpressRoute Circuit private peering identifier
        :param _builtins.str primary_subnet: CIDR of primary subnet
        :param _builtins.str secondary_subnet: CIDR of secondary subnet
        """
        pulumi.set(__self__, "express_route_id", express_route_id)
        pulumi.set(__self__, "express_route_private_peering_id", express_route_private_peering_id)
        pulumi.set(__self__, "primary_subnet", primary_subnet)
        pulumi.set(__self__, "secondary_subnet", secondary_subnet)

    @_builtins.property
    @pulumi.getter(name="expressRouteID")
    def express_route_id(self) -> _builtins.str:
        """
        Identifier of the ExpressRoute Circuit (Microsoft Colo only)
        """
        return pulumi.get(self, "express_route_id")

    @_builtins.property
    @pulumi.getter(name="expressRoutePrivatePeeringID")
    def express_route_private_peering_id(self) -> _builtins.str:
        """
        ExpressRoute Circuit private peering identifier
        """
        return pulumi.get(self, "express_route_private_peering_id")

    @_builtins.property
    @pulumi.getter(name="primarySubnet")
    def primary_subnet(self) -> _builtins.str:
        """
        CIDR of primary subnet
        """
        return pulumi.get(self, "primary_subnet")

    @_builtins.property
    @pulumi.getter(name="secondarySubnet")
    def secondary_subnet(self) -> _builtins.str:
        """
        CIDR of secondary subnet
        """
        return pulumi.get(self, "secondary_subnet")


@pulumi.output_type
class ClusterZoneResponse(dict):
    """
    Zone and associated hosts info
    """
    def __init__(__self__, *,
                 hosts: Sequence[_builtins.str],
                 zone: _builtins.str):
        """
        Zone and associated hosts info
        :param Sequence[_builtins.str] hosts: List of hosts belonging to the availability zone in a cluster
        :param _builtins.str zone: Availability zone identifier
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Sequence[_builtins.str]:
        """
        List of hosts belonging to the availability zone in a cluster
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        Availability zone identifier
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class DiskPoolVolumeResponse(dict):
    """
    An iSCSI volume from Microsoft.StoragePool provider
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lunName":
            suggest = "lun_name"
        elif key == "targetId":
            suggest = "target_id"
        elif key == "mountOption":
            suggest = "mount_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskPoolVolumeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskPoolVolumeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskPoolVolumeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lun_name: _builtins.str,
                 path: _builtins.str,
                 target_id: _builtins.str,
                 mount_option: Optional[_builtins.str] = None):
        """
        An iSCSI volume from Microsoft.StoragePool provider
        :param _builtins.str lun_name: Name of the LUN to be used for datastore
        :param _builtins.str path: Device path
        :param _builtins.str target_id: Azure resource ID of the iSCSI target
        :param _builtins.str mount_option: Mode that describes whether the LUN has to be mounted as a datastore or
               attached as a LUN
        """
        pulumi.set(__self__, "lun_name", lun_name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "target_id", target_id)
        if mount_option is None:
            mount_option = 'MOUNT'
        if mount_option is not None:
            pulumi.set(__self__, "mount_option", mount_option)

    @_builtins.property
    @pulumi.getter(name="lunName")
    def lun_name(self) -> _builtins.str:
        """
        Name of the LUN to be used for datastore
        """
        return pulumi.get(self, "lun_name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Device path
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="targetId")
    def target_id(self) -> _builtins.str:
        """
        Azure resource ID of the iSCSI target
        """
        return pulumi.get(self, "target_id")

    @_builtins.property
    @pulumi.getter(name="mountOption")
    def mount_option(self) -> Optional[_builtins.str]:
        """
        Mode that describes whether the LUN has to be mounted as a datastore or
        attached as a LUN
        """
        return pulumi.get(self, "mount_option")


@pulumi.output_type
class ElasticSanVolumeResponse(dict):
    """
    An Elastic SAN volume from Microsoft.ElasticSan provider
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetId":
            suggest = "target_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticSanVolumeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticSanVolumeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticSanVolumeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_id: _builtins.str):
        """
        An Elastic SAN volume from Microsoft.ElasticSan provider
        :param _builtins.str target_id: Azure resource ID of the Elastic SAN Volume
        """
        pulumi.set(__self__, "target_id", target_id)

    @_builtins.property
    @pulumi.getter(name="targetId")
    def target_id(self) -> _builtins.str:
        """
        Azure resource ID of the Elastic SAN Volume
        """
        return pulumi.get(self, "target_id")


@pulumi.output_type
class EncryptionKeyVaultPropertiesResponse(dict):
    """
    An Encryption Key
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDetectedKeyVersion":
            suggest = "auto_detected_key_version"
        elif key == "keyState":
            suggest = "key_state"
        elif key == "versionType":
            suggest = "version_type"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "keyVaultUrl":
            suggest = "key_vault_url"
        elif key == "keyVersion":
            suggest = "key_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionKeyVaultPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionKeyVaultPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionKeyVaultPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_detected_key_version: _builtins.str,
                 key_state: _builtins.str,
                 version_type: _builtins.str,
                 key_name: Optional[_builtins.str] = None,
                 key_vault_url: Optional[_builtins.str] = None,
                 key_version: Optional[_builtins.str] = None):
        """
        An Encryption Key
        :param _builtins.str auto_detected_key_version: The auto-detected version of the key if versionType is auto-detected.
        :param _builtins.str key_state: The state of key provided
        :param _builtins.str version_type: Property of the key if user provided or auto detected
        :param _builtins.str key_name: The name of the key.
        :param _builtins.str key_vault_url: The URL of the vault.
        :param _builtins.str key_version: The version of the key.
        """
        pulumi.set(__self__, "auto_detected_key_version", auto_detected_key_version)
        pulumi.set(__self__, "key_state", key_state)
        pulumi.set(__self__, "version_type", version_type)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if key_vault_url is not None:
            pulumi.set(__self__, "key_vault_url", key_vault_url)
        if key_version is not None:
            pulumi.set(__self__, "key_version", key_version)

    @_builtins.property
    @pulumi.getter(name="autoDetectedKeyVersion")
    def auto_detected_key_version(self) -> _builtins.str:
        """
        The auto-detected version of the key if versionType is auto-detected.
        """
        return pulumi.get(self, "auto_detected_key_version")

    @_builtins.property
    @pulumi.getter(name="keyState")
    def key_state(self) -> _builtins.str:
        """
        The state of key provided
        """
        return pulumi.get(self, "key_state")

    @_builtins.property
    @pulumi.getter(name="versionType")
    def version_type(self) -> _builtins.str:
        """
        Property of the key if user provided or auto detected
        """
        return pulumi.get(self, "version_type")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[_builtins.str]:
        """
        The name of the key.
        """
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter(name="keyVaultUrl")
    def key_vault_url(self) -> Optional[_builtins.str]:
        """
        The URL of the vault.
        """
        return pulumi.get(self, "key_vault_url")

    @_builtins.property
    @pulumi.getter(name="keyVersion")
    def key_version(self) -> Optional[_builtins.str]:
        """
        The version of the key.
        """
        return pulumi.get(self, "key_version")


@pulumi.output_type
class EncryptionResponse(dict):
    """
    The properties of customer managed encryption key
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultProperties":
            suggest = "key_vault_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_properties: Optional['outputs.EncryptionKeyVaultPropertiesResponse'] = None,
                 status: Optional[_builtins.str] = None):
        """
        The properties of customer managed encryption key
        :param 'EncryptionKeyVaultPropertiesResponse' key_vault_properties: The key vault where the encryption key is stored
        :param _builtins.str status: Status of customer managed encryption key
        """
        if key_vault_properties is not None:
            pulumi.set(__self__, "key_vault_properties", key_vault_properties)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="keyVaultProperties")
    def key_vault_properties(self) -> Optional['outputs.EncryptionKeyVaultPropertiesResponse']:
        """
        The key vault where the encryption key is stored
        """
        return pulumi.get(self, "key_vault_properties")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of customer managed encryption key
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class EndpointsResponse(dict):
    """
    Endpoint addresses
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hcxCloudManager":
            suggest = "hcx_cloud_manager"
        elif key == "hcxCloudManagerIp":
            suggest = "hcx_cloud_manager_ip"
        elif key == "nsxtManager":
            suggest = "nsxt_manager"
        elif key == "nsxtManagerIp":
            suggest = "nsxt_manager_ip"
        elif key == "vcenterIp":
            suggest = "vcenter_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hcx_cloud_manager: _builtins.str,
                 hcx_cloud_manager_ip: _builtins.str,
                 nsxt_manager: _builtins.str,
                 nsxt_manager_ip: _builtins.str,
                 vcenter_ip: _builtins.str,
                 vcsa: _builtins.str):
        """
        Endpoint addresses
        :param _builtins.str hcx_cloud_manager: Endpoint FQDN for the HCX Cloud Manager
        :param _builtins.str hcx_cloud_manager_ip: Endpoint IP for the HCX Cloud Manager
        :param _builtins.str nsxt_manager: Endpoint FQDN for the NSX-T Data Center manager
        :param _builtins.str nsxt_manager_ip: Endpoint IP for the NSX-T Data Center manager
        :param _builtins.str vcenter_ip: Endpoint IP for Virtual Center Server Appliance
        :param _builtins.str vcsa: Endpoint FQDN for Virtual Center Server Appliance
        """
        pulumi.set(__self__, "hcx_cloud_manager", hcx_cloud_manager)
        pulumi.set(__self__, "hcx_cloud_manager_ip", hcx_cloud_manager_ip)
        pulumi.set(__self__, "nsxt_manager", nsxt_manager)
        pulumi.set(__self__, "nsxt_manager_ip", nsxt_manager_ip)
        pulumi.set(__self__, "vcenter_ip", vcenter_ip)
        pulumi.set(__self__, "vcsa", vcsa)

    @_builtins.property
    @pulumi.getter(name="hcxCloudManager")
    def hcx_cloud_manager(self) -> _builtins.str:
        """
        Endpoint FQDN for the HCX Cloud Manager
        """
        return pulumi.get(self, "hcx_cloud_manager")

    @_builtins.property
    @pulumi.getter(name="hcxCloudManagerIp")
    def hcx_cloud_manager_ip(self) -> _builtins.str:
        """
        Endpoint IP for the HCX Cloud Manager
        """
        return pulumi.get(self, "hcx_cloud_manager_ip")

    @_builtins.property
    @pulumi.getter(name="nsxtManager")
    def nsxt_manager(self) -> _builtins.str:
        """
        Endpoint FQDN for the NSX-T Data Center manager
        """
        return pulumi.get(self, "nsxt_manager")

    @_builtins.property
    @pulumi.getter(name="nsxtManagerIp")
    def nsxt_manager_ip(self) -> _builtins.str:
        """
        Endpoint IP for the NSX-T Data Center manager
        """
        return pulumi.get(self, "nsxt_manager_ip")

    @_builtins.property
    @pulumi.getter(name="vcenterIp")
    def vcenter_ip(self) -> _builtins.str:
        """
        Endpoint IP for Virtual Center Server Appliance
        """
        return pulumi.get(self, "vcenter_ip")

    @_builtins.property
    @pulumi.getter
    def vcsa(self) -> _builtins.str:
        """
        Endpoint FQDN for Virtual Center Server Appliance
        """
        return pulumi.get(self, "vcsa")


@pulumi.output_type
class IdentitySourceResponse(dict):
    """
    vCenter Single Sign On Identity Source
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseGroupDN":
            suggest = "base_group_dn"
        elif key == "baseUserDN":
            suggest = "base_user_dn"
        elif key == "primaryServer":
            suggest = "primary_server"
        elif key == "secondaryServer":
            suggest = "secondary_server"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentitySourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentitySourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentitySourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias: Optional[_builtins.str] = None,
                 base_group_dn: Optional[_builtins.str] = None,
                 base_user_dn: Optional[_builtins.str] = None,
                 domain: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 primary_server: Optional[_builtins.str] = None,
                 secondary_server: Optional[_builtins.str] = None,
                 ssl: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        vCenter Single Sign On Identity Source
        :param _builtins.str alias: The domain's NetBIOS name
        :param _builtins.str base_group_dn: The base distinguished name for groups
        :param _builtins.str base_user_dn: The base distinguished name for users
        :param _builtins.str domain: The domain's DNS name
        :param _builtins.str name: The name of the identity source
        :param _builtins.str password: The password of the Active Directory user with a minimum of read-only access to
               Base DN for users and groups.
        :param _builtins.str primary_server: Primary server URL
        :param _builtins.str secondary_server: Secondary server URL
        :param _builtins.str ssl: Protect LDAP communication using SSL certificate (LDAPS)
        :param _builtins.str username: The ID of an Active Directory user with a minimum of read-only access to Base
               DN for users and group
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if base_group_dn is not None:
            pulumi.set(__self__, "base_group_dn", base_group_dn)
        if base_user_dn is not None:
            pulumi.set(__self__, "base_user_dn", base_user_dn)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if primary_server is not None:
            pulumi.set(__self__, "primary_server", primary_server)
        if secondary_server is not None:
            pulumi.set(__self__, "secondary_server", secondary_server)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        """
        The domain's NetBIOS name
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter(name="baseGroupDN")
    def base_group_dn(self) -> Optional[_builtins.str]:
        """
        The base distinguished name for groups
        """
        return pulumi.get(self, "base_group_dn")

    @_builtins.property
    @pulumi.getter(name="baseUserDN")
    def base_user_dn(self) -> Optional[_builtins.str]:
        """
        The base distinguished name for users
        """
        return pulumi.get(self, "base_user_dn")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        The domain's DNS name
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the identity source
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password of the Active Directory user with a minimum of read-only access to
        Base DN for users and groups.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="primaryServer")
    def primary_server(self) -> Optional[_builtins.str]:
        """
        Primary server URL
        """
        return pulumi.get(self, "primary_server")

    @_builtins.property
    @pulumi.getter(name="secondaryServer")
    def secondary_server(self) -> Optional[_builtins.str]:
        """
        Secondary server URL
        """
        return pulumi.get(self, "secondary_server")

    @_builtins.property
    @pulumi.getter
    def ssl(self) -> Optional[_builtins.str]:
        """
        Protect LDAP communication using SSL certificate (LDAPS)
        """
        return pulumi.get(self, "ssl")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The ID of an Active Directory user with a minimum of read-only access to Base
        DN for users and group
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ManagementClusterResponse(dict):
    """
    The properties of a management cluster
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "clusterSize":
            suggest = "cluster_size"
        elif key == "vsanDatastoreName":
            suggest = "vsan_datastore_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementClusterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementClusterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementClusterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_id: _builtins.int,
                 provisioning_state: _builtins.str,
                 cluster_size: Optional[_builtins.int] = None,
                 hosts: Optional[Sequence[_builtins.str]] = None,
                 vsan_datastore_name: Optional[_builtins.str] = None):
        """
        The properties of a management cluster
        :param _builtins.int cluster_id: The identity
        :param _builtins.str provisioning_state: The state of the cluster provisioning
        :param _builtins.int cluster_size: The cluster size
        :param Sequence[_builtins.str] hosts: The hosts
        :param _builtins.str vsan_datastore_name: Name of the vsan datastore associated with the cluster
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if cluster_size is not None:
            pulumi.set(__self__, "cluster_size", cluster_size)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if vsan_datastore_name is not None:
            pulumi.set(__self__, "vsan_datastore_name", vsan_datastore_name)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.int:
        """
        The identity
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The state of the cluster provisioning
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="clusterSize")
    def cluster_size(self) -> Optional[_builtins.int]:
        """
        The cluster size
        """
        return pulumi.get(self, "cluster_size")

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        The hosts
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter(name="vsanDatastoreName")
    def vsan_datastore_name(self) -> Optional[_builtins.str]:
        """
        Name of the vsan datastore associated with the cluster
        """
        return pulumi.get(self, "vsan_datastore_name")


@pulumi.output_type
class NetAppVolumeResponse(dict):
    """
    An Azure NetApp Files volume from Microsoft.NetApp provider
    """
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        An Azure NetApp Files volume from Microsoft.NetApp provider
        :param _builtins.str id: Azure resource ID of the NetApp volume
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Azure resource ID of the NetApp volume
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PSCredentialExecutionParameterResponse(dict):
    """
    a powershell credential object
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 password: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        a powershell credential object
        :param _builtins.str name: The parameter name
        :param _builtins.str type: script execution parameter type
               Expected value is 'Credential'.
        :param _builtins.str password: password for login
        :param _builtins.str username: username for login
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'Credential')
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The parameter name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        script execution parameter type
        Expected value is 'Credential'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        password for login
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        username for login
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ScriptSecureStringExecutionParameterResponse(dict):
    """
    a plain text value execution parameter
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secureValue":
            suggest = "secure_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScriptSecureStringExecutionParameterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScriptSecureStringExecutionParameterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScriptSecureStringExecutionParameterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 secure_value: Optional[_builtins.str] = None):
        """
        a plain text value execution parameter
        :param _builtins.str name: The parameter name
        :param _builtins.str type: script execution parameter type
               Expected value is 'SecureValue'.
        :param _builtins.str secure_value: A secure value for the passed parameter, not to be stored in logs
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'SecureValue')
        if secure_value is not None:
            pulumi.set(__self__, "secure_value", secure_value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The parameter name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        script execution parameter type
        Expected value is 'SecureValue'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="secureValue")
    def secure_value(self) -> Optional[_builtins.str]:
        """
        A secure value for the passed parameter, not to be stored in logs
        """
        return pulumi.get(self, "secure_value")


@pulumi.output_type
class ScriptStringExecutionParameterResponse(dict):
    """
    a plain text value execution parameter
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        a plain text value execution parameter
        :param _builtins.str name: The parameter name
        :param _builtins.str type: script execution parameter type
               Expected value is 'Value'.
        :param _builtins.str value: The value for the passed parameter
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", 'Value')
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The parameter name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        script execution parameter type
        Expected value is 'Value'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value for the passed parameter
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SkuResponse(dict):
    """
    The resource model definition representing SKU
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 capacity: Optional[_builtins.int] = None,
                 family: Optional[_builtins.str] = None,
                 size: Optional[_builtins.str] = None,
                 tier: Optional[_builtins.str] = None):
        """
        The resource model definition representing SKU
        :param _builtins.str name: The name of the SKU. E.g. P3. It is typically a letter+number code
        :param _builtins.int capacity: If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        :param _builtins.str family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
        :param _builtins.str size: The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        :param _builtins.str tier: This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the SKU. E.g. P3. It is typically a letter+number code
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> Optional[_builtins.int]:
        """
        If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        """
        return pulumi.get(self, "capacity")

    @_builtins.property
    @pulumi.getter
    def family(self) -> Optional[_builtins.str]:
        """
        If the service has different generations of hardware, for the same SKU, then that can be captured here.
        """
        return pulumi.get(self, "family")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        """
        The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def tier(self) -> Optional[_builtins.str]:
        """
        This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class SystemAssignedServiceIdentityResponse(dict):
    """
    Managed service identity (either system assigned, or none)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemAssignedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemAssignedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemAssignedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: _builtins.str,
                 tenant_id: _builtins.str,
                 type: _builtins.str):
        """
        Managed service identity (either system assigned, or none)
        :param _builtins.str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param _builtins.str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param _builtins.str type: Type of managed service identity (either system assigned, or none).
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of managed service identity (either system assigned, or none).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 created_by_type: Optional[_builtins.str] = None,
                 last_modified_at: Optional[_builtins.str] = None,
                 last_modified_by: Optional[_builtins.str] = None,
                 last_modified_by_type: Optional[_builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param _builtins.str created_at: The timestamp of resource creation (UTC).
        :param _builtins.str created_by: The identity that created the resource.
        :param _builtins.str created_by_type: The type of identity that created the resource.
        :param _builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param _builtins.str last_modified_by: The identity that last modified the resource.
        :param _builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @_builtins.property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @_builtins.property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[_builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @_builtins.property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class WorkloadNetworkSegmentPortVifResponse(dict):
    """
    Ports and any VIF attached to segment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portName":
            suggest = "port_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadNetworkSegmentPortVifResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadNetworkSegmentPortVifResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadNetworkSegmentPortVifResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_name: Optional[_builtins.str] = None):
        """
        Ports and any VIF attached to segment.
        :param _builtins.str port_name: Name of port or VIF attached to segment.
        """
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[_builtins.str]:
        """
        Name of port or VIF attached to segment.
        """
        return pulumi.get(self, "port_name")


@pulumi.output_type
class WorkloadNetworkSegmentSubnetResponse(dict):
    """
    Subnet configuration for segment
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dhcpRanges":
            suggest = "dhcp_ranges"
        elif key == "gatewayAddress":
            suggest = "gateway_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadNetworkSegmentSubnetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadNetworkSegmentSubnetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadNetworkSegmentSubnetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dhcp_ranges: Optional[Sequence[_builtins.str]] = None,
                 gateway_address: Optional[_builtins.str] = None):
        """
        Subnet configuration for segment
        :param Sequence[_builtins.str] dhcp_ranges: DHCP Range assigned for subnet.
        :param _builtins.str gateway_address: Gateway address.
        """
        if dhcp_ranges is not None:
            pulumi.set(__self__, "dhcp_ranges", dhcp_ranges)
        if gateway_address is not None:
            pulumi.set(__self__, "gateway_address", gateway_address)

    @_builtins.property
    @pulumi.getter(name="dhcpRanges")
    def dhcp_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        DHCP Range assigned for subnet.
        """
        return pulumi.get(self, "dhcp_ranges")

    @_builtins.property
    @pulumi.getter(name="gatewayAddress")
    def gateway_address(self) -> Optional[_builtins.str]:
        """
        Gateway address.
        """
        return pulumi.get(self, "gateway_address")


