# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AadConfigurationResponse',
    'AdministrativeCredentialsResponse',
    'AdministratorConfigurationResponse',
    'AgentOptionsResponse',
    'AgentPoolUpgradeSettingsResponse',
    'AnalyticsOutputSettingsResponse',
    'AttachedNetworkConfigurationResponse',
    'AvailableUpgradeResponse',
    'BareMetalMachineConfigurationDataResponse',
    'BgpAdvertisementResponse',
    'BgpServiceLoadBalancerConfigurationResponse',
    'ClusterAvailableUpgradeVersionResponse',
    'ClusterAvailableVersionResponse',
    'ClusterCapacityResponse',
    'ClusterSecretArchiveResponse',
    'ClusterUpdateStrategyResponse',
    'CommandOutputSettingsResponse',
    'ControlPlaneNodeConfigurationResponse',
    'EgressEndpointResponse',
    'EndpointDependencyResponse',
    'ExtendedLocationResponse',
    'FeatureStatusResponse',
    'HardwareInventoryNetworkInterfaceResponse',
    'HardwareInventoryResponse',
    'HardwareValidationStatusResponse',
    'IdentitySelectorResponse',
    'ImageRepositoryCredentialsResponse',
    'InitialAgentPoolConfigurationResponse',
    'IpAddressPoolResponse',
    'KeySetUserResponse',
    'KeySetUserStatusResponse',
    'KubernetesClusterNodeResponse',
    'KubernetesLabelResponse',
    'L2NetworkAttachmentConfigurationResponse',
    'L2ServiceLoadBalancerConfigurationResponse',
    'L3NetworkAttachmentConfigurationResponse',
    'LldpNeighborResponse',
    'ManagedResourceGroupConfigurationResponse',
    'ManagedServiceIdentityResponse',
    'NetworkAttachmentResponse',
    'NetworkConfigurationResponse',
    'NicResponse',
    'OsDiskResponse',
    'RackDefinitionResponse',
    'RuntimeProtectionConfigurationResponse',
    'RuntimeProtectionStatusResponse',
    'SecretArchiveReferenceResponse',
    'SecretArchiveSettingsResponse',
    'SecretRotationStatusResponse',
    'ServiceLoadBalancerBgpPeerResponse',
    'ServicePrincipalInformationResponse',
    'SshPublicKeyResponse',
    'StorageApplianceConfigurationDataResponse',
    'StorageProfileResponse',
    'StringKeyValuePairResponse',
    'SystemDataResponse',
    'TrunkedNetworkAttachmentConfigurationResponse',
    'UserAssignedIdentityResponse',
    'ValidationThresholdResponse',
    'VirtualMachinePlacementHintResponse',
    'VulnerabilityScanningSettingsResponse',
]

@pulumi.output_type
class AadConfigurationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminGroupObjectIds":
            suggest = "admin_group_object_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AadConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AadConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AadConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_group_object_ids: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] admin_group_object_ids: The list of Azure Active Directory group object IDs that will have an administrative role on the Kubernetes cluster.
        """
        pulumi.set(__self__, "admin_group_object_ids", admin_group_object_ids)

    @_builtins.property
    @pulumi.getter(name="adminGroupObjectIds")
    def admin_group_object_ids(self) -> Sequence[_builtins.str]:
        """
        The list of Azure Active Directory group object IDs that will have an administrative role on the Kubernetes cluster.
        """
        return pulumi.get(self, "admin_group_object_ids")


@pulumi.output_type
class AdministrativeCredentialsResponse(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str password: The password of the administrator of the device used during initialization.
        :param _builtins.str username: The username of the administrator of the device used during initialization.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The password of the administrator of the device used during initialization.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The username of the administrator of the device used during initialization.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class AdministratorConfigurationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUsername":
            suggest = "admin_username"
        elif key == "sshPublicKeys":
            suggest = "ssh_public_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdministratorConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdministratorConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdministratorConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_username: Optional[_builtins.str] = None,
                 ssh_public_keys: Optional[Sequence['outputs.SshPublicKeyResponse']] = None):
        """
        :param _builtins.str admin_username: The user name for the administrator that will be applied to the operating systems that run Kubernetes nodes. If not supplied, a user name will be chosen by the service.
        :param Sequence['SshPublicKeyResponse'] ssh_public_keys: The SSH configuration for the operating systems that run the nodes in the Kubernetes cluster. In some cases, specification of public keys may be required to produce a working environment.
        """
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)

    @_builtins.property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[_builtins.str]:
        """
        The user name for the administrator that will be applied to the operating systems that run Kubernetes nodes. If not supplied, a user name will be chosen by the service.
        """
        return pulumi.get(self, "admin_username")

    @_builtins.property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence['outputs.SshPublicKeyResponse']]:
        """
        The SSH configuration for the operating systems that run the nodes in the Kubernetes cluster. In some cases, specification of public keys may be required to produce a working environment.
        """
        return pulumi.get(self, "ssh_public_keys")


@pulumi.output_type
class AgentOptionsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hugepagesCount":
            suggest = "hugepages_count"
        elif key == "hugepagesSize":
            suggest = "hugepages_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hugepages_count: _builtins.float,
                 hugepages_size: Optional[_builtins.str] = None):
        """
        :param _builtins.float hugepages_count: The number of hugepages to allocate.
        :param _builtins.str hugepages_size: The size of the hugepages to allocate.
        """
        pulumi.set(__self__, "hugepages_count", hugepages_count)
        if hugepages_size is None:
            hugepages_size = '2M'
        if hugepages_size is not None:
            pulumi.set(__self__, "hugepages_size", hugepages_size)

    @_builtins.property
    @pulumi.getter(name="hugepagesCount")
    def hugepages_count(self) -> _builtins.float:
        """
        The number of hugepages to allocate.
        """
        return pulumi.get(self, "hugepages_count")

    @_builtins.property
    @pulumi.getter(name="hugepagesSize")
    def hugepages_size(self) -> Optional[_builtins.str]:
        """
        The size of the hugepages to allocate.
        """
        return pulumi.get(self, "hugepages_size")


@pulumi.output_type
class AgentPoolUpgradeSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainTimeout":
            suggest = "drain_timeout"
        elif key == "maxSurge":
            suggest = "max_surge"
        elif key == "maxUnavailable":
            suggest = "max_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentPoolUpgradeSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentPoolUpgradeSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentPoolUpgradeSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drain_timeout: Optional[_builtins.float] = None,
                 max_surge: Optional[_builtins.str] = None,
                 max_unavailable: Optional[_builtins.str] = None):
        """
        :param _builtins.float drain_timeout: The maximum time in seconds that is allowed for a node drain to complete before proceeding with the upgrade of the agent pool. If not specified during creation, a value of 1800 seconds is used.
        :param _builtins.str max_surge: The maximum number or percentage of nodes that are surged during upgrade. This can either be set to an integer (e.g. '5') or a percentage (e.g. '50%'). If a percentage is specified, it is the percentage of the total agent pool size at the time of the upgrade. For percentages, fractional nodes are rounded up. If not specified during creation, a value of 1 is used. One of MaxSurge and MaxUnavailable must be greater than 0.
        :param _builtins.str max_unavailable: The maximum number or percentage of nodes that can be unavailable during upgrade. This can either be set to an integer (e.g. '5') or a percentage (e.g. '50%'). If a percentage is specified, it is the percentage of the total agent pool size at the time of the upgrade. For percentages, fractional nodes are rounded up. If not specified during creation, a value of 0 is used. One of MaxSurge and MaxUnavailable must be greater than 0.
        """
        if drain_timeout is not None:
            pulumi.set(__self__, "drain_timeout", drain_timeout)
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @_builtins.property
    @pulumi.getter(name="drainTimeout")
    def drain_timeout(self) -> Optional[_builtins.float]:
        """
        The maximum time in seconds that is allowed for a node drain to complete before proceeding with the upgrade of the agent pool. If not specified during creation, a value of 1800 seconds is used.
        """
        return pulumi.get(self, "drain_timeout")

    @_builtins.property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[_builtins.str]:
        """
        The maximum number or percentage of nodes that are surged during upgrade. This can either be set to an integer (e.g. '5') or a percentage (e.g. '50%'). If a percentage is specified, it is the percentage of the total agent pool size at the time of the upgrade. For percentages, fractional nodes are rounded up. If not specified during creation, a value of 1 is used. One of MaxSurge and MaxUnavailable must be greater than 0.
        """
        return pulumi.get(self, "max_surge")

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[_builtins.str]:
        """
        The maximum number or percentage of nodes that can be unavailable during upgrade. This can either be set to an integer (e.g. '5') or a percentage (e.g. '50%'). If a percentage is specified, it is the percentage of the total agent pool size at the time of the upgrade. For percentages, fractional nodes are rounded up. If not specified during creation, a value of 0 is used. One of MaxSurge and MaxUnavailable must be greater than 0.
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class AnalyticsOutputSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "analyticsWorkspaceId":
            suggest = "analytics_workspace_id"
        elif key == "associatedIdentity":
            suggest = "associated_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalyticsOutputSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalyticsOutputSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalyticsOutputSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 analytics_workspace_id: Optional[_builtins.str] = None,
                 associated_identity: Optional['outputs.IdentitySelectorResponse'] = None):
        """
        :param _builtins.str analytics_workspace_id: The resource ID of the analytics workspace that is to be used by the specified identity.
        :param 'IdentitySelectorResponse' associated_identity: The selection of the managed identity to use with this analytics workspace. The identity type must be either system assigned or user assigned.
        """
        if analytics_workspace_id is not None:
            pulumi.set(__self__, "analytics_workspace_id", analytics_workspace_id)
        if associated_identity is not None:
            pulumi.set(__self__, "associated_identity", associated_identity)

    @_builtins.property
    @pulumi.getter(name="analyticsWorkspaceId")
    def analytics_workspace_id(self) -> Optional[_builtins.str]:
        """
        The resource ID of the analytics workspace that is to be used by the specified identity.
        """
        return pulumi.get(self, "analytics_workspace_id")

    @_builtins.property
    @pulumi.getter(name="associatedIdentity")
    def associated_identity(self) -> Optional['outputs.IdentitySelectorResponse']:
        """
        The selection of the managed identity to use with this analytics workspace. The identity type must be either system assigned or user assigned.
        """
        return pulumi.get(self, "associated_identity")


@pulumi.output_type
class AttachedNetworkConfigurationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "l2Networks":
            suggest = "l2_networks"
        elif key == "l3Networks":
            suggest = "l3_networks"
        elif key == "trunkedNetworks":
            suggest = "trunked_networks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AttachedNetworkConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AttachedNetworkConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AttachedNetworkConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 l2_networks: Optional[Sequence['outputs.L2NetworkAttachmentConfigurationResponse']] = None,
                 l3_networks: Optional[Sequence['outputs.L3NetworkAttachmentConfigurationResponse']] = None,
                 trunked_networks: Optional[Sequence['outputs.TrunkedNetworkAttachmentConfigurationResponse']] = None):
        """
        :param Sequence['L2NetworkAttachmentConfigurationResponse'] l2_networks: The list of Layer 2 Networks and related configuration for attachment.
        :param Sequence['L3NetworkAttachmentConfigurationResponse'] l3_networks: The list of Layer 3 Networks and related configuration for attachment.
        :param Sequence['TrunkedNetworkAttachmentConfigurationResponse'] trunked_networks: The list of Trunked Networks and related configuration for attachment.
        """
        if l2_networks is not None:
            pulumi.set(__self__, "l2_networks", l2_networks)
        if l3_networks is not None:
            pulumi.set(__self__, "l3_networks", l3_networks)
        if trunked_networks is not None:
            pulumi.set(__self__, "trunked_networks", trunked_networks)

    @_builtins.property
    @pulumi.getter(name="l2Networks")
    def l2_networks(self) -> Optional[Sequence['outputs.L2NetworkAttachmentConfigurationResponse']]:
        """
        The list of Layer 2 Networks and related configuration for attachment.
        """
        return pulumi.get(self, "l2_networks")

    @_builtins.property
    @pulumi.getter(name="l3Networks")
    def l3_networks(self) -> Optional[Sequence['outputs.L3NetworkAttachmentConfigurationResponse']]:
        """
        The list of Layer 3 Networks and related configuration for attachment.
        """
        return pulumi.get(self, "l3_networks")

    @_builtins.property
    @pulumi.getter(name="trunkedNetworks")
    def trunked_networks(self) -> Optional[Sequence['outputs.TrunkedNetworkAttachmentConfigurationResponse']]:
        """
        The list of Trunked Networks and related configuration for attachment.
        """
        return pulumi.get(self, "trunked_networks")


@pulumi.output_type
class AvailableUpgradeResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityLifecycle":
            suggest = "availability_lifecycle"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AvailableUpgradeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AvailableUpgradeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AvailableUpgradeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_lifecycle: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str availability_lifecycle: The version lifecycle indicator.
        :param _builtins.str version: The version available for upgrading.
        """
        pulumi.set(__self__, "availability_lifecycle", availability_lifecycle)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="availabilityLifecycle")
    def availability_lifecycle(self) -> _builtins.str:
        """
        The version lifecycle indicator.
        """
        return pulumi.get(self, "availability_lifecycle")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The version available for upgrading.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class BareMetalMachineConfigurationDataResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bmcConnectionString":
            suggest = "bmc_connection_string"
        elif key == "bmcCredentials":
            suggest = "bmc_credentials"
        elif key == "bmcMacAddress":
            suggest = "bmc_mac_address"
        elif key == "bootMacAddress":
            suggest = "boot_mac_address"
        elif key == "rackSlot":
            suggest = "rack_slot"
        elif key == "serialNumber":
            suggest = "serial_number"
        elif key == "machineDetails":
            suggest = "machine_details"
        elif key == "machineName":
            suggest = "machine_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalMachineConfigurationDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalMachineConfigurationDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalMachineConfigurationDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bmc_connection_string: _builtins.str,
                 bmc_credentials: 'outputs.AdministrativeCredentialsResponse',
                 bmc_mac_address: _builtins.str,
                 boot_mac_address: _builtins.str,
                 rack_slot: _builtins.float,
                 serial_number: _builtins.str,
                 machine_details: Optional[_builtins.str] = None,
                 machine_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str bmc_connection_string: The connection string for the baseboard management controller including IP address and protocol.
        :param 'AdministrativeCredentialsResponse' bmc_credentials: The credentials of the baseboard management controller on this bare metal machine. The password field is expected to be an Azure Key Vault key URL. Until the cluster is converted to utilize managed identity by setting the secret archive settings, the actual password value should be provided instead.
        :param _builtins.str bmc_mac_address: The MAC address of the BMC for this machine.
        :param _builtins.str boot_mac_address: The MAC address associated with the PXE NIC card.
        :param _builtins.float rack_slot: The slot the physical machine is in the rack based on the BOM configuration.
        :param _builtins.str serial_number: The serial number of the machine. Hardware suppliers may use an alternate value. For example, service tag.
        :param _builtins.str machine_details: The free-form additional information about the machine, e.g. an asset tag.
        :param _builtins.str machine_name: The user-provided name for the bare metal machine created from this specification.
               If not provided, the machine name will be generated programmatically.
        """
        pulumi.set(__self__, "bmc_connection_string", bmc_connection_string)
        pulumi.set(__self__, "bmc_credentials", bmc_credentials)
        pulumi.set(__self__, "bmc_mac_address", bmc_mac_address)
        pulumi.set(__self__, "boot_mac_address", boot_mac_address)
        pulumi.set(__self__, "rack_slot", rack_slot)
        pulumi.set(__self__, "serial_number", serial_number)
        if machine_details is not None:
            pulumi.set(__self__, "machine_details", machine_details)
        if machine_name is not None:
            pulumi.set(__self__, "machine_name", machine_name)

    @_builtins.property
    @pulumi.getter(name="bmcConnectionString")
    def bmc_connection_string(self) -> _builtins.str:
        """
        The connection string for the baseboard management controller including IP address and protocol.
        """
        return pulumi.get(self, "bmc_connection_string")

    @_builtins.property
    @pulumi.getter(name="bmcCredentials")
    def bmc_credentials(self) -> 'outputs.AdministrativeCredentialsResponse':
        """
        The credentials of the baseboard management controller on this bare metal machine. The password field is expected to be an Azure Key Vault key URL. Until the cluster is converted to utilize managed identity by setting the secret archive settings, the actual password value should be provided instead.
        """
        return pulumi.get(self, "bmc_credentials")

    @_builtins.property
    @pulumi.getter(name="bmcMacAddress")
    def bmc_mac_address(self) -> _builtins.str:
        """
        The MAC address of the BMC for this machine.
        """
        return pulumi.get(self, "bmc_mac_address")

    @_builtins.property
    @pulumi.getter(name="bootMacAddress")
    def boot_mac_address(self) -> _builtins.str:
        """
        The MAC address associated with the PXE NIC card.
        """
        return pulumi.get(self, "boot_mac_address")

    @_builtins.property
    @pulumi.getter(name="rackSlot")
    def rack_slot(self) -> _builtins.float:
        """
        The slot the physical machine is in the rack based on the BOM configuration.
        """
        return pulumi.get(self, "rack_slot")

    @_builtins.property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> _builtins.str:
        """
        The serial number of the machine. Hardware suppliers may use an alternate value. For example, service tag.
        """
        return pulumi.get(self, "serial_number")

    @_builtins.property
    @pulumi.getter(name="machineDetails")
    def machine_details(self) -> Optional[_builtins.str]:
        """
        The free-form additional information about the machine, e.g. an asset tag.
        """
        return pulumi.get(self, "machine_details")

    @_builtins.property
    @pulumi.getter(name="machineName")
    def machine_name(self) -> Optional[_builtins.str]:
        """
        The user-provided name for the bare metal machine created from this specification.
        If not provided, the machine name will be generated programmatically.
        """
        return pulumi.get(self, "machine_name")


@pulumi.output_type
class BgpAdvertisementResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddressPools":
            suggest = "ip_address_pools"
        elif key == "advertiseToFabric":
            suggest = "advertise_to_fabric"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BgpAdvertisementResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BgpAdvertisementResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BgpAdvertisementResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address_pools: Sequence[_builtins.str],
                 advertise_to_fabric: Optional[_builtins.str] = None,
                 communities: Optional[Sequence[_builtins.str]] = None,
                 peers: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] ip_address_pools: The names of the IP address pools associated with this announcement.
        :param _builtins.str advertise_to_fabric: The indicator of if this advertisement is also made to the network fabric associated with the Network Cloud Cluster. This field is ignored if fabricPeeringEnabled is set to False.
        :param Sequence[_builtins.str] communities: The names of the BGP communities to be associated with the announcement, utilizing a BGP community string in 1234:1234 format.
        :param Sequence[_builtins.str] peers: The names of the BGP peers to limit this advertisement to. If no values are specified, all BGP peers will receive this advertisement.
        """
        pulumi.set(__self__, "ip_address_pools", ip_address_pools)
        if advertise_to_fabric is None:
            advertise_to_fabric = 'True'
        if advertise_to_fabric is not None:
            pulumi.set(__self__, "advertise_to_fabric", advertise_to_fabric)
        if communities is not None:
            pulumi.set(__self__, "communities", communities)
        if peers is not None:
            pulumi.set(__self__, "peers", peers)

    @_builtins.property
    @pulumi.getter(name="ipAddressPools")
    def ip_address_pools(self) -> Sequence[_builtins.str]:
        """
        The names of the IP address pools associated with this announcement.
        """
        return pulumi.get(self, "ip_address_pools")

    @_builtins.property
    @pulumi.getter(name="advertiseToFabric")
    def advertise_to_fabric(self) -> Optional[_builtins.str]:
        """
        The indicator of if this advertisement is also made to the network fabric associated with the Network Cloud Cluster. This field is ignored if fabricPeeringEnabled is set to False.
        """
        return pulumi.get(self, "advertise_to_fabric")

    @_builtins.property
    @pulumi.getter
    def communities(self) -> Optional[Sequence[_builtins.str]]:
        """
        The names of the BGP communities to be associated with the announcement, utilizing a BGP community string in 1234:1234 format.
        """
        return pulumi.get(self, "communities")

    @_builtins.property
    @pulumi.getter
    def peers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The names of the BGP peers to limit this advertisement to. If no values are specified, all BGP peers will receive this advertisement.
        """
        return pulumi.get(self, "peers")


@pulumi.output_type
class BgpServiceLoadBalancerConfigurationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bgpAdvertisements":
            suggest = "bgp_advertisements"
        elif key == "bgpPeers":
            suggest = "bgp_peers"
        elif key == "fabricPeeringEnabled":
            suggest = "fabric_peering_enabled"
        elif key == "ipAddressPools":
            suggest = "ip_address_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BgpServiceLoadBalancerConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BgpServiceLoadBalancerConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BgpServiceLoadBalancerConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bgp_advertisements: Optional[Sequence['outputs.BgpAdvertisementResponse']] = None,
                 bgp_peers: Optional[Sequence['outputs.ServiceLoadBalancerBgpPeerResponse']] = None,
                 fabric_peering_enabled: Optional[_builtins.str] = None,
                 ip_address_pools: Optional[Sequence['outputs.IpAddressPoolResponse']] = None):
        """
        :param Sequence['BgpAdvertisementResponse'] bgp_advertisements: The association of IP address pools to the communities and peers, allowing for announcement of IPs.
        :param Sequence['ServiceLoadBalancerBgpPeerResponse'] bgp_peers: The list of additional BgpPeer entities that the Kubernetes cluster will peer with. All peering must be explicitly defined.
        :param _builtins.str fabric_peering_enabled: The indicator to specify if the load balancer peers with the network fabric.
        :param Sequence['IpAddressPoolResponse'] ip_address_pools: The list of pools of IP addresses that can be allocated to load balancer services.
        """
        if bgp_advertisements is not None:
            pulumi.set(__self__, "bgp_advertisements", bgp_advertisements)
        if bgp_peers is not None:
            pulumi.set(__self__, "bgp_peers", bgp_peers)
        if fabric_peering_enabled is None:
            fabric_peering_enabled = 'True'
        if fabric_peering_enabled is not None:
            pulumi.set(__self__, "fabric_peering_enabled", fabric_peering_enabled)
        if ip_address_pools is not None:
            pulumi.set(__self__, "ip_address_pools", ip_address_pools)

    @_builtins.property
    @pulumi.getter(name="bgpAdvertisements")
    def bgp_advertisements(self) -> Optional[Sequence['outputs.BgpAdvertisementResponse']]:
        """
        The association of IP address pools to the communities and peers, allowing for announcement of IPs.
        """
        return pulumi.get(self, "bgp_advertisements")

    @_builtins.property
    @pulumi.getter(name="bgpPeers")
    def bgp_peers(self) -> Optional[Sequence['outputs.ServiceLoadBalancerBgpPeerResponse']]:
        """
        The list of additional BgpPeer entities that the Kubernetes cluster will peer with. All peering must be explicitly defined.
        """
        return pulumi.get(self, "bgp_peers")

    @_builtins.property
    @pulumi.getter(name="fabricPeeringEnabled")
    def fabric_peering_enabled(self) -> Optional[_builtins.str]:
        """
        The indicator to specify if the load balancer peers with the network fabric.
        """
        return pulumi.get(self, "fabric_peering_enabled")

    @_builtins.property
    @pulumi.getter(name="ipAddressPools")
    def ip_address_pools(self) -> Optional[Sequence['outputs.IpAddressPoolResponse']]:
        """
        The list of pools of IP addresses that can be allocated to load balancer services.
        """
        return pulumi.get(self, "ip_address_pools")


@pulumi.output_type
class ClusterAvailableUpgradeVersionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlImpact":
            suggest = "control_impact"
        elif key == "expectedDuration":
            suggest = "expected_duration"
        elif key == "impactDescription":
            suggest = "impact_description"
        elif key == "supportExpiryDate":
            suggest = "support_expiry_date"
        elif key == "targetClusterVersion":
            suggest = "target_cluster_version"
        elif key == "workloadImpact":
            suggest = "workload_impact"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAvailableUpgradeVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAvailableUpgradeVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAvailableUpgradeVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_impact: _builtins.str,
                 expected_duration: _builtins.str,
                 impact_description: _builtins.str,
                 support_expiry_date: _builtins.str,
                 target_cluster_version: _builtins.str,
                 workload_impact: _builtins.str):
        """
        :param _builtins.str control_impact: The indicator of whether the control plane will be impacted during the upgrade.
        :param _builtins.str expected_duration: The expected duration needed for this upgrade.
        :param _builtins.str impact_description: The impact description including the specific details and release notes.
        :param _builtins.str support_expiry_date: The last date the version of the platform is supported.
        :param _builtins.str target_cluster_version: The target version this cluster will be upgraded to.
        :param _builtins.str workload_impact: The indicator of whether the workload will be impacted during the upgrade.
        """
        pulumi.set(__self__, "control_impact", control_impact)
        pulumi.set(__self__, "expected_duration", expected_duration)
        pulumi.set(__self__, "impact_description", impact_description)
        pulumi.set(__self__, "support_expiry_date", support_expiry_date)
        pulumi.set(__self__, "target_cluster_version", target_cluster_version)
        pulumi.set(__self__, "workload_impact", workload_impact)

    @_builtins.property
    @pulumi.getter(name="controlImpact")
    def control_impact(self) -> _builtins.str:
        """
        The indicator of whether the control plane will be impacted during the upgrade.
        """
        return pulumi.get(self, "control_impact")

    @_builtins.property
    @pulumi.getter(name="expectedDuration")
    def expected_duration(self) -> _builtins.str:
        """
        The expected duration needed for this upgrade.
        """
        return pulumi.get(self, "expected_duration")

    @_builtins.property
    @pulumi.getter(name="impactDescription")
    def impact_description(self) -> _builtins.str:
        """
        The impact description including the specific details and release notes.
        """
        return pulumi.get(self, "impact_description")

    @_builtins.property
    @pulumi.getter(name="supportExpiryDate")
    def support_expiry_date(self) -> _builtins.str:
        """
        The last date the version of the platform is supported.
        """
        return pulumi.get(self, "support_expiry_date")

    @_builtins.property
    @pulumi.getter(name="targetClusterVersion")
    def target_cluster_version(self) -> _builtins.str:
        """
        The target version this cluster will be upgraded to.
        """
        return pulumi.get(self, "target_cluster_version")

    @_builtins.property
    @pulumi.getter(name="workloadImpact")
    def workload_impact(self) -> _builtins.str:
        """
        The indicator of whether the workload will be impacted during the upgrade.
        """
        return pulumi.get(self, "workload_impact")


@pulumi.output_type
class ClusterAvailableVersionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "supportExpiryDate":
            suggest = "support_expiry_date"
        elif key == "targetClusterVersion":
            suggest = "target_cluster_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAvailableVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAvailableVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAvailableVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 support_expiry_date: _builtins.str,
                 target_cluster_version: _builtins.str):
        """
        :param _builtins.str support_expiry_date: The last date the version of the platform is supported.
        :param _builtins.str target_cluster_version: The version of the cluster to be deployed.
        """
        pulumi.set(__self__, "support_expiry_date", support_expiry_date)
        pulumi.set(__self__, "target_cluster_version", target_cluster_version)

    @_builtins.property
    @pulumi.getter(name="supportExpiryDate")
    def support_expiry_date(self) -> _builtins.str:
        """
        The last date the version of the platform is supported.
        """
        return pulumi.get(self, "support_expiry_date")

    @_builtins.property
    @pulumi.getter(name="targetClusterVersion")
    def target_cluster_version(self) -> _builtins.str:
        """
        The version of the cluster to be deployed.
        """
        return pulumi.get(self, "target_cluster_version")


@pulumi.output_type
class ClusterCapacityResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availableApplianceStorageGB":
            suggest = "available_appliance_storage_gb"
        elif key == "availableCoreCount":
            suggest = "available_core_count"
        elif key == "availableHostStorageGB":
            suggest = "available_host_storage_gb"
        elif key == "availableMemoryGB":
            suggest = "available_memory_gb"
        elif key == "totalApplianceStorageGB":
            suggest = "total_appliance_storage_gb"
        elif key == "totalCoreCount":
            suggest = "total_core_count"
        elif key == "totalHostStorageGB":
            suggest = "total_host_storage_gb"
        elif key == "totalMemoryGB":
            suggest = "total_memory_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCapacityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCapacityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCapacityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 available_appliance_storage_gb: Optional[_builtins.float] = None,
                 available_core_count: Optional[_builtins.float] = None,
                 available_host_storage_gb: Optional[_builtins.float] = None,
                 available_memory_gb: Optional[_builtins.float] = None,
                 total_appliance_storage_gb: Optional[_builtins.float] = None,
                 total_core_count: Optional[_builtins.float] = None,
                 total_host_storage_gb: Optional[_builtins.float] = None,
                 total_memory_gb: Optional[_builtins.float] = None):
        """
        :param _builtins.float available_appliance_storage_gb: The remaining appliance-based storage in GB available for workload use. Measured in gibibytes.
        :param _builtins.float available_core_count: The remaining number of cores that are available in this cluster for workload use.
        :param _builtins.float available_host_storage_gb: The remaining machine or host-based storage in GB available for workload use. Measured in gibibytes.
        :param _builtins.float available_memory_gb: The remaining memory in GB that are available in this cluster for workload use. Measured in gibibytes.
        :param _builtins.float total_appliance_storage_gb: The total appliance-based storage in GB supported by this cluster for workload use. Measured in gibibytes.
        :param _builtins.float total_core_count: The total number of cores that are supported by this cluster for workload use.
        :param _builtins.float total_host_storage_gb: The total machine or host-based storage in GB supported by this cluster for workload use. Measured in gibibytes.
        :param _builtins.float total_memory_gb: The total memory supported by this cluster for workload use. Measured in gibibytes.
        """
        if available_appliance_storage_gb is not None:
            pulumi.set(__self__, "available_appliance_storage_gb", available_appliance_storage_gb)
        if available_core_count is not None:
            pulumi.set(__self__, "available_core_count", available_core_count)
        if available_host_storage_gb is not None:
            pulumi.set(__self__, "available_host_storage_gb", available_host_storage_gb)
        if available_memory_gb is not None:
            pulumi.set(__self__, "available_memory_gb", available_memory_gb)
        if total_appliance_storage_gb is not None:
            pulumi.set(__self__, "total_appliance_storage_gb", total_appliance_storage_gb)
        if total_core_count is not None:
            pulumi.set(__self__, "total_core_count", total_core_count)
        if total_host_storage_gb is not None:
            pulumi.set(__self__, "total_host_storage_gb", total_host_storage_gb)
        if total_memory_gb is not None:
            pulumi.set(__self__, "total_memory_gb", total_memory_gb)

    @_builtins.property
    @pulumi.getter(name="availableApplianceStorageGB")
    def available_appliance_storage_gb(self) -> Optional[_builtins.float]:
        """
        The remaining appliance-based storage in GB available for workload use. Measured in gibibytes.
        """
        return pulumi.get(self, "available_appliance_storage_gb")

    @_builtins.property
    @pulumi.getter(name="availableCoreCount")
    def available_core_count(self) -> Optional[_builtins.float]:
        """
        The remaining number of cores that are available in this cluster for workload use.
        """
        return pulumi.get(self, "available_core_count")

    @_builtins.property
    @pulumi.getter(name="availableHostStorageGB")
    def available_host_storage_gb(self) -> Optional[_builtins.float]:
        """
        The remaining machine or host-based storage in GB available for workload use. Measured in gibibytes.
        """
        return pulumi.get(self, "available_host_storage_gb")

    @_builtins.property
    @pulumi.getter(name="availableMemoryGB")
    def available_memory_gb(self) -> Optional[_builtins.float]:
        """
        The remaining memory in GB that are available in this cluster for workload use. Measured in gibibytes.
        """
        return pulumi.get(self, "available_memory_gb")

    @_builtins.property
    @pulumi.getter(name="totalApplianceStorageGB")
    def total_appliance_storage_gb(self) -> Optional[_builtins.float]:
        """
        The total appliance-based storage in GB supported by this cluster for workload use. Measured in gibibytes.
        """
        return pulumi.get(self, "total_appliance_storage_gb")

    @_builtins.property
    @pulumi.getter(name="totalCoreCount")
    def total_core_count(self) -> Optional[_builtins.float]:
        """
        The total number of cores that are supported by this cluster for workload use.
        """
        return pulumi.get(self, "total_core_count")

    @_builtins.property
    @pulumi.getter(name="totalHostStorageGB")
    def total_host_storage_gb(self) -> Optional[_builtins.float]:
        """
        The total machine or host-based storage in GB supported by this cluster for workload use. Measured in gibibytes.
        """
        return pulumi.get(self, "total_host_storage_gb")

    @_builtins.property
    @pulumi.getter(name="totalMemoryGB")
    def total_memory_gb(self) -> Optional[_builtins.float]:
        """
        The total memory supported by this cluster for workload use. Measured in gibibytes.
        """
        return pulumi.get(self, "total_memory_gb")


@pulumi.output_type
class ClusterSecretArchiveResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultId":
            suggest = "key_vault_id"
        elif key == "useKeyVault":
            suggest = "use_key_vault"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSecretArchiveResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSecretArchiveResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSecretArchiveResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_id: _builtins.str,
                 use_key_vault: Optional[_builtins.str] = None):
        """
        :param _builtins.str key_vault_id: The resource ID of the key vault to archive the secrets of the cluster.
        :param _builtins.str use_key_vault: The indicator if the specified key vault should be used to archive the secrets of the cluster.
        """
        pulumi.set(__self__, "key_vault_id", key_vault_id)
        if use_key_vault is None:
            use_key_vault = 'False'
        if use_key_vault is not None:
            pulumi.set(__self__, "use_key_vault", use_key_vault)

    @_builtins.property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> _builtins.str:
        """
        The resource ID of the key vault to archive the secrets of the cluster.
        """
        return pulumi.get(self, "key_vault_id")

    @_builtins.property
    @pulumi.getter(name="useKeyVault")
    def use_key_vault(self) -> Optional[_builtins.str]:
        """
        The indicator if the specified key vault should be used to archive the secrets of the cluster.
        """
        return pulumi.get(self, "use_key_vault")


@pulumi.output_type
class ClusterUpdateStrategyResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "strategyType":
            suggest = "strategy_type"
        elif key == "thresholdType":
            suggest = "threshold_type"
        elif key == "thresholdValue":
            suggest = "threshold_value"
        elif key == "maxUnavailable":
            suggest = "max_unavailable"
        elif key == "waitTimeMinutes":
            suggest = "wait_time_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterUpdateStrategyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterUpdateStrategyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterUpdateStrategyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 strategy_type: _builtins.str,
                 threshold_type: _builtins.str,
                 threshold_value: _builtins.float,
                 max_unavailable: Optional[_builtins.float] = None,
                 wait_time_minutes: Optional[_builtins.float] = None):
        """
        :param _builtins.str strategy_type: The mode of operation for runtime protection.
        :param _builtins.str threshold_type: Selection of how the threshold should be evaluated.
        :param _builtins.float threshold_value: The numeric threshold value.
        :param _builtins.float max_unavailable: The maximum number of worker nodes that can be offline within the increment of update, e.g., rack-by-rack.
               Limited by the maximum number of machines in the increment. Defaults to the whole increment size.
        :param _builtins.float wait_time_minutes: The time to wait between the increments of update defined by the strategy.
        """
        pulumi.set(__self__, "strategy_type", strategy_type)
        pulumi.set(__self__, "threshold_type", threshold_type)
        pulumi.set(__self__, "threshold_value", threshold_value)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if wait_time_minutes is None:
            wait_time_minutes = 15
        if wait_time_minutes is not None:
            pulumi.set(__self__, "wait_time_minutes", wait_time_minutes)

    @_builtins.property
    @pulumi.getter(name="strategyType")
    def strategy_type(self) -> _builtins.str:
        """
        The mode of operation for runtime protection.
        """
        return pulumi.get(self, "strategy_type")

    @_builtins.property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> _builtins.str:
        """
        Selection of how the threshold should be evaluated.
        """
        return pulumi.get(self, "threshold_type")

    @_builtins.property
    @pulumi.getter(name="thresholdValue")
    def threshold_value(self) -> _builtins.float:
        """
        The numeric threshold value.
        """
        return pulumi.get(self, "threshold_value")

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[_builtins.float]:
        """
        The maximum number of worker nodes that can be offline within the increment of update, e.g., rack-by-rack.
        Limited by the maximum number of machines in the increment. Defaults to the whole increment size.
        """
        return pulumi.get(self, "max_unavailable")

    @_builtins.property
    @pulumi.getter(name="waitTimeMinutes")
    def wait_time_minutes(self) -> Optional[_builtins.float]:
        """
        The time to wait between the increments of update defined by the strategy.
        """
        return pulumi.get(self, "wait_time_minutes")


@pulumi.output_type
class CommandOutputSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associatedIdentity":
            suggest = "associated_identity"
        elif key == "containerUrl":
            suggest = "container_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CommandOutputSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CommandOutputSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CommandOutputSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associated_identity: Optional['outputs.IdentitySelectorResponse'] = None,
                 container_url: Optional[_builtins.str] = None):
        """
        :param 'IdentitySelectorResponse' associated_identity: The selection of the managed identity to use with this storage account container. The identity type must be either system assigned or user assigned.
        :param _builtins.str container_url: The URL of the storage account container that is to be used by the specified identities.
        """
        if associated_identity is not None:
            pulumi.set(__self__, "associated_identity", associated_identity)
        if container_url is not None:
            pulumi.set(__self__, "container_url", container_url)

    @_builtins.property
    @pulumi.getter(name="associatedIdentity")
    def associated_identity(self) -> Optional['outputs.IdentitySelectorResponse']:
        """
        The selection of the managed identity to use with this storage account container. The identity type must be either system assigned or user assigned.
        """
        return pulumi.get(self, "associated_identity")

    @_builtins.property
    @pulumi.getter(name="containerUrl")
    def container_url(self) -> Optional[_builtins.str]:
        """
        The URL of the storage account container that is to be used by the specified identities.
        """
        return pulumi.get(self, "container_url")


@pulumi.output_type
class ControlPlaneNodeConfigurationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vmSkuName":
            suggest = "vm_sku_name"
        elif key == "administratorConfiguration":
            suggest = "administrator_configuration"
        elif key == "availabilityZones":
            suggest = "availability_zones"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ControlPlaneNodeConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ControlPlaneNodeConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ControlPlaneNodeConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: _builtins.float,
                 vm_sku_name: _builtins.str,
                 administrator_configuration: Optional['outputs.AdministratorConfigurationResponse'] = None,
                 availability_zones: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.float count: The number of virtual machines that use this configuration.
        :param _builtins.str vm_sku_name: The name of the VM SKU supplied during creation.
        :param 'AdministratorConfigurationResponse' administrator_configuration: The administrator credentials to be used for the nodes in the control plane.
        :param Sequence[_builtins.str] availability_zones: The list of availability zones of the Network Cloud cluster to be used for the provisioning of nodes in the control plane. If not specified, all availability zones will be used.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "vm_sku_name", vm_sku_name)
        if administrator_configuration is not None:
            pulumi.set(__self__, "administrator_configuration", administrator_configuration)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.float:
        """
        The number of virtual machines that use this configuration.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="vmSkuName")
    def vm_sku_name(self) -> _builtins.str:
        """
        The name of the VM SKU supplied during creation.
        """
        return pulumi.get(self, "vm_sku_name")

    @_builtins.property
    @pulumi.getter(name="administratorConfiguration")
    def administrator_configuration(self) -> Optional['outputs.AdministratorConfigurationResponse']:
        """
        The administrator credentials to be used for the nodes in the control plane.
        """
        return pulumi.get(self, "administrator_configuration")

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of availability zones of the Network Cloud cluster to be used for the provisioning of nodes in the control plane. If not specified, all availability zones will be used.
        """
        return pulumi.get(self, "availability_zones")


@pulumi.output_type
class EgressEndpointResponse(dict):
    def __init__(__self__, *,
                 category: _builtins.str,
                 endpoints: Sequence['outputs.EndpointDependencyResponse']):
        """
        :param _builtins.str category: The descriptive category name of endpoints accessible by the AKS agent node. For example, azure-resource-management, API server, etc. The platform egress endpoints provided by default will use the category 'default'.
        :param Sequence['EndpointDependencyResponse'] endpoints: The list of endpoint dependencies.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "endpoints", endpoints)

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        """
        The descriptive category name of endpoints accessible by the AKS agent node. For example, azure-resource-management, API server, etc. The platform egress endpoints provided by default will use the category 'default'.
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.EndpointDependencyResponse']:
        """
        The list of endpoint dependencies.
        """
        return pulumi.get(self, "endpoints")


@pulumi.output_type
class EndpointDependencyResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainName":
            suggest = "domain_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointDependencyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointDependencyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointDependencyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name: _builtins.str,
                 port: Optional[_builtins.float] = None):
        """
        :param _builtins.str domain_name: The domain name of the dependency.
        :param _builtins.float port: The port of this endpoint.
        """
        pulumi.set(__self__, "domain_name", domain_name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        """
        The domain name of the dependency.
        """
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.float]:
        """
        The port of this endpoint.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ExtendedLocationResponse(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str name: The resource ID of the extended location on which the resource will be created.
        :param _builtins.str type: The extended location type, for example, CustomLocation.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The resource ID of the extended location on which the resource will be created.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The extended location type, for example, CustomLocation.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FeatureStatusResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detailedStatus":
            suggest = "detailed_status"
        elif key == "detailedStatusMessage":
            suggest = "detailed_status_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 detailed_status: _builtins.str,
                 detailed_status_message: _builtins.str,
                 name: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str detailed_status: The status representing the state of this feature.
        :param _builtins.str detailed_status_message: The descriptive message about the current detailed status.
        :param _builtins.str name: The name of the feature.
        :param _builtins.str version: The version of the feature.
        """
        pulumi.set(__self__, "detailed_status", detailed_status)
        pulumi.set(__self__, "detailed_status_message", detailed_status_message)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="detailedStatus")
    def detailed_status(self) -> _builtins.str:
        """
        The status representing the state of this feature.
        """
        return pulumi.get(self, "detailed_status")

    @_builtins.property
    @pulumi.getter(name="detailedStatusMessage")
    def detailed_status_message(self) -> _builtins.str:
        """
        The descriptive message about the current detailed status.
        """
        return pulumi.get(self, "detailed_status_message")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the feature.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The version of the feature.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class HardwareInventoryNetworkInterfaceResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkStatus":
            suggest = "link_status"
        elif key == "macAddress":
            suggest = "mac_address"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HardwareInventoryNetworkInterfaceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HardwareInventoryNetworkInterfaceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HardwareInventoryNetworkInterfaceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 link_status: _builtins.str,
                 mac_address: _builtins.str,
                 name: _builtins.str,
                 network_interface_id: _builtins.str):
        """
        :param _builtins.str link_status: The current status of the link.
        :param _builtins.str mac_address: The MAC address associated with this interface.
        :param _builtins.str name: The name of the interface.
        :param _builtins.str network_interface_id: The resource ID of the network interface for the port on the switch that this machine's interface is connected to.
        """
        pulumi.set(__self__, "link_status", link_status)
        pulumi.set(__self__, "mac_address", mac_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_interface_id", network_interface_id)

    @_builtins.property
    @pulumi.getter(name="linkStatus")
    def link_status(self) -> _builtins.str:
        """
        The current status of the link.
        """
        return pulumi.get(self, "link_status")

    @_builtins.property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> _builtins.str:
        """
        The MAC address associated with this interface.
        """
        return pulumi.get(self, "mac_address")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the interface.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> _builtins.str:
        """
        The resource ID of the network interface for the port on the switch that this machine's interface is connected to.
        """
        return pulumi.get(self, "network_interface_id")


@pulumi.output_type
class HardwareInventoryResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalHostInformation":
            suggest = "additional_host_information"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HardwareInventoryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HardwareInventoryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HardwareInventoryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_host_information: _builtins.str,
                 interfaces: Sequence['outputs.HardwareInventoryNetworkInterfaceResponse'],
                 nics: Sequence['outputs.NicResponse']):
        """
        :param _builtins.str additional_host_information: Freeform data extracted from the environment about this machine. This information varies depending on the specific hardware and configuration.
        :param Sequence['HardwareInventoryNetworkInterfaceResponse'] interfaces: The list of network interfaces and associated details for the bare metal machine.
        :param Sequence['NicResponse'] nics: Field Deprecated. Will be removed in an upcoming version. The list of network interface cards and associated details for the bare metal machine.
        """
        pulumi.set(__self__, "additional_host_information", additional_host_information)
        pulumi.set(__self__, "interfaces", interfaces)
        pulumi.set(__self__, "nics", nics)

    @_builtins.property
    @pulumi.getter(name="additionalHostInformation")
    def additional_host_information(self) -> _builtins.str:
        """
        Freeform data extracted from the environment about this machine. This information varies depending on the specific hardware and configuration.
        """
        return pulumi.get(self, "additional_host_information")

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Sequence['outputs.HardwareInventoryNetworkInterfaceResponse']:
        """
        The list of network interfaces and associated details for the bare metal machine.
        """
        return pulumi.get(self, "interfaces")

    @_builtins.property
    @pulumi.getter
    def nics(self) -> Sequence['outputs.NicResponse']:
        """
        Field Deprecated. Will be removed in an upcoming version. The list of network interface cards and associated details for the bare metal machine.
        """
        return pulumi.get(self, "nics")


@pulumi.output_type
class HardwareValidationStatusResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastValidationTime":
            suggest = "last_validation_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HardwareValidationStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HardwareValidationStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HardwareValidationStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_validation_time: _builtins.str,
                 result: _builtins.str):
        """
        :param _builtins.str last_validation_time: The timestamp of the hardware validation execution.
        :param _builtins.str result: The outcome of the hardware validation.
        """
        pulumi.set(__self__, "last_validation_time", last_validation_time)
        pulumi.set(__self__, "result", result)

    @_builtins.property
    @pulumi.getter(name="lastValidationTime")
    def last_validation_time(self) -> _builtins.str:
        """
        The timestamp of the hardware validation execution.
        """
        return pulumi.get(self, "last_validation_time")

    @_builtins.property
    @pulumi.getter
    def result(self) -> _builtins.str:
        """
        The outcome of the hardware validation.
        """
        return pulumi.get(self, "result")


@pulumi.output_type
class IdentitySelectorResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityType":
            suggest = "identity_type"
        elif key == "userAssignedIdentityResourceId":
            suggest = "user_assigned_identity_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentitySelectorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentitySelectorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentitySelectorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_type: Optional[_builtins.str] = None,
                 user_assigned_identity_resource_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str identity_type: The type of managed identity that is being selected.
        :param _builtins.str user_assigned_identity_resource_id: The user assigned managed identity resource ID to use. Mutually exclusive with a system assigned identity type.
        """
        if identity_type is not None:
            pulumi.set(__self__, "identity_type", identity_type)
        if user_assigned_identity_resource_id is not None:
            pulumi.set(__self__, "user_assigned_identity_resource_id", user_assigned_identity_resource_id)

    @_builtins.property
    @pulumi.getter(name="identityType")
    def identity_type(self) -> Optional[_builtins.str]:
        """
        The type of managed identity that is being selected.
        """
        return pulumi.get(self, "identity_type")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentityResourceId")
    def user_assigned_identity_resource_id(self) -> Optional[_builtins.str]:
        """
        The user assigned managed identity resource ID to use. Mutually exclusive with a system assigned identity type.
        """
        return pulumi.get(self, "user_assigned_identity_resource_id")


@pulumi.output_type
class ImageRepositoryCredentialsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "registryUrl":
            suggest = "registry_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageRepositoryCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageRepositoryCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageRepositoryCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: _builtins.str,
                 registry_url: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str password: The password or token used to access an image in the target repository.
        :param _builtins.str registry_url: The URL of the authentication server used to validate the repository credentials.
        :param _builtins.str username: The username used to access an image in the target repository.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "registry_url", registry_url)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The password or token used to access an image in the target repository.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="registryUrl")
    def registry_url(self) -> _builtins.str:
        """
        The URL of the authentication server used to validate the repository credentials.
        """
        return pulumi.get(self, "registry_url")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The username used to access an image in the target repository.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class InitialAgentPoolConfigurationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vmSkuName":
            suggest = "vm_sku_name"
        elif key == "administratorConfiguration":
            suggest = "administrator_configuration"
        elif key == "agentOptions":
            suggest = "agent_options"
        elif key == "attachedNetworkConfiguration":
            suggest = "attached_network_configuration"
        elif key == "availabilityZones":
            suggest = "availability_zones"
        elif key == "upgradeSettings":
            suggest = "upgrade_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InitialAgentPoolConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InitialAgentPoolConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InitialAgentPoolConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: _builtins.float,
                 mode: _builtins.str,
                 name: _builtins.str,
                 vm_sku_name: _builtins.str,
                 administrator_configuration: Optional['outputs.AdministratorConfigurationResponse'] = None,
                 agent_options: Optional['outputs.AgentOptionsResponse'] = None,
                 attached_network_configuration: Optional['outputs.AttachedNetworkConfigurationResponse'] = None,
                 availability_zones: Optional[Sequence[_builtins.str]] = None,
                 labels: Optional[Sequence['outputs.KubernetesLabelResponse']] = None,
                 taints: Optional[Sequence['outputs.KubernetesLabelResponse']] = None,
                 upgrade_settings: Optional['outputs.AgentPoolUpgradeSettingsResponse'] = None):
        """
        :param _builtins.float count: The number of virtual machines that use this configuration.
        :param _builtins.str mode: The selection of how this agent pool is utilized, either as a system pool or a user pool. System pools run the features and critical services for the Kubernetes Cluster, while user pools are dedicated to user workloads. Every Kubernetes cluster must contain at least one system node pool with at least one node.
        :param _builtins.str name: The name that will be used for the agent pool resource representing this agent pool.
        :param _builtins.str vm_sku_name: The name of the VM SKU that determines the size of resources allocated for node VMs.
        :param 'AdministratorConfigurationResponse' administrator_configuration: The administrator credentials to be used for the nodes in this agent pool.
        :param 'AgentOptionsResponse' agent_options: The configurations that will be applied to each agent in this agent pool.
        :param 'AttachedNetworkConfigurationResponse' attached_network_configuration: The configuration of networks being attached to the agent pool for use by the workloads that run on this Kubernetes cluster.
        :param Sequence[_builtins.str] availability_zones: The list of availability zones of the Network Cloud cluster used for the provisioning of nodes in this agent pool. If not specified, all availability zones will be used.
        :param Sequence['KubernetesLabelResponse'] labels: The labels applied to the nodes in this agent pool.
        :param Sequence['KubernetesLabelResponse'] taints: The taints applied to the nodes in this agent pool.
        :param 'AgentPoolUpgradeSettingsResponse' upgrade_settings: The configuration of the agent pool.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vm_sku_name", vm_sku_name)
        if administrator_configuration is not None:
            pulumi.set(__self__, "administrator_configuration", administrator_configuration)
        if agent_options is not None:
            pulumi.set(__self__, "agent_options", agent_options)
        if attached_network_configuration is not None:
            pulumi.set(__self__, "attached_network_configuration", attached_network_configuration)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if upgrade_settings is not None:
            pulumi.set(__self__, "upgrade_settings", upgrade_settings)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.float:
        """
        The number of virtual machines that use this configuration.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        The selection of how this agent pool is utilized, either as a system pool or a user pool. System pools run the features and critical services for the Kubernetes Cluster, while user pools are dedicated to user workloads. Every Kubernetes cluster must contain at least one system node pool with at least one node.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name that will be used for the agent pool resource representing this agent pool.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="vmSkuName")
    def vm_sku_name(self) -> _builtins.str:
        """
        The name of the VM SKU that determines the size of resources allocated for node VMs.
        """
        return pulumi.get(self, "vm_sku_name")

    @_builtins.property
    @pulumi.getter(name="administratorConfiguration")
    def administrator_configuration(self) -> Optional['outputs.AdministratorConfigurationResponse']:
        """
        The administrator credentials to be used for the nodes in this agent pool.
        """
        return pulumi.get(self, "administrator_configuration")

    @_builtins.property
    @pulumi.getter(name="agentOptions")
    def agent_options(self) -> Optional['outputs.AgentOptionsResponse']:
        """
        The configurations that will be applied to each agent in this agent pool.
        """
        return pulumi.get(self, "agent_options")

    @_builtins.property
    @pulumi.getter(name="attachedNetworkConfiguration")
    def attached_network_configuration(self) -> Optional['outputs.AttachedNetworkConfigurationResponse']:
        """
        The configuration of networks being attached to the agent pool for use by the workloads that run on this Kubernetes cluster.
        """
        return pulumi.get(self, "attached_network_configuration")

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of availability zones of the Network Cloud cluster used for the provisioning of nodes in this agent pool. If not specified, all availability zones will be used.
        """
        return pulumi.get(self, "availability_zones")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Sequence['outputs.KubernetesLabelResponse']]:
        """
        The labels applied to the nodes in this agent pool.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.KubernetesLabelResponse']]:
        """
        The taints applied to the nodes in this agent pool.
        """
        return pulumi.get(self, "taints")

    @_builtins.property
    @pulumi.getter(name="upgradeSettings")
    def upgrade_settings(self) -> Optional['outputs.AgentPoolUpgradeSettingsResponse']:
        """
        The configuration of the agent pool.
        """
        return pulumi.get(self, "upgrade_settings")


@pulumi.output_type
class IpAddressPoolResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoAssign":
            suggest = "auto_assign"
        elif key == "onlyUseHostIps":
            suggest = "only_use_host_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpAddressPoolResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpAddressPoolResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpAddressPoolResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Sequence[_builtins.str],
                 name: _builtins.str,
                 auto_assign: Optional[_builtins.str] = None,
                 only_use_host_ips: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] addresses: The list of IP address ranges. Each range can be a either a subnet in CIDR format or an explicit start-end range of IP addresses. For a BGP service load balancer configuration, only CIDR format is supported and excludes /32 (IPv4) and /128 (IPv6) prefixes.
        :param _builtins.str name: The name used to identify this IP address pool for association with a BGP advertisement.
        :param _builtins.str auto_assign: The indicator to determine if automatic allocation from the pool should occur.
        :param _builtins.str only_use_host_ips: The indicator to prevent the use of IP addresses ending with .0 and .255 for this pool. Enabling this option will only use IP addresses between .1 and .254 inclusive.
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "name", name)
        if auto_assign is None:
            auto_assign = 'True'
        if auto_assign is not None:
            pulumi.set(__self__, "auto_assign", auto_assign)
        if only_use_host_ips is None:
            only_use_host_ips = 'True'
        if only_use_host_ips is not None:
            pulumi.set(__self__, "only_use_host_ips", only_use_host_ips)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Sequence[_builtins.str]:
        """
        The list of IP address ranges. Each range can be a either a subnet in CIDR format or an explicit start-end range of IP addresses. For a BGP service load balancer configuration, only CIDR format is supported and excludes /32 (IPv4) and /128 (IPv6) prefixes.
        """
        return pulumi.get(self, "addresses")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name used to identify this IP address pool for association with a BGP advertisement.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="autoAssign")
    def auto_assign(self) -> Optional[_builtins.str]:
        """
        The indicator to determine if automatic allocation from the pool should occur.
        """
        return pulumi.get(self, "auto_assign")

    @_builtins.property
    @pulumi.getter(name="onlyUseHostIps")
    def only_use_host_ips(self) -> Optional[_builtins.str]:
        """
        The indicator to prevent the use of IP addresses ending with .0 and .255 for this pool. Enabling this option will only use IP addresses between .1 and .254 inclusive.
        """
        return pulumi.get(self, "only_use_host_ips")


@pulumi.output_type
class KeySetUserResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureUserName":
            suggest = "azure_user_name"
        elif key == "sshPublicKey":
            suggest = "ssh_public_key"
        elif key == "userPrincipalName":
            suggest = "user_principal_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeySetUserResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeySetUserResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeySetUserResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_user_name: _builtins.str,
                 ssh_public_key: 'outputs.SshPublicKeyResponse',
                 description: Optional[_builtins.str] = None,
                 user_principal_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str azure_user_name: The user name that will be used for access.
        :param 'SshPublicKeyResponse' ssh_public_key: The SSH public key that will be provisioned for user access. The user is expected to have the corresponding SSH private key for logging in.
        :param _builtins.str description: The free-form description for this user.
        :param _builtins.str user_principal_name: The user principal name (email format) used to validate this user's group membership.
        """
        pulumi.set(__self__, "azure_user_name", azure_user_name)
        pulumi.set(__self__, "ssh_public_key", ssh_public_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if user_principal_name is not None:
            pulumi.set(__self__, "user_principal_name", user_principal_name)

    @_builtins.property
    @pulumi.getter(name="azureUserName")
    def azure_user_name(self) -> _builtins.str:
        """
        The user name that will be used for access.
        """
        return pulumi.get(self, "azure_user_name")

    @_builtins.property
    @pulumi.getter(name="sshPublicKey")
    def ssh_public_key(self) -> 'outputs.SshPublicKeyResponse':
        """
        The SSH public key that will be provisioned for user access. The user is expected to have the corresponding SSH private key for logging in.
        """
        return pulumi.get(self, "ssh_public_key")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The free-form description for this user.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="userPrincipalName")
    def user_principal_name(self) -> Optional[_builtins.str]:
        """
        The user principal name (email format) used to validate this user's group membership.
        """
        return pulumi.get(self, "user_principal_name")


@pulumi.output_type
class KeySetUserStatusResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureUserName":
            suggest = "azure_user_name"
        elif key == "statusMessage":
            suggest = "status_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeySetUserStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeySetUserStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeySetUserStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_user_name: _builtins.str,
                 status: _builtins.str,
                 status_message: _builtins.str):
        """
        :param _builtins.str azure_user_name: The user name that will be used for access.
        :param _builtins.str status: The indicator of whether the user is currently deployed for access.
        :param _builtins.str status_message: The additional information describing the current status of this user, if any available.
        """
        pulumi.set(__self__, "azure_user_name", azure_user_name)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_message", status_message)

    @_builtins.property
    @pulumi.getter(name="azureUserName")
    def azure_user_name(self) -> _builtins.str:
        """
        The user name that will be used for access.
        """
        return pulumi.get(self, "azure_user_name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The indicator of whether the user is currently deployed for access.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> _builtins.str:
        """
        The additional information describing the current status of this user, if any available.
        """
        return pulumi.get(self, "status_message")


@pulumi.output_type
class KubernetesClusterNodeResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentPoolId":
            suggest = "agent_pool_id"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "bareMetalMachineId":
            suggest = "bare_metal_machine_id"
        elif key == "cpuCores":
            suggest = "cpu_cores"
        elif key == "detailedStatus":
            suggest = "detailed_status"
        elif key == "detailedStatusMessage":
            suggest = "detailed_status_message"
        elif key == "diskSizeGB":
            suggest = "disk_size_gb"
        elif key == "kubernetesVersion":
            suggest = "kubernetes_version"
        elif key == "memorySizeGB":
            suggest = "memory_size_gb"
        elif key == "networkAttachments":
            suggest = "network_attachments"
        elif key == "powerState":
            suggest = "power_state"
        elif key == "vmSkuName":
            suggest = "vm_sku_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterNodeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterNodeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterNodeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_pool_id: _builtins.str,
                 availability_zone: _builtins.str,
                 bare_metal_machine_id: _builtins.str,
                 cpu_cores: _builtins.float,
                 detailed_status: _builtins.str,
                 detailed_status_message: _builtins.str,
                 disk_size_gb: _builtins.float,
                 image: _builtins.str,
                 kubernetes_version: _builtins.str,
                 labels: Sequence['outputs.KubernetesLabelResponse'],
                 memory_size_gb: _builtins.float,
                 mode: _builtins.str,
                 name: _builtins.str,
                 network_attachments: Sequence['outputs.NetworkAttachmentResponse'],
                 power_state: _builtins.str,
                 role: _builtins.str,
                 taints: Sequence['outputs.KubernetesLabelResponse'],
                 vm_sku_name: _builtins.str):
        """
        :param _builtins.str agent_pool_id: The resource ID of the agent pool that this node belongs to. This value is not represented on control plane nodes.
        :param _builtins.str availability_zone: The availability zone this node is running within.
        :param _builtins.str bare_metal_machine_id: The resource ID of the bare metal machine that hosts this node.
        :param _builtins.float cpu_cores: The number of CPU cores configured for this node, derived from the VM SKU specified.
        :param _builtins.str detailed_status: The detailed state of this node.
        :param _builtins.str detailed_status_message: The descriptive message about the current detailed status.
        :param _builtins.float disk_size_gb: The size of the disk configured for this node. Allocations are measured in gibibytes.
        :param _builtins.str image: The machine image used to deploy this node.
        :param _builtins.str kubernetes_version: The currently running version of Kubernetes and bundled features running on this node.
        :param Sequence['KubernetesLabelResponse'] labels: The list of labels on this node that have been assigned to the agent pool containing this node.
        :param _builtins.float memory_size_gb: The amount of memory configured for this node, derived from the vm SKU specified. Allocations are measured in gibibytes.
        :param _builtins.str mode: The mode of the agent pool containing this node. Not applicable for control plane nodes.
        :param _builtins.str name: The name of this node, as realized in the Kubernetes cluster.
        :param Sequence['NetworkAttachmentResponse'] network_attachments: The NetworkAttachments made to this node.
        :param _builtins.str power_state: The power state of this node.
        :param _builtins.str role: The role of this node in the cluster.
        :param Sequence['KubernetesLabelResponse'] taints: The list of taints that have been assigned to the agent pool containing this node.
        :param _builtins.str vm_sku_name: The VM SKU name that was used to create this cluster node.
        """
        pulumi.set(__self__, "agent_pool_id", agent_pool_id)
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "bare_metal_machine_id", bare_metal_machine_id)
        pulumi.set(__self__, "cpu_cores", cpu_cores)
        pulumi.set(__self__, "detailed_status", detailed_status)
        pulumi.set(__self__, "detailed_status_message", detailed_status_message)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "memory_size_gb", memory_size_gb)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_attachments", network_attachments)
        pulumi.set(__self__, "power_state", power_state)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "taints", taints)
        pulumi.set(__self__, "vm_sku_name", vm_sku_name)

    @_builtins.property
    @pulumi.getter(name="agentPoolId")
    def agent_pool_id(self) -> _builtins.str:
        """
        The resource ID of the agent pool that this node belongs to. This value is not represented on control plane nodes.
        """
        return pulumi.get(self, "agent_pool_id")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> _builtins.str:
        """
        The availability zone this node is running within.
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="bareMetalMachineId")
    def bare_metal_machine_id(self) -> _builtins.str:
        """
        The resource ID of the bare metal machine that hosts this node.
        """
        return pulumi.get(self, "bare_metal_machine_id")

    @_builtins.property
    @pulumi.getter(name="cpuCores")
    def cpu_cores(self) -> _builtins.float:
        """
        The number of CPU cores configured for this node, derived from the VM SKU specified.
        """
        return pulumi.get(self, "cpu_cores")

    @_builtins.property
    @pulumi.getter(name="detailedStatus")
    def detailed_status(self) -> _builtins.str:
        """
        The detailed state of this node.
        """
        return pulumi.get(self, "detailed_status")

    @_builtins.property
    @pulumi.getter(name="detailedStatusMessage")
    def detailed_status_message(self) -> _builtins.str:
        """
        The descriptive message about the current detailed status.
        """
        return pulumi.get(self, "detailed_status_message")

    @_builtins.property
    @pulumi.getter(name="diskSizeGB")
    def disk_size_gb(self) -> _builtins.float:
        """
        The size of the disk configured for this node. Allocations are measured in gibibytes.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        """
        The machine image used to deploy this node.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> _builtins.str:
        """
        The currently running version of Kubernetes and bundled features running on this node.
        """
        return pulumi.get(self, "kubernetes_version")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.KubernetesLabelResponse']:
        """
        The list of labels on this node that have been assigned to the agent pool containing this node.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="memorySizeGB")
    def memory_size_gb(self) -> _builtins.float:
        """
        The amount of memory configured for this node, derived from the vm SKU specified. Allocations are measured in gibibytes.
        """
        return pulumi.get(self, "memory_size_gb")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        The mode of the agent pool containing this node. Not applicable for control plane nodes.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of this node, as realized in the Kubernetes cluster.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkAttachments")
    def network_attachments(self) -> Sequence['outputs.NetworkAttachmentResponse']:
        """
        The NetworkAttachments made to this node.
        """
        return pulumi.get(self, "network_attachments")

    @_builtins.property
    @pulumi.getter(name="powerState")
    def power_state(self) -> _builtins.str:
        """
        The power state of this node.
        """
        return pulumi.get(self, "power_state")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The role of this node in the cluster.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Sequence['outputs.KubernetesLabelResponse']:
        """
        The list of taints that have been assigned to the agent pool containing this node.
        """
        return pulumi.get(self, "taints")

    @_builtins.property
    @pulumi.getter(name="vmSkuName")
    def vm_sku_name(self) -> _builtins.str:
        """
        The VM SKU name that was used to create this cluster node.
        """
        return pulumi.get(self, "vm_sku_name")


@pulumi.output_type
class KubernetesLabelResponse(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The name of the label or taint.
        :param _builtins.str value: The value of the label or taint.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The name of the label or taint.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the label or taint.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class L2NetworkAttachmentConfigurationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "pluginType":
            suggest = "plugin_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in L2NetworkAttachmentConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        L2NetworkAttachmentConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        L2NetworkAttachmentConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: _builtins.str,
                 plugin_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str network_id: The resource ID of the network that is being configured for attachment.
        :param _builtins.str plugin_type: The indicator of how this network will be utilized by the Kubernetes cluster.
        """
        pulumi.set(__self__, "network_id", network_id)
        if plugin_type is None:
            plugin_type = 'SRIOV'
        if plugin_type is not None:
            pulumi.set(__self__, "plugin_type", plugin_type)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        """
        The resource ID of the network that is being configured for attachment.
        """
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter(name="pluginType")
    def plugin_type(self) -> Optional[_builtins.str]:
        """
        The indicator of how this network will be utilized by the Kubernetes cluster.
        """
        return pulumi.get(self, "plugin_type")


@pulumi.output_type
class L2ServiceLoadBalancerConfigurationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddressPools":
            suggest = "ip_address_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in L2ServiceLoadBalancerConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        L2ServiceLoadBalancerConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        L2ServiceLoadBalancerConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address_pools: Optional[Sequence['outputs.IpAddressPoolResponse']] = None):
        """
        :param Sequence['IpAddressPoolResponse'] ip_address_pools: The list of pools of IP addresses that can be allocated to load balancer services.
        """
        if ip_address_pools is not None:
            pulumi.set(__self__, "ip_address_pools", ip_address_pools)

    @_builtins.property
    @pulumi.getter(name="ipAddressPools")
    def ip_address_pools(self) -> Optional[Sequence['outputs.IpAddressPoolResponse']]:
        """
        The list of pools of IP addresses that can be allocated to load balancer services.
        """
        return pulumi.get(self, "ip_address_pools")


@pulumi.output_type
class L3NetworkAttachmentConfigurationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "ipamEnabled":
            suggest = "ipam_enabled"
        elif key == "pluginType":
            suggest = "plugin_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in L3NetworkAttachmentConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        L3NetworkAttachmentConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        L3NetworkAttachmentConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: _builtins.str,
                 ipam_enabled: Optional[_builtins.str] = None,
                 plugin_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str network_id: The resource ID of the network that is being configured for attachment.
        :param _builtins.str ipam_enabled: The indication of whether this network will or will not perform IP address management and allocate IP addresses when attached.
        :param _builtins.str plugin_type: The indicator of how this network will be utilized by the Kubernetes cluster.
        """
        pulumi.set(__self__, "network_id", network_id)
        if ipam_enabled is None:
            ipam_enabled = 'False'
        if ipam_enabled is not None:
            pulumi.set(__self__, "ipam_enabled", ipam_enabled)
        if plugin_type is None:
            plugin_type = 'SRIOV'
        if plugin_type is not None:
            pulumi.set(__self__, "plugin_type", plugin_type)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        """
        The resource ID of the network that is being configured for attachment.
        """
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter(name="ipamEnabled")
    def ipam_enabled(self) -> Optional[_builtins.str]:
        """
        The indication of whether this network will or will not perform IP address management and allocate IP addresses when attached.
        """
        return pulumi.get(self, "ipam_enabled")

    @_builtins.property
    @pulumi.getter(name="pluginType")
    def plugin_type(self) -> Optional[_builtins.str]:
        """
        The indicator of how this network will be utilized by the Kubernetes cluster.
        """
        return pulumi.get(self, "plugin_type")


@pulumi.output_type
class LldpNeighborResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portDescription":
            suggest = "port_description"
        elif key == "portName":
            suggest = "port_name"
        elif key == "systemDescription":
            suggest = "system_description"
        elif key == "systemName":
            suggest = "system_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LldpNeighborResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LldpNeighborResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LldpNeighborResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_description: _builtins.str,
                 port_name: _builtins.str,
                 system_description: _builtins.str,
                 system_name: _builtins.str):
        """
        :param _builtins.str port_description: The descriptive information about the port on the connected device.
        :param _builtins.str port_name: The system-assigned name of the port on the connected device.
        :param _builtins.str system_description: The descriptive information about the connected device.
        :param _builtins.str system_name: The system-assigned name of the connected device.
        """
        pulumi.set(__self__, "port_description", port_description)
        pulumi.set(__self__, "port_name", port_name)
        pulumi.set(__self__, "system_description", system_description)
        pulumi.set(__self__, "system_name", system_name)

    @_builtins.property
    @pulumi.getter(name="portDescription")
    def port_description(self) -> _builtins.str:
        """
        The descriptive information about the port on the connected device.
        """
        return pulumi.get(self, "port_description")

    @_builtins.property
    @pulumi.getter(name="portName")
    def port_name(self) -> _builtins.str:
        """
        The system-assigned name of the port on the connected device.
        """
        return pulumi.get(self, "port_name")

    @_builtins.property
    @pulumi.getter(name="systemDescription")
    def system_description(self) -> _builtins.str:
        """
        The descriptive information about the connected device.
        """
        return pulumi.get(self, "system_description")

    @_builtins.property
    @pulumi.getter(name="systemName")
    def system_name(self) -> _builtins.str:
        """
        The system-assigned name of the connected device.
        """
        return pulumi.get(self, "system_name")


@pulumi.output_type
class ManagedResourceGroupConfigurationResponse(dict):
    def __init__(__self__, *,
                 location: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str location: The location of the managed resource group. If not specified, the location of the parent resource is chosen.
        :param _builtins.str name: The name for the managed resource group. If not specified, the unique name is automatically generated.
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        The location of the managed resource group. If not specified, the location of the parent resource is chosen.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name for the managed resource group. If not specified, the unique name is automatically generated.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity (system assigned and/or user assigned identities)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: _builtins.str,
                 tenant_id: _builtins.str,
                 type: _builtins.str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param _builtins.str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param _builtins.str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param _builtins.str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class NetworkAttachmentResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachedNetworkId":
            suggest = "attached_network_id"
        elif key == "ipAllocationMethod":
            suggest = "ip_allocation_method"
        elif key == "macAddress":
            suggest = "mac_address"
        elif key == "defaultGateway":
            suggest = "default_gateway"
        elif key == "ipv4Address":
            suggest = "ipv4_address"
        elif key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "networkAttachmentName":
            suggest = "network_attachment_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkAttachmentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkAttachmentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkAttachmentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attached_network_id: _builtins.str,
                 ip_allocation_method: _builtins.str,
                 mac_address: _builtins.str,
                 default_gateway: Optional[_builtins.str] = None,
                 ipv4_address: Optional[_builtins.str] = None,
                 ipv6_address: Optional[_builtins.str] = None,
                 network_attachment_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str attached_network_id: The resource ID of the associated network attached to the virtual machine.
               It can be one of cloudServicesNetwork, l3Network, l2Network or trunkedNetwork resources.
        :param _builtins.str ip_allocation_method: The IP allocation mechanism for the virtual machine.
               Dynamic and Static are only valid for l3Network which may also specify Disabled.
               Otherwise, Disabled is the only permitted value.
        :param _builtins.str mac_address: The MAC address of the interface for the virtual machine that corresponds to this network attachment.
        :param _builtins.str default_gateway: The indicator of whether this is the default gateway.
               Only one of the attached networks (including the CloudServicesNetwork attachment) for a single machine may be specified as True.
        :param _builtins.str ipv4_address: The IPv4 address of the virtual machine.
               
               This field is used only if the attached network has IPAllocationType of IPV4 or DualStack.
               
               If IPAllocationMethod is:
               Static - this field must contain a user specified IPv4 address from within the subnet specified in the attached network.
               Dynamic - this field is read-only, but will be populated with an address from within the subnet specified in the attached network.
               Disabled - this field will be empty.
        :param _builtins.str ipv6_address: The IPv6 address of the virtual machine.
               
               This field is used only if the attached network has IPAllocationType of IPV6 or DualStack.
               
               If IPAllocationMethod is:
               Static - this field must contain an IPv6 address range from within the range specified in the attached network.
               Dynamic - this field is read-only, but will be populated with an range from within the subnet specified in the attached network.
               Disabled - this field will be empty.
        :param _builtins.str network_attachment_name: The associated network's interface name.
               If specified, the network attachment name has a maximum length of 15 characters and must be unique to this virtual machine.
               If the user doesn’t specify this value, the default interface name of the network resource will be used.
               For a CloudServicesNetwork resource, this name will be ignored.
        """
        pulumi.set(__self__, "attached_network_id", attached_network_id)
        pulumi.set(__self__, "ip_allocation_method", ip_allocation_method)
        pulumi.set(__self__, "mac_address", mac_address)
        if default_gateway is not None:
            pulumi.set(__self__, "default_gateway", default_gateway)
        if ipv4_address is not None:
            pulumi.set(__self__, "ipv4_address", ipv4_address)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if network_attachment_name is not None:
            pulumi.set(__self__, "network_attachment_name", network_attachment_name)

    @_builtins.property
    @pulumi.getter(name="attachedNetworkId")
    def attached_network_id(self) -> _builtins.str:
        """
        The resource ID of the associated network attached to the virtual machine.
        It can be one of cloudServicesNetwork, l3Network, l2Network or trunkedNetwork resources.
        """
        return pulumi.get(self, "attached_network_id")

    @_builtins.property
    @pulumi.getter(name="ipAllocationMethod")
    def ip_allocation_method(self) -> _builtins.str:
        """
        The IP allocation mechanism for the virtual machine.
        Dynamic and Static are only valid for l3Network which may also specify Disabled.
        Otherwise, Disabled is the only permitted value.
        """
        return pulumi.get(self, "ip_allocation_method")

    @_builtins.property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> _builtins.str:
        """
        The MAC address of the interface for the virtual machine that corresponds to this network attachment.
        """
        return pulumi.get(self, "mac_address")

    @_builtins.property
    @pulumi.getter(name="defaultGateway")
    def default_gateway(self) -> Optional[_builtins.str]:
        """
        The indicator of whether this is the default gateway.
        Only one of the attached networks (including the CloudServicesNetwork attachment) for a single machine may be specified as True.
        """
        return pulumi.get(self, "default_gateway")

    @_builtins.property
    @pulumi.getter(name="ipv4Address")
    def ipv4_address(self) -> Optional[_builtins.str]:
        """
        The IPv4 address of the virtual machine.

        This field is used only if the attached network has IPAllocationType of IPV4 or DualStack.

        If IPAllocationMethod is:
        Static - this field must contain a user specified IPv4 address from within the subnet specified in the attached network.
        Dynamic - this field is read-only, but will be populated with an address from within the subnet specified in the attached network.
        Disabled - this field will be empty.
        """
        return pulumi.get(self, "ipv4_address")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[_builtins.str]:
        """
        The IPv6 address of the virtual machine.

        This field is used only if the attached network has IPAllocationType of IPV6 or DualStack.

        If IPAllocationMethod is:
        Static - this field must contain an IPv6 address range from within the range specified in the attached network.
        Dynamic - this field is read-only, but will be populated with an range from within the subnet specified in the attached network.
        Disabled - this field will be empty.
        """
        return pulumi.get(self, "ipv6_address")

    @_builtins.property
    @pulumi.getter(name="networkAttachmentName")
    def network_attachment_name(self) -> Optional[_builtins.str]:
        """
        The associated network's interface name.
        If specified, the network attachment name has a maximum length of 15 characters and must be unique to this virtual machine.
        If the user doesn’t specify this value, the default interface name of the network resource will be used.
        For a CloudServicesNetwork resource, this name will be ignored.
        """
        return pulumi.get(self, "network_attachment_name")


@pulumi.output_type
class NetworkConfigurationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudServicesNetworkId":
            suggest = "cloud_services_network_id"
        elif key == "cniNetworkId":
            suggest = "cni_network_id"
        elif key == "attachedNetworkConfiguration":
            suggest = "attached_network_configuration"
        elif key == "bgpServiceLoadBalancerConfiguration":
            suggest = "bgp_service_load_balancer_configuration"
        elif key == "dnsServiceIp":
            suggest = "dns_service_ip"
        elif key == "l2ServiceLoadBalancerConfiguration":
            suggest = "l2_service_load_balancer_configuration"
        elif key == "podCidrs":
            suggest = "pod_cidrs"
        elif key == "serviceCidrs":
            suggest = "service_cidrs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_services_network_id: _builtins.str,
                 cni_network_id: _builtins.str,
                 attached_network_configuration: Optional['outputs.AttachedNetworkConfigurationResponse'] = None,
                 bgp_service_load_balancer_configuration: Optional['outputs.BgpServiceLoadBalancerConfigurationResponse'] = None,
                 dns_service_ip: Optional[_builtins.str] = None,
                 l2_service_load_balancer_configuration: Optional['outputs.L2ServiceLoadBalancerConfigurationResponse'] = None,
                 pod_cidrs: Optional[Sequence[_builtins.str]] = None,
                 service_cidrs: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str cloud_services_network_id: The resource ID of the associated Cloud Services network.
        :param _builtins.str cni_network_id: The resource ID of the Layer 3 network that is used for creation of the Container Networking Interface network.
        :param 'AttachedNetworkConfigurationResponse' attached_network_configuration: The configuration of networks being attached to the cluster for use by the workloads that run on this Kubernetes cluster.
        :param 'BgpServiceLoadBalancerConfigurationResponse' bgp_service_load_balancer_configuration: The configuration of the BGP service load balancer for this Kubernetes cluster. A maximum of one service load balancer may be specified, either Layer 2 or BGP.
        :param _builtins.str dns_service_ip: The IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range specified in service CIDR.
        :param 'L2ServiceLoadBalancerConfigurationResponse' l2_service_load_balancer_configuration: The configuration of the Layer 2 service load balancer for this Kubernetes cluster. A maximum of one service load balancer may be specified, either Layer 2 or BGP.
        :param Sequence[_builtins.str] pod_cidrs: The CIDR notation IP ranges from which to assign pod IPs. One IPv4 CIDR is expected for single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack networking.
        :param Sequence[_builtins.str] service_cidrs: The CIDR notation IP ranges from which to assign service IPs. One IPv4 CIDR is expected for single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack networking.
        """
        pulumi.set(__self__, "cloud_services_network_id", cloud_services_network_id)
        pulumi.set(__self__, "cni_network_id", cni_network_id)
        if attached_network_configuration is not None:
            pulumi.set(__self__, "attached_network_configuration", attached_network_configuration)
        if bgp_service_load_balancer_configuration is not None:
            pulumi.set(__self__, "bgp_service_load_balancer_configuration", bgp_service_load_balancer_configuration)
        if dns_service_ip is not None:
            pulumi.set(__self__, "dns_service_ip", dns_service_ip)
        if l2_service_load_balancer_configuration is not None:
            pulumi.set(__self__, "l2_service_load_balancer_configuration", l2_service_load_balancer_configuration)
        if pod_cidrs is not None:
            pulumi.set(__self__, "pod_cidrs", pod_cidrs)
        if service_cidrs is not None:
            pulumi.set(__self__, "service_cidrs", service_cidrs)

    @_builtins.property
    @pulumi.getter(name="cloudServicesNetworkId")
    def cloud_services_network_id(self) -> _builtins.str:
        """
        The resource ID of the associated Cloud Services network.
        """
        return pulumi.get(self, "cloud_services_network_id")

    @_builtins.property
    @pulumi.getter(name="cniNetworkId")
    def cni_network_id(self) -> _builtins.str:
        """
        The resource ID of the Layer 3 network that is used for creation of the Container Networking Interface network.
        """
        return pulumi.get(self, "cni_network_id")

    @_builtins.property
    @pulumi.getter(name="attachedNetworkConfiguration")
    def attached_network_configuration(self) -> Optional['outputs.AttachedNetworkConfigurationResponse']:
        """
        The configuration of networks being attached to the cluster for use by the workloads that run on this Kubernetes cluster.
        """
        return pulumi.get(self, "attached_network_configuration")

    @_builtins.property
    @pulumi.getter(name="bgpServiceLoadBalancerConfiguration")
    def bgp_service_load_balancer_configuration(self) -> Optional['outputs.BgpServiceLoadBalancerConfigurationResponse']:
        """
        The configuration of the BGP service load balancer for this Kubernetes cluster. A maximum of one service load balancer may be specified, either Layer 2 or BGP.
        """
        return pulumi.get(self, "bgp_service_load_balancer_configuration")

    @_builtins.property
    @pulumi.getter(name="dnsServiceIp")
    def dns_service_ip(self) -> Optional[_builtins.str]:
        """
        The IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range specified in service CIDR.
        """
        return pulumi.get(self, "dns_service_ip")

    @_builtins.property
    @pulumi.getter(name="l2ServiceLoadBalancerConfiguration")
    def l2_service_load_balancer_configuration(self) -> Optional['outputs.L2ServiceLoadBalancerConfigurationResponse']:
        """
        The configuration of the Layer 2 service load balancer for this Kubernetes cluster. A maximum of one service load balancer may be specified, either Layer 2 or BGP.
        """
        return pulumi.get(self, "l2_service_load_balancer_configuration")

    @_builtins.property
    @pulumi.getter(name="podCidrs")
    def pod_cidrs(self) -> Optional[Sequence[_builtins.str]]:
        """
        The CIDR notation IP ranges from which to assign pod IPs. One IPv4 CIDR is expected for single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack networking.
        """
        return pulumi.get(self, "pod_cidrs")

    @_builtins.property
    @pulumi.getter(name="serviceCidrs")
    def service_cidrs(self) -> Optional[Sequence[_builtins.str]]:
        """
        The CIDR notation IP ranges from which to assign service IPs. One IPv4 CIDR is expected for single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack networking.
        """
        return pulumi.get(self, "service_cidrs")


@pulumi.output_type
class NicResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lldpNeighbor":
            suggest = "lldp_neighbor"
        elif key == "macAddress":
            suggest = "mac_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NicResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NicResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NicResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lldp_neighbor: 'outputs.LldpNeighborResponse',
                 mac_address: _builtins.str,
                 name: _builtins.str):
        """
        :param 'LldpNeighborResponse' lldp_neighbor: The information about the device connected to this NIC.
        :param _builtins.str mac_address: The MAC address associated with this NIC.
        :param _builtins.str name: The name of the NIC/interface.
        """
        pulumi.set(__self__, "lldp_neighbor", lldp_neighbor)
        pulumi.set(__self__, "mac_address", mac_address)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="lldpNeighbor")
    def lldp_neighbor(self) -> 'outputs.LldpNeighborResponse':
        """
        The information about the device connected to this NIC.
        """
        return pulumi.get(self, "lldp_neighbor")

    @_builtins.property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> _builtins.str:
        """
        The MAC address associated with this NIC.
        """
        return pulumi.get(self, "mac_address")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the NIC/interface.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class OsDiskResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSizeGB":
            suggest = "disk_size_gb"
        elif key == "createOption":
            suggest = "create_option"
        elif key == "deleteOption":
            suggest = "delete_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OsDiskResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OsDiskResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OsDiskResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size_gb: _builtins.float,
                 create_option: Optional[_builtins.str] = None,
                 delete_option: Optional[_builtins.str] = None):
        """
        :param _builtins.float disk_size_gb: The size of the disk. Required if the createOption is Ephemeral. Allocations are measured in gibibytes.
        :param _builtins.str create_option: The strategy for creating the OS disk.
        :param _builtins.str delete_option: The strategy for deleting the OS disk.
        """
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if create_option is None:
            create_option = 'Ephemeral'
        if create_option is not None:
            pulumi.set(__self__, "create_option", create_option)
        if delete_option is None:
            delete_option = 'Delete'
        if delete_option is not None:
            pulumi.set(__self__, "delete_option", delete_option)

    @_builtins.property
    @pulumi.getter(name="diskSizeGB")
    def disk_size_gb(self) -> _builtins.float:
        """
        The size of the disk. Required if the createOption is Ephemeral. Allocations are measured in gibibytes.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="createOption")
    def create_option(self) -> Optional[_builtins.str]:
        """
        The strategy for creating the OS disk.
        """
        return pulumi.get(self, "create_option")

    @_builtins.property
    @pulumi.getter(name="deleteOption")
    def delete_option(self) -> Optional[_builtins.str]:
        """
        The strategy for deleting the OS disk.
        """
        return pulumi.get(self, "delete_option")


@pulumi.output_type
class RackDefinitionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkRackId":
            suggest = "network_rack_id"
        elif key == "rackSerialNumber":
            suggest = "rack_serial_number"
        elif key == "rackSkuId":
            suggest = "rack_sku_id"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "bareMetalMachineConfigurationData":
            suggest = "bare_metal_machine_configuration_data"
        elif key == "rackLocation":
            suggest = "rack_location"
        elif key == "storageApplianceConfigurationData":
            suggest = "storage_appliance_configuration_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RackDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RackDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RackDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_rack_id: _builtins.str,
                 rack_serial_number: _builtins.str,
                 rack_sku_id: _builtins.str,
                 availability_zone: Optional[_builtins.str] = None,
                 bare_metal_machine_configuration_data: Optional[Sequence['outputs.BareMetalMachineConfigurationDataResponse']] = None,
                 rack_location: Optional[_builtins.str] = None,
                 storage_appliance_configuration_data: Optional[Sequence['outputs.StorageApplianceConfigurationDataResponse']] = None):
        """
        :param _builtins.str network_rack_id: The resource ID of the network rack that matches this rack definition.
        :param _builtins.str rack_serial_number: The unique identifier for the rack within Network Cloud cluster. An alternate unique alphanumeric value other than a serial number may be provided if desired.
        :param _builtins.str rack_sku_id: The resource ID of the sku for the rack being added.
        :param _builtins.str availability_zone: The zone name used for this rack when created. Availability zones are used for workload placement.
        :param Sequence['BareMetalMachineConfigurationDataResponse'] bare_metal_machine_configuration_data: The unordered list of bare metal machine configuration.
        :param _builtins.str rack_location: The free-form description of the rack's location.
        :param Sequence['StorageApplianceConfigurationDataResponse'] storage_appliance_configuration_data: The list of storage appliance configuration data for this rack.
        """
        pulumi.set(__self__, "network_rack_id", network_rack_id)
        pulumi.set(__self__, "rack_serial_number", rack_serial_number)
        pulumi.set(__self__, "rack_sku_id", rack_sku_id)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if bare_metal_machine_configuration_data is not None:
            pulumi.set(__self__, "bare_metal_machine_configuration_data", bare_metal_machine_configuration_data)
        if rack_location is not None:
            pulumi.set(__self__, "rack_location", rack_location)
        if storage_appliance_configuration_data is not None:
            pulumi.set(__self__, "storage_appliance_configuration_data", storage_appliance_configuration_data)

    @_builtins.property
    @pulumi.getter(name="networkRackId")
    def network_rack_id(self) -> _builtins.str:
        """
        The resource ID of the network rack that matches this rack definition.
        """
        return pulumi.get(self, "network_rack_id")

    @_builtins.property
    @pulumi.getter(name="rackSerialNumber")
    def rack_serial_number(self) -> _builtins.str:
        """
        The unique identifier for the rack within Network Cloud cluster. An alternate unique alphanumeric value other than a serial number may be provided if desired.
        """
        return pulumi.get(self, "rack_serial_number")

    @_builtins.property
    @pulumi.getter(name="rackSkuId")
    def rack_sku_id(self) -> _builtins.str:
        """
        The resource ID of the sku for the rack being added.
        """
        return pulumi.get(self, "rack_sku_id")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        """
        The zone name used for this rack when created. Availability zones are used for workload placement.
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="bareMetalMachineConfigurationData")
    def bare_metal_machine_configuration_data(self) -> Optional[Sequence['outputs.BareMetalMachineConfigurationDataResponse']]:
        """
        The unordered list of bare metal machine configuration.
        """
        return pulumi.get(self, "bare_metal_machine_configuration_data")

    @_builtins.property
    @pulumi.getter(name="rackLocation")
    def rack_location(self) -> Optional[_builtins.str]:
        """
        The free-form description of the rack's location.
        """
        return pulumi.get(self, "rack_location")

    @_builtins.property
    @pulumi.getter(name="storageApplianceConfigurationData")
    def storage_appliance_configuration_data(self) -> Optional[Sequence['outputs.StorageApplianceConfigurationDataResponse']]:
        """
        The list of storage appliance configuration data for this rack.
        """
        return pulumi.get(self, "storage_appliance_configuration_data")


@pulumi.output_type
class RuntimeProtectionConfigurationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enforcementLevel":
            suggest = "enforcement_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuntimeProtectionConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuntimeProtectionConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuntimeProtectionConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enforcement_level: Optional[_builtins.str] = None):
        """
        :param _builtins.str enforcement_level: The mode of operation for runtime protection.
        """
        if enforcement_level is None:
            enforcement_level = 'Disabled'
        if enforcement_level is not None:
            pulumi.set(__self__, "enforcement_level", enforcement_level)

    @_builtins.property
    @pulumi.getter(name="enforcementLevel")
    def enforcement_level(self) -> Optional[_builtins.str]:
        """
        The mode of operation for runtime protection.
        """
        return pulumi.get(self, "enforcement_level")


@pulumi.output_type
class RuntimeProtectionStatusResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "definitionsLastUpdated":
            suggest = "definitions_last_updated"
        elif key == "definitionsVersion":
            suggest = "definitions_version"
        elif key == "scanCompletedTime":
            suggest = "scan_completed_time"
        elif key == "scanScheduledTime":
            suggest = "scan_scheduled_time"
        elif key == "scanStartedTime":
            suggest = "scan_started_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuntimeProtectionStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuntimeProtectionStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuntimeProtectionStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definitions_last_updated: _builtins.str,
                 definitions_version: _builtins.str,
                 scan_completed_time: _builtins.str,
                 scan_scheduled_time: _builtins.str,
                 scan_started_time: _builtins.str):
        """
        :param _builtins.str definitions_last_updated: The timestamp when the malware definitions were last updated.
        :param _builtins.str definitions_version: The version of the malware definitions.
        :param _builtins.str scan_completed_time: The timestamp of the most recently completed scan, or empty if there has never been a scan.
        :param _builtins.str scan_scheduled_time: The timestamp of the most recently scheduled scan, or empty if no scan has been scheduled.
        :param _builtins.str scan_started_time: The timestamp of the most recently started scan, or empty if there has never been a scan.
        """
        pulumi.set(__self__, "definitions_last_updated", definitions_last_updated)
        pulumi.set(__self__, "definitions_version", definitions_version)
        pulumi.set(__self__, "scan_completed_time", scan_completed_time)
        pulumi.set(__self__, "scan_scheduled_time", scan_scheduled_time)
        pulumi.set(__self__, "scan_started_time", scan_started_time)

    @_builtins.property
    @pulumi.getter(name="definitionsLastUpdated")
    def definitions_last_updated(self) -> _builtins.str:
        """
        The timestamp when the malware definitions were last updated.
        """
        return pulumi.get(self, "definitions_last_updated")

    @_builtins.property
    @pulumi.getter(name="definitionsVersion")
    def definitions_version(self) -> _builtins.str:
        """
        The version of the malware definitions.
        """
        return pulumi.get(self, "definitions_version")

    @_builtins.property
    @pulumi.getter(name="scanCompletedTime")
    def scan_completed_time(self) -> _builtins.str:
        """
        The timestamp of the most recently completed scan, or empty if there has never been a scan.
        """
        return pulumi.get(self, "scan_completed_time")

    @_builtins.property
    @pulumi.getter(name="scanScheduledTime")
    def scan_scheduled_time(self) -> _builtins.str:
        """
        The timestamp of the most recently scheduled scan, or empty if no scan has been scheduled.
        """
        return pulumi.get(self, "scan_scheduled_time")

    @_builtins.property
    @pulumi.getter(name="scanStartedTime")
    def scan_started_time(self) -> _builtins.str:
        """
        The timestamp of the most recently started scan, or empty if there has never been a scan.
        """
        return pulumi.get(self, "scan_started_time")


@pulumi.output_type
class SecretArchiveReferenceResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultId":
            suggest = "key_vault_id"
        elif key == "secretName":
            suggest = "secret_name"
        elif key == "secretVersion":
            suggest = "secret_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretArchiveReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretArchiveReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretArchiveReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_id: _builtins.str,
                 secret_name: _builtins.str,
                 secret_version: _builtins.str):
        """
        :param _builtins.str key_vault_id: The resource ID of the key vault containing the secret.
        :param _builtins.str secret_name: The name of the secret in the key vault.
        :param _builtins.str secret_version: The version of the secret in the key vault.
        """
        pulumi.set(__self__, "key_vault_id", key_vault_id)
        pulumi.set(__self__, "secret_name", secret_name)
        pulumi.set(__self__, "secret_version", secret_version)

    @_builtins.property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> _builtins.str:
        """
        The resource ID of the key vault containing the secret.
        """
        return pulumi.get(self, "key_vault_id")

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> _builtins.str:
        """
        The name of the secret in the key vault.
        """
        return pulumi.get(self, "secret_name")

    @_builtins.property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> _builtins.str:
        """
        The version of the secret in the key vault.
        """
        return pulumi.get(self, "secret_version")


@pulumi.output_type
class SecretArchiveSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associatedIdentity":
            suggest = "associated_identity"
        elif key == "vaultUri":
            suggest = "vault_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretArchiveSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretArchiveSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretArchiveSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associated_identity: Optional['outputs.IdentitySelectorResponse'] = None,
                 vault_uri: Optional[_builtins.str] = None):
        """
        :param 'IdentitySelectorResponse' associated_identity: The selection of the managed identity to use with this vault URI. The identity type must be either system assigned or user assigned.
        :param _builtins.str vault_uri: The URI for the key vault used as the secret archive.
        """
        if associated_identity is not None:
            pulumi.set(__self__, "associated_identity", associated_identity)
        if vault_uri is not None:
            pulumi.set(__self__, "vault_uri", vault_uri)

    @_builtins.property
    @pulumi.getter(name="associatedIdentity")
    def associated_identity(self) -> Optional['outputs.IdentitySelectorResponse']:
        """
        The selection of the managed identity to use with this vault URI. The identity type must be either system assigned or user assigned.
        """
        return pulumi.get(self, "associated_identity")

    @_builtins.property
    @pulumi.getter(name="vaultUri")
    def vault_uri(self) -> Optional[_builtins.str]:
        """
        The URI for the key vault used as the secret archive.
        """
        return pulumi.get(self, "vault_uri")


@pulumi.output_type
class SecretRotationStatusResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expirePeriodDays":
            suggest = "expire_period_days"
        elif key == "lastRotationTime":
            suggest = "last_rotation_time"
        elif key == "rotationPeriodDays":
            suggest = "rotation_period_days"
        elif key == "secretArchiveReference":
            suggest = "secret_archive_reference"
        elif key == "secretType":
            suggest = "secret_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretRotationStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretRotationStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretRotationStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expire_period_days: _builtins.float,
                 last_rotation_time: _builtins.str,
                 rotation_period_days: _builtins.float,
                 secret_archive_reference: 'outputs.SecretArchiveReferenceResponse',
                 secret_type: _builtins.str):
        """
        :param _builtins.float expire_period_days: The maximum number of days the secret may be used before it must be changed.
        :param _builtins.str last_rotation_time: The date and time when the secret was last changed.
        :param _builtins.float rotation_period_days: The number of days a secret exists before rotations will be attempted.
        :param 'SecretArchiveReferenceResponse' secret_archive_reference: The reference to the secret in a key vault.
        :param _builtins.str secret_type: The type name used to identify the purpose of the secret.
        """
        pulumi.set(__self__, "expire_period_days", expire_period_days)
        pulumi.set(__self__, "last_rotation_time", last_rotation_time)
        pulumi.set(__self__, "rotation_period_days", rotation_period_days)
        pulumi.set(__self__, "secret_archive_reference", secret_archive_reference)
        pulumi.set(__self__, "secret_type", secret_type)

    @_builtins.property
    @pulumi.getter(name="expirePeriodDays")
    def expire_period_days(self) -> _builtins.float:
        """
        The maximum number of days the secret may be used before it must be changed.
        """
        return pulumi.get(self, "expire_period_days")

    @_builtins.property
    @pulumi.getter(name="lastRotationTime")
    def last_rotation_time(self) -> _builtins.str:
        """
        The date and time when the secret was last changed.
        """
        return pulumi.get(self, "last_rotation_time")

    @_builtins.property
    @pulumi.getter(name="rotationPeriodDays")
    def rotation_period_days(self) -> _builtins.float:
        """
        The number of days a secret exists before rotations will be attempted.
        """
        return pulumi.get(self, "rotation_period_days")

    @_builtins.property
    @pulumi.getter(name="secretArchiveReference")
    def secret_archive_reference(self) -> 'outputs.SecretArchiveReferenceResponse':
        """
        The reference to the secret in a key vault.
        """
        return pulumi.get(self, "secret_archive_reference")

    @_builtins.property
    @pulumi.getter(name="secretType")
    def secret_type(self) -> _builtins.str:
        """
        The type name used to identify the purpose of the secret.
        """
        return pulumi.get(self, "secret_type")


@pulumi.output_type
class ServiceLoadBalancerBgpPeerResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "peerAddress":
            suggest = "peer_address"
        elif key == "peerAsn":
            suggest = "peer_asn"
        elif key == "bfdEnabled":
            suggest = "bfd_enabled"
        elif key == "bgpMultiHop":
            suggest = "bgp_multi_hop"
        elif key == "holdTime":
            suggest = "hold_time"
        elif key == "keepAliveTime":
            suggest = "keep_alive_time"
        elif key == "myAsn":
            suggest = "my_asn"
        elif key == "peerPort":
            suggest = "peer_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceLoadBalancerBgpPeerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceLoadBalancerBgpPeerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceLoadBalancerBgpPeerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 peer_address: _builtins.str,
                 peer_asn: _builtins.float,
                 bfd_enabled: Optional[_builtins.str] = None,
                 bgp_multi_hop: Optional[_builtins.str] = None,
                 hold_time: Optional[_builtins.str] = None,
                 keep_alive_time: Optional[_builtins.str] = None,
                 my_asn: Optional[_builtins.float] = None,
                 peer_port: Optional[_builtins.float] = None):
        """
        :param _builtins.str name: The name used to identify this BGP peer for association with a BGP advertisement.
        :param _builtins.str peer_address: The IPv4 or IPv6 address used to connect this BGP session.
        :param _builtins.float peer_asn: The autonomous system number expected from the remote end of the BGP session.
        :param _builtins.str bfd_enabled: The indicator of BFD enablement for this BgpPeer.
        :param _builtins.str bgp_multi_hop: The indicator to enable multi-hop peering support.
        :param _builtins.str hold_time: Field Deprecated. The field was previously optional, now it will have no defined behavior and will be ignored. The requested BGP hold time value. This field uses ISO 8601 duration format, for example P1H.
        :param _builtins.str keep_alive_time: Field Deprecated. The field was previously optional, now it will have no defined behavior and will be ignored. The requested BGP keepalive time value. This field uses ISO 8601 duration format, for example P1H.
        :param _builtins.float my_asn: The autonomous system number used for the local end of the BGP session.
        :param _builtins.float peer_port: The port used to connect this BGP session.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "peer_address", peer_address)
        pulumi.set(__self__, "peer_asn", peer_asn)
        if bfd_enabled is None:
            bfd_enabled = 'False'
        if bfd_enabled is not None:
            pulumi.set(__self__, "bfd_enabled", bfd_enabled)
        if bgp_multi_hop is None:
            bgp_multi_hop = 'False'
        if bgp_multi_hop is not None:
            pulumi.set(__self__, "bgp_multi_hop", bgp_multi_hop)
        if hold_time is not None:
            pulumi.set(__self__, "hold_time", hold_time)
        if keep_alive_time is not None:
            pulumi.set(__self__, "keep_alive_time", keep_alive_time)
        if my_asn is not None:
            pulumi.set(__self__, "my_asn", my_asn)
        if peer_port is None:
            peer_port = 179
        if peer_port is not None:
            pulumi.set(__self__, "peer_port", peer_port)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name used to identify this BGP peer for association with a BGP advertisement.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="peerAddress")
    def peer_address(self) -> _builtins.str:
        """
        The IPv4 or IPv6 address used to connect this BGP session.
        """
        return pulumi.get(self, "peer_address")

    @_builtins.property
    @pulumi.getter(name="peerAsn")
    def peer_asn(self) -> _builtins.float:
        """
        The autonomous system number expected from the remote end of the BGP session.
        """
        return pulumi.get(self, "peer_asn")

    @_builtins.property
    @pulumi.getter(name="bfdEnabled")
    def bfd_enabled(self) -> Optional[_builtins.str]:
        """
        The indicator of BFD enablement for this BgpPeer.
        """
        return pulumi.get(self, "bfd_enabled")

    @_builtins.property
    @pulumi.getter(name="bgpMultiHop")
    def bgp_multi_hop(self) -> Optional[_builtins.str]:
        """
        The indicator to enable multi-hop peering support.
        """
        return pulumi.get(self, "bgp_multi_hop")

    @_builtins.property
    @pulumi.getter(name="holdTime")
    def hold_time(self) -> Optional[_builtins.str]:
        """
        Field Deprecated. The field was previously optional, now it will have no defined behavior and will be ignored. The requested BGP hold time value. This field uses ISO 8601 duration format, for example P1H.
        """
        return pulumi.get(self, "hold_time")

    @_builtins.property
    @pulumi.getter(name="keepAliveTime")
    def keep_alive_time(self) -> Optional[_builtins.str]:
        """
        Field Deprecated. The field was previously optional, now it will have no defined behavior and will be ignored. The requested BGP keepalive time value. This field uses ISO 8601 duration format, for example P1H.
        """
        return pulumi.get(self, "keep_alive_time")

    @_builtins.property
    @pulumi.getter(name="myAsn")
    def my_asn(self) -> Optional[_builtins.float]:
        """
        The autonomous system number used for the local end of the BGP session.
        """
        return pulumi.get(self, "my_asn")

    @_builtins.property
    @pulumi.getter(name="peerPort")
    def peer_port(self) -> Optional[_builtins.float]:
        """
        The port used to connect this BGP session.
        """
        return pulumi.get(self, "peer_port")


@pulumi.output_type
class ServicePrincipalInformationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicePrincipalInformationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicePrincipalInformationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicePrincipalInformationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: _builtins.str,
                 password: _builtins.str,
                 principal_id: _builtins.str,
                 tenant_id: _builtins.str):
        """
        :param _builtins.str application_id: The application ID, also known as client ID, of the service principal.
        :param _builtins.str password: The password of the service principal.
        :param _builtins.str principal_id: The principal ID, also known as the object ID, of the service principal.
        :param _builtins.str tenant_id: The tenant ID, also known as the directory ID, of the tenant in which the service principal is created.
        """
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> _builtins.str:
        """
        The application ID, also known as client ID, of the service principal.
        """
        return pulumi.get(self, "application_id")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The password of the service principal.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The principal ID, also known as the object ID, of the service principal.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The tenant ID, also known as the directory ID, of the tenant in which the service principal is created.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class SshPublicKeyResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyData":
            suggest = "key_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SshPublicKeyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SshPublicKeyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SshPublicKeyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_data: _builtins.str):
        """
        :param _builtins.str key_data: The SSH public key data.
        """
        pulumi.set(__self__, "key_data", key_data)

    @_builtins.property
    @pulumi.getter(name="keyData")
    def key_data(self) -> _builtins.str:
        """
        The SSH public key data.
        """
        return pulumi.get(self, "key_data")


@pulumi.output_type
class StorageApplianceConfigurationDataResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminCredentials":
            suggest = "admin_credentials"
        elif key == "rackSlot":
            suggest = "rack_slot"
        elif key == "serialNumber":
            suggest = "serial_number"
        elif key == "storageApplianceName":
            suggest = "storage_appliance_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageApplianceConfigurationDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageApplianceConfigurationDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageApplianceConfigurationDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_credentials: 'outputs.AdministrativeCredentialsResponse',
                 rack_slot: _builtins.float,
                 serial_number: _builtins.str,
                 storage_appliance_name: Optional[_builtins.str] = None):
        """
        :param 'AdministrativeCredentialsResponse' admin_credentials: The credentials of the administrative interface on this storage appliance. The password field is expected to be an Azure Key Vault key URL. Until the cluster is converted to utilize managed identity by setting the secret archive settings, the actual password value should be provided instead.
        :param _builtins.float rack_slot: The slot that storage appliance is in the rack based on the BOM configuration.
        :param _builtins.str serial_number: The serial number of the appliance.
        :param _builtins.str storage_appliance_name: The user-provided name for the storage appliance that will be created from this specification.
        """
        pulumi.set(__self__, "admin_credentials", admin_credentials)
        pulumi.set(__self__, "rack_slot", rack_slot)
        pulumi.set(__self__, "serial_number", serial_number)
        if storage_appliance_name is not None:
            pulumi.set(__self__, "storage_appliance_name", storage_appliance_name)

    @_builtins.property
    @pulumi.getter(name="adminCredentials")
    def admin_credentials(self) -> 'outputs.AdministrativeCredentialsResponse':
        """
        The credentials of the administrative interface on this storage appliance. The password field is expected to be an Azure Key Vault key URL. Until the cluster is converted to utilize managed identity by setting the secret archive settings, the actual password value should be provided instead.
        """
        return pulumi.get(self, "admin_credentials")

    @_builtins.property
    @pulumi.getter(name="rackSlot")
    def rack_slot(self) -> _builtins.float:
        """
        The slot that storage appliance is in the rack based on the BOM configuration.
        """
        return pulumi.get(self, "rack_slot")

    @_builtins.property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> _builtins.str:
        """
        The serial number of the appliance.
        """
        return pulumi.get(self, "serial_number")

    @_builtins.property
    @pulumi.getter(name="storageApplianceName")
    def storage_appliance_name(self) -> Optional[_builtins.str]:
        """
        The user-provided name for the storage appliance that will be created from this specification.
        """
        return pulumi.get(self, "storage_appliance_name")


@pulumi.output_type
class StorageProfileResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "osDisk":
            suggest = "os_disk"
        elif key == "volumeAttachments":
            suggest = "volume_attachments"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 os_disk: 'outputs.OsDiskResponse',
                 volume_attachments: Optional[Sequence[_builtins.str]] = None):
        """
        :param 'OsDiskResponse' os_disk: The disk to use with this virtual machine.
        :param Sequence[_builtins.str] volume_attachments: The resource IDs of volumes that are requested to be attached to the virtual machine.
        """
        pulumi.set(__self__, "os_disk", os_disk)
        if volume_attachments is not None:
            pulumi.set(__self__, "volume_attachments", volume_attachments)

    @_builtins.property
    @pulumi.getter(name="osDisk")
    def os_disk(self) -> 'outputs.OsDiskResponse':
        """
        The disk to use with this virtual machine.
        """
        return pulumi.get(self, "os_disk")

    @_builtins.property
    @pulumi.getter(name="volumeAttachments")
    def volume_attachments(self) -> Optional[Sequence[_builtins.str]]:
        """
        The resource IDs of volumes that are requested to be attached to the virtual machine.
        """
        return pulumi.get(self, "volume_attachments")


@pulumi.output_type
class StringKeyValuePairResponse(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The key to the mapped value.
        :param _builtins.str value: The value of the mapping key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key to the mapped value.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the mapping key.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 created_by_type: Optional[_builtins.str] = None,
                 last_modified_at: Optional[_builtins.str] = None,
                 last_modified_by: Optional[_builtins.str] = None,
                 last_modified_by_type: Optional[_builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param _builtins.str created_at: The timestamp of resource creation (UTC).
        :param _builtins.str created_by: The identity that created the resource.
        :param _builtins.str created_by_type: The type of identity that created the resource.
        :param _builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param _builtins.str last_modified_by: The identity that last modified the resource.
        :param _builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @_builtins.property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @_builtins.property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[_builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @_builtins.property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TrunkedNetworkAttachmentConfigurationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "pluginType":
            suggest = "plugin_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrunkedNetworkAttachmentConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrunkedNetworkAttachmentConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrunkedNetworkAttachmentConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: _builtins.str,
                 plugin_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str network_id: The resource ID of the network that is being configured for attachment.
        :param _builtins.str plugin_type: The indicator of how this network will be utilized by the Kubernetes cluster.
        """
        pulumi.set(__self__, "network_id", network_id)
        if plugin_type is None:
            plugin_type = 'SRIOV'
        if plugin_type is not None:
            pulumi.set(__self__, "plugin_type", plugin_type)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        """
        The resource ID of the network that is being configured for attachment.
        """
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter(name="pluginType")
    def plugin_type(self) -> Optional[_builtins.str]:
        """
        The indicator of how this network will be utilized by the Kubernetes cluster.
        """
        return pulumi.get(self, "plugin_type")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 principal_id: _builtins.str):
        """
        User assigned identity properties
        :param _builtins.str client_id: The client ID of the assigned identity.
        :param _builtins.str principal_id: The principal ID of the assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class ValidationThresholdResponse(dict):
    def __init__(__self__, *,
                 grouping: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.float):
        """
        :param _builtins.str grouping: Selection of how the type evaluation is applied to the cluster calculation.
        :param _builtins.str type: Selection of how the threshold should be evaluated.
        :param _builtins.float value: The numeric threshold value.
        """
        pulumi.set(__self__, "grouping", grouping)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def grouping(self) -> _builtins.str:
        """
        Selection of how the type evaluation is applied to the cluster calculation.
        """
        return pulumi.get(self, "grouping")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Selection of how the threshold should be evaluated.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        The numeric threshold value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VirtualMachinePlacementHintResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hintType":
            suggest = "hint_type"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "schedulingExecution":
            suggest = "scheduling_execution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachinePlacementHintResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachinePlacementHintResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachinePlacementHintResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hint_type: _builtins.str,
                 resource_id: _builtins.str,
                 scheduling_execution: _builtins.str,
                 scope: _builtins.str):
        """
        :param _builtins.str hint_type: The specification of whether this hint supports affinity or anti-affinity with the referenced resources.
        :param _builtins.str resource_id: The resource ID of the target object that the placement hints will be checked against, e.g., the bare metal node to host the virtual machine.
        :param _builtins.str scheduling_execution: The indicator of whether the hint is a hard or soft requirement during scheduling.
        :param _builtins.str scope: The scope for the virtual machine affinity or anti-affinity placement hint. It should always be "Machine" in the case of node affinity.
        """
        pulumi.set(__self__, "hint_type", hint_type)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "scheduling_execution", scheduling_execution)
        pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter(name="hintType")
    def hint_type(self) -> _builtins.str:
        """
        The specification of whether this hint supports affinity or anti-affinity with the referenced resources.
        """
        return pulumi.get(self, "hint_type")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        The resource ID of the target object that the placement hints will be checked against, e.g., the bare metal node to host the virtual machine.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="schedulingExecution")
    def scheduling_execution(self) -> _builtins.str:
        """
        The indicator of whether the hint is a hard or soft requirement during scheduling.
        """
        return pulumi.get(self, "scheduling_execution")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        The scope for the virtual machine affinity or anti-affinity placement hint. It should always be "Machine" in the case of node affinity.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class VulnerabilityScanningSettingsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerScan":
            suggest = "container_scan"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VulnerabilityScanningSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VulnerabilityScanningSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VulnerabilityScanningSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_scan: Optional[_builtins.str] = None):
        """
        :param _builtins.str container_scan: The mode selection for container vulnerability scanning.
        """
        if container_scan is None:
            container_scan = 'Enabled'
        if container_scan is not None:
            pulumi.set(__self__, "container_scan", container_scan)

    @_builtins.property
    @pulumi.getter(name="containerScan")
    def container_scan(self) -> Optional[_builtins.str]:
        """
        The mode selection for container vulnerability scanning.
        """
        return pulumi.get(self, "container_scan")


