# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ApprovalSettingsResponse',
    'ApproverResponse',
    'CommunityEndpointDestinationRuleResponse',
    'EnclaveAddressSpacesModelResponse',
    'EnclaveDefaultSettingsModelResponse',
    'EnclaveEndpointDestinationRuleResponse',
    'EnclaveVirtualNetworkModelResponse',
    'GovernedServiceItemResponse',
    'MaintenanceModeConfigurationModelResponse',
    'ManagedOnBehalfOfConfigurationResponse',
    'ManagedServiceIdentityResponse',
    'MandatoryApproverResponse',
    'MoboBrokerResourceResponse',
    'PrincipalResponse',
    'RequestMetadataResponse',
    'RoleAssignmentItemResponse',
    'SubnetConfigurationResponse',
    'SystemDataResponse',
    'TransitOptionParamsResponse',
    'TransitOptionResponse',
    'UserAssignedIdentityResponse',
]

@pulumi.output_type
class ApprovalSettingsResponse(dict):
    """
    ApprovalSettings Properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionCreation":
            suggest = "connection_creation"
        elif key == "connectionDeletion":
            suggest = "connection_deletion"
        elif key == "connectionUpdate":
            suggest = "connection_update"
        elif key == "enclaveCreation":
            suggest = "enclave_creation"
        elif key == "enclaveDeletion":
            suggest = "enclave_deletion"
        elif key == "endpointCreation":
            suggest = "endpoint_creation"
        elif key == "endpointDeletion":
            suggest = "endpoint_deletion"
        elif key == "endpointUpdate":
            suggest = "endpoint_update"
        elif key == "maintenanceMode":
            suggest = "maintenance_mode"
        elif key == "mandatoryApprovers":
            suggest = "mandatory_approvers"
        elif key == "minimumApproversRequired":
            suggest = "minimum_approvers_required"
        elif key == "notificationOnApprovalAction":
            suggest = "notification_on_approval_action"
        elif key == "notificationOnApprovalCreation":
            suggest = "notification_on_approval_creation"
        elif key == "notificationOnApprovalDeletion":
            suggest = "notification_on_approval_deletion"
        elif key == "serviceCatalogDeployment":
            suggest = "service_catalog_deployment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApprovalSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApprovalSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApprovalSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_creation: Optional[_builtins.str] = None,
                 connection_deletion: Optional[_builtins.str] = None,
                 connection_update: Optional[_builtins.str] = None,
                 enclave_creation: Optional[_builtins.str] = None,
                 enclave_deletion: Optional[_builtins.str] = None,
                 endpoint_creation: Optional[_builtins.str] = None,
                 endpoint_deletion: Optional[_builtins.str] = None,
                 endpoint_update: Optional[_builtins.str] = None,
                 maintenance_mode: Optional[_builtins.str] = None,
                 mandatory_approvers: Optional[Sequence['outputs.MandatoryApproverResponse']] = None,
                 minimum_approvers_required: Optional[_builtins.float] = None,
                 notification_on_approval_action: Optional[_builtins.str] = None,
                 notification_on_approval_creation: Optional[_builtins.str] = None,
                 notification_on_approval_deletion: Optional[_builtins.str] = None,
                 service_catalog_deployment: Optional[_builtins.str] = None):
        """
        ApprovalSettings Properties
        :param _builtins.str connection_creation: Approval required for enclave connection creation (Required or NotRequired).
        :param _builtins.str connection_deletion: Approval required for enclave connection deletion (Required or NotRequired).
        :param _builtins.str connection_update: Approval required for enclave connection update (Required or NotRequired).
        :param _builtins.str enclave_creation: Approval required for virtual enclave creation (Required or NotRequired).
        :param _builtins.str enclave_deletion: Approval required for virtual enclave deletion (Required or NotRequired).
        :param _builtins.str endpoint_creation: Approval required for endpoint creation (Required or NotRequired).
        :param _builtins.str endpoint_deletion: Approval required for endpoint deletion (Required or NotRequired).
        :param _builtins.str endpoint_update: Approval required for endpoint update (Required or NotRequired).
        :param _builtins.str maintenance_mode: Approval required for toggling maintenance mode (Required or NotRequired).
        :param Sequence['MandatoryApproverResponse'] mandatory_approvers: List of mandatory approvers for the approval request
        :param _builtins.float minimum_approvers_required: Minimum number of approvers required for the approval request
        :param _builtins.str notification_on_approval_action: Notification will be sent on any action taken (Approve/Reject) on an Approval Request
        :param _builtins.str notification_on_approval_creation: Notification will be sent on creation of an Approval Request
        :param _builtins.str notification_on_approval_deletion: Notification will be sent on deletion of an Approval Request
        :param _builtins.str service_catalog_deployment: Approval required for deploying service catalog templates (Required or NotRequired).
        """
        if connection_creation is not None:
            pulumi.set(__self__, "connection_creation", connection_creation)
        if connection_deletion is not None:
            pulumi.set(__self__, "connection_deletion", connection_deletion)
        if connection_update is not None:
            pulumi.set(__self__, "connection_update", connection_update)
        if enclave_creation is not None:
            pulumi.set(__self__, "enclave_creation", enclave_creation)
        if enclave_deletion is not None:
            pulumi.set(__self__, "enclave_deletion", enclave_deletion)
        if endpoint_creation is not None:
            pulumi.set(__self__, "endpoint_creation", endpoint_creation)
        if endpoint_deletion is not None:
            pulumi.set(__self__, "endpoint_deletion", endpoint_deletion)
        if endpoint_update is not None:
            pulumi.set(__self__, "endpoint_update", endpoint_update)
        if maintenance_mode is not None:
            pulumi.set(__self__, "maintenance_mode", maintenance_mode)
        if mandatory_approvers is not None:
            pulumi.set(__self__, "mandatory_approvers", mandatory_approvers)
        if minimum_approvers_required is not None:
            pulumi.set(__self__, "minimum_approvers_required", minimum_approvers_required)
        if notification_on_approval_action is not None:
            pulumi.set(__self__, "notification_on_approval_action", notification_on_approval_action)
        if notification_on_approval_creation is not None:
            pulumi.set(__self__, "notification_on_approval_creation", notification_on_approval_creation)
        if notification_on_approval_deletion is not None:
            pulumi.set(__self__, "notification_on_approval_deletion", notification_on_approval_deletion)
        if service_catalog_deployment is not None:
            pulumi.set(__self__, "service_catalog_deployment", service_catalog_deployment)

    @_builtins.property
    @pulumi.getter(name="connectionCreation")
    def connection_creation(self) -> Optional[_builtins.str]:
        """
        Approval required for enclave connection creation (Required or NotRequired).
        """
        return pulumi.get(self, "connection_creation")

    @_builtins.property
    @pulumi.getter(name="connectionDeletion")
    def connection_deletion(self) -> Optional[_builtins.str]:
        """
        Approval required for enclave connection deletion (Required or NotRequired).
        """
        return pulumi.get(self, "connection_deletion")

    @_builtins.property
    @pulumi.getter(name="connectionUpdate")
    def connection_update(self) -> Optional[_builtins.str]:
        """
        Approval required for enclave connection update (Required or NotRequired).
        """
        return pulumi.get(self, "connection_update")

    @_builtins.property
    @pulumi.getter(name="enclaveCreation")
    def enclave_creation(self) -> Optional[_builtins.str]:
        """
        Approval required for virtual enclave creation (Required or NotRequired).
        """
        return pulumi.get(self, "enclave_creation")

    @_builtins.property
    @pulumi.getter(name="enclaveDeletion")
    def enclave_deletion(self) -> Optional[_builtins.str]:
        """
        Approval required for virtual enclave deletion (Required or NotRequired).
        """
        return pulumi.get(self, "enclave_deletion")

    @_builtins.property
    @pulumi.getter(name="endpointCreation")
    def endpoint_creation(self) -> Optional[_builtins.str]:
        """
        Approval required for endpoint creation (Required or NotRequired).
        """
        return pulumi.get(self, "endpoint_creation")

    @_builtins.property
    @pulumi.getter(name="endpointDeletion")
    def endpoint_deletion(self) -> Optional[_builtins.str]:
        """
        Approval required for endpoint deletion (Required or NotRequired).
        """
        return pulumi.get(self, "endpoint_deletion")

    @_builtins.property
    @pulumi.getter(name="endpointUpdate")
    def endpoint_update(self) -> Optional[_builtins.str]:
        """
        Approval required for endpoint update (Required or NotRequired).
        """
        return pulumi.get(self, "endpoint_update")

    @_builtins.property
    @pulumi.getter(name="maintenanceMode")
    def maintenance_mode(self) -> Optional[_builtins.str]:
        """
        Approval required for toggling maintenance mode (Required or NotRequired).
        """
        return pulumi.get(self, "maintenance_mode")

    @_builtins.property
    @pulumi.getter(name="mandatoryApprovers")
    def mandatory_approvers(self) -> Optional[Sequence['outputs.MandatoryApproverResponse']]:
        """
        List of mandatory approvers for the approval request
        """
        return pulumi.get(self, "mandatory_approvers")

    @_builtins.property
    @pulumi.getter(name="minimumApproversRequired")
    def minimum_approvers_required(self) -> Optional[_builtins.float]:
        """
        Minimum number of approvers required for the approval request
        """
        return pulumi.get(self, "minimum_approvers_required")

    @_builtins.property
    @pulumi.getter(name="notificationOnApprovalAction")
    def notification_on_approval_action(self) -> Optional[_builtins.str]:
        """
        Notification will be sent on any action taken (Approve/Reject) on an Approval Request
        """
        return pulumi.get(self, "notification_on_approval_action")

    @_builtins.property
    @pulumi.getter(name="notificationOnApprovalCreation")
    def notification_on_approval_creation(self) -> Optional[_builtins.str]:
        """
        Notification will be sent on creation of an Approval Request
        """
        return pulumi.get(self, "notification_on_approval_creation")

    @_builtins.property
    @pulumi.getter(name="notificationOnApprovalDeletion")
    def notification_on_approval_deletion(self) -> Optional[_builtins.str]:
        """
        Notification will be sent on deletion of an Approval Request
        """
        return pulumi.get(self, "notification_on_approval_deletion")

    @_builtins.property
    @pulumi.getter(name="serviceCatalogDeployment")
    def service_catalog_deployment(self) -> Optional[_builtins.str]:
        """
        Approval required for deploying service catalog templates (Required or NotRequired).
        """
        return pulumi.get(self, "service_catalog_deployment")


@pulumi.output_type
class ApproverResponse(dict):
    """
    Approver Metadata for approvals request.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "approverEntraId":
            suggest = "approver_entra_id"
        elif key == "lastUpdatedAt":
            suggest = "last_updated_at"
        elif key == "actionPerformed":
            suggest = "action_performed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApproverResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApproverResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApproverResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approver_entra_id: _builtins.str,
                 last_updated_at: _builtins.str,
                 action_performed: Optional[_builtins.str] = None):
        """
        Approver Metadata for approvals request.
        :param _builtins.str approver_entra_id: Entra ObjectID of the approver
        :param _builtins.str last_updated_at: approval request last updated at
        :param _builtins.str action_performed: Action Performed by approver
        """
        pulumi.set(__self__, "approver_entra_id", approver_entra_id)
        pulumi.set(__self__, "last_updated_at", last_updated_at)
        if action_performed is not None:
            pulumi.set(__self__, "action_performed", action_performed)

    @_builtins.property
    @pulumi.getter(name="approverEntraId")
    def approver_entra_id(self) -> _builtins.str:
        """
        Entra ObjectID of the approver
        """
        return pulumi.get(self, "approver_entra_id")

    @_builtins.property
    @pulumi.getter(name="lastUpdatedAt")
    def last_updated_at(self) -> _builtins.str:
        """
        approval request last updated at
        """
        return pulumi.get(self, "last_updated_at")

    @_builtins.property
    @pulumi.getter(name="actionPerformed")
    def action_performed(self) -> Optional[_builtins.str]:
        """
        Action Performed by approver
        """
        return pulumi.get(self, "action_performed")


@pulumi.output_type
class CommunityEndpointDestinationRuleResponse(dict):
    """
    Base type for destination rules.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationType":
            suggest = "destination_type"
        elif key == "endpointRuleName":
            suggest = "endpoint_rule_name"
        elif key == "transitHubResourceId":
            suggest = "transit_hub_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CommunityEndpointDestinationRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CommunityEndpointDestinationRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CommunityEndpointDestinationRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: Optional[_builtins.str] = None,
                 destination_type: Optional[_builtins.str] = None,
                 endpoint_rule_name: Optional[_builtins.str] = None,
                 ports: Optional[_builtins.str] = None,
                 protocols: Optional[Sequence[_builtins.str]] = None,
                 transit_hub_resource_id: Optional[_builtins.str] = None):
        """
        Base type for destination rules.
        :param _builtins.str destination: Destination address. Can include multiple CIDR/IP Addresses or fqdn tags or fqdns (for community endpoint) separated by commas.
        :param _builtins.str destination_type: Destination Type.
        :param _builtins.str endpoint_rule_name: Endpoint Rule Name.
        :param _builtins.str ports: Port. Can include multiple ports separated by commas or a range indicated by a hyphen.
        :param Sequence[_builtins.str] protocols: Protocols. Options specified by Endpoint Protocol Enum.
        :param _builtins.str transit_hub_resource_id: Transit Hub Resource Id.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)
        if endpoint_rule_name is not None:
            pulumi.set(__self__, "endpoint_rule_name", endpoint_rule_name)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if transit_hub_resource_id is not None:
            pulumi.set(__self__, "transit_hub_resource_id", transit_hub_resource_id)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[_builtins.str]:
        """
        Destination address. Can include multiple CIDR/IP Addresses or fqdn tags or fqdns (for community endpoint) separated by commas.
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[_builtins.str]:
        """
        Destination Type.
        """
        return pulumi.get(self, "destination_type")

    @_builtins.property
    @pulumi.getter(name="endpointRuleName")
    def endpoint_rule_name(self) -> Optional[_builtins.str]:
        """
        Endpoint Rule Name.
        """
        return pulumi.get(self, "endpoint_rule_name")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[_builtins.str]:
        """
        Port. Can include multiple ports separated by commas or a range indicated by a hyphen.
        """
        return pulumi.get(self, "ports")

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence[_builtins.str]]:
        """
        Protocols. Options specified by Endpoint Protocol Enum.
        """
        return pulumi.get(self, "protocols")

    @_builtins.property
    @pulumi.getter(name="transitHubResourceId")
    def transit_hub_resource_id(self) -> Optional[_builtins.str]:
        """
        Transit Hub Resource Id.
        """
        return pulumi.get(self, "transit_hub_resource_id")


@pulumi.output_type
class EnclaveAddressSpacesModelResponse(dict):
    """
    Enclave Address Spaces
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enclaveAddressSpace":
            suggest = "enclave_address_space"
        elif key == "managedAddressSpace":
            suggest = "managed_address_space"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnclaveAddressSpacesModelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnclaveAddressSpacesModelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnclaveAddressSpacesModelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enclave_address_space: Optional[_builtins.str] = None,
                 managed_address_space: Optional[_builtins.str] = None):
        """
        Enclave Address Spaces
        :param _builtins.str enclave_address_space: Enclave Address Space
        :param _builtins.str managed_address_space: Managed Address Space
        """
        if enclave_address_space is not None:
            pulumi.set(__self__, "enclave_address_space", enclave_address_space)
        if managed_address_space is not None:
            pulumi.set(__self__, "managed_address_space", managed_address_space)

    @_builtins.property
    @pulumi.getter(name="enclaveAddressSpace")
    def enclave_address_space(self) -> Optional[_builtins.str]:
        """
        Enclave Address Space
        """
        return pulumi.get(self, "enclave_address_space")

    @_builtins.property
    @pulumi.getter(name="managedAddressSpace")
    def managed_address_space(self) -> Optional[_builtins.str]:
        """
        Managed Address Space
        """
        return pulumi.get(self, "managed_address_space")


@pulumi.output_type
class EnclaveDefaultSettingsModelResponse(dict):
    """
    Virtual Enclave Default Settings
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultResourceId":
            suggest = "key_vault_resource_id"
        elif key == "logAnalyticsResourceIdCollection":
            suggest = "log_analytics_resource_id_collection"
        elif key == "storageAccountResourceId":
            suggest = "storage_account_resource_id"
        elif key == "diagnosticDestination":
            suggest = "diagnostic_destination"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnclaveDefaultSettingsModelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnclaveDefaultSettingsModelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnclaveDefaultSettingsModelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_resource_id: _builtins.str,
                 log_analytics_resource_id_collection: Sequence[_builtins.str],
                 storage_account_resource_id: _builtins.str,
                 diagnostic_destination: Optional[_builtins.str] = None):
        """
        Virtual Enclave Default Settings
        :param _builtins.str key_vault_resource_id: Key Vault Resource Id.
        :param Sequence[_builtins.str] log_analytics_resource_id_collection: Log Analytics Resource Ids.
        :param _builtins.str storage_account_resource_id: Storage Account Resource Id.
        :param _builtins.str diagnostic_destination: Diagnostic Destination.
        """
        pulumi.set(__self__, "key_vault_resource_id", key_vault_resource_id)
        pulumi.set(__self__, "log_analytics_resource_id_collection", log_analytics_resource_id_collection)
        pulumi.set(__self__, "storage_account_resource_id", storage_account_resource_id)
        if diagnostic_destination is None:
            diagnostic_destination = 'EnclaveOnly'
        if diagnostic_destination is not None:
            pulumi.set(__self__, "diagnostic_destination", diagnostic_destination)

    @_builtins.property
    @pulumi.getter(name="keyVaultResourceId")
    def key_vault_resource_id(self) -> _builtins.str:
        """
        Key Vault Resource Id.
        """
        return pulumi.get(self, "key_vault_resource_id")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsResourceIdCollection")
    def log_analytics_resource_id_collection(self) -> Sequence[_builtins.str]:
        """
        Log Analytics Resource Ids.
        """
        return pulumi.get(self, "log_analytics_resource_id_collection")

    @_builtins.property
    @pulumi.getter(name="storageAccountResourceId")
    def storage_account_resource_id(self) -> _builtins.str:
        """
        Storage Account Resource Id.
        """
        return pulumi.get(self, "storage_account_resource_id")

    @_builtins.property
    @pulumi.getter(name="diagnosticDestination")
    def diagnostic_destination(self) -> Optional[_builtins.str]:
        """
        Diagnostic Destination.
        """
        return pulumi.get(self, "diagnostic_destination")


@pulumi.output_type
class EnclaveEndpointDestinationRuleResponse(dict):
    """
    Enclave Endpoint Rule Properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointRuleName":
            suggest = "endpoint_rule_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnclaveEndpointDestinationRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnclaveEndpointDestinationRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnclaveEndpointDestinationRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: Optional[_builtins.str] = None,
                 endpoint_rule_name: Optional[_builtins.str] = None,
                 ports: Optional[_builtins.str] = None,
                 protocols: Optional[Sequence[_builtins.str]] = None):
        """
        Enclave Endpoint Rule Properties
        :param _builtins.str destination: Destination address. Can include multiple CIDR/IP Addresses or fqdn tags or fqdns (for community endpoint) separated by commas.
        :param _builtins.str endpoint_rule_name: Endpoint Rule Name.
        :param _builtins.str ports: Port. Can include multiple ports separated by commas or a range indicated by a hyphen.
        :param Sequence[_builtins.str] protocols: Protocols. Options specified by Endpoint Protocol Enum.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if endpoint_rule_name is not None:
            pulumi.set(__self__, "endpoint_rule_name", endpoint_rule_name)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[_builtins.str]:
        """
        Destination address. Can include multiple CIDR/IP Addresses or fqdn tags or fqdns (for community endpoint) separated by commas.
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="endpointRuleName")
    def endpoint_rule_name(self) -> Optional[_builtins.str]:
        """
        Endpoint Rule Name.
        """
        return pulumi.get(self, "endpoint_rule_name")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[_builtins.str]:
        """
        Port. Can include multiple ports separated by commas or a range indicated by a hyphen.
        """
        return pulumi.get(self, "ports")

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence[_builtins.str]]:
        """
        Protocols. Options specified by Endpoint Protocol Enum.
        """
        return pulumi.get(self, "protocols")


@pulumi.output_type
class EnclaveVirtualNetworkModelResponse(dict):
    """
    Enclave Virtual Network Properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowSubnetCommunication":
            suggest = "allow_subnet_communication"
        elif key == "customCidrRange":
            suggest = "custom_cidr_range"
        elif key == "networkName":
            suggest = "network_name"
        elif key == "networkSize":
            suggest = "network_size"
        elif key == "subnetConfigurations":
            suggest = "subnet_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnclaveVirtualNetworkModelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnclaveVirtualNetworkModelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnclaveVirtualNetworkModelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_subnet_communication: Optional[_builtins.bool] = None,
                 custom_cidr_range: Optional[_builtins.str] = None,
                 network_name: Optional[_builtins.str] = None,
                 network_size: Optional[_builtins.str] = None,
                 subnet_configurations: Optional[Sequence['outputs.SubnetConfigurationResponse']] = None):
        """
        Enclave Virtual Network Properties
        :param _builtins.bool allow_subnet_communication: Allow Subnet Communication.
        :param _builtins.str custom_cidr_range: Custom CIDR Range.
        :param _builtins.str network_name: Network Name.
        :param _builtins.str network_size: Network Size.
        :param Sequence['SubnetConfigurationResponse'] subnet_configurations: Subnet Configurations.
        """
        if allow_subnet_communication is None:
            allow_subnet_communication = False
        if allow_subnet_communication is not None:
            pulumi.set(__self__, "allow_subnet_communication", allow_subnet_communication)
        if custom_cidr_range is not None:
            pulumi.set(__self__, "custom_cidr_range", custom_cidr_range)
        if network_name is not None:
            pulumi.set(__self__, "network_name", network_name)
        if network_size is not None:
            pulumi.set(__self__, "network_size", network_size)
        if subnet_configurations is not None:
            pulumi.set(__self__, "subnet_configurations", subnet_configurations)

    @_builtins.property
    @pulumi.getter(name="allowSubnetCommunication")
    def allow_subnet_communication(self) -> Optional[_builtins.bool]:
        """
        Allow Subnet Communication.
        """
        return pulumi.get(self, "allow_subnet_communication")

    @_builtins.property
    @pulumi.getter(name="customCidrRange")
    def custom_cidr_range(self) -> Optional[_builtins.str]:
        """
        Custom CIDR Range.
        """
        return pulumi.get(self, "custom_cidr_range")

    @_builtins.property
    @pulumi.getter(name="networkName")
    def network_name(self) -> Optional[_builtins.str]:
        """
        Network Name.
        """
        return pulumi.get(self, "network_name")

    @_builtins.property
    @pulumi.getter(name="networkSize")
    def network_size(self) -> Optional[_builtins.str]:
        """
        Network Size.
        """
        return pulumi.get(self, "network_size")

    @_builtins.property
    @pulumi.getter(name="subnetConfigurations")
    def subnet_configurations(self) -> Optional[Sequence['outputs.SubnetConfigurationResponse']]:
        """
        Subnet Configurations.
        """
        return pulumi.get(self, "subnet_configurations")


@pulumi.output_type
class GovernedServiceItemResponse(dict):
    """
    GovernedServiceItem Properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceId":
            suggest = "service_id"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "policyAction":
            suggest = "policy_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GovernedServiceItemResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GovernedServiceItemResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GovernedServiceItemResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initiatives: Sequence[_builtins.str],
                 service_id: _builtins.str,
                 service_name: _builtins.str,
                 enforcement: Optional[_builtins.str] = None,
                 option: Optional[_builtins.str] = None,
                 policy_action: Optional[_builtins.str] = None):
        """
        GovernedServiceItem Properties
        :param Sequence[_builtins.str] initiatives: Initiatives associated with this service.
        :param _builtins.str service_id: Service ID
        :param _builtins.str service_name: Service name.
        :param _builtins.str enforcement: Initiative enforcement (Enabled or Disabled).
        :param _builtins.str option: Governance option for this service (Allow, Deny, ExceptionOnly, or NotApplicable).
        :param _builtins.str policy_action: Enforcement mode for policy. AuditOnly, Enforce, or None.
        """
        pulumi.set(__self__, "initiatives", initiatives)
        pulumi.set(__self__, "service_id", service_id)
        pulumi.set(__self__, "service_name", service_name)
        if enforcement is not None:
            pulumi.set(__self__, "enforcement", enforcement)
        if option is not None:
            pulumi.set(__self__, "option", option)
        if policy_action is not None:
            pulumi.set(__self__, "policy_action", policy_action)

    @_builtins.property
    @pulumi.getter
    def initiatives(self) -> Sequence[_builtins.str]:
        """
        Initiatives associated with this service.
        """
        return pulumi.get(self, "initiatives")

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> _builtins.str:
        """
        Service ID
        """
        return pulumi.get(self, "service_id")

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> _builtins.str:
        """
        Service name.
        """
        return pulumi.get(self, "service_name")

    @_builtins.property
    @pulumi.getter
    def enforcement(self) -> Optional[_builtins.str]:
        """
        Initiative enforcement (Enabled or Disabled).
        """
        return pulumi.get(self, "enforcement")

    @_builtins.property
    @pulumi.getter
    def option(self) -> Optional[_builtins.str]:
        """
        Governance option for this service (Allow, Deny, ExceptionOnly, or NotApplicable).
        """
        return pulumi.get(self, "option")

    @_builtins.property
    @pulumi.getter(name="policyAction")
    def policy_action(self) -> Optional[_builtins.str]:
        """
        Enforcement mode for policy. AuditOnly, Enforce, or None.
        """
        return pulumi.get(self, "policy_action")


@pulumi.output_type
class MaintenanceModeConfigurationModelResponse(dict):
    """
    Maintenance Mode
    """
    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 justification: Optional[_builtins.str] = None,
                 principals: Optional[Sequence['outputs.PrincipalResponse']] = None):
        """
        Maintenance Mode
        :param _builtins.str mode: Current mode of Maintenance Mode Configuration
        :param _builtins.str justification: Justification for entering or exiting Maintenance Mode
        :param Sequence['PrincipalResponse'] principals: The user, group or service principal object affected by Maintenance Mode
        """
        if mode is None:
            mode = 'Off'
        pulumi.set(__self__, "mode", mode)
        if justification is None:
            justification = 'Off'
        if justification is not None:
            pulumi.set(__self__, "justification", justification)
        if principals is not None:
            pulumi.set(__self__, "principals", principals)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Current mode of Maintenance Mode Configuration
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def justification(self) -> Optional[_builtins.str]:
        """
        Justification for entering or exiting Maintenance Mode
        """
        return pulumi.get(self, "justification")

    @_builtins.property
    @pulumi.getter
    def principals(self) -> Optional[Sequence['outputs.PrincipalResponse']]:
        """
        The user, group or service principal object affected by Maintenance Mode
        """
        return pulumi.get(self, "principals")


@pulumi.output_type
class ManagedOnBehalfOfConfigurationResponse(dict):
    """
    Managed-On-Behalf-Of configuration properties. This configuration exists for the resources where a resource provider manages those resources on behalf of the resource owner.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "moboBrokerResources":
            suggest = "mobo_broker_resources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedOnBehalfOfConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedOnBehalfOfConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedOnBehalfOfConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mobo_broker_resources: Optional[Sequence['outputs.MoboBrokerResourceResponse']] = None):
        """
        Managed-On-Behalf-Of configuration properties. This configuration exists for the resources where a resource provider manages those resources on behalf of the resource owner.
        :param Sequence['MoboBrokerResourceResponse'] mobo_broker_resources: Managed-On-Behalf-Of broker resources
        """
        if mobo_broker_resources is not None:
            pulumi.set(__self__, "mobo_broker_resources", mobo_broker_resources)

    @_builtins.property
    @pulumi.getter(name="moboBrokerResources")
    def mobo_broker_resources(self) -> Optional[Sequence['outputs.MoboBrokerResourceResponse']]:
        """
        Managed-On-Behalf-Of broker resources
        """
        return pulumi.get(self, "mobo_broker_resources")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity (system assigned and/or user assigned identities)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: _builtins.str,
                 tenant_id: _builtins.str,
                 type: _builtins.str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param _builtins.str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param _builtins.str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param _builtins.str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class MandatoryApproverResponse(dict):
    """
    Approver Metadata for approvals request.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "approverEntraId":
            suggest = "approver_entra_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MandatoryApproverResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MandatoryApproverResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MandatoryApproverResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approver_entra_id: _builtins.str):
        """
        Approver Metadata for approvals request.
        :param _builtins.str approver_entra_id: EntraId of the approver
        """
        pulumi.set(__self__, "approver_entra_id", approver_entra_id)

    @_builtins.property
    @pulumi.getter(name="approverEntraId")
    def approver_entra_id(self) -> _builtins.str:
        """
        EntraId of the approver
        """
        return pulumi.get(self, "approver_entra_id")


@pulumi.output_type
class MoboBrokerResourceResponse(dict):
    """
    Managed-On-Behalf-Of broker resource. This resource is created by the Resource Provider to manage some resources on behalf of the user.
    """
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None):
        """
        Managed-On-Behalf-Of broker resource. This resource is created by the Resource Provider to manage some resources on behalf of the user.
        :param _builtins.str id: Resource identifier of a Managed-On-Behalf-Of broker resource
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Resource identifier of a Managed-On-Behalf-Of broker resource
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrincipalResponse(dict):
    """
    Principal for maintenance mode or role assignments
    """
    def __init__(__self__, *,
                 id: _builtins.str,
                 type: _builtins.str):
        """
        Principal for maintenance mode or role assignments
        :param _builtins.str id: The object id associated with the principal
        :param _builtins.str type: The type of the object id. We currently allow users, groups, and service principals
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The object id associated with the principal
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the object id. We currently allow users, groups, and service principals
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RequestMetadataResponse(dict):
    """
    Request Metadata for approvals request.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceAction":
            suggest = "resource_action"
        elif key == "approvalCallbackPayload":
            suggest = "approval_callback_payload"
        elif key == "approvalCallbackRoute":
            suggest = "approval_callback_route"
        elif key == "approvalStatus":
            suggest = "approval_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestMetadataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestMetadataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestMetadataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_action: _builtins.str,
                 approval_callback_payload: Optional[_builtins.str] = None,
                 approval_callback_route: Optional[_builtins.str] = None,
                 approval_status: Optional[_builtins.str] = None):
        """
        Request Metadata for approvals request.
        :param _builtins.str resource_action: Resource Action of the item being approved or declined.
        :param _builtins.str approval_callback_payload: Payload to be sent upon any action on approval request
        :param _builtins.str approval_callback_route: Route name for the approval callback
        :param _builtins.str approval_status: Status of the approval. Uses ApprovalStatus enum.
        """
        pulumi.set(__self__, "resource_action", resource_action)
        if approval_callback_payload is not None:
            pulumi.set(__self__, "approval_callback_payload", approval_callback_payload)
        if approval_callback_route is not None:
            pulumi.set(__self__, "approval_callback_route", approval_callback_route)
        if approval_status is None:
            approval_status = 'Pending'
        if approval_status is not None:
            pulumi.set(__self__, "approval_status", approval_status)

    @_builtins.property
    @pulumi.getter(name="resourceAction")
    def resource_action(self) -> _builtins.str:
        """
        Resource Action of the item being approved or declined.
        """
        return pulumi.get(self, "resource_action")

    @_builtins.property
    @pulumi.getter(name="approvalCallbackPayload")
    def approval_callback_payload(self) -> Optional[_builtins.str]:
        """
        Payload to be sent upon any action on approval request
        """
        return pulumi.get(self, "approval_callback_payload")

    @_builtins.property
    @pulumi.getter(name="approvalCallbackRoute")
    def approval_callback_route(self) -> Optional[_builtins.str]:
        """
        Route name for the approval callback
        """
        return pulumi.get(self, "approval_callback_route")

    @_builtins.property
    @pulumi.getter(name="approvalStatus")
    def approval_status(self) -> Optional[_builtins.str]:
        """
        Status of the approval. Uses ApprovalStatus enum.
        """
        return pulumi.get(self, "approval_status")


@pulumi.output_type
class RoleAssignmentItemResponse(dict):
    """
    Role assignment item that indicates which principals should be assigned this role definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleDefinitionId":
            suggest = "role_definition_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoleAssignmentItemResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoleAssignmentItemResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoleAssignmentItemResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_definition_id: _builtins.str,
                 principals: Optional[Sequence['outputs.PrincipalResponse']] = None):
        """
        Role assignment item that indicates which principals should be assigned this role definition
        :param _builtins.str role_definition_id: Role definition identifier
        :param Sequence['PrincipalResponse'] principals: List of principal IDs to which to assign this role definition
        """
        pulumi.set(__self__, "role_definition_id", role_definition_id)
        if principals is not None:
            pulumi.set(__self__, "principals", principals)

    @_builtins.property
    @pulumi.getter(name="roleDefinitionId")
    def role_definition_id(self) -> _builtins.str:
        """
        Role definition identifier
        """
        return pulumi.get(self, "role_definition_id")

    @_builtins.property
    @pulumi.getter
    def principals(self) -> Optional[Sequence['outputs.PrincipalResponse']]:
        """
        List of principal IDs to which to assign this role definition
        """
        return pulumi.get(self, "principals")


@pulumi.output_type
class SubnetConfigurationResponse(dict):
    """
    Subnet Configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPrefix":
            suggest = "address_prefix"
        elif key == "networkPrefixSize":
            suggest = "network_prefix_size"
        elif key == "networkSecurityGroupResourceId":
            suggest = "network_security_group_resource_id"
        elif key == "subnetName":
            suggest = "subnet_name"
        elif key == "subnetResourceId":
            suggest = "subnet_resource_id"
        elif key == "subnetDelegation":
            suggest = "subnet_delegation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubnetConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubnetConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubnetConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_prefix: _builtins.str,
                 network_prefix_size: _builtins.int,
                 network_security_group_resource_id: _builtins.str,
                 subnet_name: _builtins.str,
                 subnet_resource_id: _builtins.str,
                 subnet_delegation: Optional[_builtins.str] = None):
        """
        Subnet Configuration
        :param _builtins.str address_prefix: Address prefix.
        :param _builtins.int network_prefix_size: Network prefix size.
        :param _builtins.str network_security_group_resource_id: Network security group ID.
        :param _builtins.str subnet_name: Subnet name.
        :param _builtins.str subnet_resource_id: Subnet Resource ID.
        :param _builtins.str subnet_delegation: Subnet delegation.
        """
        pulumi.set(__self__, "address_prefix", address_prefix)
        pulumi.set(__self__, "network_prefix_size", network_prefix_size)
        pulumi.set(__self__, "network_security_group_resource_id", network_security_group_resource_id)
        pulumi.set(__self__, "subnet_name", subnet_name)
        pulumi.set(__self__, "subnet_resource_id", subnet_resource_id)
        if subnet_delegation is not None:
            pulumi.set(__self__, "subnet_delegation", subnet_delegation)

    @_builtins.property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> _builtins.str:
        """
        Address prefix.
        """
        return pulumi.get(self, "address_prefix")

    @_builtins.property
    @pulumi.getter(name="networkPrefixSize")
    def network_prefix_size(self) -> _builtins.int:
        """
        Network prefix size.
        """
        return pulumi.get(self, "network_prefix_size")

    @_builtins.property
    @pulumi.getter(name="networkSecurityGroupResourceId")
    def network_security_group_resource_id(self) -> _builtins.str:
        """
        Network security group ID.
        """
        return pulumi.get(self, "network_security_group_resource_id")

    @_builtins.property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> _builtins.str:
        """
        Subnet name.
        """
        return pulumi.get(self, "subnet_name")

    @_builtins.property
    @pulumi.getter(name="subnetResourceId")
    def subnet_resource_id(self) -> _builtins.str:
        """
        Subnet Resource ID.
        """
        return pulumi.get(self, "subnet_resource_id")

    @_builtins.property
    @pulumi.getter(name="subnetDelegation")
    def subnet_delegation(self) -> Optional[_builtins.str]:
        """
        Subnet delegation.
        """
        return pulumi.get(self, "subnet_delegation")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 created_by_type: Optional[_builtins.str] = None,
                 last_modified_at: Optional[_builtins.str] = None,
                 last_modified_by: Optional[_builtins.str] = None,
                 last_modified_by_type: Optional[_builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param _builtins.str created_at: The timestamp of resource creation (UTC).
        :param _builtins.str created_by: The identity that created the resource.
        :param _builtins.str created_by_type: The type of identity that created the resource.
        :param _builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param _builtins.str last_modified_by: The identity that last modified the resource.
        :param _builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @_builtins.property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @_builtins.property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[_builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @_builtins.property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TransitOptionParamsResponse(dict):
    """
    TransitOptionParams Properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "remoteVirtualNetworkId":
            suggest = "remote_virtual_network_id"
        elif key == "scaleUnits":
            suggest = "scale_units"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransitOptionParamsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransitOptionParamsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransitOptionParamsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 remote_virtual_network_id: Optional[_builtins.str] = None,
                 scale_units: Optional[_builtins.float] = None):
        """
        TransitOptionParams Properties
        :param _builtins.str remote_virtual_network_id: Transit Option Params remoteVirtualNetworkId.
        :param _builtins.float scale_units: Transit Option Params scaleUnits.
        """
        if remote_virtual_network_id is not None:
            pulumi.set(__self__, "remote_virtual_network_id", remote_virtual_network_id)
        if scale_units is not None:
            pulumi.set(__self__, "scale_units", scale_units)

    @_builtins.property
    @pulumi.getter(name="remoteVirtualNetworkId")
    def remote_virtual_network_id(self) -> Optional[_builtins.str]:
        """
        Transit Option Params remoteVirtualNetworkId.
        """
        return pulumi.get(self, "remote_virtual_network_id")

    @_builtins.property
    @pulumi.getter(name="scaleUnits")
    def scale_units(self) -> Optional[_builtins.float]:
        """
        Transit Option Params scaleUnits.
        """
        return pulumi.get(self, "scale_units")


@pulumi.output_type
class TransitOptionResponse(dict):
    """
    TransitOption Properties
    """
    def __init__(__self__, *,
                 params: Optional['outputs.TransitOptionParamsResponse'] = None,
                 type: Optional[_builtins.str] = None):
        """
        TransitOption Properties
        :param 'TransitOptionParamsResponse' params: Transit Option Params
        :param _builtins.str type: Transit Option Type.
        """
        if params is not None:
            pulumi.set(__self__, "params", params)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional['outputs.TransitOptionParamsResponse']:
        """
        Transit Option Params
        """
        return pulumi.get(self, "params")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Transit Option Type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 principal_id: _builtins.str):
        """
        User assigned identity properties
        :param _builtins.str client_id: The client ID of the assigned identity.
        :param _builtins.str principal_id: The principal ID of the assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")


