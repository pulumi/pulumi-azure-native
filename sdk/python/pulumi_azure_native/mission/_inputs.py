# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'ApprovalSettingsArgs',
    'ApprovalSettingsArgsDict',
    'ApproverArgs',
    'ApproverArgsDict',
    'CommunityEndpointDestinationRuleArgs',
    'CommunityEndpointDestinationRuleArgsDict',
    'EnclaveDefaultSettingsModelArgs',
    'EnclaveDefaultSettingsModelArgsDict',
    'EnclaveEndpointDestinationRuleArgs',
    'EnclaveEndpointDestinationRuleArgsDict',
    'EnclaveVirtualNetworkModelArgs',
    'EnclaveVirtualNetworkModelArgsDict',
    'GovernedServiceItemArgs',
    'GovernedServiceItemArgsDict',
    'MaintenanceModeConfigurationModelArgs',
    'MaintenanceModeConfigurationModelArgsDict',
    'ManagedServiceIdentityArgs',
    'ManagedServiceIdentityArgsDict',
    'MandatoryApproverArgs',
    'MandatoryApproverArgsDict',
    'PrincipalArgs',
    'PrincipalArgsDict',
    'RequestMetadataArgs',
    'RequestMetadataArgsDict',
    'RoleAssignmentItemArgs',
    'RoleAssignmentItemArgsDict',
    'SubnetConfigurationArgs',
    'SubnetConfigurationArgsDict',
    'TransitOptionParamsArgs',
    'TransitOptionParamsArgsDict',
    'TransitOptionArgs',
    'TransitOptionArgsDict',
]

MYPY = False

if not MYPY:
    class ApprovalSettingsArgsDict(TypedDict):
        """
        ApprovalSettings Properties
        """
        connection_creation: NotRequired[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]
        """
        Approval required for enclave connection creation (Required or NotRequired).
        """
        connection_deletion: NotRequired[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]
        """
        Approval required for enclave connection deletion (Required or NotRequired).
        """
        connection_update: NotRequired[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]
        """
        Approval required for enclave connection update (Required or NotRequired).
        """
        enclave_creation: NotRequired[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]
        """
        Approval required for virtual enclave creation (Required or NotRequired).
        """
        enclave_deletion: NotRequired[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]
        """
        Approval required for virtual enclave deletion (Required or NotRequired).
        """
        endpoint_creation: NotRequired[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]
        """
        Approval required for endpoint creation (Required or NotRequired).
        """
        endpoint_deletion: NotRequired[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]
        """
        Approval required for endpoint deletion (Required or NotRequired).
        """
        endpoint_update: NotRequired[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]
        """
        Approval required for endpoint update (Required or NotRequired).
        """
        maintenance_mode: NotRequired[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]
        """
        Approval required for toggling maintenance mode (Required or NotRequired).
        """
        mandatory_approvers: NotRequired[pulumi.Input[Sequence[pulumi.Input['MandatoryApproverArgsDict']]]]
        """
        List of mandatory approvers for the approval request
        """
        minimum_approvers_required: NotRequired[pulumi.Input[_builtins.float]]
        """
        Minimum number of approvers required for the approval request
        """
        notification_on_approval_action: NotRequired[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]
        """
        Notification will be sent on any action taken (Approve/Reject) on an Approval Request
        """
        notification_on_approval_creation: NotRequired[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]
        """
        Notification will be sent on creation of an Approval Request
        """
        notification_on_approval_deletion: NotRequired[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]
        """
        Notification will be sent on deletion of an Approval Request
        """
        service_catalog_deployment: NotRequired[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]
        """
        Approval required for deploying service catalog templates (Required or NotRequired).
        """
elif False:
    ApprovalSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApprovalSettingsArgs:
    def __init__(__self__, *,
                 connection_creation: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]] = None,
                 connection_deletion: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]] = None,
                 connection_update: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]] = None,
                 enclave_creation: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]] = None,
                 enclave_deletion: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]] = None,
                 endpoint_creation: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]] = None,
                 endpoint_deletion: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]] = None,
                 endpoint_update: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]] = None,
                 maintenance_mode: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]] = None,
                 mandatory_approvers: Optional[pulumi.Input[Sequence[pulumi.Input['MandatoryApproverArgs']]]] = None,
                 minimum_approvers_required: Optional[pulumi.Input[_builtins.float]] = None,
                 notification_on_approval_action: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]] = None,
                 notification_on_approval_creation: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]] = None,
                 notification_on_approval_deletion: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]] = None,
                 service_catalog_deployment: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]] = None):
        """
        ApprovalSettings Properties
        :param pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']] connection_creation: Approval required for enclave connection creation (Required or NotRequired).
        :param pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']] connection_deletion: Approval required for enclave connection deletion (Required or NotRequired).
        :param pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']] connection_update: Approval required for enclave connection update (Required or NotRequired).
        :param pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']] enclave_creation: Approval required for virtual enclave creation (Required or NotRequired).
        :param pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']] enclave_deletion: Approval required for virtual enclave deletion (Required or NotRequired).
        :param pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']] endpoint_creation: Approval required for endpoint creation (Required or NotRequired).
        :param pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']] endpoint_deletion: Approval required for endpoint deletion (Required or NotRequired).
        :param pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']] endpoint_update: Approval required for endpoint update (Required or NotRequired).
        :param pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']] maintenance_mode: Approval required for toggling maintenance mode (Required or NotRequired).
        :param pulumi.Input[Sequence[pulumi.Input['MandatoryApproverArgs']]] mandatory_approvers: List of mandatory approvers for the approval request
        :param pulumi.Input[_builtins.float] minimum_approvers_required: Minimum number of approvers required for the approval request
        :param pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']] notification_on_approval_action: Notification will be sent on any action taken (Approve/Reject) on an Approval Request
        :param pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']] notification_on_approval_creation: Notification will be sent on creation of an Approval Request
        :param pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']] notification_on_approval_deletion: Notification will be sent on deletion of an Approval Request
        :param pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']] service_catalog_deployment: Approval required for deploying service catalog templates (Required or NotRequired).
        """
        if connection_creation is not None:
            pulumi.set(__self__, "connection_creation", connection_creation)
        if connection_deletion is not None:
            pulumi.set(__self__, "connection_deletion", connection_deletion)
        if connection_update is not None:
            pulumi.set(__self__, "connection_update", connection_update)
        if enclave_creation is not None:
            pulumi.set(__self__, "enclave_creation", enclave_creation)
        if enclave_deletion is not None:
            pulumi.set(__self__, "enclave_deletion", enclave_deletion)
        if endpoint_creation is not None:
            pulumi.set(__self__, "endpoint_creation", endpoint_creation)
        if endpoint_deletion is not None:
            pulumi.set(__self__, "endpoint_deletion", endpoint_deletion)
        if endpoint_update is not None:
            pulumi.set(__self__, "endpoint_update", endpoint_update)
        if maintenance_mode is not None:
            pulumi.set(__self__, "maintenance_mode", maintenance_mode)
        if mandatory_approvers is not None:
            pulumi.set(__self__, "mandatory_approvers", mandatory_approvers)
        if minimum_approvers_required is not None:
            pulumi.set(__self__, "minimum_approvers_required", minimum_approvers_required)
        if notification_on_approval_action is not None:
            pulumi.set(__self__, "notification_on_approval_action", notification_on_approval_action)
        if notification_on_approval_creation is not None:
            pulumi.set(__self__, "notification_on_approval_creation", notification_on_approval_creation)
        if notification_on_approval_deletion is not None:
            pulumi.set(__self__, "notification_on_approval_deletion", notification_on_approval_deletion)
        if service_catalog_deployment is not None:
            pulumi.set(__self__, "service_catalog_deployment", service_catalog_deployment)

    @_builtins.property
    @pulumi.getter(name="connectionCreation")
    def connection_creation(self) -> Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]:
        """
        Approval required for enclave connection creation (Required or NotRequired).
        """
        return pulumi.get(self, "connection_creation")

    @connection_creation.setter
    def connection_creation(self, value: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]):
        pulumi.set(self, "connection_creation", value)

    @_builtins.property
    @pulumi.getter(name="connectionDeletion")
    def connection_deletion(self) -> Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]:
        """
        Approval required for enclave connection deletion (Required or NotRequired).
        """
        return pulumi.get(self, "connection_deletion")

    @connection_deletion.setter
    def connection_deletion(self, value: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]):
        pulumi.set(self, "connection_deletion", value)

    @_builtins.property
    @pulumi.getter(name="connectionUpdate")
    def connection_update(self) -> Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]:
        """
        Approval required for enclave connection update (Required or NotRequired).
        """
        return pulumi.get(self, "connection_update")

    @connection_update.setter
    def connection_update(self, value: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]):
        pulumi.set(self, "connection_update", value)

    @_builtins.property
    @pulumi.getter(name="enclaveCreation")
    def enclave_creation(self) -> Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]:
        """
        Approval required for virtual enclave creation (Required or NotRequired).
        """
        return pulumi.get(self, "enclave_creation")

    @enclave_creation.setter
    def enclave_creation(self, value: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]):
        pulumi.set(self, "enclave_creation", value)

    @_builtins.property
    @pulumi.getter(name="enclaveDeletion")
    def enclave_deletion(self) -> Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]:
        """
        Approval required for virtual enclave deletion (Required or NotRequired).
        """
        return pulumi.get(self, "enclave_deletion")

    @enclave_deletion.setter
    def enclave_deletion(self, value: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]):
        pulumi.set(self, "enclave_deletion", value)

    @_builtins.property
    @pulumi.getter(name="endpointCreation")
    def endpoint_creation(self) -> Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]:
        """
        Approval required for endpoint creation (Required or NotRequired).
        """
        return pulumi.get(self, "endpoint_creation")

    @endpoint_creation.setter
    def endpoint_creation(self, value: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]):
        pulumi.set(self, "endpoint_creation", value)

    @_builtins.property
    @pulumi.getter(name="endpointDeletion")
    def endpoint_deletion(self) -> Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]:
        """
        Approval required for endpoint deletion (Required or NotRequired).
        """
        return pulumi.get(self, "endpoint_deletion")

    @endpoint_deletion.setter
    def endpoint_deletion(self, value: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]):
        pulumi.set(self, "endpoint_deletion", value)

    @_builtins.property
    @pulumi.getter(name="endpointUpdate")
    def endpoint_update(self) -> Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]:
        """
        Approval required for endpoint update (Required or NotRequired).
        """
        return pulumi.get(self, "endpoint_update")

    @endpoint_update.setter
    def endpoint_update(self, value: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]):
        pulumi.set(self, "endpoint_update", value)

    @_builtins.property
    @pulumi.getter(name="maintenanceMode")
    def maintenance_mode(self) -> Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]:
        """
        Approval required for toggling maintenance mode (Required or NotRequired).
        """
        return pulumi.get(self, "maintenance_mode")

    @maintenance_mode.setter
    def maintenance_mode(self, value: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]):
        pulumi.set(self, "maintenance_mode", value)

    @_builtins.property
    @pulumi.getter(name="mandatoryApprovers")
    def mandatory_approvers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MandatoryApproverArgs']]]]:
        """
        List of mandatory approvers for the approval request
        """
        return pulumi.get(self, "mandatory_approvers")

    @mandatory_approvers.setter
    def mandatory_approvers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MandatoryApproverArgs']]]]):
        pulumi.set(self, "mandatory_approvers", value)

    @_builtins.property
    @pulumi.getter(name="minimumApproversRequired")
    def minimum_approvers_required(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Minimum number of approvers required for the approval request
        """
        return pulumi.get(self, "minimum_approvers_required")

    @minimum_approvers_required.setter
    def minimum_approvers_required(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "minimum_approvers_required", value)

    @_builtins.property
    @pulumi.getter(name="notificationOnApprovalAction")
    def notification_on_approval_action(self) -> Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]:
        """
        Notification will be sent on any action taken (Approve/Reject) on an Approval Request
        """
        return pulumi.get(self, "notification_on_approval_action")

    @notification_on_approval_action.setter
    def notification_on_approval_action(self, value: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]):
        pulumi.set(self, "notification_on_approval_action", value)

    @_builtins.property
    @pulumi.getter(name="notificationOnApprovalCreation")
    def notification_on_approval_creation(self) -> Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]:
        """
        Notification will be sent on creation of an Approval Request
        """
        return pulumi.get(self, "notification_on_approval_creation")

    @notification_on_approval_creation.setter
    def notification_on_approval_creation(self, value: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]):
        pulumi.set(self, "notification_on_approval_creation", value)

    @_builtins.property
    @pulumi.getter(name="notificationOnApprovalDeletion")
    def notification_on_approval_deletion(self) -> Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]:
        """
        Notification will be sent on deletion of an Approval Request
        """
        return pulumi.get(self, "notification_on_approval_deletion")

    @notification_on_approval_deletion.setter
    def notification_on_approval_deletion(self, value: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]):
        pulumi.set(self, "notification_on_approval_deletion", value)

    @_builtins.property
    @pulumi.getter(name="serviceCatalogDeployment")
    def service_catalog_deployment(self) -> Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]:
        """
        Approval required for deploying service catalog templates (Required or NotRequired).
        """
        return pulumi.get(self, "service_catalog_deployment")

    @service_catalog_deployment.setter
    def service_catalog_deployment(self, value: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalPolicy']]]):
        pulumi.set(self, "service_catalog_deployment", value)


if not MYPY:
    class ApproverArgsDict(TypedDict):
        """
        Approver Metadata for approvals request.
        """
        approver_entra_id: pulumi.Input[_builtins.str]
        """
        Entra ObjectID of the approver
        """
        last_updated_at: pulumi.Input[_builtins.str]
        """
        approval request last updated at
        """
        action_performed: NotRequired[pulumi.Input[Union[_builtins.str, 'ActionPerformed']]]
        """
        Action Performed by approver
        """
elif False:
    ApproverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApproverArgs:
    def __init__(__self__, *,
                 approver_entra_id: pulumi.Input[_builtins.str],
                 last_updated_at: pulumi.Input[_builtins.str],
                 action_performed: Optional[pulumi.Input[Union[_builtins.str, 'ActionPerformed']]] = None):
        """
        Approver Metadata for approvals request.
        :param pulumi.Input[_builtins.str] approver_entra_id: Entra ObjectID of the approver
        :param pulumi.Input[_builtins.str] last_updated_at: approval request last updated at
        :param pulumi.Input[Union[_builtins.str, 'ActionPerformed']] action_performed: Action Performed by approver
        """
        pulumi.set(__self__, "approver_entra_id", approver_entra_id)
        pulumi.set(__self__, "last_updated_at", last_updated_at)
        if action_performed is not None:
            pulumi.set(__self__, "action_performed", action_performed)

    @_builtins.property
    @pulumi.getter(name="approverEntraId")
    def approver_entra_id(self) -> pulumi.Input[_builtins.str]:
        """
        Entra ObjectID of the approver
        """
        return pulumi.get(self, "approver_entra_id")

    @approver_entra_id.setter
    def approver_entra_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "approver_entra_id", value)

    @_builtins.property
    @pulumi.getter(name="lastUpdatedAt")
    def last_updated_at(self) -> pulumi.Input[_builtins.str]:
        """
        approval request last updated at
        """
        return pulumi.get(self, "last_updated_at")

    @last_updated_at.setter
    def last_updated_at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "last_updated_at", value)

    @_builtins.property
    @pulumi.getter(name="actionPerformed")
    def action_performed(self) -> Optional[pulumi.Input[Union[_builtins.str, 'ActionPerformed']]]:
        """
        Action Performed by approver
        """
        return pulumi.get(self, "action_performed")

    @action_performed.setter
    def action_performed(self, value: Optional[pulumi.Input[Union[_builtins.str, 'ActionPerformed']]]):
        pulumi.set(self, "action_performed", value)


if not MYPY:
    class CommunityEndpointDestinationRuleArgsDict(TypedDict):
        """
        Base type for destination rules.
        """
        destination: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination address. Can include multiple CIDR/IP Addresses or fqdn tags or fqdns (for community endpoint) separated by commas.
        """
        destination_type: NotRequired[pulumi.Input[Union[_builtins.str, 'DestinationType']]]
        """
        Destination Type.
        """
        endpoint_rule_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Endpoint Rule Name.
        """
        ports: NotRequired[pulumi.Input[_builtins.str]]
        """
        Port. Can include multiple ports separated by commas or a range indicated by a hyphen.
        """
        protocols: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'CommunityEndpointProtocol']]]]]
        """
        Protocols. Options specified by Endpoint Protocol Enum.
        """
        transit_hub_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Transit Hub Resource Id.
        """
elif False:
    CommunityEndpointDestinationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CommunityEndpointDestinationRuleArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_type: Optional[pulumi.Input[Union[_builtins.str, 'DestinationType']]] = None,
                 endpoint_rule_name: Optional[pulumi.Input[_builtins.str]] = None,
                 ports: Optional[pulumi.Input[_builtins.str]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'CommunityEndpointProtocol']]]]] = None,
                 transit_hub_resource_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Base type for destination rules.
        :param pulumi.Input[_builtins.str] destination: Destination address. Can include multiple CIDR/IP Addresses or fqdn tags or fqdns (for community endpoint) separated by commas.
        :param pulumi.Input[Union[_builtins.str, 'DestinationType']] destination_type: Destination Type.
        :param pulumi.Input[_builtins.str] endpoint_rule_name: Endpoint Rule Name.
        :param pulumi.Input[_builtins.str] ports: Port. Can include multiple ports separated by commas or a range indicated by a hyphen.
        :param pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'CommunityEndpointProtocol']]]] protocols: Protocols. Options specified by Endpoint Protocol Enum.
        :param pulumi.Input[_builtins.str] transit_hub_resource_id: Transit Hub Resource Id.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)
        if endpoint_rule_name is not None:
            pulumi.set(__self__, "endpoint_rule_name", endpoint_rule_name)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if transit_hub_resource_id is not None:
            pulumi.set(__self__, "transit_hub_resource_id", transit_hub_resource_id)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination address. Can include multiple CIDR/IP Addresses or fqdn tags or fqdns (for community endpoint) separated by commas.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[pulumi.Input[Union[_builtins.str, 'DestinationType']]]:
        """
        Destination Type.
        """
        return pulumi.get(self, "destination_type")

    @destination_type.setter
    def destination_type(self, value: Optional[pulumi.Input[Union[_builtins.str, 'DestinationType']]]):
        pulumi.set(self, "destination_type", value)

    @_builtins.property
    @pulumi.getter(name="endpointRuleName")
    def endpoint_rule_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Endpoint Rule Name.
        """
        return pulumi.get(self, "endpoint_rule_name")

    @endpoint_rule_name.setter
    def endpoint_rule_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint_rule_name", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Port. Can include multiple ports separated by commas or a range indicated by a hyphen.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ports", value)

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'CommunityEndpointProtocol']]]]]:
        """
        Protocols. Options specified by Endpoint Protocol Enum.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'CommunityEndpointProtocol']]]]]):
        pulumi.set(self, "protocols", value)

    @_builtins.property
    @pulumi.getter(name="transitHubResourceId")
    def transit_hub_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Transit Hub Resource Id.
        """
        return pulumi.get(self, "transit_hub_resource_id")

    @transit_hub_resource_id.setter
    def transit_hub_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "transit_hub_resource_id", value)


if not MYPY:
    class EnclaveDefaultSettingsModelArgsDict(TypedDict):
        """
        Virtual Enclave Default Settings
        """
        diagnostic_destination: NotRequired[pulumi.Input[Union[_builtins.str, 'DiagnosticDestination']]]
        """
        Diagnostic Destination.
        """
elif False:
    EnclaveDefaultSettingsModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnclaveDefaultSettingsModelArgs:
    def __init__(__self__, *,
                 diagnostic_destination: Optional[pulumi.Input[Union[_builtins.str, 'DiagnosticDestination']]] = None):
        """
        Virtual Enclave Default Settings
        :param pulumi.Input[Union[_builtins.str, 'DiagnosticDestination']] diagnostic_destination: Diagnostic Destination.
        """
        if diagnostic_destination is None:
            diagnostic_destination = 'EnclaveOnly'
        if diagnostic_destination is not None:
            pulumi.set(__self__, "diagnostic_destination", diagnostic_destination)

    @_builtins.property
    @pulumi.getter(name="diagnosticDestination")
    def diagnostic_destination(self) -> Optional[pulumi.Input[Union[_builtins.str, 'DiagnosticDestination']]]:
        """
        Diagnostic Destination.
        """
        return pulumi.get(self, "diagnostic_destination")

    @diagnostic_destination.setter
    def diagnostic_destination(self, value: Optional[pulumi.Input[Union[_builtins.str, 'DiagnosticDestination']]]):
        pulumi.set(self, "diagnostic_destination", value)


if not MYPY:
    class EnclaveEndpointDestinationRuleArgsDict(TypedDict):
        """
        Enclave Endpoint Rule Properties
        """
        destination: NotRequired[pulumi.Input[_builtins.str]]
        """
        Destination address. Can include multiple CIDR/IP Addresses or fqdn tags or fqdns (for community endpoint) separated by commas.
        """
        endpoint_rule_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Endpoint Rule Name.
        """
        ports: NotRequired[pulumi.Input[_builtins.str]]
        """
        Port. Can include multiple ports separated by commas or a range indicated by a hyphen.
        """
        protocols: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'EnclaveEndpointProtocol']]]]]
        """
        Protocols. Options specified by Endpoint Protocol Enum.
        """
elif False:
    EnclaveEndpointDestinationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnclaveEndpointDestinationRuleArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 endpoint_rule_name: Optional[pulumi.Input[_builtins.str]] = None,
                 ports: Optional[pulumi.Input[_builtins.str]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'EnclaveEndpointProtocol']]]]] = None):
        """
        Enclave Endpoint Rule Properties
        :param pulumi.Input[_builtins.str] destination: Destination address. Can include multiple CIDR/IP Addresses or fqdn tags or fqdns (for community endpoint) separated by commas.
        :param pulumi.Input[_builtins.str] endpoint_rule_name: Endpoint Rule Name.
        :param pulumi.Input[_builtins.str] ports: Port. Can include multiple ports separated by commas or a range indicated by a hyphen.
        :param pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'EnclaveEndpointProtocol']]]] protocols: Protocols. Options specified by Endpoint Protocol Enum.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if endpoint_rule_name is not None:
            pulumi.set(__self__, "endpoint_rule_name", endpoint_rule_name)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Destination address. Can include multiple CIDR/IP Addresses or fqdn tags or fqdns (for community endpoint) separated by commas.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter(name="endpointRuleName")
    def endpoint_rule_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Endpoint Rule Name.
        """
        return pulumi.get(self, "endpoint_rule_name")

    @endpoint_rule_name.setter
    def endpoint_rule_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint_rule_name", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Port. Can include multiple ports separated by commas or a range indicated by a hyphen.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ports", value)

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'EnclaveEndpointProtocol']]]]]:
        """
        Protocols. Options specified by Endpoint Protocol Enum.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[_builtins.str, 'EnclaveEndpointProtocol']]]]]):
        pulumi.set(self, "protocols", value)


if not MYPY:
    class EnclaveVirtualNetworkModelArgsDict(TypedDict):
        """
        Enclave Virtual Network Properties
        """
        allow_subnet_communication: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow Subnet Communication.
        """
        custom_cidr_range: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom CIDR Range.
        """
        network_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network Name.
        """
        network_size: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network Size.
        """
        subnet_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetConfigurationArgsDict']]]]
        """
        Subnet Configurations.
        """
elif False:
    EnclaveVirtualNetworkModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnclaveVirtualNetworkModelArgs:
    def __init__(__self__, *,
                 allow_subnet_communication: Optional[pulumi.Input[_builtins.bool]] = None,
                 custom_cidr_range: Optional[pulumi.Input[_builtins.str]] = None,
                 network_name: Optional[pulumi.Input[_builtins.str]] = None,
                 network_size: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetConfigurationArgs']]]] = None):
        """
        Enclave Virtual Network Properties
        :param pulumi.Input[_builtins.bool] allow_subnet_communication: Allow Subnet Communication.
        :param pulumi.Input[_builtins.str] custom_cidr_range: Custom CIDR Range.
        :param pulumi.Input[_builtins.str] network_name: Network Name.
        :param pulumi.Input[_builtins.str] network_size: Network Size.
        :param pulumi.Input[Sequence[pulumi.Input['SubnetConfigurationArgs']]] subnet_configurations: Subnet Configurations.
        """
        if allow_subnet_communication is None:
            allow_subnet_communication = False
        if allow_subnet_communication is not None:
            pulumi.set(__self__, "allow_subnet_communication", allow_subnet_communication)
        if custom_cidr_range is not None:
            pulumi.set(__self__, "custom_cidr_range", custom_cidr_range)
        if network_name is not None:
            pulumi.set(__self__, "network_name", network_name)
        if network_size is not None:
            pulumi.set(__self__, "network_size", network_size)
        if subnet_configurations is not None:
            pulumi.set(__self__, "subnet_configurations", subnet_configurations)

    @_builtins.property
    @pulumi.getter(name="allowSubnetCommunication")
    def allow_subnet_communication(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow Subnet Communication.
        """
        return pulumi.get(self, "allow_subnet_communication")

    @allow_subnet_communication.setter
    def allow_subnet_communication(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_subnet_communication", value)

    @_builtins.property
    @pulumi.getter(name="customCidrRange")
    def custom_cidr_range(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom CIDR Range.
        """
        return pulumi.get(self, "custom_cidr_range")

    @custom_cidr_range.setter
    def custom_cidr_range(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_cidr_range", value)

    @_builtins.property
    @pulumi.getter(name="networkName")
    def network_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network Name.
        """
        return pulumi.get(self, "network_name")

    @network_name.setter
    def network_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_name", value)

    @_builtins.property
    @pulumi.getter(name="networkSize")
    def network_size(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network Size.
        """
        return pulumi.get(self, "network_size")

    @network_size.setter
    def network_size(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_size", value)

    @_builtins.property
    @pulumi.getter(name="subnetConfigurations")
    def subnet_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetConfigurationArgs']]]]:
        """
        Subnet Configurations.
        """
        return pulumi.get(self, "subnet_configurations")

    @subnet_configurations.setter
    def subnet_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetConfigurationArgs']]]]):
        pulumi.set(self, "subnet_configurations", value)


if not MYPY:
    class GovernedServiceItemArgsDict(TypedDict):
        """
        GovernedServiceItem Properties
        """
        service_id: pulumi.Input[Union[_builtins.str, 'ServiceIdentifier']]
        """
        Service ID
        """
        enforcement: NotRequired[pulumi.Input[Union[_builtins.str, 'Enforcement']]]
        """
        Initiative enforcement (Enabled or Disabled).
        """
        option: NotRequired[pulumi.Input[Union[_builtins.str, 'Option']]]
        """
        Governance option for this service (Allow, Deny, ExceptionOnly, or NotApplicable).
        """
        policy_action: NotRequired[pulumi.Input[Union[_builtins.str, 'PolicyAction']]]
        """
        Enforcement mode for policy. AuditOnly, Enforce, or None.
        """
elif False:
    GovernedServiceItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GovernedServiceItemArgs:
    def __init__(__self__, *,
                 service_id: pulumi.Input[Union[_builtins.str, 'ServiceIdentifier']],
                 enforcement: Optional[pulumi.Input[Union[_builtins.str, 'Enforcement']]] = None,
                 option: Optional[pulumi.Input[Union[_builtins.str, 'Option']]] = None,
                 policy_action: Optional[pulumi.Input[Union[_builtins.str, 'PolicyAction']]] = None):
        """
        GovernedServiceItem Properties
        :param pulumi.Input[Union[_builtins.str, 'ServiceIdentifier']] service_id: Service ID
        :param pulumi.Input[Union[_builtins.str, 'Enforcement']] enforcement: Initiative enforcement (Enabled or Disabled).
        :param pulumi.Input[Union[_builtins.str, 'Option']] option: Governance option for this service (Allow, Deny, ExceptionOnly, or NotApplicable).
        :param pulumi.Input[Union[_builtins.str, 'PolicyAction']] policy_action: Enforcement mode for policy. AuditOnly, Enforce, or None.
        """
        pulumi.set(__self__, "service_id", service_id)
        if enforcement is not None:
            pulumi.set(__self__, "enforcement", enforcement)
        if option is not None:
            pulumi.set(__self__, "option", option)
        if policy_action is not None:
            pulumi.set(__self__, "policy_action", policy_action)

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> pulumi.Input[Union[_builtins.str, 'ServiceIdentifier']]:
        """
        Service ID
        """
        return pulumi.get(self, "service_id")

    @service_id.setter
    def service_id(self, value: pulumi.Input[Union[_builtins.str, 'ServiceIdentifier']]):
        pulumi.set(self, "service_id", value)

    @_builtins.property
    @pulumi.getter
    def enforcement(self) -> Optional[pulumi.Input[Union[_builtins.str, 'Enforcement']]]:
        """
        Initiative enforcement (Enabled or Disabled).
        """
        return pulumi.get(self, "enforcement")

    @enforcement.setter
    def enforcement(self, value: Optional[pulumi.Input[Union[_builtins.str, 'Enforcement']]]):
        pulumi.set(self, "enforcement", value)

    @_builtins.property
    @pulumi.getter
    def option(self) -> Optional[pulumi.Input[Union[_builtins.str, 'Option']]]:
        """
        Governance option for this service (Allow, Deny, ExceptionOnly, or NotApplicable).
        """
        return pulumi.get(self, "option")

    @option.setter
    def option(self, value: Optional[pulumi.Input[Union[_builtins.str, 'Option']]]):
        pulumi.set(self, "option", value)

    @_builtins.property
    @pulumi.getter(name="policyAction")
    def policy_action(self) -> Optional[pulumi.Input[Union[_builtins.str, 'PolicyAction']]]:
        """
        Enforcement mode for policy. AuditOnly, Enforce, or None.
        """
        return pulumi.get(self, "policy_action")

    @policy_action.setter
    def policy_action(self, value: Optional[pulumi.Input[Union[_builtins.str, 'PolicyAction']]]):
        pulumi.set(self, "policy_action", value)


if not MYPY:
    class MaintenanceModeConfigurationModelArgsDict(TypedDict):
        """
        Maintenance Mode
        """
        mode: pulumi.Input[Union[_builtins.str, 'Mode']]
        """
        Current mode of Maintenance Mode Configuration
        """
        justification: NotRequired[pulumi.Input[Union[_builtins.str, 'Justification']]]
        """
        Justification for entering or exiting Maintenance Mode
        """
        principals: NotRequired[pulumi.Input[Sequence[pulumi.Input['PrincipalArgsDict']]]]
        """
        The user, group or service principal object affected by Maintenance Mode
        """
elif False:
    MaintenanceModeConfigurationModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceModeConfigurationModelArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[Union[_builtins.str, 'Mode']]] = None,
                 justification: Optional[pulumi.Input[Union[_builtins.str, 'Justification']]] = None,
                 principals: Optional[pulumi.Input[Sequence[pulumi.Input['PrincipalArgs']]]] = None):
        """
        Maintenance Mode
        :param pulumi.Input[Union[_builtins.str, 'Mode']] mode: Current mode of Maintenance Mode Configuration
        :param pulumi.Input[Union[_builtins.str, 'Justification']] justification: Justification for entering or exiting Maintenance Mode
        :param pulumi.Input[Sequence[pulumi.Input['PrincipalArgs']]] principals: The user, group or service principal object affected by Maintenance Mode
        """
        if mode is None:
            mode = 'Off'
        pulumi.set(__self__, "mode", mode)
        if justification is None:
            justification = 'Off'
        if justification is not None:
            pulumi.set(__self__, "justification", justification)
        if principals is not None:
            pulumi.set(__self__, "principals", principals)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[Union[_builtins.str, 'Mode']]:
        """
        Current mode of Maintenance Mode Configuration
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[Union[_builtins.str, 'Mode']]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def justification(self) -> Optional[pulumi.Input[Union[_builtins.str, 'Justification']]]:
        """
        Justification for entering or exiting Maintenance Mode
        """
        return pulumi.get(self, "justification")

    @justification.setter
    def justification(self, value: Optional[pulumi.Input[Union[_builtins.str, 'Justification']]]):
        pulumi.set(self, "justification", value)

    @_builtins.property
    @pulumi.getter
    def principals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PrincipalArgs']]]]:
        """
        The user, group or service principal object affected by Maintenance Mode
        """
        return pulumi.get(self, "principals")

    @principals.setter
    def principals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PrincipalArgs']]]]):
        pulumi.set(self, "principals", value)


if not MYPY:
    class ManagedServiceIdentityArgsDict(TypedDict):
        """
        Managed service identity (system assigned and/or user assigned identities)
        """
        type: pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']]
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    ManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class MandatoryApproverArgsDict(TypedDict):
        """
        Approver Metadata for approvals request.
        """
        approver_entra_id: pulumi.Input[_builtins.str]
        """
        EntraId of the approver
        """
elif False:
    MandatoryApproverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MandatoryApproverArgs:
    def __init__(__self__, *,
                 approver_entra_id: pulumi.Input[_builtins.str]):
        """
        Approver Metadata for approvals request.
        :param pulumi.Input[_builtins.str] approver_entra_id: EntraId of the approver
        """
        pulumi.set(__self__, "approver_entra_id", approver_entra_id)

    @_builtins.property
    @pulumi.getter(name="approverEntraId")
    def approver_entra_id(self) -> pulumi.Input[_builtins.str]:
        """
        EntraId of the approver
        """
        return pulumi.get(self, "approver_entra_id")

    @approver_entra_id.setter
    def approver_entra_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "approver_entra_id", value)


if not MYPY:
    class PrincipalArgsDict(TypedDict):
        """
        Principal for maintenance mode or role assignments
        """
        id: pulumi.Input[_builtins.str]
        """
        The object id associated with the principal
        """
        type: pulumi.Input[Union[_builtins.str, 'Type']]
        """
        The type of the object id. We currently allow users, groups, and service principals
        """
elif False:
    PrincipalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrincipalArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 type: pulumi.Input[Union[_builtins.str, 'Type']]):
        """
        Principal for maintenance mode or role assignments
        :param pulumi.Input[_builtins.str] id: The object id associated with the principal
        :param pulumi.Input[Union[_builtins.str, 'Type']] type: The type of the object id. We currently allow users, groups, and service principals
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The object id associated with the principal
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[_builtins.str, 'Type']]:
        """
        The type of the object id. We currently allow users, groups, and service principals
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[_builtins.str, 'Type']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RequestMetadataArgsDict(TypedDict):
        """
        Request Metadata for approvals request.
        """
        resource_action: pulumi.Input[_builtins.str]
        """
        Resource Action of the item being approved or declined.
        """
        approval_callback_payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        Payload to be sent upon any action on approval request
        """
        approval_callback_route: NotRequired[pulumi.Input[_builtins.str]]
        """
        Route name for the approval callback
        """
        approval_status: NotRequired[pulumi.Input[Union[_builtins.str, 'ApprovalStatus']]]
        """
        Status of the approval. Uses ApprovalStatus enum.
        """
elif False:
    RequestMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RequestMetadataArgs:
    def __init__(__self__, *,
                 resource_action: pulumi.Input[_builtins.str],
                 approval_callback_payload: Optional[pulumi.Input[_builtins.str]] = None,
                 approval_callback_route: Optional[pulumi.Input[_builtins.str]] = None,
                 approval_status: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalStatus']]] = None):
        """
        Request Metadata for approvals request.
        :param pulumi.Input[_builtins.str] resource_action: Resource Action of the item being approved or declined.
        :param pulumi.Input[_builtins.str] approval_callback_payload: Payload to be sent upon any action on approval request
        :param pulumi.Input[_builtins.str] approval_callback_route: Route name for the approval callback
        :param pulumi.Input[Union[_builtins.str, 'ApprovalStatus']] approval_status: Status of the approval. Uses ApprovalStatus enum.
        """
        pulumi.set(__self__, "resource_action", resource_action)
        if approval_callback_payload is not None:
            pulumi.set(__self__, "approval_callback_payload", approval_callback_payload)
        if approval_callback_route is not None:
            pulumi.set(__self__, "approval_callback_route", approval_callback_route)
        if approval_status is None:
            approval_status = 'Pending'
        if approval_status is not None:
            pulumi.set(__self__, "approval_status", approval_status)

    @_builtins.property
    @pulumi.getter(name="resourceAction")
    def resource_action(self) -> pulumi.Input[_builtins.str]:
        """
        Resource Action of the item being approved or declined.
        """
        return pulumi.get(self, "resource_action")

    @resource_action.setter
    def resource_action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_action", value)

    @_builtins.property
    @pulumi.getter(name="approvalCallbackPayload")
    def approval_callback_payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Payload to be sent upon any action on approval request
        """
        return pulumi.get(self, "approval_callback_payload")

    @approval_callback_payload.setter
    def approval_callback_payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "approval_callback_payload", value)

    @_builtins.property
    @pulumi.getter(name="approvalCallbackRoute")
    def approval_callback_route(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Route name for the approval callback
        """
        return pulumi.get(self, "approval_callback_route")

    @approval_callback_route.setter
    def approval_callback_route(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "approval_callback_route", value)

    @_builtins.property
    @pulumi.getter(name="approvalStatus")
    def approval_status(self) -> Optional[pulumi.Input[Union[_builtins.str, 'ApprovalStatus']]]:
        """
        Status of the approval. Uses ApprovalStatus enum.
        """
        return pulumi.get(self, "approval_status")

    @approval_status.setter
    def approval_status(self, value: Optional[pulumi.Input[Union[_builtins.str, 'ApprovalStatus']]]):
        pulumi.set(self, "approval_status", value)


if not MYPY:
    class RoleAssignmentItemArgsDict(TypedDict):
        """
        Role assignment item that indicates which principals should be assigned this role definition
        """
        role_definition_id: pulumi.Input[_builtins.str]
        """
        Role definition identifier
        """
        principals: NotRequired[pulumi.Input[Sequence[pulumi.Input['PrincipalArgsDict']]]]
        """
        List of principal IDs to which to assign this role definition
        """
elif False:
    RoleAssignmentItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoleAssignmentItemArgs:
    def __init__(__self__, *,
                 role_definition_id: pulumi.Input[_builtins.str],
                 principals: Optional[pulumi.Input[Sequence[pulumi.Input['PrincipalArgs']]]] = None):
        """
        Role assignment item that indicates which principals should be assigned this role definition
        :param pulumi.Input[_builtins.str] role_definition_id: Role definition identifier
        :param pulumi.Input[Sequence[pulumi.Input['PrincipalArgs']]] principals: List of principal IDs to which to assign this role definition
        """
        pulumi.set(__self__, "role_definition_id", role_definition_id)
        if principals is not None:
            pulumi.set(__self__, "principals", principals)

    @_builtins.property
    @pulumi.getter(name="roleDefinitionId")
    def role_definition_id(self) -> pulumi.Input[_builtins.str]:
        """
        Role definition identifier
        """
        return pulumi.get(self, "role_definition_id")

    @role_definition_id.setter
    def role_definition_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_definition_id", value)

    @_builtins.property
    @pulumi.getter
    def principals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PrincipalArgs']]]]:
        """
        List of principal IDs to which to assign this role definition
        """
        return pulumi.get(self, "principals")

    @principals.setter
    def principals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PrincipalArgs']]]]):
        pulumi.set(self, "principals", value)


if not MYPY:
    class SubnetConfigurationArgsDict(TypedDict):
        """
        Subnet Configuration
        """
        network_prefix_size: pulumi.Input[_builtins.int]
        """
        Network prefix size.
        """
        subnet_name: pulumi.Input[_builtins.str]
        """
        Subnet name.
        """
        subnet_delegation: NotRequired[pulumi.Input[_builtins.str]]
        """
        Subnet delegation.
        """
elif False:
    SubnetConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetConfigurationArgs:
    def __init__(__self__, *,
                 network_prefix_size: pulumi.Input[_builtins.int],
                 subnet_name: pulumi.Input[_builtins.str],
                 subnet_delegation: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Subnet Configuration
        :param pulumi.Input[_builtins.int] network_prefix_size: Network prefix size.
        :param pulumi.Input[_builtins.str] subnet_name: Subnet name.
        :param pulumi.Input[_builtins.str] subnet_delegation: Subnet delegation.
        """
        pulumi.set(__self__, "network_prefix_size", network_prefix_size)
        pulumi.set(__self__, "subnet_name", subnet_name)
        if subnet_delegation is not None:
            pulumi.set(__self__, "subnet_delegation", subnet_delegation)

    @_builtins.property
    @pulumi.getter(name="networkPrefixSize")
    def network_prefix_size(self) -> pulumi.Input[_builtins.int]:
        """
        Network prefix size.
        """
        return pulumi.get(self, "network_prefix_size")

    @network_prefix_size.setter
    def network_prefix_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "network_prefix_size", value)

    @_builtins.property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> pulumi.Input[_builtins.str]:
        """
        Subnet name.
        """
        return pulumi.get(self, "subnet_name")

    @subnet_name.setter
    def subnet_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_name", value)

    @_builtins.property
    @pulumi.getter(name="subnetDelegation")
    def subnet_delegation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Subnet delegation.
        """
        return pulumi.get(self, "subnet_delegation")

    @subnet_delegation.setter
    def subnet_delegation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_delegation", value)


if not MYPY:
    class TransitOptionParamsArgsDict(TypedDict):
        """
        TransitOptionParams Properties
        """
        remote_virtual_network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Transit Option Params remoteVirtualNetworkId.
        """
        scale_units: NotRequired[pulumi.Input[_builtins.float]]
        """
        Transit Option Params scaleUnits.
        """
elif False:
    TransitOptionParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransitOptionParamsArgs:
    def __init__(__self__, *,
                 remote_virtual_network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 scale_units: Optional[pulumi.Input[_builtins.float]] = None):
        """
        TransitOptionParams Properties
        :param pulumi.Input[_builtins.str] remote_virtual_network_id: Transit Option Params remoteVirtualNetworkId.
        :param pulumi.Input[_builtins.float] scale_units: Transit Option Params scaleUnits.
        """
        if remote_virtual_network_id is not None:
            pulumi.set(__self__, "remote_virtual_network_id", remote_virtual_network_id)
        if scale_units is not None:
            pulumi.set(__self__, "scale_units", scale_units)

    @_builtins.property
    @pulumi.getter(name="remoteVirtualNetworkId")
    def remote_virtual_network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Transit Option Params remoteVirtualNetworkId.
        """
        return pulumi.get(self, "remote_virtual_network_id")

    @remote_virtual_network_id.setter
    def remote_virtual_network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_virtual_network_id", value)

    @_builtins.property
    @pulumi.getter(name="scaleUnits")
    def scale_units(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Transit Option Params scaleUnits.
        """
        return pulumi.get(self, "scale_units")

    @scale_units.setter
    def scale_units(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "scale_units", value)


if not MYPY:
    class TransitOptionArgsDict(TypedDict):
        """
        TransitOption Properties
        """
        params: NotRequired[pulumi.Input['TransitOptionParamsArgsDict']]
        """
        Transit Option Params
        """
        type: NotRequired[pulumi.Input[Union[_builtins.str, 'TransitOptionType']]]
        """
        Transit Option Type.
        """
elif False:
    TransitOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransitOptionArgs:
    def __init__(__self__, *,
                 params: Optional[pulumi.Input['TransitOptionParamsArgs']] = None,
                 type: Optional[pulumi.Input[Union[_builtins.str, 'TransitOptionType']]] = None):
        """
        TransitOption Properties
        :param pulumi.Input['TransitOptionParamsArgs'] params: Transit Option Params
        :param pulumi.Input[Union[_builtins.str, 'TransitOptionType']] type: Transit Option Type.
        """
        if params is not None:
            pulumi.set(__self__, "params", params)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input['TransitOptionParamsArgs']]:
        """
        Transit Option Params
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input['TransitOptionParamsArgs']]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[_builtins.str, 'TransitOptionType']]]:
        """
        Transit Option Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[_builtins.str, 'TransitOptionType']]]):
        pulumi.set(self, "type", value)


