# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'AccessControlListActionArgs',
    'AccessControlListActionArgsDict',
    'AccessControlListMatchConditionArgs',
    'AccessControlListMatchConditionArgsDict',
    'AccessControlListMatchConfigurationArgs',
    'AccessControlListMatchConfigurationArgsDict',
    'AccessControlListPortConditionArgs',
    'AccessControlListPortConditionArgsDict',
    'ActionIpCommunityPropertiesArgs',
    'ActionIpCommunityPropertiesArgsDict',
    'ActionIpExtendedCommunityPropertiesArgs',
    'ActionIpExtendedCommunityPropertiesArgsDict',
    'AggregateRouteConfigurationArgs',
    'AggregateRouteConfigurationArgsDict',
    'AggregateRouteArgs',
    'AggregateRouteArgsDict',
    'BfdConfigurationArgs',
    'BfdConfigurationArgsDict',
    'CommonDynamicMatchConfigurationArgs',
    'CommonDynamicMatchConfigurationArgsDict',
    'ConnectedSubnetRoutePolicyArgs',
    'ConnectedSubnetRoutePolicyArgsDict',
    'ConnectedSubnetArgs',
    'ConnectedSubnetArgsDict',
    'ExportRoutePolicyInformationArgs',
    'ExportRoutePolicyInformationArgsDict',
    'ExportRoutePolicyArgs',
    'ExportRoutePolicyArgsDict',
    'ExpressRouteConnectionInformationArgs',
    'ExpressRouteConnectionInformationArgsDict',
    'ExternalNetworkPropertiesOptionAPropertiesArgs',
    'ExternalNetworkPropertiesOptionAPropertiesArgsDict',
    'FabricOptionBPropertiesArgs',
    'FabricOptionBPropertiesArgsDict',
    'ImportRoutePolicyInformationArgs',
    'ImportRoutePolicyInformationArgsDict',
    'ImportRoutePolicyArgs',
    'ImportRoutePolicyArgsDict',
    'InternalNetworkPropertiesBgpConfigurationArgs',
    'InternalNetworkPropertiesBgpConfigurationArgsDict',
    'InternalNetworkPropertiesStaticRouteConfigurationArgs',
    'InternalNetworkPropertiesStaticRouteConfigurationArgsDict',
    'IpCommunityIdListArgs',
    'IpCommunityIdListArgsDict',
    'IpCommunityRuleArgs',
    'IpCommunityRuleArgsDict',
    'IpExtendedCommunityIdListArgs',
    'IpExtendedCommunityIdListArgsDict',
    'IpExtendedCommunityRuleArgs',
    'IpExtendedCommunityRuleArgsDict',
    'IpGroupPropertiesArgs',
    'IpGroupPropertiesArgsDict',
    'IpMatchConditionArgs',
    'IpMatchConditionArgsDict',
    'IpPrefixRuleArgs',
    'IpPrefixRuleArgsDict',
    'IsolationDomainPropertiesArgs',
    'IsolationDomainPropertiesArgsDict',
    'L3ExportRoutePolicyArgs',
    'L3ExportRoutePolicyArgsDict',
    'L3OptionBPropertiesArgs',
    'L3OptionBPropertiesArgsDict',
    'Layer2ConfigurationArgs',
    'Layer2ConfigurationArgsDict',
    'ManagedResourceGroupConfigurationArgs',
    'ManagedResourceGroupConfigurationArgsDict',
    'ManagementNetworkConfigurationPropertiesArgs',
    'ManagementNetworkConfigurationPropertiesArgsDict',
    'NeighborAddressArgs',
    'NeighborAddressArgsDict',
    'NeighborGroupDestinationArgs',
    'NeighborGroupDestinationArgsDict',
    'NetworkTapPropertiesDestinationsArgs',
    'NetworkTapPropertiesDestinationsArgsDict',
    'NetworkTapRuleActionArgs',
    'NetworkTapRuleActionArgsDict',
    'NetworkTapRuleMatchConditionArgs',
    'NetworkTapRuleMatchConditionArgsDict',
    'NetworkTapRuleMatchConfigurationArgs',
    'NetworkTapRuleMatchConfigurationArgsDict',
    'NetworkToNetworkInterconnectPropertiesOptionBLayer3ConfigurationArgs',
    'NetworkToNetworkInterconnectPropertiesOptionBLayer3ConfigurationArgsDict',
    'NpbStaticRouteConfigurationArgs',
    'NpbStaticRouteConfigurationArgsDict',
    'PortConditionArgs',
    'PortConditionArgsDict',
    'PortGroupPropertiesArgs',
    'PortGroupPropertiesArgsDict',
    'RoutePolicyStatementPropertiesArgs',
    'RoutePolicyStatementPropertiesArgsDict',
    'RouteTargetInformationArgs',
    'RouteTargetInformationArgsDict',
    'RulePropertiesArgs',
    'RulePropertiesArgsDict',
    'StatementActionPropertiesArgs',
    'StatementActionPropertiesArgsDict',
    'StatementConditionPropertiesArgs',
    'StatementConditionPropertiesArgsDict',
    'StaticRoutePropertiesArgs',
    'StaticRoutePropertiesArgsDict',
    'TerminalServerConfigurationArgs',
    'TerminalServerConfigurationArgsDict',
    'VlanGroupPropertiesArgs',
    'VlanGroupPropertiesArgsDict',
    'VlanMatchConditionArgs',
    'VlanMatchConditionArgsDict',
    'VpnConfigurationPropertiesOptionAPropertiesArgs',
    'VpnConfigurationPropertiesOptionAPropertiesArgsDict',
    'VpnConfigurationPropertiesArgs',
    'VpnConfigurationPropertiesArgsDict',
]

MYPY = False

if not MYPY:
    class AccessControlListActionArgsDict(TypedDict):
        """
        Action that need to performed.
        """
        counter_name: NotRequired[pulumi.Input[str]]
        """
        Name of the counter block to get match count information.
        """
        type: NotRequired[pulumi.Input[Union[str, 'AclActionType']]]
        """
        Type of actions that can be performed.
        """
elif False:
    AccessControlListActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessControlListActionArgs:
    def __init__(__self__, *,
                 counter_name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[Union[str, 'AclActionType']]] = None):
        """
        Action that need to performed.
        :param pulumi.Input[str] counter_name: Name of the counter block to get match count information.
        :param pulumi.Input[Union[str, 'AclActionType']] type: Type of actions that can be performed.
        """
        if counter_name is not None:
            pulumi.set(__self__, "counter_name", counter_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="counterName")
    def counter_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the counter block to get match count information.
        """
        return pulumi.get(self, "counter_name")

    @counter_name.setter
    def counter_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "counter_name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'AclActionType']]]:
        """
        Type of actions that can be performed.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'AclActionType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AccessControlListMatchConditionArgsDict(TypedDict):
        """
        Defines the match condition that is supported to filter the traffic.
        """
        dscp_markings: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of DSCP Markings that need to be matched.
        """
        ether_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of ether type values that need to be matched.
        """
        fragments: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of IP fragment packets that need to be matched.
        """
        ip_condition: NotRequired[pulumi.Input['IpMatchConditionArgsDict']]
        """
        IP condition that needs to be matched.
        """
        ip_lengths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of IP Lengths that need to be matched.
        """
        port_condition: NotRequired[pulumi.Input['AccessControlListPortConditionArgsDict']]
        """
        Defines the port condition that needs to be matched.
        """
        protocol_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of the protocols that need to be matched.
        """
        ttl_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of TTL [Time To Live] values that need to be matched.
        """
        vlan_match_condition: NotRequired[pulumi.Input['VlanMatchConditionArgsDict']]
        """
        Vlan match condition that needs to be matched.
        """
elif False:
    AccessControlListMatchConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessControlListMatchConditionArgs:
    def __init__(__self__, *,
                 dscp_markings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ether_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fragments: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip_condition: Optional[pulumi.Input['IpMatchConditionArgs']] = None,
                 ip_lengths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 port_condition: Optional[pulumi.Input['AccessControlListPortConditionArgs']] = None,
                 protocol_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ttl_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vlan_match_condition: Optional[pulumi.Input['VlanMatchConditionArgs']] = None):
        """
        Defines the match condition that is supported to filter the traffic.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dscp_markings: List of DSCP Markings that need to be matched.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ether_types: List of ether type values that need to be matched.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fragments: List of IP fragment packets that need to be matched.
        :param pulumi.Input['IpMatchConditionArgs'] ip_condition: IP condition that needs to be matched.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_lengths: List of IP Lengths that need to be matched.
        :param pulumi.Input['AccessControlListPortConditionArgs'] port_condition: Defines the port condition that needs to be matched.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] protocol_types: List of the protocols that need to be matched.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ttl_values: List of TTL [Time To Live] values that need to be matched.
        :param pulumi.Input['VlanMatchConditionArgs'] vlan_match_condition: Vlan match condition that needs to be matched.
        """
        if dscp_markings is not None:
            pulumi.set(__self__, "dscp_markings", dscp_markings)
        if ether_types is not None:
            pulumi.set(__self__, "ether_types", ether_types)
        if fragments is not None:
            pulumi.set(__self__, "fragments", fragments)
        if ip_condition is not None:
            pulumi.set(__self__, "ip_condition", ip_condition)
        if ip_lengths is not None:
            pulumi.set(__self__, "ip_lengths", ip_lengths)
        if port_condition is not None:
            pulumi.set(__self__, "port_condition", port_condition)
        if protocol_types is not None:
            pulumi.set(__self__, "protocol_types", protocol_types)
        if ttl_values is not None:
            pulumi.set(__self__, "ttl_values", ttl_values)
        if vlan_match_condition is not None:
            pulumi.set(__self__, "vlan_match_condition", vlan_match_condition)

    @property
    @pulumi.getter(name="dscpMarkings")
    def dscp_markings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of DSCP Markings that need to be matched.
        """
        return pulumi.get(self, "dscp_markings")

    @dscp_markings.setter
    def dscp_markings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dscp_markings", value)

    @property
    @pulumi.getter(name="etherTypes")
    def ether_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of ether type values that need to be matched.
        """
        return pulumi.get(self, "ether_types")

    @ether_types.setter
    def ether_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ether_types", value)

    @property
    @pulumi.getter
    def fragments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IP fragment packets that need to be matched.
        """
        return pulumi.get(self, "fragments")

    @fragments.setter
    def fragments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fragments", value)

    @property
    @pulumi.getter(name="ipCondition")
    def ip_condition(self) -> Optional[pulumi.Input['IpMatchConditionArgs']]:
        """
        IP condition that needs to be matched.
        """
        return pulumi.get(self, "ip_condition")

    @ip_condition.setter
    def ip_condition(self, value: Optional[pulumi.Input['IpMatchConditionArgs']]):
        pulumi.set(self, "ip_condition", value)

    @property
    @pulumi.getter(name="ipLengths")
    def ip_lengths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IP Lengths that need to be matched.
        """
        return pulumi.get(self, "ip_lengths")

    @ip_lengths.setter
    def ip_lengths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_lengths", value)

    @property
    @pulumi.getter(name="portCondition")
    def port_condition(self) -> Optional[pulumi.Input['AccessControlListPortConditionArgs']]:
        """
        Defines the port condition that needs to be matched.
        """
        return pulumi.get(self, "port_condition")

    @port_condition.setter
    def port_condition(self, value: Optional[pulumi.Input['AccessControlListPortConditionArgs']]):
        pulumi.set(self, "port_condition", value)

    @property
    @pulumi.getter(name="protocolTypes")
    def protocol_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of the protocols that need to be matched.
        """
        return pulumi.get(self, "protocol_types")

    @protocol_types.setter
    def protocol_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "protocol_types", value)

    @property
    @pulumi.getter(name="ttlValues")
    def ttl_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of TTL [Time To Live] values that need to be matched.
        """
        return pulumi.get(self, "ttl_values")

    @ttl_values.setter
    def ttl_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ttl_values", value)

    @property
    @pulumi.getter(name="vlanMatchCondition")
    def vlan_match_condition(self) -> Optional[pulumi.Input['VlanMatchConditionArgs']]:
        """
        Vlan match condition that needs to be matched.
        """
        return pulumi.get(self, "vlan_match_condition")

    @vlan_match_condition.setter
    def vlan_match_condition(self, value: Optional[pulumi.Input['VlanMatchConditionArgs']]):
        pulumi.set(self, "vlan_match_condition", value)


if not MYPY:
    class AccessControlListMatchConfigurationArgsDict(TypedDict):
        """
        Defines the match configuration that are supported to filter the traffic.
        """
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessControlListActionArgsDict']]]]
        """
        List of actions that need to be performed for the matched conditions.
        """
        ip_address_type: NotRequired[pulumi.Input[Union[str, 'IPAddressType']]]
        """
        Type of IP Address. IPv4 or IPv6
        """
        match_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessControlListMatchConditionArgsDict']]]]
        """
        List of the match conditions.
        """
        match_configuration_name: NotRequired[pulumi.Input[str]]
        """
        The name of the match configuration.
        """
        sequence_number: NotRequired[pulumi.Input[float]]
        """
        Sequence Number of the match configuration.
        """
elif False:
    AccessControlListMatchConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessControlListMatchConfigurationArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input['AccessControlListActionArgs']]]] = None,
                 ip_address_type: Optional[pulumi.Input[Union[str, 'IPAddressType']]] = None,
                 match_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['AccessControlListMatchConditionArgs']]]] = None,
                 match_configuration_name: Optional[pulumi.Input[str]] = None,
                 sequence_number: Optional[pulumi.Input[float]] = None):
        """
        Defines the match configuration that are supported to filter the traffic.
        :param pulumi.Input[Sequence[pulumi.Input['AccessControlListActionArgs']]] actions: List of actions that need to be performed for the matched conditions.
        :param pulumi.Input[Union[str, 'IPAddressType']] ip_address_type: Type of IP Address. IPv4 or IPv6
        :param pulumi.Input[Sequence[pulumi.Input['AccessControlListMatchConditionArgs']]] match_conditions: List of the match conditions.
        :param pulumi.Input[str] match_configuration_name: The name of the match configuration.
        :param pulumi.Input[float] sequence_number: Sequence Number of the match configuration.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)
        if match_conditions is not None:
            pulumi.set(__self__, "match_conditions", match_conditions)
        if match_configuration_name is not None:
            pulumi.set(__self__, "match_configuration_name", match_configuration_name)
        if sequence_number is not None:
            pulumi.set(__self__, "sequence_number", sequence_number)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessControlListActionArgs']]]]:
        """
        List of actions that need to be performed for the matched conditions.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessControlListActionArgs']]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[pulumi.Input[Union[str, 'IPAddressType']]]:
        """
        Type of IP Address. IPv4 or IPv6
        """
        return pulumi.get(self, "ip_address_type")

    @ip_address_type.setter
    def ip_address_type(self, value: Optional[pulumi.Input[Union[str, 'IPAddressType']]]):
        pulumi.set(self, "ip_address_type", value)

    @property
    @pulumi.getter(name="matchConditions")
    def match_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessControlListMatchConditionArgs']]]]:
        """
        List of the match conditions.
        """
        return pulumi.get(self, "match_conditions")

    @match_conditions.setter
    def match_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessControlListMatchConditionArgs']]]]):
        pulumi.set(self, "match_conditions", value)

    @property
    @pulumi.getter(name="matchConfigurationName")
    def match_configuration_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the match configuration.
        """
        return pulumi.get(self, "match_configuration_name")

    @match_configuration_name.setter
    def match_configuration_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_configuration_name", value)

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> Optional[pulumi.Input[float]]:
        """
        Sequence Number of the match configuration.
        """
        return pulumi.get(self, "sequence_number")

    @sequence_number.setter
    def sequence_number(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "sequence_number", value)


if not MYPY:
    class AccessControlListPortConditionArgsDict(TypedDict):
        """
        Defines the port condition that needs to be matched.
        """
        layer4_protocol: pulumi.Input[Union[str, 'Layer4Protocol']]
        """
        Layer4 protocol type that needs to be matched.
        """
        flags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of protocol flags that need to be matched. Example: established | initial | <List-of-TCP-flags>. List of eligible TCP Flags are ack, fin, not-ack, not-fin, not-psh, not-rst, not-syn, not-urg, psh, rst, syn, urg
        """
        port_group_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of the port Group Names that need to be matched.
        """
        port_type: NotRequired[pulumi.Input[Union[str, 'PortType']]]
        """
        Port type that needs to be matched.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of the Ports that need to be matched.
        """
elif False:
    AccessControlListPortConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessControlListPortConditionArgs:
    def __init__(__self__, *,
                 layer4_protocol: pulumi.Input[Union[str, 'Layer4Protocol']],
                 flags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 port_group_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 port_type: Optional[pulumi.Input[Union[str, 'PortType']]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Defines the port condition that needs to be matched.
        :param pulumi.Input[Union[str, 'Layer4Protocol']] layer4_protocol: Layer4 protocol type that needs to be matched.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] flags: List of protocol flags that need to be matched. Example: established | initial | <List-of-TCP-flags>. List of eligible TCP Flags are ack, fin, not-ack, not-fin, not-psh, not-rst, not-syn, not-urg, psh, rst, syn, urg
        :param pulumi.Input[Sequence[pulumi.Input[str]]] port_group_names: List of the port Group Names that need to be matched.
        :param pulumi.Input[Union[str, 'PortType']] port_type: Port type that needs to be matched.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ports: List of the Ports that need to be matched.
        """
        pulumi.set(__self__, "layer4_protocol", layer4_protocol)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if port_group_names is not None:
            pulumi.set(__self__, "port_group_names", port_group_names)
        if port_type is not None:
            pulumi.set(__self__, "port_type", port_type)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter(name="layer4Protocol")
    def layer4_protocol(self) -> pulumi.Input[Union[str, 'Layer4Protocol']]:
        """
        Layer4 protocol type that needs to be matched.
        """
        return pulumi.get(self, "layer4_protocol")

    @layer4_protocol.setter
    def layer4_protocol(self, value: pulumi.Input[Union[str, 'Layer4Protocol']]):
        pulumi.set(self, "layer4_protocol", value)

    @property
    @pulumi.getter
    def flags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of protocol flags that need to be matched. Example: established | initial | <List-of-TCP-flags>. List of eligible TCP Flags are ack, fin, not-ack, not-fin, not-psh, not-rst, not-syn, not-urg, psh, rst, syn, urg
        """
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "flags", value)

    @property
    @pulumi.getter(name="portGroupNames")
    def port_group_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of the port Group Names that need to be matched.
        """
        return pulumi.get(self, "port_group_names")

    @port_group_names.setter
    def port_group_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "port_group_names", value)

    @property
    @pulumi.getter(name="portType")
    def port_type(self) -> Optional[pulumi.Input[Union[str, 'PortType']]]:
        """
        Port type that needs to be matched.
        """
        return pulumi.get(self, "port_type")

    @port_type.setter
    def port_type(self, value: Optional[pulumi.Input[Union[str, 'PortType']]]):
        pulumi.set(self, "port_type", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of the Ports that need to be matched.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class ActionIpCommunityPropertiesArgsDict(TypedDict):
        """
        IP Community Properties.
        """
        add: NotRequired[pulumi.Input['IpCommunityIdListArgsDict']]
        """
        List of IP Community IDs.
        """
        delete: NotRequired[pulumi.Input['IpCommunityIdListArgsDict']]
        """
        List of IP Community IDs.
        """
        set: NotRequired[pulumi.Input['IpCommunityIdListArgsDict']]
        """
        List of IP Community IDs.
        """
elif False:
    ActionIpCommunityPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionIpCommunityPropertiesArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input['IpCommunityIdListArgs']] = None,
                 delete: Optional[pulumi.Input['IpCommunityIdListArgs']] = None,
                 set: Optional[pulumi.Input['IpCommunityIdListArgs']] = None):
        """
        IP Community Properties.
        :param pulumi.Input['IpCommunityIdListArgs'] add: List of IP Community IDs.
        :param pulumi.Input['IpCommunityIdListArgs'] delete: List of IP Community IDs.
        :param pulumi.Input['IpCommunityIdListArgs'] set: List of IP Community IDs.
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input['IpCommunityIdListArgs']]:
        """
        List of IP Community IDs.
        """
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input['IpCommunityIdListArgs']]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input['IpCommunityIdListArgs']]:
        """
        List of IP Community IDs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input['IpCommunityIdListArgs']]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input['IpCommunityIdListArgs']]:
        """
        List of IP Community IDs.
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input['IpCommunityIdListArgs']]):
        pulumi.set(self, "set", value)


if not MYPY:
    class ActionIpExtendedCommunityPropertiesArgsDict(TypedDict):
        """
        IP Extended Community Properties.
        """
        add: NotRequired[pulumi.Input['IpExtendedCommunityIdListArgsDict']]
        """
        List of IP Extended Community IDs.
        """
        delete: NotRequired[pulumi.Input['IpExtendedCommunityIdListArgsDict']]
        """
        List of IP Extended Community IDs.
        """
        set: NotRequired[pulumi.Input['IpExtendedCommunityIdListArgsDict']]
        """
        List of IP Extended Community IDs.
        """
elif False:
    ActionIpExtendedCommunityPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionIpExtendedCommunityPropertiesArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input['IpExtendedCommunityIdListArgs']] = None,
                 delete: Optional[pulumi.Input['IpExtendedCommunityIdListArgs']] = None,
                 set: Optional[pulumi.Input['IpExtendedCommunityIdListArgs']] = None):
        """
        IP Extended Community Properties.
        :param pulumi.Input['IpExtendedCommunityIdListArgs'] add: List of IP Extended Community IDs.
        :param pulumi.Input['IpExtendedCommunityIdListArgs'] delete: List of IP Extended Community IDs.
        :param pulumi.Input['IpExtendedCommunityIdListArgs'] set: List of IP Extended Community IDs.
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input['IpExtendedCommunityIdListArgs']]:
        """
        List of IP Extended Community IDs.
        """
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input['IpExtendedCommunityIdListArgs']]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input['IpExtendedCommunityIdListArgs']]:
        """
        List of IP Extended Community IDs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input['IpExtendedCommunityIdListArgs']]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input['IpExtendedCommunityIdListArgs']]:
        """
        List of IP Extended Community IDs.
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input['IpExtendedCommunityIdListArgs']]):
        pulumi.set(self, "set", value)


if not MYPY:
    class AggregateRouteConfigurationArgsDict(TypedDict):
        """
        List of IPv4 and IPv6 aggregate routes.
        """
        ipv4_routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AggregateRouteArgsDict']]]]
        """
        List of IPv4 Route prefixes.
        """
        ipv6_routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AggregateRouteArgsDict']]]]
        """
        List of Ipv6Routes prefixes.
        """
elif False:
    AggregateRouteConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AggregateRouteConfigurationArgs:
    def __init__(__self__, *,
                 ipv4_routes: Optional[pulumi.Input[Sequence[pulumi.Input['AggregateRouteArgs']]]] = None,
                 ipv6_routes: Optional[pulumi.Input[Sequence[pulumi.Input['AggregateRouteArgs']]]] = None):
        """
        List of IPv4 and IPv6 aggregate routes.
        :param pulumi.Input[Sequence[pulumi.Input['AggregateRouteArgs']]] ipv4_routes: List of IPv4 Route prefixes.
        :param pulumi.Input[Sequence[pulumi.Input['AggregateRouteArgs']]] ipv6_routes: List of Ipv6Routes prefixes.
        """
        if ipv4_routes is not None:
            pulumi.set(__self__, "ipv4_routes", ipv4_routes)
        if ipv6_routes is not None:
            pulumi.set(__self__, "ipv6_routes", ipv6_routes)

    @property
    @pulumi.getter(name="ipv4Routes")
    def ipv4_routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AggregateRouteArgs']]]]:
        """
        List of IPv4 Route prefixes.
        """
        return pulumi.get(self, "ipv4_routes")

    @ipv4_routes.setter
    def ipv4_routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AggregateRouteArgs']]]]):
        pulumi.set(self, "ipv4_routes", value)

    @property
    @pulumi.getter(name="ipv6Routes")
    def ipv6_routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AggregateRouteArgs']]]]:
        """
        List of Ipv6Routes prefixes.
        """
        return pulumi.get(self, "ipv6_routes")

    @ipv6_routes.setter
    def ipv6_routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AggregateRouteArgs']]]]):
        pulumi.set(self, "ipv6_routes", value)


if not MYPY:
    class AggregateRouteArgsDict(TypedDict):
        """
        aggregateIpv4Route model.
        """
        prefix: pulumi.Input[str]
        """
        IPv4 Prefix of the aggregate Ipv4Route.
        """
elif False:
    AggregateRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AggregateRouteArgs:
    def __init__(__self__, *,
                 prefix: pulumi.Input[str]):
        """
        aggregateIpv4Route model.
        :param pulumi.Input[str] prefix: IPv4 Prefix of the aggregate Ipv4Route.
        """
        pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def prefix(self) -> pulumi.Input[str]:
        """
        IPv4 Prefix of the aggregate Ipv4Route.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class BfdConfigurationArgsDict(TypedDict):
        """
        BFD configuration properties
        """
        interval_in_milli_seconds: NotRequired[pulumi.Input[int]]
        """
        Interval in milliseconds. Example: 300.
        """
        multiplier: NotRequired[pulumi.Input[int]]
        """
        Multiplier for the Bfd Configuration. Example: 5.
        """
elif False:
    BfdConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BfdConfigurationArgs:
    def __init__(__self__, *,
                 interval_in_milli_seconds: Optional[pulumi.Input[int]] = None,
                 multiplier: Optional[pulumi.Input[int]] = None):
        """
        BFD configuration properties
        :param pulumi.Input[int] interval_in_milli_seconds: Interval in milliseconds. Example: 300.
        :param pulumi.Input[int] multiplier: Multiplier for the Bfd Configuration. Example: 5.
        """
        if interval_in_milli_seconds is None:
            interval_in_milli_seconds = 300
        if interval_in_milli_seconds is not None:
            pulumi.set(__self__, "interval_in_milli_seconds", interval_in_milli_seconds)
        if multiplier is None:
            multiplier = 5
        if multiplier is not None:
            pulumi.set(__self__, "multiplier", multiplier)

    @property
    @pulumi.getter(name="intervalInMilliSeconds")
    def interval_in_milli_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Interval in milliseconds. Example: 300.
        """
        return pulumi.get(self, "interval_in_milli_seconds")

    @interval_in_milli_seconds.setter
    def interval_in_milli_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval_in_milli_seconds", value)

    @property
    @pulumi.getter
    def multiplier(self) -> Optional[pulumi.Input[int]]:
        """
        Multiplier for the Bfd Configuration. Example: 5.
        """
        return pulumi.get(self, "multiplier")

    @multiplier.setter
    def multiplier(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "multiplier", value)


if not MYPY:
    class CommonDynamicMatchConfigurationArgsDict(TypedDict):
        """
        Dynamic match configuration object.
        """
        ip_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['IpGroupPropertiesArgsDict']]]]
        """
        List of IP Groups.
        """
        port_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['PortGroupPropertiesArgsDict']]]]
        """
        List of the port groups.
        """
        vlan_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['VlanGroupPropertiesArgsDict']]]]
        """
        List of vlan groups.
        """
elif False:
    CommonDynamicMatchConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CommonDynamicMatchConfigurationArgs:
    def __init__(__self__, *,
                 ip_groups: Optional[pulumi.Input[Sequence[pulumi.Input['IpGroupPropertiesArgs']]]] = None,
                 port_groups: Optional[pulumi.Input[Sequence[pulumi.Input['PortGroupPropertiesArgs']]]] = None,
                 vlan_groups: Optional[pulumi.Input[Sequence[pulumi.Input['VlanGroupPropertiesArgs']]]] = None):
        """
        Dynamic match configuration object.
        :param pulumi.Input[Sequence[pulumi.Input['IpGroupPropertiesArgs']]] ip_groups: List of IP Groups.
        :param pulumi.Input[Sequence[pulumi.Input['PortGroupPropertiesArgs']]] port_groups: List of the port groups.
        :param pulumi.Input[Sequence[pulumi.Input['VlanGroupPropertiesArgs']]] vlan_groups: List of vlan groups.
        """
        if ip_groups is not None:
            pulumi.set(__self__, "ip_groups", ip_groups)
        if port_groups is not None:
            pulumi.set(__self__, "port_groups", port_groups)
        if vlan_groups is not None:
            pulumi.set(__self__, "vlan_groups", vlan_groups)

    @property
    @pulumi.getter(name="ipGroups")
    def ip_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IpGroupPropertiesArgs']]]]:
        """
        List of IP Groups.
        """
        return pulumi.get(self, "ip_groups")

    @ip_groups.setter
    def ip_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IpGroupPropertiesArgs']]]]):
        pulumi.set(self, "ip_groups", value)

    @property
    @pulumi.getter(name="portGroups")
    def port_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PortGroupPropertiesArgs']]]]:
        """
        List of the port groups.
        """
        return pulumi.get(self, "port_groups")

    @port_groups.setter
    def port_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PortGroupPropertiesArgs']]]]):
        pulumi.set(self, "port_groups", value)

    @property
    @pulumi.getter(name="vlanGroups")
    def vlan_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VlanGroupPropertiesArgs']]]]:
        """
        List of vlan groups.
        """
        return pulumi.get(self, "vlan_groups")

    @vlan_groups.setter
    def vlan_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VlanGroupPropertiesArgs']]]]):
        pulumi.set(self, "vlan_groups", value)


if not MYPY:
    class ConnectedSubnetRoutePolicyArgsDict(TypedDict):
        """
        Connected Subnet Route Policy properties.
        """
        export_route_policy: NotRequired[pulumi.Input['L3ExportRoutePolicyArgsDict']]
        """
        Array of ARM Resource ID of the RoutePolicies.
        """
        export_route_policy_id: NotRequired[pulumi.Input[str]]
        """
        ARM Resource ID of the Route Policy. This is used for the backward compatibility.
        """
elif False:
    ConnectedSubnetRoutePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectedSubnetRoutePolicyArgs:
    def __init__(__self__, *,
                 export_route_policy: Optional[pulumi.Input['L3ExportRoutePolicyArgs']] = None,
                 export_route_policy_id: Optional[pulumi.Input[str]] = None):
        """
        Connected Subnet Route Policy properties.
        :param pulumi.Input['L3ExportRoutePolicyArgs'] export_route_policy: Array of ARM Resource ID of the RoutePolicies.
        :param pulumi.Input[str] export_route_policy_id: ARM Resource ID of the Route Policy. This is used for the backward compatibility.
        """
        if export_route_policy is not None:
            pulumi.set(__self__, "export_route_policy", export_route_policy)
        if export_route_policy_id is not None:
            pulumi.set(__self__, "export_route_policy_id", export_route_policy_id)

    @property
    @pulumi.getter(name="exportRoutePolicy")
    def export_route_policy(self) -> Optional[pulumi.Input['L3ExportRoutePolicyArgs']]:
        """
        Array of ARM Resource ID of the RoutePolicies.
        """
        return pulumi.get(self, "export_route_policy")

    @export_route_policy.setter
    def export_route_policy(self, value: Optional[pulumi.Input['L3ExportRoutePolicyArgs']]):
        pulumi.set(self, "export_route_policy", value)

    @property
    @pulumi.getter(name="exportRoutePolicyId")
    def export_route_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM Resource ID of the Route Policy. This is used for the backward compatibility.
        """
        return pulumi.get(self, "export_route_policy_id")

    @export_route_policy_id.setter
    def export_route_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "export_route_policy_id", value)


if not MYPY:
    class ConnectedSubnetArgsDict(TypedDict):
        """
        Connected Subnet properties.
        """
        prefix: pulumi.Input[str]
        """
        Prefix of the Connected Subnet.
        """
        annotation: NotRequired[pulumi.Input[str]]
        """
        Switch configuration description.
        """
elif False:
    ConnectedSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectedSubnetArgs:
    def __init__(__self__, *,
                 prefix: pulumi.Input[str],
                 annotation: Optional[pulumi.Input[str]] = None):
        """
        Connected Subnet properties.
        :param pulumi.Input[str] prefix: Prefix of the Connected Subnet.
        :param pulumi.Input[str] annotation: Switch configuration description.
        """
        pulumi.set(__self__, "prefix", prefix)
        if annotation is not None:
            pulumi.set(__self__, "annotation", annotation)

    @property
    @pulumi.getter
    def prefix(self) -> pulumi.Input[str]:
        """
        Prefix of the Connected Subnet.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def annotation(self) -> Optional[pulumi.Input[str]]:
        """
        Switch configuration description.
        """
        return pulumi.get(self, "annotation")

    @annotation.setter
    def annotation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "annotation", value)


if not MYPY:
    class ExportRoutePolicyInformationArgsDict(TypedDict):
        """
        Export Route Policy Configuration.
        """
        export_ipv4_route_policy_id: NotRequired[pulumi.Input[str]]
        """
        Export IPv4 Route Policy Id.
        """
        export_ipv6_route_policy_id: NotRequired[pulumi.Input[str]]
        """
        Export IPv6 Route Policy Id.
        """
elif False:
    ExportRoutePolicyInformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExportRoutePolicyInformationArgs:
    def __init__(__self__, *,
                 export_ipv4_route_policy_id: Optional[pulumi.Input[str]] = None,
                 export_ipv6_route_policy_id: Optional[pulumi.Input[str]] = None):
        """
        Export Route Policy Configuration.
        :param pulumi.Input[str] export_ipv4_route_policy_id: Export IPv4 Route Policy Id.
        :param pulumi.Input[str] export_ipv6_route_policy_id: Export IPv6 Route Policy Id.
        """
        if export_ipv4_route_policy_id is not None:
            pulumi.set(__self__, "export_ipv4_route_policy_id", export_ipv4_route_policy_id)
        if export_ipv6_route_policy_id is not None:
            pulumi.set(__self__, "export_ipv6_route_policy_id", export_ipv6_route_policy_id)

    @property
    @pulumi.getter(name="exportIpv4RoutePolicyId")
    def export_ipv4_route_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        Export IPv4 Route Policy Id.
        """
        return pulumi.get(self, "export_ipv4_route_policy_id")

    @export_ipv4_route_policy_id.setter
    def export_ipv4_route_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "export_ipv4_route_policy_id", value)

    @property
    @pulumi.getter(name="exportIpv6RoutePolicyId")
    def export_ipv6_route_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        Export IPv6 Route Policy Id.
        """
        return pulumi.get(self, "export_ipv6_route_policy_id")

    @export_ipv6_route_policy_id.setter
    def export_ipv6_route_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "export_ipv6_route_policy_id", value)


if not MYPY:
    class ExportRoutePolicyArgsDict(TypedDict):
        """
        Export Route Policy either IPv4 or IPv6.
        """
        export_ipv4_route_policy_id: NotRequired[pulumi.Input[str]]
        """
        ARM resource ID of RoutePolicy.
        """
        export_ipv6_route_policy_id: NotRequired[pulumi.Input[str]]
        """
        ARM resource ID of RoutePolicy.
        """
elif False:
    ExportRoutePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExportRoutePolicyArgs:
    def __init__(__self__, *,
                 export_ipv4_route_policy_id: Optional[pulumi.Input[str]] = None,
                 export_ipv6_route_policy_id: Optional[pulumi.Input[str]] = None):
        """
        Export Route Policy either IPv4 or IPv6.
        :param pulumi.Input[str] export_ipv4_route_policy_id: ARM resource ID of RoutePolicy.
        :param pulumi.Input[str] export_ipv6_route_policy_id: ARM resource ID of RoutePolicy.
        """
        if export_ipv4_route_policy_id is not None:
            pulumi.set(__self__, "export_ipv4_route_policy_id", export_ipv4_route_policy_id)
        if export_ipv6_route_policy_id is not None:
            pulumi.set(__self__, "export_ipv6_route_policy_id", export_ipv6_route_policy_id)

    @property
    @pulumi.getter(name="exportIpv4RoutePolicyId")
    def export_ipv4_route_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM resource ID of RoutePolicy.
        """
        return pulumi.get(self, "export_ipv4_route_policy_id")

    @export_ipv4_route_policy_id.setter
    def export_ipv4_route_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "export_ipv4_route_policy_id", value)

    @property
    @pulumi.getter(name="exportIpv6RoutePolicyId")
    def export_ipv6_route_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM resource ID of RoutePolicy.
        """
        return pulumi.get(self, "export_ipv6_route_policy_id")

    @export_ipv6_route_policy_id.setter
    def export_ipv6_route_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "export_ipv6_route_policy_id", value)


if not MYPY:
    class ExpressRouteConnectionInformationArgsDict(TypedDict):
        """
        The ExpressRoute circuit ID and the Auth Key are required for you to successfully deploy NFC service.
        """
        express_route_authorization_key: pulumi.Input[str]
        """
        Authorization key for the circuit, must be of type Microsoft.Network/expressRouteCircuits/authorizations. The Auth Key is a mandatory attribute.
        """
        express_route_circuit_id: pulumi.Input[str]
        """
        The express route circuit Azure resource ID, must be of type Microsoft.Network/expressRouteCircuits/circuitName. The ExpressRoute Circuit is a mandatory attribute.
        """
elif False:
    ExpressRouteConnectionInformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExpressRouteConnectionInformationArgs:
    def __init__(__self__, *,
                 express_route_authorization_key: pulumi.Input[str],
                 express_route_circuit_id: pulumi.Input[str]):
        """
        The ExpressRoute circuit ID and the Auth Key are required for you to successfully deploy NFC service.
        :param pulumi.Input[str] express_route_authorization_key: Authorization key for the circuit, must be of type Microsoft.Network/expressRouteCircuits/authorizations. The Auth Key is a mandatory attribute.
        :param pulumi.Input[str] express_route_circuit_id: The express route circuit Azure resource ID, must be of type Microsoft.Network/expressRouteCircuits/circuitName. The ExpressRoute Circuit is a mandatory attribute.
        """
        pulumi.set(__self__, "express_route_authorization_key", express_route_authorization_key)
        pulumi.set(__self__, "express_route_circuit_id", express_route_circuit_id)

    @property
    @pulumi.getter(name="expressRouteAuthorizationKey")
    def express_route_authorization_key(self) -> pulumi.Input[str]:
        """
        Authorization key for the circuit, must be of type Microsoft.Network/expressRouteCircuits/authorizations. The Auth Key is a mandatory attribute.
        """
        return pulumi.get(self, "express_route_authorization_key")

    @express_route_authorization_key.setter
    def express_route_authorization_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "express_route_authorization_key", value)

    @property
    @pulumi.getter(name="expressRouteCircuitId")
    def express_route_circuit_id(self) -> pulumi.Input[str]:
        """
        The express route circuit Azure resource ID, must be of type Microsoft.Network/expressRouteCircuits/circuitName. The ExpressRoute Circuit is a mandatory attribute.
        """
        return pulumi.get(self, "express_route_circuit_id")

    @express_route_circuit_id.setter
    def express_route_circuit_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "express_route_circuit_id", value)


if not MYPY:
    class ExternalNetworkPropertiesOptionAPropertiesArgsDict(TypedDict):
        """
        option A properties object
        """
        peer_asn: pulumi.Input[float]
        """
        Peer ASN number.Example : 28
        """
        vlan_id: pulumi.Input[int]
        """
        Vlan identifier. Example : 501
        """
        bfd_configuration: NotRequired[pulumi.Input['BfdConfigurationArgsDict']]
        """
        BFD configuration properties
        """
        egress_acl_id: NotRequired[pulumi.Input[str]]
        """
        Egress Acl. ARM resource ID of Access Control Lists.
        """
        ingress_acl_id: NotRequired[pulumi.Input[str]]
        """
        Ingress Acl. ARM resource ID of Access Control Lists.
        """
        mtu: NotRequired[pulumi.Input[int]]
        """
        MTU to use for option A peering.
        """
        primary_ipv4_prefix: NotRequired[pulumi.Input[str]]
        """
        IPv4 Address Prefix.
        """
        primary_ipv6_prefix: NotRequired[pulumi.Input[str]]
        """
        IPv6 Address Prefix.
        """
        secondary_ipv4_prefix: NotRequired[pulumi.Input[str]]
        """
        Secondary IPv4 Address Prefix.
        """
        secondary_ipv6_prefix: NotRequired[pulumi.Input[str]]
        """
        Secondary IPv6 Address Prefix.
        """
elif False:
    ExternalNetworkPropertiesOptionAPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalNetworkPropertiesOptionAPropertiesArgs:
    def __init__(__self__, *,
                 peer_asn: pulumi.Input[float],
                 vlan_id: pulumi.Input[int],
                 bfd_configuration: Optional[pulumi.Input['BfdConfigurationArgs']] = None,
                 egress_acl_id: Optional[pulumi.Input[str]] = None,
                 ingress_acl_id: Optional[pulumi.Input[str]] = None,
                 mtu: Optional[pulumi.Input[int]] = None,
                 primary_ipv4_prefix: Optional[pulumi.Input[str]] = None,
                 primary_ipv6_prefix: Optional[pulumi.Input[str]] = None,
                 secondary_ipv4_prefix: Optional[pulumi.Input[str]] = None,
                 secondary_ipv6_prefix: Optional[pulumi.Input[str]] = None):
        """
        option A properties object
        :param pulumi.Input[float] peer_asn: Peer ASN number.Example : 28
        :param pulumi.Input[int] vlan_id: Vlan identifier. Example : 501
        :param pulumi.Input['BfdConfigurationArgs'] bfd_configuration: BFD configuration properties
        :param pulumi.Input[str] egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
        :param pulumi.Input[str] ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
        :param pulumi.Input[int] mtu: MTU to use for option A peering.
        :param pulumi.Input[str] primary_ipv4_prefix: IPv4 Address Prefix.
        :param pulumi.Input[str] primary_ipv6_prefix: IPv6 Address Prefix.
        :param pulumi.Input[str] secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
        :param pulumi.Input[str] secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
        """
        pulumi.set(__self__, "peer_asn", peer_asn)
        pulumi.set(__self__, "vlan_id", vlan_id)
        if bfd_configuration is not None:
            pulumi.set(__self__, "bfd_configuration", bfd_configuration)
        if egress_acl_id is not None:
            pulumi.set(__self__, "egress_acl_id", egress_acl_id)
        if ingress_acl_id is not None:
            pulumi.set(__self__, "ingress_acl_id", ingress_acl_id)
        if mtu is None:
            mtu = 1500
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if primary_ipv4_prefix is not None:
            pulumi.set(__self__, "primary_ipv4_prefix", primary_ipv4_prefix)
        if primary_ipv6_prefix is not None:
            pulumi.set(__self__, "primary_ipv6_prefix", primary_ipv6_prefix)
        if secondary_ipv4_prefix is not None:
            pulumi.set(__self__, "secondary_ipv4_prefix", secondary_ipv4_prefix)
        if secondary_ipv6_prefix is not None:
            pulumi.set(__self__, "secondary_ipv6_prefix", secondary_ipv6_prefix)

    @property
    @pulumi.getter(name="peerASN")
    def peer_asn(self) -> pulumi.Input[float]:
        """
        Peer ASN number.Example : 28
        """
        return pulumi.get(self, "peer_asn")

    @peer_asn.setter
    def peer_asn(self, value: pulumi.Input[float]):
        pulumi.set(self, "peer_asn", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> pulumi.Input[int]:
        """
        Vlan identifier. Example : 501
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "vlan_id", value)

    @property
    @pulumi.getter(name="bfdConfiguration")
    def bfd_configuration(self) -> Optional[pulumi.Input['BfdConfigurationArgs']]:
        """
        BFD configuration properties
        """
        return pulumi.get(self, "bfd_configuration")

    @bfd_configuration.setter
    def bfd_configuration(self, value: Optional[pulumi.Input['BfdConfigurationArgs']]):
        pulumi.set(self, "bfd_configuration", value)

    @property
    @pulumi.getter(name="egressAclId")
    def egress_acl_id(self) -> Optional[pulumi.Input[str]]:
        """
        Egress Acl. ARM resource ID of Access Control Lists.
        """
        return pulumi.get(self, "egress_acl_id")

    @egress_acl_id.setter
    def egress_acl_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "egress_acl_id", value)

    @property
    @pulumi.getter(name="ingressAclId")
    def ingress_acl_id(self) -> Optional[pulumi.Input[str]]:
        """
        Ingress Acl. ARM resource ID of Access Control Lists.
        """
        return pulumi.get(self, "ingress_acl_id")

    @ingress_acl_id.setter
    def ingress_acl_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ingress_acl_id", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[int]]:
        """
        MTU to use for option A peering.
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter(name="primaryIpv4Prefix")
    def primary_ipv4_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        IPv4 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv4_prefix")

    @primary_ipv4_prefix.setter
    def primary_ipv4_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_ipv4_prefix", value)

    @property
    @pulumi.getter(name="primaryIpv6Prefix")
    def primary_ipv6_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        IPv6 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv6_prefix")

    @primary_ipv6_prefix.setter
    def primary_ipv6_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_ipv6_prefix", value)

    @property
    @pulumi.getter(name="secondaryIpv4Prefix")
    def secondary_ipv4_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Secondary IPv4 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv4_prefix")

    @secondary_ipv4_prefix.setter
    def secondary_ipv4_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secondary_ipv4_prefix", value)

    @property
    @pulumi.getter(name="secondaryIpv6Prefix")
    def secondary_ipv6_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Secondary IPv6 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv6_prefix")

    @secondary_ipv6_prefix.setter
    def secondary_ipv6_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secondary_ipv6_prefix", value)


if not MYPY:
    class FabricOptionBPropertiesArgsDict(TypedDict):
        """
        Option B configuration to be used for Management VPN.
        """
        export_route_targets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Route Targets to be applied for outgoing routes from CE. This is for backward compatibility.
        """
        import_route_targets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Route Targets to be applied for incoming routes into CE. This is for backward compatibility.
        """
        route_targets: NotRequired[pulumi.Input['RouteTargetInformationArgsDict']]
        """
        Route Targets to be applied.
        """
elif False:
    FabricOptionBPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FabricOptionBPropertiesArgs:
    def __init__(__self__, *,
                 export_route_targets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 import_route_targets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 route_targets: Optional[pulumi.Input['RouteTargetInformationArgs']] = None):
        """
        Option B configuration to be used for Management VPN.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] export_route_targets: Route Targets to be applied for outgoing routes from CE. This is for backward compatibility.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] import_route_targets: Route Targets to be applied for incoming routes into CE. This is for backward compatibility.
        :param pulumi.Input['RouteTargetInformationArgs'] route_targets: Route Targets to be applied.
        """
        if export_route_targets is not None:
            pulumi.set(__self__, "export_route_targets", export_route_targets)
        if import_route_targets is not None:
            pulumi.set(__self__, "import_route_targets", import_route_targets)
        if route_targets is not None:
            pulumi.set(__self__, "route_targets", route_targets)

    @property
    @pulumi.getter(name="exportRouteTargets")
    def export_route_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Route Targets to be applied for outgoing routes from CE. This is for backward compatibility.
        """
        return pulumi.get(self, "export_route_targets")

    @export_route_targets.setter
    def export_route_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "export_route_targets", value)

    @property
    @pulumi.getter(name="importRouteTargets")
    def import_route_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Route Targets to be applied for incoming routes into CE. This is for backward compatibility.
        """
        return pulumi.get(self, "import_route_targets")

    @import_route_targets.setter
    def import_route_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "import_route_targets", value)

    @property
    @pulumi.getter(name="routeTargets")
    def route_targets(self) -> Optional[pulumi.Input['RouteTargetInformationArgs']]:
        """
        Route Targets to be applied.
        """
        return pulumi.get(self, "route_targets")

    @route_targets.setter
    def route_targets(self, value: Optional[pulumi.Input['RouteTargetInformationArgs']]):
        pulumi.set(self, "route_targets", value)


if not MYPY:
    class ImportRoutePolicyInformationArgsDict(TypedDict):
        """
        Import Route Policy Configuration.
        """
        import_ipv4_route_policy_id: NotRequired[pulumi.Input[str]]
        """
        Import IPv4 Route Policy Id.
        """
        import_ipv6_route_policy_id: NotRequired[pulumi.Input[str]]
        """
        Import IPv6 Route Policy Id.
        """
elif False:
    ImportRoutePolicyInformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImportRoutePolicyInformationArgs:
    def __init__(__self__, *,
                 import_ipv4_route_policy_id: Optional[pulumi.Input[str]] = None,
                 import_ipv6_route_policy_id: Optional[pulumi.Input[str]] = None):
        """
        Import Route Policy Configuration.
        :param pulumi.Input[str] import_ipv4_route_policy_id: Import IPv4 Route Policy Id.
        :param pulumi.Input[str] import_ipv6_route_policy_id: Import IPv6 Route Policy Id.
        """
        if import_ipv4_route_policy_id is not None:
            pulumi.set(__self__, "import_ipv4_route_policy_id", import_ipv4_route_policy_id)
        if import_ipv6_route_policy_id is not None:
            pulumi.set(__self__, "import_ipv6_route_policy_id", import_ipv6_route_policy_id)

    @property
    @pulumi.getter(name="importIpv4RoutePolicyId")
    def import_ipv4_route_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        Import IPv4 Route Policy Id.
        """
        return pulumi.get(self, "import_ipv4_route_policy_id")

    @import_ipv4_route_policy_id.setter
    def import_ipv4_route_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "import_ipv4_route_policy_id", value)

    @property
    @pulumi.getter(name="importIpv6RoutePolicyId")
    def import_ipv6_route_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        Import IPv6 Route Policy Id.
        """
        return pulumi.get(self, "import_ipv6_route_policy_id")

    @import_ipv6_route_policy_id.setter
    def import_ipv6_route_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "import_ipv6_route_policy_id", value)


if not MYPY:
    class ImportRoutePolicyArgsDict(TypedDict):
        """
        Import Route Policy either IPv4 or IPv6.
        """
        import_ipv4_route_policy_id: NotRequired[pulumi.Input[str]]
        """
        ARM resource ID of RoutePolicy.
        """
        import_ipv6_route_policy_id: NotRequired[pulumi.Input[str]]
        """
        ARM resource ID of RoutePolicy.
        """
elif False:
    ImportRoutePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImportRoutePolicyArgs:
    def __init__(__self__, *,
                 import_ipv4_route_policy_id: Optional[pulumi.Input[str]] = None,
                 import_ipv6_route_policy_id: Optional[pulumi.Input[str]] = None):
        """
        Import Route Policy either IPv4 or IPv6.
        :param pulumi.Input[str] import_ipv4_route_policy_id: ARM resource ID of RoutePolicy.
        :param pulumi.Input[str] import_ipv6_route_policy_id: ARM resource ID of RoutePolicy.
        """
        if import_ipv4_route_policy_id is not None:
            pulumi.set(__self__, "import_ipv4_route_policy_id", import_ipv4_route_policy_id)
        if import_ipv6_route_policy_id is not None:
            pulumi.set(__self__, "import_ipv6_route_policy_id", import_ipv6_route_policy_id)

    @property
    @pulumi.getter(name="importIpv4RoutePolicyId")
    def import_ipv4_route_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM resource ID of RoutePolicy.
        """
        return pulumi.get(self, "import_ipv4_route_policy_id")

    @import_ipv4_route_policy_id.setter
    def import_ipv4_route_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "import_ipv4_route_policy_id", value)

    @property
    @pulumi.getter(name="importIpv6RoutePolicyId")
    def import_ipv6_route_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM resource ID of RoutePolicy.
        """
        return pulumi.get(self, "import_ipv6_route_policy_id")

    @import_ipv6_route_policy_id.setter
    def import_ipv6_route_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "import_ipv6_route_policy_id", value)


if not MYPY:
    class InternalNetworkPropertiesBgpConfigurationArgsDict(TypedDict):
        """
        BGP configuration properties.
        """
        peer_asn: pulumi.Input[float]
        """
        Peer ASN. Example: 65047.
        """
        allow_as: NotRequired[pulumi.Input[int]]
        """
        Allows for routes to be received and processed even if the router detects its own ASN in the AS-Path. 0 is disable, Possible values are 1-10, default is 2.
        """
        allow_as_override: NotRequired[pulumi.Input[Union[str, 'AllowASOverride']]]
        """
        Enable Or Disable state.
        """
        annotation: NotRequired[pulumi.Input[str]]
        """
        Switch configuration description.
        """
        bfd_configuration: NotRequired[pulumi.Input['BfdConfigurationArgsDict']]
        """
        BFD configuration properties
        """
        default_route_originate: NotRequired[pulumi.Input[Union[str, 'BooleanEnumProperty']]]
        """
        Originate a defaultRoute. Ex: "True" | "False".
        """
        ipv4_listen_range_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of BGP IPv4 Listen Range prefixes.
        """
        ipv4_neighbor_address: NotRequired[pulumi.Input[Sequence[pulumi.Input['NeighborAddressArgsDict']]]]
        """
        List with stringified IPv4 Neighbor Addresses.
        """
        ipv6_listen_range_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of BGP IPv6 Listen Ranges prefixes.
        """
        ipv6_neighbor_address: NotRequired[pulumi.Input[Sequence[pulumi.Input['NeighborAddressArgsDict']]]]
        """
        List with stringified IPv6 Neighbor Address.
        """
elif False:
    InternalNetworkPropertiesBgpConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InternalNetworkPropertiesBgpConfigurationArgs:
    def __init__(__self__, *,
                 peer_asn: pulumi.Input[float],
                 allow_as: Optional[pulumi.Input[int]] = None,
                 allow_as_override: Optional[pulumi.Input[Union[str, 'AllowASOverride']]] = None,
                 annotation: Optional[pulumi.Input[str]] = None,
                 bfd_configuration: Optional[pulumi.Input['BfdConfigurationArgs']] = None,
                 default_route_originate: Optional[pulumi.Input[Union[str, 'BooleanEnumProperty']]] = None,
                 ipv4_listen_range_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ipv4_neighbor_address: Optional[pulumi.Input[Sequence[pulumi.Input['NeighborAddressArgs']]]] = None,
                 ipv6_listen_range_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ipv6_neighbor_address: Optional[pulumi.Input[Sequence[pulumi.Input['NeighborAddressArgs']]]] = None):
        """
        BGP configuration properties.
        :param pulumi.Input[float] peer_asn: Peer ASN. Example: 65047.
        :param pulumi.Input[int] allow_as: Allows for routes to be received and processed even if the router detects its own ASN in the AS-Path. 0 is disable, Possible values are 1-10, default is 2.
        :param pulumi.Input[Union[str, 'AllowASOverride']] allow_as_override: Enable Or Disable state.
        :param pulumi.Input[str] annotation: Switch configuration description.
        :param pulumi.Input['BfdConfigurationArgs'] bfd_configuration: BFD configuration properties
        :param pulumi.Input[Union[str, 'BooleanEnumProperty']] default_route_originate: Originate a defaultRoute. Ex: "True" | "False".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ipv4_listen_range_prefixes: List of BGP IPv4 Listen Range prefixes.
        :param pulumi.Input[Sequence[pulumi.Input['NeighborAddressArgs']]] ipv4_neighbor_address: List with stringified IPv4 Neighbor Addresses.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ipv6_listen_range_prefixes: List of BGP IPv6 Listen Ranges prefixes.
        :param pulumi.Input[Sequence[pulumi.Input['NeighborAddressArgs']]] ipv6_neighbor_address: List with stringified IPv6 Neighbor Address.
        """
        pulumi.set(__self__, "peer_asn", peer_asn)
        if allow_as is None:
            allow_as = 2
        if allow_as is not None:
            pulumi.set(__self__, "allow_as", allow_as)
        if allow_as_override is not None:
            pulumi.set(__self__, "allow_as_override", allow_as_override)
        if annotation is not None:
            pulumi.set(__self__, "annotation", annotation)
        if bfd_configuration is not None:
            pulumi.set(__self__, "bfd_configuration", bfd_configuration)
        if default_route_originate is not None:
            pulumi.set(__self__, "default_route_originate", default_route_originate)
        if ipv4_listen_range_prefixes is not None:
            pulumi.set(__self__, "ipv4_listen_range_prefixes", ipv4_listen_range_prefixes)
        if ipv4_neighbor_address is not None:
            pulumi.set(__self__, "ipv4_neighbor_address", ipv4_neighbor_address)
        if ipv6_listen_range_prefixes is not None:
            pulumi.set(__self__, "ipv6_listen_range_prefixes", ipv6_listen_range_prefixes)
        if ipv6_neighbor_address is not None:
            pulumi.set(__self__, "ipv6_neighbor_address", ipv6_neighbor_address)

    @property
    @pulumi.getter(name="peerASN")
    def peer_asn(self) -> pulumi.Input[float]:
        """
        Peer ASN. Example: 65047.
        """
        return pulumi.get(self, "peer_asn")

    @peer_asn.setter
    def peer_asn(self, value: pulumi.Input[float]):
        pulumi.set(self, "peer_asn", value)

    @property
    @pulumi.getter(name="allowAS")
    def allow_as(self) -> Optional[pulumi.Input[int]]:
        """
        Allows for routes to be received and processed even if the router detects its own ASN in the AS-Path. 0 is disable, Possible values are 1-10, default is 2.
        """
        return pulumi.get(self, "allow_as")

    @allow_as.setter
    def allow_as(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "allow_as", value)

    @property
    @pulumi.getter(name="allowASOverride")
    def allow_as_override(self) -> Optional[pulumi.Input[Union[str, 'AllowASOverride']]]:
        """
        Enable Or Disable state.
        """
        return pulumi.get(self, "allow_as_override")

    @allow_as_override.setter
    def allow_as_override(self, value: Optional[pulumi.Input[Union[str, 'AllowASOverride']]]):
        pulumi.set(self, "allow_as_override", value)

    @property
    @pulumi.getter
    def annotation(self) -> Optional[pulumi.Input[str]]:
        """
        Switch configuration description.
        """
        return pulumi.get(self, "annotation")

    @annotation.setter
    def annotation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "annotation", value)

    @property
    @pulumi.getter(name="bfdConfiguration")
    def bfd_configuration(self) -> Optional[pulumi.Input['BfdConfigurationArgs']]:
        """
        BFD configuration properties
        """
        return pulumi.get(self, "bfd_configuration")

    @bfd_configuration.setter
    def bfd_configuration(self, value: Optional[pulumi.Input['BfdConfigurationArgs']]):
        pulumi.set(self, "bfd_configuration", value)

    @property
    @pulumi.getter(name="defaultRouteOriginate")
    def default_route_originate(self) -> Optional[pulumi.Input[Union[str, 'BooleanEnumProperty']]]:
        """
        Originate a defaultRoute. Ex: "True" | "False".
        """
        return pulumi.get(self, "default_route_originate")

    @default_route_originate.setter
    def default_route_originate(self, value: Optional[pulumi.Input[Union[str, 'BooleanEnumProperty']]]):
        pulumi.set(self, "default_route_originate", value)

    @property
    @pulumi.getter(name="ipv4ListenRangePrefixes")
    def ipv4_listen_range_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of BGP IPv4 Listen Range prefixes.
        """
        return pulumi.get(self, "ipv4_listen_range_prefixes")

    @ipv4_listen_range_prefixes.setter
    def ipv4_listen_range_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ipv4_listen_range_prefixes", value)

    @property
    @pulumi.getter(name="ipv4NeighborAddress")
    def ipv4_neighbor_address(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NeighborAddressArgs']]]]:
        """
        List with stringified IPv4 Neighbor Addresses.
        """
        return pulumi.get(self, "ipv4_neighbor_address")

    @ipv4_neighbor_address.setter
    def ipv4_neighbor_address(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NeighborAddressArgs']]]]):
        pulumi.set(self, "ipv4_neighbor_address", value)

    @property
    @pulumi.getter(name="ipv6ListenRangePrefixes")
    def ipv6_listen_range_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of BGP IPv6 Listen Ranges prefixes.
        """
        return pulumi.get(self, "ipv6_listen_range_prefixes")

    @ipv6_listen_range_prefixes.setter
    def ipv6_listen_range_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ipv6_listen_range_prefixes", value)

    @property
    @pulumi.getter(name="ipv6NeighborAddress")
    def ipv6_neighbor_address(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NeighborAddressArgs']]]]:
        """
        List with stringified IPv6 Neighbor Address.
        """
        return pulumi.get(self, "ipv6_neighbor_address")

    @ipv6_neighbor_address.setter
    def ipv6_neighbor_address(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NeighborAddressArgs']]]]):
        pulumi.set(self, "ipv6_neighbor_address", value)


if not MYPY:
    class InternalNetworkPropertiesStaticRouteConfigurationArgsDict(TypedDict):
        """
        Static Route Configuration properties.
        """
        bfd_configuration: NotRequired[pulumi.Input['BfdConfigurationArgsDict']]
        """
        BFD configuration properties
        """
        extension: NotRequired[pulumi.Input[Union[str, 'Extension']]]
        """
        Extension. Example: NoExtension | NPB.
        """
        ipv4_routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['StaticRoutePropertiesArgsDict']]]]
        """
        List of IPv4 Routes.
        """
        ipv6_routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['StaticRoutePropertiesArgsDict']]]]
        """
        List of IPv6 Routes.
        """
elif False:
    InternalNetworkPropertiesStaticRouteConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InternalNetworkPropertiesStaticRouteConfigurationArgs:
    def __init__(__self__, *,
                 bfd_configuration: Optional[pulumi.Input['BfdConfigurationArgs']] = None,
                 extension: Optional[pulumi.Input[Union[str, 'Extension']]] = None,
                 ipv4_routes: Optional[pulumi.Input[Sequence[pulumi.Input['StaticRoutePropertiesArgs']]]] = None,
                 ipv6_routes: Optional[pulumi.Input[Sequence[pulumi.Input['StaticRoutePropertiesArgs']]]] = None):
        """
        Static Route Configuration properties.
        :param pulumi.Input['BfdConfigurationArgs'] bfd_configuration: BFD configuration properties
        :param pulumi.Input[Union[str, 'Extension']] extension: Extension. Example: NoExtension | NPB.
        :param pulumi.Input[Sequence[pulumi.Input['StaticRoutePropertiesArgs']]] ipv4_routes: List of IPv4 Routes.
        :param pulumi.Input[Sequence[pulumi.Input['StaticRoutePropertiesArgs']]] ipv6_routes: List of IPv6 Routes.
        """
        if bfd_configuration is not None:
            pulumi.set(__self__, "bfd_configuration", bfd_configuration)
        if extension is None:
            extension = 'NoExtension'
        if extension is not None:
            pulumi.set(__self__, "extension", extension)
        if ipv4_routes is not None:
            pulumi.set(__self__, "ipv4_routes", ipv4_routes)
        if ipv6_routes is not None:
            pulumi.set(__self__, "ipv6_routes", ipv6_routes)

    @property
    @pulumi.getter(name="bfdConfiguration")
    def bfd_configuration(self) -> Optional[pulumi.Input['BfdConfigurationArgs']]:
        """
        BFD configuration properties
        """
        return pulumi.get(self, "bfd_configuration")

    @bfd_configuration.setter
    def bfd_configuration(self, value: Optional[pulumi.Input['BfdConfigurationArgs']]):
        pulumi.set(self, "bfd_configuration", value)

    @property
    @pulumi.getter
    def extension(self) -> Optional[pulumi.Input[Union[str, 'Extension']]]:
        """
        Extension. Example: NoExtension | NPB.
        """
        return pulumi.get(self, "extension")

    @extension.setter
    def extension(self, value: Optional[pulumi.Input[Union[str, 'Extension']]]):
        pulumi.set(self, "extension", value)

    @property
    @pulumi.getter(name="ipv4Routes")
    def ipv4_routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StaticRoutePropertiesArgs']]]]:
        """
        List of IPv4 Routes.
        """
        return pulumi.get(self, "ipv4_routes")

    @ipv4_routes.setter
    def ipv4_routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StaticRoutePropertiesArgs']]]]):
        pulumi.set(self, "ipv4_routes", value)

    @property
    @pulumi.getter(name="ipv6Routes")
    def ipv6_routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StaticRoutePropertiesArgs']]]]:
        """
        List of IPv6 Routes.
        """
        return pulumi.get(self, "ipv6_routes")

    @ipv6_routes.setter
    def ipv6_routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StaticRoutePropertiesArgs']]]]):
        pulumi.set(self, "ipv6_routes", value)


if not MYPY:
    class IpCommunityIdListArgsDict(TypedDict):
        """
        IP Community ID list properties.
        """
        ip_community_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of IP Community resource IDs.
        """
elif False:
    IpCommunityIdListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpCommunityIdListArgs:
    def __init__(__self__, *,
                 ip_community_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        IP Community ID list properties.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_community_ids: List of IP Community resource IDs.
        """
        if ip_community_ids is not None:
            pulumi.set(__self__, "ip_community_ids", ip_community_ids)

    @property
    @pulumi.getter(name="ipCommunityIds")
    def ip_community_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IP Community resource IDs.
        """
        return pulumi.get(self, "ip_community_ids")

    @ip_community_ids.setter
    def ip_community_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_community_ids", value)


if not MYPY:
    class IpCommunityRuleArgsDict(TypedDict):
        """
        IP Community patchable properties.
        """
        action: pulumi.Input[Union[str, 'CommunityActionTypes']]
        """
        Action to be taken on the configuration. Example: Permit | Deny.
        """
        community_members: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List the community members of IP Community.
        """
        sequence_number: pulumi.Input[float]
        """
        Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        """
        well_known_communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'WellKnownCommunities']]]]]
        """
        Supported well known Community List.
        """
elif False:
    IpCommunityRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpCommunityRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[Union[str, 'CommunityActionTypes']],
                 community_members: pulumi.Input[Sequence[pulumi.Input[str]]],
                 sequence_number: pulumi.Input[float],
                 well_known_communities: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'WellKnownCommunities']]]]] = None):
        """
        IP Community patchable properties.
        :param pulumi.Input[Union[str, 'CommunityActionTypes']] action: Action to be taken on the configuration. Example: Permit | Deny.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] community_members: List the community members of IP Community.
        :param pulumi.Input[float] sequence_number: Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'WellKnownCommunities']]]] well_known_communities: Supported well known Community List.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "community_members", community_members)
        pulumi.set(__self__, "sequence_number", sequence_number)
        if well_known_communities is not None:
            pulumi.set(__self__, "well_known_communities", well_known_communities)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[Union[str, 'CommunityActionTypes']]:
        """
        Action to be taken on the configuration. Example: Permit | Deny.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[Union[str, 'CommunityActionTypes']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="communityMembers")
    def community_members(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List the community members of IP Community.
        """
        return pulumi.get(self, "community_members")

    @community_members.setter
    def community_members(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "community_members", value)

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> pulumi.Input[float]:
        """
        Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        """
        return pulumi.get(self, "sequence_number")

    @sequence_number.setter
    def sequence_number(self, value: pulumi.Input[float]):
        pulumi.set(self, "sequence_number", value)

    @property
    @pulumi.getter(name="wellKnownCommunities")
    def well_known_communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'WellKnownCommunities']]]]]:
        """
        Supported well known Community List.
        """
        return pulumi.get(self, "well_known_communities")

    @well_known_communities.setter
    def well_known_communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'WellKnownCommunities']]]]]):
        pulumi.set(self, "well_known_communities", value)


if not MYPY:
    class IpExtendedCommunityIdListArgsDict(TypedDict):
        """
        IP Extended Community Id list properties.
        """
        ip_extended_community_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of IP Extended Community resource IDs.
        """
elif False:
    IpExtendedCommunityIdListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpExtendedCommunityIdListArgs:
    def __init__(__self__, *,
                 ip_extended_community_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        IP Extended Community Id list properties.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_extended_community_ids: List of IP Extended Community resource IDs.
        """
        if ip_extended_community_ids is not None:
            pulumi.set(__self__, "ip_extended_community_ids", ip_extended_community_ids)

    @property
    @pulumi.getter(name="ipExtendedCommunityIds")
    def ip_extended_community_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IP Extended Community resource IDs.
        """
        return pulumi.get(self, "ip_extended_community_ids")

    @ip_extended_community_ids.setter
    def ip_extended_community_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_extended_community_ids", value)


if not MYPY:
    class IpExtendedCommunityRuleArgsDict(TypedDict):
        """
        List of IP Extended Community Rules.
        """
        action: pulumi.Input[Union[str, 'CommunityActionTypes']]
        """
        Action to be taken on the configuration. Example: Permit | Deny.
        """
        route_targets: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Route Target List.The expected formats are ASN(plain):NN >> example 4294967294:50, ASN.ASN:NN >> example 65533.65333:40, IP-address:NN >> example 10.10.10.10:65535. The possible values of ASN,NN are in range of 0-65535, ASN(plain) is in range of 0-4294967295.
        """
        sequence_number: pulumi.Input[float]
        """
        Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        """
elif False:
    IpExtendedCommunityRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpExtendedCommunityRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[Union[str, 'CommunityActionTypes']],
                 route_targets: pulumi.Input[Sequence[pulumi.Input[str]]],
                 sequence_number: pulumi.Input[float]):
        """
        List of IP Extended Community Rules.
        :param pulumi.Input[Union[str, 'CommunityActionTypes']] action: Action to be taken on the configuration. Example: Permit | Deny.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] route_targets: Route Target List.The expected formats are ASN(plain):NN >> example 4294967294:50, ASN.ASN:NN >> example 65533.65333:40, IP-address:NN >> example 10.10.10.10:65535. The possible values of ASN,NN are in range of 0-65535, ASN(plain) is in range of 0-4294967295.
        :param pulumi.Input[float] sequence_number: Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "route_targets", route_targets)
        pulumi.set(__self__, "sequence_number", sequence_number)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[Union[str, 'CommunityActionTypes']]:
        """
        Action to be taken on the configuration. Example: Permit | Deny.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[Union[str, 'CommunityActionTypes']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="routeTargets")
    def route_targets(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Route Target List.The expected formats are ASN(plain):NN >> example 4294967294:50, ASN.ASN:NN >> example 65533.65333:40, IP-address:NN >> example 10.10.10.10:65535. The possible values of ASN,NN are in range of 0-65535, ASN(plain) is in range of 0-4294967295.
        """
        return pulumi.get(self, "route_targets")

    @route_targets.setter
    def route_targets(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "route_targets", value)

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> pulumi.Input[float]:
        """
        Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        """
        return pulumi.get(self, "sequence_number")

    @sequence_number.setter
    def sequence_number(self, value: pulumi.Input[float]):
        pulumi.set(self, "sequence_number", value)


if not MYPY:
    class IpGroupPropertiesArgsDict(TypedDict):
        """
        IP Group properties.
        """
        ip_address_type: NotRequired[pulumi.Input[Union[str, 'IPAddressType']]]
        """
        IP Address type.
        """
        ip_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of IP Prefixes.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        IP Group name.
        """
elif False:
    IpGroupPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpGroupPropertiesArgs:
    def __init__(__self__, *,
                 ip_address_type: Optional[pulumi.Input[Union[str, 'IPAddressType']]] = None,
                 ip_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        IP Group properties.
        :param pulumi.Input[Union[str, 'IPAddressType']] ip_address_type: IP Address type.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_prefixes: List of IP Prefixes.
        :param pulumi.Input[str] name: IP Group name.
        """
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)
        if ip_prefixes is not None:
            pulumi.set(__self__, "ip_prefixes", ip_prefixes)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[pulumi.Input[Union[str, 'IPAddressType']]]:
        """
        IP Address type.
        """
        return pulumi.get(self, "ip_address_type")

    @ip_address_type.setter
    def ip_address_type(self, value: Optional[pulumi.Input[Union[str, 'IPAddressType']]]):
        pulumi.set(self, "ip_address_type", value)

    @property
    @pulumi.getter(name="ipPrefixes")
    def ip_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IP Prefixes.
        """
        return pulumi.get(self, "ip_prefixes")

    @ip_prefixes.setter
    def ip_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_prefixes", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        IP Group name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class IpMatchConditionArgsDict(TypedDict):
        """
        Defines the condition that can be filtered using the selected IPs.
        """
        ip_group_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The List of IP Group Names that need to be matched.
        """
        ip_prefix_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of IP Prefixes that need to be matched.
        """
        prefix_type: NotRequired[pulumi.Input[Union[str, 'PrefixType']]]
        """
        IP Prefix Type that needs to be matched.
        """
        type: NotRequired[pulumi.Input[Union[str, 'SourceDestinationType']]]
        """
        IP Address type that needs to be matched.
        """
elif False:
    IpMatchConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpMatchConditionArgs:
    def __init__(__self__, *,
                 ip_group_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip_prefix_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 prefix_type: Optional[pulumi.Input[Union[str, 'PrefixType']]] = None,
                 type: Optional[pulumi.Input[Union[str, 'SourceDestinationType']]] = None):
        """
        Defines the condition that can be filtered using the selected IPs.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_group_names: The List of IP Group Names that need to be matched.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_prefix_values: The list of IP Prefixes that need to be matched.
        :param pulumi.Input[Union[str, 'PrefixType']] prefix_type: IP Prefix Type that needs to be matched.
        :param pulumi.Input[Union[str, 'SourceDestinationType']] type: IP Address type that needs to be matched.
        """
        if ip_group_names is not None:
            pulumi.set(__self__, "ip_group_names", ip_group_names)
        if ip_prefix_values is not None:
            pulumi.set(__self__, "ip_prefix_values", ip_prefix_values)
        if prefix_type is not None:
            pulumi.set(__self__, "prefix_type", prefix_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="ipGroupNames")
    def ip_group_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The List of IP Group Names that need to be matched.
        """
        return pulumi.get(self, "ip_group_names")

    @ip_group_names.setter
    def ip_group_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_group_names", value)

    @property
    @pulumi.getter(name="ipPrefixValues")
    def ip_prefix_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of IP Prefixes that need to be matched.
        """
        return pulumi.get(self, "ip_prefix_values")

    @ip_prefix_values.setter
    def ip_prefix_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_prefix_values", value)

    @property
    @pulumi.getter(name="prefixType")
    def prefix_type(self) -> Optional[pulumi.Input[Union[str, 'PrefixType']]]:
        """
        IP Prefix Type that needs to be matched.
        """
        return pulumi.get(self, "prefix_type")

    @prefix_type.setter
    def prefix_type(self, value: Optional[pulumi.Input[Union[str, 'PrefixType']]]):
        pulumi.set(self, "prefix_type", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'SourceDestinationType']]]:
        """
        IP Address type that needs to be matched.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'SourceDestinationType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class IpPrefixRuleArgsDict(TypedDict):
        """
        IP Prefix Rule properties.
        """
        action: pulumi.Input[Union[str, 'CommunityActionTypes']]
        """
        Action to be taken on the configuration. Example: Permit | Deny.
        """
        network_prefix: pulumi.Input[str]
        """
        Network Prefix specifying IPv4/IPv6 packets to be permitted or denied. Example: 1.1.1.0/24 | 3FFE:FFFF:0:CD30::/126 
        """
        sequence_number: pulumi.Input[float]
        """
        Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        """
        condition: NotRequired[pulumi.Input[Union[str, 'Condition']]]
        """
        Specify prefix-list bounds.
        """
        subnet_mask_length: NotRequired[pulumi.Input[str]]
        """
        SubnetMaskLength gives the minimum NetworkPrefix length to be matched. Possible values for IPv4 are 1 - 32 . Possible values of IPv6 are 1 - 128.
        """
elif False:
    IpPrefixRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpPrefixRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[Union[str, 'CommunityActionTypes']],
                 network_prefix: pulumi.Input[str],
                 sequence_number: pulumi.Input[float],
                 condition: Optional[pulumi.Input[Union[str, 'Condition']]] = None,
                 subnet_mask_length: Optional[pulumi.Input[str]] = None):
        """
        IP Prefix Rule properties.
        :param pulumi.Input[Union[str, 'CommunityActionTypes']] action: Action to be taken on the configuration. Example: Permit | Deny.
        :param pulumi.Input[str] network_prefix: Network Prefix specifying IPv4/IPv6 packets to be permitted or denied. Example: 1.1.1.0/24 | 3FFE:FFFF:0:CD30::/126 
        :param pulumi.Input[float] sequence_number: Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        :param pulumi.Input[Union[str, 'Condition']] condition: Specify prefix-list bounds.
        :param pulumi.Input[str] subnet_mask_length: SubnetMaskLength gives the minimum NetworkPrefix length to be matched. Possible values for IPv4 are 1 - 32 . Possible values of IPv6 are 1 - 128.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "network_prefix", network_prefix)
        pulumi.set(__self__, "sequence_number", sequence_number)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if subnet_mask_length is not None:
            pulumi.set(__self__, "subnet_mask_length", subnet_mask_length)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[Union[str, 'CommunityActionTypes']]:
        """
        Action to be taken on the configuration. Example: Permit | Deny.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[Union[str, 'CommunityActionTypes']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="networkPrefix")
    def network_prefix(self) -> pulumi.Input[str]:
        """
        Network Prefix specifying IPv4/IPv6 packets to be permitted or denied. Example: 1.1.1.0/24 | 3FFE:FFFF:0:CD30::/126 
        """
        return pulumi.get(self, "network_prefix")

    @network_prefix.setter
    def network_prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_prefix", value)

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> pulumi.Input[float]:
        """
        Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        """
        return pulumi.get(self, "sequence_number")

    @sequence_number.setter
    def sequence_number(self, value: pulumi.Input[float]):
        pulumi.set(self, "sequence_number", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[Union[str, 'Condition']]]:
        """
        Specify prefix-list bounds.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[Union[str, 'Condition']]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter(name="subnetMaskLength")
    def subnet_mask_length(self) -> Optional[pulumi.Input[str]]:
        """
        SubnetMaskLength gives the minimum NetworkPrefix length to be matched. Possible values for IPv4 are 1 - 32 . Possible values of IPv6 are 1 - 128.
        """
        return pulumi.get(self, "subnet_mask_length")

    @subnet_mask_length.setter
    def subnet_mask_length(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_mask_length", value)


if not MYPY:
    class IsolationDomainPropertiesArgsDict(TypedDict):
        """
        Isolation Domain Properties.
        """
        encapsulation: NotRequired[pulumi.Input[Union[str, 'Encapsulation']]]
        """
        Type of encapsulation.
        """
        neighbor_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Neighbor Group IDs.
        """
elif False:
    IsolationDomainPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IsolationDomainPropertiesArgs:
    def __init__(__self__, *,
                 encapsulation: Optional[pulumi.Input[Union[str, 'Encapsulation']]] = None,
                 neighbor_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Isolation Domain Properties.
        :param pulumi.Input[Union[str, 'Encapsulation']] encapsulation: Type of encapsulation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] neighbor_group_ids: List of Neighbor Group IDs.
        """
        if encapsulation is not None:
            pulumi.set(__self__, "encapsulation", encapsulation)
        if neighbor_group_ids is not None:
            pulumi.set(__self__, "neighbor_group_ids", neighbor_group_ids)

    @property
    @pulumi.getter
    def encapsulation(self) -> Optional[pulumi.Input[Union[str, 'Encapsulation']]]:
        """
        Type of encapsulation.
        """
        return pulumi.get(self, "encapsulation")

    @encapsulation.setter
    def encapsulation(self, value: Optional[pulumi.Input[Union[str, 'Encapsulation']]]):
        pulumi.set(self, "encapsulation", value)

    @property
    @pulumi.getter(name="neighborGroupIds")
    def neighbor_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Neighbor Group IDs.
        """
        return pulumi.get(self, "neighbor_group_ids")

    @neighbor_group_ids.setter
    def neighbor_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "neighbor_group_ids", value)


if not MYPY:
    class L3ExportRoutePolicyArgsDict(TypedDict):
        """
        Array of ARM Resource ID of the RoutePolicies.
        """
        export_ipv4_route_policy_id: NotRequired[pulumi.Input[str]]
        """
        ARM Resource ID of the RoutePolicy.
        """
        export_ipv6_route_policy_id: NotRequired[pulumi.Input[str]]
        """
        ARM Resource ID of the RoutePolicy.
        """
elif False:
    L3ExportRoutePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class L3ExportRoutePolicyArgs:
    def __init__(__self__, *,
                 export_ipv4_route_policy_id: Optional[pulumi.Input[str]] = None,
                 export_ipv6_route_policy_id: Optional[pulumi.Input[str]] = None):
        """
        Array of ARM Resource ID of the RoutePolicies.
        :param pulumi.Input[str] export_ipv4_route_policy_id: ARM Resource ID of the RoutePolicy.
        :param pulumi.Input[str] export_ipv6_route_policy_id: ARM Resource ID of the RoutePolicy.
        """
        if export_ipv4_route_policy_id is not None:
            pulumi.set(__self__, "export_ipv4_route_policy_id", export_ipv4_route_policy_id)
        if export_ipv6_route_policy_id is not None:
            pulumi.set(__self__, "export_ipv6_route_policy_id", export_ipv6_route_policy_id)

    @property
    @pulumi.getter(name="exportIpv4RoutePolicyId")
    def export_ipv4_route_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM Resource ID of the RoutePolicy.
        """
        return pulumi.get(self, "export_ipv4_route_policy_id")

    @export_ipv4_route_policy_id.setter
    def export_ipv4_route_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "export_ipv4_route_policy_id", value)

    @property
    @pulumi.getter(name="exportIpv6RoutePolicyId")
    def export_ipv6_route_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM Resource ID of the RoutePolicy.
        """
        return pulumi.get(self, "export_ipv6_route_policy_id")

    @export_ipv6_route_policy_id.setter
    def export_ipv6_route_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "export_ipv6_route_policy_id", value)


if not MYPY:
    class L3OptionBPropertiesArgsDict(TypedDict):
        """
        Option B configuration.
        """
        export_route_targets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        RouteTargets to be applied. This is used for the backward compatibility.
        """
        import_route_targets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        RouteTargets to be applied. This is used for the backward compatibility.
        """
        route_targets: NotRequired[pulumi.Input['RouteTargetInformationArgsDict']]
        """
        RouteTargets to be applied.
        """
elif False:
    L3OptionBPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class L3OptionBPropertiesArgs:
    def __init__(__self__, *,
                 export_route_targets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 import_route_targets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 route_targets: Optional[pulumi.Input['RouteTargetInformationArgs']] = None):
        """
        Option B configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] export_route_targets: RouteTargets to be applied. This is used for the backward compatibility.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] import_route_targets: RouteTargets to be applied. This is used for the backward compatibility.
        :param pulumi.Input['RouteTargetInformationArgs'] route_targets: RouteTargets to be applied.
        """
        if export_route_targets is not None:
            pulumi.set(__self__, "export_route_targets", export_route_targets)
        if import_route_targets is not None:
            pulumi.set(__self__, "import_route_targets", import_route_targets)
        if route_targets is not None:
            pulumi.set(__self__, "route_targets", route_targets)

    @property
    @pulumi.getter(name="exportRouteTargets")
    def export_route_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        RouteTargets to be applied. This is used for the backward compatibility.
        """
        return pulumi.get(self, "export_route_targets")

    @export_route_targets.setter
    def export_route_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "export_route_targets", value)

    @property
    @pulumi.getter(name="importRouteTargets")
    def import_route_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        RouteTargets to be applied. This is used for the backward compatibility.
        """
        return pulumi.get(self, "import_route_targets")

    @import_route_targets.setter
    def import_route_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "import_route_targets", value)

    @property
    @pulumi.getter(name="routeTargets")
    def route_targets(self) -> Optional[pulumi.Input['RouteTargetInformationArgs']]:
        """
        RouteTargets to be applied.
        """
        return pulumi.get(self, "route_targets")

    @route_targets.setter
    def route_targets(self, value: Optional[pulumi.Input['RouteTargetInformationArgs']]):
        pulumi.set(self, "route_targets", value)


if not MYPY:
    class Layer2ConfigurationArgsDict(TypedDict):
        """
        Common properties for Layer2 Configuration.
        """
        interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of network device interfaces resource IDs.
        """
        mtu: NotRequired[pulumi.Input[int]]
        """
        MTU of the packets between PE & CE.
        """
elif False:
    Layer2ConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Layer2ConfigurationArgs:
    def __init__(__self__, *,
                 interfaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 mtu: Optional[pulumi.Input[int]] = None):
        """
        Common properties for Layer2 Configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] interfaces: List of network device interfaces resource IDs.
        :param pulumi.Input[int] mtu: MTU of the packets between PE & CE.
        """
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)
        if mtu is None:
            mtu = 1500
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)

    @property
    @pulumi.getter
    def interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of network device interfaces resource IDs.
        """
        return pulumi.get(self, "interfaces")

    @interfaces.setter
    def interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "interfaces", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[int]]:
        """
        MTU of the packets between PE & CE.
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mtu", value)


if not MYPY:
    class ManagedResourceGroupConfigurationArgsDict(TypedDict):
        """
        Managed Resource Group configuration properties.
        """
        location: NotRequired[pulumi.Input[str]]
        """
        Managed resource group location.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The NFC service will be hosted in a Managed resource group.
        """
elif False:
    ManagedResourceGroupConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedResourceGroupConfigurationArgs:
    def __init__(__self__, *,
                 location: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Managed Resource Group configuration properties.
        :param pulumi.Input[str] location: Managed resource group location.
        :param pulumi.Input[str] name: The NFC service will be hosted in a Managed resource group.
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        Managed resource group location.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The NFC service will be hosted in a Managed resource group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ManagementNetworkConfigurationPropertiesArgsDict(TypedDict):
        """
        Configuration to be used to setup the management network.
        """
        infrastructure_vpn_configuration: pulumi.Input['VpnConfigurationPropertiesArgsDict']
        """
        VPN Configuration properties.
        """
        workload_vpn_configuration: pulumi.Input['VpnConfigurationPropertiesArgsDict']
        """
        VPN Configuration properties.
        """
elif False:
    ManagementNetworkConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementNetworkConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 infrastructure_vpn_configuration: pulumi.Input['VpnConfigurationPropertiesArgs'],
                 workload_vpn_configuration: pulumi.Input['VpnConfigurationPropertiesArgs']):
        """
        Configuration to be used to setup the management network.
        :param pulumi.Input['VpnConfigurationPropertiesArgs'] infrastructure_vpn_configuration: VPN Configuration properties.
        :param pulumi.Input['VpnConfigurationPropertiesArgs'] workload_vpn_configuration: VPN Configuration properties.
        """
        pulumi.set(__self__, "infrastructure_vpn_configuration", infrastructure_vpn_configuration)
        pulumi.set(__self__, "workload_vpn_configuration", workload_vpn_configuration)

    @property
    @pulumi.getter(name="infrastructureVpnConfiguration")
    def infrastructure_vpn_configuration(self) -> pulumi.Input['VpnConfigurationPropertiesArgs']:
        """
        VPN Configuration properties.
        """
        return pulumi.get(self, "infrastructure_vpn_configuration")

    @infrastructure_vpn_configuration.setter
    def infrastructure_vpn_configuration(self, value: pulumi.Input['VpnConfigurationPropertiesArgs']):
        pulumi.set(self, "infrastructure_vpn_configuration", value)

    @property
    @pulumi.getter(name="workloadVpnConfiguration")
    def workload_vpn_configuration(self) -> pulumi.Input['VpnConfigurationPropertiesArgs']:
        """
        VPN Configuration properties.
        """
        return pulumi.get(self, "workload_vpn_configuration")

    @workload_vpn_configuration.setter
    def workload_vpn_configuration(self, value: pulumi.Input['VpnConfigurationPropertiesArgs']):
        pulumi.set(self, "workload_vpn_configuration", value)


if not MYPY:
    class NeighborAddressArgsDict(TypedDict):
        """
        Neighbor Address properties.
        """
        address: NotRequired[pulumi.Input[str]]
        """
        IP Address.
        """
elif False:
    NeighborAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NeighborAddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None):
        """
        Neighbor Address properties.
        :param pulumi.Input[str] address: IP Address.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        IP Address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)


if not MYPY:
    class NeighborGroupDestinationArgsDict(TypedDict):
        """
        An array of destination IPv4 Addresses or IPv6 Addresses.
        """
        ipv4_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Array of IPv4 Addresses.
        """
        ipv6_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Array of IPv6 Addresses.
        """
elif False:
    NeighborGroupDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NeighborGroupDestinationArgs:
    def __init__(__self__, *,
                 ipv4_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ipv6_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        An array of destination IPv4 Addresses or IPv6 Addresses.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ipv4_addresses: Array of IPv4 Addresses.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ipv6_addresses: Array of IPv6 Addresses.
        """
        if ipv4_addresses is not None:
            pulumi.set(__self__, "ipv4_addresses", ipv4_addresses)
        if ipv6_addresses is not None:
            pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)

    @property
    @pulumi.getter(name="ipv4Addresses")
    def ipv4_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of IPv4 Addresses.
        """
        return pulumi.get(self, "ipv4_addresses")

    @ipv4_addresses.setter
    def ipv4_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ipv4_addresses", value)

    @property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of IPv6 Addresses.
        """
        return pulumi.get(self, "ipv6_addresses")

    @ipv6_addresses.setter
    def ipv6_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ipv6_addresses", value)


if not MYPY:
    class NetworkTapPropertiesDestinationsArgsDict(TypedDict):
        """
        Destination.
        """
        destination_id: pulumi.Input[str]
        """
        The destination Id. ARM Resource ID of either NNI or Internal Networks.
        """
        destination_type: pulumi.Input[Union[str, 'DestinationType']]
        """
        Type of destination. Input can be IsolationDomain or Direct.
        """
        name: pulumi.Input[str]
        """
        Destination name.
        """
        destination_tap_rule_id: NotRequired[pulumi.Input[str]]
        """
        ARM Resource ID of destination Tap Rule that contains match configurations.
        """
        isolation_domain_properties: NotRequired[pulumi.Input['IsolationDomainPropertiesArgsDict']]
        """
        Isolation Domain Properties.
        """
elif False:
    NetworkTapPropertiesDestinationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkTapPropertiesDestinationsArgs:
    def __init__(__self__, *,
                 destination_id: pulumi.Input[str],
                 destination_type: pulumi.Input[Union[str, 'DestinationType']],
                 name: pulumi.Input[str],
                 destination_tap_rule_id: Optional[pulumi.Input[str]] = None,
                 isolation_domain_properties: Optional[pulumi.Input['IsolationDomainPropertiesArgs']] = None):
        """
        Destination.
        :param pulumi.Input[str] destination_id: The destination Id. ARM Resource ID of either NNI or Internal Networks.
        :param pulumi.Input[Union[str, 'DestinationType']] destination_type: Type of destination. Input can be IsolationDomain or Direct.
        :param pulumi.Input[str] name: Destination name.
        :param pulumi.Input[str] destination_tap_rule_id: ARM Resource ID of destination Tap Rule that contains match configurations.
        :param pulumi.Input['IsolationDomainPropertiesArgs'] isolation_domain_properties: Isolation Domain Properties.
        """
        pulumi.set(__self__, "destination_id", destination_id)
        pulumi.set(__self__, "destination_type", destination_type)
        pulumi.set(__self__, "name", name)
        if destination_tap_rule_id is not None:
            pulumi.set(__self__, "destination_tap_rule_id", destination_tap_rule_id)
        if isolation_domain_properties is not None:
            pulumi.set(__self__, "isolation_domain_properties", isolation_domain_properties)

    @property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> pulumi.Input[str]:
        """
        The destination Id. ARM Resource ID of either NNI or Internal Networks.
        """
        return pulumi.get(self, "destination_id")

    @destination_id.setter
    def destination_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_id", value)

    @property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> pulumi.Input[Union[str, 'DestinationType']]:
        """
        Type of destination. Input can be IsolationDomain or Direct.
        """
        return pulumi.get(self, "destination_type")

    @destination_type.setter
    def destination_type(self, value: pulumi.Input[Union[str, 'DestinationType']]):
        pulumi.set(self, "destination_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Destination name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="destinationTapRuleId")
    def destination_tap_rule_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM Resource ID of destination Tap Rule that contains match configurations.
        """
        return pulumi.get(self, "destination_tap_rule_id")

    @destination_tap_rule_id.setter
    def destination_tap_rule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_tap_rule_id", value)

    @property
    @pulumi.getter(name="isolationDomainProperties")
    def isolation_domain_properties(self) -> Optional[pulumi.Input['IsolationDomainPropertiesArgs']]:
        """
        Isolation Domain Properties.
        """
        return pulumi.get(self, "isolation_domain_properties")

    @isolation_domain_properties.setter
    def isolation_domain_properties(self, value: Optional[pulumi.Input['IsolationDomainPropertiesArgs']]):
        pulumi.set(self, "isolation_domain_properties", value)


if not MYPY:
    class NetworkTapRuleActionArgsDict(TypedDict):
        """
        Action that need to performed.
        """
        destination_id: NotRequired[pulumi.Input[str]]
        """
        Destination Id. The ARM resource Id may be either Network To Network Interconnect or NeighborGroup.
        """
        is_timestamp_enabled: NotRequired[pulumi.Input[Union[str, 'BooleanEnumProperty']]]
        """
        The parameter to enable or disable the timestamp.
        """
        match_configuration_name: NotRequired[pulumi.Input[str]]
        """
        The name of the match configuration. This is used when Goto type is provided. If Goto type is selected and no match configuration name is provided. It goes to next configuration.
        """
        truncate: NotRequired[pulumi.Input[str]]
        """
        Truncate. 0 indicates do not truncate.
        """
        type: NotRequired[pulumi.Input[Union[str, 'TapRuleActionType']]]
        """
        Type of actions that can be performed.
        """
elif False:
    NetworkTapRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkTapRuleActionArgs:
    def __init__(__self__, *,
                 destination_id: Optional[pulumi.Input[str]] = None,
                 is_timestamp_enabled: Optional[pulumi.Input[Union[str, 'BooleanEnumProperty']]] = None,
                 match_configuration_name: Optional[pulumi.Input[str]] = None,
                 truncate: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[Union[str, 'TapRuleActionType']]] = None):
        """
        Action that need to performed.
        :param pulumi.Input[str] destination_id: Destination Id. The ARM resource Id may be either Network To Network Interconnect or NeighborGroup.
        :param pulumi.Input[Union[str, 'BooleanEnumProperty']] is_timestamp_enabled: The parameter to enable or disable the timestamp.
        :param pulumi.Input[str] match_configuration_name: The name of the match configuration. This is used when Goto type is provided. If Goto type is selected and no match configuration name is provided. It goes to next configuration.
        :param pulumi.Input[str] truncate: Truncate. 0 indicates do not truncate.
        :param pulumi.Input[Union[str, 'TapRuleActionType']] type: Type of actions that can be performed.
        """
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if is_timestamp_enabled is not None:
            pulumi.set(__self__, "is_timestamp_enabled", is_timestamp_enabled)
        if match_configuration_name is not None:
            pulumi.set(__self__, "match_configuration_name", match_configuration_name)
        if truncate is not None:
            pulumi.set(__self__, "truncate", truncate)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[pulumi.Input[str]]:
        """
        Destination Id. The ARM resource Id may be either Network To Network Interconnect or NeighborGroup.
        """
        return pulumi.get(self, "destination_id")

    @destination_id.setter
    def destination_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_id", value)

    @property
    @pulumi.getter(name="isTimestampEnabled")
    def is_timestamp_enabled(self) -> Optional[pulumi.Input[Union[str, 'BooleanEnumProperty']]]:
        """
        The parameter to enable or disable the timestamp.
        """
        return pulumi.get(self, "is_timestamp_enabled")

    @is_timestamp_enabled.setter
    def is_timestamp_enabled(self, value: Optional[pulumi.Input[Union[str, 'BooleanEnumProperty']]]):
        pulumi.set(self, "is_timestamp_enabled", value)

    @property
    @pulumi.getter(name="matchConfigurationName")
    def match_configuration_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the match configuration. This is used when Goto type is provided. If Goto type is selected and no match configuration name is provided. It goes to next configuration.
        """
        return pulumi.get(self, "match_configuration_name")

    @match_configuration_name.setter
    def match_configuration_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_configuration_name", value)

    @property
    @pulumi.getter
    def truncate(self) -> Optional[pulumi.Input[str]]:
        """
        Truncate. 0 indicates do not truncate.
        """
        return pulumi.get(self, "truncate")

    @truncate.setter
    def truncate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "truncate", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'TapRuleActionType']]]:
        """
        Type of actions that can be performed.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'TapRuleActionType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NetworkTapRuleMatchConditionArgsDict(TypedDict):
        """
        Defines the match condition that is supported to filter the traffic.
        """
        encapsulation_type: NotRequired[pulumi.Input[Union[str, 'EncapsulationType']]]
        """
        Encapsulation Type that needs to be matched.
        """
        ip_condition: NotRequired[pulumi.Input['IpMatchConditionArgsDict']]
        """
        IP condition that needs to be matched.
        """
        port_condition: NotRequired[pulumi.Input['PortConditionArgsDict']]
        """
        Defines the port condition that needs to be matched.
        """
        protocol_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of the protocols that need to be matched.
        """
        vlan_match_condition: NotRequired[pulumi.Input['VlanMatchConditionArgsDict']]
        """
        Vlan match condition that needs to be matched.
        """
elif False:
    NetworkTapRuleMatchConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkTapRuleMatchConditionArgs:
    def __init__(__self__, *,
                 encapsulation_type: Optional[pulumi.Input[Union[str, 'EncapsulationType']]] = None,
                 ip_condition: Optional[pulumi.Input['IpMatchConditionArgs']] = None,
                 port_condition: Optional[pulumi.Input['PortConditionArgs']] = None,
                 protocol_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vlan_match_condition: Optional[pulumi.Input['VlanMatchConditionArgs']] = None):
        """
        Defines the match condition that is supported to filter the traffic.
        :param pulumi.Input[Union[str, 'EncapsulationType']] encapsulation_type: Encapsulation Type that needs to be matched.
        :param pulumi.Input['IpMatchConditionArgs'] ip_condition: IP condition that needs to be matched.
        :param pulumi.Input['PortConditionArgs'] port_condition: Defines the port condition that needs to be matched.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] protocol_types: List of the protocols that need to be matched.
        :param pulumi.Input['VlanMatchConditionArgs'] vlan_match_condition: Vlan match condition that needs to be matched.
        """
        if encapsulation_type is None:
            encapsulation_type = 'None'
        if encapsulation_type is not None:
            pulumi.set(__self__, "encapsulation_type", encapsulation_type)
        if ip_condition is not None:
            pulumi.set(__self__, "ip_condition", ip_condition)
        if port_condition is not None:
            pulumi.set(__self__, "port_condition", port_condition)
        if protocol_types is not None:
            pulumi.set(__self__, "protocol_types", protocol_types)
        if vlan_match_condition is not None:
            pulumi.set(__self__, "vlan_match_condition", vlan_match_condition)

    @property
    @pulumi.getter(name="encapsulationType")
    def encapsulation_type(self) -> Optional[pulumi.Input[Union[str, 'EncapsulationType']]]:
        """
        Encapsulation Type that needs to be matched.
        """
        return pulumi.get(self, "encapsulation_type")

    @encapsulation_type.setter
    def encapsulation_type(self, value: Optional[pulumi.Input[Union[str, 'EncapsulationType']]]):
        pulumi.set(self, "encapsulation_type", value)

    @property
    @pulumi.getter(name="ipCondition")
    def ip_condition(self) -> Optional[pulumi.Input['IpMatchConditionArgs']]:
        """
        IP condition that needs to be matched.
        """
        return pulumi.get(self, "ip_condition")

    @ip_condition.setter
    def ip_condition(self, value: Optional[pulumi.Input['IpMatchConditionArgs']]):
        pulumi.set(self, "ip_condition", value)

    @property
    @pulumi.getter(name="portCondition")
    def port_condition(self) -> Optional[pulumi.Input['PortConditionArgs']]:
        """
        Defines the port condition that needs to be matched.
        """
        return pulumi.get(self, "port_condition")

    @port_condition.setter
    def port_condition(self, value: Optional[pulumi.Input['PortConditionArgs']]):
        pulumi.set(self, "port_condition", value)

    @property
    @pulumi.getter(name="protocolTypes")
    def protocol_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of the protocols that need to be matched.
        """
        return pulumi.get(self, "protocol_types")

    @protocol_types.setter
    def protocol_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "protocol_types", value)

    @property
    @pulumi.getter(name="vlanMatchCondition")
    def vlan_match_condition(self) -> Optional[pulumi.Input['VlanMatchConditionArgs']]:
        """
        Vlan match condition that needs to be matched.
        """
        return pulumi.get(self, "vlan_match_condition")

    @vlan_match_condition.setter
    def vlan_match_condition(self, value: Optional[pulumi.Input['VlanMatchConditionArgs']]):
        pulumi.set(self, "vlan_match_condition", value)


if not MYPY:
    class NetworkTapRuleMatchConfigurationArgsDict(TypedDict):
        """
        Defines the match configuration that are supported to filter the traffic.
        """
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkTapRuleActionArgsDict']]]]
        """
        List of actions that need to be performed for the matched conditions.
        """
        ip_address_type: NotRequired[pulumi.Input[Union[str, 'IPAddressType']]]
        """
        Type of IP Address. IPv4 or IPv6
        """
        match_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkTapRuleMatchConditionArgsDict']]]]
        """
        List of the match conditions.
        """
        match_configuration_name: NotRequired[pulumi.Input[str]]
        """
        The name of the match configuration.
        """
        sequence_number: NotRequired[pulumi.Input[float]]
        """
        Sequence Number of the match configuration..
        """
elif False:
    NetworkTapRuleMatchConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkTapRuleMatchConfigurationArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkTapRuleActionArgs']]]] = None,
                 ip_address_type: Optional[pulumi.Input[Union[str, 'IPAddressType']]] = None,
                 match_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkTapRuleMatchConditionArgs']]]] = None,
                 match_configuration_name: Optional[pulumi.Input[str]] = None,
                 sequence_number: Optional[pulumi.Input[float]] = None):
        """
        Defines the match configuration that are supported to filter the traffic.
        :param pulumi.Input[Sequence[pulumi.Input['NetworkTapRuleActionArgs']]] actions: List of actions that need to be performed for the matched conditions.
        :param pulumi.Input[Union[str, 'IPAddressType']] ip_address_type: Type of IP Address. IPv4 or IPv6
        :param pulumi.Input[Sequence[pulumi.Input['NetworkTapRuleMatchConditionArgs']]] match_conditions: List of the match conditions.
        :param pulumi.Input[str] match_configuration_name: The name of the match configuration.
        :param pulumi.Input[float] sequence_number: Sequence Number of the match configuration..
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)
        if match_conditions is not None:
            pulumi.set(__self__, "match_conditions", match_conditions)
        if match_configuration_name is not None:
            pulumi.set(__self__, "match_configuration_name", match_configuration_name)
        if sequence_number is not None:
            pulumi.set(__self__, "sequence_number", sequence_number)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkTapRuleActionArgs']]]]:
        """
        List of actions that need to be performed for the matched conditions.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkTapRuleActionArgs']]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[pulumi.Input[Union[str, 'IPAddressType']]]:
        """
        Type of IP Address. IPv4 or IPv6
        """
        return pulumi.get(self, "ip_address_type")

    @ip_address_type.setter
    def ip_address_type(self, value: Optional[pulumi.Input[Union[str, 'IPAddressType']]]):
        pulumi.set(self, "ip_address_type", value)

    @property
    @pulumi.getter(name="matchConditions")
    def match_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkTapRuleMatchConditionArgs']]]]:
        """
        List of the match conditions.
        """
        return pulumi.get(self, "match_conditions")

    @match_conditions.setter
    def match_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkTapRuleMatchConditionArgs']]]]):
        pulumi.set(self, "match_conditions", value)

    @property
    @pulumi.getter(name="matchConfigurationName")
    def match_configuration_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the match configuration.
        """
        return pulumi.get(self, "match_configuration_name")

    @match_configuration_name.setter
    def match_configuration_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_configuration_name", value)

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> Optional[pulumi.Input[float]]:
        """
        Sequence Number of the match configuration..
        """
        return pulumi.get(self, "sequence_number")

    @sequence_number.setter
    def sequence_number(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "sequence_number", value)


if not MYPY:
    class NetworkToNetworkInterconnectPropertiesOptionBLayer3ConfigurationArgsDict(TypedDict):
        """
        Common properties for Layer3Configuration.
        """
        peer_asn: pulumi.Input[float]
        """
        ASN of PE devices for CE/PE connectivity.Example : 28
        """
        vlan_id: pulumi.Input[int]
        """
        VLAN for CE/PE Layer 3 connectivity.Example : 501
        """
        primary_ipv4_prefix: NotRequired[pulumi.Input[str]]
        """
        IPv4 Address Prefix.
        """
        primary_ipv6_prefix: NotRequired[pulumi.Input[str]]
        """
        IPv6 Address Prefix.
        """
        secondary_ipv4_prefix: NotRequired[pulumi.Input[str]]
        """
        Secondary IPv4 Address Prefix.
        """
        secondary_ipv6_prefix: NotRequired[pulumi.Input[str]]
        """
        Secondary IPv6 Address Prefix.
        """
elif False:
    NetworkToNetworkInterconnectPropertiesOptionBLayer3ConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkToNetworkInterconnectPropertiesOptionBLayer3ConfigurationArgs:
    def __init__(__self__, *,
                 peer_asn: pulumi.Input[float],
                 vlan_id: pulumi.Input[int],
                 primary_ipv4_prefix: Optional[pulumi.Input[str]] = None,
                 primary_ipv6_prefix: Optional[pulumi.Input[str]] = None,
                 secondary_ipv4_prefix: Optional[pulumi.Input[str]] = None,
                 secondary_ipv6_prefix: Optional[pulumi.Input[str]] = None):
        """
        Common properties for Layer3Configuration.
        :param pulumi.Input[float] peer_asn: ASN of PE devices for CE/PE connectivity.Example : 28
        :param pulumi.Input[int] vlan_id: VLAN for CE/PE Layer 3 connectivity.Example : 501
        :param pulumi.Input[str] primary_ipv4_prefix: IPv4 Address Prefix.
        :param pulumi.Input[str] primary_ipv6_prefix: IPv6 Address Prefix.
        :param pulumi.Input[str] secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
        :param pulumi.Input[str] secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
        """
        pulumi.set(__self__, "peer_asn", peer_asn)
        pulumi.set(__self__, "vlan_id", vlan_id)
        if primary_ipv4_prefix is not None:
            pulumi.set(__self__, "primary_ipv4_prefix", primary_ipv4_prefix)
        if primary_ipv6_prefix is not None:
            pulumi.set(__self__, "primary_ipv6_prefix", primary_ipv6_prefix)
        if secondary_ipv4_prefix is not None:
            pulumi.set(__self__, "secondary_ipv4_prefix", secondary_ipv4_prefix)
        if secondary_ipv6_prefix is not None:
            pulumi.set(__self__, "secondary_ipv6_prefix", secondary_ipv6_prefix)

    @property
    @pulumi.getter(name="peerASN")
    def peer_asn(self) -> pulumi.Input[float]:
        """
        ASN of PE devices for CE/PE connectivity.Example : 28
        """
        return pulumi.get(self, "peer_asn")

    @peer_asn.setter
    def peer_asn(self, value: pulumi.Input[float]):
        pulumi.set(self, "peer_asn", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> pulumi.Input[int]:
        """
        VLAN for CE/PE Layer 3 connectivity.Example : 501
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "vlan_id", value)

    @property
    @pulumi.getter(name="primaryIpv4Prefix")
    def primary_ipv4_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        IPv4 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv4_prefix")

    @primary_ipv4_prefix.setter
    def primary_ipv4_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_ipv4_prefix", value)

    @property
    @pulumi.getter(name="primaryIpv6Prefix")
    def primary_ipv6_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        IPv6 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv6_prefix")

    @primary_ipv6_prefix.setter
    def primary_ipv6_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_ipv6_prefix", value)

    @property
    @pulumi.getter(name="secondaryIpv4Prefix")
    def secondary_ipv4_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Secondary IPv4 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv4_prefix")

    @secondary_ipv4_prefix.setter
    def secondary_ipv4_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secondary_ipv4_prefix", value)

    @property
    @pulumi.getter(name="secondaryIpv6Prefix")
    def secondary_ipv6_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Secondary IPv6 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv6_prefix")

    @secondary_ipv6_prefix.setter
    def secondary_ipv6_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secondary_ipv6_prefix", value)


if not MYPY:
    class NpbStaticRouteConfigurationArgsDict(TypedDict):
        """
        NPB Static Route Configuration properties.
        """
        bfd_configuration: NotRequired[pulumi.Input['BfdConfigurationArgsDict']]
        """
        BFD Configuration properties.
        """
        ipv4_routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['StaticRoutePropertiesArgsDict']]]]
        """
        List of IPv4 Routes.
        """
        ipv6_routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['StaticRoutePropertiesArgsDict']]]]
        """
        List of IPv6 Routes.
        """
elif False:
    NpbStaticRouteConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NpbStaticRouteConfigurationArgs:
    def __init__(__self__, *,
                 bfd_configuration: Optional[pulumi.Input['BfdConfigurationArgs']] = None,
                 ipv4_routes: Optional[pulumi.Input[Sequence[pulumi.Input['StaticRoutePropertiesArgs']]]] = None,
                 ipv6_routes: Optional[pulumi.Input[Sequence[pulumi.Input['StaticRoutePropertiesArgs']]]] = None):
        """
        NPB Static Route Configuration properties.
        :param pulumi.Input['BfdConfigurationArgs'] bfd_configuration: BFD Configuration properties.
        :param pulumi.Input[Sequence[pulumi.Input['StaticRoutePropertiesArgs']]] ipv4_routes: List of IPv4 Routes.
        :param pulumi.Input[Sequence[pulumi.Input['StaticRoutePropertiesArgs']]] ipv6_routes: List of IPv6 Routes.
        """
        if bfd_configuration is not None:
            pulumi.set(__self__, "bfd_configuration", bfd_configuration)
        if ipv4_routes is not None:
            pulumi.set(__self__, "ipv4_routes", ipv4_routes)
        if ipv6_routes is not None:
            pulumi.set(__self__, "ipv6_routes", ipv6_routes)

    @property
    @pulumi.getter(name="bfdConfiguration")
    def bfd_configuration(self) -> Optional[pulumi.Input['BfdConfigurationArgs']]:
        """
        BFD Configuration properties.
        """
        return pulumi.get(self, "bfd_configuration")

    @bfd_configuration.setter
    def bfd_configuration(self, value: Optional[pulumi.Input['BfdConfigurationArgs']]):
        pulumi.set(self, "bfd_configuration", value)

    @property
    @pulumi.getter(name="ipv4Routes")
    def ipv4_routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StaticRoutePropertiesArgs']]]]:
        """
        List of IPv4 Routes.
        """
        return pulumi.get(self, "ipv4_routes")

    @ipv4_routes.setter
    def ipv4_routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StaticRoutePropertiesArgs']]]]):
        pulumi.set(self, "ipv4_routes", value)

    @property
    @pulumi.getter(name="ipv6Routes")
    def ipv6_routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StaticRoutePropertiesArgs']]]]:
        """
        List of IPv6 Routes.
        """
        return pulumi.get(self, "ipv6_routes")

    @ipv6_routes.setter
    def ipv6_routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StaticRoutePropertiesArgs']]]]):
        pulumi.set(self, "ipv6_routes", value)


if not MYPY:
    class PortConditionArgsDict(TypedDict):
        """
        Port condition that needs to be matched.
        """
        layer4_protocol: pulumi.Input[Union[str, 'Layer4Protocol']]
        """
        Layer4 protocol type that needs to be matched.
        """
        port_group_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of the port Group Names that need to be matched.
        """
        port_type: NotRequired[pulumi.Input[Union[str, 'PortType']]]
        """
        Port type that needs to be matched.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of the Ports that need to be matched.
        """
elif False:
    PortConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortConditionArgs:
    def __init__(__self__, *,
                 layer4_protocol: pulumi.Input[Union[str, 'Layer4Protocol']],
                 port_group_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 port_type: Optional[pulumi.Input[Union[str, 'PortType']]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Port condition that needs to be matched.
        :param pulumi.Input[Union[str, 'Layer4Protocol']] layer4_protocol: Layer4 protocol type that needs to be matched.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] port_group_names: List of the port Group Names that need to be matched.
        :param pulumi.Input[Union[str, 'PortType']] port_type: Port type that needs to be matched.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ports: List of the Ports that need to be matched.
        """
        pulumi.set(__self__, "layer4_protocol", layer4_protocol)
        if port_group_names is not None:
            pulumi.set(__self__, "port_group_names", port_group_names)
        if port_type is not None:
            pulumi.set(__self__, "port_type", port_type)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter(name="layer4Protocol")
    def layer4_protocol(self) -> pulumi.Input[Union[str, 'Layer4Protocol']]:
        """
        Layer4 protocol type that needs to be matched.
        """
        return pulumi.get(self, "layer4_protocol")

    @layer4_protocol.setter
    def layer4_protocol(self, value: pulumi.Input[Union[str, 'Layer4Protocol']]):
        pulumi.set(self, "layer4_protocol", value)

    @property
    @pulumi.getter(name="portGroupNames")
    def port_group_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of the port Group Names that need to be matched.
        """
        return pulumi.get(self, "port_group_names")

    @port_group_names.setter
    def port_group_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "port_group_names", value)

    @property
    @pulumi.getter(name="portType")
    def port_type(self) -> Optional[pulumi.Input[Union[str, 'PortType']]]:
        """
        Port type that needs to be matched.
        """
        return pulumi.get(self, "port_type")

    @port_type.setter
    def port_type(self, value: Optional[pulumi.Input[Union[str, 'PortType']]]):
        pulumi.set(self, "port_type", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of the Ports that need to be matched.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class PortGroupPropertiesArgsDict(TypedDict):
        """
        Port Group properties.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the port group.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of the ports that need to be matched.
        """
elif False:
    PortGroupPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortGroupPropertiesArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Port Group properties.
        :param pulumi.Input[str] name: The name of the port group.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ports: List of the ports that need to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the port group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of the ports that need to be matched.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class RoutePolicyStatementPropertiesArgsDict(TypedDict):
        """
        Route Policy Statement properties.
        """
        action: pulumi.Input['StatementActionPropertiesArgsDict']
        """
        Route policy action properties.
        """
        condition: pulumi.Input['StatementConditionPropertiesArgsDict']
        """
        Route policy condition properties.
        """
        sequence_number: pulumi.Input[float]
        """
        Sequence to insert to/delete from existing route.
        """
        annotation: NotRequired[pulumi.Input[str]]
        """
        Switch configuration description.
        """
elif False:
    RoutePolicyStatementPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutePolicyStatementPropertiesArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['StatementActionPropertiesArgs'],
                 condition: pulumi.Input['StatementConditionPropertiesArgs'],
                 sequence_number: pulumi.Input[float],
                 annotation: Optional[pulumi.Input[str]] = None):
        """
        Route Policy Statement properties.
        :param pulumi.Input['StatementActionPropertiesArgs'] action: Route policy action properties.
        :param pulumi.Input['StatementConditionPropertiesArgs'] condition: Route policy condition properties.
        :param pulumi.Input[float] sequence_number: Sequence to insert to/delete from existing route.
        :param pulumi.Input[str] annotation: Switch configuration description.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "sequence_number", sequence_number)
        if annotation is not None:
            pulumi.set(__self__, "annotation", annotation)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['StatementActionPropertiesArgs']:
        """
        Route policy action properties.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['StatementActionPropertiesArgs']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input['StatementConditionPropertiesArgs']:
        """
        Route policy condition properties.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['StatementConditionPropertiesArgs']):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> pulumi.Input[float]:
        """
        Sequence to insert to/delete from existing route.
        """
        return pulumi.get(self, "sequence_number")

    @sequence_number.setter
    def sequence_number(self, value: pulumi.Input[float]):
        pulumi.set(self, "sequence_number", value)

    @property
    @pulumi.getter
    def annotation(self) -> Optional[pulumi.Input[str]]:
        """
        Switch configuration description.
        """
        return pulumi.get(self, "annotation")

    @annotation.setter
    def annotation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "annotation", value)


if not MYPY:
    class RouteTargetInformationArgsDict(TypedDict):
        """
        Route Target Configuration.
        """
        export_ipv4_route_targets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Route Targets to be applied for outgoing routes into CE.
        """
        export_ipv6_route_targets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Route Targets to be applied for outgoing routes from CE.
        """
        import_ipv4_route_targets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Route Targets to be applied for incoming routes into CE.
        """
        import_ipv6_route_targets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Route Targets to be applied for incoming routes from CE.
        """
elif False:
    RouteTargetInformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteTargetInformationArgs:
    def __init__(__self__, *,
                 export_ipv4_route_targets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 export_ipv6_route_targets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 import_ipv4_route_targets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 import_ipv6_route_targets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Route Target Configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] export_ipv4_route_targets: Route Targets to be applied for outgoing routes into CE.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] export_ipv6_route_targets: Route Targets to be applied for outgoing routes from CE.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] import_ipv4_route_targets: Route Targets to be applied for incoming routes into CE.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] import_ipv6_route_targets: Route Targets to be applied for incoming routes from CE.
        """
        if export_ipv4_route_targets is not None:
            pulumi.set(__self__, "export_ipv4_route_targets", export_ipv4_route_targets)
        if export_ipv6_route_targets is not None:
            pulumi.set(__self__, "export_ipv6_route_targets", export_ipv6_route_targets)
        if import_ipv4_route_targets is not None:
            pulumi.set(__self__, "import_ipv4_route_targets", import_ipv4_route_targets)
        if import_ipv6_route_targets is not None:
            pulumi.set(__self__, "import_ipv6_route_targets", import_ipv6_route_targets)

    @property
    @pulumi.getter(name="exportIpv4RouteTargets")
    def export_ipv4_route_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Route Targets to be applied for outgoing routes into CE.
        """
        return pulumi.get(self, "export_ipv4_route_targets")

    @export_ipv4_route_targets.setter
    def export_ipv4_route_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "export_ipv4_route_targets", value)

    @property
    @pulumi.getter(name="exportIpv6RouteTargets")
    def export_ipv6_route_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Route Targets to be applied for outgoing routes from CE.
        """
        return pulumi.get(self, "export_ipv6_route_targets")

    @export_ipv6_route_targets.setter
    def export_ipv6_route_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "export_ipv6_route_targets", value)

    @property
    @pulumi.getter(name="importIpv4RouteTargets")
    def import_ipv4_route_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Route Targets to be applied for incoming routes into CE.
        """
        return pulumi.get(self, "import_ipv4_route_targets")

    @import_ipv4_route_targets.setter
    def import_ipv4_route_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "import_ipv4_route_targets", value)

    @property
    @pulumi.getter(name="importIpv6RouteTargets")
    def import_ipv6_route_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Route Targets to be applied for incoming routes from CE.
        """
        return pulumi.get(self, "import_ipv6_route_targets")

    @import_ipv6_route_targets.setter
    def import_ipv6_route_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "import_ipv6_route_targets", value)


if not MYPY:
    class RulePropertiesArgsDict(TypedDict):
        """
        Rules for the InternetGateways
        """
        action: pulumi.Input[Union[str, 'Action']]
        """
        Specify action.
        """
        address_list: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of Addresses to be allowed or denied.
        """
elif False:
    RulePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulePropertiesArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[Union[str, 'Action']],
                 address_list: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Rules for the InternetGateways
        :param pulumi.Input[Union[str, 'Action']] action: Specify action.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] address_list: List of Addresses to be allowed or denied.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "address_list", address_list)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[Union[str, 'Action']]:
        """
        Specify action.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[Union[str, 'Action']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="addressList")
    def address_list(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of Addresses to be allowed or denied.
        """
        return pulumi.get(self, "address_list")

    @address_list.setter
    def address_list(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "address_list", value)


if not MYPY:
    class StatementActionPropertiesArgsDict(TypedDict):
        """
        Route policy action properties.
        """
        action_type: pulumi.Input[Union[str, 'RoutePolicyActionType']]
        """
        Action type. Example: Permit | Deny | Continue.
        """
        ip_community_properties: NotRequired[pulumi.Input['ActionIpCommunityPropertiesArgsDict']]
        """
        IP Community Properties.
        """
        ip_extended_community_properties: NotRequired[pulumi.Input['ActionIpExtendedCommunityPropertiesArgsDict']]
        """
        IP Extended Community Properties.
        """
        local_preference: NotRequired[pulumi.Input[float]]
        """
        Local Preference of the route policy.
        """
elif False:
    StatementActionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatementActionPropertiesArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[Union[str, 'RoutePolicyActionType']],
                 ip_community_properties: Optional[pulumi.Input['ActionIpCommunityPropertiesArgs']] = None,
                 ip_extended_community_properties: Optional[pulumi.Input['ActionIpExtendedCommunityPropertiesArgs']] = None,
                 local_preference: Optional[pulumi.Input[float]] = None):
        """
        Route policy action properties.
        :param pulumi.Input[Union[str, 'RoutePolicyActionType']] action_type: Action type. Example: Permit | Deny | Continue.
        :param pulumi.Input['ActionIpCommunityPropertiesArgs'] ip_community_properties: IP Community Properties.
        :param pulumi.Input['ActionIpExtendedCommunityPropertiesArgs'] ip_extended_community_properties: IP Extended Community Properties.
        :param pulumi.Input[float] local_preference: Local Preference of the route policy.
        """
        pulumi.set(__self__, "action_type", action_type)
        if ip_community_properties is not None:
            pulumi.set(__self__, "ip_community_properties", ip_community_properties)
        if ip_extended_community_properties is not None:
            pulumi.set(__self__, "ip_extended_community_properties", ip_extended_community_properties)
        if local_preference is not None:
            pulumi.set(__self__, "local_preference", local_preference)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[Union[str, 'RoutePolicyActionType']]:
        """
        Action type. Example: Permit | Deny | Continue.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[Union[str, 'RoutePolicyActionType']]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter(name="ipCommunityProperties")
    def ip_community_properties(self) -> Optional[pulumi.Input['ActionIpCommunityPropertiesArgs']]:
        """
        IP Community Properties.
        """
        return pulumi.get(self, "ip_community_properties")

    @ip_community_properties.setter
    def ip_community_properties(self, value: Optional[pulumi.Input['ActionIpCommunityPropertiesArgs']]):
        pulumi.set(self, "ip_community_properties", value)

    @property
    @pulumi.getter(name="ipExtendedCommunityProperties")
    def ip_extended_community_properties(self) -> Optional[pulumi.Input['ActionIpExtendedCommunityPropertiesArgs']]:
        """
        IP Extended Community Properties.
        """
        return pulumi.get(self, "ip_extended_community_properties")

    @ip_extended_community_properties.setter
    def ip_extended_community_properties(self, value: Optional[pulumi.Input['ActionIpExtendedCommunityPropertiesArgs']]):
        pulumi.set(self, "ip_extended_community_properties", value)

    @property
    @pulumi.getter(name="localPreference")
    def local_preference(self) -> Optional[pulumi.Input[float]]:
        """
        Local Preference of the route policy.
        """
        return pulumi.get(self, "local_preference")

    @local_preference.setter
    def local_preference(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "local_preference", value)


if not MYPY:
    class StatementConditionPropertiesArgsDict(TypedDict):
        """
        Route policy statement condition properties.
        """
        ip_community_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of IP Community resource IDs.
        """
        ip_extended_community_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of IP Extended Community resource IDs.
        """
        ip_prefix_id: NotRequired[pulumi.Input[str]]
        """
        Arm Resource Id of IpPrefix.
        """
        type: NotRequired[pulumi.Input[Union[str, 'RoutePolicyConditionType']]]
        """
        Type of the condition used.
        """
elif False:
    StatementConditionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatementConditionPropertiesArgs:
    def __init__(__self__, *,
                 ip_community_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip_extended_community_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip_prefix_id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[Union[str, 'RoutePolicyConditionType']]] = None):
        """
        Route policy statement condition properties.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_community_ids: List of IP Community resource IDs.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_extended_community_ids: List of IP Extended Community resource IDs.
        :param pulumi.Input[str] ip_prefix_id: Arm Resource Id of IpPrefix.
        :param pulumi.Input[Union[str, 'RoutePolicyConditionType']] type: Type of the condition used.
        """
        if ip_community_ids is not None:
            pulumi.set(__self__, "ip_community_ids", ip_community_ids)
        if ip_extended_community_ids is not None:
            pulumi.set(__self__, "ip_extended_community_ids", ip_extended_community_ids)
        if ip_prefix_id is not None:
            pulumi.set(__self__, "ip_prefix_id", ip_prefix_id)
        if type is None:
            type = 'Or'
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="ipCommunityIds")
    def ip_community_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IP Community resource IDs.
        """
        return pulumi.get(self, "ip_community_ids")

    @ip_community_ids.setter
    def ip_community_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_community_ids", value)

    @property
    @pulumi.getter(name="ipExtendedCommunityIds")
    def ip_extended_community_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IP Extended Community resource IDs.
        """
        return pulumi.get(self, "ip_extended_community_ids")

    @ip_extended_community_ids.setter
    def ip_extended_community_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_extended_community_ids", value)

    @property
    @pulumi.getter(name="ipPrefixId")
    def ip_prefix_id(self) -> Optional[pulumi.Input[str]]:
        """
        Arm Resource Id of IpPrefix.
        """
        return pulumi.get(self, "ip_prefix_id")

    @ip_prefix_id.setter
    def ip_prefix_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_prefix_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'RoutePolicyConditionType']]]:
        """
        Type of the condition used.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'RoutePolicyConditionType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class StaticRoutePropertiesArgsDict(TypedDict):
        """
        Route Properties.
        """
        next_hop: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of next hop addresses.
        """
        prefix: pulumi.Input[str]
        """
        Prefix of the route.
        """
elif False:
    StaticRoutePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StaticRoutePropertiesArgs:
    def __init__(__self__, *,
                 next_hop: pulumi.Input[Sequence[pulumi.Input[str]]],
                 prefix: pulumi.Input[str]):
        """
        Route Properties.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_hop: List of next hop addresses.
        :param pulumi.Input[str] prefix: Prefix of the route.
        """
        pulumi.set(__self__, "next_hop", next_hop)
        pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of next hop addresses.
        """
        return pulumi.get(self, "next_hop")

    @next_hop.setter
    def next_hop(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "next_hop", value)

    @property
    @pulumi.getter
    def prefix(self) -> pulumi.Input[str]:
        """
        Prefix of the route.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class TerminalServerConfigurationArgsDict(TypedDict):
        """
        Network and credentials configuration currently applied to terminal server.
        """
        password: pulumi.Input[str]
        """
        Password for the terminal server connection.
        """
        primary_ipv4_prefix: pulumi.Input[str]
        """
        IPv4 Address Prefix.
        """
        secondary_ipv4_prefix: pulumi.Input[str]
        """
        Secondary IPv4 Address Prefix.
        """
        username: pulumi.Input[str]
        """
        Username for the terminal server connection.
        """
        primary_ipv6_prefix: NotRequired[pulumi.Input[str]]
        """
        IPv6 Address Prefix.
        """
        secondary_ipv6_prefix: NotRequired[pulumi.Input[str]]
        """
        Secondary IPv6 Address Prefix.
        """
        serial_number: NotRequired[pulumi.Input[str]]
        """
        Serial Number of Terminal server.
        """
elif False:
    TerminalServerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TerminalServerConfigurationArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 primary_ipv4_prefix: pulumi.Input[str],
                 secondary_ipv4_prefix: pulumi.Input[str],
                 username: pulumi.Input[str],
                 primary_ipv6_prefix: Optional[pulumi.Input[str]] = None,
                 secondary_ipv6_prefix: Optional[pulumi.Input[str]] = None,
                 serial_number: Optional[pulumi.Input[str]] = None):
        """
        Network and credentials configuration currently applied to terminal server.
        :param pulumi.Input[str] password: Password for the terminal server connection.
        :param pulumi.Input[str] primary_ipv4_prefix: IPv4 Address Prefix.
        :param pulumi.Input[str] secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
        :param pulumi.Input[str] username: Username for the terminal server connection.
        :param pulumi.Input[str] primary_ipv6_prefix: IPv6 Address Prefix.
        :param pulumi.Input[str] secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
        :param pulumi.Input[str] serial_number: Serial Number of Terminal server.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "primary_ipv4_prefix", primary_ipv4_prefix)
        pulumi.set(__self__, "secondary_ipv4_prefix", secondary_ipv4_prefix)
        pulumi.set(__self__, "username", username)
        if primary_ipv6_prefix is not None:
            pulumi.set(__self__, "primary_ipv6_prefix", primary_ipv6_prefix)
        if secondary_ipv6_prefix is not None:
            pulumi.set(__self__, "secondary_ipv6_prefix", secondary_ipv6_prefix)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Password for the terminal server connection.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="primaryIpv4Prefix")
    def primary_ipv4_prefix(self) -> pulumi.Input[str]:
        """
        IPv4 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv4_prefix")

    @primary_ipv4_prefix.setter
    def primary_ipv4_prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "primary_ipv4_prefix", value)

    @property
    @pulumi.getter(name="secondaryIpv4Prefix")
    def secondary_ipv4_prefix(self) -> pulumi.Input[str]:
        """
        Secondary IPv4 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv4_prefix")

    @secondary_ipv4_prefix.setter
    def secondary_ipv4_prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "secondary_ipv4_prefix", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username for the terminal server connection.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="primaryIpv6Prefix")
    def primary_ipv6_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        IPv6 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv6_prefix")

    @primary_ipv6_prefix.setter
    def primary_ipv6_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_ipv6_prefix", value)

    @property
    @pulumi.getter(name="secondaryIpv6Prefix")
    def secondary_ipv6_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Secondary IPv6 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv6_prefix")

    @secondary_ipv6_prefix.setter
    def secondary_ipv6_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secondary_ipv6_prefix", value)

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[pulumi.Input[str]]:
        """
        Serial Number of Terminal server.
        """
        return pulumi.get(self, "serial_number")

    @serial_number.setter
    def serial_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "serial_number", value)


if not MYPY:
    class VlanGroupPropertiesArgsDict(TypedDict):
        """
        Vlan group properties.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Vlan group name.
        """
        vlans: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of vlans.
        """
elif False:
    VlanGroupPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VlanGroupPropertiesArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 vlans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Vlan group properties.
        :param pulumi.Input[str] name: Vlan group name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vlans: List of vlans.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if vlans is not None:
            pulumi.set(__self__, "vlans", vlans)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Vlan group name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def vlans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of vlans.
        """
        return pulumi.get(self, "vlans")

    @vlans.setter
    def vlans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vlans", value)


if not MYPY:
    class VlanMatchConditionArgsDict(TypedDict):
        """
        The vlan match conditions that need to be matched.
        """
        inner_vlans: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of inner vlans that need to be matched.
        """
        vlan_group_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of vlan group names that need to be matched.
        """
        vlans: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of vlans that need to be matched.
        """
elif False:
    VlanMatchConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VlanMatchConditionArgs:
    def __init__(__self__, *,
                 inner_vlans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vlan_group_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vlans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The vlan match conditions that need to be matched.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] inner_vlans: List of inner vlans that need to be matched.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vlan_group_names: List of vlan group names that need to be matched.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vlans: List of vlans that need to be matched.
        """
        if inner_vlans is not None:
            pulumi.set(__self__, "inner_vlans", inner_vlans)
        if vlan_group_names is not None:
            pulumi.set(__self__, "vlan_group_names", vlan_group_names)
        if vlans is not None:
            pulumi.set(__self__, "vlans", vlans)

    @property
    @pulumi.getter(name="innerVlans")
    def inner_vlans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of inner vlans that need to be matched.
        """
        return pulumi.get(self, "inner_vlans")

    @inner_vlans.setter
    def inner_vlans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "inner_vlans", value)

    @property
    @pulumi.getter(name="vlanGroupNames")
    def vlan_group_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of vlan group names that need to be matched.
        """
        return pulumi.get(self, "vlan_group_names")

    @vlan_group_names.setter
    def vlan_group_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vlan_group_names", value)

    @property
    @pulumi.getter
    def vlans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of vlans that need to be matched.
        """
        return pulumi.get(self, "vlans")

    @vlans.setter
    def vlans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vlans", value)


if not MYPY:
    class VpnConfigurationPropertiesOptionAPropertiesArgsDict(TypedDict):
        """
        option A properties
        """
        peer_asn: pulumi.Input[float]
        """
        Peer ASN number.Example : 28
        """
        vlan_id: pulumi.Input[int]
        """
        Vlan Id.Example : 501
        """
        bfd_configuration: NotRequired[pulumi.Input['BfdConfigurationArgsDict']]
        """
        BFD Configuration properties.
        """
        mtu: NotRequired[pulumi.Input[int]]
        """
        MTU to use for option A peering.
        """
        primary_ipv4_prefix: NotRequired[pulumi.Input[str]]
        """
        IPv4 Address Prefix.
        """
        primary_ipv6_prefix: NotRequired[pulumi.Input[str]]
        """
        IPv6 Address Prefix.
        """
        secondary_ipv4_prefix: NotRequired[pulumi.Input[str]]
        """
        Secondary IPv4 Address Prefix.
        """
        secondary_ipv6_prefix: NotRequired[pulumi.Input[str]]
        """
        Secondary IPv6 Address Prefix.
        """
elif False:
    VpnConfigurationPropertiesOptionAPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConfigurationPropertiesOptionAPropertiesArgs:
    def __init__(__self__, *,
                 peer_asn: pulumi.Input[float],
                 vlan_id: pulumi.Input[int],
                 bfd_configuration: Optional[pulumi.Input['BfdConfigurationArgs']] = None,
                 mtu: Optional[pulumi.Input[int]] = None,
                 primary_ipv4_prefix: Optional[pulumi.Input[str]] = None,
                 primary_ipv6_prefix: Optional[pulumi.Input[str]] = None,
                 secondary_ipv4_prefix: Optional[pulumi.Input[str]] = None,
                 secondary_ipv6_prefix: Optional[pulumi.Input[str]] = None):
        """
        option A properties
        :param pulumi.Input[float] peer_asn: Peer ASN number.Example : 28
        :param pulumi.Input[int] vlan_id: Vlan Id.Example : 501
        :param pulumi.Input['BfdConfigurationArgs'] bfd_configuration: BFD Configuration properties.
        :param pulumi.Input[int] mtu: MTU to use for option A peering.
        :param pulumi.Input[str] primary_ipv4_prefix: IPv4 Address Prefix.
        :param pulumi.Input[str] primary_ipv6_prefix: IPv6 Address Prefix.
        :param pulumi.Input[str] secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
        :param pulumi.Input[str] secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
        """
        pulumi.set(__self__, "peer_asn", peer_asn)
        pulumi.set(__self__, "vlan_id", vlan_id)
        if bfd_configuration is not None:
            pulumi.set(__self__, "bfd_configuration", bfd_configuration)
        if mtu is None:
            mtu = 1500
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if primary_ipv4_prefix is not None:
            pulumi.set(__self__, "primary_ipv4_prefix", primary_ipv4_prefix)
        if primary_ipv6_prefix is not None:
            pulumi.set(__self__, "primary_ipv6_prefix", primary_ipv6_prefix)
        if secondary_ipv4_prefix is not None:
            pulumi.set(__self__, "secondary_ipv4_prefix", secondary_ipv4_prefix)
        if secondary_ipv6_prefix is not None:
            pulumi.set(__self__, "secondary_ipv6_prefix", secondary_ipv6_prefix)

    @property
    @pulumi.getter(name="peerASN")
    def peer_asn(self) -> pulumi.Input[float]:
        """
        Peer ASN number.Example : 28
        """
        return pulumi.get(self, "peer_asn")

    @peer_asn.setter
    def peer_asn(self, value: pulumi.Input[float]):
        pulumi.set(self, "peer_asn", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> pulumi.Input[int]:
        """
        Vlan Id.Example : 501
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "vlan_id", value)

    @property
    @pulumi.getter(name="bfdConfiguration")
    def bfd_configuration(self) -> Optional[pulumi.Input['BfdConfigurationArgs']]:
        """
        BFD Configuration properties.
        """
        return pulumi.get(self, "bfd_configuration")

    @bfd_configuration.setter
    def bfd_configuration(self, value: Optional[pulumi.Input['BfdConfigurationArgs']]):
        pulumi.set(self, "bfd_configuration", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[int]]:
        """
        MTU to use for option A peering.
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter(name="primaryIpv4Prefix")
    def primary_ipv4_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        IPv4 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv4_prefix")

    @primary_ipv4_prefix.setter
    def primary_ipv4_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_ipv4_prefix", value)

    @property
    @pulumi.getter(name="primaryIpv6Prefix")
    def primary_ipv6_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        IPv6 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv6_prefix")

    @primary_ipv6_prefix.setter
    def primary_ipv6_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_ipv6_prefix", value)

    @property
    @pulumi.getter(name="secondaryIpv4Prefix")
    def secondary_ipv4_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Secondary IPv4 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv4_prefix")

    @secondary_ipv4_prefix.setter
    def secondary_ipv4_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secondary_ipv4_prefix", value)

    @property
    @pulumi.getter(name="secondaryIpv6Prefix")
    def secondary_ipv6_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Secondary IPv6 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv6_prefix")

    @secondary_ipv6_prefix.setter
    def secondary_ipv6_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secondary_ipv6_prefix", value)


if not MYPY:
    class VpnConfigurationPropertiesArgsDict(TypedDict):
        """
        Network and credential configuration currently applied on terminal server.
        """
        peering_option: pulumi.Input[Union[str, 'PeeringOption']]
        """
        Peering option list.
        """
        network_to_network_interconnect_id: NotRequired[pulumi.Input[str]]
        """
        ARM Resource ID of the Network To Network Interconnect.
        """
        option_a_properties: NotRequired[pulumi.Input['VpnConfigurationPropertiesOptionAPropertiesArgsDict']]
        """
        option A properties
        """
        option_b_properties: NotRequired[pulumi.Input['FabricOptionBPropertiesArgsDict']]
        """
        option B properties
        """
elif False:
    VpnConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 peering_option: pulumi.Input[Union[str, 'PeeringOption']],
                 network_to_network_interconnect_id: Optional[pulumi.Input[str]] = None,
                 option_a_properties: Optional[pulumi.Input['VpnConfigurationPropertiesOptionAPropertiesArgs']] = None,
                 option_b_properties: Optional[pulumi.Input['FabricOptionBPropertiesArgs']] = None):
        """
        Network and credential configuration currently applied on terminal server.
        :param pulumi.Input[Union[str, 'PeeringOption']] peering_option: Peering option list.
        :param pulumi.Input[str] network_to_network_interconnect_id: ARM Resource ID of the Network To Network Interconnect.
        :param pulumi.Input['VpnConfigurationPropertiesOptionAPropertiesArgs'] option_a_properties: option A properties
        :param pulumi.Input['FabricOptionBPropertiesArgs'] option_b_properties: option B properties
        """
        pulumi.set(__self__, "peering_option", peering_option)
        if network_to_network_interconnect_id is not None:
            pulumi.set(__self__, "network_to_network_interconnect_id", network_to_network_interconnect_id)
        if option_a_properties is not None:
            pulumi.set(__self__, "option_a_properties", option_a_properties)
        if option_b_properties is not None:
            pulumi.set(__self__, "option_b_properties", option_b_properties)

    @property
    @pulumi.getter(name="peeringOption")
    def peering_option(self) -> pulumi.Input[Union[str, 'PeeringOption']]:
        """
        Peering option list.
        """
        return pulumi.get(self, "peering_option")

    @peering_option.setter
    def peering_option(self, value: pulumi.Input[Union[str, 'PeeringOption']]):
        pulumi.set(self, "peering_option", value)

    @property
    @pulumi.getter(name="networkToNetworkInterconnectId")
    def network_to_network_interconnect_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM Resource ID of the Network To Network Interconnect.
        """
        return pulumi.get(self, "network_to_network_interconnect_id")

    @network_to_network_interconnect_id.setter
    def network_to_network_interconnect_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_to_network_interconnect_id", value)

    @property
    @pulumi.getter(name="optionAProperties")
    def option_a_properties(self) -> Optional[pulumi.Input['VpnConfigurationPropertiesOptionAPropertiesArgs']]:
        """
        option A properties
        """
        return pulumi.get(self, "option_a_properties")

    @option_a_properties.setter
    def option_a_properties(self, value: Optional[pulumi.Input['VpnConfigurationPropertiesOptionAPropertiesArgs']]):
        pulumi.set(self, "option_a_properties", value)

    @property
    @pulumi.getter(name="optionBProperties")
    def option_b_properties(self) -> Optional[pulumi.Input['FabricOptionBPropertiesArgs']]:
        """
        option B properties
        """
        return pulumi.get(self, "option_b_properties")

    @option_b_properties.setter
    def option_b_properties(self, value: Optional[pulumi.Input['FabricOptionBPropertiesArgs']]):
        pulumi.set(self, "option_b_properties", value)


