# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AccessControlListActionResponse',
    'AccessControlListMatchConditionResponse',
    'AccessControlListMatchConfigurationResponse',
    'AccessControlListPortConditionResponse',
    'ActionIpCommunityPropertiesResponse',
    'ActionIpExtendedCommunityPropertiesResponse',
    'AggregateRouteConfigurationResponse',
    'AggregateRouteResponse',
    'BfdConfigurationResponse',
    'CommonDynamicMatchConfigurationResponse',
    'ConnectedSubnetResponse',
    'ConnectedSubnetRoutePolicyResponse',
    'ControllerServicesResponse',
    'ErrorAdditionalInfoResponse',
    'ErrorDetailResponse',
    'ExportRoutePolicyInformationResponse',
    'ExportRoutePolicyResponse',
    'ExpressRouteConnectionInformationResponse',
    'ExternalNetworkPropertiesResponseOptionAProperties',
    'FabricOptionBPropertiesResponse',
    'ImportRoutePolicyInformationResponse',
    'ImportRoutePolicyResponse',
    'InternalNetworkPropertiesResponseBgpConfiguration',
    'InternalNetworkPropertiesResponseStaticRouteConfiguration',
    'IpCommunityIdListResponse',
    'IpCommunityRuleResponse',
    'IpExtendedCommunityIdListResponse',
    'IpExtendedCommunityRuleResponse',
    'IpGroupPropertiesResponse',
    'IpMatchConditionResponse',
    'IpPrefixRuleResponse',
    'IsolationDomainPropertiesResponse',
    'L3ExportRoutePolicyResponse',
    'L3OptionBPropertiesResponse',
    'Layer2ConfigurationResponse',
    'ManagedResourceGroupConfigurationResponse',
    'ManagementNetworkConfigurationPropertiesResponse',
    'NeighborAddressResponse',
    'NeighborGroupDestinationResponse',
    'NetworkTapPropertiesResponseDestinations',
    'NetworkTapRuleActionResponse',
    'NetworkTapRuleMatchConditionResponse',
    'NetworkTapRuleMatchConfigurationResponse',
    'NetworkToNetworkInterconnectPropertiesResponseOptionBLayer3Configuration',
    'NpbStaticRouteConfigurationResponse',
    'PortConditionResponse',
    'PortGroupPropertiesResponse',
    'RoutePolicyStatementPropertiesResponse',
    'RouteTargetInformationResponse',
    'RulePropertiesResponse',
    'StatementActionPropertiesResponse',
    'StatementConditionPropertiesResponse',
    'StaticRoutePropertiesResponse',
    'SystemDataResponse',
    'TerminalServerConfigurationResponse',
    'VlanGroupPropertiesResponse',
    'VlanMatchConditionResponse',
    'VpnConfigurationPropertiesResponse',
    'VpnConfigurationPropertiesResponseOptionAProperties',
]

@pulumi.output_type
class AccessControlListActionResponse(dict):
    """
    Action that need to performed.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "counterName":
            suggest = "counter_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessControlListActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessControlListActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessControlListActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 counter_name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Action that need to performed.
        :param str counter_name: Name of the counter block to get match count information.
        :param str type: Type of actions that can be performed.
        """
        AccessControlListActionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            counter_name=counter_name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             counter_name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if counter_name is None and 'counterName' in kwargs:
            counter_name = kwargs['counterName']

        if counter_name is not None:
            _setter("counter_name", counter_name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="counterName")
    def counter_name(self) -> Optional[str]:
        """
        Name of the counter block to get match count information.
        """
        return pulumi.get(self, "counter_name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of actions that can be performed.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AccessControlListMatchConditionResponse(dict):
    """
    Defines the match condition that is supported to filter the traffic.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dscpMarkings":
            suggest = "dscp_markings"
        elif key == "etherTypes":
            suggest = "ether_types"
        elif key == "ipCondition":
            suggest = "ip_condition"
        elif key == "ipLengths":
            suggest = "ip_lengths"
        elif key == "portCondition":
            suggest = "port_condition"
        elif key == "protocolTypes":
            suggest = "protocol_types"
        elif key == "ttlValues":
            suggest = "ttl_values"
        elif key == "vlanMatchCondition":
            suggest = "vlan_match_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessControlListMatchConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessControlListMatchConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessControlListMatchConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dscp_markings: Optional[Sequence[str]] = None,
                 ether_types: Optional[Sequence[str]] = None,
                 fragments: Optional[Sequence[str]] = None,
                 ip_condition: Optional['outputs.IpMatchConditionResponse'] = None,
                 ip_lengths: Optional[Sequence[str]] = None,
                 port_condition: Optional['outputs.AccessControlListPortConditionResponse'] = None,
                 protocol_types: Optional[Sequence[str]] = None,
                 ttl_values: Optional[Sequence[str]] = None,
                 vlan_match_condition: Optional['outputs.VlanMatchConditionResponse'] = None):
        """
        Defines the match condition that is supported to filter the traffic.
        :param Sequence[str] dscp_markings: List of DSCP Markings that need to be matched.
        :param Sequence[str] ether_types: List of ether type values that need to be matched.
        :param Sequence[str] fragments: List of IP fragment packets that need to be matched.
        :param 'IpMatchConditionResponse' ip_condition: IP condition that needs to be matched.
        :param Sequence[str] ip_lengths: List of IP Lengths that need to be matched.
        :param 'AccessControlListPortConditionResponse' port_condition: Defines the port condition that needs to be matched.
        :param Sequence[str] protocol_types: List of the protocols that need to be matched.
        :param Sequence[str] ttl_values: List of TTL [Time To Live] values that need to be matched.
        :param 'VlanMatchConditionResponse' vlan_match_condition: Vlan match condition that needs to be matched.
        """
        AccessControlListMatchConditionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dscp_markings=dscp_markings,
            ether_types=ether_types,
            fragments=fragments,
            ip_condition=ip_condition,
            ip_lengths=ip_lengths,
            port_condition=port_condition,
            protocol_types=protocol_types,
            ttl_values=ttl_values,
            vlan_match_condition=vlan_match_condition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dscp_markings: Optional[Sequence[str]] = None,
             ether_types: Optional[Sequence[str]] = None,
             fragments: Optional[Sequence[str]] = None,
             ip_condition: Optional['outputs.IpMatchConditionResponse'] = None,
             ip_lengths: Optional[Sequence[str]] = None,
             port_condition: Optional['outputs.AccessControlListPortConditionResponse'] = None,
             protocol_types: Optional[Sequence[str]] = None,
             ttl_values: Optional[Sequence[str]] = None,
             vlan_match_condition: Optional['outputs.VlanMatchConditionResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if dscp_markings is None and 'dscpMarkings' in kwargs:
            dscp_markings = kwargs['dscpMarkings']
        if ether_types is None and 'etherTypes' in kwargs:
            ether_types = kwargs['etherTypes']
        if ip_condition is None and 'ipCondition' in kwargs:
            ip_condition = kwargs['ipCondition']
        if ip_lengths is None and 'ipLengths' in kwargs:
            ip_lengths = kwargs['ipLengths']
        if port_condition is None and 'portCondition' in kwargs:
            port_condition = kwargs['portCondition']
        if protocol_types is None and 'protocolTypes' in kwargs:
            protocol_types = kwargs['protocolTypes']
        if ttl_values is None and 'ttlValues' in kwargs:
            ttl_values = kwargs['ttlValues']
        if vlan_match_condition is None and 'vlanMatchCondition' in kwargs:
            vlan_match_condition = kwargs['vlanMatchCondition']

        if dscp_markings is not None:
            _setter("dscp_markings", dscp_markings)
        if ether_types is not None:
            _setter("ether_types", ether_types)
        if fragments is not None:
            _setter("fragments", fragments)
        if ip_condition is not None:
            _setter("ip_condition", ip_condition)
        if ip_lengths is not None:
            _setter("ip_lengths", ip_lengths)
        if port_condition is not None:
            _setter("port_condition", port_condition)
        if protocol_types is not None:
            _setter("protocol_types", protocol_types)
        if ttl_values is not None:
            _setter("ttl_values", ttl_values)
        if vlan_match_condition is not None:
            _setter("vlan_match_condition", vlan_match_condition)

    @property
    @pulumi.getter(name="dscpMarkings")
    def dscp_markings(self) -> Optional[Sequence[str]]:
        """
        List of DSCP Markings that need to be matched.
        """
        return pulumi.get(self, "dscp_markings")

    @property
    @pulumi.getter(name="etherTypes")
    def ether_types(self) -> Optional[Sequence[str]]:
        """
        List of ether type values that need to be matched.
        """
        return pulumi.get(self, "ether_types")

    @property
    @pulumi.getter
    def fragments(self) -> Optional[Sequence[str]]:
        """
        List of IP fragment packets that need to be matched.
        """
        return pulumi.get(self, "fragments")

    @property
    @pulumi.getter(name="ipCondition")
    def ip_condition(self) -> Optional['outputs.IpMatchConditionResponse']:
        """
        IP condition that needs to be matched.
        """
        return pulumi.get(self, "ip_condition")

    @property
    @pulumi.getter(name="ipLengths")
    def ip_lengths(self) -> Optional[Sequence[str]]:
        """
        List of IP Lengths that need to be matched.
        """
        return pulumi.get(self, "ip_lengths")

    @property
    @pulumi.getter(name="portCondition")
    def port_condition(self) -> Optional['outputs.AccessControlListPortConditionResponse']:
        """
        Defines the port condition that needs to be matched.
        """
        return pulumi.get(self, "port_condition")

    @property
    @pulumi.getter(name="protocolTypes")
    def protocol_types(self) -> Optional[Sequence[str]]:
        """
        List of the protocols that need to be matched.
        """
        return pulumi.get(self, "protocol_types")

    @property
    @pulumi.getter(name="ttlValues")
    def ttl_values(self) -> Optional[Sequence[str]]:
        """
        List of TTL [Time To Live] values that need to be matched.
        """
        return pulumi.get(self, "ttl_values")

    @property
    @pulumi.getter(name="vlanMatchCondition")
    def vlan_match_condition(self) -> Optional['outputs.VlanMatchConditionResponse']:
        """
        Vlan match condition that needs to be matched.
        """
        return pulumi.get(self, "vlan_match_condition")


@pulumi.output_type
class AccessControlListMatchConfigurationResponse(dict):
    """
    Defines the match configuration that are supported to filter the traffic.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddressType":
            suggest = "ip_address_type"
        elif key == "matchConditions":
            suggest = "match_conditions"
        elif key == "matchConfigurationName":
            suggest = "match_configuration_name"
        elif key == "sequenceNumber":
            suggest = "sequence_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessControlListMatchConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessControlListMatchConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessControlListMatchConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Optional[Sequence['outputs.AccessControlListActionResponse']] = None,
                 ip_address_type: Optional[str] = None,
                 match_conditions: Optional[Sequence['outputs.AccessControlListMatchConditionResponse']] = None,
                 match_configuration_name: Optional[str] = None,
                 sequence_number: Optional[float] = None):
        """
        Defines the match configuration that are supported to filter the traffic.
        :param Sequence['AccessControlListActionResponse'] actions: List of actions that need to be performed for the matched conditions.
        :param str ip_address_type: Type of IP Address. IPv4 or IPv6
        :param Sequence['AccessControlListMatchConditionResponse'] match_conditions: List of the match conditions.
        :param str match_configuration_name: The name of the match configuration.
        :param float sequence_number: Sequence Number of the match configuration.
        """
        AccessControlListMatchConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            ip_address_type=ip_address_type,
            match_conditions=match_conditions,
            match_configuration_name=match_configuration_name,
            sequence_number=sequence_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[Sequence['outputs.AccessControlListActionResponse']] = None,
             ip_address_type: Optional[str] = None,
             match_conditions: Optional[Sequence['outputs.AccessControlListMatchConditionResponse']] = None,
             match_configuration_name: Optional[str] = None,
             sequence_number: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_address_type is None and 'ipAddressType' in kwargs:
            ip_address_type = kwargs['ipAddressType']
        if match_conditions is None and 'matchConditions' in kwargs:
            match_conditions = kwargs['matchConditions']
        if match_configuration_name is None and 'matchConfigurationName' in kwargs:
            match_configuration_name = kwargs['matchConfigurationName']
        if sequence_number is None and 'sequenceNumber' in kwargs:
            sequence_number = kwargs['sequenceNumber']

        if actions is not None:
            _setter("actions", actions)
        if ip_address_type is not None:
            _setter("ip_address_type", ip_address_type)
        if match_conditions is not None:
            _setter("match_conditions", match_conditions)
        if match_configuration_name is not None:
            _setter("match_configuration_name", match_configuration_name)
        if sequence_number is not None:
            _setter("sequence_number", sequence_number)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AccessControlListActionResponse']]:
        """
        List of actions that need to be performed for the matched conditions.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[str]:
        """
        Type of IP Address. IPv4 or IPv6
        """
        return pulumi.get(self, "ip_address_type")

    @property
    @pulumi.getter(name="matchConditions")
    def match_conditions(self) -> Optional[Sequence['outputs.AccessControlListMatchConditionResponse']]:
        """
        List of the match conditions.
        """
        return pulumi.get(self, "match_conditions")

    @property
    @pulumi.getter(name="matchConfigurationName")
    def match_configuration_name(self) -> Optional[str]:
        """
        The name of the match configuration.
        """
        return pulumi.get(self, "match_configuration_name")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> Optional[float]:
        """
        Sequence Number of the match configuration.
        """
        return pulumi.get(self, "sequence_number")


@pulumi.output_type
class AccessControlListPortConditionResponse(dict):
    """
    Defines the port condition that needs to be matched.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layer4Protocol":
            suggest = "layer4_protocol"
        elif key == "portGroupNames":
            suggest = "port_group_names"
        elif key == "portType":
            suggest = "port_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessControlListPortConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessControlListPortConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessControlListPortConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layer4_protocol: str,
                 flags: Optional[Sequence[str]] = None,
                 port_group_names: Optional[Sequence[str]] = None,
                 port_type: Optional[str] = None,
                 ports: Optional[Sequence[str]] = None):
        """
        Defines the port condition that needs to be matched.
        :param str layer4_protocol: Layer4 protocol type that needs to be matched.
        :param Sequence[str] flags: List of protocol flags that need to be matched. Example: established | initial | <List-of-TCP-flags>. List of eligible TCP Flags are ack, fin, not-ack, not-fin, not-psh, not-rst, not-syn, not-urg, psh, rst, syn, urg
        :param Sequence[str] port_group_names: List of the port Group Names that need to be matched.
        :param str port_type: Port type that needs to be matched.
        :param Sequence[str] ports: List of the Ports that need to be matched.
        """
        AccessControlListPortConditionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            layer4_protocol=layer4_protocol,
            flags=flags,
            port_group_names=port_group_names,
            port_type=port_type,
            ports=ports,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             layer4_protocol: Optional[str] = None,
             flags: Optional[Sequence[str]] = None,
             port_group_names: Optional[Sequence[str]] = None,
             port_type: Optional[str] = None,
             ports: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if layer4_protocol is None and 'layer4Protocol' in kwargs:
            layer4_protocol = kwargs['layer4Protocol']
        if layer4_protocol is None:
            raise TypeError("Missing 'layer4_protocol' argument")
        if port_group_names is None and 'portGroupNames' in kwargs:
            port_group_names = kwargs['portGroupNames']
        if port_type is None and 'portType' in kwargs:
            port_type = kwargs['portType']

        _setter("layer4_protocol", layer4_protocol)
        if flags is not None:
            _setter("flags", flags)
        if port_group_names is not None:
            _setter("port_group_names", port_group_names)
        if port_type is not None:
            _setter("port_type", port_type)
        if ports is not None:
            _setter("ports", ports)

    @property
    @pulumi.getter(name="layer4Protocol")
    def layer4_protocol(self) -> str:
        """
        Layer4 protocol type that needs to be matched.
        """
        return pulumi.get(self, "layer4_protocol")

    @property
    @pulumi.getter
    def flags(self) -> Optional[Sequence[str]]:
        """
        List of protocol flags that need to be matched. Example: established | initial | <List-of-TCP-flags>. List of eligible TCP Flags are ack, fin, not-ack, not-fin, not-psh, not-rst, not-syn, not-urg, psh, rst, syn, urg
        """
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter(name="portGroupNames")
    def port_group_names(self) -> Optional[Sequence[str]]:
        """
        List of the port Group Names that need to be matched.
        """
        return pulumi.get(self, "port_group_names")

    @property
    @pulumi.getter(name="portType")
    def port_type(self) -> Optional[str]:
        """
        Port type that needs to be matched.
        """
        return pulumi.get(self, "port_type")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[str]]:
        """
        List of the Ports that need to be matched.
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class ActionIpCommunityPropertiesResponse(dict):
    """
    IP Community Properties.
    """
    def __init__(__self__, *,
                 add: Optional['outputs.IpCommunityIdListResponse'] = None,
                 delete: Optional['outputs.IpCommunityIdListResponse'] = None,
                 set: Optional['outputs.IpCommunityIdListResponse'] = None):
        """
        IP Community Properties.
        :param 'IpCommunityIdListResponse' add: List of IP Community IDs.
        :param 'IpCommunityIdListResponse' delete: List of IP Community IDs.
        :param 'IpCommunityIdListResponse' set: List of IP Community IDs.
        """
        ActionIpCommunityPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            add=add,
            delete=delete,
            set=set,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             add: Optional['outputs.IpCommunityIdListResponse'] = None,
             delete: Optional['outputs.IpCommunityIdListResponse'] = None,
             set: Optional['outputs.IpCommunityIdListResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if add is not None:
            _setter("add", add)
        if delete is not None:
            _setter("delete", delete)
        if set is not None:
            _setter("set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional['outputs.IpCommunityIdListResponse']:
        """
        List of IP Community IDs.
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def delete(self) -> Optional['outputs.IpCommunityIdListResponse']:
        """
        List of IP Community IDs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def set(self) -> Optional['outputs.IpCommunityIdListResponse']:
        """
        List of IP Community IDs.
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class ActionIpExtendedCommunityPropertiesResponse(dict):
    """
    IP Extended Community Properties.
    """
    def __init__(__self__, *,
                 add: Optional['outputs.IpExtendedCommunityIdListResponse'] = None,
                 delete: Optional['outputs.IpExtendedCommunityIdListResponse'] = None,
                 set: Optional['outputs.IpExtendedCommunityIdListResponse'] = None):
        """
        IP Extended Community Properties.
        :param 'IpExtendedCommunityIdListResponse' add: List of IP Extended Community IDs.
        :param 'IpExtendedCommunityIdListResponse' delete: List of IP Extended Community IDs.
        :param 'IpExtendedCommunityIdListResponse' set: List of IP Extended Community IDs.
        """
        ActionIpExtendedCommunityPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            add=add,
            delete=delete,
            set=set,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             add: Optional['outputs.IpExtendedCommunityIdListResponse'] = None,
             delete: Optional['outputs.IpExtendedCommunityIdListResponse'] = None,
             set: Optional['outputs.IpExtendedCommunityIdListResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if add is not None:
            _setter("add", add)
        if delete is not None:
            _setter("delete", delete)
        if set is not None:
            _setter("set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional['outputs.IpExtendedCommunityIdListResponse']:
        """
        List of IP Extended Community IDs.
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def delete(self) -> Optional['outputs.IpExtendedCommunityIdListResponse']:
        """
        List of IP Extended Community IDs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def set(self) -> Optional['outputs.IpExtendedCommunityIdListResponse']:
        """
        List of IP Extended Community IDs.
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class AggregateRouteConfigurationResponse(dict):
    """
    List of IPv4 and IPv6 aggregate routes.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4Routes":
            suggest = "ipv4_routes"
        elif key == "ipv6Routes":
            suggest = "ipv6_routes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AggregateRouteConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AggregateRouteConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AggregateRouteConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4_routes: Optional[Sequence['outputs.AggregateRouteResponse']] = None,
                 ipv6_routes: Optional[Sequence['outputs.AggregateRouteResponse']] = None):
        """
        List of IPv4 and IPv6 aggregate routes.
        :param Sequence['AggregateRouteResponse'] ipv4_routes: List of IPv4 Route prefixes.
        :param Sequence['AggregateRouteResponse'] ipv6_routes: List of Ipv6Routes prefixes.
        """
        AggregateRouteConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv4_routes=ipv4_routes,
            ipv6_routes=ipv6_routes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv4_routes: Optional[Sequence['outputs.AggregateRouteResponse']] = None,
             ipv6_routes: Optional[Sequence['outputs.AggregateRouteResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ipv4_routes is None and 'ipv4Routes' in kwargs:
            ipv4_routes = kwargs['ipv4Routes']
        if ipv6_routes is None and 'ipv6Routes' in kwargs:
            ipv6_routes = kwargs['ipv6Routes']

        if ipv4_routes is not None:
            _setter("ipv4_routes", ipv4_routes)
        if ipv6_routes is not None:
            _setter("ipv6_routes", ipv6_routes)

    @property
    @pulumi.getter(name="ipv4Routes")
    def ipv4_routes(self) -> Optional[Sequence['outputs.AggregateRouteResponse']]:
        """
        List of IPv4 Route prefixes.
        """
        return pulumi.get(self, "ipv4_routes")

    @property
    @pulumi.getter(name="ipv6Routes")
    def ipv6_routes(self) -> Optional[Sequence['outputs.AggregateRouteResponse']]:
        """
        List of Ipv6Routes prefixes.
        """
        return pulumi.get(self, "ipv6_routes")


@pulumi.output_type
class AggregateRouteResponse(dict):
    """
    aggregateIpv4Route model.
    """
    def __init__(__self__, *,
                 prefix: str):
        """
        aggregateIpv4Route model.
        :param str prefix: IPv4 Prefix of the aggregate Ipv4Route.
        """
        AggregateRouteResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            prefix=prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if prefix is None:
            raise TypeError("Missing 'prefix' argument")

        _setter("prefix", prefix)

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        IPv4 Prefix of the aggregate Ipv4Route.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class BfdConfigurationResponse(dict):
    """
    BFD configuration properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "administrativeState":
            suggest = "administrative_state"
        elif key == "intervalInMilliSeconds":
            suggest = "interval_in_milli_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BfdConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BfdConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BfdConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 administrative_state: Optional[str] = None,
                 interval_in_milli_seconds: Optional[int] = None,
                 multiplier: Optional[int] = None):
        """
        BFD configuration properties
        :param str administrative_state: Administrative state of the BfdConfiguration. Example: Enabled | Disabled.
        :param int interval_in_milli_seconds: Interval in milliseconds. Example: 300.
        :param int multiplier: Multiplier for the Bfd Configuration. Example: 5.
        """
        BfdConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            administrative_state=administrative_state,
            interval_in_milli_seconds=interval_in_milli_seconds,
            multiplier=multiplier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             administrative_state: Optional[str] = None,
             interval_in_milli_seconds: Optional[int] = None,
             multiplier: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if administrative_state is None and 'administrativeState' in kwargs:
            administrative_state = kwargs['administrativeState']
        if interval_in_milli_seconds is None and 'intervalInMilliSeconds' in kwargs:
            interval_in_milli_seconds = kwargs['intervalInMilliSeconds']

        if administrative_state is None:
            administrative_state = 'Disabled'
        _setter("administrative_state", administrative_state)
        if interval_in_milli_seconds is None:
            interval_in_milli_seconds = 300
        if interval_in_milli_seconds is not None:
            _setter("interval_in_milli_seconds", interval_in_milli_seconds)
        if multiplier is None:
            multiplier = 5
        if multiplier is not None:
            _setter("multiplier", multiplier)

    @property
    @pulumi.getter(name="administrativeState")
    def administrative_state(self) -> str:
        """
        Administrative state of the BfdConfiguration. Example: Enabled | Disabled.
        """
        return pulumi.get(self, "administrative_state")

    @property
    @pulumi.getter(name="intervalInMilliSeconds")
    def interval_in_milli_seconds(self) -> Optional[int]:
        """
        Interval in milliseconds. Example: 300.
        """
        return pulumi.get(self, "interval_in_milli_seconds")

    @property
    @pulumi.getter
    def multiplier(self) -> Optional[int]:
        """
        Multiplier for the Bfd Configuration. Example: 5.
        """
        return pulumi.get(self, "multiplier")


@pulumi.output_type
class CommonDynamicMatchConfigurationResponse(dict):
    """
    Dynamic match configuration object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipGroups":
            suggest = "ip_groups"
        elif key == "portGroups":
            suggest = "port_groups"
        elif key == "vlanGroups":
            suggest = "vlan_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CommonDynamicMatchConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CommonDynamicMatchConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CommonDynamicMatchConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_groups: Optional[Sequence['outputs.IpGroupPropertiesResponse']] = None,
                 port_groups: Optional[Sequence['outputs.PortGroupPropertiesResponse']] = None,
                 vlan_groups: Optional[Sequence['outputs.VlanGroupPropertiesResponse']] = None):
        """
        Dynamic match configuration object.
        :param Sequence['IpGroupPropertiesResponse'] ip_groups: List of IP Groups.
        :param Sequence['PortGroupPropertiesResponse'] port_groups: List of the port groups.
        :param Sequence['VlanGroupPropertiesResponse'] vlan_groups: List of vlan groups.
        """
        CommonDynamicMatchConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_groups=ip_groups,
            port_groups=port_groups,
            vlan_groups=vlan_groups,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_groups: Optional[Sequence['outputs.IpGroupPropertiesResponse']] = None,
             port_groups: Optional[Sequence['outputs.PortGroupPropertiesResponse']] = None,
             vlan_groups: Optional[Sequence['outputs.VlanGroupPropertiesResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_groups is None and 'ipGroups' in kwargs:
            ip_groups = kwargs['ipGroups']
        if port_groups is None and 'portGroups' in kwargs:
            port_groups = kwargs['portGroups']
        if vlan_groups is None and 'vlanGroups' in kwargs:
            vlan_groups = kwargs['vlanGroups']

        if ip_groups is not None:
            _setter("ip_groups", ip_groups)
        if port_groups is not None:
            _setter("port_groups", port_groups)
        if vlan_groups is not None:
            _setter("vlan_groups", vlan_groups)

    @property
    @pulumi.getter(name="ipGroups")
    def ip_groups(self) -> Optional[Sequence['outputs.IpGroupPropertiesResponse']]:
        """
        List of IP Groups.
        """
        return pulumi.get(self, "ip_groups")

    @property
    @pulumi.getter(name="portGroups")
    def port_groups(self) -> Optional[Sequence['outputs.PortGroupPropertiesResponse']]:
        """
        List of the port groups.
        """
        return pulumi.get(self, "port_groups")

    @property
    @pulumi.getter(name="vlanGroups")
    def vlan_groups(self) -> Optional[Sequence['outputs.VlanGroupPropertiesResponse']]:
        """
        List of vlan groups.
        """
        return pulumi.get(self, "vlan_groups")


@pulumi.output_type
class ConnectedSubnetResponse(dict):
    """
    Connected Subnet properties.
    """
    def __init__(__self__, *,
                 prefix: str,
                 annotation: Optional[str] = None):
        """
        Connected Subnet properties.
        :param str prefix: Prefix of the Connected Subnet.
        :param str annotation: Switch configuration description.
        """
        ConnectedSubnetResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            prefix=prefix,
            annotation=annotation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             prefix: Optional[str] = None,
             annotation: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if prefix is None:
            raise TypeError("Missing 'prefix' argument")

        _setter("prefix", prefix)
        if annotation is not None:
            _setter("annotation", annotation)

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        Prefix of the Connected Subnet.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def annotation(self) -> Optional[str]:
        """
        Switch configuration description.
        """
        return pulumi.get(self, "annotation")


@pulumi.output_type
class ConnectedSubnetRoutePolicyResponse(dict):
    """
    Connected Subnet Route Policy properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportRoutePolicy":
            suggest = "export_route_policy"
        elif key == "exportRoutePolicyId":
            suggest = "export_route_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectedSubnetRoutePolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectedSubnetRoutePolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectedSubnetRoutePolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_route_policy: Optional['outputs.L3ExportRoutePolicyResponse'] = None,
                 export_route_policy_id: Optional[str] = None):
        """
        Connected Subnet Route Policy properties.
        :param 'L3ExportRoutePolicyResponse' export_route_policy: Array of ARM Resource ID of the RoutePolicies.
        :param str export_route_policy_id: ARM Resource ID of the Route Policy. This is used for the backward compatibility.
        """
        ConnectedSubnetRoutePolicyResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            export_route_policy=export_route_policy,
            export_route_policy_id=export_route_policy_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             export_route_policy: Optional['outputs.L3ExportRoutePolicyResponse'] = None,
             export_route_policy_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if export_route_policy is None and 'exportRoutePolicy' in kwargs:
            export_route_policy = kwargs['exportRoutePolicy']
        if export_route_policy_id is None and 'exportRoutePolicyId' in kwargs:
            export_route_policy_id = kwargs['exportRoutePolicyId']

        if export_route_policy is not None:
            _setter("export_route_policy", export_route_policy)
        if export_route_policy_id is not None:
            _setter("export_route_policy_id", export_route_policy_id)

    @property
    @pulumi.getter(name="exportRoutePolicy")
    def export_route_policy(self) -> Optional['outputs.L3ExportRoutePolicyResponse']:
        """
        Array of ARM Resource ID of the RoutePolicies.
        """
        return pulumi.get(self, "export_route_policy")

    @property
    @pulumi.getter(name="exportRoutePolicyId")
    def export_route_policy_id(self) -> Optional[str]:
        """
        ARM Resource ID of the Route Policy. This is used for the backward compatibility.
        """
        return pulumi.get(self, "export_route_policy_id")


@pulumi.output_type
class ControllerServicesResponse(dict):
    """
    Network Fabric Controller services.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4AddressSpaces":
            suggest = "ipv4_address_spaces"
        elif key == "ipv6AddressSpaces":
            suggest = "ipv6_address_spaces"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ControllerServicesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ControllerServicesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ControllerServicesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4_address_spaces: Optional[Sequence[str]] = None,
                 ipv6_address_spaces: Optional[Sequence[str]] = None):
        """
        Network Fabric Controller services.
        :param Sequence[str] ipv4_address_spaces: The IPv4 Address space is optional, if the value is not defined at the time of NFC creation, then the default value 10.0.0.0/19 is considered. The IPV4 address subnet is an optional attribute.
        :param Sequence[str] ipv6_address_spaces: The IPv6 is not supported right now.
        """
        ControllerServicesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv4_address_spaces=ipv4_address_spaces,
            ipv6_address_spaces=ipv6_address_spaces,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv4_address_spaces: Optional[Sequence[str]] = None,
             ipv6_address_spaces: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ipv4_address_spaces is None and 'ipv4AddressSpaces' in kwargs:
            ipv4_address_spaces = kwargs['ipv4AddressSpaces']
        if ipv6_address_spaces is None and 'ipv6AddressSpaces' in kwargs:
            ipv6_address_spaces = kwargs['ipv6AddressSpaces']

        if ipv4_address_spaces is not None:
            _setter("ipv4_address_spaces", ipv4_address_spaces)
        if ipv6_address_spaces is not None:
            _setter("ipv6_address_spaces", ipv6_address_spaces)

    @property
    @pulumi.getter(name="ipv4AddressSpaces")
    def ipv4_address_spaces(self) -> Optional[Sequence[str]]:
        """
        The IPv4 Address space is optional, if the value is not defined at the time of NFC creation, then the default value 10.0.0.0/19 is considered. The IPV4 address subnet is an optional attribute.
        """
        return pulumi.get(self, "ipv4_address_spaces")

    @property
    @pulumi.getter(name="ipv6AddressSpaces")
    def ipv6_address_spaces(self) -> Optional[Sequence[str]]:
        """
        The IPv6 is not supported right now.
        """
        return pulumi.get(self, "ipv6_address_spaces")


@pulumi.output_type
class ErrorAdditionalInfoResponse(dict):
    """
    The resource management error additional info.
    """
    def __init__(__self__, *,
                 info: Any,
                 type: str):
        """
        The resource management error additional info.
        :param Any info: The additional info.
        :param str type: The additional info type.
        """
        ErrorAdditionalInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            info=info,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             info: Optional[Any] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if info is None:
            raise TypeError("Missing 'info' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("info", info)
        _setter("type", type)

    @property
    @pulumi.getter
    def info(self) -> Any:
        """
        The additional info.
        """
        return pulumi.get(self, "info")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The additional info type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ErrorDetailResponse(dict):
    """
    The error detail.
    """
    def __init__(__self__, *,
                 additional_info: Sequence['outputs.ErrorAdditionalInfoResponse'],
                 code: str,
                 details: Sequence['outputs.ErrorDetailResponse'],
                 message: str,
                 target: str):
        """
        The error detail.
        :param Sequence['ErrorAdditionalInfoResponse'] additional_info: The error additional info.
        :param str code: The error code.
        :param Sequence['ErrorDetailResponse'] details: The error details.
        :param str message: The error message.
        :param str target: The error target.
        """
        ErrorDetailResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_info=additional_info,
            code=code,
            details=details,
            message=message,
            target=target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_info: Optional[Sequence['outputs.ErrorAdditionalInfoResponse']] = None,
             code: Optional[str] = None,
             details: Optional[Sequence['outputs.ErrorDetailResponse']] = None,
             message: Optional[str] = None,
             target: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if additional_info is None and 'additionalInfo' in kwargs:
            additional_info = kwargs['additionalInfo']
        if additional_info is None:
            raise TypeError("Missing 'additional_info' argument")
        if code is None:
            raise TypeError("Missing 'code' argument")
        if details is None:
            raise TypeError("Missing 'details' argument")
        if message is None:
            raise TypeError("Missing 'message' argument")
        if target is None:
            raise TypeError("Missing 'target' argument")

        _setter("additional_info", additional_info)
        _setter("code", code)
        _setter("details", details)
        _setter("message", message)
        _setter("target", target)

    @property
    @pulumi.getter(name="additionalInfo")
    def additional_info(self) -> Sequence['outputs.ErrorAdditionalInfoResponse']:
        """
        The error additional info.
        """
        return pulumi.get(self, "additional_info")

    @property
    @pulumi.getter
    def code(self) -> str:
        """
        The error code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.ErrorDetailResponse']:
        """
        The error details.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        The error message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The error target.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class ExportRoutePolicyInformationResponse(dict):
    """
    Export Route Policy Configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportIpv4RoutePolicyId":
            suggest = "export_ipv4_route_policy_id"
        elif key == "exportIpv6RoutePolicyId":
            suggest = "export_ipv6_route_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExportRoutePolicyInformationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExportRoutePolicyInformationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExportRoutePolicyInformationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_ipv4_route_policy_id: Optional[str] = None,
                 export_ipv6_route_policy_id: Optional[str] = None):
        """
        Export Route Policy Configuration.
        :param str export_ipv4_route_policy_id: Export IPv4 Route Policy Id.
        :param str export_ipv6_route_policy_id: Export IPv6 Route Policy Id.
        """
        ExportRoutePolicyInformationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            export_ipv4_route_policy_id=export_ipv4_route_policy_id,
            export_ipv6_route_policy_id=export_ipv6_route_policy_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             export_ipv4_route_policy_id: Optional[str] = None,
             export_ipv6_route_policy_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if export_ipv4_route_policy_id is None and 'exportIpv4RoutePolicyId' in kwargs:
            export_ipv4_route_policy_id = kwargs['exportIpv4RoutePolicyId']
        if export_ipv6_route_policy_id is None and 'exportIpv6RoutePolicyId' in kwargs:
            export_ipv6_route_policy_id = kwargs['exportIpv6RoutePolicyId']

        if export_ipv4_route_policy_id is not None:
            _setter("export_ipv4_route_policy_id", export_ipv4_route_policy_id)
        if export_ipv6_route_policy_id is not None:
            _setter("export_ipv6_route_policy_id", export_ipv6_route_policy_id)

    @property
    @pulumi.getter(name="exportIpv4RoutePolicyId")
    def export_ipv4_route_policy_id(self) -> Optional[str]:
        """
        Export IPv4 Route Policy Id.
        """
        return pulumi.get(self, "export_ipv4_route_policy_id")

    @property
    @pulumi.getter(name="exportIpv6RoutePolicyId")
    def export_ipv6_route_policy_id(self) -> Optional[str]:
        """
        Export IPv6 Route Policy Id.
        """
        return pulumi.get(self, "export_ipv6_route_policy_id")


@pulumi.output_type
class ExportRoutePolicyResponse(dict):
    """
    Export Route Policy either IPv4 or IPv6.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportIpv4RoutePolicyId":
            suggest = "export_ipv4_route_policy_id"
        elif key == "exportIpv6RoutePolicyId":
            suggest = "export_ipv6_route_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExportRoutePolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExportRoutePolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExportRoutePolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_ipv4_route_policy_id: Optional[str] = None,
                 export_ipv6_route_policy_id: Optional[str] = None):
        """
        Export Route Policy either IPv4 or IPv6.
        :param str export_ipv4_route_policy_id: ARM resource ID of RoutePolicy.
        :param str export_ipv6_route_policy_id: ARM resource ID of RoutePolicy.
        """
        ExportRoutePolicyResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            export_ipv4_route_policy_id=export_ipv4_route_policy_id,
            export_ipv6_route_policy_id=export_ipv6_route_policy_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             export_ipv4_route_policy_id: Optional[str] = None,
             export_ipv6_route_policy_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if export_ipv4_route_policy_id is None and 'exportIpv4RoutePolicyId' in kwargs:
            export_ipv4_route_policy_id = kwargs['exportIpv4RoutePolicyId']
        if export_ipv6_route_policy_id is None and 'exportIpv6RoutePolicyId' in kwargs:
            export_ipv6_route_policy_id = kwargs['exportIpv6RoutePolicyId']

        if export_ipv4_route_policy_id is not None:
            _setter("export_ipv4_route_policy_id", export_ipv4_route_policy_id)
        if export_ipv6_route_policy_id is not None:
            _setter("export_ipv6_route_policy_id", export_ipv6_route_policy_id)

    @property
    @pulumi.getter(name="exportIpv4RoutePolicyId")
    def export_ipv4_route_policy_id(self) -> Optional[str]:
        """
        ARM resource ID of RoutePolicy.
        """
        return pulumi.get(self, "export_ipv4_route_policy_id")

    @property
    @pulumi.getter(name="exportIpv6RoutePolicyId")
    def export_ipv6_route_policy_id(self) -> Optional[str]:
        """
        ARM resource ID of RoutePolicy.
        """
        return pulumi.get(self, "export_ipv6_route_policy_id")


@pulumi.output_type
class ExpressRouteConnectionInformationResponse(dict):
    """
    The ExpressRoute circuit ID and the Auth Key are required for you to successfully deploy NFC service.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expressRouteAuthorizationKey":
            suggest = "express_route_authorization_key"
        elif key == "expressRouteCircuitId":
            suggest = "express_route_circuit_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRouteConnectionInformationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRouteConnectionInformationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRouteConnectionInformationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 express_route_authorization_key: str,
                 express_route_circuit_id: str):
        """
        The ExpressRoute circuit ID and the Auth Key are required for you to successfully deploy NFC service.
        :param str express_route_authorization_key: Authorization key for the circuit, must be of type Microsoft.Network/expressRouteCircuits/authorizations. The Auth Key is a mandatory attribute.
        :param str express_route_circuit_id: The express route circuit Azure resource ID, must be of type Microsoft.Network/expressRouteCircuits/circuitName. The ExpressRoute Circuit is a mandatory attribute.
        """
        ExpressRouteConnectionInformationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            express_route_authorization_key=express_route_authorization_key,
            express_route_circuit_id=express_route_circuit_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             express_route_authorization_key: Optional[str] = None,
             express_route_circuit_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if express_route_authorization_key is None and 'expressRouteAuthorizationKey' in kwargs:
            express_route_authorization_key = kwargs['expressRouteAuthorizationKey']
        if express_route_authorization_key is None:
            raise TypeError("Missing 'express_route_authorization_key' argument")
        if express_route_circuit_id is None and 'expressRouteCircuitId' in kwargs:
            express_route_circuit_id = kwargs['expressRouteCircuitId']
        if express_route_circuit_id is None:
            raise TypeError("Missing 'express_route_circuit_id' argument")

        _setter("express_route_authorization_key", express_route_authorization_key)
        _setter("express_route_circuit_id", express_route_circuit_id)

    @property
    @pulumi.getter(name="expressRouteAuthorizationKey")
    def express_route_authorization_key(self) -> str:
        """
        Authorization key for the circuit, must be of type Microsoft.Network/expressRouteCircuits/authorizations. The Auth Key is a mandatory attribute.
        """
        return pulumi.get(self, "express_route_authorization_key")

    @property
    @pulumi.getter(name="expressRouteCircuitId")
    def express_route_circuit_id(self) -> str:
        """
        The express route circuit Azure resource ID, must be of type Microsoft.Network/expressRouteCircuits/circuitName. The ExpressRoute Circuit is a mandatory attribute.
        """
        return pulumi.get(self, "express_route_circuit_id")


@pulumi.output_type
class ExternalNetworkPropertiesResponseOptionAProperties(dict):
    """
    option A properties object
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fabricASN":
            suggest = "fabric_asn"
        elif key == "peerASN":
            suggest = "peer_asn"
        elif key == "vlanId":
            suggest = "vlan_id"
        elif key == "bfdConfiguration":
            suggest = "bfd_configuration"
        elif key == "egressAclId":
            suggest = "egress_acl_id"
        elif key == "ingressAclId":
            suggest = "ingress_acl_id"
        elif key == "primaryIpv4Prefix":
            suggest = "primary_ipv4_prefix"
        elif key == "primaryIpv6Prefix":
            suggest = "primary_ipv6_prefix"
        elif key == "secondaryIpv4Prefix":
            suggest = "secondary_ipv4_prefix"
        elif key == "secondaryIpv6Prefix":
            suggest = "secondary_ipv6_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalNetworkPropertiesResponseOptionAProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalNetworkPropertiesResponseOptionAProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalNetworkPropertiesResponseOptionAProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fabric_asn: float,
                 peer_asn: float,
                 vlan_id: int,
                 bfd_configuration: Optional['outputs.BfdConfigurationResponse'] = None,
                 egress_acl_id: Optional[str] = None,
                 ingress_acl_id: Optional[str] = None,
                 mtu: Optional[int] = None,
                 primary_ipv4_prefix: Optional[str] = None,
                 primary_ipv6_prefix: Optional[str] = None,
                 secondary_ipv4_prefix: Optional[str] = None,
                 secondary_ipv6_prefix: Optional[str] = None):
        """
        option A properties object
        :param float fabric_asn: Fabric ASN number. Example 65001 
        :param float peer_asn: Peer ASN number.Example : 28
        :param int vlan_id: Vlan identifier. Example : 501
        :param 'BfdConfigurationResponse' bfd_configuration: BFD configuration properties
        :param str egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
        :param str ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
        :param int mtu: MTU to use for option A peering.
        :param str primary_ipv4_prefix: IPv4 Address Prefix.
        :param str primary_ipv6_prefix: IPv6 Address Prefix.
        :param str secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
        :param str secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
        """
        ExternalNetworkPropertiesResponseOptionAProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fabric_asn=fabric_asn,
            peer_asn=peer_asn,
            vlan_id=vlan_id,
            bfd_configuration=bfd_configuration,
            egress_acl_id=egress_acl_id,
            ingress_acl_id=ingress_acl_id,
            mtu=mtu,
            primary_ipv4_prefix=primary_ipv4_prefix,
            primary_ipv6_prefix=primary_ipv6_prefix,
            secondary_ipv4_prefix=secondary_ipv4_prefix,
            secondary_ipv6_prefix=secondary_ipv6_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fabric_asn: Optional[float] = None,
             peer_asn: Optional[float] = None,
             vlan_id: Optional[int] = None,
             bfd_configuration: Optional['outputs.BfdConfigurationResponse'] = None,
             egress_acl_id: Optional[str] = None,
             ingress_acl_id: Optional[str] = None,
             mtu: Optional[int] = None,
             primary_ipv4_prefix: Optional[str] = None,
             primary_ipv6_prefix: Optional[str] = None,
             secondary_ipv4_prefix: Optional[str] = None,
             secondary_ipv6_prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fabric_asn is None and 'fabricASN' in kwargs:
            fabric_asn = kwargs['fabricASN']
        if fabric_asn is None:
            raise TypeError("Missing 'fabric_asn' argument")
        if peer_asn is None and 'peerASN' in kwargs:
            peer_asn = kwargs['peerASN']
        if peer_asn is None:
            raise TypeError("Missing 'peer_asn' argument")
        if vlan_id is None and 'vlanId' in kwargs:
            vlan_id = kwargs['vlanId']
        if vlan_id is None:
            raise TypeError("Missing 'vlan_id' argument")
        if bfd_configuration is None and 'bfdConfiguration' in kwargs:
            bfd_configuration = kwargs['bfdConfiguration']
        if egress_acl_id is None and 'egressAclId' in kwargs:
            egress_acl_id = kwargs['egressAclId']
        if ingress_acl_id is None and 'ingressAclId' in kwargs:
            ingress_acl_id = kwargs['ingressAclId']
        if primary_ipv4_prefix is None and 'primaryIpv4Prefix' in kwargs:
            primary_ipv4_prefix = kwargs['primaryIpv4Prefix']
        if primary_ipv6_prefix is None and 'primaryIpv6Prefix' in kwargs:
            primary_ipv6_prefix = kwargs['primaryIpv6Prefix']
        if secondary_ipv4_prefix is None and 'secondaryIpv4Prefix' in kwargs:
            secondary_ipv4_prefix = kwargs['secondaryIpv4Prefix']
        if secondary_ipv6_prefix is None and 'secondaryIpv6Prefix' in kwargs:
            secondary_ipv6_prefix = kwargs['secondaryIpv6Prefix']

        _setter("fabric_asn", fabric_asn)
        _setter("peer_asn", peer_asn)
        _setter("vlan_id", vlan_id)
        if bfd_configuration is not None:
            _setter("bfd_configuration", bfd_configuration)
        if egress_acl_id is not None:
            _setter("egress_acl_id", egress_acl_id)
        if ingress_acl_id is not None:
            _setter("ingress_acl_id", ingress_acl_id)
        if mtu is None:
            mtu = 1500
        if mtu is not None:
            _setter("mtu", mtu)
        if primary_ipv4_prefix is not None:
            _setter("primary_ipv4_prefix", primary_ipv4_prefix)
        if primary_ipv6_prefix is not None:
            _setter("primary_ipv6_prefix", primary_ipv6_prefix)
        if secondary_ipv4_prefix is not None:
            _setter("secondary_ipv4_prefix", secondary_ipv4_prefix)
        if secondary_ipv6_prefix is not None:
            _setter("secondary_ipv6_prefix", secondary_ipv6_prefix)

    @property
    @pulumi.getter(name="fabricASN")
    def fabric_asn(self) -> float:
        """
        Fabric ASN number. Example 65001 
        """
        return pulumi.get(self, "fabric_asn")

    @property
    @pulumi.getter(name="peerASN")
    def peer_asn(self) -> float:
        """
        Peer ASN number.Example : 28
        """
        return pulumi.get(self, "peer_asn")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> int:
        """
        Vlan identifier. Example : 501
        """
        return pulumi.get(self, "vlan_id")

    @property
    @pulumi.getter(name="bfdConfiguration")
    def bfd_configuration(self) -> Optional['outputs.BfdConfigurationResponse']:
        """
        BFD configuration properties
        """
        return pulumi.get(self, "bfd_configuration")

    @property
    @pulumi.getter(name="egressAclId")
    def egress_acl_id(self) -> Optional[str]:
        """
        Egress Acl. ARM resource ID of Access Control Lists.
        """
        return pulumi.get(self, "egress_acl_id")

    @property
    @pulumi.getter(name="ingressAclId")
    def ingress_acl_id(self) -> Optional[str]:
        """
        Ingress Acl. ARM resource ID of Access Control Lists.
        """
        return pulumi.get(self, "ingress_acl_id")

    @property
    @pulumi.getter
    def mtu(self) -> Optional[int]:
        """
        MTU to use for option A peering.
        """
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter(name="primaryIpv4Prefix")
    def primary_ipv4_prefix(self) -> Optional[str]:
        """
        IPv4 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv4_prefix")

    @property
    @pulumi.getter(name="primaryIpv6Prefix")
    def primary_ipv6_prefix(self) -> Optional[str]:
        """
        IPv6 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv6_prefix")

    @property
    @pulumi.getter(name="secondaryIpv4Prefix")
    def secondary_ipv4_prefix(self) -> Optional[str]:
        """
        Secondary IPv4 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv4_prefix")

    @property
    @pulumi.getter(name="secondaryIpv6Prefix")
    def secondary_ipv6_prefix(self) -> Optional[str]:
        """
        Secondary IPv6 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv6_prefix")


@pulumi.output_type
class FabricOptionBPropertiesResponse(dict):
    """
    Option B configuration to be used for Management VPN.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportRouteTargets":
            suggest = "export_route_targets"
        elif key == "importRouteTargets":
            suggest = "import_route_targets"
        elif key == "routeTargets":
            suggest = "route_targets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FabricOptionBPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FabricOptionBPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FabricOptionBPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_route_targets: Optional[Sequence[str]] = None,
                 import_route_targets: Optional[Sequence[str]] = None,
                 route_targets: Optional['outputs.RouteTargetInformationResponse'] = None):
        """
        Option B configuration to be used for Management VPN.
        :param Sequence[str] export_route_targets: Route Targets to be applied for outgoing routes from CE. This is for backward compatibility.
        :param Sequence[str] import_route_targets: Route Targets to be applied for incoming routes into CE. This is for backward compatibility.
        :param 'RouteTargetInformationResponse' route_targets: Route Targets to be applied.
        """
        FabricOptionBPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            export_route_targets=export_route_targets,
            import_route_targets=import_route_targets,
            route_targets=route_targets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             export_route_targets: Optional[Sequence[str]] = None,
             import_route_targets: Optional[Sequence[str]] = None,
             route_targets: Optional['outputs.RouteTargetInformationResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if export_route_targets is None and 'exportRouteTargets' in kwargs:
            export_route_targets = kwargs['exportRouteTargets']
        if import_route_targets is None and 'importRouteTargets' in kwargs:
            import_route_targets = kwargs['importRouteTargets']
        if route_targets is None and 'routeTargets' in kwargs:
            route_targets = kwargs['routeTargets']

        if export_route_targets is not None:
            _setter("export_route_targets", export_route_targets)
        if import_route_targets is not None:
            _setter("import_route_targets", import_route_targets)
        if route_targets is not None:
            _setter("route_targets", route_targets)

    @property
    @pulumi.getter(name="exportRouteTargets")
    def export_route_targets(self) -> Optional[Sequence[str]]:
        """
        Route Targets to be applied for outgoing routes from CE. This is for backward compatibility.
        """
        return pulumi.get(self, "export_route_targets")

    @property
    @pulumi.getter(name="importRouteTargets")
    def import_route_targets(self) -> Optional[Sequence[str]]:
        """
        Route Targets to be applied for incoming routes into CE. This is for backward compatibility.
        """
        return pulumi.get(self, "import_route_targets")

    @property
    @pulumi.getter(name="routeTargets")
    def route_targets(self) -> Optional['outputs.RouteTargetInformationResponse']:
        """
        Route Targets to be applied.
        """
        return pulumi.get(self, "route_targets")


@pulumi.output_type
class ImportRoutePolicyInformationResponse(dict):
    """
    Import Route Policy Configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "importIpv4RoutePolicyId":
            suggest = "import_ipv4_route_policy_id"
        elif key == "importIpv6RoutePolicyId":
            suggest = "import_ipv6_route_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImportRoutePolicyInformationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImportRoutePolicyInformationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImportRoutePolicyInformationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 import_ipv4_route_policy_id: Optional[str] = None,
                 import_ipv6_route_policy_id: Optional[str] = None):
        """
        Import Route Policy Configuration.
        :param str import_ipv4_route_policy_id: Import IPv4 Route Policy Id.
        :param str import_ipv6_route_policy_id: Import IPv6 Route Policy Id.
        """
        ImportRoutePolicyInformationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            import_ipv4_route_policy_id=import_ipv4_route_policy_id,
            import_ipv6_route_policy_id=import_ipv6_route_policy_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             import_ipv4_route_policy_id: Optional[str] = None,
             import_ipv6_route_policy_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if import_ipv4_route_policy_id is None and 'importIpv4RoutePolicyId' in kwargs:
            import_ipv4_route_policy_id = kwargs['importIpv4RoutePolicyId']
        if import_ipv6_route_policy_id is None and 'importIpv6RoutePolicyId' in kwargs:
            import_ipv6_route_policy_id = kwargs['importIpv6RoutePolicyId']

        if import_ipv4_route_policy_id is not None:
            _setter("import_ipv4_route_policy_id", import_ipv4_route_policy_id)
        if import_ipv6_route_policy_id is not None:
            _setter("import_ipv6_route_policy_id", import_ipv6_route_policy_id)

    @property
    @pulumi.getter(name="importIpv4RoutePolicyId")
    def import_ipv4_route_policy_id(self) -> Optional[str]:
        """
        Import IPv4 Route Policy Id.
        """
        return pulumi.get(self, "import_ipv4_route_policy_id")

    @property
    @pulumi.getter(name="importIpv6RoutePolicyId")
    def import_ipv6_route_policy_id(self) -> Optional[str]:
        """
        Import IPv6 Route Policy Id.
        """
        return pulumi.get(self, "import_ipv6_route_policy_id")


@pulumi.output_type
class ImportRoutePolicyResponse(dict):
    """
    Import Route Policy either IPv4 or IPv6.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "importIpv4RoutePolicyId":
            suggest = "import_ipv4_route_policy_id"
        elif key == "importIpv6RoutePolicyId":
            suggest = "import_ipv6_route_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImportRoutePolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImportRoutePolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImportRoutePolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 import_ipv4_route_policy_id: Optional[str] = None,
                 import_ipv6_route_policy_id: Optional[str] = None):
        """
        Import Route Policy either IPv4 or IPv6.
        :param str import_ipv4_route_policy_id: ARM resource ID of RoutePolicy.
        :param str import_ipv6_route_policy_id: ARM resource ID of RoutePolicy.
        """
        ImportRoutePolicyResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            import_ipv4_route_policy_id=import_ipv4_route_policy_id,
            import_ipv6_route_policy_id=import_ipv6_route_policy_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             import_ipv4_route_policy_id: Optional[str] = None,
             import_ipv6_route_policy_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if import_ipv4_route_policy_id is None and 'importIpv4RoutePolicyId' in kwargs:
            import_ipv4_route_policy_id = kwargs['importIpv4RoutePolicyId']
        if import_ipv6_route_policy_id is None and 'importIpv6RoutePolicyId' in kwargs:
            import_ipv6_route_policy_id = kwargs['importIpv6RoutePolicyId']

        if import_ipv4_route_policy_id is not None:
            _setter("import_ipv4_route_policy_id", import_ipv4_route_policy_id)
        if import_ipv6_route_policy_id is not None:
            _setter("import_ipv6_route_policy_id", import_ipv6_route_policy_id)

    @property
    @pulumi.getter(name="importIpv4RoutePolicyId")
    def import_ipv4_route_policy_id(self) -> Optional[str]:
        """
        ARM resource ID of RoutePolicy.
        """
        return pulumi.get(self, "import_ipv4_route_policy_id")

    @property
    @pulumi.getter(name="importIpv6RoutePolicyId")
    def import_ipv6_route_policy_id(self) -> Optional[str]:
        """
        ARM resource ID of RoutePolicy.
        """
        return pulumi.get(self, "import_ipv6_route_policy_id")


@pulumi.output_type
class InternalNetworkPropertiesResponseBgpConfiguration(dict):
    """
    BGP configuration properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fabricASN":
            suggest = "fabric_asn"
        elif key == "peerASN":
            suggest = "peer_asn"
        elif key == "allowAS":
            suggest = "allow_as"
        elif key == "allowASOverride":
            suggest = "allow_as_override"
        elif key == "bfdConfiguration":
            suggest = "bfd_configuration"
        elif key == "defaultRouteOriginate":
            suggest = "default_route_originate"
        elif key == "ipv4ListenRangePrefixes":
            suggest = "ipv4_listen_range_prefixes"
        elif key == "ipv4NeighborAddress":
            suggest = "ipv4_neighbor_address"
        elif key == "ipv6ListenRangePrefixes":
            suggest = "ipv6_listen_range_prefixes"
        elif key == "ipv6NeighborAddress":
            suggest = "ipv6_neighbor_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternalNetworkPropertiesResponseBgpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternalNetworkPropertiesResponseBgpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternalNetworkPropertiesResponseBgpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fabric_asn: float,
                 peer_asn: float,
                 allow_as: Optional[int] = None,
                 allow_as_override: Optional[str] = None,
                 annotation: Optional[str] = None,
                 bfd_configuration: Optional['outputs.BfdConfigurationResponse'] = None,
                 default_route_originate: Optional[str] = None,
                 ipv4_listen_range_prefixes: Optional[Sequence[str]] = None,
                 ipv4_neighbor_address: Optional[Sequence['outputs.NeighborAddressResponse']] = None,
                 ipv6_listen_range_prefixes: Optional[Sequence[str]] = None,
                 ipv6_neighbor_address: Optional[Sequence['outputs.NeighborAddressResponse']] = None):
        """
        BGP configuration properties.
        :param float fabric_asn: ASN of Network Fabric. Example: 65048.
        :param float peer_asn: Peer ASN. Example: 65047.
        :param int allow_as: Allows for routes to be received and processed even if the router detects its own ASN in the AS-Path. 0 is disable, Possible values are 1-10, default is 2.
        :param str allow_as_override: Enable Or Disable state.
        :param str annotation: Switch configuration description.
        :param 'BfdConfigurationResponse' bfd_configuration: BFD configuration properties
        :param str default_route_originate: Originate a defaultRoute. Ex: "True" | "False".
        :param Sequence[str] ipv4_listen_range_prefixes: List of BGP IPv4 Listen Range prefixes.
        :param Sequence['NeighborAddressResponse'] ipv4_neighbor_address: List with stringified IPv4 Neighbor Addresses.
        :param Sequence[str] ipv6_listen_range_prefixes: List of BGP IPv6 Listen Ranges prefixes.
        :param Sequence['NeighborAddressResponse'] ipv6_neighbor_address: List with stringified IPv6 Neighbor Address.
        """
        InternalNetworkPropertiesResponseBgpConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fabric_asn=fabric_asn,
            peer_asn=peer_asn,
            allow_as=allow_as,
            allow_as_override=allow_as_override,
            annotation=annotation,
            bfd_configuration=bfd_configuration,
            default_route_originate=default_route_originate,
            ipv4_listen_range_prefixes=ipv4_listen_range_prefixes,
            ipv4_neighbor_address=ipv4_neighbor_address,
            ipv6_listen_range_prefixes=ipv6_listen_range_prefixes,
            ipv6_neighbor_address=ipv6_neighbor_address,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fabric_asn: Optional[float] = None,
             peer_asn: Optional[float] = None,
             allow_as: Optional[int] = None,
             allow_as_override: Optional[str] = None,
             annotation: Optional[str] = None,
             bfd_configuration: Optional['outputs.BfdConfigurationResponse'] = None,
             default_route_originate: Optional[str] = None,
             ipv4_listen_range_prefixes: Optional[Sequence[str]] = None,
             ipv4_neighbor_address: Optional[Sequence['outputs.NeighborAddressResponse']] = None,
             ipv6_listen_range_prefixes: Optional[Sequence[str]] = None,
             ipv6_neighbor_address: Optional[Sequence['outputs.NeighborAddressResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fabric_asn is None and 'fabricASN' in kwargs:
            fabric_asn = kwargs['fabricASN']
        if fabric_asn is None:
            raise TypeError("Missing 'fabric_asn' argument")
        if peer_asn is None and 'peerASN' in kwargs:
            peer_asn = kwargs['peerASN']
        if peer_asn is None:
            raise TypeError("Missing 'peer_asn' argument")
        if allow_as is None and 'allowAS' in kwargs:
            allow_as = kwargs['allowAS']
        if allow_as_override is None and 'allowASOverride' in kwargs:
            allow_as_override = kwargs['allowASOverride']
        if bfd_configuration is None and 'bfdConfiguration' in kwargs:
            bfd_configuration = kwargs['bfdConfiguration']
        if default_route_originate is None and 'defaultRouteOriginate' in kwargs:
            default_route_originate = kwargs['defaultRouteOriginate']
        if ipv4_listen_range_prefixes is None and 'ipv4ListenRangePrefixes' in kwargs:
            ipv4_listen_range_prefixes = kwargs['ipv4ListenRangePrefixes']
        if ipv4_neighbor_address is None and 'ipv4NeighborAddress' in kwargs:
            ipv4_neighbor_address = kwargs['ipv4NeighborAddress']
        if ipv6_listen_range_prefixes is None and 'ipv6ListenRangePrefixes' in kwargs:
            ipv6_listen_range_prefixes = kwargs['ipv6ListenRangePrefixes']
        if ipv6_neighbor_address is None and 'ipv6NeighborAddress' in kwargs:
            ipv6_neighbor_address = kwargs['ipv6NeighborAddress']

        _setter("fabric_asn", fabric_asn)
        _setter("peer_asn", peer_asn)
        if allow_as is None:
            allow_as = 2
        if allow_as is not None:
            _setter("allow_as", allow_as)
        if allow_as_override is not None:
            _setter("allow_as_override", allow_as_override)
        if annotation is not None:
            _setter("annotation", annotation)
        if bfd_configuration is not None:
            _setter("bfd_configuration", bfd_configuration)
        if default_route_originate is not None:
            _setter("default_route_originate", default_route_originate)
        if ipv4_listen_range_prefixes is not None:
            _setter("ipv4_listen_range_prefixes", ipv4_listen_range_prefixes)
        if ipv4_neighbor_address is not None:
            _setter("ipv4_neighbor_address", ipv4_neighbor_address)
        if ipv6_listen_range_prefixes is not None:
            _setter("ipv6_listen_range_prefixes", ipv6_listen_range_prefixes)
        if ipv6_neighbor_address is not None:
            _setter("ipv6_neighbor_address", ipv6_neighbor_address)

    @property
    @pulumi.getter(name="fabricASN")
    def fabric_asn(self) -> float:
        """
        ASN of Network Fabric. Example: 65048.
        """
        return pulumi.get(self, "fabric_asn")

    @property
    @pulumi.getter(name="peerASN")
    def peer_asn(self) -> float:
        """
        Peer ASN. Example: 65047.
        """
        return pulumi.get(self, "peer_asn")

    @property
    @pulumi.getter(name="allowAS")
    def allow_as(self) -> Optional[int]:
        """
        Allows for routes to be received and processed even if the router detects its own ASN in the AS-Path. 0 is disable, Possible values are 1-10, default is 2.
        """
        return pulumi.get(self, "allow_as")

    @property
    @pulumi.getter(name="allowASOverride")
    def allow_as_override(self) -> Optional[str]:
        """
        Enable Or Disable state.
        """
        return pulumi.get(self, "allow_as_override")

    @property
    @pulumi.getter
    def annotation(self) -> Optional[str]:
        """
        Switch configuration description.
        """
        return pulumi.get(self, "annotation")

    @property
    @pulumi.getter(name="bfdConfiguration")
    def bfd_configuration(self) -> Optional['outputs.BfdConfigurationResponse']:
        """
        BFD configuration properties
        """
        return pulumi.get(self, "bfd_configuration")

    @property
    @pulumi.getter(name="defaultRouteOriginate")
    def default_route_originate(self) -> Optional[str]:
        """
        Originate a defaultRoute. Ex: "True" | "False".
        """
        return pulumi.get(self, "default_route_originate")

    @property
    @pulumi.getter(name="ipv4ListenRangePrefixes")
    def ipv4_listen_range_prefixes(self) -> Optional[Sequence[str]]:
        """
        List of BGP IPv4 Listen Range prefixes.
        """
        return pulumi.get(self, "ipv4_listen_range_prefixes")

    @property
    @pulumi.getter(name="ipv4NeighborAddress")
    def ipv4_neighbor_address(self) -> Optional[Sequence['outputs.NeighborAddressResponse']]:
        """
        List with stringified IPv4 Neighbor Addresses.
        """
        return pulumi.get(self, "ipv4_neighbor_address")

    @property
    @pulumi.getter(name="ipv6ListenRangePrefixes")
    def ipv6_listen_range_prefixes(self) -> Optional[Sequence[str]]:
        """
        List of BGP IPv6 Listen Ranges prefixes.
        """
        return pulumi.get(self, "ipv6_listen_range_prefixes")

    @property
    @pulumi.getter(name="ipv6NeighborAddress")
    def ipv6_neighbor_address(self) -> Optional[Sequence['outputs.NeighborAddressResponse']]:
        """
        List with stringified IPv6 Neighbor Address.
        """
        return pulumi.get(self, "ipv6_neighbor_address")


@pulumi.output_type
class InternalNetworkPropertiesResponseStaticRouteConfiguration(dict):
    """
    Static Route Configuration properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bfdConfiguration":
            suggest = "bfd_configuration"
        elif key == "ipv4Routes":
            suggest = "ipv4_routes"
        elif key == "ipv6Routes":
            suggest = "ipv6_routes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternalNetworkPropertiesResponseStaticRouteConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternalNetworkPropertiesResponseStaticRouteConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternalNetworkPropertiesResponseStaticRouteConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bfd_configuration: Optional['outputs.BfdConfigurationResponse'] = None,
                 extension: Optional[str] = None,
                 ipv4_routes: Optional[Sequence['outputs.StaticRoutePropertiesResponse']] = None,
                 ipv6_routes: Optional[Sequence['outputs.StaticRoutePropertiesResponse']] = None):
        """
        Static Route Configuration properties.
        :param 'BfdConfigurationResponse' bfd_configuration: BFD configuration properties
        :param str extension: Extension. Example: NoExtension | NPB.
        :param Sequence['StaticRoutePropertiesResponse'] ipv4_routes: List of IPv4 Routes.
        :param Sequence['StaticRoutePropertiesResponse'] ipv6_routes: List of IPv6 Routes.
        """
        InternalNetworkPropertiesResponseStaticRouteConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bfd_configuration=bfd_configuration,
            extension=extension,
            ipv4_routes=ipv4_routes,
            ipv6_routes=ipv6_routes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bfd_configuration: Optional['outputs.BfdConfigurationResponse'] = None,
             extension: Optional[str] = None,
             ipv4_routes: Optional[Sequence['outputs.StaticRoutePropertiesResponse']] = None,
             ipv6_routes: Optional[Sequence['outputs.StaticRoutePropertiesResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bfd_configuration is None and 'bfdConfiguration' in kwargs:
            bfd_configuration = kwargs['bfdConfiguration']
        if ipv4_routes is None and 'ipv4Routes' in kwargs:
            ipv4_routes = kwargs['ipv4Routes']
        if ipv6_routes is None and 'ipv6Routes' in kwargs:
            ipv6_routes = kwargs['ipv6Routes']

        if bfd_configuration is not None:
            _setter("bfd_configuration", bfd_configuration)
        if extension is None:
            extension = 'NoExtension'
        if extension is not None:
            _setter("extension", extension)
        if ipv4_routes is not None:
            _setter("ipv4_routes", ipv4_routes)
        if ipv6_routes is not None:
            _setter("ipv6_routes", ipv6_routes)

    @property
    @pulumi.getter(name="bfdConfiguration")
    def bfd_configuration(self) -> Optional['outputs.BfdConfigurationResponse']:
        """
        BFD configuration properties
        """
        return pulumi.get(self, "bfd_configuration")

    @property
    @pulumi.getter
    def extension(self) -> Optional[str]:
        """
        Extension. Example: NoExtension | NPB.
        """
        return pulumi.get(self, "extension")

    @property
    @pulumi.getter(name="ipv4Routes")
    def ipv4_routes(self) -> Optional[Sequence['outputs.StaticRoutePropertiesResponse']]:
        """
        List of IPv4 Routes.
        """
        return pulumi.get(self, "ipv4_routes")

    @property
    @pulumi.getter(name="ipv6Routes")
    def ipv6_routes(self) -> Optional[Sequence['outputs.StaticRoutePropertiesResponse']]:
        """
        List of IPv6 Routes.
        """
        return pulumi.get(self, "ipv6_routes")


@pulumi.output_type
class IpCommunityIdListResponse(dict):
    """
    IP Community ID list properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipCommunityIds":
            suggest = "ip_community_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpCommunityIdListResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpCommunityIdListResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpCommunityIdListResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_community_ids: Optional[Sequence[str]] = None):
        """
        IP Community ID list properties.
        :param Sequence[str] ip_community_ids: List of IP Community resource IDs.
        """
        IpCommunityIdListResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_community_ids=ip_community_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_community_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_community_ids is None and 'ipCommunityIds' in kwargs:
            ip_community_ids = kwargs['ipCommunityIds']

        if ip_community_ids is not None:
            _setter("ip_community_ids", ip_community_ids)

    @property
    @pulumi.getter(name="ipCommunityIds")
    def ip_community_ids(self) -> Optional[Sequence[str]]:
        """
        List of IP Community resource IDs.
        """
        return pulumi.get(self, "ip_community_ids")


@pulumi.output_type
class IpCommunityRuleResponse(dict):
    """
    IP Community patchable properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "communityMembers":
            suggest = "community_members"
        elif key == "sequenceNumber":
            suggest = "sequence_number"
        elif key == "wellKnownCommunities":
            suggest = "well_known_communities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpCommunityRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpCommunityRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpCommunityRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 community_members: Sequence[str],
                 sequence_number: float,
                 well_known_communities: Optional[Sequence[str]] = None):
        """
        IP Community patchable properties.
        :param str action: Action to be taken on the configuration. Example: Permit | Deny.
        :param Sequence[str] community_members: List the community members of IP Community.
        :param float sequence_number: Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        :param Sequence[str] well_known_communities: Supported well known Community List.
        """
        IpCommunityRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            community_members=community_members,
            sequence_number=sequence_number,
            well_known_communities=well_known_communities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             community_members: Optional[Sequence[str]] = None,
             sequence_number: Optional[float] = None,
             well_known_communities: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if community_members is None and 'communityMembers' in kwargs:
            community_members = kwargs['communityMembers']
        if community_members is None:
            raise TypeError("Missing 'community_members' argument")
        if sequence_number is None and 'sequenceNumber' in kwargs:
            sequence_number = kwargs['sequenceNumber']
        if sequence_number is None:
            raise TypeError("Missing 'sequence_number' argument")
        if well_known_communities is None and 'wellKnownCommunities' in kwargs:
            well_known_communities = kwargs['wellKnownCommunities']

        _setter("action", action)
        _setter("community_members", community_members)
        _setter("sequence_number", sequence_number)
        if well_known_communities is not None:
            _setter("well_known_communities", well_known_communities)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action to be taken on the configuration. Example: Permit | Deny.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="communityMembers")
    def community_members(self) -> Sequence[str]:
        """
        List the community members of IP Community.
        """
        return pulumi.get(self, "community_members")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> float:
        """
        Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        """
        return pulumi.get(self, "sequence_number")

    @property
    @pulumi.getter(name="wellKnownCommunities")
    def well_known_communities(self) -> Optional[Sequence[str]]:
        """
        Supported well known Community List.
        """
        return pulumi.get(self, "well_known_communities")


@pulumi.output_type
class IpExtendedCommunityIdListResponse(dict):
    """
    IP Extended Community Id list properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipExtendedCommunityIds":
            suggest = "ip_extended_community_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpExtendedCommunityIdListResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpExtendedCommunityIdListResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpExtendedCommunityIdListResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_extended_community_ids: Optional[Sequence[str]] = None):
        """
        IP Extended Community Id list properties.
        :param Sequence[str] ip_extended_community_ids: List of IP Extended Community resource IDs.
        """
        IpExtendedCommunityIdListResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_extended_community_ids=ip_extended_community_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_extended_community_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_extended_community_ids is None and 'ipExtendedCommunityIds' in kwargs:
            ip_extended_community_ids = kwargs['ipExtendedCommunityIds']

        if ip_extended_community_ids is not None:
            _setter("ip_extended_community_ids", ip_extended_community_ids)

    @property
    @pulumi.getter(name="ipExtendedCommunityIds")
    def ip_extended_community_ids(self) -> Optional[Sequence[str]]:
        """
        List of IP Extended Community resource IDs.
        """
        return pulumi.get(self, "ip_extended_community_ids")


@pulumi.output_type
class IpExtendedCommunityRuleResponse(dict):
    """
    List of IP Extended Community Rules.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routeTargets":
            suggest = "route_targets"
        elif key == "sequenceNumber":
            suggest = "sequence_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpExtendedCommunityRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpExtendedCommunityRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpExtendedCommunityRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 route_targets: Sequence[str],
                 sequence_number: float):
        """
        List of IP Extended Community Rules.
        :param str action: Action to be taken on the configuration. Example: Permit | Deny.
        :param Sequence[str] route_targets: Route Target List.The expected formats are ASN(plain):NN >> example 4294967294:50, ASN.ASN:NN >> example 65533.65333:40, IP-address:NN >> example 10.10.10.10:65535. The possible values of ASN,NN are in range of 0-65535, ASN(plain) is in range of 0-4294967295.
        :param float sequence_number: Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        """
        IpExtendedCommunityRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            route_targets=route_targets,
            sequence_number=sequence_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             route_targets: Optional[Sequence[str]] = None,
             sequence_number: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if route_targets is None and 'routeTargets' in kwargs:
            route_targets = kwargs['routeTargets']
        if route_targets is None:
            raise TypeError("Missing 'route_targets' argument")
        if sequence_number is None and 'sequenceNumber' in kwargs:
            sequence_number = kwargs['sequenceNumber']
        if sequence_number is None:
            raise TypeError("Missing 'sequence_number' argument")

        _setter("action", action)
        _setter("route_targets", route_targets)
        _setter("sequence_number", sequence_number)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action to be taken on the configuration. Example: Permit | Deny.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="routeTargets")
    def route_targets(self) -> Sequence[str]:
        """
        Route Target List.The expected formats are ASN(plain):NN >> example 4294967294:50, ASN.ASN:NN >> example 65533.65333:40, IP-address:NN >> example 10.10.10.10:65535. The possible values of ASN,NN are in range of 0-65535, ASN(plain) is in range of 0-4294967295.
        """
        return pulumi.get(self, "route_targets")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> float:
        """
        Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        """
        return pulumi.get(self, "sequence_number")


@pulumi.output_type
class IpGroupPropertiesResponse(dict):
    """
    IP Group properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddressType":
            suggest = "ip_address_type"
        elif key == "ipPrefixes":
            suggest = "ip_prefixes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpGroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpGroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpGroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address_type: Optional[str] = None,
                 ip_prefixes: Optional[Sequence[str]] = None,
                 name: Optional[str] = None):
        """
        IP Group properties.
        :param str ip_address_type: IP Address type.
        :param Sequence[str] ip_prefixes: List of IP Prefixes.
        :param str name: IP Group name.
        """
        IpGroupPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_address_type=ip_address_type,
            ip_prefixes=ip_prefixes,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_address_type: Optional[str] = None,
             ip_prefixes: Optional[Sequence[str]] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_address_type is None and 'ipAddressType' in kwargs:
            ip_address_type = kwargs['ipAddressType']
        if ip_prefixes is None and 'ipPrefixes' in kwargs:
            ip_prefixes = kwargs['ipPrefixes']

        if ip_address_type is not None:
            _setter("ip_address_type", ip_address_type)
        if ip_prefixes is not None:
            _setter("ip_prefixes", ip_prefixes)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[str]:
        """
        IP Address type.
        """
        return pulumi.get(self, "ip_address_type")

    @property
    @pulumi.getter(name="ipPrefixes")
    def ip_prefixes(self) -> Optional[Sequence[str]]:
        """
        List of IP Prefixes.
        """
        return pulumi.get(self, "ip_prefixes")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        IP Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class IpMatchConditionResponse(dict):
    """
    Defines the condition that can be filtered using the selected IPs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipGroupNames":
            suggest = "ip_group_names"
        elif key == "ipPrefixValues":
            suggest = "ip_prefix_values"
        elif key == "prefixType":
            suggest = "prefix_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpMatchConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpMatchConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpMatchConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_group_names: Optional[Sequence[str]] = None,
                 ip_prefix_values: Optional[Sequence[str]] = None,
                 prefix_type: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Defines the condition that can be filtered using the selected IPs.
        :param Sequence[str] ip_group_names: The List of IP Group Names that need to be matched.
        :param Sequence[str] ip_prefix_values: The list of IP Prefixes that need to be matched.
        :param str prefix_type: IP Prefix Type that needs to be matched.
        :param str type: IP Address type that needs to be matched.
        """
        IpMatchConditionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_group_names=ip_group_names,
            ip_prefix_values=ip_prefix_values,
            prefix_type=prefix_type,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_group_names: Optional[Sequence[str]] = None,
             ip_prefix_values: Optional[Sequence[str]] = None,
             prefix_type: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_group_names is None and 'ipGroupNames' in kwargs:
            ip_group_names = kwargs['ipGroupNames']
        if ip_prefix_values is None and 'ipPrefixValues' in kwargs:
            ip_prefix_values = kwargs['ipPrefixValues']
        if prefix_type is None and 'prefixType' in kwargs:
            prefix_type = kwargs['prefixType']

        if ip_group_names is not None:
            _setter("ip_group_names", ip_group_names)
        if ip_prefix_values is not None:
            _setter("ip_prefix_values", ip_prefix_values)
        if prefix_type is not None:
            _setter("prefix_type", prefix_type)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="ipGroupNames")
    def ip_group_names(self) -> Optional[Sequence[str]]:
        """
        The List of IP Group Names that need to be matched.
        """
        return pulumi.get(self, "ip_group_names")

    @property
    @pulumi.getter(name="ipPrefixValues")
    def ip_prefix_values(self) -> Optional[Sequence[str]]:
        """
        The list of IP Prefixes that need to be matched.
        """
        return pulumi.get(self, "ip_prefix_values")

    @property
    @pulumi.getter(name="prefixType")
    def prefix_type(self) -> Optional[str]:
        """
        IP Prefix Type that needs to be matched.
        """
        return pulumi.get(self, "prefix_type")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        IP Address type that needs to be matched.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class IpPrefixRuleResponse(dict):
    """
    IP Prefix Rule properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkPrefix":
            suggest = "network_prefix"
        elif key == "sequenceNumber":
            suggest = "sequence_number"
        elif key == "subnetMaskLength":
            suggest = "subnet_mask_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpPrefixRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpPrefixRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpPrefixRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 network_prefix: str,
                 sequence_number: float,
                 condition: Optional[str] = None,
                 subnet_mask_length: Optional[str] = None):
        """
        IP Prefix Rule properties.
        :param str action: Action to be taken on the configuration. Example: Permit | Deny.
        :param str network_prefix: Network Prefix specifying IPv4/IPv6 packets to be permitted or denied. Example: 1.1.1.0/24 | 3FFE:FFFF:0:CD30::/126 
        :param float sequence_number: Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        :param str condition: Specify prefix-list bounds.
        :param str subnet_mask_length: SubnetMaskLength gives the minimum NetworkPrefix length to be matched. Possible values for IPv4 are 1 - 32 . Possible values of IPv6 are 1 - 128.
        """
        IpPrefixRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            network_prefix=network_prefix,
            sequence_number=sequence_number,
            condition=condition,
            subnet_mask_length=subnet_mask_length,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             network_prefix: Optional[str] = None,
             sequence_number: Optional[float] = None,
             condition: Optional[str] = None,
             subnet_mask_length: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if network_prefix is None and 'networkPrefix' in kwargs:
            network_prefix = kwargs['networkPrefix']
        if network_prefix is None:
            raise TypeError("Missing 'network_prefix' argument")
        if sequence_number is None and 'sequenceNumber' in kwargs:
            sequence_number = kwargs['sequenceNumber']
        if sequence_number is None:
            raise TypeError("Missing 'sequence_number' argument")
        if subnet_mask_length is None and 'subnetMaskLength' in kwargs:
            subnet_mask_length = kwargs['subnetMaskLength']

        _setter("action", action)
        _setter("network_prefix", network_prefix)
        _setter("sequence_number", sequence_number)
        if condition is not None:
            _setter("condition", condition)
        if subnet_mask_length is not None:
            _setter("subnet_mask_length", subnet_mask_length)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action to be taken on the configuration. Example: Permit | Deny.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="networkPrefix")
    def network_prefix(self) -> str:
        """
        Network Prefix specifying IPv4/IPv6 packets to be permitted or denied. Example: 1.1.1.0/24 | 3FFE:FFFF:0:CD30::/126 
        """
        return pulumi.get(self, "network_prefix")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> float:
        """
        Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        """
        return pulumi.get(self, "sequence_number")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        Specify prefix-list bounds.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="subnetMaskLength")
    def subnet_mask_length(self) -> Optional[str]:
        """
        SubnetMaskLength gives the minimum NetworkPrefix length to be matched. Possible values for IPv4 are 1 - 32 . Possible values of IPv6 are 1 - 128.
        """
        return pulumi.get(self, "subnet_mask_length")


@pulumi.output_type
class IsolationDomainPropertiesResponse(dict):
    """
    Isolation Domain Properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "neighborGroupIds":
            suggest = "neighbor_group_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IsolationDomainPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IsolationDomainPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IsolationDomainPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encapsulation: Optional[str] = None,
                 neighbor_group_ids: Optional[Sequence[str]] = None):
        """
        Isolation Domain Properties.
        :param str encapsulation: Type of encapsulation.
        :param Sequence[str] neighbor_group_ids: List of Neighbor Group IDs.
        """
        IsolationDomainPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            encapsulation=encapsulation,
            neighbor_group_ids=neighbor_group_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             encapsulation: Optional[str] = None,
             neighbor_group_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if neighbor_group_ids is None and 'neighborGroupIds' in kwargs:
            neighbor_group_ids = kwargs['neighborGroupIds']

        if encapsulation is not None:
            _setter("encapsulation", encapsulation)
        if neighbor_group_ids is not None:
            _setter("neighbor_group_ids", neighbor_group_ids)

    @property
    @pulumi.getter
    def encapsulation(self) -> Optional[str]:
        """
        Type of encapsulation.
        """
        return pulumi.get(self, "encapsulation")

    @property
    @pulumi.getter(name="neighborGroupIds")
    def neighbor_group_ids(self) -> Optional[Sequence[str]]:
        """
        List of Neighbor Group IDs.
        """
        return pulumi.get(self, "neighbor_group_ids")


@pulumi.output_type
class L3ExportRoutePolicyResponse(dict):
    """
    Array of ARM Resource ID of the RoutePolicies.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportIpv4RoutePolicyId":
            suggest = "export_ipv4_route_policy_id"
        elif key == "exportIpv6RoutePolicyId":
            suggest = "export_ipv6_route_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in L3ExportRoutePolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        L3ExportRoutePolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        L3ExportRoutePolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_ipv4_route_policy_id: Optional[str] = None,
                 export_ipv6_route_policy_id: Optional[str] = None):
        """
        Array of ARM Resource ID of the RoutePolicies.
        :param str export_ipv4_route_policy_id: ARM Resource ID of the RoutePolicy.
        :param str export_ipv6_route_policy_id: ARM Resource ID of the RoutePolicy.
        """
        L3ExportRoutePolicyResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            export_ipv4_route_policy_id=export_ipv4_route_policy_id,
            export_ipv6_route_policy_id=export_ipv6_route_policy_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             export_ipv4_route_policy_id: Optional[str] = None,
             export_ipv6_route_policy_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if export_ipv4_route_policy_id is None and 'exportIpv4RoutePolicyId' in kwargs:
            export_ipv4_route_policy_id = kwargs['exportIpv4RoutePolicyId']
        if export_ipv6_route_policy_id is None and 'exportIpv6RoutePolicyId' in kwargs:
            export_ipv6_route_policy_id = kwargs['exportIpv6RoutePolicyId']

        if export_ipv4_route_policy_id is not None:
            _setter("export_ipv4_route_policy_id", export_ipv4_route_policy_id)
        if export_ipv6_route_policy_id is not None:
            _setter("export_ipv6_route_policy_id", export_ipv6_route_policy_id)

    @property
    @pulumi.getter(name="exportIpv4RoutePolicyId")
    def export_ipv4_route_policy_id(self) -> Optional[str]:
        """
        ARM Resource ID of the RoutePolicy.
        """
        return pulumi.get(self, "export_ipv4_route_policy_id")

    @property
    @pulumi.getter(name="exportIpv6RoutePolicyId")
    def export_ipv6_route_policy_id(self) -> Optional[str]:
        """
        ARM Resource ID of the RoutePolicy.
        """
        return pulumi.get(self, "export_ipv6_route_policy_id")


@pulumi.output_type
class L3OptionBPropertiesResponse(dict):
    """
    Option B configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportRouteTargets":
            suggest = "export_route_targets"
        elif key == "importRouteTargets":
            suggest = "import_route_targets"
        elif key == "routeTargets":
            suggest = "route_targets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in L3OptionBPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        L3OptionBPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        L3OptionBPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_route_targets: Optional[Sequence[str]] = None,
                 import_route_targets: Optional[Sequence[str]] = None,
                 route_targets: Optional['outputs.RouteTargetInformationResponse'] = None):
        """
        Option B configuration.
        :param Sequence[str] export_route_targets: RouteTargets to be applied. This is used for the backward compatibility.
        :param Sequence[str] import_route_targets: RouteTargets to be applied. This is used for the backward compatibility.
        :param 'RouteTargetInformationResponse' route_targets: RouteTargets to be applied.
        """
        L3OptionBPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            export_route_targets=export_route_targets,
            import_route_targets=import_route_targets,
            route_targets=route_targets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             export_route_targets: Optional[Sequence[str]] = None,
             import_route_targets: Optional[Sequence[str]] = None,
             route_targets: Optional['outputs.RouteTargetInformationResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if export_route_targets is None and 'exportRouteTargets' in kwargs:
            export_route_targets = kwargs['exportRouteTargets']
        if import_route_targets is None and 'importRouteTargets' in kwargs:
            import_route_targets = kwargs['importRouteTargets']
        if route_targets is None and 'routeTargets' in kwargs:
            route_targets = kwargs['routeTargets']

        if export_route_targets is not None:
            _setter("export_route_targets", export_route_targets)
        if import_route_targets is not None:
            _setter("import_route_targets", import_route_targets)
        if route_targets is not None:
            _setter("route_targets", route_targets)

    @property
    @pulumi.getter(name="exportRouteTargets")
    def export_route_targets(self) -> Optional[Sequence[str]]:
        """
        RouteTargets to be applied. This is used for the backward compatibility.
        """
        return pulumi.get(self, "export_route_targets")

    @property
    @pulumi.getter(name="importRouteTargets")
    def import_route_targets(self) -> Optional[Sequence[str]]:
        """
        RouteTargets to be applied. This is used for the backward compatibility.
        """
        return pulumi.get(self, "import_route_targets")

    @property
    @pulumi.getter(name="routeTargets")
    def route_targets(self) -> Optional['outputs.RouteTargetInformationResponse']:
        """
        RouteTargets to be applied.
        """
        return pulumi.get(self, "route_targets")


@pulumi.output_type
class Layer2ConfigurationResponse(dict):
    """
    Common properties for Layer2 Configuration.
    """
    def __init__(__self__, *,
                 interfaces: Optional[Sequence[str]] = None,
                 mtu: Optional[int] = None):
        """
        Common properties for Layer2 Configuration.
        :param Sequence[str] interfaces: List of network device interfaces resource IDs.
        :param int mtu: MTU of the packets between PE & CE.
        """
        Layer2ConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            interfaces=interfaces,
            mtu=mtu,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             interfaces: Optional[Sequence[str]] = None,
             mtu: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if interfaces is not None:
            _setter("interfaces", interfaces)
        if mtu is None:
            mtu = 1500
        if mtu is not None:
            _setter("mtu", mtu)

    @property
    @pulumi.getter
    def interfaces(self) -> Optional[Sequence[str]]:
        """
        List of network device interfaces resource IDs.
        """
        return pulumi.get(self, "interfaces")

    @property
    @pulumi.getter
    def mtu(self) -> Optional[int]:
        """
        MTU of the packets between PE & CE.
        """
        return pulumi.get(self, "mtu")


@pulumi.output_type
class ManagedResourceGroupConfigurationResponse(dict):
    """
    Managed Resource Group configuration properties.
    """
    def __init__(__self__, *,
                 location: Optional[str] = None,
                 name: Optional[str] = None):
        """
        Managed Resource Group configuration properties.
        :param str location: Managed resource group location.
        :param str name: The NFC service will be hosted in a Managed resource group.
        """
        ManagedResourceGroupConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            location=location,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             location: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if location is not None:
            _setter("location", location)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Managed resource group location.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The NFC service will be hosted in a Managed resource group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ManagementNetworkConfigurationPropertiesResponse(dict):
    """
    Configuration to be used to setup the management network.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infrastructureVpnConfiguration":
            suggest = "infrastructure_vpn_configuration"
        elif key == "workloadVpnConfiguration":
            suggest = "workload_vpn_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementNetworkConfigurationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementNetworkConfigurationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementNetworkConfigurationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 infrastructure_vpn_configuration: 'outputs.VpnConfigurationPropertiesResponse',
                 workload_vpn_configuration: 'outputs.VpnConfigurationPropertiesResponse'):
        """
        Configuration to be used to setup the management network.
        :param 'VpnConfigurationPropertiesResponse' infrastructure_vpn_configuration: VPN Configuration properties.
        :param 'VpnConfigurationPropertiesResponse' workload_vpn_configuration: VPN Configuration properties.
        """
        ManagementNetworkConfigurationPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            infrastructure_vpn_configuration=infrastructure_vpn_configuration,
            workload_vpn_configuration=workload_vpn_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             infrastructure_vpn_configuration: Optional['outputs.VpnConfigurationPropertiesResponse'] = None,
             workload_vpn_configuration: Optional['outputs.VpnConfigurationPropertiesResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if infrastructure_vpn_configuration is None and 'infrastructureVpnConfiguration' in kwargs:
            infrastructure_vpn_configuration = kwargs['infrastructureVpnConfiguration']
        if infrastructure_vpn_configuration is None:
            raise TypeError("Missing 'infrastructure_vpn_configuration' argument")
        if workload_vpn_configuration is None and 'workloadVpnConfiguration' in kwargs:
            workload_vpn_configuration = kwargs['workloadVpnConfiguration']
        if workload_vpn_configuration is None:
            raise TypeError("Missing 'workload_vpn_configuration' argument")

        _setter("infrastructure_vpn_configuration", infrastructure_vpn_configuration)
        _setter("workload_vpn_configuration", workload_vpn_configuration)

    @property
    @pulumi.getter(name="infrastructureVpnConfiguration")
    def infrastructure_vpn_configuration(self) -> 'outputs.VpnConfigurationPropertiesResponse':
        """
        VPN Configuration properties.
        """
        return pulumi.get(self, "infrastructure_vpn_configuration")

    @property
    @pulumi.getter(name="workloadVpnConfiguration")
    def workload_vpn_configuration(self) -> 'outputs.VpnConfigurationPropertiesResponse':
        """
        VPN Configuration properties.
        """
        return pulumi.get(self, "workload_vpn_configuration")


@pulumi.output_type
class NeighborAddressResponse(dict):
    """
    Neighbor Address properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationState":
            suggest = "configuration_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NeighborAddressResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NeighborAddressResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NeighborAddressResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configuration_state: str,
                 address: Optional[str] = None):
        """
        Neighbor Address properties.
        :param str configuration_state: Configuration state of the resource.
        :param str address: IP Address.
        """
        NeighborAddressResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configuration_state=configuration_state,
            address=address,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configuration_state: Optional[str] = None,
             address: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if configuration_state is None and 'configurationState' in kwargs:
            configuration_state = kwargs['configurationState']
        if configuration_state is None:
            raise TypeError("Missing 'configuration_state' argument")

        _setter("configuration_state", configuration_state)
        if address is not None:
            _setter("address", address)

    @property
    @pulumi.getter(name="configurationState")
    def configuration_state(self) -> str:
        """
        Configuration state of the resource.
        """
        return pulumi.get(self, "configuration_state")

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        IP Address.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class NeighborGroupDestinationResponse(dict):
    """
    An array of destination IPv4 Addresses or IPv6 Addresses.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4Addresses":
            suggest = "ipv4_addresses"
        elif key == "ipv6Addresses":
            suggest = "ipv6_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NeighborGroupDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NeighborGroupDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NeighborGroupDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4_addresses: Optional[Sequence[str]] = None,
                 ipv6_addresses: Optional[Sequence[str]] = None):
        """
        An array of destination IPv4 Addresses or IPv6 Addresses.
        :param Sequence[str] ipv4_addresses: Array of IPv4 Addresses.
        :param Sequence[str] ipv6_addresses: Array of IPv6 Addresses.
        """
        NeighborGroupDestinationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv4_addresses=ipv4_addresses,
            ipv6_addresses=ipv6_addresses,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv4_addresses: Optional[Sequence[str]] = None,
             ipv6_addresses: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ipv4_addresses is None and 'ipv4Addresses' in kwargs:
            ipv4_addresses = kwargs['ipv4Addresses']
        if ipv6_addresses is None and 'ipv6Addresses' in kwargs:
            ipv6_addresses = kwargs['ipv6Addresses']

        if ipv4_addresses is not None:
            _setter("ipv4_addresses", ipv4_addresses)
        if ipv6_addresses is not None:
            _setter("ipv6_addresses", ipv6_addresses)

    @property
    @pulumi.getter(name="ipv4Addresses")
    def ipv4_addresses(self) -> Optional[Sequence[str]]:
        """
        Array of IPv4 Addresses.
        """
        return pulumi.get(self, "ipv4_addresses")

    @property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[Sequence[str]]:
        """
        Array of IPv6 Addresses.
        """
        return pulumi.get(self, "ipv6_addresses")


@pulumi.output_type
class NetworkTapPropertiesResponseDestinations(dict):
    """
    Destination.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationId":
            suggest = "destination_id"
        elif key == "destinationType":
            suggest = "destination_type"
        elif key == "destinationTapRuleId":
            suggest = "destination_tap_rule_id"
        elif key == "isolationDomainProperties":
            suggest = "isolation_domain_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkTapPropertiesResponseDestinations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkTapPropertiesResponseDestinations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkTapPropertiesResponseDestinations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_id: str,
                 destination_type: str,
                 name: str,
                 destination_tap_rule_id: Optional[str] = None,
                 isolation_domain_properties: Optional['outputs.IsolationDomainPropertiesResponse'] = None):
        """
        Destination.
        :param str destination_id: The destination Id. ARM Resource ID of either NNI or Internal Networks.
        :param str destination_type: Type of destination. Input can be IsolationDomain or Direct.
        :param str name: Destination name.
        :param str destination_tap_rule_id: ARM Resource ID of destination Tap Rule that contains match configurations.
        :param 'IsolationDomainPropertiesResponse' isolation_domain_properties: Isolation Domain Properties.
        """
        NetworkTapPropertiesResponseDestinations._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_id=destination_id,
            destination_type=destination_type,
            name=name,
            destination_tap_rule_id=destination_tap_rule_id,
            isolation_domain_properties=isolation_domain_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_id: Optional[str] = None,
             destination_type: Optional[str] = None,
             name: Optional[str] = None,
             destination_tap_rule_id: Optional[str] = None,
             isolation_domain_properties: Optional['outputs.IsolationDomainPropertiesResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_id is None and 'destinationId' in kwargs:
            destination_id = kwargs['destinationId']
        if destination_id is None:
            raise TypeError("Missing 'destination_id' argument")
        if destination_type is None and 'destinationType' in kwargs:
            destination_type = kwargs['destinationType']
        if destination_type is None:
            raise TypeError("Missing 'destination_type' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if destination_tap_rule_id is None and 'destinationTapRuleId' in kwargs:
            destination_tap_rule_id = kwargs['destinationTapRuleId']
        if isolation_domain_properties is None and 'isolationDomainProperties' in kwargs:
            isolation_domain_properties = kwargs['isolationDomainProperties']

        _setter("destination_id", destination_id)
        _setter("destination_type", destination_type)
        _setter("name", name)
        if destination_tap_rule_id is not None:
            _setter("destination_tap_rule_id", destination_tap_rule_id)
        if isolation_domain_properties is not None:
            _setter("isolation_domain_properties", isolation_domain_properties)

    @property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> str:
        """
        The destination Id. ARM Resource ID of either NNI or Internal Networks.
        """
        return pulumi.get(self, "destination_id")

    @property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> str:
        """
        Type of destination. Input can be IsolationDomain or Direct.
        """
        return pulumi.get(self, "destination_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Destination name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="destinationTapRuleId")
    def destination_tap_rule_id(self) -> Optional[str]:
        """
        ARM Resource ID of destination Tap Rule that contains match configurations.
        """
        return pulumi.get(self, "destination_tap_rule_id")

    @property
    @pulumi.getter(name="isolationDomainProperties")
    def isolation_domain_properties(self) -> Optional['outputs.IsolationDomainPropertiesResponse']:
        """
        Isolation Domain Properties.
        """
        return pulumi.get(self, "isolation_domain_properties")


@pulumi.output_type
class NetworkTapRuleActionResponse(dict):
    """
    Action that need to performed.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationId":
            suggest = "destination_id"
        elif key == "isTimestampEnabled":
            suggest = "is_timestamp_enabled"
        elif key == "matchConfigurationName":
            suggest = "match_configuration_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkTapRuleActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkTapRuleActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkTapRuleActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_id: Optional[str] = None,
                 is_timestamp_enabled: Optional[str] = None,
                 match_configuration_name: Optional[str] = None,
                 truncate: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Action that need to performed.
        :param str destination_id: Destination Id. The ARM resource Id may be either Network To Network Interconnect or NeighborGroup.
        :param str is_timestamp_enabled: The parameter to enable or disable the timestamp.
        :param str match_configuration_name: The name of the match configuration. This is used when Goto type is provided. If Goto type is selected and no match configuration name is provided. It goes to next configuration.
        :param str truncate: Truncate. 0 indicates do not truncate.
        :param str type: Type of actions that can be performed.
        """
        NetworkTapRuleActionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_id=destination_id,
            is_timestamp_enabled=is_timestamp_enabled,
            match_configuration_name=match_configuration_name,
            truncate=truncate,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_id: Optional[str] = None,
             is_timestamp_enabled: Optional[str] = None,
             match_configuration_name: Optional[str] = None,
             truncate: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_id is None and 'destinationId' in kwargs:
            destination_id = kwargs['destinationId']
        if is_timestamp_enabled is None and 'isTimestampEnabled' in kwargs:
            is_timestamp_enabled = kwargs['isTimestampEnabled']
        if match_configuration_name is None and 'matchConfigurationName' in kwargs:
            match_configuration_name = kwargs['matchConfigurationName']

        if destination_id is not None:
            _setter("destination_id", destination_id)
        if is_timestamp_enabled is not None:
            _setter("is_timestamp_enabled", is_timestamp_enabled)
        if match_configuration_name is not None:
            _setter("match_configuration_name", match_configuration_name)
        if truncate is not None:
            _setter("truncate", truncate)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[str]:
        """
        Destination Id. The ARM resource Id may be either Network To Network Interconnect or NeighborGroup.
        """
        return pulumi.get(self, "destination_id")

    @property
    @pulumi.getter(name="isTimestampEnabled")
    def is_timestamp_enabled(self) -> Optional[str]:
        """
        The parameter to enable or disable the timestamp.
        """
        return pulumi.get(self, "is_timestamp_enabled")

    @property
    @pulumi.getter(name="matchConfigurationName")
    def match_configuration_name(self) -> Optional[str]:
        """
        The name of the match configuration. This is used when Goto type is provided. If Goto type is selected and no match configuration name is provided. It goes to next configuration.
        """
        return pulumi.get(self, "match_configuration_name")

    @property
    @pulumi.getter
    def truncate(self) -> Optional[str]:
        """
        Truncate. 0 indicates do not truncate.
        """
        return pulumi.get(self, "truncate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of actions that can be performed.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NetworkTapRuleMatchConditionResponse(dict):
    """
    Defines the match condition that is supported to filter the traffic.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encapsulationType":
            suggest = "encapsulation_type"
        elif key == "ipCondition":
            suggest = "ip_condition"
        elif key == "portCondition":
            suggest = "port_condition"
        elif key == "protocolTypes":
            suggest = "protocol_types"
        elif key == "vlanMatchCondition":
            suggest = "vlan_match_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkTapRuleMatchConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkTapRuleMatchConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkTapRuleMatchConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encapsulation_type: Optional[str] = None,
                 ip_condition: Optional['outputs.IpMatchConditionResponse'] = None,
                 port_condition: Optional['outputs.PortConditionResponse'] = None,
                 protocol_types: Optional[Sequence[str]] = None,
                 vlan_match_condition: Optional['outputs.VlanMatchConditionResponse'] = None):
        """
        Defines the match condition that is supported to filter the traffic.
        :param str encapsulation_type: Encapsulation Type that needs to be matched.
        :param 'IpMatchConditionResponse' ip_condition: IP condition that needs to be matched.
        :param 'PortConditionResponse' port_condition: Defines the port condition that needs to be matched.
        :param Sequence[str] protocol_types: List of the protocols that need to be matched.
        :param 'VlanMatchConditionResponse' vlan_match_condition: Vlan match condition that needs to be matched.
        """
        NetworkTapRuleMatchConditionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            encapsulation_type=encapsulation_type,
            ip_condition=ip_condition,
            port_condition=port_condition,
            protocol_types=protocol_types,
            vlan_match_condition=vlan_match_condition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             encapsulation_type: Optional[str] = None,
             ip_condition: Optional['outputs.IpMatchConditionResponse'] = None,
             port_condition: Optional['outputs.PortConditionResponse'] = None,
             protocol_types: Optional[Sequence[str]] = None,
             vlan_match_condition: Optional['outputs.VlanMatchConditionResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if encapsulation_type is None and 'encapsulationType' in kwargs:
            encapsulation_type = kwargs['encapsulationType']
        if ip_condition is None and 'ipCondition' in kwargs:
            ip_condition = kwargs['ipCondition']
        if port_condition is None and 'portCondition' in kwargs:
            port_condition = kwargs['portCondition']
        if protocol_types is None and 'protocolTypes' in kwargs:
            protocol_types = kwargs['protocolTypes']
        if vlan_match_condition is None and 'vlanMatchCondition' in kwargs:
            vlan_match_condition = kwargs['vlanMatchCondition']

        if encapsulation_type is None:
            encapsulation_type = 'None'
        if encapsulation_type is not None:
            _setter("encapsulation_type", encapsulation_type)
        if ip_condition is not None:
            _setter("ip_condition", ip_condition)
        if port_condition is not None:
            _setter("port_condition", port_condition)
        if protocol_types is not None:
            _setter("protocol_types", protocol_types)
        if vlan_match_condition is not None:
            _setter("vlan_match_condition", vlan_match_condition)

    @property
    @pulumi.getter(name="encapsulationType")
    def encapsulation_type(self) -> Optional[str]:
        """
        Encapsulation Type that needs to be matched.
        """
        return pulumi.get(self, "encapsulation_type")

    @property
    @pulumi.getter(name="ipCondition")
    def ip_condition(self) -> Optional['outputs.IpMatchConditionResponse']:
        """
        IP condition that needs to be matched.
        """
        return pulumi.get(self, "ip_condition")

    @property
    @pulumi.getter(name="portCondition")
    def port_condition(self) -> Optional['outputs.PortConditionResponse']:
        """
        Defines the port condition that needs to be matched.
        """
        return pulumi.get(self, "port_condition")

    @property
    @pulumi.getter(name="protocolTypes")
    def protocol_types(self) -> Optional[Sequence[str]]:
        """
        List of the protocols that need to be matched.
        """
        return pulumi.get(self, "protocol_types")

    @property
    @pulumi.getter(name="vlanMatchCondition")
    def vlan_match_condition(self) -> Optional['outputs.VlanMatchConditionResponse']:
        """
        Vlan match condition that needs to be matched.
        """
        return pulumi.get(self, "vlan_match_condition")


@pulumi.output_type
class NetworkTapRuleMatchConfigurationResponse(dict):
    """
    Defines the match configuration that are supported to filter the traffic.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddressType":
            suggest = "ip_address_type"
        elif key == "matchConditions":
            suggest = "match_conditions"
        elif key == "matchConfigurationName":
            suggest = "match_configuration_name"
        elif key == "sequenceNumber":
            suggest = "sequence_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkTapRuleMatchConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkTapRuleMatchConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkTapRuleMatchConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Optional[Sequence['outputs.NetworkTapRuleActionResponse']] = None,
                 ip_address_type: Optional[str] = None,
                 match_conditions: Optional[Sequence['outputs.NetworkTapRuleMatchConditionResponse']] = None,
                 match_configuration_name: Optional[str] = None,
                 sequence_number: Optional[float] = None):
        """
        Defines the match configuration that are supported to filter the traffic.
        :param Sequence['NetworkTapRuleActionResponse'] actions: List of actions that need to be performed for the matched conditions.
        :param str ip_address_type: Type of IP Address. IPv4 or IPv6
        :param Sequence['NetworkTapRuleMatchConditionResponse'] match_conditions: List of the match conditions.
        :param str match_configuration_name: The name of the match configuration.
        :param float sequence_number: Sequence Number of the match configuration..
        """
        NetworkTapRuleMatchConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            ip_address_type=ip_address_type,
            match_conditions=match_conditions,
            match_configuration_name=match_configuration_name,
            sequence_number=sequence_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[Sequence['outputs.NetworkTapRuleActionResponse']] = None,
             ip_address_type: Optional[str] = None,
             match_conditions: Optional[Sequence['outputs.NetworkTapRuleMatchConditionResponse']] = None,
             match_configuration_name: Optional[str] = None,
             sequence_number: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_address_type is None and 'ipAddressType' in kwargs:
            ip_address_type = kwargs['ipAddressType']
        if match_conditions is None and 'matchConditions' in kwargs:
            match_conditions = kwargs['matchConditions']
        if match_configuration_name is None and 'matchConfigurationName' in kwargs:
            match_configuration_name = kwargs['matchConfigurationName']
        if sequence_number is None and 'sequenceNumber' in kwargs:
            sequence_number = kwargs['sequenceNumber']

        if actions is not None:
            _setter("actions", actions)
        if ip_address_type is not None:
            _setter("ip_address_type", ip_address_type)
        if match_conditions is not None:
            _setter("match_conditions", match_conditions)
        if match_configuration_name is not None:
            _setter("match_configuration_name", match_configuration_name)
        if sequence_number is not None:
            _setter("sequence_number", sequence_number)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.NetworkTapRuleActionResponse']]:
        """
        List of actions that need to be performed for the matched conditions.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[str]:
        """
        Type of IP Address. IPv4 or IPv6
        """
        return pulumi.get(self, "ip_address_type")

    @property
    @pulumi.getter(name="matchConditions")
    def match_conditions(self) -> Optional[Sequence['outputs.NetworkTapRuleMatchConditionResponse']]:
        """
        List of the match conditions.
        """
        return pulumi.get(self, "match_conditions")

    @property
    @pulumi.getter(name="matchConfigurationName")
    def match_configuration_name(self) -> Optional[str]:
        """
        The name of the match configuration.
        """
        return pulumi.get(self, "match_configuration_name")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> Optional[float]:
        """
        Sequence Number of the match configuration..
        """
        return pulumi.get(self, "sequence_number")


@pulumi.output_type
class NetworkToNetworkInterconnectPropertiesResponseOptionBLayer3Configuration(dict):
    """
    Common properties for Layer3Configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fabricASN":
            suggest = "fabric_asn"
        elif key == "peerASN":
            suggest = "peer_asn"
        elif key == "vlanId":
            suggest = "vlan_id"
        elif key == "primaryIpv4Prefix":
            suggest = "primary_ipv4_prefix"
        elif key == "primaryIpv6Prefix":
            suggest = "primary_ipv6_prefix"
        elif key == "secondaryIpv4Prefix":
            suggest = "secondary_ipv4_prefix"
        elif key == "secondaryIpv6Prefix":
            suggest = "secondary_ipv6_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkToNetworkInterconnectPropertiesResponseOptionBLayer3Configuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkToNetworkInterconnectPropertiesResponseOptionBLayer3Configuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkToNetworkInterconnectPropertiesResponseOptionBLayer3Configuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fabric_asn: float,
                 peer_asn: float,
                 vlan_id: int,
                 primary_ipv4_prefix: Optional[str] = None,
                 primary_ipv6_prefix: Optional[str] = None,
                 secondary_ipv4_prefix: Optional[str] = None,
                 secondary_ipv6_prefix: Optional[str] = None):
        """
        Common properties for Layer3Configuration.
        :param float fabric_asn: ASN of CE devices for CE/PE connectivity.
        :param float peer_asn: ASN of PE devices for CE/PE connectivity.Example : 28
        :param int vlan_id: VLAN for CE/PE Layer 3 connectivity.Example : 501
        :param str primary_ipv4_prefix: IPv4 Address Prefix.
        :param str primary_ipv6_prefix: IPv6 Address Prefix.
        :param str secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
        :param str secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
        """
        NetworkToNetworkInterconnectPropertiesResponseOptionBLayer3Configuration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fabric_asn=fabric_asn,
            peer_asn=peer_asn,
            vlan_id=vlan_id,
            primary_ipv4_prefix=primary_ipv4_prefix,
            primary_ipv6_prefix=primary_ipv6_prefix,
            secondary_ipv4_prefix=secondary_ipv4_prefix,
            secondary_ipv6_prefix=secondary_ipv6_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fabric_asn: Optional[float] = None,
             peer_asn: Optional[float] = None,
             vlan_id: Optional[int] = None,
             primary_ipv4_prefix: Optional[str] = None,
             primary_ipv6_prefix: Optional[str] = None,
             secondary_ipv4_prefix: Optional[str] = None,
             secondary_ipv6_prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fabric_asn is None and 'fabricASN' in kwargs:
            fabric_asn = kwargs['fabricASN']
        if fabric_asn is None:
            raise TypeError("Missing 'fabric_asn' argument")
        if peer_asn is None and 'peerASN' in kwargs:
            peer_asn = kwargs['peerASN']
        if peer_asn is None:
            raise TypeError("Missing 'peer_asn' argument")
        if vlan_id is None and 'vlanId' in kwargs:
            vlan_id = kwargs['vlanId']
        if vlan_id is None:
            raise TypeError("Missing 'vlan_id' argument")
        if primary_ipv4_prefix is None and 'primaryIpv4Prefix' in kwargs:
            primary_ipv4_prefix = kwargs['primaryIpv4Prefix']
        if primary_ipv6_prefix is None and 'primaryIpv6Prefix' in kwargs:
            primary_ipv6_prefix = kwargs['primaryIpv6Prefix']
        if secondary_ipv4_prefix is None and 'secondaryIpv4Prefix' in kwargs:
            secondary_ipv4_prefix = kwargs['secondaryIpv4Prefix']
        if secondary_ipv6_prefix is None and 'secondaryIpv6Prefix' in kwargs:
            secondary_ipv6_prefix = kwargs['secondaryIpv6Prefix']

        _setter("fabric_asn", fabric_asn)
        _setter("peer_asn", peer_asn)
        _setter("vlan_id", vlan_id)
        if primary_ipv4_prefix is not None:
            _setter("primary_ipv4_prefix", primary_ipv4_prefix)
        if primary_ipv6_prefix is not None:
            _setter("primary_ipv6_prefix", primary_ipv6_prefix)
        if secondary_ipv4_prefix is not None:
            _setter("secondary_ipv4_prefix", secondary_ipv4_prefix)
        if secondary_ipv6_prefix is not None:
            _setter("secondary_ipv6_prefix", secondary_ipv6_prefix)

    @property
    @pulumi.getter(name="fabricASN")
    def fabric_asn(self) -> float:
        """
        ASN of CE devices for CE/PE connectivity.
        """
        return pulumi.get(self, "fabric_asn")

    @property
    @pulumi.getter(name="peerASN")
    def peer_asn(self) -> float:
        """
        ASN of PE devices for CE/PE connectivity.Example : 28
        """
        return pulumi.get(self, "peer_asn")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> int:
        """
        VLAN for CE/PE Layer 3 connectivity.Example : 501
        """
        return pulumi.get(self, "vlan_id")

    @property
    @pulumi.getter(name="primaryIpv4Prefix")
    def primary_ipv4_prefix(self) -> Optional[str]:
        """
        IPv4 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv4_prefix")

    @property
    @pulumi.getter(name="primaryIpv6Prefix")
    def primary_ipv6_prefix(self) -> Optional[str]:
        """
        IPv6 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv6_prefix")

    @property
    @pulumi.getter(name="secondaryIpv4Prefix")
    def secondary_ipv4_prefix(self) -> Optional[str]:
        """
        Secondary IPv4 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv4_prefix")

    @property
    @pulumi.getter(name="secondaryIpv6Prefix")
    def secondary_ipv6_prefix(self) -> Optional[str]:
        """
        Secondary IPv6 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv6_prefix")


@pulumi.output_type
class NpbStaticRouteConfigurationResponse(dict):
    """
    NPB Static Route Configuration properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bfdConfiguration":
            suggest = "bfd_configuration"
        elif key == "ipv4Routes":
            suggest = "ipv4_routes"
        elif key == "ipv6Routes":
            suggest = "ipv6_routes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NpbStaticRouteConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NpbStaticRouteConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NpbStaticRouteConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bfd_configuration: Optional['outputs.BfdConfigurationResponse'] = None,
                 ipv4_routes: Optional[Sequence['outputs.StaticRoutePropertiesResponse']] = None,
                 ipv6_routes: Optional[Sequence['outputs.StaticRoutePropertiesResponse']] = None):
        """
        NPB Static Route Configuration properties.
        :param 'BfdConfigurationResponse' bfd_configuration: BFD Configuration properties.
        :param Sequence['StaticRoutePropertiesResponse'] ipv4_routes: List of IPv4 Routes.
        :param Sequence['StaticRoutePropertiesResponse'] ipv6_routes: List of IPv6 Routes.
        """
        NpbStaticRouteConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bfd_configuration=bfd_configuration,
            ipv4_routes=ipv4_routes,
            ipv6_routes=ipv6_routes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bfd_configuration: Optional['outputs.BfdConfigurationResponse'] = None,
             ipv4_routes: Optional[Sequence['outputs.StaticRoutePropertiesResponse']] = None,
             ipv6_routes: Optional[Sequence['outputs.StaticRoutePropertiesResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bfd_configuration is None and 'bfdConfiguration' in kwargs:
            bfd_configuration = kwargs['bfdConfiguration']
        if ipv4_routes is None and 'ipv4Routes' in kwargs:
            ipv4_routes = kwargs['ipv4Routes']
        if ipv6_routes is None and 'ipv6Routes' in kwargs:
            ipv6_routes = kwargs['ipv6Routes']

        if bfd_configuration is not None:
            _setter("bfd_configuration", bfd_configuration)
        if ipv4_routes is not None:
            _setter("ipv4_routes", ipv4_routes)
        if ipv6_routes is not None:
            _setter("ipv6_routes", ipv6_routes)

    @property
    @pulumi.getter(name="bfdConfiguration")
    def bfd_configuration(self) -> Optional['outputs.BfdConfigurationResponse']:
        """
        BFD Configuration properties.
        """
        return pulumi.get(self, "bfd_configuration")

    @property
    @pulumi.getter(name="ipv4Routes")
    def ipv4_routes(self) -> Optional[Sequence['outputs.StaticRoutePropertiesResponse']]:
        """
        List of IPv4 Routes.
        """
        return pulumi.get(self, "ipv4_routes")

    @property
    @pulumi.getter(name="ipv6Routes")
    def ipv6_routes(self) -> Optional[Sequence['outputs.StaticRoutePropertiesResponse']]:
        """
        List of IPv6 Routes.
        """
        return pulumi.get(self, "ipv6_routes")


@pulumi.output_type
class PortConditionResponse(dict):
    """
    Port condition that needs to be matched.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layer4Protocol":
            suggest = "layer4_protocol"
        elif key == "portGroupNames":
            suggest = "port_group_names"
        elif key == "portType":
            suggest = "port_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layer4_protocol: str,
                 port_group_names: Optional[Sequence[str]] = None,
                 port_type: Optional[str] = None,
                 ports: Optional[Sequence[str]] = None):
        """
        Port condition that needs to be matched.
        :param str layer4_protocol: Layer4 protocol type that needs to be matched.
        :param Sequence[str] port_group_names: List of the port Group Names that need to be matched.
        :param str port_type: Port type that needs to be matched.
        :param Sequence[str] ports: List of the Ports that need to be matched.
        """
        PortConditionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            layer4_protocol=layer4_protocol,
            port_group_names=port_group_names,
            port_type=port_type,
            ports=ports,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             layer4_protocol: Optional[str] = None,
             port_group_names: Optional[Sequence[str]] = None,
             port_type: Optional[str] = None,
             ports: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if layer4_protocol is None and 'layer4Protocol' in kwargs:
            layer4_protocol = kwargs['layer4Protocol']
        if layer4_protocol is None:
            raise TypeError("Missing 'layer4_protocol' argument")
        if port_group_names is None and 'portGroupNames' in kwargs:
            port_group_names = kwargs['portGroupNames']
        if port_type is None and 'portType' in kwargs:
            port_type = kwargs['portType']

        _setter("layer4_protocol", layer4_protocol)
        if port_group_names is not None:
            _setter("port_group_names", port_group_names)
        if port_type is not None:
            _setter("port_type", port_type)
        if ports is not None:
            _setter("ports", ports)

    @property
    @pulumi.getter(name="layer4Protocol")
    def layer4_protocol(self) -> str:
        """
        Layer4 protocol type that needs to be matched.
        """
        return pulumi.get(self, "layer4_protocol")

    @property
    @pulumi.getter(name="portGroupNames")
    def port_group_names(self) -> Optional[Sequence[str]]:
        """
        List of the port Group Names that need to be matched.
        """
        return pulumi.get(self, "port_group_names")

    @property
    @pulumi.getter(name="portType")
    def port_type(self) -> Optional[str]:
        """
        Port type that needs to be matched.
        """
        return pulumi.get(self, "port_type")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[str]]:
        """
        List of the Ports that need to be matched.
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class PortGroupPropertiesResponse(dict):
    """
    Port Group properties.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 ports: Optional[Sequence[str]] = None):
        """
        Port Group properties.
        :param str name: The name of the port group.
        :param Sequence[str] ports: List of the ports that need to be matched.
        """
        PortGroupPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            ports=ports,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             ports: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if ports is not None:
            _setter("ports", ports)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the port group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[str]]:
        """
        List of the ports that need to be matched.
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class RoutePolicyStatementPropertiesResponse(dict):
    """
    Route Policy Statement properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sequenceNumber":
            suggest = "sequence_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoutePolicyStatementPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoutePolicyStatementPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoutePolicyStatementPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: 'outputs.StatementActionPropertiesResponse',
                 condition: 'outputs.StatementConditionPropertiesResponse',
                 sequence_number: float,
                 annotation: Optional[str] = None):
        """
        Route Policy Statement properties.
        :param 'StatementActionPropertiesResponse' action: Route policy action properties.
        :param 'StatementConditionPropertiesResponse' condition: Route policy condition properties.
        :param float sequence_number: Sequence to insert to/delete from existing route.
        :param str annotation: Switch configuration description.
        """
        RoutePolicyStatementPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            condition=condition,
            sequence_number=sequence_number,
            annotation=annotation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional['outputs.StatementActionPropertiesResponse'] = None,
             condition: Optional['outputs.StatementConditionPropertiesResponse'] = None,
             sequence_number: Optional[float] = None,
             annotation: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if condition is None:
            raise TypeError("Missing 'condition' argument")
        if sequence_number is None and 'sequenceNumber' in kwargs:
            sequence_number = kwargs['sequenceNumber']
        if sequence_number is None:
            raise TypeError("Missing 'sequence_number' argument")

        _setter("action", action)
        _setter("condition", condition)
        _setter("sequence_number", sequence_number)
        if annotation is not None:
            _setter("annotation", annotation)

    @property
    @pulumi.getter
    def action(self) -> 'outputs.StatementActionPropertiesResponse':
        """
        Route policy action properties.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.StatementConditionPropertiesResponse':
        """
        Route policy condition properties.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> float:
        """
        Sequence to insert to/delete from existing route.
        """
        return pulumi.get(self, "sequence_number")

    @property
    @pulumi.getter
    def annotation(self) -> Optional[str]:
        """
        Switch configuration description.
        """
        return pulumi.get(self, "annotation")


@pulumi.output_type
class RouteTargetInformationResponse(dict):
    """
    Route Target Configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportIpv4RouteTargets":
            suggest = "export_ipv4_route_targets"
        elif key == "exportIpv6RouteTargets":
            suggest = "export_ipv6_route_targets"
        elif key == "importIpv4RouteTargets":
            suggest = "import_ipv4_route_targets"
        elif key == "importIpv6RouteTargets":
            suggest = "import_ipv6_route_targets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteTargetInformationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteTargetInformationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteTargetInformationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_ipv4_route_targets: Optional[Sequence[str]] = None,
                 export_ipv6_route_targets: Optional[Sequence[str]] = None,
                 import_ipv4_route_targets: Optional[Sequence[str]] = None,
                 import_ipv6_route_targets: Optional[Sequence[str]] = None):
        """
        Route Target Configuration.
        :param Sequence[str] export_ipv4_route_targets: Route Targets to be applied for outgoing routes into CE.
        :param Sequence[str] export_ipv6_route_targets: Route Targets to be applied for outgoing routes from CE.
        :param Sequence[str] import_ipv4_route_targets: Route Targets to be applied for incoming routes into CE.
        :param Sequence[str] import_ipv6_route_targets: Route Targets to be applied for incoming routes from CE.
        """
        RouteTargetInformationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            export_ipv4_route_targets=export_ipv4_route_targets,
            export_ipv6_route_targets=export_ipv6_route_targets,
            import_ipv4_route_targets=import_ipv4_route_targets,
            import_ipv6_route_targets=import_ipv6_route_targets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             export_ipv4_route_targets: Optional[Sequence[str]] = None,
             export_ipv6_route_targets: Optional[Sequence[str]] = None,
             import_ipv4_route_targets: Optional[Sequence[str]] = None,
             import_ipv6_route_targets: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if export_ipv4_route_targets is None and 'exportIpv4RouteTargets' in kwargs:
            export_ipv4_route_targets = kwargs['exportIpv4RouteTargets']
        if export_ipv6_route_targets is None and 'exportIpv6RouteTargets' in kwargs:
            export_ipv6_route_targets = kwargs['exportIpv6RouteTargets']
        if import_ipv4_route_targets is None and 'importIpv4RouteTargets' in kwargs:
            import_ipv4_route_targets = kwargs['importIpv4RouteTargets']
        if import_ipv6_route_targets is None and 'importIpv6RouteTargets' in kwargs:
            import_ipv6_route_targets = kwargs['importIpv6RouteTargets']

        if export_ipv4_route_targets is not None:
            _setter("export_ipv4_route_targets", export_ipv4_route_targets)
        if export_ipv6_route_targets is not None:
            _setter("export_ipv6_route_targets", export_ipv6_route_targets)
        if import_ipv4_route_targets is not None:
            _setter("import_ipv4_route_targets", import_ipv4_route_targets)
        if import_ipv6_route_targets is not None:
            _setter("import_ipv6_route_targets", import_ipv6_route_targets)

    @property
    @pulumi.getter(name="exportIpv4RouteTargets")
    def export_ipv4_route_targets(self) -> Optional[Sequence[str]]:
        """
        Route Targets to be applied for outgoing routes into CE.
        """
        return pulumi.get(self, "export_ipv4_route_targets")

    @property
    @pulumi.getter(name="exportIpv6RouteTargets")
    def export_ipv6_route_targets(self) -> Optional[Sequence[str]]:
        """
        Route Targets to be applied for outgoing routes from CE.
        """
        return pulumi.get(self, "export_ipv6_route_targets")

    @property
    @pulumi.getter(name="importIpv4RouteTargets")
    def import_ipv4_route_targets(self) -> Optional[Sequence[str]]:
        """
        Route Targets to be applied for incoming routes into CE.
        """
        return pulumi.get(self, "import_ipv4_route_targets")

    @property
    @pulumi.getter(name="importIpv6RouteTargets")
    def import_ipv6_route_targets(self) -> Optional[Sequence[str]]:
        """
        Route Targets to be applied for incoming routes from CE.
        """
        return pulumi.get(self, "import_ipv6_route_targets")


@pulumi.output_type
class RulePropertiesResponse(dict):
    """
    Rules for the InternetGateways
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressList":
            suggest = "address_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 address_list: Sequence[str]):
        """
        Rules for the InternetGateways
        :param str action: Specify action.
        :param Sequence[str] address_list: List of Addresses to be allowed or denied.
        """
        RulePropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            address_list=address_list,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             address_list: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if address_list is None and 'addressList' in kwargs:
            address_list = kwargs['addressList']
        if address_list is None:
            raise TypeError("Missing 'address_list' argument")

        _setter("action", action)
        _setter("address_list", address_list)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Specify action.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="addressList")
    def address_list(self) -> Sequence[str]:
        """
        List of Addresses to be allowed or denied.
        """
        return pulumi.get(self, "address_list")


@pulumi.output_type
class StatementActionPropertiesResponse(dict):
    """
    Route policy action properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "ipCommunityProperties":
            suggest = "ip_community_properties"
        elif key == "ipExtendedCommunityProperties":
            suggest = "ip_extended_community_properties"
        elif key == "localPreference":
            suggest = "local_preference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatementActionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatementActionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatementActionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: str,
                 ip_community_properties: Optional['outputs.ActionIpCommunityPropertiesResponse'] = None,
                 ip_extended_community_properties: Optional['outputs.ActionIpExtendedCommunityPropertiesResponse'] = None,
                 local_preference: Optional[float] = None):
        """
        Route policy action properties.
        :param str action_type: Action type. Example: Permit | Deny | Continue.
        :param 'ActionIpCommunityPropertiesResponse' ip_community_properties: IP Community Properties.
        :param 'ActionIpExtendedCommunityPropertiesResponse' ip_extended_community_properties: IP Extended Community Properties.
        :param float local_preference: Local Preference of the route policy.
        """
        StatementActionPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_type=action_type,
            ip_community_properties=ip_community_properties,
            ip_extended_community_properties=ip_extended_community_properties,
            local_preference=local_preference,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_type: Optional[str] = None,
             ip_community_properties: Optional['outputs.ActionIpCommunityPropertiesResponse'] = None,
             ip_extended_community_properties: Optional['outputs.ActionIpExtendedCommunityPropertiesResponse'] = None,
             local_preference: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_type is None and 'actionType' in kwargs:
            action_type = kwargs['actionType']
        if action_type is None:
            raise TypeError("Missing 'action_type' argument")
        if ip_community_properties is None and 'ipCommunityProperties' in kwargs:
            ip_community_properties = kwargs['ipCommunityProperties']
        if ip_extended_community_properties is None and 'ipExtendedCommunityProperties' in kwargs:
            ip_extended_community_properties = kwargs['ipExtendedCommunityProperties']
        if local_preference is None and 'localPreference' in kwargs:
            local_preference = kwargs['localPreference']

        _setter("action_type", action_type)
        if ip_community_properties is not None:
            _setter("ip_community_properties", ip_community_properties)
        if ip_extended_community_properties is not None:
            _setter("ip_extended_community_properties", ip_extended_community_properties)
        if local_preference is not None:
            _setter("local_preference", local_preference)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        Action type. Example: Permit | Deny | Continue.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="ipCommunityProperties")
    def ip_community_properties(self) -> Optional['outputs.ActionIpCommunityPropertiesResponse']:
        """
        IP Community Properties.
        """
        return pulumi.get(self, "ip_community_properties")

    @property
    @pulumi.getter(name="ipExtendedCommunityProperties")
    def ip_extended_community_properties(self) -> Optional['outputs.ActionIpExtendedCommunityPropertiesResponse']:
        """
        IP Extended Community Properties.
        """
        return pulumi.get(self, "ip_extended_community_properties")

    @property
    @pulumi.getter(name="localPreference")
    def local_preference(self) -> Optional[float]:
        """
        Local Preference of the route policy.
        """
        return pulumi.get(self, "local_preference")


@pulumi.output_type
class StatementConditionPropertiesResponse(dict):
    """
    Route policy statement condition properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipCommunityIds":
            suggest = "ip_community_ids"
        elif key == "ipExtendedCommunityIds":
            suggest = "ip_extended_community_ids"
        elif key == "ipPrefixId":
            suggest = "ip_prefix_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatementConditionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatementConditionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatementConditionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_community_ids: Optional[Sequence[str]] = None,
                 ip_extended_community_ids: Optional[Sequence[str]] = None,
                 ip_prefix_id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Route policy statement condition properties.
        :param Sequence[str] ip_community_ids: List of IP Community resource IDs.
        :param Sequence[str] ip_extended_community_ids: List of IP Extended Community resource IDs.
        :param str ip_prefix_id: Arm Resource Id of IpPrefix.
        :param str type: Type of the condition used.
        """
        StatementConditionPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_community_ids=ip_community_ids,
            ip_extended_community_ids=ip_extended_community_ids,
            ip_prefix_id=ip_prefix_id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_community_ids: Optional[Sequence[str]] = None,
             ip_extended_community_ids: Optional[Sequence[str]] = None,
             ip_prefix_id: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_community_ids is None and 'ipCommunityIds' in kwargs:
            ip_community_ids = kwargs['ipCommunityIds']
        if ip_extended_community_ids is None and 'ipExtendedCommunityIds' in kwargs:
            ip_extended_community_ids = kwargs['ipExtendedCommunityIds']
        if ip_prefix_id is None and 'ipPrefixId' in kwargs:
            ip_prefix_id = kwargs['ipPrefixId']

        if ip_community_ids is not None:
            _setter("ip_community_ids", ip_community_ids)
        if ip_extended_community_ids is not None:
            _setter("ip_extended_community_ids", ip_extended_community_ids)
        if ip_prefix_id is not None:
            _setter("ip_prefix_id", ip_prefix_id)
        if type is None:
            type = 'Or'
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="ipCommunityIds")
    def ip_community_ids(self) -> Optional[Sequence[str]]:
        """
        List of IP Community resource IDs.
        """
        return pulumi.get(self, "ip_community_ids")

    @property
    @pulumi.getter(name="ipExtendedCommunityIds")
    def ip_extended_community_ids(self) -> Optional[Sequence[str]]:
        """
        List of IP Extended Community resource IDs.
        """
        return pulumi.get(self, "ip_extended_community_ids")

    @property
    @pulumi.getter(name="ipPrefixId")
    def ip_prefix_id(self) -> Optional[str]:
        """
        Arm Resource Id of IpPrefix.
        """
        return pulumi.get(self, "ip_prefix_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the condition used.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class StaticRoutePropertiesResponse(dict):
    """
    Route Properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextHop":
            suggest = "next_hop"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StaticRoutePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StaticRoutePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StaticRoutePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 next_hop: Sequence[str],
                 prefix: str):
        """
        Route Properties.
        :param Sequence[str] next_hop: List of next hop addresses.
        :param str prefix: Prefix of the route.
        """
        StaticRoutePropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            next_hop=next_hop,
            prefix=prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             next_hop: Optional[Sequence[str]] = None,
             prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if next_hop is None and 'nextHop' in kwargs:
            next_hop = kwargs['nextHop']
        if next_hop is None:
            raise TypeError("Missing 'next_hop' argument")
        if prefix is None:
            raise TypeError("Missing 'prefix' argument")

        _setter("next_hop", next_hop)
        _setter("prefix", prefix)

    @property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> Sequence[str]:
        """
        List of next hop addresses.
        """
        return pulumi.get(self, "next_hop")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        Prefix of the route.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        SystemDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            created_by=created_by,
            created_by_type=created_by_type,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            last_modified_by_type=last_modified_by_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: Optional[str] = None,
             created_by: Optional[str] = None,
             created_by_type: Optional[str] = None,
             last_modified_at: Optional[str] = None,
             last_modified_by: Optional[str] = None,
             last_modified_by_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if created_at is None and 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if created_by_type is None and 'createdByType' in kwargs:
            created_by_type = kwargs['createdByType']
        if last_modified_at is None and 'lastModifiedAt' in kwargs:
            last_modified_at = kwargs['lastModifiedAt']
        if last_modified_by is None and 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if last_modified_by_type is None and 'lastModifiedByType' in kwargs:
            last_modified_by_type = kwargs['lastModifiedByType']

        if created_at is not None:
            _setter("created_at", created_at)
        if created_by is not None:
            _setter("created_by", created_by)
        if created_by_type is not None:
            _setter("created_by_type", created_by_type)
        if last_modified_at is not None:
            _setter("last_modified_at", last_modified_at)
        if last_modified_by is not None:
            _setter("last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            _setter("last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TerminalServerConfigurationResponse(dict):
    """
    Network and credentials configuration currently applied to terminal server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkDeviceId":
            suggest = "network_device_id"
        elif key == "primaryIpv4Prefix":
            suggest = "primary_ipv4_prefix"
        elif key == "secondaryIpv4Prefix":
            suggest = "secondary_ipv4_prefix"
        elif key == "primaryIpv6Prefix":
            suggest = "primary_ipv6_prefix"
        elif key == "secondaryIpv6Prefix":
            suggest = "secondary_ipv6_prefix"
        elif key == "serialNumber":
            suggest = "serial_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TerminalServerConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TerminalServerConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TerminalServerConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_device_id: str,
                 password: str,
                 primary_ipv4_prefix: str,
                 secondary_ipv4_prefix: str,
                 username: str,
                 primary_ipv6_prefix: Optional[str] = None,
                 secondary_ipv6_prefix: Optional[str] = None,
                 serial_number: Optional[str] = None):
        """
        Network and credentials configuration currently applied to terminal server.
        :param str network_device_id: ARM Resource ID used for the NetworkDevice.
        :param str password: Password for the terminal server connection.
        :param str primary_ipv4_prefix: IPv4 Address Prefix.
        :param str secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
        :param str username: Username for the terminal server connection.
        :param str primary_ipv6_prefix: IPv6 Address Prefix.
        :param str secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
        :param str serial_number: Serial Number of Terminal server.
        """
        TerminalServerConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network_device_id=network_device_id,
            password=password,
            primary_ipv4_prefix=primary_ipv4_prefix,
            secondary_ipv4_prefix=secondary_ipv4_prefix,
            username=username,
            primary_ipv6_prefix=primary_ipv6_prefix,
            secondary_ipv6_prefix=secondary_ipv6_prefix,
            serial_number=serial_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network_device_id: Optional[str] = None,
             password: Optional[str] = None,
             primary_ipv4_prefix: Optional[str] = None,
             secondary_ipv4_prefix: Optional[str] = None,
             username: Optional[str] = None,
             primary_ipv6_prefix: Optional[str] = None,
             secondary_ipv6_prefix: Optional[str] = None,
             serial_number: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if network_device_id is None and 'networkDeviceId' in kwargs:
            network_device_id = kwargs['networkDeviceId']
        if network_device_id is None:
            raise TypeError("Missing 'network_device_id' argument")
        if password is None:
            raise TypeError("Missing 'password' argument")
        if primary_ipv4_prefix is None and 'primaryIpv4Prefix' in kwargs:
            primary_ipv4_prefix = kwargs['primaryIpv4Prefix']
        if primary_ipv4_prefix is None:
            raise TypeError("Missing 'primary_ipv4_prefix' argument")
        if secondary_ipv4_prefix is None and 'secondaryIpv4Prefix' in kwargs:
            secondary_ipv4_prefix = kwargs['secondaryIpv4Prefix']
        if secondary_ipv4_prefix is None:
            raise TypeError("Missing 'secondary_ipv4_prefix' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")
        if primary_ipv6_prefix is None and 'primaryIpv6Prefix' in kwargs:
            primary_ipv6_prefix = kwargs['primaryIpv6Prefix']
        if secondary_ipv6_prefix is None and 'secondaryIpv6Prefix' in kwargs:
            secondary_ipv6_prefix = kwargs['secondaryIpv6Prefix']
        if serial_number is None and 'serialNumber' in kwargs:
            serial_number = kwargs['serialNumber']

        _setter("network_device_id", network_device_id)
        _setter("password", password)
        _setter("primary_ipv4_prefix", primary_ipv4_prefix)
        _setter("secondary_ipv4_prefix", secondary_ipv4_prefix)
        _setter("username", username)
        if primary_ipv6_prefix is not None:
            _setter("primary_ipv6_prefix", primary_ipv6_prefix)
        if secondary_ipv6_prefix is not None:
            _setter("secondary_ipv6_prefix", secondary_ipv6_prefix)
        if serial_number is not None:
            _setter("serial_number", serial_number)

    @property
    @pulumi.getter(name="networkDeviceId")
    def network_device_id(self) -> str:
        """
        ARM Resource ID used for the NetworkDevice.
        """
        return pulumi.get(self, "network_device_id")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password for the terminal server connection.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="primaryIpv4Prefix")
    def primary_ipv4_prefix(self) -> str:
        """
        IPv4 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv4_prefix")

    @property
    @pulumi.getter(name="secondaryIpv4Prefix")
    def secondary_ipv4_prefix(self) -> str:
        """
        Secondary IPv4 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv4_prefix")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username for the terminal server connection.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="primaryIpv6Prefix")
    def primary_ipv6_prefix(self) -> Optional[str]:
        """
        IPv6 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv6_prefix")

    @property
    @pulumi.getter(name="secondaryIpv6Prefix")
    def secondary_ipv6_prefix(self) -> Optional[str]:
        """
        Secondary IPv6 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv6_prefix")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[str]:
        """
        Serial Number of Terminal server.
        """
        return pulumi.get(self, "serial_number")


@pulumi.output_type
class VlanGroupPropertiesResponse(dict):
    """
    Vlan group properties.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 vlans: Optional[Sequence[str]] = None):
        """
        Vlan group properties.
        :param str name: Vlan group name.
        :param Sequence[str] vlans: List of vlans.
        """
        VlanGroupPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            vlans=vlans,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             vlans: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if vlans is not None:
            _setter("vlans", vlans)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Vlan group name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def vlans(self) -> Optional[Sequence[str]]:
        """
        List of vlans.
        """
        return pulumi.get(self, "vlans")


@pulumi.output_type
class VlanMatchConditionResponse(dict):
    """
    The vlan match conditions that need to be matched.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "innerVlans":
            suggest = "inner_vlans"
        elif key == "vlanGroupNames":
            suggest = "vlan_group_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VlanMatchConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VlanMatchConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VlanMatchConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inner_vlans: Optional[Sequence[str]] = None,
                 vlan_group_names: Optional[Sequence[str]] = None,
                 vlans: Optional[Sequence[str]] = None):
        """
        The vlan match conditions that need to be matched.
        :param Sequence[str] inner_vlans: List of inner vlans that need to be matched.
        :param Sequence[str] vlan_group_names: List of vlan group names that need to be matched.
        :param Sequence[str] vlans: List of vlans that need to be matched.
        """
        VlanMatchConditionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            inner_vlans=inner_vlans,
            vlan_group_names=vlan_group_names,
            vlans=vlans,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             inner_vlans: Optional[Sequence[str]] = None,
             vlan_group_names: Optional[Sequence[str]] = None,
             vlans: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if inner_vlans is None and 'innerVlans' in kwargs:
            inner_vlans = kwargs['innerVlans']
        if vlan_group_names is None and 'vlanGroupNames' in kwargs:
            vlan_group_names = kwargs['vlanGroupNames']

        if inner_vlans is not None:
            _setter("inner_vlans", inner_vlans)
        if vlan_group_names is not None:
            _setter("vlan_group_names", vlan_group_names)
        if vlans is not None:
            _setter("vlans", vlans)

    @property
    @pulumi.getter(name="innerVlans")
    def inner_vlans(self) -> Optional[Sequence[str]]:
        """
        List of inner vlans that need to be matched.
        """
        return pulumi.get(self, "inner_vlans")

    @property
    @pulumi.getter(name="vlanGroupNames")
    def vlan_group_names(self) -> Optional[Sequence[str]]:
        """
        List of vlan group names that need to be matched.
        """
        return pulumi.get(self, "vlan_group_names")

    @property
    @pulumi.getter
    def vlans(self) -> Optional[Sequence[str]]:
        """
        List of vlans that need to be matched.
        """
        return pulumi.get(self, "vlans")


@pulumi.output_type
class VpnConfigurationPropertiesResponse(dict):
    """
    Network and credential configuration currently applied on terminal server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "administrativeState":
            suggest = "administrative_state"
        elif key == "peeringOption":
            suggest = "peering_option"
        elif key == "networkToNetworkInterconnectId":
            suggest = "network_to_network_interconnect_id"
        elif key == "optionAProperties":
            suggest = "option_a_properties"
        elif key == "optionBProperties":
            suggest = "option_b_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConfigurationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConfigurationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConfigurationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 administrative_state: str,
                 peering_option: str,
                 network_to_network_interconnect_id: Optional[str] = None,
                 option_a_properties: Optional['outputs.VpnConfigurationPropertiesResponseOptionAProperties'] = None,
                 option_b_properties: Optional['outputs.FabricOptionBPropertiesResponse'] = None):
        """
        Network and credential configuration currently applied on terminal server.
        :param str administrative_state: Administrative state of the resource.
        :param str peering_option: Peering option list.
        :param str network_to_network_interconnect_id: ARM Resource ID of the Network To Network Interconnect.
        :param 'VpnConfigurationPropertiesResponseOptionAProperties' option_a_properties: option A properties
        :param 'FabricOptionBPropertiesResponse' option_b_properties: option B properties
        """
        VpnConfigurationPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            administrative_state=administrative_state,
            peering_option=peering_option,
            network_to_network_interconnect_id=network_to_network_interconnect_id,
            option_a_properties=option_a_properties,
            option_b_properties=option_b_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             administrative_state: Optional[str] = None,
             peering_option: Optional[str] = None,
             network_to_network_interconnect_id: Optional[str] = None,
             option_a_properties: Optional['outputs.VpnConfigurationPropertiesResponseOptionAProperties'] = None,
             option_b_properties: Optional['outputs.FabricOptionBPropertiesResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if administrative_state is None and 'administrativeState' in kwargs:
            administrative_state = kwargs['administrativeState']
        if administrative_state is None:
            raise TypeError("Missing 'administrative_state' argument")
        if peering_option is None and 'peeringOption' in kwargs:
            peering_option = kwargs['peeringOption']
        if peering_option is None:
            raise TypeError("Missing 'peering_option' argument")
        if network_to_network_interconnect_id is None and 'networkToNetworkInterconnectId' in kwargs:
            network_to_network_interconnect_id = kwargs['networkToNetworkInterconnectId']
        if option_a_properties is None and 'optionAProperties' in kwargs:
            option_a_properties = kwargs['optionAProperties']
        if option_b_properties is None and 'optionBProperties' in kwargs:
            option_b_properties = kwargs['optionBProperties']

        _setter("administrative_state", administrative_state)
        _setter("peering_option", peering_option)
        if network_to_network_interconnect_id is not None:
            _setter("network_to_network_interconnect_id", network_to_network_interconnect_id)
        if option_a_properties is not None:
            _setter("option_a_properties", option_a_properties)
        if option_b_properties is not None:
            _setter("option_b_properties", option_b_properties)

    @property
    @pulumi.getter(name="administrativeState")
    def administrative_state(self) -> str:
        """
        Administrative state of the resource.
        """
        return pulumi.get(self, "administrative_state")

    @property
    @pulumi.getter(name="peeringOption")
    def peering_option(self) -> str:
        """
        Peering option list.
        """
        return pulumi.get(self, "peering_option")

    @property
    @pulumi.getter(name="networkToNetworkInterconnectId")
    def network_to_network_interconnect_id(self) -> Optional[str]:
        """
        ARM Resource ID of the Network To Network Interconnect.
        """
        return pulumi.get(self, "network_to_network_interconnect_id")

    @property
    @pulumi.getter(name="optionAProperties")
    def option_a_properties(self) -> Optional['outputs.VpnConfigurationPropertiesResponseOptionAProperties']:
        """
        option A properties
        """
        return pulumi.get(self, "option_a_properties")

    @property
    @pulumi.getter(name="optionBProperties")
    def option_b_properties(self) -> Optional['outputs.FabricOptionBPropertiesResponse']:
        """
        option B properties
        """
        return pulumi.get(self, "option_b_properties")


@pulumi.output_type
class VpnConfigurationPropertiesResponseOptionAProperties(dict):
    """
    option A properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "peerASN":
            suggest = "peer_asn"
        elif key == "vlanId":
            suggest = "vlan_id"
        elif key == "bfdConfiguration":
            suggest = "bfd_configuration"
        elif key == "primaryIpv4Prefix":
            suggest = "primary_ipv4_prefix"
        elif key == "primaryIpv6Prefix":
            suggest = "primary_ipv6_prefix"
        elif key == "secondaryIpv4Prefix":
            suggest = "secondary_ipv4_prefix"
        elif key == "secondaryIpv6Prefix":
            suggest = "secondary_ipv6_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConfigurationPropertiesResponseOptionAProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConfigurationPropertiesResponseOptionAProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConfigurationPropertiesResponseOptionAProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 peer_asn: float,
                 vlan_id: int,
                 bfd_configuration: Optional['outputs.BfdConfigurationResponse'] = None,
                 mtu: Optional[int] = None,
                 primary_ipv4_prefix: Optional[str] = None,
                 primary_ipv6_prefix: Optional[str] = None,
                 secondary_ipv4_prefix: Optional[str] = None,
                 secondary_ipv6_prefix: Optional[str] = None):
        """
        option A properties
        :param float peer_asn: Peer ASN number.Example : 28
        :param int vlan_id: Vlan Id.Example : 501
        :param 'BfdConfigurationResponse' bfd_configuration: BFD Configuration properties.
        :param int mtu: MTU to use for option A peering.
        :param str primary_ipv4_prefix: IPv4 Address Prefix.
        :param str primary_ipv6_prefix: IPv6 Address Prefix.
        :param str secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
        :param str secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
        """
        VpnConfigurationPropertiesResponseOptionAProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            peer_asn=peer_asn,
            vlan_id=vlan_id,
            bfd_configuration=bfd_configuration,
            mtu=mtu,
            primary_ipv4_prefix=primary_ipv4_prefix,
            primary_ipv6_prefix=primary_ipv6_prefix,
            secondary_ipv4_prefix=secondary_ipv4_prefix,
            secondary_ipv6_prefix=secondary_ipv6_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             peer_asn: Optional[float] = None,
             vlan_id: Optional[int] = None,
             bfd_configuration: Optional['outputs.BfdConfigurationResponse'] = None,
             mtu: Optional[int] = None,
             primary_ipv4_prefix: Optional[str] = None,
             primary_ipv6_prefix: Optional[str] = None,
             secondary_ipv4_prefix: Optional[str] = None,
             secondary_ipv6_prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if peer_asn is None and 'peerASN' in kwargs:
            peer_asn = kwargs['peerASN']
        if peer_asn is None:
            raise TypeError("Missing 'peer_asn' argument")
        if vlan_id is None and 'vlanId' in kwargs:
            vlan_id = kwargs['vlanId']
        if vlan_id is None:
            raise TypeError("Missing 'vlan_id' argument")
        if bfd_configuration is None and 'bfdConfiguration' in kwargs:
            bfd_configuration = kwargs['bfdConfiguration']
        if primary_ipv4_prefix is None and 'primaryIpv4Prefix' in kwargs:
            primary_ipv4_prefix = kwargs['primaryIpv4Prefix']
        if primary_ipv6_prefix is None and 'primaryIpv6Prefix' in kwargs:
            primary_ipv6_prefix = kwargs['primaryIpv6Prefix']
        if secondary_ipv4_prefix is None and 'secondaryIpv4Prefix' in kwargs:
            secondary_ipv4_prefix = kwargs['secondaryIpv4Prefix']
        if secondary_ipv6_prefix is None and 'secondaryIpv6Prefix' in kwargs:
            secondary_ipv6_prefix = kwargs['secondaryIpv6Prefix']

        _setter("peer_asn", peer_asn)
        _setter("vlan_id", vlan_id)
        if bfd_configuration is not None:
            _setter("bfd_configuration", bfd_configuration)
        if mtu is None:
            mtu = 1500
        if mtu is not None:
            _setter("mtu", mtu)
        if primary_ipv4_prefix is not None:
            _setter("primary_ipv4_prefix", primary_ipv4_prefix)
        if primary_ipv6_prefix is not None:
            _setter("primary_ipv6_prefix", primary_ipv6_prefix)
        if secondary_ipv4_prefix is not None:
            _setter("secondary_ipv4_prefix", secondary_ipv4_prefix)
        if secondary_ipv6_prefix is not None:
            _setter("secondary_ipv6_prefix", secondary_ipv6_prefix)

    @property
    @pulumi.getter(name="peerASN")
    def peer_asn(self) -> float:
        """
        Peer ASN number.Example : 28
        """
        return pulumi.get(self, "peer_asn")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> int:
        """
        Vlan Id.Example : 501
        """
        return pulumi.get(self, "vlan_id")

    @property
    @pulumi.getter(name="bfdConfiguration")
    def bfd_configuration(self) -> Optional['outputs.BfdConfigurationResponse']:
        """
        BFD Configuration properties.
        """
        return pulumi.get(self, "bfd_configuration")

    @property
    @pulumi.getter
    def mtu(self) -> Optional[int]:
        """
        MTU to use for option A peering.
        """
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter(name="primaryIpv4Prefix")
    def primary_ipv4_prefix(self) -> Optional[str]:
        """
        IPv4 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv4_prefix")

    @property
    @pulumi.getter(name="primaryIpv6Prefix")
    def primary_ipv6_prefix(self) -> Optional[str]:
        """
        IPv6 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv6_prefix")

    @property
    @pulumi.getter(name="secondaryIpv4Prefix")
    def secondary_ipv4_prefix(self) -> Optional[str]:
        """
        Secondary IPv4 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv4_prefix")

    @property
    @pulumi.getter(name="secondaryIpv6Prefix")
    def secondary_ipv6_prefix(self) -> Optional[str]:
        """
        Secondary IPv6 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv6_prefix")


