# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AccessControlListActionResponse',
    'AccessControlListMatchConditionResponse',
    'AccessControlListMatchConfigurationResponse',
    'AccessControlListPortConditionResponse',
    'ActionIpCommunityPropertiesResponse',
    'ActionIpExtendedCommunityPropertiesResponse',
    'AggregateRouteConfigurationResponse',
    'AggregateRouteResponse',
    'BfdConfigurationResponse',
    'CommonDynamicMatchConfigurationResponse',
    'ConnectedSubnetResponse',
    'ConnectedSubnetRoutePolicyResponse',
    'ControllerServicesResponse',
    'ErrorAdditionalInfoResponse',
    'ErrorDetailResponse',
    'ExportRoutePolicyInformationResponse',
    'ExportRoutePolicyResponse',
    'ExpressRouteConnectionInformationResponse',
    'ExternalNetworkPropertiesResponseOptionAProperties',
    'FabricOptionBPropertiesResponse',
    'ImportRoutePolicyInformationResponse',
    'ImportRoutePolicyResponse',
    'InternalNetworkPropertiesResponseBgpConfiguration',
    'InternalNetworkPropertiesResponseStaticRouteConfiguration',
    'IpCommunityIdListResponse',
    'IpCommunityRuleResponse',
    'IpExtendedCommunityIdListResponse',
    'IpExtendedCommunityRuleResponse',
    'IpGroupPropertiesResponse',
    'IpMatchConditionResponse',
    'IpPrefixRuleResponse',
    'IsolationDomainPropertiesResponse',
    'L3ExportRoutePolicyResponse',
    'L3OptionBPropertiesResponse',
    'Layer2ConfigurationResponse',
    'ManagedResourceGroupConfigurationResponse',
    'ManagementNetworkConfigurationPropertiesResponse',
    'NeighborAddressResponse',
    'NeighborGroupDestinationResponse',
    'NetworkTapPropertiesResponseDestinations',
    'NetworkTapRuleActionResponse',
    'NetworkTapRuleMatchConditionResponse',
    'NetworkTapRuleMatchConfigurationResponse',
    'NetworkToNetworkInterconnectPropertiesResponseOptionBLayer3Configuration',
    'NpbStaticRouteConfigurationResponse',
    'PortConditionResponse',
    'PortGroupPropertiesResponse',
    'RoutePolicyStatementPropertiesResponse',
    'RouteTargetInformationResponse',
    'RulePropertiesResponse',
    'StatementActionPropertiesResponse',
    'StatementConditionPropertiesResponse',
    'StaticRoutePropertiesResponse',
    'SystemDataResponse',
    'TerminalServerConfigurationResponse',
    'VlanGroupPropertiesResponse',
    'VlanMatchConditionResponse',
    'VpnConfigurationPropertiesResponse',
    'VpnConfigurationPropertiesResponseOptionAProperties',
]

@pulumi.output_type
class AccessControlListActionResponse(dict):
    """
    Action that need to performed.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "counterName":
            suggest = "counter_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessControlListActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessControlListActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessControlListActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 counter_name: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        Action that need to performed.
        :param builtins.str counter_name: Name of the counter block to get match count information.
        :param builtins.str type: Type of actions that can be performed.
        """
        if counter_name is not None:
            pulumi.set(__self__, "counter_name", counter_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="counterName")
    def counter_name(self) -> Optional[builtins.str]:
        """
        Name of the counter block to get match count information.
        """
        return pulumi.get(self, "counter_name")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of actions that can be performed.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AccessControlListMatchConditionResponse(dict):
    """
    Defines the match condition that is supported to filter the traffic.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dscpMarkings":
            suggest = "dscp_markings"
        elif key == "etherTypes":
            suggest = "ether_types"
        elif key == "ipCondition":
            suggest = "ip_condition"
        elif key == "ipLengths":
            suggest = "ip_lengths"
        elif key == "portCondition":
            suggest = "port_condition"
        elif key == "protocolTypes":
            suggest = "protocol_types"
        elif key == "ttlValues":
            suggest = "ttl_values"
        elif key == "vlanMatchCondition":
            suggest = "vlan_match_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessControlListMatchConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessControlListMatchConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessControlListMatchConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dscp_markings: Optional[Sequence[builtins.str]] = None,
                 ether_types: Optional[Sequence[builtins.str]] = None,
                 fragments: Optional[Sequence[builtins.str]] = None,
                 ip_condition: Optional['outputs.IpMatchConditionResponse'] = None,
                 ip_lengths: Optional[Sequence[builtins.str]] = None,
                 port_condition: Optional['outputs.AccessControlListPortConditionResponse'] = None,
                 protocol_types: Optional[Sequence[builtins.str]] = None,
                 ttl_values: Optional[Sequence[builtins.str]] = None,
                 vlan_match_condition: Optional['outputs.VlanMatchConditionResponse'] = None):
        """
        Defines the match condition that is supported to filter the traffic.
        :param Sequence[builtins.str] dscp_markings: List of DSCP Markings that need to be matched.
        :param Sequence[builtins.str] ether_types: List of ether type values that need to be matched.
        :param Sequence[builtins.str] fragments: List of IP fragment packets that need to be matched.
        :param 'IpMatchConditionResponse' ip_condition: IP condition that needs to be matched.
        :param Sequence[builtins.str] ip_lengths: List of IP Lengths that need to be matched.
        :param 'AccessControlListPortConditionResponse' port_condition: Defines the port condition that needs to be matched.
        :param Sequence[builtins.str] protocol_types: List of the protocols that need to be matched.
        :param Sequence[builtins.str] ttl_values: List of TTL [Time To Live] values that need to be matched.
        :param 'VlanMatchConditionResponse' vlan_match_condition: Vlan match condition that needs to be matched.
        """
        if dscp_markings is not None:
            pulumi.set(__self__, "dscp_markings", dscp_markings)
        if ether_types is not None:
            pulumi.set(__self__, "ether_types", ether_types)
        if fragments is not None:
            pulumi.set(__self__, "fragments", fragments)
        if ip_condition is not None:
            pulumi.set(__self__, "ip_condition", ip_condition)
        if ip_lengths is not None:
            pulumi.set(__self__, "ip_lengths", ip_lengths)
        if port_condition is not None:
            pulumi.set(__self__, "port_condition", port_condition)
        if protocol_types is not None:
            pulumi.set(__self__, "protocol_types", protocol_types)
        if ttl_values is not None:
            pulumi.set(__self__, "ttl_values", ttl_values)
        if vlan_match_condition is not None:
            pulumi.set(__self__, "vlan_match_condition", vlan_match_condition)

    @property
    @pulumi.getter(name="dscpMarkings")
    def dscp_markings(self) -> Optional[Sequence[builtins.str]]:
        """
        List of DSCP Markings that need to be matched.
        """
        return pulumi.get(self, "dscp_markings")

    @property
    @pulumi.getter(name="etherTypes")
    def ether_types(self) -> Optional[Sequence[builtins.str]]:
        """
        List of ether type values that need to be matched.
        """
        return pulumi.get(self, "ether_types")

    @property
    @pulumi.getter
    def fragments(self) -> Optional[Sequence[builtins.str]]:
        """
        List of IP fragment packets that need to be matched.
        """
        return pulumi.get(self, "fragments")

    @property
    @pulumi.getter(name="ipCondition")
    def ip_condition(self) -> Optional['outputs.IpMatchConditionResponse']:
        """
        IP condition that needs to be matched.
        """
        return pulumi.get(self, "ip_condition")

    @property
    @pulumi.getter(name="ipLengths")
    def ip_lengths(self) -> Optional[Sequence[builtins.str]]:
        """
        List of IP Lengths that need to be matched.
        """
        return pulumi.get(self, "ip_lengths")

    @property
    @pulumi.getter(name="portCondition")
    def port_condition(self) -> Optional['outputs.AccessControlListPortConditionResponse']:
        """
        Defines the port condition that needs to be matched.
        """
        return pulumi.get(self, "port_condition")

    @property
    @pulumi.getter(name="protocolTypes")
    def protocol_types(self) -> Optional[Sequence[builtins.str]]:
        """
        List of the protocols that need to be matched.
        """
        return pulumi.get(self, "protocol_types")

    @property
    @pulumi.getter(name="ttlValues")
    def ttl_values(self) -> Optional[Sequence[builtins.str]]:
        """
        List of TTL [Time To Live] values that need to be matched.
        """
        return pulumi.get(self, "ttl_values")

    @property
    @pulumi.getter(name="vlanMatchCondition")
    def vlan_match_condition(self) -> Optional['outputs.VlanMatchConditionResponse']:
        """
        Vlan match condition that needs to be matched.
        """
        return pulumi.get(self, "vlan_match_condition")


@pulumi.output_type
class AccessControlListMatchConfigurationResponse(dict):
    """
    Defines the match configuration that are supported to filter the traffic.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddressType":
            suggest = "ip_address_type"
        elif key == "matchConditions":
            suggest = "match_conditions"
        elif key == "matchConfigurationName":
            suggest = "match_configuration_name"
        elif key == "sequenceNumber":
            suggest = "sequence_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessControlListMatchConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessControlListMatchConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessControlListMatchConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Optional[Sequence['outputs.AccessControlListActionResponse']] = None,
                 ip_address_type: Optional[builtins.str] = None,
                 match_conditions: Optional[Sequence['outputs.AccessControlListMatchConditionResponse']] = None,
                 match_configuration_name: Optional[builtins.str] = None,
                 sequence_number: Optional[builtins.float] = None):
        """
        Defines the match configuration that are supported to filter the traffic.
        :param Sequence['AccessControlListActionResponse'] actions: List of actions that need to be performed for the matched conditions.
        :param builtins.str ip_address_type: Type of IP Address. IPv4 or IPv6
        :param Sequence['AccessControlListMatchConditionResponse'] match_conditions: List of the match conditions.
        :param builtins.str match_configuration_name: The name of the match configuration.
        :param builtins.float sequence_number: Sequence Number of the match configuration.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)
        if match_conditions is not None:
            pulumi.set(__self__, "match_conditions", match_conditions)
        if match_configuration_name is not None:
            pulumi.set(__self__, "match_configuration_name", match_configuration_name)
        if sequence_number is not None:
            pulumi.set(__self__, "sequence_number", sequence_number)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AccessControlListActionResponse']]:
        """
        List of actions that need to be performed for the matched conditions.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[builtins.str]:
        """
        Type of IP Address. IPv4 or IPv6
        """
        return pulumi.get(self, "ip_address_type")

    @property
    @pulumi.getter(name="matchConditions")
    def match_conditions(self) -> Optional[Sequence['outputs.AccessControlListMatchConditionResponse']]:
        """
        List of the match conditions.
        """
        return pulumi.get(self, "match_conditions")

    @property
    @pulumi.getter(name="matchConfigurationName")
    def match_configuration_name(self) -> Optional[builtins.str]:
        """
        The name of the match configuration.
        """
        return pulumi.get(self, "match_configuration_name")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> Optional[builtins.float]:
        """
        Sequence Number of the match configuration.
        """
        return pulumi.get(self, "sequence_number")


@pulumi.output_type
class AccessControlListPortConditionResponse(dict):
    """
    Defines the port condition that needs to be matched.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layer4Protocol":
            suggest = "layer4_protocol"
        elif key == "portGroupNames":
            suggest = "port_group_names"
        elif key == "portType":
            suggest = "port_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessControlListPortConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessControlListPortConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessControlListPortConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layer4_protocol: builtins.str,
                 flags: Optional[Sequence[builtins.str]] = None,
                 port_group_names: Optional[Sequence[builtins.str]] = None,
                 port_type: Optional[builtins.str] = None,
                 ports: Optional[Sequence[builtins.str]] = None):
        """
        Defines the port condition that needs to be matched.
        :param builtins.str layer4_protocol: Layer4 protocol type that needs to be matched.
        :param Sequence[builtins.str] flags: List of protocol flags that need to be matched. Example: established | initial | <List-of-TCP-flags>. List of eligible TCP Flags are ack, fin, not-ack, not-fin, not-psh, not-rst, not-syn, not-urg, psh, rst, syn, urg
        :param Sequence[builtins.str] port_group_names: List of the port Group Names that need to be matched.
        :param builtins.str port_type: Port type that needs to be matched.
        :param Sequence[builtins.str] ports: List of the Ports that need to be matched.
        """
        pulumi.set(__self__, "layer4_protocol", layer4_protocol)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if port_group_names is not None:
            pulumi.set(__self__, "port_group_names", port_group_names)
        if port_type is not None:
            pulumi.set(__self__, "port_type", port_type)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter(name="layer4Protocol")
    def layer4_protocol(self) -> builtins.str:
        """
        Layer4 protocol type that needs to be matched.
        """
        return pulumi.get(self, "layer4_protocol")

    @property
    @pulumi.getter
    def flags(self) -> Optional[Sequence[builtins.str]]:
        """
        List of protocol flags that need to be matched. Example: established | initial | <List-of-TCP-flags>. List of eligible TCP Flags are ack, fin, not-ack, not-fin, not-psh, not-rst, not-syn, not-urg, psh, rst, syn, urg
        """
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter(name="portGroupNames")
    def port_group_names(self) -> Optional[Sequence[builtins.str]]:
        """
        List of the port Group Names that need to be matched.
        """
        return pulumi.get(self, "port_group_names")

    @property
    @pulumi.getter(name="portType")
    def port_type(self) -> Optional[builtins.str]:
        """
        Port type that needs to be matched.
        """
        return pulumi.get(self, "port_type")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[builtins.str]]:
        """
        List of the Ports that need to be matched.
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class ActionIpCommunityPropertiesResponse(dict):
    """
    IP Community Properties.
    """
    def __init__(__self__, *,
                 add: Optional['outputs.IpCommunityIdListResponse'] = None,
                 delete: Optional['outputs.IpCommunityIdListResponse'] = None,
                 set: Optional['outputs.IpCommunityIdListResponse'] = None):
        """
        IP Community Properties.
        :param 'IpCommunityIdListResponse' add: List of IP Community IDs.
        :param 'IpCommunityIdListResponse' delete: List of IP Community IDs.
        :param 'IpCommunityIdListResponse' set: List of IP Community IDs.
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional['outputs.IpCommunityIdListResponse']:
        """
        List of IP Community IDs.
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def delete(self) -> Optional['outputs.IpCommunityIdListResponse']:
        """
        List of IP Community IDs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def set(self) -> Optional['outputs.IpCommunityIdListResponse']:
        """
        List of IP Community IDs.
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class ActionIpExtendedCommunityPropertiesResponse(dict):
    """
    IP Extended Community Properties.
    """
    def __init__(__self__, *,
                 add: Optional['outputs.IpExtendedCommunityIdListResponse'] = None,
                 delete: Optional['outputs.IpExtendedCommunityIdListResponse'] = None,
                 set: Optional['outputs.IpExtendedCommunityIdListResponse'] = None):
        """
        IP Extended Community Properties.
        :param 'IpExtendedCommunityIdListResponse' add: List of IP Extended Community IDs.
        :param 'IpExtendedCommunityIdListResponse' delete: List of IP Extended Community IDs.
        :param 'IpExtendedCommunityIdListResponse' set: List of IP Extended Community IDs.
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional['outputs.IpExtendedCommunityIdListResponse']:
        """
        List of IP Extended Community IDs.
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def delete(self) -> Optional['outputs.IpExtendedCommunityIdListResponse']:
        """
        List of IP Extended Community IDs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def set(self) -> Optional['outputs.IpExtendedCommunityIdListResponse']:
        """
        List of IP Extended Community IDs.
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class AggregateRouteConfigurationResponse(dict):
    """
    List of IPv4 and IPv6 aggregate routes.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4Routes":
            suggest = "ipv4_routes"
        elif key == "ipv6Routes":
            suggest = "ipv6_routes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AggregateRouteConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AggregateRouteConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AggregateRouteConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4_routes: Optional[Sequence['outputs.AggregateRouteResponse']] = None,
                 ipv6_routes: Optional[Sequence['outputs.AggregateRouteResponse']] = None):
        """
        List of IPv4 and IPv6 aggregate routes.
        :param Sequence['AggregateRouteResponse'] ipv4_routes: List of IPv4 Route prefixes.
        :param Sequence['AggregateRouteResponse'] ipv6_routes: List of Ipv6Routes prefixes.
        """
        if ipv4_routes is not None:
            pulumi.set(__self__, "ipv4_routes", ipv4_routes)
        if ipv6_routes is not None:
            pulumi.set(__self__, "ipv6_routes", ipv6_routes)

    @property
    @pulumi.getter(name="ipv4Routes")
    def ipv4_routes(self) -> Optional[Sequence['outputs.AggregateRouteResponse']]:
        """
        List of IPv4 Route prefixes.
        """
        return pulumi.get(self, "ipv4_routes")

    @property
    @pulumi.getter(name="ipv6Routes")
    def ipv6_routes(self) -> Optional[Sequence['outputs.AggregateRouteResponse']]:
        """
        List of Ipv6Routes prefixes.
        """
        return pulumi.get(self, "ipv6_routes")


@pulumi.output_type
class AggregateRouteResponse(dict):
    """
    aggregateIpv4Route model.
    """
    def __init__(__self__, *,
                 prefix: builtins.str):
        """
        aggregateIpv4Route model.
        :param builtins.str prefix: IPv4 Prefix of the aggregate Ipv4Route.
        """
        pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def prefix(self) -> builtins.str:
        """
        IPv4 Prefix of the aggregate Ipv4Route.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class BfdConfigurationResponse(dict):
    """
    BFD configuration properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "administrativeState":
            suggest = "administrative_state"
        elif key == "intervalInMilliSeconds":
            suggest = "interval_in_milli_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BfdConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BfdConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BfdConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 administrative_state: Optional[builtins.str] = None,
                 interval_in_milli_seconds: Optional[builtins.int] = None,
                 multiplier: Optional[builtins.int] = None):
        """
        BFD configuration properties
        :param builtins.str administrative_state: Administrative state of the BfdConfiguration. Example: Enabled | Disabled.
        :param builtins.int interval_in_milli_seconds: Interval in milliseconds. Example: 300.
        :param builtins.int multiplier: Multiplier for the Bfd Configuration. Example: 5.
        """
        if administrative_state is None:
            administrative_state = 'Disabled'
        pulumi.set(__self__, "administrative_state", administrative_state)
        if interval_in_milli_seconds is None:
            interval_in_milli_seconds = 300
        if interval_in_milli_seconds is not None:
            pulumi.set(__self__, "interval_in_milli_seconds", interval_in_milli_seconds)
        if multiplier is None:
            multiplier = 5
        if multiplier is not None:
            pulumi.set(__self__, "multiplier", multiplier)

    @property
    @pulumi.getter(name="administrativeState")
    def administrative_state(self) -> builtins.str:
        """
        Administrative state of the BfdConfiguration. Example: Enabled | Disabled.
        """
        return pulumi.get(self, "administrative_state")

    @property
    @pulumi.getter(name="intervalInMilliSeconds")
    def interval_in_milli_seconds(self) -> Optional[builtins.int]:
        """
        Interval in milliseconds. Example: 300.
        """
        return pulumi.get(self, "interval_in_milli_seconds")

    @property
    @pulumi.getter
    def multiplier(self) -> Optional[builtins.int]:
        """
        Multiplier for the Bfd Configuration. Example: 5.
        """
        return pulumi.get(self, "multiplier")


@pulumi.output_type
class CommonDynamicMatchConfigurationResponse(dict):
    """
    Dynamic match configuration object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipGroups":
            suggest = "ip_groups"
        elif key == "portGroups":
            suggest = "port_groups"
        elif key == "vlanGroups":
            suggest = "vlan_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CommonDynamicMatchConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CommonDynamicMatchConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CommonDynamicMatchConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_groups: Optional[Sequence['outputs.IpGroupPropertiesResponse']] = None,
                 port_groups: Optional[Sequence['outputs.PortGroupPropertiesResponse']] = None,
                 vlan_groups: Optional[Sequence['outputs.VlanGroupPropertiesResponse']] = None):
        """
        Dynamic match configuration object.
        :param Sequence['IpGroupPropertiesResponse'] ip_groups: List of IP Groups.
        :param Sequence['PortGroupPropertiesResponse'] port_groups: List of the port groups.
        :param Sequence['VlanGroupPropertiesResponse'] vlan_groups: List of vlan groups.
        """
        if ip_groups is not None:
            pulumi.set(__self__, "ip_groups", ip_groups)
        if port_groups is not None:
            pulumi.set(__self__, "port_groups", port_groups)
        if vlan_groups is not None:
            pulumi.set(__self__, "vlan_groups", vlan_groups)

    @property
    @pulumi.getter(name="ipGroups")
    def ip_groups(self) -> Optional[Sequence['outputs.IpGroupPropertiesResponse']]:
        """
        List of IP Groups.
        """
        return pulumi.get(self, "ip_groups")

    @property
    @pulumi.getter(name="portGroups")
    def port_groups(self) -> Optional[Sequence['outputs.PortGroupPropertiesResponse']]:
        """
        List of the port groups.
        """
        return pulumi.get(self, "port_groups")

    @property
    @pulumi.getter(name="vlanGroups")
    def vlan_groups(self) -> Optional[Sequence['outputs.VlanGroupPropertiesResponse']]:
        """
        List of vlan groups.
        """
        return pulumi.get(self, "vlan_groups")


@pulumi.output_type
class ConnectedSubnetResponse(dict):
    """
    Connected Subnet properties.
    """
    def __init__(__self__, *,
                 prefix: builtins.str,
                 annotation: Optional[builtins.str] = None):
        """
        Connected Subnet properties.
        :param builtins.str prefix: Prefix of the Connected Subnet.
        :param builtins.str annotation: Switch configuration description.
        """
        pulumi.set(__self__, "prefix", prefix)
        if annotation is not None:
            pulumi.set(__self__, "annotation", annotation)

    @property
    @pulumi.getter
    def prefix(self) -> builtins.str:
        """
        Prefix of the Connected Subnet.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def annotation(self) -> Optional[builtins.str]:
        """
        Switch configuration description.
        """
        return pulumi.get(self, "annotation")


@pulumi.output_type
class ConnectedSubnetRoutePolicyResponse(dict):
    """
    Connected Subnet Route Policy properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportRoutePolicy":
            suggest = "export_route_policy"
        elif key == "exportRoutePolicyId":
            suggest = "export_route_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectedSubnetRoutePolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectedSubnetRoutePolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectedSubnetRoutePolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_route_policy: Optional['outputs.L3ExportRoutePolicyResponse'] = None,
                 export_route_policy_id: Optional[builtins.str] = None):
        """
        Connected Subnet Route Policy properties.
        :param 'L3ExportRoutePolicyResponse' export_route_policy: Array of ARM Resource ID of the RoutePolicies.
        :param builtins.str export_route_policy_id: ARM Resource ID of the Route Policy. This is used for the backward compatibility.
        """
        if export_route_policy is not None:
            pulumi.set(__self__, "export_route_policy", export_route_policy)
        if export_route_policy_id is not None:
            pulumi.set(__self__, "export_route_policy_id", export_route_policy_id)

    @property
    @pulumi.getter(name="exportRoutePolicy")
    def export_route_policy(self) -> Optional['outputs.L3ExportRoutePolicyResponse']:
        """
        Array of ARM Resource ID of the RoutePolicies.
        """
        return pulumi.get(self, "export_route_policy")

    @property
    @pulumi.getter(name="exportRoutePolicyId")
    def export_route_policy_id(self) -> Optional[builtins.str]:
        """
        ARM Resource ID of the Route Policy. This is used for the backward compatibility.
        """
        return pulumi.get(self, "export_route_policy_id")


@pulumi.output_type
class ControllerServicesResponse(dict):
    """
    Network Fabric Controller services.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4AddressSpaces":
            suggest = "ipv4_address_spaces"
        elif key == "ipv6AddressSpaces":
            suggest = "ipv6_address_spaces"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ControllerServicesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ControllerServicesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ControllerServicesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4_address_spaces: Optional[Sequence[builtins.str]] = None,
                 ipv6_address_spaces: Optional[Sequence[builtins.str]] = None):
        """
        Network Fabric Controller services.
        :param Sequence[builtins.str] ipv4_address_spaces: The IPv4 Address space is optional, if the value is not defined at the time of NFC creation, then the default value 10.0.0.0/19 is considered. The IPV4 address subnet is an optional attribute.
        :param Sequence[builtins.str] ipv6_address_spaces: The IPv6 is not supported right now.
        """
        if ipv4_address_spaces is not None:
            pulumi.set(__self__, "ipv4_address_spaces", ipv4_address_spaces)
        if ipv6_address_spaces is not None:
            pulumi.set(__self__, "ipv6_address_spaces", ipv6_address_spaces)

    @property
    @pulumi.getter(name="ipv4AddressSpaces")
    def ipv4_address_spaces(self) -> Optional[Sequence[builtins.str]]:
        """
        The IPv4 Address space is optional, if the value is not defined at the time of NFC creation, then the default value 10.0.0.0/19 is considered. The IPV4 address subnet is an optional attribute.
        """
        return pulumi.get(self, "ipv4_address_spaces")

    @property
    @pulumi.getter(name="ipv6AddressSpaces")
    def ipv6_address_spaces(self) -> Optional[Sequence[builtins.str]]:
        """
        The IPv6 is not supported right now.
        """
        return pulumi.get(self, "ipv6_address_spaces")


@pulumi.output_type
class ErrorAdditionalInfoResponse(dict):
    """
    The resource management error additional info.
    """
    def __init__(__self__, *,
                 info: Any,
                 type: builtins.str):
        """
        The resource management error additional info.
        :param Any info: The additional info.
        :param builtins.str type: The additional info type.
        """
        pulumi.set(__self__, "info", info)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def info(self) -> Any:
        """
        The additional info.
        """
        return pulumi.get(self, "info")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The additional info type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ErrorDetailResponse(dict):
    """
    The error detail.
    """
    def __init__(__self__, *,
                 additional_info: Sequence['outputs.ErrorAdditionalInfoResponse'],
                 code: builtins.str,
                 details: Sequence['outputs.ErrorDetailResponse'],
                 message: builtins.str,
                 target: builtins.str):
        """
        The error detail.
        :param Sequence['ErrorAdditionalInfoResponse'] additional_info: The error additional info.
        :param builtins.str code: The error code.
        :param Sequence['ErrorDetailResponse'] details: The error details.
        :param builtins.str message: The error message.
        :param builtins.str target: The error target.
        """
        pulumi.set(__self__, "additional_info", additional_info)
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="additionalInfo")
    def additional_info(self) -> Sequence['outputs.ErrorAdditionalInfoResponse']:
        """
        The error additional info.
        """
        return pulumi.get(self, "additional_info")

    @property
    @pulumi.getter
    def code(self) -> builtins.str:
        """
        The error code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.ErrorDetailResponse']:
        """
        The error details.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def message(self) -> builtins.str:
        """
        The error message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def target(self) -> builtins.str:
        """
        The error target.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class ExportRoutePolicyInformationResponse(dict):
    """
    Export Route Policy Configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportIpv4RoutePolicyId":
            suggest = "export_ipv4_route_policy_id"
        elif key == "exportIpv6RoutePolicyId":
            suggest = "export_ipv6_route_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExportRoutePolicyInformationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExportRoutePolicyInformationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExportRoutePolicyInformationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_ipv4_route_policy_id: Optional[builtins.str] = None,
                 export_ipv6_route_policy_id: Optional[builtins.str] = None):
        """
        Export Route Policy Configuration.
        :param builtins.str export_ipv4_route_policy_id: Export IPv4 Route Policy Id.
        :param builtins.str export_ipv6_route_policy_id: Export IPv6 Route Policy Id.
        """
        if export_ipv4_route_policy_id is not None:
            pulumi.set(__self__, "export_ipv4_route_policy_id", export_ipv4_route_policy_id)
        if export_ipv6_route_policy_id is not None:
            pulumi.set(__self__, "export_ipv6_route_policy_id", export_ipv6_route_policy_id)

    @property
    @pulumi.getter(name="exportIpv4RoutePolicyId")
    def export_ipv4_route_policy_id(self) -> Optional[builtins.str]:
        """
        Export IPv4 Route Policy Id.
        """
        return pulumi.get(self, "export_ipv4_route_policy_id")

    @property
    @pulumi.getter(name="exportIpv6RoutePolicyId")
    def export_ipv6_route_policy_id(self) -> Optional[builtins.str]:
        """
        Export IPv6 Route Policy Id.
        """
        return pulumi.get(self, "export_ipv6_route_policy_id")


@pulumi.output_type
class ExportRoutePolicyResponse(dict):
    """
    Export Route Policy either IPv4 or IPv6.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportIpv4RoutePolicyId":
            suggest = "export_ipv4_route_policy_id"
        elif key == "exportIpv6RoutePolicyId":
            suggest = "export_ipv6_route_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExportRoutePolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExportRoutePolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExportRoutePolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_ipv4_route_policy_id: Optional[builtins.str] = None,
                 export_ipv6_route_policy_id: Optional[builtins.str] = None):
        """
        Export Route Policy either IPv4 or IPv6.
        :param builtins.str export_ipv4_route_policy_id: ARM resource ID of RoutePolicy.
        :param builtins.str export_ipv6_route_policy_id: ARM resource ID of RoutePolicy.
        """
        if export_ipv4_route_policy_id is not None:
            pulumi.set(__self__, "export_ipv4_route_policy_id", export_ipv4_route_policy_id)
        if export_ipv6_route_policy_id is not None:
            pulumi.set(__self__, "export_ipv6_route_policy_id", export_ipv6_route_policy_id)

    @property
    @pulumi.getter(name="exportIpv4RoutePolicyId")
    def export_ipv4_route_policy_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of RoutePolicy.
        """
        return pulumi.get(self, "export_ipv4_route_policy_id")

    @property
    @pulumi.getter(name="exportIpv6RoutePolicyId")
    def export_ipv6_route_policy_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of RoutePolicy.
        """
        return pulumi.get(self, "export_ipv6_route_policy_id")


@pulumi.output_type
class ExpressRouteConnectionInformationResponse(dict):
    """
    The ExpressRoute circuit ID and the Auth Key are required for you to successfully deploy NFC service.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expressRouteAuthorizationKey":
            suggest = "express_route_authorization_key"
        elif key == "expressRouteCircuitId":
            suggest = "express_route_circuit_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRouteConnectionInformationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRouteConnectionInformationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRouteConnectionInformationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 express_route_authorization_key: builtins.str,
                 express_route_circuit_id: builtins.str):
        """
        The ExpressRoute circuit ID and the Auth Key are required for you to successfully deploy NFC service.
        :param builtins.str express_route_authorization_key: Authorization key for the circuit, must be of type Microsoft.Network/expressRouteCircuits/authorizations. The Auth Key is a mandatory attribute.
        :param builtins.str express_route_circuit_id: The express route circuit Azure resource ID, must be of type Microsoft.Network/expressRouteCircuits/circuitName. The ExpressRoute Circuit is a mandatory attribute.
        """
        pulumi.set(__self__, "express_route_authorization_key", express_route_authorization_key)
        pulumi.set(__self__, "express_route_circuit_id", express_route_circuit_id)

    @property
    @pulumi.getter(name="expressRouteAuthorizationKey")
    def express_route_authorization_key(self) -> builtins.str:
        """
        Authorization key for the circuit, must be of type Microsoft.Network/expressRouteCircuits/authorizations. The Auth Key is a mandatory attribute.
        """
        return pulumi.get(self, "express_route_authorization_key")

    @property
    @pulumi.getter(name="expressRouteCircuitId")
    def express_route_circuit_id(self) -> builtins.str:
        """
        The express route circuit Azure resource ID, must be of type Microsoft.Network/expressRouteCircuits/circuitName. The ExpressRoute Circuit is a mandatory attribute.
        """
        return pulumi.get(self, "express_route_circuit_id")


@pulumi.output_type
class ExternalNetworkPropertiesResponseOptionAProperties(dict):
    """
    option A properties object
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fabricASN":
            suggest = "fabric_asn"
        elif key == "peerASN":
            suggest = "peer_asn"
        elif key == "vlanId":
            suggest = "vlan_id"
        elif key == "bfdConfiguration":
            suggest = "bfd_configuration"
        elif key == "egressAclId":
            suggest = "egress_acl_id"
        elif key == "ingressAclId":
            suggest = "ingress_acl_id"
        elif key == "primaryIpv4Prefix":
            suggest = "primary_ipv4_prefix"
        elif key == "primaryIpv6Prefix":
            suggest = "primary_ipv6_prefix"
        elif key == "secondaryIpv4Prefix":
            suggest = "secondary_ipv4_prefix"
        elif key == "secondaryIpv6Prefix":
            suggest = "secondary_ipv6_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalNetworkPropertiesResponseOptionAProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalNetworkPropertiesResponseOptionAProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalNetworkPropertiesResponseOptionAProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fabric_asn: builtins.float,
                 peer_asn: builtins.float,
                 vlan_id: builtins.int,
                 bfd_configuration: Optional['outputs.BfdConfigurationResponse'] = None,
                 egress_acl_id: Optional[builtins.str] = None,
                 ingress_acl_id: Optional[builtins.str] = None,
                 mtu: Optional[builtins.int] = None,
                 primary_ipv4_prefix: Optional[builtins.str] = None,
                 primary_ipv6_prefix: Optional[builtins.str] = None,
                 secondary_ipv4_prefix: Optional[builtins.str] = None,
                 secondary_ipv6_prefix: Optional[builtins.str] = None):
        """
        option A properties object
        :param builtins.float fabric_asn: Fabric ASN number. Example 65001 
        :param builtins.float peer_asn: Peer ASN number.Example : 28
        :param builtins.int vlan_id: Vlan identifier. Example : 501
        :param 'BfdConfigurationResponse' bfd_configuration: BFD configuration properties
        :param builtins.str egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
        :param builtins.str ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
        :param builtins.int mtu: MTU to use for option A peering.
        :param builtins.str primary_ipv4_prefix: IPv4 Address Prefix.
        :param builtins.str primary_ipv6_prefix: IPv6 Address Prefix.
        :param builtins.str secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
        :param builtins.str secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
        """
        pulumi.set(__self__, "fabric_asn", fabric_asn)
        pulumi.set(__self__, "peer_asn", peer_asn)
        pulumi.set(__self__, "vlan_id", vlan_id)
        if bfd_configuration is not None:
            pulumi.set(__self__, "bfd_configuration", bfd_configuration)
        if egress_acl_id is not None:
            pulumi.set(__self__, "egress_acl_id", egress_acl_id)
        if ingress_acl_id is not None:
            pulumi.set(__self__, "ingress_acl_id", ingress_acl_id)
        if mtu is None:
            mtu = 1500
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if primary_ipv4_prefix is not None:
            pulumi.set(__self__, "primary_ipv4_prefix", primary_ipv4_prefix)
        if primary_ipv6_prefix is not None:
            pulumi.set(__self__, "primary_ipv6_prefix", primary_ipv6_prefix)
        if secondary_ipv4_prefix is not None:
            pulumi.set(__self__, "secondary_ipv4_prefix", secondary_ipv4_prefix)
        if secondary_ipv6_prefix is not None:
            pulumi.set(__self__, "secondary_ipv6_prefix", secondary_ipv6_prefix)

    @property
    @pulumi.getter(name="fabricASN")
    def fabric_asn(self) -> builtins.float:
        """
        Fabric ASN number. Example 65001 
        """
        return pulumi.get(self, "fabric_asn")

    @property
    @pulumi.getter(name="peerASN")
    def peer_asn(self) -> builtins.float:
        """
        Peer ASN number.Example : 28
        """
        return pulumi.get(self, "peer_asn")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> builtins.int:
        """
        Vlan identifier. Example : 501
        """
        return pulumi.get(self, "vlan_id")

    @property
    @pulumi.getter(name="bfdConfiguration")
    def bfd_configuration(self) -> Optional['outputs.BfdConfigurationResponse']:
        """
        BFD configuration properties
        """
        return pulumi.get(self, "bfd_configuration")

    @property
    @pulumi.getter(name="egressAclId")
    def egress_acl_id(self) -> Optional[builtins.str]:
        """
        Egress Acl. ARM resource ID of Access Control Lists.
        """
        return pulumi.get(self, "egress_acl_id")

    @property
    @pulumi.getter(name="ingressAclId")
    def ingress_acl_id(self) -> Optional[builtins.str]:
        """
        Ingress Acl. ARM resource ID of Access Control Lists.
        """
        return pulumi.get(self, "ingress_acl_id")

    @property
    @pulumi.getter
    def mtu(self) -> Optional[builtins.int]:
        """
        MTU to use for option A peering.
        """
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter(name="primaryIpv4Prefix")
    def primary_ipv4_prefix(self) -> Optional[builtins.str]:
        """
        IPv4 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv4_prefix")

    @property
    @pulumi.getter(name="primaryIpv6Prefix")
    def primary_ipv6_prefix(self) -> Optional[builtins.str]:
        """
        IPv6 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv6_prefix")

    @property
    @pulumi.getter(name="secondaryIpv4Prefix")
    def secondary_ipv4_prefix(self) -> Optional[builtins.str]:
        """
        Secondary IPv4 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv4_prefix")

    @property
    @pulumi.getter(name="secondaryIpv6Prefix")
    def secondary_ipv6_prefix(self) -> Optional[builtins.str]:
        """
        Secondary IPv6 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv6_prefix")


@pulumi.output_type
class FabricOptionBPropertiesResponse(dict):
    """
    Option B configuration to be used for Management VPN.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportRouteTargets":
            suggest = "export_route_targets"
        elif key == "importRouteTargets":
            suggest = "import_route_targets"
        elif key == "routeTargets":
            suggest = "route_targets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FabricOptionBPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FabricOptionBPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FabricOptionBPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_route_targets: Optional[Sequence[builtins.str]] = None,
                 import_route_targets: Optional[Sequence[builtins.str]] = None,
                 route_targets: Optional['outputs.RouteTargetInformationResponse'] = None):
        """
        Option B configuration to be used for Management VPN.
        :param Sequence[builtins.str] export_route_targets: Route Targets to be applied for outgoing routes from CE. This is for backward compatibility.
        :param Sequence[builtins.str] import_route_targets: Route Targets to be applied for incoming routes into CE. This is for backward compatibility.
        :param 'RouteTargetInformationResponse' route_targets: Route Targets to be applied.
        """
        if export_route_targets is not None:
            pulumi.set(__self__, "export_route_targets", export_route_targets)
        if import_route_targets is not None:
            pulumi.set(__self__, "import_route_targets", import_route_targets)
        if route_targets is not None:
            pulumi.set(__self__, "route_targets", route_targets)

    @property
    @pulumi.getter(name="exportRouteTargets")
    def export_route_targets(self) -> Optional[Sequence[builtins.str]]:
        """
        Route Targets to be applied for outgoing routes from CE. This is for backward compatibility.
        """
        return pulumi.get(self, "export_route_targets")

    @property
    @pulumi.getter(name="importRouteTargets")
    def import_route_targets(self) -> Optional[Sequence[builtins.str]]:
        """
        Route Targets to be applied for incoming routes into CE. This is for backward compatibility.
        """
        return pulumi.get(self, "import_route_targets")

    @property
    @pulumi.getter(name="routeTargets")
    def route_targets(self) -> Optional['outputs.RouteTargetInformationResponse']:
        """
        Route Targets to be applied.
        """
        return pulumi.get(self, "route_targets")


@pulumi.output_type
class ImportRoutePolicyInformationResponse(dict):
    """
    Import Route Policy Configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "importIpv4RoutePolicyId":
            suggest = "import_ipv4_route_policy_id"
        elif key == "importIpv6RoutePolicyId":
            suggest = "import_ipv6_route_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImportRoutePolicyInformationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImportRoutePolicyInformationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImportRoutePolicyInformationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 import_ipv4_route_policy_id: Optional[builtins.str] = None,
                 import_ipv6_route_policy_id: Optional[builtins.str] = None):
        """
        Import Route Policy Configuration.
        :param builtins.str import_ipv4_route_policy_id: Import IPv4 Route Policy Id.
        :param builtins.str import_ipv6_route_policy_id: Import IPv6 Route Policy Id.
        """
        if import_ipv4_route_policy_id is not None:
            pulumi.set(__self__, "import_ipv4_route_policy_id", import_ipv4_route_policy_id)
        if import_ipv6_route_policy_id is not None:
            pulumi.set(__self__, "import_ipv6_route_policy_id", import_ipv6_route_policy_id)

    @property
    @pulumi.getter(name="importIpv4RoutePolicyId")
    def import_ipv4_route_policy_id(self) -> Optional[builtins.str]:
        """
        Import IPv4 Route Policy Id.
        """
        return pulumi.get(self, "import_ipv4_route_policy_id")

    @property
    @pulumi.getter(name="importIpv6RoutePolicyId")
    def import_ipv6_route_policy_id(self) -> Optional[builtins.str]:
        """
        Import IPv6 Route Policy Id.
        """
        return pulumi.get(self, "import_ipv6_route_policy_id")


@pulumi.output_type
class ImportRoutePolicyResponse(dict):
    """
    Import Route Policy either IPv4 or IPv6.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "importIpv4RoutePolicyId":
            suggest = "import_ipv4_route_policy_id"
        elif key == "importIpv6RoutePolicyId":
            suggest = "import_ipv6_route_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImportRoutePolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImportRoutePolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImportRoutePolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 import_ipv4_route_policy_id: Optional[builtins.str] = None,
                 import_ipv6_route_policy_id: Optional[builtins.str] = None):
        """
        Import Route Policy either IPv4 or IPv6.
        :param builtins.str import_ipv4_route_policy_id: ARM resource ID of RoutePolicy.
        :param builtins.str import_ipv6_route_policy_id: ARM resource ID of RoutePolicy.
        """
        if import_ipv4_route_policy_id is not None:
            pulumi.set(__self__, "import_ipv4_route_policy_id", import_ipv4_route_policy_id)
        if import_ipv6_route_policy_id is not None:
            pulumi.set(__self__, "import_ipv6_route_policy_id", import_ipv6_route_policy_id)

    @property
    @pulumi.getter(name="importIpv4RoutePolicyId")
    def import_ipv4_route_policy_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of RoutePolicy.
        """
        return pulumi.get(self, "import_ipv4_route_policy_id")

    @property
    @pulumi.getter(name="importIpv6RoutePolicyId")
    def import_ipv6_route_policy_id(self) -> Optional[builtins.str]:
        """
        ARM resource ID of RoutePolicy.
        """
        return pulumi.get(self, "import_ipv6_route_policy_id")


@pulumi.output_type
class InternalNetworkPropertiesResponseBgpConfiguration(dict):
    """
    BGP configuration properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fabricASN":
            suggest = "fabric_asn"
        elif key == "peerASN":
            suggest = "peer_asn"
        elif key == "allowAS":
            suggest = "allow_as"
        elif key == "allowASOverride":
            suggest = "allow_as_override"
        elif key == "bfdConfiguration":
            suggest = "bfd_configuration"
        elif key == "defaultRouteOriginate":
            suggest = "default_route_originate"
        elif key == "ipv4ListenRangePrefixes":
            suggest = "ipv4_listen_range_prefixes"
        elif key == "ipv4NeighborAddress":
            suggest = "ipv4_neighbor_address"
        elif key == "ipv6ListenRangePrefixes":
            suggest = "ipv6_listen_range_prefixes"
        elif key == "ipv6NeighborAddress":
            suggest = "ipv6_neighbor_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternalNetworkPropertiesResponseBgpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternalNetworkPropertiesResponseBgpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternalNetworkPropertiesResponseBgpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fabric_asn: builtins.float,
                 peer_asn: builtins.float,
                 allow_as: Optional[builtins.int] = None,
                 allow_as_override: Optional[builtins.str] = None,
                 annotation: Optional[builtins.str] = None,
                 bfd_configuration: Optional['outputs.BfdConfigurationResponse'] = None,
                 default_route_originate: Optional[builtins.str] = None,
                 ipv4_listen_range_prefixes: Optional[Sequence[builtins.str]] = None,
                 ipv4_neighbor_address: Optional[Sequence['outputs.NeighborAddressResponse']] = None,
                 ipv6_listen_range_prefixes: Optional[Sequence[builtins.str]] = None,
                 ipv6_neighbor_address: Optional[Sequence['outputs.NeighborAddressResponse']] = None):
        """
        BGP configuration properties.
        :param builtins.float fabric_asn: ASN of Network Fabric. Example: 65048.
        :param builtins.float peer_asn: Peer ASN. Example: 65047.
        :param builtins.int allow_as: Allows for routes to be received and processed even if the router detects its own ASN in the AS-Path. 0 is disable, Possible values are 1-10, default is 2.
        :param builtins.str allow_as_override: Enable Or Disable state.
        :param builtins.str annotation: Switch configuration description.
        :param 'BfdConfigurationResponse' bfd_configuration: BFD configuration properties
        :param builtins.str default_route_originate: Originate a defaultRoute. Ex: "True" | "False".
        :param Sequence[builtins.str] ipv4_listen_range_prefixes: List of BGP IPv4 Listen Range prefixes.
        :param Sequence['NeighborAddressResponse'] ipv4_neighbor_address: List with stringified IPv4 Neighbor Addresses.
        :param Sequence[builtins.str] ipv6_listen_range_prefixes: List of BGP IPv6 Listen Ranges prefixes.
        :param Sequence['NeighborAddressResponse'] ipv6_neighbor_address: List with stringified IPv6 Neighbor Address.
        """
        pulumi.set(__self__, "fabric_asn", fabric_asn)
        pulumi.set(__self__, "peer_asn", peer_asn)
        if allow_as is None:
            allow_as = 2
        if allow_as is not None:
            pulumi.set(__self__, "allow_as", allow_as)
        if allow_as_override is not None:
            pulumi.set(__self__, "allow_as_override", allow_as_override)
        if annotation is not None:
            pulumi.set(__self__, "annotation", annotation)
        if bfd_configuration is not None:
            pulumi.set(__self__, "bfd_configuration", bfd_configuration)
        if default_route_originate is not None:
            pulumi.set(__self__, "default_route_originate", default_route_originate)
        if ipv4_listen_range_prefixes is not None:
            pulumi.set(__self__, "ipv4_listen_range_prefixes", ipv4_listen_range_prefixes)
        if ipv4_neighbor_address is not None:
            pulumi.set(__self__, "ipv4_neighbor_address", ipv4_neighbor_address)
        if ipv6_listen_range_prefixes is not None:
            pulumi.set(__self__, "ipv6_listen_range_prefixes", ipv6_listen_range_prefixes)
        if ipv6_neighbor_address is not None:
            pulumi.set(__self__, "ipv6_neighbor_address", ipv6_neighbor_address)

    @property
    @pulumi.getter(name="fabricASN")
    def fabric_asn(self) -> builtins.float:
        """
        ASN of Network Fabric. Example: 65048.
        """
        return pulumi.get(self, "fabric_asn")

    @property
    @pulumi.getter(name="peerASN")
    def peer_asn(self) -> builtins.float:
        """
        Peer ASN. Example: 65047.
        """
        return pulumi.get(self, "peer_asn")

    @property
    @pulumi.getter(name="allowAS")
    def allow_as(self) -> Optional[builtins.int]:
        """
        Allows for routes to be received and processed even if the router detects its own ASN in the AS-Path. 0 is disable, Possible values are 1-10, default is 2.
        """
        return pulumi.get(self, "allow_as")

    @property
    @pulumi.getter(name="allowASOverride")
    def allow_as_override(self) -> Optional[builtins.str]:
        """
        Enable Or Disable state.
        """
        return pulumi.get(self, "allow_as_override")

    @property
    @pulumi.getter
    def annotation(self) -> Optional[builtins.str]:
        """
        Switch configuration description.
        """
        return pulumi.get(self, "annotation")

    @property
    @pulumi.getter(name="bfdConfiguration")
    def bfd_configuration(self) -> Optional['outputs.BfdConfigurationResponse']:
        """
        BFD configuration properties
        """
        return pulumi.get(self, "bfd_configuration")

    @property
    @pulumi.getter(name="defaultRouteOriginate")
    def default_route_originate(self) -> Optional[builtins.str]:
        """
        Originate a defaultRoute. Ex: "True" | "False".
        """
        return pulumi.get(self, "default_route_originate")

    @property
    @pulumi.getter(name="ipv4ListenRangePrefixes")
    def ipv4_listen_range_prefixes(self) -> Optional[Sequence[builtins.str]]:
        """
        List of BGP IPv4 Listen Range prefixes.
        """
        return pulumi.get(self, "ipv4_listen_range_prefixes")

    @property
    @pulumi.getter(name="ipv4NeighborAddress")
    def ipv4_neighbor_address(self) -> Optional[Sequence['outputs.NeighborAddressResponse']]:
        """
        List with stringified IPv4 Neighbor Addresses.
        """
        return pulumi.get(self, "ipv4_neighbor_address")

    @property
    @pulumi.getter(name="ipv6ListenRangePrefixes")
    def ipv6_listen_range_prefixes(self) -> Optional[Sequence[builtins.str]]:
        """
        List of BGP IPv6 Listen Ranges prefixes.
        """
        return pulumi.get(self, "ipv6_listen_range_prefixes")

    @property
    @pulumi.getter(name="ipv6NeighborAddress")
    def ipv6_neighbor_address(self) -> Optional[Sequence['outputs.NeighborAddressResponse']]:
        """
        List with stringified IPv6 Neighbor Address.
        """
        return pulumi.get(self, "ipv6_neighbor_address")


@pulumi.output_type
class InternalNetworkPropertiesResponseStaticRouteConfiguration(dict):
    """
    Static Route Configuration properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bfdConfiguration":
            suggest = "bfd_configuration"
        elif key == "ipv4Routes":
            suggest = "ipv4_routes"
        elif key == "ipv6Routes":
            suggest = "ipv6_routes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternalNetworkPropertiesResponseStaticRouteConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternalNetworkPropertiesResponseStaticRouteConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternalNetworkPropertiesResponseStaticRouteConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bfd_configuration: Optional['outputs.BfdConfigurationResponse'] = None,
                 extension: Optional[builtins.str] = None,
                 ipv4_routes: Optional[Sequence['outputs.StaticRoutePropertiesResponse']] = None,
                 ipv6_routes: Optional[Sequence['outputs.StaticRoutePropertiesResponse']] = None):
        """
        Static Route Configuration properties.
        :param 'BfdConfigurationResponse' bfd_configuration: BFD configuration properties
        :param builtins.str extension: Extension. Example: NoExtension | NPB.
        :param Sequence['StaticRoutePropertiesResponse'] ipv4_routes: List of IPv4 Routes.
        :param Sequence['StaticRoutePropertiesResponse'] ipv6_routes: List of IPv6 Routes.
        """
        if bfd_configuration is not None:
            pulumi.set(__self__, "bfd_configuration", bfd_configuration)
        if extension is None:
            extension = 'NoExtension'
        if extension is not None:
            pulumi.set(__self__, "extension", extension)
        if ipv4_routes is not None:
            pulumi.set(__self__, "ipv4_routes", ipv4_routes)
        if ipv6_routes is not None:
            pulumi.set(__self__, "ipv6_routes", ipv6_routes)

    @property
    @pulumi.getter(name="bfdConfiguration")
    def bfd_configuration(self) -> Optional['outputs.BfdConfigurationResponse']:
        """
        BFD configuration properties
        """
        return pulumi.get(self, "bfd_configuration")

    @property
    @pulumi.getter
    def extension(self) -> Optional[builtins.str]:
        """
        Extension. Example: NoExtension | NPB.
        """
        return pulumi.get(self, "extension")

    @property
    @pulumi.getter(name="ipv4Routes")
    def ipv4_routes(self) -> Optional[Sequence['outputs.StaticRoutePropertiesResponse']]:
        """
        List of IPv4 Routes.
        """
        return pulumi.get(self, "ipv4_routes")

    @property
    @pulumi.getter(name="ipv6Routes")
    def ipv6_routes(self) -> Optional[Sequence['outputs.StaticRoutePropertiesResponse']]:
        """
        List of IPv6 Routes.
        """
        return pulumi.get(self, "ipv6_routes")


@pulumi.output_type
class IpCommunityIdListResponse(dict):
    """
    IP Community ID list properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipCommunityIds":
            suggest = "ip_community_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpCommunityIdListResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpCommunityIdListResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpCommunityIdListResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_community_ids: Optional[Sequence[builtins.str]] = None):
        """
        IP Community ID list properties.
        :param Sequence[builtins.str] ip_community_ids: List of IP Community resource IDs.
        """
        if ip_community_ids is not None:
            pulumi.set(__self__, "ip_community_ids", ip_community_ids)

    @property
    @pulumi.getter(name="ipCommunityIds")
    def ip_community_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        List of IP Community resource IDs.
        """
        return pulumi.get(self, "ip_community_ids")


@pulumi.output_type
class IpCommunityRuleResponse(dict):
    """
    IP Community patchable properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "communityMembers":
            suggest = "community_members"
        elif key == "sequenceNumber":
            suggest = "sequence_number"
        elif key == "wellKnownCommunities":
            suggest = "well_known_communities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpCommunityRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpCommunityRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpCommunityRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: builtins.str,
                 community_members: Sequence[builtins.str],
                 sequence_number: builtins.float,
                 well_known_communities: Optional[Sequence[builtins.str]] = None):
        """
        IP Community patchable properties.
        :param builtins.str action: Action to be taken on the configuration. Example: Permit | Deny.
        :param Sequence[builtins.str] community_members: List the community members of IP Community.
        :param builtins.float sequence_number: Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        :param Sequence[builtins.str] well_known_communities: Supported well known Community List.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "community_members", community_members)
        pulumi.set(__self__, "sequence_number", sequence_number)
        if well_known_communities is not None:
            pulumi.set(__self__, "well_known_communities", well_known_communities)

    @property
    @pulumi.getter
    def action(self) -> builtins.str:
        """
        Action to be taken on the configuration. Example: Permit | Deny.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="communityMembers")
    def community_members(self) -> Sequence[builtins.str]:
        """
        List the community members of IP Community.
        """
        return pulumi.get(self, "community_members")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> builtins.float:
        """
        Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        """
        return pulumi.get(self, "sequence_number")

    @property
    @pulumi.getter(name="wellKnownCommunities")
    def well_known_communities(self) -> Optional[Sequence[builtins.str]]:
        """
        Supported well known Community List.
        """
        return pulumi.get(self, "well_known_communities")


@pulumi.output_type
class IpExtendedCommunityIdListResponse(dict):
    """
    IP Extended Community Id list properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipExtendedCommunityIds":
            suggest = "ip_extended_community_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpExtendedCommunityIdListResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpExtendedCommunityIdListResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpExtendedCommunityIdListResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_extended_community_ids: Optional[Sequence[builtins.str]] = None):
        """
        IP Extended Community Id list properties.
        :param Sequence[builtins.str] ip_extended_community_ids: List of IP Extended Community resource IDs.
        """
        if ip_extended_community_ids is not None:
            pulumi.set(__self__, "ip_extended_community_ids", ip_extended_community_ids)

    @property
    @pulumi.getter(name="ipExtendedCommunityIds")
    def ip_extended_community_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        List of IP Extended Community resource IDs.
        """
        return pulumi.get(self, "ip_extended_community_ids")


@pulumi.output_type
class IpExtendedCommunityRuleResponse(dict):
    """
    List of IP Extended Community Rules.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routeTargets":
            suggest = "route_targets"
        elif key == "sequenceNumber":
            suggest = "sequence_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpExtendedCommunityRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpExtendedCommunityRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpExtendedCommunityRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: builtins.str,
                 route_targets: Sequence[builtins.str],
                 sequence_number: builtins.float):
        """
        List of IP Extended Community Rules.
        :param builtins.str action: Action to be taken on the configuration. Example: Permit | Deny.
        :param Sequence[builtins.str] route_targets: Route Target List.The expected formats are ASN(plain):NN >> example 4294967294:50, ASN.ASN:NN >> example 65533.65333:40, IP-address:NN >> example 10.10.10.10:65535. The possible values of ASN,NN are in range of 0-65535, ASN(plain) is in range of 0-4294967295.
        :param builtins.float sequence_number: Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "route_targets", route_targets)
        pulumi.set(__self__, "sequence_number", sequence_number)

    @property
    @pulumi.getter
    def action(self) -> builtins.str:
        """
        Action to be taken on the configuration. Example: Permit | Deny.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="routeTargets")
    def route_targets(self) -> Sequence[builtins.str]:
        """
        Route Target List.The expected formats are ASN(plain):NN >> example 4294967294:50, ASN.ASN:NN >> example 65533.65333:40, IP-address:NN >> example 10.10.10.10:65535. The possible values of ASN,NN are in range of 0-65535, ASN(plain) is in range of 0-4294967295.
        """
        return pulumi.get(self, "route_targets")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> builtins.float:
        """
        Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        """
        return pulumi.get(self, "sequence_number")


@pulumi.output_type
class IpGroupPropertiesResponse(dict):
    """
    IP Group properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddressType":
            suggest = "ip_address_type"
        elif key == "ipPrefixes":
            suggest = "ip_prefixes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpGroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpGroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpGroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address_type: Optional[builtins.str] = None,
                 ip_prefixes: Optional[Sequence[builtins.str]] = None,
                 name: Optional[builtins.str] = None):
        """
        IP Group properties.
        :param builtins.str ip_address_type: IP Address type.
        :param Sequence[builtins.str] ip_prefixes: List of IP Prefixes.
        :param builtins.str name: IP Group name.
        """
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)
        if ip_prefixes is not None:
            pulumi.set(__self__, "ip_prefixes", ip_prefixes)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[builtins.str]:
        """
        IP Address type.
        """
        return pulumi.get(self, "ip_address_type")

    @property
    @pulumi.getter(name="ipPrefixes")
    def ip_prefixes(self) -> Optional[Sequence[builtins.str]]:
        """
        List of IP Prefixes.
        """
        return pulumi.get(self, "ip_prefixes")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        IP Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class IpMatchConditionResponse(dict):
    """
    Defines the condition that can be filtered using the selected IPs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipGroupNames":
            suggest = "ip_group_names"
        elif key == "ipPrefixValues":
            suggest = "ip_prefix_values"
        elif key == "prefixType":
            suggest = "prefix_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpMatchConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpMatchConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpMatchConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_group_names: Optional[Sequence[builtins.str]] = None,
                 ip_prefix_values: Optional[Sequence[builtins.str]] = None,
                 prefix_type: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        Defines the condition that can be filtered using the selected IPs.
        :param Sequence[builtins.str] ip_group_names: The List of IP Group Names that need to be matched.
        :param Sequence[builtins.str] ip_prefix_values: The list of IP Prefixes that need to be matched.
        :param builtins.str prefix_type: IP Prefix Type that needs to be matched.
        :param builtins.str type: IP Address type that needs to be matched.
        """
        if ip_group_names is not None:
            pulumi.set(__self__, "ip_group_names", ip_group_names)
        if ip_prefix_values is not None:
            pulumi.set(__self__, "ip_prefix_values", ip_prefix_values)
        if prefix_type is not None:
            pulumi.set(__self__, "prefix_type", prefix_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="ipGroupNames")
    def ip_group_names(self) -> Optional[Sequence[builtins.str]]:
        """
        The List of IP Group Names that need to be matched.
        """
        return pulumi.get(self, "ip_group_names")

    @property
    @pulumi.getter(name="ipPrefixValues")
    def ip_prefix_values(self) -> Optional[Sequence[builtins.str]]:
        """
        The list of IP Prefixes that need to be matched.
        """
        return pulumi.get(self, "ip_prefix_values")

    @property
    @pulumi.getter(name="prefixType")
    def prefix_type(self) -> Optional[builtins.str]:
        """
        IP Prefix Type that needs to be matched.
        """
        return pulumi.get(self, "prefix_type")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        IP Address type that needs to be matched.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class IpPrefixRuleResponse(dict):
    """
    IP Prefix Rule properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkPrefix":
            suggest = "network_prefix"
        elif key == "sequenceNumber":
            suggest = "sequence_number"
        elif key == "subnetMaskLength":
            suggest = "subnet_mask_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpPrefixRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpPrefixRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpPrefixRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: builtins.str,
                 network_prefix: builtins.str,
                 sequence_number: builtins.float,
                 condition: Optional[builtins.str] = None,
                 subnet_mask_length: Optional[builtins.str] = None):
        """
        IP Prefix Rule properties.
        :param builtins.str action: Action to be taken on the configuration. Example: Permit | Deny.
        :param builtins.str network_prefix: Network Prefix specifying IPv4/IPv6 packets to be permitted or denied. Example: 1.1.1.0/24 | 3FFE:FFFF:0:CD30::/126 
        :param builtins.float sequence_number: Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        :param builtins.str condition: Specify prefix-list bounds.
        :param builtins.str subnet_mask_length: SubnetMaskLength gives the minimum NetworkPrefix length to be matched. Possible values for IPv4 are 1 - 32 . Possible values of IPv6 are 1 - 128.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "network_prefix", network_prefix)
        pulumi.set(__self__, "sequence_number", sequence_number)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if subnet_mask_length is not None:
            pulumi.set(__self__, "subnet_mask_length", subnet_mask_length)

    @property
    @pulumi.getter
    def action(self) -> builtins.str:
        """
        Action to be taken on the configuration. Example: Permit | Deny.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="networkPrefix")
    def network_prefix(self) -> builtins.str:
        """
        Network Prefix specifying IPv4/IPv6 packets to be permitted or denied. Example: 1.1.1.0/24 | 3FFE:FFFF:0:CD30::/126 
        """
        return pulumi.get(self, "network_prefix")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> builtins.float:
        """
        Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        """
        return pulumi.get(self, "sequence_number")

    @property
    @pulumi.getter
    def condition(self) -> Optional[builtins.str]:
        """
        Specify prefix-list bounds.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="subnetMaskLength")
    def subnet_mask_length(self) -> Optional[builtins.str]:
        """
        SubnetMaskLength gives the minimum NetworkPrefix length to be matched. Possible values for IPv4 are 1 - 32 . Possible values of IPv6 are 1 - 128.
        """
        return pulumi.get(self, "subnet_mask_length")


@pulumi.output_type
class IsolationDomainPropertiesResponse(dict):
    """
    Isolation Domain Properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "neighborGroupIds":
            suggest = "neighbor_group_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IsolationDomainPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IsolationDomainPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IsolationDomainPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encapsulation: Optional[builtins.str] = None,
                 neighbor_group_ids: Optional[Sequence[builtins.str]] = None):
        """
        Isolation Domain Properties.
        :param builtins.str encapsulation: Type of encapsulation.
        :param Sequence[builtins.str] neighbor_group_ids: List of Neighbor Group IDs.
        """
        if encapsulation is not None:
            pulumi.set(__self__, "encapsulation", encapsulation)
        if neighbor_group_ids is not None:
            pulumi.set(__self__, "neighbor_group_ids", neighbor_group_ids)

    @property
    @pulumi.getter
    def encapsulation(self) -> Optional[builtins.str]:
        """
        Type of encapsulation.
        """
        return pulumi.get(self, "encapsulation")

    @property
    @pulumi.getter(name="neighborGroupIds")
    def neighbor_group_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        List of Neighbor Group IDs.
        """
        return pulumi.get(self, "neighbor_group_ids")


@pulumi.output_type
class L3ExportRoutePolicyResponse(dict):
    """
    Array of ARM Resource ID of the RoutePolicies.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportIpv4RoutePolicyId":
            suggest = "export_ipv4_route_policy_id"
        elif key == "exportIpv6RoutePolicyId":
            suggest = "export_ipv6_route_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in L3ExportRoutePolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        L3ExportRoutePolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        L3ExportRoutePolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_ipv4_route_policy_id: Optional[builtins.str] = None,
                 export_ipv6_route_policy_id: Optional[builtins.str] = None):
        """
        Array of ARM Resource ID of the RoutePolicies.
        :param builtins.str export_ipv4_route_policy_id: ARM Resource ID of the RoutePolicy.
        :param builtins.str export_ipv6_route_policy_id: ARM Resource ID of the RoutePolicy.
        """
        if export_ipv4_route_policy_id is not None:
            pulumi.set(__self__, "export_ipv4_route_policy_id", export_ipv4_route_policy_id)
        if export_ipv6_route_policy_id is not None:
            pulumi.set(__self__, "export_ipv6_route_policy_id", export_ipv6_route_policy_id)

    @property
    @pulumi.getter(name="exportIpv4RoutePolicyId")
    def export_ipv4_route_policy_id(self) -> Optional[builtins.str]:
        """
        ARM Resource ID of the RoutePolicy.
        """
        return pulumi.get(self, "export_ipv4_route_policy_id")

    @property
    @pulumi.getter(name="exportIpv6RoutePolicyId")
    def export_ipv6_route_policy_id(self) -> Optional[builtins.str]:
        """
        ARM Resource ID of the RoutePolicy.
        """
        return pulumi.get(self, "export_ipv6_route_policy_id")


@pulumi.output_type
class L3OptionBPropertiesResponse(dict):
    """
    Option B configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportRouteTargets":
            suggest = "export_route_targets"
        elif key == "importRouteTargets":
            suggest = "import_route_targets"
        elif key == "routeTargets":
            suggest = "route_targets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in L3OptionBPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        L3OptionBPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        L3OptionBPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_route_targets: Optional[Sequence[builtins.str]] = None,
                 import_route_targets: Optional[Sequence[builtins.str]] = None,
                 route_targets: Optional['outputs.RouteTargetInformationResponse'] = None):
        """
        Option B configuration.
        :param Sequence[builtins.str] export_route_targets: RouteTargets to be applied. This is used for the backward compatibility.
        :param Sequence[builtins.str] import_route_targets: RouteTargets to be applied. This is used for the backward compatibility.
        :param 'RouteTargetInformationResponse' route_targets: RouteTargets to be applied.
        """
        if export_route_targets is not None:
            pulumi.set(__self__, "export_route_targets", export_route_targets)
        if import_route_targets is not None:
            pulumi.set(__self__, "import_route_targets", import_route_targets)
        if route_targets is not None:
            pulumi.set(__self__, "route_targets", route_targets)

    @property
    @pulumi.getter(name="exportRouteTargets")
    def export_route_targets(self) -> Optional[Sequence[builtins.str]]:
        """
        RouteTargets to be applied. This is used for the backward compatibility.
        """
        return pulumi.get(self, "export_route_targets")

    @property
    @pulumi.getter(name="importRouteTargets")
    def import_route_targets(self) -> Optional[Sequence[builtins.str]]:
        """
        RouteTargets to be applied. This is used for the backward compatibility.
        """
        return pulumi.get(self, "import_route_targets")

    @property
    @pulumi.getter(name="routeTargets")
    def route_targets(self) -> Optional['outputs.RouteTargetInformationResponse']:
        """
        RouteTargets to be applied.
        """
        return pulumi.get(self, "route_targets")


@pulumi.output_type
class Layer2ConfigurationResponse(dict):
    """
    Common properties for Layer2 Configuration.
    """
    def __init__(__self__, *,
                 interfaces: Optional[Sequence[builtins.str]] = None,
                 mtu: Optional[builtins.int] = None):
        """
        Common properties for Layer2 Configuration.
        :param Sequence[builtins.str] interfaces: List of network device interfaces resource IDs.
        :param builtins.int mtu: MTU of the packets between PE & CE.
        """
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)
        if mtu is None:
            mtu = 1500
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)

    @property
    @pulumi.getter
    def interfaces(self) -> Optional[Sequence[builtins.str]]:
        """
        List of network device interfaces resource IDs.
        """
        return pulumi.get(self, "interfaces")

    @property
    @pulumi.getter
    def mtu(self) -> Optional[builtins.int]:
        """
        MTU of the packets between PE & CE.
        """
        return pulumi.get(self, "mtu")


@pulumi.output_type
class ManagedResourceGroupConfigurationResponse(dict):
    """
    Managed Resource Group configuration properties.
    """
    def __init__(__self__, *,
                 location: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None):
        """
        Managed Resource Group configuration properties.
        :param builtins.str location: Managed resource group location.
        :param builtins.str name: The NFC service will be hosted in a Managed resource group.
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def location(self) -> Optional[builtins.str]:
        """
        Managed resource group location.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The NFC service will be hosted in a Managed resource group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ManagementNetworkConfigurationPropertiesResponse(dict):
    """
    Configuration to be used to setup the management network.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infrastructureVpnConfiguration":
            suggest = "infrastructure_vpn_configuration"
        elif key == "workloadVpnConfiguration":
            suggest = "workload_vpn_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementNetworkConfigurationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementNetworkConfigurationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementNetworkConfigurationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 infrastructure_vpn_configuration: 'outputs.VpnConfigurationPropertiesResponse',
                 workload_vpn_configuration: 'outputs.VpnConfigurationPropertiesResponse'):
        """
        Configuration to be used to setup the management network.
        :param 'VpnConfigurationPropertiesResponse' infrastructure_vpn_configuration: VPN Configuration properties.
        :param 'VpnConfigurationPropertiesResponse' workload_vpn_configuration: VPN Configuration properties.
        """
        pulumi.set(__self__, "infrastructure_vpn_configuration", infrastructure_vpn_configuration)
        pulumi.set(__self__, "workload_vpn_configuration", workload_vpn_configuration)

    @property
    @pulumi.getter(name="infrastructureVpnConfiguration")
    def infrastructure_vpn_configuration(self) -> 'outputs.VpnConfigurationPropertiesResponse':
        """
        VPN Configuration properties.
        """
        return pulumi.get(self, "infrastructure_vpn_configuration")

    @property
    @pulumi.getter(name="workloadVpnConfiguration")
    def workload_vpn_configuration(self) -> 'outputs.VpnConfigurationPropertiesResponse':
        """
        VPN Configuration properties.
        """
        return pulumi.get(self, "workload_vpn_configuration")


@pulumi.output_type
class NeighborAddressResponse(dict):
    """
    Neighbor Address properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationState":
            suggest = "configuration_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NeighborAddressResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NeighborAddressResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NeighborAddressResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configuration_state: builtins.str,
                 address: Optional[builtins.str] = None):
        """
        Neighbor Address properties.
        :param builtins.str configuration_state: Configuration state of the resource.
        :param builtins.str address: IP Address.
        """
        pulumi.set(__self__, "configuration_state", configuration_state)
        if address is not None:
            pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter(name="configurationState")
    def configuration_state(self) -> builtins.str:
        """
        Configuration state of the resource.
        """
        return pulumi.get(self, "configuration_state")

    @property
    @pulumi.getter
    def address(self) -> Optional[builtins.str]:
        """
        IP Address.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class NeighborGroupDestinationResponse(dict):
    """
    An array of destination IPv4 Addresses or IPv6 Addresses.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4Addresses":
            suggest = "ipv4_addresses"
        elif key == "ipv6Addresses":
            suggest = "ipv6_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NeighborGroupDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NeighborGroupDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NeighborGroupDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4_addresses: Optional[Sequence[builtins.str]] = None,
                 ipv6_addresses: Optional[Sequence[builtins.str]] = None):
        """
        An array of destination IPv4 Addresses or IPv6 Addresses.
        :param Sequence[builtins.str] ipv4_addresses: Array of IPv4 Addresses.
        :param Sequence[builtins.str] ipv6_addresses: Array of IPv6 Addresses.
        """
        if ipv4_addresses is not None:
            pulumi.set(__self__, "ipv4_addresses", ipv4_addresses)
        if ipv6_addresses is not None:
            pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)

    @property
    @pulumi.getter(name="ipv4Addresses")
    def ipv4_addresses(self) -> Optional[Sequence[builtins.str]]:
        """
        Array of IPv4 Addresses.
        """
        return pulumi.get(self, "ipv4_addresses")

    @property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[Sequence[builtins.str]]:
        """
        Array of IPv6 Addresses.
        """
        return pulumi.get(self, "ipv6_addresses")


@pulumi.output_type
class NetworkTapPropertiesResponseDestinations(dict):
    """
    Destination.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationId":
            suggest = "destination_id"
        elif key == "destinationType":
            suggest = "destination_type"
        elif key == "destinationTapRuleId":
            suggest = "destination_tap_rule_id"
        elif key == "isolationDomainProperties":
            suggest = "isolation_domain_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkTapPropertiesResponseDestinations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkTapPropertiesResponseDestinations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkTapPropertiesResponseDestinations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_id: builtins.str,
                 destination_type: builtins.str,
                 name: builtins.str,
                 destination_tap_rule_id: Optional[builtins.str] = None,
                 isolation_domain_properties: Optional['outputs.IsolationDomainPropertiesResponse'] = None):
        """
        Destination.
        :param builtins.str destination_id: The destination Id. ARM Resource ID of either NNI or Internal Networks.
        :param builtins.str destination_type: Type of destination. Input can be IsolationDomain or Direct.
        :param builtins.str name: Destination name.
        :param builtins.str destination_tap_rule_id: ARM Resource ID of destination Tap Rule that contains match configurations.
        :param 'IsolationDomainPropertiesResponse' isolation_domain_properties: Isolation Domain Properties.
        """
        pulumi.set(__self__, "destination_id", destination_id)
        pulumi.set(__self__, "destination_type", destination_type)
        pulumi.set(__self__, "name", name)
        if destination_tap_rule_id is not None:
            pulumi.set(__self__, "destination_tap_rule_id", destination_tap_rule_id)
        if isolation_domain_properties is not None:
            pulumi.set(__self__, "isolation_domain_properties", isolation_domain_properties)

    @property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> builtins.str:
        """
        The destination Id. ARM Resource ID of either NNI or Internal Networks.
        """
        return pulumi.get(self, "destination_id")

    @property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> builtins.str:
        """
        Type of destination. Input can be IsolationDomain or Direct.
        """
        return pulumi.get(self, "destination_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Destination name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="destinationTapRuleId")
    def destination_tap_rule_id(self) -> Optional[builtins.str]:
        """
        ARM Resource ID of destination Tap Rule that contains match configurations.
        """
        return pulumi.get(self, "destination_tap_rule_id")

    @property
    @pulumi.getter(name="isolationDomainProperties")
    def isolation_domain_properties(self) -> Optional['outputs.IsolationDomainPropertiesResponse']:
        """
        Isolation Domain Properties.
        """
        return pulumi.get(self, "isolation_domain_properties")


@pulumi.output_type
class NetworkTapRuleActionResponse(dict):
    """
    Action that need to performed.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationId":
            suggest = "destination_id"
        elif key == "isTimestampEnabled":
            suggest = "is_timestamp_enabled"
        elif key == "matchConfigurationName":
            suggest = "match_configuration_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkTapRuleActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkTapRuleActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkTapRuleActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_id: Optional[builtins.str] = None,
                 is_timestamp_enabled: Optional[builtins.str] = None,
                 match_configuration_name: Optional[builtins.str] = None,
                 truncate: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        Action that need to performed.
        :param builtins.str destination_id: Destination Id. The ARM resource Id may be either Network To Network Interconnect or NeighborGroup.
        :param builtins.str is_timestamp_enabled: The parameter to enable or disable the timestamp.
        :param builtins.str match_configuration_name: The name of the match configuration. This is used when Goto type is provided. If Goto type is selected and no match configuration name is provided. It goes to next configuration.
        :param builtins.str truncate: Truncate. 0 indicates do not truncate.
        :param builtins.str type: Type of actions that can be performed.
        """
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if is_timestamp_enabled is not None:
            pulumi.set(__self__, "is_timestamp_enabled", is_timestamp_enabled)
        if match_configuration_name is not None:
            pulumi.set(__self__, "match_configuration_name", match_configuration_name)
        if truncate is not None:
            pulumi.set(__self__, "truncate", truncate)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[builtins.str]:
        """
        Destination Id. The ARM resource Id may be either Network To Network Interconnect or NeighborGroup.
        """
        return pulumi.get(self, "destination_id")

    @property
    @pulumi.getter(name="isTimestampEnabled")
    def is_timestamp_enabled(self) -> Optional[builtins.str]:
        """
        The parameter to enable or disable the timestamp.
        """
        return pulumi.get(self, "is_timestamp_enabled")

    @property
    @pulumi.getter(name="matchConfigurationName")
    def match_configuration_name(self) -> Optional[builtins.str]:
        """
        The name of the match configuration. This is used when Goto type is provided. If Goto type is selected and no match configuration name is provided. It goes to next configuration.
        """
        return pulumi.get(self, "match_configuration_name")

    @property
    @pulumi.getter
    def truncate(self) -> Optional[builtins.str]:
        """
        Truncate. 0 indicates do not truncate.
        """
        return pulumi.get(self, "truncate")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of actions that can be performed.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NetworkTapRuleMatchConditionResponse(dict):
    """
    Defines the match condition that is supported to filter the traffic.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encapsulationType":
            suggest = "encapsulation_type"
        elif key == "ipCondition":
            suggest = "ip_condition"
        elif key == "portCondition":
            suggest = "port_condition"
        elif key == "protocolTypes":
            suggest = "protocol_types"
        elif key == "vlanMatchCondition":
            suggest = "vlan_match_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkTapRuleMatchConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkTapRuleMatchConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkTapRuleMatchConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encapsulation_type: Optional[builtins.str] = None,
                 ip_condition: Optional['outputs.IpMatchConditionResponse'] = None,
                 port_condition: Optional['outputs.PortConditionResponse'] = None,
                 protocol_types: Optional[Sequence[builtins.str]] = None,
                 vlan_match_condition: Optional['outputs.VlanMatchConditionResponse'] = None):
        """
        Defines the match condition that is supported to filter the traffic.
        :param builtins.str encapsulation_type: Encapsulation Type that needs to be matched.
        :param 'IpMatchConditionResponse' ip_condition: IP condition that needs to be matched.
        :param 'PortConditionResponse' port_condition: Defines the port condition that needs to be matched.
        :param Sequence[builtins.str] protocol_types: List of the protocols that need to be matched.
        :param 'VlanMatchConditionResponse' vlan_match_condition: Vlan match condition that needs to be matched.
        """
        if encapsulation_type is None:
            encapsulation_type = 'None'
        if encapsulation_type is not None:
            pulumi.set(__self__, "encapsulation_type", encapsulation_type)
        if ip_condition is not None:
            pulumi.set(__self__, "ip_condition", ip_condition)
        if port_condition is not None:
            pulumi.set(__self__, "port_condition", port_condition)
        if protocol_types is not None:
            pulumi.set(__self__, "protocol_types", protocol_types)
        if vlan_match_condition is not None:
            pulumi.set(__self__, "vlan_match_condition", vlan_match_condition)

    @property
    @pulumi.getter(name="encapsulationType")
    def encapsulation_type(self) -> Optional[builtins.str]:
        """
        Encapsulation Type that needs to be matched.
        """
        return pulumi.get(self, "encapsulation_type")

    @property
    @pulumi.getter(name="ipCondition")
    def ip_condition(self) -> Optional['outputs.IpMatchConditionResponse']:
        """
        IP condition that needs to be matched.
        """
        return pulumi.get(self, "ip_condition")

    @property
    @pulumi.getter(name="portCondition")
    def port_condition(self) -> Optional['outputs.PortConditionResponse']:
        """
        Defines the port condition that needs to be matched.
        """
        return pulumi.get(self, "port_condition")

    @property
    @pulumi.getter(name="protocolTypes")
    def protocol_types(self) -> Optional[Sequence[builtins.str]]:
        """
        List of the protocols that need to be matched.
        """
        return pulumi.get(self, "protocol_types")

    @property
    @pulumi.getter(name="vlanMatchCondition")
    def vlan_match_condition(self) -> Optional['outputs.VlanMatchConditionResponse']:
        """
        Vlan match condition that needs to be matched.
        """
        return pulumi.get(self, "vlan_match_condition")


@pulumi.output_type
class NetworkTapRuleMatchConfigurationResponse(dict):
    """
    Defines the match configuration that are supported to filter the traffic.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddressType":
            suggest = "ip_address_type"
        elif key == "matchConditions":
            suggest = "match_conditions"
        elif key == "matchConfigurationName":
            suggest = "match_configuration_name"
        elif key == "sequenceNumber":
            suggest = "sequence_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkTapRuleMatchConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkTapRuleMatchConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkTapRuleMatchConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Optional[Sequence['outputs.NetworkTapRuleActionResponse']] = None,
                 ip_address_type: Optional[builtins.str] = None,
                 match_conditions: Optional[Sequence['outputs.NetworkTapRuleMatchConditionResponse']] = None,
                 match_configuration_name: Optional[builtins.str] = None,
                 sequence_number: Optional[builtins.float] = None):
        """
        Defines the match configuration that are supported to filter the traffic.
        :param Sequence['NetworkTapRuleActionResponse'] actions: List of actions that need to be performed for the matched conditions.
        :param builtins.str ip_address_type: Type of IP Address. IPv4 or IPv6
        :param Sequence['NetworkTapRuleMatchConditionResponse'] match_conditions: List of the match conditions.
        :param builtins.str match_configuration_name: The name of the match configuration.
        :param builtins.float sequence_number: Sequence Number of the match configuration..
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)
        if match_conditions is not None:
            pulumi.set(__self__, "match_conditions", match_conditions)
        if match_configuration_name is not None:
            pulumi.set(__self__, "match_configuration_name", match_configuration_name)
        if sequence_number is not None:
            pulumi.set(__self__, "sequence_number", sequence_number)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.NetworkTapRuleActionResponse']]:
        """
        List of actions that need to be performed for the matched conditions.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[builtins.str]:
        """
        Type of IP Address. IPv4 or IPv6
        """
        return pulumi.get(self, "ip_address_type")

    @property
    @pulumi.getter(name="matchConditions")
    def match_conditions(self) -> Optional[Sequence['outputs.NetworkTapRuleMatchConditionResponse']]:
        """
        List of the match conditions.
        """
        return pulumi.get(self, "match_conditions")

    @property
    @pulumi.getter(name="matchConfigurationName")
    def match_configuration_name(self) -> Optional[builtins.str]:
        """
        The name of the match configuration.
        """
        return pulumi.get(self, "match_configuration_name")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> Optional[builtins.float]:
        """
        Sequence Number of the match configuration..
        """
        return pulumi.get(self, "sequence_number")


@pulumi.output_type
class NetworkToNetworkInterconnectPropertiesResponseOptionBLayer3Configuration(dict):
    """
    Common properties for Layer3Configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fabricASN":
            suggest = "fabric_asn"
        elif key == "peerASN":
            suggest = "peer_asn"
        elif key == "vlanId":
            suggest = "vlan_id"
        elif key == "primaryIpv4Prefix":
            suggest = "primary_ipv4_prefix"
        elif key == "primaryIpv6Prefix":
            suggest = "primary_ipv6_prefix"
        elif key == "secondaryIpv4Prefix":
            suggest = "secondary_ipv4_prefix"
        elif key == "secondaryIpv6Prefix":
            suggest = "secondary_ipv6_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkToNetworkInterconnectPropertiesResponseOptionBLayer3Configuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkToNetworkInterconnectPropertiesResponseOptionBLayer3Configuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkToNetworkInterconnectPropertiesResponseOptionBLayer3Configuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fabric_asn: builtins.float,
                 peer_asn: builtins.float,
                 vlan_id: builtins.int,
                 primary_ipv4_prefix: Optional[builtins.str] = None,
                 primary_ipv6_prefix: Optional[builtins.str] = None,
                 secondary_ipv4_prefix: Optional[builtins.str] = None,
                 secondary_ipv6_prefix: Optional[builtins.str] = None):
        """
        Common properties for Layer3Configuration.
        :param builtins.float fabric_asn: ASN of CE devices for CE/PE connectivity.
        :param builtins.float peer_asn: ASN of PE devices for CE/PE connectivity.Example : 28
        :param builtins.int vlan_id: VLAN for CE/PE Layer 3 connectivity.Example : 501
        :param builtins.str primary_ipv4_prefix: IPv4 Address Prefix.
        :param builtins.str primary_ipv6_prefix: IPv6 Address Prefix.
        :param builtins.str secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
        :param builtins.str secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
        """
        pulumi.set(__self__, "fabric_asn", fabric_asn)
        pulumi.set(__self__, "peer_asn", peer_asn)
        pulumi.set(__self__, "vlan_id", vlan_id)
        if primary_ipv4_prefix is not None:
            pulumi.set(__self__, "primary_ipv4_prefix", primary_ipv4_prefix)
        if primary_ipv6_prefix is not None:
            pulumi.set(__self__, "primary_ipv6_prefix", primary_ipv6_prefix)
        if secondary_ipv4_prefix is not None:
            pulumi.set(__self__, "secondary_ipv4_prefix", secondary_ipv4_prefix)
        if secondary_ipv6_prefix is not None:
            pulumi.set(__self__, "secondary_ipv6_prefix", secondary_ipv6_prefix)

    @property
    @pulumi.getter(name="fabricASN")
    def fabric_asn(self) -> builtins.float:
        """
        ASN of CE devices for CE/PE connectivity.
        """
        return pulumi.get(self, "fabric_asn")

    @property
    @pulumi.getter(name="peerASN")
    def peer_asn(self) -> builtins.float:
        """
        ASN of PE devices for CE/PE connectivity.Example : 28
        """
        return pulumi.get(self, "peer_asn")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> builtins.int:
        """
        VLAN for CE/PE Layer 3 connectivity.Example : 501
        """
        return pulumi.get(self, "vlan_id")

    @property
    @pulumi.getter(name="primaryIpv4Prefix")
    def primary_ipv4_prefix(self) -> Optional[builtins.str]:
        """
        IPv4 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv4_prefix")

    @property
    @pulumi.getter(name="primaryIpv6Prefix")
    def primary_ipv6_prefix(self) -> Optional[builtins.str]:
        """
        IPv6 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv6_prefix")

    @property
    @pulumi.getter(name="secondaryIpv4Prefix")
    def secondary_ipv4_prefix(self) -> Optional[builtins.str]:
        """
        Secondary IPv4 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv4_prefix")

    @property
    @pulumi.getter(name="secondaryIpv6Prefix")
    def secondary_ipv6_prefix(self) -> Optional[builtins.str]:
        """
        Secondary IPv6 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv6_prefix")


@pulumi.output_type
class NpbStaticRouteConfigurationResponse(dict):
    """
    NPB Static Route Configuration properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bfdConfiguration":
            suggest = "bfd_configuration"
        elif key == "ipv4Routes":
            suggest = "ipv4_routes"
        elif key == "ipv6Routes":
            suggest = "ipv6_routes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NpbStaticRouteConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NpbStaticRouteConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NpbStaticRouteConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bfd_configuration: Optional['outputs.BfdConfigurationResponse'] = None,
                 ipv4_routes: Optional[Sequence['outputs.StaticRoutePropertiesResponse']] = None,
                 ipv6_routes: Optional[Sequence['outputs.StaticRoutePropertiesResponse']] = None):
        """
        NPB Static Route Configuration properties.
        :param 'BfdConfigurationResponse' bfd_configuration: BFD Configuration properties.
        :param Sequence['StaticRoutePropertiesResponse'] ipv4_routes: List of IPv4 Routes.
        :param Sequence['StaticRoutePropertiesResponse'] ipv6_routes: List of IPv6 Routes.
        """
        if bfd_configuration is not None:
            pulumi.set(__self__, "bfd_configuration", bfd_configuration)
        if ipv4_routes is not None:
            pulumi.set(__self__, "ipv4_routes", ipv4_routes)
        if ipv6_routes is not None:
            pulumi.set(__self__, "ipv6_routes", ipv6_routes)

    @property
    @pulumi.getter(name="bfdConfiguration")
    def bfd_configuration(self) -> Optional['outputs.BfdConfigurationResponse']:
        """
        BFD Configuration properties.
        """
        return pulumi.get(self, "bfd_configuration")

    @property
    @pulumi.getter(name="ipv4Routes")
    def ipv4_routes(self) -> Optional[Sequence['outputs.StaticRoutePropertiesResponse']]:
        """
        List of IPv4 Routes.
        """
        return pulumi.get(self, "ipv4_routes")

    @property
    @pulumi.getter(name="ipv6Routes")
    def ipv6_routes(self) -> Optional[Sequence['outputs.StaticRoutePropertiesResponse']]:
        """
        List of IPv6 Routes.
        """
        return pulumi.get(self, "ipv6_routes")


@pulumi.output_type
class PortConditionResponse(dict):
    """
    Port condition that needs to be matched.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layer4Protocol":
            suggest = "layer4_protocol"
        elif key == "portGroupNames":
            suggest = "port_group_names"
        elif key == "portType":
            suggest = "port_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layer4_protocol: builtins.str,
                 port_group_names: Optional[Sequence[builtins.str]] = None,
                 port_type: Optional[builtins.str] = None,
                 ports: Optional[Sequence[builtins.str]] = None):
        """
        Port condition that needs to be matched.
        :param builtins.str layer4_protocol: Layer4 protocol type that needs to be matched.
        :param Sequence[builtins.str] port_group_names: List of the port Group Names that need to be matched.
        :param builtins.str port_type: Port type that needs to be matched.
        :param Sequence[builtins.str] ports: List of the Ports that need to be matched.
        """
        pulumi.set(__self__, "layer4_protocol", layer4_protocol)
        if port_group_names is not None:
            pulumi.set(__self__, "port_group_names", port_group_names)
        if port_type is not None:
            pulumi.set(__self__, "port_type", port_type)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter(name="layer4Protocol")
    def layer4_protocol(self) -> builtins.str:
        """
        Layer4 protocol type that needs to be matched.
        """
        return pulumi.get(self, "layer4_protocol")

    @property
    @pulumi.getter(name="portGroupNames")
    def port_group_names(self) -> Optional[Sequence[builtins.str]]:
        """
        List of the port Group Names that need to be matched.
        """
        return pulumi.get(self, "port_group_names")

    @property
    @pulumi.getter(name="portType")
    def port_type(self) -> Optional[builtins.str]:
        """
        Port type that needs to be matched.
        """
        return pulumi.get(self, "port_type")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[builtins.str]]:
        """
        List of the Ports that need to be matched.
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class PortGroupPropertiesResponse(dict):
    """
    Port Group properties.
    """
    def __init__(__self__, *,
                 name: Optional[builtins.str] = None,
                 ports: Optional[Sequence[builtins.str]] = None):
        """
        Port Group properties.
        :param builtins.str name: The name of the port group.
        :param Sequence[builtins.str] ports: List of the ports that need to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the port group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[builtins.str]]:
        """
        List of the ports that need to be matched.
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class RoutePolicyStatementPropertiesResponse(dict):
    """
    Route Policy Statement properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sequenceNumber":
            suggest = "sequence_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoutePolicyStatementPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoutePolicyStatementPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoutePolicyStatementPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: 'outputs.StatementActionPropertiesResponse',
                 condition: 'outputs.StatementConditionPropertiesResponse',
                 sequence_number: builtins.float,
                 annotation: Optional[builtins.str] = None):
        """
        Route Policy Statement properties.
        :param 'StatementActionPropertiesResponse' action: Route policy action properties.
        :param 'StatementConditionPropertiesResponse' condition: Route policy condition properties.
        :param builtins.float sequence_number: Sequence to insert to/delete from existing route.
        :param builtins.str annotation: Switch configuration description.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "sequence_number", sequence_number)
        if annotation is not None:
            pulumi.set(__self__, "annotation", annotation)

    @property
    @pulumi.getter
    def action(self) -> 'outputs.StatementActionPropertiesResponse':
        """
        Route policy action properties.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.StatementConditionPropertiesResponse':
        """
        Route policy condition properties.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> builtins.float:
        """
        Sequence to insert to/delete from existing route.
        """
        return pulumi.get(self, "sequence_number")

    @property
    @pulumi.getter
    def annotation(self) -> Optional[builtins.str]:
        """
        Switch configuration description.
        """
        return pulumi.get(self, "annotation")


@pulumi.output_type
class RouteTargetInformationResponse(dict):
    """
    Route Target Configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportIpv4RouteTargets":
            suggest = "export_ipv4_route_targets"
        elif key == "exportIpv6RouteTargets":
            suggest = "export_ipv6_route_targets"
        elif key == "importIpv4RouteTargets":
            suggest = "import_ipv4_route_targets"
        elif key == "importIpv6RouteTargets":
            suggest = "import_ipv6_route_targets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteTargetInformationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteTargetInformationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteTargetInformationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_ipv4_route_targets: Optional[Sequence[builtins.str]] = None,
                 export_ipv6_route_targets: Optional[Sequence[builtins.str]] = None,
                 import_ipv4_route_targets: Optional[Sequence[builtins.str]] = None,
                 import_ipv6_route_targets: Optional[Sequence[builtins.str]] = None):
        """
        Route Target Configuration.
        :param Sequence[builtins.str] export_ipv4_route_targets: Route Targets to be applied for outgoing routes into CE.
        :param Sequence[builtins.str] export_ipv6_route_targets: Route Targets to be applied for outgoing routes from CE.
        :param Sequence[builtins.str] import_ipv4_route_targets: Route Targets to be applied for incoming routes into CE.
        :param Sequence[builtins.str] import_ipv6_route_targets: Route Targets to be applied for incoming routes from CE.
        """
        if export_ipv4_route_targets is not None:
            pulumi.set(__self__, "export_ipv4_route_targets", export_ipv4_route_targets)
        if export_ipv6_route_targets is not None:
            pulumi.set(__self__, "export_ipv6_route_targets", export_ipv6_route_targets)
        if import_ipv4_route_targets is not None:
            pulumi.set(__self__, "import_ipv4_route_targets", import_ipv4_route_targets)
        if import_ipv6_route_targets is not None:
            pulumi.set(__self__, "import_ipv6_route_targets", import_ipv6_route_targets)

    @property
    @pulumi.getter(name="exportIpv4RouteTargets")
    def export_ipv4_route_targets(self) -> Optional[Sequence[builtins.str]]:
        """
        Route Targets to be applied for outgoing routes into CE.
        """
        return pulumi.get(self, "export_ipv4_route_targets")

    @property
    @pulumi.getter(name="exportIpv6RouteTargets")
    def export_ipv6_route_targets(self) -> Optional[Sequence[builtins.str]]:
        """
        Route Targets to be applied for outgoing routes from CE.
        """
        return pulumi.get(self, "export_ipv6_route_targets")

    @property
    @pulumi.getter(name="importIpv4RouteTargets")
    def import_ipv4_route_targets(self) -> Optional[Sequence[builtins.str]]:
        """
        Route Targets to be applied for incoming routes into CE.
        """
        return pulumi.get(self, "import_ipv4_route_targets")

    @property
    @pulumi.getter(name="importIpv6RouteTargets")
    def import_ipv6_route_targets(self) -> Optional[Sequence[builtins.str]]:
        """
        Route Targets to be applied for incoming routes from CE.
        """
        return pulumi.get(self, "import_ipv6_route_targets")


@pulumi.output_type
class RulePropertiesResponse(dict):
    """
    Rules for the InternetGateways
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressList":
            suggest = "address_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: builtins.str,
                 address_list: Sequence[builtins.str]):
        """
        Rules for the InternetGateways
        :param builtins.str action: Specify action.
        :param Sequence[builtins.str] address_list: List of Addresses to be allowed or denied.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "address_list", address_list)

    @property
    @pulumi.getter
    def action(self) -> builtins.str:
        """
        Specify action.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="addressList")
    def address_list(self) -> Sequence[builtins.str]:
        """
        List of Addresses to be allowed or denied.
        """
        return pulumi.get(self, "address_list")


@pulumi.output_type
class StatementActionPropertiesResponse(dict):
    """
    Route policy action properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "ipCommunityProperties":
            suggest = "ip_community_properties"
        elif key == "ipExtendedCommunityProperties":
            suggest = "ip_extended_community_properties"
        elif key == "localPreference":
            suggest = "local_preference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatementActionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatementActionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatementActionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: builtins.str,
                 ip_community_properties: Optional['outputs.ActionIpCommunityPropertiesResponse'] = None,
                 ip_extended_community_properties: Optional['outputs.ActionIpExtendedCommunityPropertiesResponse'] = None,
                 local_preference: Optional[builtins.float] = None):
        """
        Route policy action properties.
        :param builtins.str action_type: Action type. Example: Permit | Deny | Continue.
        :param 'ActionIpCommunityPropertiesResponse' ip_community_properties: IP Community Properties.
        :param 'ActionIpExtendedCommunityPropertiesResponse' ip_extended_community_properties: IP Extended Community Properties.
        :param builtins.float local_preference: Local Preference of the route policy.
        """
        pulumi.set(__self__, "action_type", action_type)
        if ip_community_properties is not None:
            pulumi.set(__self__, "ip_community_properties", ip_community_properties)
        if ip_extended_community_properties is not None:
            pulumi.set(__self__, "ip_extended_community_properties", ip_extended_community_properties)
        if local_preference is not None:
            pulumi.set(__self__, "local_preference", local_preference)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> builtins.str:
        """
        Action type. Example: Permit | Deny | Continue.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="ipCommunityProperties")
    def ip_community_properties(self) -> Optional['outputs.ActionIpCommunityPropertiesResponse']:
        """
        IP Community Properties.
        """
        return pulumi.get(self, "ip_community_properties")

    @property
    @pulumi.getter(name="ipExtendedCommunityProperties")
    def ip_extended_community_properties(self) -> Optional['outputs.ActionIpExtendedCommunityPropertiesResponse']:
        """
        IP Extended Community Properties.
        """
        return pulumi.get(self, "ip_extended_community_properties")

    @property
    @pulumi.getter(name="localPreference")
    def local_preference(self) -> Optional[builtins.float]:
        """
        Local Preference of the route policy.
        """
        return pulumi.get(self, "local_preference")


@pulumi.output_type
class StatementConditionPropertiesResponse(dict):
    """
    Route policy statement condition properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipCommunityIds":
            suggest = "ip_community_ids"
        elif key == "ipExtendedCommunityIds":
            suggest = "ip_extended_community_ids"
        elif key == "ipPrefixId":
            suggest = "ip_prefix_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatementConditionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatementConditionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatementConditionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_community_ids: Optional[Sequence[builtins.str]] = None,
                 ip_extended_community_ids: Optional[Sequence[builtins.str]] = None,
                 ip_prefix_id: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        Route policy statement condition properties.
        :param Sequence[builtins.str] ip_community_ids: List of IP Community resource IDs.
        :param Sequence[builtins.str] ip_extended_community_ids: List of IP Extended Community resource IDs.
        :param builtins.str ip_prefix_id: Arm Resource Id of IpPrefix.
        :param builtins.str type: Type of the condition used.
        """
        if ip_community_ids is not None:
            pulumi.set(__self__, "ip_community_ids", ip_community_ids)
        if ip_extended_community_ids is not None:
            pulumi.set(__self__, "ip_extended_community_ids", ip_extended_community_ids)
        if ip_prefix_id is not None:
            pulumi.set(__self__, "ip_prefix_id", ip_prefix_id)
        if type is None:
            type = 'Or'
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="ipCommunityIds")
    def ip_community_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        List of IP Community resource IDs.
        """
        return pulumi.get(self, "ip_community_ids")

    @property
    @pulumi.getter(name="ipExtendedCommunityIds")
    def ip_extended_community_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        List of IP Extended Community resource IDs.
        """
        return pulumi.get(self, "ip_extended_community_ids")

    @property
    @pulumi.getter(name="ipPrefixId")
    def ip_prefix_id(self) -> Optional[builtins.str]:
        """
        Arm Resource Id of IpPrefix.
        """
        return pulumi.get(self, "ip_prefix_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the condition used.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class StaticRoutePropertiesResponse(dict):
    """
    Route Properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextHop":
            suggest = "next_hop"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StaticRoutePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StaticRoutePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StaticRoutePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 next_hop: Sequence[builtins.str],
                 prefix: builtins.str):
        """
        Route Properties.
        :param Sequence[builtins.str] next_hop: List of next hop addresses.
        :param builtins.str prefix: Prefix of the route.
        """
        pulumi.set(__self__, "next_hop", next_hop)
        pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> Sequence[builtins.str]:
        """
        List of next hop addresses.
        """
        return pulumi.get(self, "next_hop")

    @property
    @pulumi.getter
    def prefix(self) -> builtins.str:
        """
        Prefix of the route.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[builtins.str] = None,
                 created_by: Optional[builtins.str] = None,
                 created_by_type: Optional[builtins.str] = None,
                 last_modified_at: Optional[builtins.str] = None,
                 last_modified_by: Optional[builtins.str] = None,
                 last_modified_by_type: Optional[builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param builtins.str created_at: The timestamp of resource creation (UTC).
        :param builtins.str created_by: The identity that created the resource.
        :param builtins.str created_by_type: The type of identity that created the resource.
        :param builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param builtins.str last_modified_by: The identity that last modified the resource.
        :param builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TerminalServerConfigurationResponse(dict):
    """
    Network and credentials configuration currently applied to terminal server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkDeviceId":
            suggest = "network_device_id"
        elif key == "primaryIpv4Prefix":
            suggest = "primary_ipv4_prefix"
        elif key == "secondaryIpv4Prefix":
            suggest = "secondary_ipv4_prefix"
        elif key == "primaryIpv6Prefix":
            suggest = "primary_ipv6_prefix"
        elif key == "secondaryIpv6Prefix":
            suggest = "secondary_ipv6_prefix"
        elif key == "serialNumber":
            suggest = "serial_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TerminalServerConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TerminalServerConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TerminalServerConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_device_id: builtins.str,
                 password: builtins.str,
                 primary_ipv4_prefix: builtins.str,
                 secondary_ipv4_prefix: builtins.str,
                 username: builtins.str,
                 primary_ipv6_prefix: Optional[builtins.str] = None,
                 secondary_ipv6_prefix: Optional[builtins.str] = None,
                 serial_number: Optional[builtins.str] = None):
        """
        Network and credentials configuration currently applied to terminal server.
        :param builtins.str network_device_id: ARM Resource ID used for the NetworkDevice.
        :param builtins.str password: Password for the terminal server connection.
        :param builtins.str primary_ipv4_prefix: IPv4 Address Prefix.
        :param builtins.str secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
        :param builtins.str username: Username for the terminal server connection.
        :param builtins.str primary_ipv6_prefix: IPv6 Address Prefix.
        :param builtins.str secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
        :param builtins.str serial_number: Serial Number of Terminal server.
        """
        pulumi.set(__self__, "network_device_id", network_device_id)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "primary_ipv4_prefix", primary_ipv4_prefix)
        pulumi.set(__self__, "secondary_ipv4_prefix", secondary_ipv4_prefix)
        pulumi.set(__self__, "username", username)
        if primary_ipv6_prefix is not None:
            pulumi.set(__self__, "primary_ipv6_prefix", primary_ipv6_prefix)
        if secondary_ipv6_prefix is not None:
            pulumi.set(__self__, "secondary_ipv6_prefix", secondary_ipv6_prefix)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)

    @property
    @pulumi.getter(name="networkDeviceId")
    def network_device_id(self) -> builtins.str:
        """
        ARM Resource ID used for the NetworkDevice.
        """
        return pulumi.get(self, "network_device_id")

    @property
    @pulumi.getter
    def password(self) -> builtins.str:
        """
        Password for the terminal server connection.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="primaryIpv4Prefix")
    def primary_ipv4_prefix(self) -> builtins.str:
        """
        IPv4 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv4_prefix")

    @property
    @pulumi.getter(name="secondaryIpv4Prefix")
    def secondary_ipv4_prefix(self) -> builtins.str:
        """
        Secondary IPv4 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv4_prefix")

    @property
    @pulumi.getter
    def username(self) -> builtins.str:
        """
        Username for the terminal server connection.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="primaryIpv6Prefix")
    def primary_ipv6_prefix(self) -> Optional[builtins.str]:
        """
        IPv6 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv6_prefix")

    @property
    @pulumi.getter(name="secondaryIpv6Prefix")
    def secondary_ipv6_prefix(self) -> Optional[builtins.str]:
        """
        Secondary IPv6 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv6_prefix")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[builtins.str]:
        """
        Serial Number of Terminal server.
        """
        return pulumi.get(self, "serial_number")


@pulumi.output_type
class VlanGroupPropertiesResponse(dict):
    """
    Vlan group properties.
    """
    def __init__(__self__, *,
                 name: Optional[builtins.str] = None,
                 vlans: Optional[Sequence[builtins.str]] = None):
        """
        Vlan group properties.
        :param builtins.str name: Vlan group name.
        :param Sequence[builtins.str] vlans: List of vlans.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if vlans is not None:
            pulumi.set(__self__, "vlans", vlans)

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Vlan group name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def vlans(self) -> Optional[Sequence[builtins.str]]:
        """
        List of vlans.
        """
        return pulumi.get(self, "vlans")


@pulumi.output_type
class VlanMatchConditionResponse(dict):
    """
    The vlan match conditions that need to be matched.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "innerVlans":
            suggest = "inner_vlans"
        elif key == "vlanGroupNames":
            suggest = "vlan_group_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VlanMatchConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VlanMatchConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VlanMatchConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inner_vlans: Optional[Sequence[builtins.str]] = None,
                 vlan_group_names: Optional[Sequence[builtins.str]] = None,
                 vlans: Optional[Sequence[builtins.str]] = None):
        """
        The vlan match conditions that need to be matched.
        :param Sequence[builtins.str] inner_vlans: List of inner vlans that need to be matched.
        :param Sequence[builtins.str] vlan_group_names: List of vlan group names that need to be matched.
        :param Sequence[builtins.str] vlans: List of vlans that need to be matched.
        """
        if inner_vlans is not None:
            pulumi.set(__self__, "inner_vlans", inner_vlans)
        if vlan_group_names is not None:
            pulumi.set(__self__, "vlan_group_names", vlan_group_names)
        if vlans is not None:
            pulumi.set(__self__, "vlans", vlans)

    @property
    @pulumi.getter(name="innerVlans")
    def inner_vlans(self) -> Optional[Sequence[builtins.str]]:
        """
        List of inner vlans that need to be matched.
        """
        return pulumi.get(self, "inner_vlans")

    @property
    @pulumi.getter(name="vlanGroupNames")
    def vlan_group_names(self) -> Optional[Sequence[builtins.str]]:
        """
        List of vlan group names that need to be matched.
        """
        return pulumi.get(self, "vlan_group_names")

    @property
    @pulumi.getter
    def vlans(self) -> Optional[Sequence[builtins.str]]:
        """
        List of vlans that need to be matched.
        """
        return pulumi.get(self, "vlans")


@pulumi.output_type
class VpnConfigurationPropertiesResponse(dict):
    """
    Network and credential configuration currently applied on terminal server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "administrativeState":
            suggest = "administrative_state"
        elif key == "peeringOption":
            suggest = "peering_option"
        elif key == "networkToNetworkInterconnectId":
            suggest = "network_to_network_interconnect_id"
        elif key == "optionAProperties":
            suggest = "option_a_properties"
        elif key == "optionBProperties":
            suggest = "option_b_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConfigurationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConfigurationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConfigurationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 administrative_state: builtins.str,
                 peering_option: builtins.str,
                 network_to_network_interconnect_id: Optional[builtins.str] = None,
                 option_a_properties: Optional['outputs.VpnConfigurationPropertiesResponseOptionAProperties'] = None,
                 option_b_properties: Optional['outputs.FabricOptionBPropertiesResponse'] = None):
        """
        Network and credential configuration currently applied on terminal server.
        :param builtins.str administrative_state: Administrative state of the resource.
        :param builtins.str peering_option: Peering option list.
        :param builtins.str network_to_network_interconnect_id: ARM Resource ID of the Network To Network Interconnect.
        :param 'VpnConfigurationPropertiesResponseOptionAProperties' option_a_properties: option A properties
        :param 'FabricOptionBPropertiesResponse' option_b_properties: option B properties
        """
        pulumi.set(__self__, "administrative_state", administrative_state)
        pulumi.set(__self__, "peering_option", peering_option)
        if network_to_network_interconnect_id is not None:
            pulumi.set(__self__, "network_to_network_interconnect_id", network_to_network_interconnect_id)
        if option_a_properties is not None:
            pulumi.set(__self__, "option_a_properties", option_a_properties)
        if option_b_properties is not None:
            pulumi.set(__self__, "option_b_properties", option_b_properties)

    @property
    @pulumi.getter(name="administrativeState")
    def administrative_state(self) -> builtins.str:
        """
        Administrative state of the resource.
        """
        return pulumi.get(self, "administrative_state")

    @property
    @pulumi.getter(name="peeringOption")
    def peering_option(self) -> builtins.str:
        """
        Peering option list.
        """
        return pulumi.get(self, "peering_option")

    @property
    @pulumi.getter(name="networkToNetworkInterconnectId")
    def network_to_network_interconnect_id(self) -> Optional[builtins.str]:
        """
        ARM Resource ID of the Network To Network Interconnect.
        """
        return pulumi.get(self, "network_to_network_interconnect_id")

    @property
    @pulumi.getter(name="optionAProperties")
    def option_a_properties(self) -> Optional['outputs.VpnConfigurationPropertiesResponseOptionAProperties']:
        """
        option A properties
        """
        return pulumi.get(self, "option_a_properties")

    @property
    @pulumi.getter(name="optionBProperties")
    def option_b_properties(self) -> Optional['outputs.FabricOptionBPropertiesResponse']:
        """
        option B properties
        """
        return pulumi.get(self, "option_b_properties")


@pulumi.output_type
class VpnConfigurationPropertiesResponseOptionAProperties(dict):
    """
    option A properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "peerASN":
            suggest = "peer_asn"
        elif key == "vlanId":
            suggest = "vlan_id"
        elif key == "bfdConfiguration":
            suggest = "bfd_configuration"
        elif key == "primaryIpv4Prefix":
            suggest = "primary_ipv4_prefix"
        elif key == "primaryIpv6Prefix":
            suggest = "primary_ipv6_prefix"
        elif key == "secondaryIpv4Prefix":
            suggest = "secondary_ipv4_prefix"
        elif key == "secondaryIpv6Prefix":
            suggest = "secondary_ipv6_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConfigurationPropertiesResponseOptionAProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConfigurationPropertiesResponseOptionAProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConfigurationPropertiesResponseOptionAProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 peer_asn: builtins.float,
                 vlan_id: builtins.int,
                 bfd_configuration: Optional['outputs.BfdConfigurationResponse'] = None,
                 mtu: Optional[builtins.int] = None,
                 primary_ipv4_prefix: Optional[builtins.str] = None,
                 primary_ipv6_prefix: Optional[builtins.str] = None,
                 secondary_ipv4_prefix: Optional[builtins.str] = None,
                 secondary_ipv6_prefix: Optional[builtins.str] = None):
        """
        option A properties
        :param builtins.float peer_asn: Peer ASN number.Example : 28
        :param builtins.int vlan_id: Vlan Id.Example : 501
        :param 'BfdConfigurationResponse' bfd_configuration: BFD Configuration properties.
        :param builtins.int mtu: MTU to use for option A peering.
        :param builtins.str primary_ipv4_prefix: IPv4 Address Prefix.
        :param builtins.str primary_ipv6_prefix: IPv6 Address Prefix.
        :param builtins.str secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
        :param builtins.str secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
        """
        pulumi.set(__self__, "peer_asn", peer_asn)
        pulumi.set(__self__, "vlan_id", vlan_id)
        if bfd_configuration is not None:
            pulumi.set(__self__, "bfd_configuration", bfd_configuration)
        if mtu is None:
            mtu = 1500
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if primary_ipv4_prefix is not None:
            pulumi.set(__self__, "primary_ipv4_prefix", primary_ipv4_prefix)
        if primary_ipv6_prefix is not None:
            pulumi.set(__self__, "primary_ipv6_prefix", primary_ipv6_prefix)
        if secondary_ipv4_prefix is not None:
            pulumi.set(__self__, "secondary_ipv4_prefix", secondary_ipv4_prefix)
        if secondary_ipv6_prefix is not None:
            pulumi.set(__self__, "secondary_ipv6_prefix", secondary_ipv6_prefix)

    @property
    @pulumi.getter(name="peerASN")
    def peer_asn(self) -> builtins.float:
        """
        Peer ASN number.Example : 28
        """
        return pulumi.get(self, "peer_asn")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> builtins.int:
        """
        Vlan Id.Example : 501
        """
        return pulumi.get(self, "vlan_id")

    @property
    @pulumi.getter(name="bfdConfiguration")
    def bfd_configuration(self) -> Optional['outputs.BfdConfigurationResponse']:
        """
        BFD Configuration properties.
        """
        return pulumi.get(self, "bfd_configuration")

    @property
    @pulumi.getter
    def mtu(self) -> Optional[builtins.int]:
        """
        MTU to use for option A peering.
        """
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter(name="primaryIpv4Prefix")
    def primary_ipv4_prefix(self) -> Optional[builtins.str]:
        """
        IPv4 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv4_prefix")

    @property
    @pulumi.getter(name="primaryIpv6Prefix")
    def primary_ipv6_prefix(self) -> Optional[builtins.str]:
        """
        IPv6 Address Prefix.
        """
        return pulumi.get(self, "primary_ipv6_prefix")

    @property
    @pulumi.getter(name="secondaryIpv4Prefix")
    def secondary_ipv4_prefix(self) -> Optional[builtins.str]:
        """
        Secondary IPv4 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv4_prefix")

    @property
    @pulumi.getter(name="secondaryIpv6Prefix")
    def secondary_ipv6_prefix(self) -> Optional[builtins.str]:
        """
        Secondary IPv6 Address Prefix.
        """
        return pulumi.get(self, "secondary_ipv6_prefix")


