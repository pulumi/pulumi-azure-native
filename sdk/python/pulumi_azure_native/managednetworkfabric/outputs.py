# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AccessControlListConditionPropertiesResponse',
    'ActionIpCommunityPropertiesResponse',
    'ActionIpExtendedCommunityPropertiesResponse',
    'AggregateRouteConfigurationResponse',
    'AggregateRouteResponse',
    'BfdConfigurationResponse',
    'BgpConfigurationResponse',
    'CommonDynamicMatchConfigurationResponse',
    'ConnectedSubnetResponse',
    'ErrorAdditionalInfoResponse',
    'ErrorDetailResponse',
    'ExpressRouteConnectionInformationResponse',
    'ExternalNetworkPropertiesResponseOptionAProperties',
    'FabricBfdConfigurationResponse',
    'FabricOptionBPropertiesResponse',
    'InfrastructureServicesResponse',
    'IpCommunityIdListResponse',
    'IpExtendedCommunityIdListResponse',
    'IpGroupPropertiesResponse',
    'IpMatchConditionResponse',
    'IpPrefixPropertiesResponseIpPrefixRules',
    'IsolationDomainPropertiesResponse',
    'L3IsolationDomainPatchPropertiesResponseConnectedSubnetRoutePolicy',
    'Layer2ConfigurationResponse',
    'Layer3ConfigurationResponse',
    'ManagedResourceGroupConfigurationResponse',
    'ManagementNetworkConfigurationResponse',
    'NeighborAddressResponse',
    'NeighborGroupDestinationResponse',
    'NetworkTapPropertiesResponseDestinations',
    'NetworkTapRuleActionResponse',
    'NetworkTapRuleMatchConditionResponse',
    'NetworkTapRuleMatchConfigurationResponse',
    'OptionAPropertiesResponse',
    'OptionBPropertiesResponse',
    'PortConditionResponse',
    'PortGroupPropertiesResponse',
    'RoutePolicyStatementPropertiesResponse',
    'RulePropertiesResponse',
    'StatementActionPropertiesResponse',
    'StatementConditionPropertiesResponse',
    'StaticRouteConfigurationResponse',
    'StaticRoutePropertiesResponse',
    'SystemDataResponse',
    'TerminalServerConfigurationResponse',
    'VlanGroupPropertiesResponse',
    'VlanMatchConditionResponse',
    'VpnConfigurationPropertiesResponse',
    'WorkloadServicesResponse',
]

@pulumi.output_type
class AccessControlListConditionPropertiesResponse(dict):
    """
    Access Control List condition model.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddress":
            suggest = "destination_address"
        elif key == "destinationPort":
            suggest = "destination_port"
        elif key == "sequenceNumber":
            suggest = "sequence_number"
        elif key == "sourceAddress":
            suggest = "source_address"
        elif key == "sourcePort":
            suggest = "source_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessControlListConditionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessControlListConditionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessControlListConditionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 destination_address: str,
                 destination_port: str,
                 protocol: int,
                 sequence_number: int,
                 source_address: str,
                 source_port: str,
                 annotation: Optional[str] = None):
        """
        Access Control List condition model.
        :param str action: action. Example: allow | deny.
        :param str destination_address: destinationAddress. Example: any | 1.1.1.0/24 | 1.1.10.10
        :param str destination_port: destinationPort. Example: any | 1253
        :param int protocol: TCP/IP protocol as defined in the list of IP protocol numbers. Example: 255 (any) | 0 | 1.
        :param int sequence_number: sequenceNumber of the Access Control List.
        :param str source_address: sourceAddress. Example: any | 1.1.1.0/24 | 1.1.10.10
        :param str source_port: sourcePort. Example: any | 1253
        :param str annotation: Switch configuration description.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "destination_address", destination_address)
        pulumi.set(__self__, "destination_port", destination_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "sequence_number", sequence_number)
        pulumi.set(__self__, "source_address", source_address)
        pulumi.set(__self__, "source_port", source_port)
        if annotation is not None:
            pulumi.set(__self__, "annotation", annotation)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        action. Example: allow | deny.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="destinationAddress")
    def destination_address(self) -> str:
        """
        destinationAddress. Example: any | 1.1.1.0/24 | 1.1.10.10
        """
        return pulumi.get(self, "destination_address")

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> str:
        """
        destinationPort. Example: any | 1253
        """
        return pulumi.get(self, "destination_port")

    @property
    @pulumi.getter
    def protocol(self) -> int:
        """
        TCP/IP protocol as defined in the list of IP protocol numbers. Example: 255 (any) | 0 | 1.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> int:
        """
        sequenceNumber of the Access Control List.
        """
        return pulumi.get(self, "sequence_number")

    @property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> str:
        """
        sourceAddress. Example: any | 1.1.1.0/24 | 1.1.10.10
        """
        return pulumi.get(self, "source_address")

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> str:
        """
        sourcePort. Example: any | 1253
        """
        return pulumi.get(self, "source_port")

    @property
    @pulumi.getter
    def annotation(self) -> Optional[str]:
        """
        Switch configuration description.
        """
        return pulumi.get(self, "annotation")


@pulumi.output_type
class ActionIpCommunityPropertiesResponse(dict):
    """
    IP Community Properties.
    """
    def __init__(__self__, *,
                 add: Optional['outputs.IpCommunityIdListResponse'] = None,
                 delete: Optional['outputs.IpCommunityIdListResponse'] = None,
                 set: Optional['outputs.IpCommunityIdListResponse'] = None):
        """
        IP Community Properties.
        :param 'IpCommunityIdListResponse' add: IP Community ID list properties.
        :param 'IpCommunityIdListResponse' delete: IP Community ID list properties.
        :param 'IpCommunityIdListResponse' set: IP Community ID list properties.
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional['outputs.IpCommunityIdListResponse']:
        """
        IP Community ID list properties.
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def delete(self) -> Optional['outputs.IpCommunityIdListResponse']:
        """
        IP Community ID list properties.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def set(self) -> Optional['outputs.IpCommunityIdListResponse']:
        """
        IP Community ID list properties.
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class ActionIpExtendedCommunityPropertiesResponse(dict):
    """
    IP Extended Community Properties.
    """
    def __init__(__self__, *,
                 add: Optional['outputs.IpExtendedCommunityIdListResponse'] = None,
                 delete: Optional['outputs.IpExtendedCommunityIdListResponse'] = None,
                 set: Optional['outputs.IpExtendedCommunityIdListResponse'] = None):
        """
        IP Extended Community Properties.
        :param 'IpExtendedCommunityIdListResponse' add: IP Extended Community Id list properties.
        :param 'IpExtendedCommunityIdListResponse' delete: IP Extended Community Id list properties.
        :param 'IpExtendedCommunityIdListResponse' set: IP Extended Community Id list properties.
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional['outputs.IpExtendedCommunityIdListResponse']:
        """
        IP Extended Community Id list properties.
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def delete(self) -> Optional['outputs.IpExtendedCommunityIdListResponse']:
        """
        IP Extended Community Id list properties.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def set(self) -> Optional['outputs.IpExtendedCommunityIdListResponse']:
        """
        IP Extended Community Id list properties.
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class AggregateRouteConfigurationResponse(dict):
    """
    List of IPv4 and IPv6 route configurations.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4Routes":
            suggest = "ipv4_routes"
        elif key == "ipv6Routes":
            suggest = "ipv6_routes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AggregateRouteConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AggregateRouteConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AggregateRouteConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4_routes: Optional[Sequence['outputs.AggregateRouteResponse']] = None,
                 ipv6_routes: Optional[Sequence['outputs.AggregateRouteResponse']] = None):
        """
        List of IPv4 and IPv6 route configurations.
        :param Sequence['AggregateRouteResponse'] ipv4_routes: List of IPv4 Route prefixes.
        :param Sequence['AggregateRouteResponse'] ipv6_routes: List of IPv6 Routes prefixes.
        """
        if ipv4_routes is not None:
            pulumi.set(__self__, "ipv4_routes", ipv4_routes)
        if ipv6_routes is not None:
            pulumi.set(__self__, "ipv6_routes", ipv6_routes)

    @property
    @pulumi.getter(name="ipv4Routes")
    def ipv4_routes(self) -> Optional[Sequence['outputs.AggregateRouteResponse']]:
        """
        List of IPv4 Route prefixes.
        """
        return pulumi.get(self, "ipv4_routes")

    @property
    @pulumi.getter(name="ipv6Routes")
    def ipv6_routes(self) -> Optional[Sequence['outputs.AggregateRouteResponse']]:
        """
        List of IPv6 Routes prefixes.
        """
        return pulumi.get(self, "ipv6_routes")


@pulumi.output_type
class AggregateRouteResponse(dict):
    """
    Aggregate Route properties.
    """
    def __init__(__self__, *,
                 prefix: Optional[str] = None):
        """
        Aggregate Route properties.
        :param str prefix: Prefix of the aggregate Route.
        """
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Prefix of the aggregate Route.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class BfdConfigurationResponse(dict):
    """
    BFD configuration properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "administrativeState":
            suggest = "administrative_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BfdConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BfdConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BfdConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 administrative_state: str,
                 interval: int,
                 multiplier: int):
        """
        BFD configuration properties
        :param str administrative_state: Administrative state of the BfdConfiguration. Example: Enabled | Disabled.
        :param int interval: interval in milliseconds. Example: 300.
        :param int multiplier: Multiplier for the Bfd Configuration. Example: 3.
        """
        pulumi.set(__self__, "administrative_state", administrative_state)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "multiplier", multiplier)

    @property
    @pulumi.getter(name="administrativeState")
    def administrative_state(self) -> str:
        """
        Administrative state of the BfdConfiguration. Example: Enabled | Disabled.
        """
        return pulumi.get(self, "administrative_state")

    @property
    @pulumi.getter
    def interval(self) -> int:
        """
        interval in milliseconds. Example: 300.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def multiplier(self) -> int:
        """
        Multiplier for the Bfd Configuration. Example: 3.
        """
        return pulumi.get(self, "multiplier")


@pulumi.output_type
class BgpConfigurationResponse(dict):
    """
    BGP configuration properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fabricASN":
            suggest = "fabric_asn"
        elif key == "peerASN":
            suggest = "peer_asn"
        elif key == "allowAS":
            suggest = "allow_as"
        elif key == "allowASOverride":
            suggest = "allow_as_override"
        elif key == "bfdConfiguration":
            suggest = "bfd_configuration"
        elif key == "defaultRouteOriginate":
            suggest = "default_route_originate"
        elif key == "ipv4ListenRangePrefixes":
            suggest = "ipv4_listen_range_prefixes"
        elif key == "ipv4NeighborAddress":
            suggest = "ipv4_neighbor_address"
        elif key == "ipv6ListenRangePrefixes":
            suggest = "ipv6_listen_range_prefixes"
        elif key == "ipv6NeighborAddress":
            suggest = "ipv6_neighbor_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BgpConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BgpConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BgpConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fabric_asn: int,
                 peer_asn: int,
                 allow_as: Optional[int] = None,
                 allow_as_override: Optional[str] = None,
                 annotation: Optional[str] = None,
                 bfd_configuration: Optional['outputs.BfdConfigurationResponse'] = None,
                 default_route_originate: Optional[str] = None,
                 ipv4_listen_range_prefixes: Optional[Sequence[str]] = None,
                 ipv4_neighbor_address: Optional[Sequence['outputs.NeighborAddressResponse']] = None,
                 ipv6_listen_range_prefixes: Optional[Sequence[str]] = None,
                 ipv6_neighbor_address: Optional[Sequence['outputs.NeighborAddressResponse']] = None):
        """
        BGP configuration properties
        :param int fabric_asn: ASN of Network Fabric. Example: 65048.
        :param int peer_asn: Peer ASN. Example: 65047.
        :param int allow_as: Allows for routes to be received and processed even if the router detects its own ASN in the AS-Path. 0 is disable, Possible values are 1-10, default is 2.
        :param str allow_as_override: Enable Or Disable state.
        :param str annotation: Switch configuration description.
        :param 'BfdConfigurationResponse' bfd_configuration: BFD configuration properties
        :param str default_route_originate: Originate a defaultRoute. Ex: "True" | "False".
        :param Sequence[str] ipv4_listen_range_prefixes: BGP Ipv4 ListenRange.
        :param Sequence['NeighborAddressResponse'] ipv4_neighbor_address: List with stringified ipv4NeighborAddresses.
        :param Sequence[str] ipv6_listen_range_prefixes: BGP Ipv6 ListenRange.
        :param Sequence['NeighborAddressResponse'] ipv6_neighbor_address: List with stringified IPv6 Neighbor Address.
        """
        pulumi.set(__self__, "fabric_asn", fabric_asn)
        pulumi.set(__self__, "peer_asn", peer_asn)
        if allow_as is None:
            allow_as = 2
        if allow_as is not None:
            pulumi.set(__self__, "allow_as", allow_as)
        if allow_as_override is not None:
            pulumi.set(__self__, "allow_as_override", allow_as_override)
        if annotation is not None:
            pulumi.set(__self__, "annotation", annotation)
        if bfd_configuration is not None:
            pulumi.set(__self__, "bfd_configuration", bfd_configuration)
        if default_route_originate is not None:
            pulumi.set(__self__, "default_route_originate", default_route_originate)
        if ipv4_listen_range_prefixes is not None:
            pulumi.set(__self__, "ipv4_listen_range_prefixes", ipv4_listen_range_prefixes)
        if ipv4_neighbor_address is not None:
            pulumi.set(__self__, "ipv4_neighbor_address", ipv4_neighbor_address)
        if ipv6_listen_range_prefixes is not None:
            pulumi.set(__self__, "ipv6_listen_range_prefixes", ipv6_listen_range_prefixes)
        if ipv6_neighbor_address is not None:
            pulumi.set(__self__, "ipv6_neighbor_address", ipv6_neighbor_address)

    @property
    @pulumi.getter(name="fabricASN")
    def fabric_asn(self) -> int:
        """
        ASN of Network Fabric. Example: 65048.
        """
        return pulumi.get(self, "fabric_asn")

    @property
    @pulumi.getter(name="peerASN")
    def peer_asn(self) -> int:
        """
        Peer ASN. Example: 65047.
        """
        return pulumi.get(self, "peer_asn")

    @property
    @pulumi.getter(name="allowAS")
    def allow_as(self) -> Optional[int]:
        """
        Allows for routes to be received and processed even if the router detects its own ASN in the AS-Path. 0 is disable, Possible values are 1-10, default is 2.
        """
        return pulumi.get(self, "allow_as")

    @property
    @pulumi.getter(name="allowASOverride")
    def allow_as_override(self) -> Optional[str]:
        """
        Enable Or Disable state.
        """
        return pulumi.get(self, "allow_as_override")

    @property
    @pulumi.getter
    def annotation(self) -> Optional[str]:
        """
        Switch configuration description.
        """
        return pulumi.get(self, "annotation")

    @property
    @pulumi.getter(name="bfdConfiguration")
    def bfd_configuration(self) -> Optional['outputs.BfdConfigurationResponse']:
        """
        BFD configuration properties
        """
        return pulumi.get(self, "bfd_configuration")

    @property
    @pulumi.getter(name="defaultRouteOriginate")
    def default_route_originate(self) -> Optional[str]:
        """
        Originate a defaultRoute. Ex: "True" | "False".
        """
        return pulumi.get(self, "default_route_originate")

    @property
    @pulumi.getter(name="ipv4ListenRangePrefixes")
    def ipv4_listen_range_prefixes(self) -> Optional[Sequence[str]]:
        """
        BGP Ipv4 ListenRange.
        """
        return pulumi.get(self, "ipv4_listen_range_prefixes")

    @property
    @pulumi.getter(name="ipv4NeighborAddress")
    def ipv4_neighbor_address(self) -> Optional[Sequence['outputs.NeighborAddressResponse']]:
        """
        List with stringified ipv4NeighborAddresses.
        """
        return pulumi.get(self, "ipv4_neighbor_address")

    @property
    @pulumi.getter(name="ipv6ListenRangePrefixes")
    def ipv6_listen_range_prefixes(self) -> Optional[Sequence[str]]:
        """
        BGP Ipv6 ListenRange.
        """
        return pulumi.get(self, "ipv6_listen_range_prefixes")

    @property
    @pulumi.getter(name="ipv6NeighborAddress")
    def ipv6_neighbor_address(self) -> Optional[Sequence['outputs.NeighborAddressResponse']]:
        """
        List with stringified IPv6 Neighbor Address.
        """
        return pulumi.get(self, "ipv6_neighbor_address")


@pulumi.output_type
class CommonDynamicMatchConfigurationResponse(dict):
    """
    Dynamic match configuration object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipGroups":
            suggest = "ip_groups"
        elif key == "portGroups":
            suggest = "port_groups"
        elif key == "vlanGroups":
            suggest = "vlan_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CommonDynamicMatchConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CommonDynamicMatchConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CommonDynamicMatchConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_groups: Optional[Sequence['outputs.IpGroupPropertiesResponse']] = None,
                 port_groups: Optional[Sequence['outputs.PortGroupPropertiesResponse']] = None,
                 vlan_groups: Optional[Sequence['outputs.VlanGroupPropertiesResponse']] = None):
        """
        Dynamic match configuration object.
        :param Sequence['IpGroupPropertiesResponse'] ip_groups: List of IP Groups.
        :param Sequence['PortGroupPropertiesResponse'] port_groups: List of the port groups.
        :param Sequence['VlanGroupPropertiesResponse'] vlan_groups: List of vlan groups.
        """
        if ip_groups is not None:
            pulumi.set(__self__, "ip_groups", ip_groups)
        if port_groups is not None:
            pulumi.set(__self__, "port_groups", port_groups)
        if vlan_groups is not None:
            pulumi.set(__self__, "vlan_groups", vlan_groups)

    @property
    @pulumi.getter(name="ipGroups")
    def ip_groups(self) -> Optional[Sequence['outputs.IpGroupPropertiesResponse']]:
        """
        List of IP Groups.
        """
        return pulumi.get(self, "ip_groups")

    @property
    @pulumi.getter(name="portGroups")
    def port_groups(self) -> Optional[Sequence['outputs.PortGroupPropertiesResponse']]:
        """
        List of the port groups.
        """
        return pulumi.get(self, "port_groups")

    @property
    @pulumi.getter(name="vlanGroups")
    def vlan_groups(self) -> Optional[Sequence['outputs.VlanGroupPropertiesResponse']]:
        """
        List of vlan groups.
        """
        return pulumi.get(self, "vlan_groups")


@pulumi.output_type
class ConnectedSubnetResponse(dict):
    """
    Connected Subnet properties.
    """
    def __init__(__self__, *,
                 annotation: Optional[str] = None,
                 prefix: Optional[str] = None):
        """
        Connected Subnet properties.
        :param str annotation: Switch configuration description.
        :param str prefix: Prefix of the connected Subnet.
        """
        if annotation is not None:
            pulumi.set(__self__, "annotation", annotation)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def annotation(self) -> Optional[str]:
        """
        Switch configuration description.
        """
        return pulumi.get(self, "annotation")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Prefix of the connected Subnet.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class ErrorAdditionalInfoResponse(dict):
    """
    The resource management error additional info.
    """
    def __init__(__self__, *,
                 info: Any,
                 type: str):
        """
        The resource management error additional info.
        :param Any info: The additional info.
        :param str type: The additional info type.
        """
        pulumi.set(__self__, "info", info)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def info(self) -> Any:
        """
        The additional info.
        """
        return pulumi.get(self, "info")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The additional info type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ErrorDetailResponse(dict):
    """
    The error detail.
    """
    def __init__(__self__, *,
                 additional_info: Sequence['outputs.ErrorAdditionalInfoResponse'],
                 code: str,
                 details: Sequence['outputs.ErrorDetailResponse'],
                 message: str,
                 target: str):
        """
        The error detail.
        :param Sequence['ErrorAdditionalInfoResponse'] additional_info: The error additional info.
        :param str code: The error code.
        :param Sequence['ErrorDetailResponse'] details: The error details.
        :param str message: The error message.
        :param str target: The error target.
        """
        pulumi.set(__self__, "additional_info", additional_info)
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="additionalInfo")
    def additional_info(self) -> Sequence['outputs.ErrorAdditionalInfoResponse']:
        """
        The error additional info.
        """
        return pulumi.get(self, "additional_info")

    @property
    @pulumi.getter
    def code(self) -> str:
        """
        The error code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.ErrorDetailResponse']:
        """
        The error details.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        The error message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The error target.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class ExpressRouteConnectionInformationResponse(dict):
    """
    The ExpressRoute circuit ID and the Auth Key are required for you to successfully deploy NFC service.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expressRouteAuthorizationKey":
            suggest = "express_route_authorization_key"
        elif key == "expressRouteCircuitId":
            suggest = "express_route_circuit_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRouteConnectionInformationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRouteConnectionInformationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRouteConnectionInformationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 express_route_authorization_key: str,
                 express_route_circuit_id: str):
        """
        The ExpressRoute circuit ID and the Auth Key are required for you to successfully deploy NFC service.
        :param str express_route_authorization_key: Authorization key for the circuit, must be of type Microsoft.Network/expressRouteCircuits/authorizations. The Auth Key is a mandatory attribute.
        :param str express_route_circuit_id: The express route circuit Azure resource ID, must be of type Microsoft.Network/expressRouteCircuits/circuitName. The ExpressRoute Circuit is a mandatory attribute.
        """
        pulumi.set(__self__, "express_route_authorization_key", express_route_authorization_key)
        pulumi.set(__self__, "express_route_circuit_id", express_route_circuit_id)

    @property
    @pulumi.getter(name="expressRouteAuthorizationKey")
    def express_route_authorization_key(self) -> str:
        """
        Authorization key for the circuit, must be of type Microsoft.Network/expressRouteCircuits/authorizations. The Auth Key is a mandatory attribute.
        """
        return pulumi.get(self, "express_route_authorization_key")

    @property
    @pulumi.getter(name="expressRouteCircuitId")
    def express_route_circuit_id(self) -> str:
        """
        The express route circuit Azure resource ID, must be of type Microsoft.Network/expressRouteCircuits/circuitName. The ExpressRoute Circuit is a mandatory attribute.
        """
        return pulumi.get(self, "express_route_circuit_id")


@pulumi.output_type
class ExternalNetworkPropertiesResponseOptionAProperties(dict):
    """
    option A properties object
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fabricASN":
            suggest = "fabric_asn"
        elif key == "peerASN":
            suggest = "peer_asn"
        elif key == "vlanId":
            suggest = "vlan_id"
        elif key == "bfdConfiguration":
            suggest = "bfd_configuration"
        elif key == "primaryIpv4Prefix":
            suggest = "primary_ipv4_prefix"
        elif key == "primaryIpv6Prefix":
            suggest = "primary_ipv6_prefix"
        elif key == "secondaryIpv4Prefix":
            suggest = "secondary_ipv4_prefix"
        elif key == "secondaryIpv6Prefix":
            suggest = "secondary_ipv6_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalNetworkPropertiesResponseOptionAProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalNetworkPropertiesResponseOptionAProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalNetworkPropertiesResponseOptionAProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fabric_asn: int,
                 peer_asn: int,
                 vlan_id: int,
                 bfd_configuration: Optional['outputs.BfdConfigurationResponse'] = None,
                 mtu: Optional[int] = None,
                 primary_ipv4_prefix: Optional[str] = None,
                 primary_ipv6_prefix: Optional[str] = None,
                 secondary_ipv4_prefix: Optional[str] = None,
                 secondary_ipv6_prefix: Optional[str] = None):
        """
        option A properties object
        :param int fabric_asn: Fabric ASN number. Example 65001 
        :param int peer_asn: Peer ASN number.Example : 28
        :param int vlan_id: Vlan identifier. Example : 501
        :param 'BfdConfigurationResponse' bfd_configuration: BFD configuration properties
        :param int mtu: MTU to use for option A peering.
        :param str primary_ipv4_prefix: IPv4 Address Prefix of CE-PE interconnect links. Example: 172.31.0.0/31. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        :param str primary_ipv6_prefix: IPv6 Address Prefix of CE-PE interconnect links. Example: 3FFE:FFFF:0:CD30::a0/126. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        :param str secondary_ipv4_prefix: Secondary IPv4 Address Prefix of CE-PE interconnect links. Example: 172.31.0.20/31. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        :param str secondary_ipv6_prefix: Secondary IPv6 Address Prefix of CE-PE interconnect links. Example: 3FFE:FFFF:0:CD30::a4/126. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        """
        pulumi.set(__self__, "fabric_asn", fabric_asn)
        pulumi.set(__self__, "peer_asn", peer_asn)
        pulumi.set(__self__, "vlan_id", vlan_id)
        if bfd_configuration is not None:
            pulumi.set(__self__, "bfd_configuration", bfd_configuration)
        if mtu is None:
            mtu = 1500
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if primary_ipv4_prefix is not None:
            pulumi.set(__self__, "primary_ipv4_prefix", primary_ipv4_prefix)
        if primary_ipv6_prefix is not None:
            pulumi.set(__self__, "primary_ipv6_prefix", primary_ipv6_prefix)
        if secondary_ipv4_prefix is not None:
            pulumi.set(__self__, "secondary_ipv4_prefix", secondary_ipv4_prefix)
        if secondary_ipv6_prefix is not None:
            pulumi.set(__self__, "secondary_ipv6_prefix", secondary_ipv6_prefix)

    @property
    @pulumi.getter(name="fabricASN")
    def fabric_asn(self) -> int:
        """
        Fabric ASN number. Example 65001 
        """
        return pulumi.get(self, "fabric_asn")

    @property
    @pulumi.getter(name="peerASN")
    def peer_asn(self) -> int:
        """
        Peer ASN number.Example : 28
        """
        return pulumi.get(self, "peer_asn")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> int:
        """
        Vlan identifier. Example : 501
        """
        return pulumi.get(self, "vlan_id")

    @property
    @pulumi.getter(name="bfdConfiguration")
    def bfd_configuration(self) -> Optional['outputs.BfdConfigurationResponse']:
        """
        BFD configuration properties
        """
        return pulumi.get(self, "bfd_configuration")

    @property
    @pulumi.getter
    def mtu(self) -> Optional[int]:
        """
        MTU to use for option A peering.
        """
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter(name="primaryIpv4Prefix")
    def primary_ipv4_prefix(self) -> Optional[str]:
        """
        IPv4 Address Prefix of CE-PE interconnect links. Example: 172.31.0.0/31. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        """
        return pulumi.get(self, "primary_ipv4_prefix")

    @property
    @pulumi.getter(name="primaryIpv6Prefix")
    def primary_ipv6_prefix(self) -> Optional[str]:
        """
        IPv6 Address Prefix of CE-PE interconnect links. Example: 3FFE:FFFF:0:CD30::a0/126. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        """
        return pulumi.get(self, "primary_ipv6_prefix")

    @property
    @pulumi.getter(name="secondaryIpv4Prefix")
    def secondary_ipv4_prefix(self) -> Optional[str]:
        """
        Secondary IPv4 Address Prefix of CE-PE interconnect links. Example: 172.31.0.20/31. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        """
        return pulumi.get(self, "secondary_ipv4_prefix")

    @property
    @pulumi.getter(name="secondaryIpv6Prefix")
    def secondary_ipv6_prefix(self) -> Optional[str]:
        """
        Secondary IPv6 Address Prefix of CE-PE interconnect links. Example: 3FFE:FFFF:0:CD30::a4/126. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        """
        return pulumi.get(self, "secondary_ipv6_prefix")


@pulumi.output_type
class FabricBfdConfigurationResponse(dict):
    """
    BFD Configuration properties.
    """
    def __init__(__self__, *,
                 interval: int,
                 multiplier: int):
        """
        BFD Configuration properties.
        :param int interval: interval in seconds. Example: 300.
        :param int multiplier: multiplier. Example: 3.
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "multiplier", multiplier)

    @property
    @pulumi.getter
    def interval(self) -> int:
        """
        interval in seconds. Example: 300.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def multiplier(self) -> int:
        """
        multiplier. Example: 3.
        """
        return pulumi.get(self, "multiplier")


@pulumi.output_type
class FabricOptionBPropertiesResponse(dict):
    """
    Option B configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportRouteTargets":
            suggest = "export_route_targets"
        elif key == "importRouteTargets":
            suggest = "import_route_targets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FabricOptionBPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FabricOptionBPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FabricOptionBPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_route_targets: Sequence[str],
                 import_route_targets: Sequence[str]):
        """
        Option B configuration.
        :param Sequence[str] export_route_targets: Route Targets to be applied for outgoing routes from CE.
        :param Sequence[str] import_route_targets: Route Targets to be applied for incoming routes into CE.
        """
        pulumi.set(__self__, "export_route_targets", export_route_targets)
        pulumi.set(__self__, "import_route_targets", import_route_targets)

    @property
    @pulumi.getter(name="exportRouteTargets")
    def export_route_targets(self) -> Sequence[str]:
        """
        Route Targets to be applied for outgoing routes from CE.
        """
        return pulumi.get(self, "export_route_targets")

    @property
    @pulumi.getter(name="importRouteTargets")
    def import_route_targets(self) -> Sequence[str]:
        """
        Route Targets to be applied for incoming routes into CE.
        """
        return pulumi.get(self, "import_route_targets")


@pulumi.output_type
class InfrastructureServicesResponse(dict):
    """
    InfrastructureServices IP ranges.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4AddressSpaces":
            suggest = "ipv4_address_spaces"
        elif key == "ipv6AddressSpaces":
            suggest = "ipv6_address_spaces"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfrastructureServicesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfrastructureServicesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfrastructureServicesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4_address_spaces: Optional[Sequence[str]] = None,
                 ipv6_address_spaces: Optional[Sequence[str]] = None):
        """
        InfrastructureServices IP ranges.
        :param Sequence[str] ipv4_address_spaces: The IPv4 Address space is optional, if the value is not defined at the time of NFC creation, then the default value 10.0.0.0/19 is considered. The IPV4 address subnet is an optional attribute.
        :param Sequence[str] ipv6_address_spaces: The IPv6 is not supported right now.
        """
        if ipv4_address_spaces is not None:
            pulumi.set(__self__, "ipv4_address_spaces", ipv4_address_spaces)
        if ipv6_address_spaces is not None:
            pulumi.set(__self__, "ipv6_address_spaces", ipv6_address_spaces)

    @property
    @pulumi.getter(name="ipv4AddressSpaces")
    def ipv4_address_spaces(self) -> Optional[Sequence[str]]:
        """
        The IPv4 Address space is optional, if the value is not defined at the time of NFC creation, then the default value 10.0.0.0/19 is considered. The IPV4 address subnet is an optional attribute.
        """
        return pulumi.get(self, "ipv4_address_spaces")

    @property
    @pulumi.getter(name="ipv6AddressSpaces")
    def ipv6_address_spaces(self) -> Optional[Sequence[str]]:
        """
        The IPv6 is not supported right now.
        """
        return pulumi.get(self, "ipv6_address_spaces")


@pulumi.output_type
class IpCommunityIdListResponse(dict):
    """
    IP Community ID list properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipCommunityIds":
            suggest = "ip_community_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpCommunityIdListResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpCommunityIdListResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpCommunityIdListResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_community_ids: Optional[Sequence[str]] = None):
        """
        IP Community ID list properties.
        :param Sequence[str] ip_community_ids: List of IP Community resource IDs.
        """
        if ip_community_ids is not None:
            pulumi.set(__self__, "ip_community_ids", ip_community_ids)

    @property
    @pulumi.getter(name="ipCommunityIds")
    def ip_community_ids(self) -> Optional[Sequence[str]]:
        """
        List of IP Community resource IDs.
        """
        return pulumi.get(self, "ip_community_ids")


@pulumi.output_type
class IpExtendedCommunityIdListResponse(dict):
    """
    IP Extended Community Id list properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipExtendedCommunityIds":
            suggest = "ip_extended_community_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpExtendedCommunityIdListResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpExtendedCommunityIdListResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpExtendedCommunityIdListResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_extended_community_ids: Optional[Sequence[str]] = None):
        """
        IP Extended Community Id list properties.
        :param Sequence[str] ip_extended_community_ids: List of IP Extended Community resource IDs.
        """
        if ip_extended_community_ids is not None:
            pulumi.set(__self__, "ip_extended_community_ids", ip_extended_community_ids)

    @property
    @pulumi.getter(name="ipExtendedCommunityIds")
    def ip_extended_community_ids(self) -> Optional[Sequence[str]]:
        """
        List of IP Extended Community resource IDs.
        """
        return pulumi.get(self, "ip_extended_community_ids")


@pulumi.output_type
class IpGroupPropertiesResponse(dict):
    """
    IP Group properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddressType":
            suggest = "ip_address_type"
        elif key == "ipPrefixes":
            suggest = "ip_prefixes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpGroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpGroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpGroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address_type: Optional[str] = None,
                 ip_prefixes: Optional[Sequence[str]] = None,
                 name: Optional[str] = None):
        """
        IP Group properties.
        :param str ip_address_type: IP Address type.
        :param Sequence[str] ip_prefixes: List of IP Prefixes.
        :param str name: IP Group name.
        """
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)
        if ip_prefixes is not None:
            pulumi.set(__self__, "ip_prefixes", ip_prefixes)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[str]:
        """
        IP Address type.
        """
        return pulumi.get(self, "ip_address_type")

    @property
    @pulumi.getter(name="ipPrefixes")
    def ip_prefixes(self) -> Optional[Sequence[str]]:
        """
        List of IP Prefixes.
        """
        return pulumi.get(self, "ip_prefixes")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        IP Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class IpMatchConditionResponse(dict):
    """
    Defines the condition that can be filtered using the selected IPs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipGroupNames":
            suggest = "ip_group_names"
        elif key == "ipPrefixValues":
            suggest = "ip_prefix_values"
        elif key == "prefixType":
            suggest = "prefix_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpMatchConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpMatchConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpMatchConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_group_names: Optional[Sequence[str]] = None,
                 ip_prefix_values: Optional[Sequence[str]] = None,
                 prefix_type: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Defines the condition that can be filtered using the selected IPs.
        :param Sequence[str] ip_group_names: The List of IP Group Names that need to be matched.
        :param Sequence[str] ip_prefix_values: The list of IP Prefixes that need to be matched.
        :param str prefix_type: IP Prefix Type that needs to be matched.
        :param str type: IP Address type that needs to be matched.
        """
        if ip_group_names is not None:
            pulumi.set(__self__, "ip_group_names", ip_group_names)
        if ip_prefix_values is not None:
            pulumi.set(__self__, "ip_prefix_values", ip_prefix_values)
        if prefix_type is not None:
            pulumi.set(__self__, "prefix_type", prefix_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="ipGroupNames")
    def ip_group_names(self) -> Optional[Sequence[str]]:
        """
        The List of IP Group Names that need to be matched.
        """
        return pulumi.get(self, "ip_group_names")

    @property
    @pulumi.getter(name="ipPrefixValues")
    def ip_prefix_values(self) -> Optional[Sequence[str]]:
        """
        The list of IP Prefixes that need to be matched.
        """
        return pulumi.get(self, "ip_prefix_values")

    @property
    @pulumi.getter(name="prefixType")
    def prefix_type(self) -> Optional[str]:
        """
        IP Prefix Type that needs to be matched.
        """
        return pulumi.get(self, "prefix_type")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        IP Address type that needs to be matched.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class IpPrefixPropertiesResponseIpPrefixRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkPrefix":
            suggest = "network_prefix"
        elif key == "sequenceNumber":
            suggest = "sequence_number"
        elif key == "subnetMaskLength":
            suggest = "subnet_mask_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpPrefixPropertiesResponseIpPrefixRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpPrefixPropertiesResponseIpPrefixRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpPrefixPropertiesResponseIpPrefixRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 network_prefix: str,
                 sequence_number: float,
                 condition: Optional[str] = None,
                 subnet_mask_length: Optional[int] = None):
        """
        :param str action: Action to be taken on the configuration. Example: Permit | Deny.
        :param str network_prefix: Network Prefix specifying IPv4/IPv6 packets to be permitted or denied. Example: 1.1.1.0/24 | 3FFE:FFFF:0:CD30::/126 
        :param float sequence_number: Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        :param str condition: Specify prefix-list bounds.
        :param int subnet_mask_length: SubnetMaskLength gives the minimum NetworkPrefix length to be matched.Possible values for IPv4 are 1 - 32. Possible values of IPv6 are 1 - 128.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "network_prefix", network_prefix)
        pulumi.set(__self__, "sequence_number", sequence_number)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if subnet_mask_length is not None:
            pulumi.set(__self__, "subnet_mask_length", subnet_mask_length)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action to be taken on the configuration. Example: Permit | Deny.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="networkPrefix")
    def network_prefix(self) -> str:
        """
        Network Prefix specifying IPv4/IPv6 packets to be permitted or denied. Example: 1.1.1.0/24 | 3FFE:FFFF:0:CD30::/126 
        """
        return pulumi.get(self, "network_prefix")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> float:
        """
        Sequence to insert to/delete from existing route. Prefix lists are evaluated starting with the lowest sequence number and continue down the list until a match is made. Once a match is made, the permit or deny statement is applied to that network and the rest of the list is ignored.
        """
        return pulumi.get(self, "sequence_number")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        Specify prefix-list bounds.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="subnetMaskLength")
    def subnet_mask_length(self) -> Optional[int]:
        """
        SubnetMaskLength gives the minimum NetworkPrefix length to be matched.Possible values for IPv4 are 1 - 32. Possible values of IPv6 are 1 - 128.
        """
        return pulumi.get(self, "subnet_mask_length")


@pulumi.output_type
class IsolationDomainPropertiesResponse(dict):
    """
    Isolation Domain Properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "neighborGroupIds":
            suggest = "neighbor_group_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IsolationDomainPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IsolationDomainPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IsolationDomainPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encapsulation: Optional[str] = None,
                 neighbor_group_ids: Optional[Sequence[str]] = None):
        """
        Isolation Domain Properties.
        :param str encapsulation: Type of encapsulation.
        :param Sequence[str] neighbor_group_ids: List of Neighbor Group IDs.
        """
        if encapsulation is not None:
            pulumi.set(__self__, "encapsulation", encapsulation)
        if neighbor_group_ids is not None:
            pulumi.set(__self__, "neighbor_group_ids", neighbor_group_ids)

    @property
    @pulumi.getter
    def encapsulation(self) -> Optional[str]:
        """
        Type of encapsulation.
        """
        return pulumi.get(self, "encapsulation")

    @property
    @pulumi.getter(name="neighborGroupIds")
    def neighbor_group_ids(self) -> Optional[Sequence[str]]:
        """
        List of Neighbor Group IDs.
        """
        return pulumi.get(self, "neighbor_group_ids")


@pulumi.output_type
class L3IsolationDomainPatchPropertiesResponseConnectedSubnetRoutePolicy(dict):
    """
    Connected Subnet RoutePolicy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "administrativeState":
            suggest = "administrative_state"
        elif key == "exportRoutePolicyId":
            suggest = "export_route_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in L3IsolationDomainPatchPropertiesResponseConnectedSubnetRoutePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        L3IsolationDomainPatchPropertiesResponseConnectedSubnetRoutePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        L3IsolationDomainPatchPropertiesResponseConnectedSubnetRoutePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 administrative_state: str,
                 export_route_policy_id: Optional[str] = None):
        """
        Connected Subnet RoutePolicy
        :param str administrative_state: Enabled/Disabled connected subnet route policy. Ex: Enabled | Disabled.
        :param str export_route_policy_id: exportRoutePolicyId value.
        """
        pulumi.set(__self__, "administrative_state", administrative_state)
        if export_route_policy_id is not None:
            pulumi.set(__self__, "export_route_policy_id", export_route_policy_id)

    @property
    @pulumi.getter(name="administrativeState")
    def administrative_state(self) -> str:
        """
        Enabled/Disabled connected subnet route policy. Ex: Enabled | Disabled.
        """
        return pulumi.get(self, "administrative_state")

    @property
    @pulumi.getter(name="exportRoutePolicyId")
    def export_route_policy_id(self) -> Optional[str]:
        """
        exportRoutePolicyId value.
        """
        return pulumi.get(self, "export_route_policy_id")


@pulumi.output_type
class Layer2ConfigurationResponse(dict):
    """
    layer2Configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portCount":
            suggest = "port_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Layer2ConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Layer2ConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Layer2ConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interfaces: Sequence[str],
                 mtu: Optional[int] = None,
                 port_count: Optional[int] = None):
        """
        layer2Configuration
        :param Sequence[str] interfaces: List of network device interfaces resource IDs.
        :param int mtu: MTU of the packets between PE & CE.
        :param int port_count: Number of ports connected between PE/CE. Maximum value depends on FabricSKU.
        """
        pulumi.set(__self__, "interfaces", interfaces)
        if mtu is None:
            mtu = 1500
        pulumi.set(__self__, "mtu", mtu)
        if port_count is not None:
            pulumi.set(__self__, "port_count", port_count)

    @property
    @pulumi.getter
    def interfaces(self) -> Sequence[str]:
        """
        List of network device interfaces resource IDs.
        """
        return pulumi.get(self, "interfaces")

    @property
    @pulumi.getter
    def mtu(self) -> int:
        """
        MTU of the packets between PE & CE.
        """
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter(name="portCount")
    def port_count(self) -> Optional[int]:
        """
        Number of ports connected between PE/CE. Maximum value depends on FabricSKU.
        """
        return pulumi.get(self, "port_count")


@pulumi.output_type
class Layer3ConfigurationResponse(dict):
    """
    layer3Configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fabricASN":
            suggest = "fabric_asn"
        elif key == "exportRoutePolicyId":
            suggest = "export_route_policy_id"
        elif key == "importRoutePolicyId":
            suggest = "import_route_policy_id"
        elif key == "peerASN":
            suggest = "peer_asn"
        elif key == "primaryIpv4Prefix":
            suggest = "primary_ipv4_prefix"
        elif key == "primaryIpv6Prefix":
            suggest = "primary_ipv6_prefix"
        elif key == "secondaryIpv4Prefix":
            suggest = "secondary_ipv4_prefix"
        elif key == "secondaryIpv6Prefix":
            suggest = "secondary_ipv6_prefix"
        elif key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Layer3ConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Layer3ConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Layer3ConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fabric_asn: int,
                 export_route_policy_id: Optional[str] = None,
                 import_route_policy_id: Optional[str] = None,
                 peer_asn: Optional[int] = None,
                 primary_ipv4_prefix: Optional[str] = None,
                 primary_ipv6_prefix: Optional[str] = None,
                 secondary_ipv4_prefix: Optional[str] = None,
                 secondary_ipv6_prefix: Optional[str] = None,
                 vlan_id: Optional[int] = None):
        """
        layer3Configuration
        :param int fabric_asn: ASN of CE devices for CE/PE connectivity.
        :param str export_route_policy_id: exportRoutePolicyId
        :param str import_route_policy_id: importRoutePolicyId
        :param int peer_asn: ASN of PE devices for CE/PE connectivity.Example : 28
        :param str primary_ipv4_prefix: IPv4 Address Prefix of CE-PE interconnect links. Example: 172.31.0.0/31. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        :param str primary_ipv6_prefix: IPv6 Address Prefix of CE-PE interconnect links. Example: 3FFE:FFFF:0:CD30::a0/126. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        :param str secondary_ipv4_prefix: Secondary IPv4 Address Prefix of CE-PE interconnect links. Example: 172.31.0.20/31. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        :param str secondary_ipv6_prefix: Secondary IPv6 Address Prefix of CE-PE interconnect links. Example: 3FFE:FFFF:0:CD30::a4/126. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        :param int vlan_id: VLAN for CE/PE Layer 3 connectivity.Example : 501
        """
        pulumi.set(__self__, "fabric_asn", fabric_asn)
        if export_route_policy_id is not None:
            pulumi.set(__self__, "export_route_policy_id", export_route_policy_id)
        if import_route_policy_id is not None:
            pulumi.set(__self__, "import_route_policy_id", import_route_policy_id)
        if peer_asn is not None:
            pulumi.set(__self__, "peer_asn", peer_asn)
        if primary_ipv4_prefix is not None:
            pulumi.set(__self__, "primary_ipv4_prefix", primary_ipv4_prefix)
        if primary_ipv6_prefix is not None:
            pulumi.set(__self__, "primary_ipv6_prefix", primary_ipv6_prefix)
        if secondary_ipv4_prefix is not None:
            pulumi.set(__self__, "secondary_ipv4_prefix", secondary_ipv4_prefix)
        if secondary_ipv6_prefix is not None:
            pulumi.set(__self__, "secondary_ipv6_prefix", secondary_ipv6_prefix)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter(name="fabricASN")
    def fabric_asn(self) -> int:
        """
        ASN of CE devices for CE/PE connectivity.
        """
        return pulumi.get(self, "fabric_asn")

    @property
    @pulumi.getter(name="exportRoutePolicyId")
    def export_route_policy_id(self) -> Optional[str]:
        """
        exportRoutePolicyId
        """
        return pulumi.get(self, "export_route_policy_id")

    @property
    @pulumi.getter(name="importRoutePolicyId")
    def import_route_policy_id(self) -> Optional[str]:
        """
        importRoutePolicyId
        """
        return pulumi.get(self, "import_route_policy_id")

    @property
    @pulumi.getter(name="peerASN")
    def peer_asn(self) -> Optional[int]:
        """
        ASN of PE devices for CE/PE connectivity.Example : 28
        """
        return pulumi.get(self, "peer_asn")

    @property
    @pulumi.getter(name="primaryIpv4Prefix")
    def primary_ipv4_prefix(self) -> Optional[str]:
        """
        IPv4 Address Prefix of CE-PE interconnect links. Example: 172.31.0.0/31. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        """
        return pulumi.get(self, "primary_ipv4_prefix")

    @property
    @pulumi.getter(name="primaryIpv6Prefix")
    def primary_ipv6_prefix(self) -> Optional[str]:
        """
        IPv6 Address Prefix of CE-PE interconnect links. Example: 3FFE:FFFF:0:CD30::a0/126. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        """
        return pulumi.get(self, "primary_ipv6_prefix")

    @property
    @pulumi.getter(name="secondaryIpv4Prefix")
    def secondary_ipv4_prefix(self) -> Optional[str]:
        """
        Secondary IPv4 Address Prefix of CE-PE interconnect links. Example: 172.31.0.20/31. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        """
        return pulumi.get(self, "secondary_ipv4_prefix")

    @property
    @pulumi.getter(name="secondaryIpv6Prefix")
    def secondary_ipv6_prefix(self) -> Optional[str]:
        """
        Secondary IPv6 Address Prefix of CE-PE interconnect links. Example: 3FFE:FFFF:0:CD30::a4/126. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        """
        return pulumi.get(self, "secondary_ipv6_prefix")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[int]:
        """
        VLAN for CE/PE Layer 3 connectivity.Example : 501
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class ManagedResourceGroupConfigurationResponse(dict):
    """
    Managed Resource Group configuration properties.
    """
    def __init__(__self__, *,
                 location: Optional[str] = None,
                 name: Optional[str] = None):
        """
        Managed Resource Group configuration properties.
        :param str location: Managed resource group location.
        :param str name: The NFC service will be hosted in a Managed resource group.
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Managed resource group location.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The NFC service will be hosted in a Managed resource group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ManagementNetworkConfigurationResponse(dict):
    """
    Configuration to be used to setup the management network.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infrastructureVpnConfiguration":
            suggest = "infrastructure_vpn_configuration"
        elif key == "workloadVpnConfiguration":
            suggest = "workload_vpn_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementNetworkConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementNetworkConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementNetworkConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 infrastructure_vpn_configuration: 'outputs.VpnConfigurationPropertiesResponse',
                 workload_vpn_configuration: 'outputs.VpnConfigurationPropertiesResponse'):
        """
        Configuration to be used to setup the management network.
        :param 'VpnConfigurationPropertiesResponse' infrastructure_vpn_configuration: Configuration for infrastructure vpn.
        :param 'VpnConfigurationPropertiesResponse' workload_vpn_configuration: Configuration for workload vpn.
        """
        pulumi.set(__self__, "infrastructure_vpn_configuration", infrastructure_vpn_configuration)
        pulumi.set(__self__, "workload_vpn_configuration", workload_vpn_configuration)

    @property
    @pulumi.getter(name="infrastructureVpnConfiguration")
    def infrastructure_vpn_configuration(self) -> 'outputs.VpnConfigurationPropertiesResponse':
        """
        Configuration for infrastructure vpn.
        """
        return pulumi.get(self, "infrastructure_vpn_configuration")

    @property
    @pulumi.getter(name="workloadVpnConfiguration")
    def workload_vpn_configuration(self) -> 'outputs.VpnConfigurationPropertiesResponse':
        """
        Configuration for workload vpn.
        """
        return pulumi.get(self, "workload_vpn_configuration")


@pulumi.output_type
class NeighborAddressResponse(dict):
    """
    Neighbor Address properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operationalState":
            suggest = "operational_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NeighborAddressResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NeighborAddressResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NeighborAddressResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operational_state: str,
                 address: Optional[str] = None):
        """
        Neighbor Address properties.
        :param str operational_state: OperationalState of the NeighborAddress.
        :param str address: IP Address.
        """
        pulumi.set(__self__, "operational_state", operational_state)
        if address is not None:
            pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter(name="operationalState")
    def operational_state(self) -> str:
        """
        OperationalState of the NeighborAddress.
        """
        return pulumi.get(self, "operational_state")

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        IP Address.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class NeighborGroupDestinationResponse(dict):
    """
    An array of destination IPv4 Addresses or IPv6 Addresses.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4Addresses":
            suggest = "ipv4_addresses"
        elif key == "ipv6Addresses":
            suggest = "ipv6_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NeighborGroupDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NeighborGroupDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NeighborGroupDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4_addresses: Optional[Sequence[str]] = None,
                 ipv6_addresses: Optional[Sequence[str]] = None):
        """
        An array of destination IPv4 Addresses or IPv6 Addresses.
        :param Sequence[str] ipv4_addresses: Array of IPv4 Addresses.
        :param Sequence[str] ipv6_addresses: Array of IPv6 Addresses.
        """
        if ipv4_addresses is not None:
            pulumi.set(__self__, "ipv4_addresses", ipv4_addresses)
        if ipv6_addresses is not None:
            pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)

    @property
    @pulumi.getter(name="ipv4Addresses")
    def ipv4_addresses(self) -> Optional[Sequence[str]]:
        """
        Array of IPv4 Addresses.
        """
        return pulumi.get(self, "ipv4_addresses")

    @property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[Sequence[str]]:
        """
        Array of IPv6 Addresses.
        """
        return pulumi.get(self, "ipv6_addresses")


@pulumi.output_type
class NetworkTapPropertiesResponseDestinations(dict):
    """
    Destination.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationId":
            suggest = "destination_id"
        elif key == "destinationType":
            suggest = "destination_type"
        elif key == "destinationTapRuleId":
            suggest = "destination_tap_rule_id"
        elif key == "isolationDomainProperties":
            suggest = "isolation_domain_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkTapPropertiesResponseDestinations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkTapPropertiesResponseDestinations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkTapPropertiesResponseDestinations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_id: str,
                 destination_type: str,
                 name: str,
                 destination_tap_rule_id: Optional[str] = None,
                 isolation_domain_properties: Optional['outputs.IsolationDomainPropertiesResponse'] = None):
        """
        Destination.
        :param str destination_id: The destination Id. ARM Resource ID of either NNI or Internal Networks.
        :param str destination_type: Type of destination. Input can be IsolationDomain or Direct.
        :param str name: Destination name.
        :param str destination_tap_rule_id: ARM Resource ID of destination Tap Rule that contains match configurations.
        :param 'IsolationDomainPropertiesResponse' isolation_domain_properties: Isolation Domain Properties.
        """
        pulumi.set(__self__, "destination_id", destination_id)
        pulumi.set(__self__, "destination_type", destination_type)
        pulumi.set(__self__, "name", name)
        if destination_tap_rule_id is not None:
            pulumi.set(__self__, "destination_tap_rule_id", destination_tap_rule_id)
        if isolation_domain_properties is not None:
            pulumi.set(__self__, "isolation_domain_properties", isolation_domain_properties)

    @property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> str:
        """
        The destination Id. ARM Resource ID of either NNI or Internal Networks.
        """
        return pulumi.get(self, "destination_id")

    @property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> str:
        """
        Type of destination. Input can be IsolationDomain or Direct.
        """
        return pulumi.get(self, "destination_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Destination name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="destinationTapRuleId")
    def destination_tap_rule_id(self) -> Optional[str]:
        """
        ARM Resource ID of destination Tap Rule that contains match configurations.
        """
        return pulumi.get(self, "destination_tap_rule_id")

    @property
    @pulumi.getter(name="isolationDomainProperties")
    def isolation_domain_properties(self) -> Optional['outputs.IsolationDomainPropertiesResponse']:
        """
        Isolation Domain Properties.
        """
        return pulumi.get(self, "isolation_domain_properties")


@pulumi.output_type
class NetworkTapRuleActionResponse(dict):
    """
    Action that need to performed.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationId":
            suggest = "destination_id"
        elif key == "isTimestampEnabled":
            suggest = "is_timestamp_enabled"
        elif key == "matchConfigurationName":
            suggest = "match_configuration_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkTapRuleActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkTapRuleActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkTapRuleActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_id: Optional[str] = None,
                 is_timestamp_enabled: Optional[str] = None,
                 match_configuration_name: Optional[str] = None,
                 truncate: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Action that need to performed.
        :param str destination_id: Destination Id. The ARM resource Id may be either Network To Network Interconnect or NeighborGroup.
        :param str is_timestamp_enabled: The parameter to enable or disable the timestamp.
        :param str match_configuration_name: The name of the match configuration. This is used when Goto type is provided. If Goto type is selected and no match configuration name is provided. It goes to next configuration.
        :param str truncate: Truncate. 0 indicates do not truncate.
        :param str type: Type of actions that can be performed.
        """
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if is_timestamp_enabled is not None:
            pulumi.set(__self__, "is_timestamp_enabled", is_timestamp_enabled)
        if match_configuration_name is not None:
            pulumi.set(__self__, "match_configuration_name", match_configuration_name)
        if truncate is not None:
            pulumi.set(__self__, "truncate", truncate)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[str]:
        """
        Destination Id. The ARM resource Id may be either Network To Network Interconnect or NeighborGroup.
        """
        return pulumi.get(self, "destination_id")

    @property
    @pulumi.getter(name="isTimestampEnabled")
    def is_timestamp_enabled(self) -> Optional[str]:
        """
        The parameter to enable or disable the timestamp.
        """
        return pulumi.get(self, "is_timestamp_enabled")

    @property
    @pulumi.getter(name="matchConfigurationName")
    def match_configuration_name(self) -> Optional[str]:
        """
        The name of the match configuration. This is used when Goto type is provided. If Goto type is selected and no match configuration name is provided. It goes to next configuration.
        """
        return pulumi.get(self, "match_configuration_name")

    @property
    @pulumi.getter
    def truncate(self) -> Optional[str]:
        """
        Truncate. 0 indicates do not truncate.
        """
        return pulumi.get(self, "truncate")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of actions that can be performed.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NetworkTapRuleMatchConditionResponse(dict):
    """
    Defines the match condition that is supported to filter the traffic.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encapsulationType":
            suggest = "encapsulation_type"
        elif key == "ipCondition":
            suggest = "ip_condition"
        elif key == "portCondition":
            suggest = "port_condition"
        elif key == "protocolTypes":
            suggest = "protocol_types"
        elif key == "vlanMatchCondition":
            suggest = "vlan_match_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkTapRuleMatchConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkTapRuleMatchConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkTapRuleMatchConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encapsulation_type: Optional[str] = None,
                 ip_condition: Optional['outputs.IpMatchConditionResponse'] = None,
                 port_condition: Optional['outputs.PortConditionResponse'] = None,
                 protocol_types: Optional[Sequence[str]] = None,
                 vlan_match_condition: Optional['outputs.VlanMatchConditionResponse'] = None):
        """
        Defines the match condition that is supported to filter the traffic.
        :param str encapsulation_type: Encapsulation Type that needs to be matched.
        :param 'IpMatchConditionResponse' ip_condition: IP condition that needs to be matched.
        :param 'PortConditionResponse' port_condition: Defines the port condition that needs to be matched.
        :param Sequence[str] protocol_types: List of the protocols that need to be matched.
        :param 'VlanMatchConditionResponse' vlan_match_condition: Vlan match condition that needs to be matched.
        """
        if encapsulation_type is None:
            encapsulation_type = 'None'
        if encapsulation_type is not None:
            pulumi.set(__self__, "encapsulation_type", encapsulation_type)
        if ip_condition is not None:
            pulumi.set(__self__, "ip_condition", ip_condition)
        if port_condition is not None:
            pulumi.set(__self__, "port_condition", port_condition)
        if protocol_types is not None:
            pulumi.set(__self__, "protocol_types", protocol_types)
        if vlan_match_condition is not None:
            pulumi.set(__self__, "vlan_match_condition", vlan_match_condition)

    @property
    @pulumi.getter(name="encapsulationType")
    def encapsulation_type(self) -> Optional[str]:
        """
        Encapsulation Type that needs to be matched.
        """
        return pulumi.get(self, "encapsulation_type")

    @property
    @pulumi.getter(name="ipCondition")
    def ip_condition(self) -> Optional['outputs.IpMatchConditionResponse']:
        """
        IP condition that needs to be matched.
        """
        return pulumi.get(self, "ip_condition")

    @property
    @pulumi.getter(name="portCondition")
    def port_condition(self) -> Optional['outputs.PortConditionResponse']:
        """
        Defines the port condition that needs to be matched.
        """
        return pulumi.get(self, "port_condition")

    @property
    @pulumi.getter(name="protocolTypes")
    def protocol_types(self) -> Optional[Sequence[str]]:
        """
        List of the protocols that need to be matched.
        """
        return pulumi.get(self, "protocol_types")

    @property
    @pulumi.getter(name="vlanMatchCondition")
    def vlan_match_condition(self) -> Optional['outputs.VlanMatchConditionResponse']:
        """
        Vlan match condition that needs to be matched.
        """
        return pulumi.get(self, "vlan_match_condition")


@pulumi.output_type
class NetworkTapRuleMatchConfigurationResponse(dict):
    """
    Defines the match configuration that are supported to filter the traffic.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddressType":
            suggest = "ip_address_type"
        elif key == "matchConditions":
            suggest = "match_conditions"
        elif key == "matchConfigurationName":
            suggest = "match_configuration_name"
        elif key == "sequenceNumber":
            suggest = "sequence_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkTapRuleMatchConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkTapRuleMatchConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkTapRuleMatchConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Optional[Sequence['outputs.NetworkTapRuleActionResponse']] = None,
                 ip_address_type: Optional[str] = None,
                 match_conditions: Optional[Sequence['outputs.NetworkTapRuleMatchConditionResponse']] = None,
                 match_configuration_name: Optional[str] = None,
                 sequence_number: Optional[float] = None):
        """
        Defines the match configuration that are supported to filter the traffic.
        :param Sequence['NetworkTapRuleActionResponse'] actions: List of actions that need to be performed for the matched conditions.
        :param str ip_address_type: Type of IP Address. IPv4 or IPv6
        :param Sequence['NetworkTapRuleMatchConditionResponse'] match_conditions: List of the match conditions.
        :param str match_configuration_name: The name of the match configuration.
        :param float sequence_number: Sequence Number of the match configuration..
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)
        if match_conditions is not None:
            pulumi.set(__self__, "match_conditions", match_conditions)
        if match_configuration_name is not None:
            pulumi.set(__self__, "match_configuration_name", match_configuration_name)
        if sequence_number is not None:
            pulumi.set(__self__, "sequence_number", sequence_number)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.NetworkTapRuleActionResponse']]:
        """
        List of actions that need to be performed for the matched conditions.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[str]:
        """
        Type of IP Address. IPv4 or IPv6
        """
        return pulumi.get(self, "ip_address_type")

    @property
    @pulumi.getter(name="matchConditions")
    def match_conditions(self) -> Optional[Sequence['outputs.NetworkTapRuleMatchConditionResponse']]:
        """
        List of the match conditions.
        """
        return pulumi.get(self, "match_conditions")

    @property
    @pulumi.getter(name="matchConfigurationName")
    def match_configuration_name(self) -> Optional[str]:
        """
        The name of the match configuration.
        """
        return pulumi.get(self, "match_configuration_name")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> Optional[float]:
        """
        Sequence Number of the match configuration..
        """
        return pulumi.get(self, "sequence_number")


@pulumi.output_type
class OptionAPropertiesResponse(dict):
    """
    Peering optionA properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bfdConfiguration":
            suggest = "bfd_configuration"
        elif key == "peerASN":
            suggest = "peer_asn"
        elif key == "primaryIpv4Prefix":
            suggest = "primary_ipv4_prefix"
        elif key == "primaryIpv6Prefix":
            suggest = "primary_ipv6_prefix"
        elif key == "secondaryIpv4Prefix":
            suggest = "secondary_ipv4_prefix"
        elif key == "secondaryIpv6Prefix":
            suggest = "secondary_ipv6_prefix"
        elif key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OptionAPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OptionAPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OptionAPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bfd_configuration: Optional['outputs.FabricBfdConfigurationResponse'] = None,
                 mtu: Optional[int] = None,
                 peer_asn: Optional[int] = None,
                 primary_ipv4_prefix: Optional[str] = None,
                 primary_ipv6_prefix: Optional[str] = None,
                 secondary_ipv4_prefix: Optional[str] = None,
                 secondary_ipv6_prefix: Optional[str] = None,
                 vlan_id: Optional[int] = None):
        """
        Peering optionA properties
        :param 'FabricBfdConfigurationResponse' bfd_configuration: BFD Configuration properties.
        :param int mtu: MTU to use for option A peering.
        :param int peer_asn: Peer ASN number.Example : 28
        :param str primary_ipv4_prefix: IPv4 Address Prefix of CE-PE interconnect links. Example: 172.31.0.0/31. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        :param str primary_ipv6_prefix: IPv6 Address Prefix of CE-PE interconnect links. Example: 3FFE:FFFF:0:CD30::a0/126. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        :param str secondary_ipv4_prefix: Secondary IPv4 Address Prefix of CE-PE interconnect links. Example: 172.31.0.20/31. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        :param str secondary_ipv6_prefix: Secondary IPv6 Address Prefix of CE-PE interconnect links. Example: 3FFE:FFFF:0:CD30::a4/126. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        :param int vlan_id: Vlan identifier. Example : 501
        """
        if bfd_configuration is not None:
            pulumi.set(__self__, "bfd_configuration", bfd_configuration)
        if mtu is None:
            mtu = 1500
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if peer_asn is not None:
            pulumi.set(__self__, "peer_asn", peer_asn)
        if primary_ipv4_prefix is not None:
            pulumi.set(__self__, "primary_ipv4_prefix", primary_ipv4_prefix)
        if primary_ipv6_prefix is not None:
            pulumi.set(__self__, "primary_ipv6_prefix", primary_ipv6_prefix)
        if secondary_ipv4_prefix is not None:
            pulumi.set(__self__, "secondary_ipv4_prefix", secondary_ipv4_prefix)
        if secondary_ipv6_prefix is not None:
            pulumi.set(__self__, "secondary_ipv6_prefix", secondary_ipv6_prefix)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter(name="bfdConfiguration")
    def bfd_configuration(self) -> Optional['outputs.FabricBfdConfigurationResponse']:
        """
        BFD Configuration properties.
        """
        return pulumi.get(self, "bfd_configuration")

    @property
    @pulumi.getter
    def mtu(self) -> Optional[int]:
        """
        MTU to use for option A peering.
        """
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter(name="peerASN")
    def peer_asn(self) -> Optional[int]:
        """
        Peer ASN number.Example : 28
        """
        return pulumi.get(self, "peer_asn")

    @property
    @pulumi.getter(name="primaryIpv4Prefix")
    def primary_ipv4_prefix(self) -> Optional[str]:
        """
        IPv4 Address Prefix of CE-PE interconnect links. Example: 172.31.0.0/31. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        """
        return pulumi.get(self, "primary_ipv4_prefix")

    @property
    @pulumi.getter(name="primaryIpv6Prefix")
    def primary_ipv6_prefix(self) -> Optional[str]:
        """
        IPv6 Address Prefix of CE-PE interconnect links. Example: 3FFE:FFFF:0:CD30::a0/126. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        """
        return pulumi.get(self, "primary_ipv6_prefix")

    @property
    @pulumi.getter(name="secondaryIpv4Prefix")
    def secondary_ipv4_prefix(self) -> Optional[str]:
        """
        Secondary IPv4 Address Prefix of CE-PE interconnect links. Example: 172.31.0.20/31. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        """
        return pulumi.get(self, "secondary_ipv4_prefix")

    @property
    @pulumi.getter(name="secondaryIpv6Prefix")
    def secondary_ipv6_prefix(self) -> Optional[str]:
        """
        Secondary IPv6 Address Prefix of CE-PE interconnect links. Example: 3FFE:FFFF:0:CD30::a4/126. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        """
        return pulumi.get(self, "secondary_ipv6_prefix")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[int]:
        """
        Vlan identifier. Example : 501
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class OptionBPropertiesResponse(dict):
    """
    Option B configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportRouteTargets":
            suggest = "export_route_targets"
        elif key == "importRouteTargets":
            suggest = "import_route_targets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OptionBPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OptionBPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OptionBPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_route_targets: Optional[Sequence[str]] = None,
                 import_route_targets: Optional[Sequence[str]] = None):
        """
        Option B configuration.
        :param Sequence[str] export_route_targets: Route Targets to be applied for outgoing routes from CE.
        :param Sequence[str] import_route_targets: Route Targets to be applied for incoming routes into CE.
        """
        if export_route_targets is not None:
            pulumi.set(__self__, "export_route_targets", export_route_targets)
        if import_route_targets is not None:
            pulumi.set(__self__, "import_route_targets", import_route_targets)

    @property
    @pulumi.getter(name="exportRouteTargets")
    def export_route_targets(self) -> Optional[Sequence[str]]:
        """
        Route Targets to be applied for outgoing routes from CE.
        """
        return pulumi.get(self, "export_route_targets")

    @property
    @pulumi.getter(name="importRouteTargets")
    def import_route_targets(self) -> Optional[Sequence[str]]:
        """
        Route Targets to be applied for incoming routes into CE.
        """
        return pulumi.get(self, "import_route_targets")


@pulumi.output_type
class PortConditionResponse(dict):
    """
    Port condition that needs to be matched.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layer4Protocol":
            suggest = "layer4_protocol"
        elif key == "portGroupNames":
            suggest = "port_group_names"
        elif key == "portType":
            suggest = "port_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layer4_protocol: str,
                 port_group_names: Optional[Sequence[str]] = None,
                 port_type: Optional[str] = None,
                 ports: Optional[Sequence[str]] = None):
        """
        Port condition that needs to be matched.
        :param str layer4_protocol: Layer4 protocol type that needs to be matched.
        :param Sequence[str] port_group_names: List of the port Group Names that need to be matched.
        :param str port_type: Port type that needs to be matched.
        :param Sequence[str] ports: List of the Ports that need to be matched.
        """
        pulumi.set(__self__, "layer4_protocol", layer4_protocol)
        if port_group_names is not None:
            pulumi.set(__self__, "port_group_names", port_group_names)
        if port_type is not None:
            pulumi.set(__self__, "port_type", port_type)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter(name="layer4Protocol")
    def layer4_protocol(self) -> str:
        """
        Layer4 protocol type that needs to be matched.
        """
        return pulumi.get(self, "layer4_protocol")

    @property
    @pulumi.getter(name="portGroupNames")
    def port_group_names(self) -> Optional[Sequence[str]]:
        """
        List of the port Group Names that need to be matched.
        """
        return pulumi.get(self, "port_group_names")

    @property
    @pulumi.getter(name="portType")
    def port_type(self) -> Optional[str]:
        """
        Port type that needs to be matched.
        """
        return pulumi.get(self, "port_type")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[str]]:
        """
        List of the Ports that need to be matched.
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class PortGroupPropertiesResponse(dict):
    """
    Port Group properties.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 ports: Optional[Sequence[str]] = None):
        """
        Port Group properties.
        :param str name: The name of the port group.
        :param Sequence[str] ports: List of the ports that need to be matched.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the port group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[str]]:
        """
        List of the ports that need to be matched.
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class RoutePolicyStatementPropertiesResponse(dict):
    """
    Route Policy Statement properties..
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sequenceNumber":
            suggest = "sequence_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoutePolicyStatementPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoutePolicyStatementPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoutePolicyStatementPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: 'outputs.StatementActionPropertiesResponse',
                 condition: 'outputs.StatementConditionPropertiesResponse',
                 sequence_number: float,
                 annotation: Optional[str] = None):
        """
        Route Policy Statement properties..
        :param 'StatementActionPropertiesResponse' action: Route policy action properties.
        :param 'StatementConditionPropertiesResponse' condition: Route policy condition properties.
        :param float sequence_number: Sequence to insert to/delete from existing route.
        :param str annotation: Switch configuration description.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "sequence_number", sequence_number)
        if annotation is not None:
            pulumi.set(__self__, "annotation", annotation)

    @property
    @pulumi.getter
    def action(self) -> 'outputs.StatementActionPropertiesResponse':
        """
        Route policy action properties.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.StatementConditionPropertiesResponse':
        """
        Route policy condition properties.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> float:
        """
        Sequence to insert to/delete from existing route.
        """
        return pulumi.get(self, "sequence_number")

    @property
    @pulumi.getter
    def annotation(self) -> Optional[str]:
        """
        Switch configuration description.
        """
        return pulumi.get(self, "annotation")


@pulumi.output_type
class RulePropertiesResponse(dict):
    """
    Rules for the InternetGateways
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressList":
            suggest = "address_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 address_list: Sequence[str]):
        """
        Rules for the InternetGateways
        :param str action: Specify action.
        :param Sequence[str] address_list: List of Addresses to be allowed or denied.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "address_list", address_list)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Specify action.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="addressList")
    def address_list(self) -> Sequence[str]:
        """
        List of Addresses to be allowed or denied.
        """
        return pulumi.get(self, "address_list")


@pulumi.output_type
class StatementActionPropertiesResponse(dict):
    """
    Route policy action properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "ipCommunityProperties":
            suggest = "ip_community_properties"
        elif key == "ipExtendedCommunityProperties":
            suggest = "ip_extended_community_properties"
        elif key == "localPreference":
            suggest = "local_preference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatementActionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatementActionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatementActionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: str,
                 ip_community_properties: Optional['outputs.ActionIpCommunityPropertiesResponse'] = None,
                 ip_extended_community_properties: Optional['outputs.ActionIpExtendedCommunityPropertiesResponse'] = None,
                 local_preference: Optional[float] = None):
        """
        Route policy action properties.
        :param str action_type: action. Example: Permit | Deny.
        :param 'ActionIpCommunityPropertiesResponse' ip_community_properties: IP Community Properties.
        :param 'ActionIpExtendedCommunityPropertiesResponse' ip_extended_community_properties: IP Extended Community Properties.
        :param float local_preference: localPreference of the route policy.
        """
        pulumi.set(__self__, "action_type", action_type)
        if ip_community_properties is not None:
            pulumi.set(__self__, "ip_community_properties", ip_community_properties)
        if ip_extended_community_properties is not None:
            pulumi.set(__self__, "ip_extended_community_properties", ip_extended_community_properties)
        if local_preference is not None:
            pulumi.set(__self__, "local_preference", local_preference)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        action. Example: Permit | Deny.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="ipCommunityProperties")
    def ip_community_properties(self) -> Optional['outputs.ActionIpCommunityPropertiesResponse']:
        """
        IP Community Properties.
        """
        return pulumi.get(self, "ip_community_properties")

    @property
    @pulumi.getter(name="ipExtendedCommunityProperties")
    def ip_extended_community_properties(self) -> Optional['outputs.ActionIpExtendedCommunityPropertiesResponse']:
        """
        IP Extended Community Properties.
        """
        return pulumi.get(self, "ip_extended_community_properties")

    @property
    @pulumi.getter(name="localPreference")
    def local_preference(self) -> Optional[float]:
        """
        localPreference of the route policy.
        """
        return pulumi.get(self, "local_preference")


@pulumi.output_type
class StatementConditionPropertiesResponse(dict):
    """
    Route policy statement condition properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipCommunityIds":
            suggest = "ip_community_ids"
        elif key == "ipExtendedCommunityIds":
            suggest = "ip_extended_community_ids"
        elif key == "ipPrefixId":
            suggest = "ip_prefix_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatementConditionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatementConditionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatementConditionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_community_ids: Optional[Sequence[str]] = None,
                 ip_extended_community_ids: Optional[Sequence[str]] = None,
                 ip_prefix_id: Optional[str] = None):
        """
        Route policy statement condition properties.
        :param Sequence[str] ip_community_ids: List of IP Community resource IDs.
        :param Sequence[str] ip_extended_community_ids: List of IP Extended Community resource IDs.
        :param str ip_prefix_id: Arm Resource Id of IpPrefix.
        """
        if ip_community_ids is not None:
            pulumi.set(__self__, "ip_community_ids", ip_community_ids)
        if ip_extended_community_ids is not None:
            pulumi.set(__self__, "ip_extended_community_ids", ip_extended_community_ids)
        if ip_prefix_id is not None:
            pulumi.set(__self__, "ip_prefix_id", ip_prefix_id)

    @property
    @pulumi.getter(name="ipCommunityIds")
    def ip_community_ids(self) -> Optional[Sequence[str]]:
        """
        List of IP Community resource IDs.
        """
        return pulumi.get(self, "ip_community_ids")

    @property
    @pulumi.getter(name="ipExtendedCommunityIds")
    def ip_extended_community_ids(self) -> Optional[Sequence[str]]:
        """
        List of IP Extended Community resource IDs.
        """
        return pulumi.get(self, "ip_extended_community_ids")

    @property
    @pulumi.getter(name="ipPrefixId")
    def ip_prefix_id(self) -> Optional[str]:
        """
        Arm Resource Id of IpPrefix.
        """
        return pulumi.get(self, "ip_prefix_id")


@pulumi.output_type
class StaticRouteConfigurationResponse(dict):
    """
    staticRouteConfiguration model.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bfdConfiguration":
            suggest = "bfd_configuration"
        elif key == "ipv4Routes":
            suggest = "ipv4_routes"
        elif key == "ipv6Routes":
            suggest = "ipv6_routes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StaticRouteConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StaticRouteConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StaticRouteConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bfd_configuration: Optional['outputs.BfdConfigurationResponse'] = None,
                 ipv4_routes: Optional[Sequence['outputs.StaticRoutePropertiesResponse']] = None,
                 ipv6_routes: Optional[Sequence['outputs.StaticRoutePropertiesResponse']] = None):
        """
        staticRouteConfiguration model.
        :param 'BfdConfigurationResponse' bfd_configuration: BFD configuration properties
        :param Sequence['StaticRoutePropertiesResponse'] ipv4_routes: List with object IPv4Routes.
        :param Sequence['StaticRoutePropertiesResponse'] ipv6_routes: List with object IPv6Routes.
        """
        if bfd_configuration is not None:
            pulumi.set(__self__, "bfd_configuration", bfd_configuration)
        if ipv4_routes is not None:
            pulumi.set(__self__, "ipv4_routes", ipv4_routes)
        if ipv6_routes is not None:
            pulumi.set(__self__, "ipv6_routes", ipv6_routes)

    @property
    @pulumi.getter(name="bfdConfiguration")
    def bfd_configuration(self) -> Optional['outputs.BfdConfigurationResponse']:
        """
        BFD configuration properties
        """
        return pulumi.get(self, "bfd_configuration")

    @property
    @pulumi.getter(name="ipv4Routes")
    def ipv4_routes(self) -> Optional[Sequence['outputs.StaticRoutePropertiesResponse']]:
        """
        List with object IPv4Routes.
        """
        return pulumi.get(self, "ipv4_routes")

    @property
    @pulumi.getter(name="ipv6Routes")
    def ipv6_routes(self) -> Optional[Sequence['outputs.StaticRoutePropertiesResponse']]:
        """
        List with object IPv6Routes.
        """
        return pulumi.get(self, "ipv6_routes")


@pulumi.output_type
class StaticRoutePropertiesResponse(dict):
    """
    Static Route properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextHop":
            suggest = "next_hop"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StaticRoutePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StaticRoutePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StaticRoutePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 next_hop: Sequence[str],
                 prefix: str):
        """
        Static Route properties.
        :param Sequence[str] next_hop: List of next hop IPv4 | IPv6 addresses.
        :param str prefix: IPv4 | IPv6 Prefix.
        """
        pulumi.set(__self__, "next_hop", next_hop)
        pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> Sequence[str]:
        """
        List of next hop IPv4 | IPv6 addresses.
        """
        return pulumi.get(self, "next_hop")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        IPv4 | IPv6 Prefix.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TerminalServerConfigurationResponse(dict):
    """
    Network and credentials configuration currently applied to terminal server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkDeviceId":
            suggest = "network_device_id"
        elif key == "primaryIpv4Prefix":
            suggest = "primary_ipv4_prefix"
        elif key == "secondaryIpv4Prefix":
            suggest = "secondary_ipv4_prefix"
        elif key == "primaryIpv6Prefix":
            suggest = "primary_ipv6_prefix"
        elif key == "secondaryIpv6Prefix":
            suggest = "secondary_ipv6_prefix"
        elif key == "serialNumber":
            suggest = "serial_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TerminalServerConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TerminalServerConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TerminalServerConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_device_id: str,
                 password: str,
                 primary_ipv4_prefix: str,
                 secondary_ipv4_prefix: str,
                 username: str,
                 primary_ipv6_prefix: Optional[str] = None,
                 secondary_ipv6_prefix: Optional[str] = None,
                 serial_number: Optional[str] = None):
        """
        Network and credentials configuration currently applied to terminal server.
        :param str network_device_id: ARM Resource ID used for the NetworkDevice.
        :param str password: Password for the terminal server connection.
        :param str primary_ipv4_prefix: IPv4 Address Prefix of CE-PE interconnect links. Example: 172.31.0.0/31. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        :param str secondary_ipv4_prefix: Secondary IPv4 Address Prefix of CE-PE interconnect links. Example: 172.31.0.20/31. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        :param str username: Username for the terminal server connection.
        :param str primary_ipv6_prefix: IPv6 Address Prefix of CE-PE interconnect links. Example: 3FFE:FFFF:0:CD30::a0/126. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        :param str secondary_ipv6_prefix: Secondary IPv6 Address Prefix of CE-PE interconnect links. Example: 3FFE:FFFF:0:CD30::a4/126. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        :param str serial_number: Serial Number of Terminal server.
        """
        pulumi.set(__self__, "network_device_id", network_device_id)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "primary_ipv4_prefix", primary_ipv4_prefix)
        pulumi.set(__self__, "secondary_ipv4_prefix", secondary_ipv4_prefix)
        pulumi.set(__self__, "username", username)
        if primary_ipv6_prefix is not None:
            pulumi.set(__self__, "primary_ipv6_prefix", primary_ipv6_prefix)
        if secondary_ipv6_prefix is not None:
            pulumi.set(__self__, "secondary_ipv6_prefix", secondary_ipv6_prefix)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)

    @property
    @pulumi.getter(name="networkDeviceId")
    def network_device_id(self) -> str:
        """
        ARM Resource ID used for the NetworkDevice.
        """
        return pulumi.get(self, "network_device_id")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password for the terminal server connection.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="primaryIpv4Prefix")
    def primary_ipv4_prefix(self) -> str:
        """
        IPv4 Address Prefix of CE-PE interconnect links. Example: 172.31.0.0/31. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        """
        return pulumi.get(self, "primary_ipv4_prefix")

    @property
    @pulumi.getter(name="secondaryIpv4Prefix")
    def secondary_ipv4_prefix(self) -> str:
        """
        Secondary IPv4 Address Prefix of CE-PE interconnect links. Example: 172.31.0.20/31. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        """
        return pulumi.get(self, "secondary_ipv4_prefix")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username for the terminal server connection.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="primaryIpv6Prefix")
    def primary_ipv6_prefix(self) -> Optional[str]:
        """
        IPv6 Address Prefix of CE-PE interconnect links. Example: 3FFE:FFFF:0:CD30::a0/126. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        """
        return pulumi.get(self, "primary_ipv6_prefix")

    @property
    @pulumi.getter(name="secondaryIpv6Prefix")
    def secondary_ipv6_prefix(self) -> Optional[str]:
        """
        Secondary IPv6 Address Prefix of CE-PE interconnect links. Example: 3FFE:FFFF:0:CD30::a4/126. The values can be specified at the time of creation or can be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be configured on PE1 and PE2 for Option B interfaces.
        """
        return pulumi.get(self, "secondary_ipv6_prefix")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[str]:
        """
        Serial Number of Terminal server.
        """
        return pulumi.get(self, "serial_number")


@pulumi.output_type
class VlanGroupPropertiesResponse(dict):
    """
    Vlan group properties.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 vlans: Optional[Sequence[str]] = None):
        """
        Vlan group properties.
        :param str name: Vlan group name.
        :param Sequence[str] vlans: List of vlans.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if vlans is not None:
            pulumi.set(__self__, "vlans", vlans)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Vlan group name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def vlans(self) -> Optional[Sequence[str]]:
        """
        List of vlans.
        """
        return pulumi.get(self, "vlans")


@pulumi.output_type
class VlanMatchConditionResponse(dict):
    """
    The vlan match conditions that need to be matched.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "innerVlans":
            suggest = "inner_vlans"
        elif key == "vlanGroupNames":
            suggest = "vlan_group_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VlanMatchConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VlanMatchConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VlanMatchConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inner_vlans: Optional[Sequence[str]] = None,
                 vlan_group_names: Optional[Sequence[str]] = None,
                 vlans: Optional[Sequence[str]] = None):
        """
        The vlan match conditions that need to be matched.
        :param Sequence[str] inner_vlans: List of inner vlans that need to be matched.
        :param Sequence[str] vlan_group_names: List of vlan group names that need to be matched.
        :param Sequence[str] vlans: List of vlans that need to be matched.
        """
        if inner_vlans is not None:
            pulumi.set(__self__, "inner_vlans", inner_vlans)
        if vlan_group_names is not None:
            pulumi.set(__self__, "vlan_group_names", vlan_group_names)
        if vlans is not None:
            pulumi.set(__self__, "vlans", vlans)

    @property
    @pulumi.getter(name="innerVlans")
    def inner_vlans(self) -> Optional[Sequence[str]]:
        """
        List of inner vlans that need to be matched.
        """
        return pulumi.get(self, "inner_vlans")

    @property
    @pulumi.getter(name="vlanGroupNames")
    def vlan_group_names(self) -> Optional[Sequence[str]]:
        """
        List of vlan group names that need to be matched.
        """
        return pulumi.get(self, "vlan_group_names")

    @property
    @pulumi.getter
    def vlans(self) -> Optional[Sequence[str]]:
        """
        List of vlans that need to be matched.
        """
        return pulumi.get(self, "vlans")


@pulumi.output_type
class VpnConfigurationPropertiesResponse(dict):
    """
    Configuration for infrastructure vpn.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "administrativeState":
            suggest = "administrative_state"
        elif key == "networkToNetworkInterconnectId":
            suggest = "network_to_network_interconnect_id"
        elif key == "peeringOption":
            suggest = "peering_option"
        elif key == "optionAProperties":
            suggest = "option_a_properties"
        elif key == "optionBProperties":
            suggest = "option_b_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConfigurationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConfigurationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConfigurationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 administrative_state: str,
                 network_to_network_interconnect_id: str,
                 peering_option: str,
                 option_a_properties: Optional['outputs.OptionAPropertiesResponse'] = None,
                 option_b_properties: Optional['outputs.FabricOptionBPropertiesResponse'] = None):
        """
        Configuration for infrastructure vpn.
        :param str administrative_state: Indicates configuration state. Example: Enabled | Disabled.
        :param str network_to_network_interconnect_id: Gets the networkToNetworkInterconnectId of the resource.
        :param str peering_option: Peering option list.
        :param 'OptionAPropertiesResponse' option_a_properties: option A properties
        :param 'FabricOptionBPropertiesResponse' option_b_properties: option B properties
        """
        pulumi.set(__self__, "administrative_state", administrative_state)
        pulumi.set(__self__, "network_to_network_interconnect_id", network_to_network_interconnect_id)
        pulumi.set(__self__, "peering_option", peering_option)
        if option_a_properties is not None:
            pulumi.set(__self__, "option_a_properties", option_a_properties)
        if option_b_properties is not None:
            pulumi.set(__self__, "option_b_properties", option_b_properties)

    @property
    @pulumi.getter(name="administrativeState")
    def administrative_state(self) -> str:
        """
        Indicates configuration state. Example: Enabled | Disabled.
        """
        return pulumi.get(self, "administrative_state")

    @property
    @pulumi.getter(name="networkToNetworkInterconnectId")
    def network_to_network_interconnect_id(self) -> str:
        """
        Gets the networkToNetworkInterconnectId of the resource.
        """
        return pulumi.get(self, "network_to_network_interconnect_id")

    @property
    @pulumi.getter(name="peeringOption")
    def peering_option(self) -> str:
        """
        Peering option list.
        """
        return pulumi.get(self, "peering_option")

    @property
    @pulumi.getter(name="optionAProperties")
    def option_a_properties(self) -> Optional['outputs.OptionAPropertiesResponse']:
        """
        option A properties
        """
        return pulumi.get(self, "option_a_properties")

    @property
    @pulumi.getter(name="optionBProperties")
    def option_b_properties(self) -> Optional['outputs.FabricOptionBPropertiesResponse']:
        """
        option B properties
        """
        return pulumi.get(self, "option_b_properties")


@pulumi.output_type
class WorkloadServicesResponse(dict):
    """
    WorkloadServices IP ranges.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4AddressSpaces":
            suggest = "ipv4_address_spaces"
        elif key == "ipv6AddressSpaces":
            suggest = "ipv6_address_spaces"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadServicesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadServicesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadServicesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4_address_spaces: Optional[Sequence[str]] = None,
                 ipv6_address_spaces: Optional[Sequence[str]] = None):
        """
        WorkloadServices IP ranges.
        :param Sequence[str] ipv4_address_spaces: The IPv4 Address space is optional, if the value is defined at the time of NFC creation, then the default value 10.0.0.0/19 is considered. The IPV4 address subnet is an optional attribute.
        :param Sequence[str] ipv6_address_spaces: The IPv6 is not supported right now.
        """
        if ipv4_address_spaces is not None:
            pulumi.set(__self__, "ipv4_address_spaces", ipv4_address_spaces)
        if ipv6_address_spaces is not None:
            pulumi.set(__self__, "ipv6_address_spaces", ipv6_address_spaces)

    @property
    @pulumi.getter(name="ipv4AddressSpaces")
    def ipv4_address_spaces(self) -> Optional[Sequence[str]]:
        """
        The IPv4 Address space is optional, if the value is defined at the time of NFC creation, then the default value 10.0.0.0/19 is considered. The IPV4 address subnet is an optional attribute.
        """
        return pulumi.get(self, "ipv4_address_spaces")

    @property
    @pulumi.getter(name="ipv6AddressSpaces")
    def ipv6_address_spaces(self) -> Optional[Sequence[str]]:
        """
        The IPv6 is not supported right now.
        """
        return pulumi.get(self, "ipv6_address_spaces")


