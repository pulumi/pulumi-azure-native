# coding=utf-8
# *** WARNING: this file was generated by pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ApprovalSettingsResponse',
    'ApprovalStageResponse',
    'IdentityResponse',
    'IdentityResponseUserAssignedIdentities',
    'ManagementLockOwnerResponse',
    'NonComplianceMessageResponse',
    'OverrideResponse',
    'ParameterDefinitionsValueResponse',
    'ParameterDefinitionsValueResponseMetadata',
    'ParameterValuesValueResponse',
    'PermissionResponse',
    'PolicyAssignmentPropertiesResponse',
    'PolicyAssignmentPropertiesResponsePolicy',
    'PolicyAssignmentPropertiesResponseRoleDefinition',
    'PolicyAssignmentPropertiesResponseScope',
    'PolicyDefinitionGroupResponse',
    'PolicyDefinitionReferenceResponse',
    'PrincipalResponse',
    'PrivateLinkAssociationPropertiesExpandedResponse',
    'ResourceManagementPrivateLinkEndpointConnectionsResponse',
    'ResourceSelectorResponse',
    'RoleManagementPolicyApprovalRuleResponse',
    'RoleManagementPolicyAuthenticationContextRuleResponse',
    'RoleManagementPolicyEnablementRuleResponse',
    'RoleManagementPolicyExpirationRuleResponse',
    'RoleManagementPolicyNotificationRuleResponse',
    'RoleManagementPolicyRuleTargetResponse',
    'SelectorResponse',
    'SystemDataResponse',
    'UserSetResponse',
]

@pulumi.output_type
class ApprovalSettingsResponse(dict):
    """
    The approval settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "approvalMode":
            suggest = "approval_mode"
        elif key == "approvalStages":
            suggest = "approval_stages"
        elif key == "isApprovalRequired":
            suggest = "is_approval_required"
        elif key == "isApprovalRequiredForExtension":
            suggest = "is_approval_required_for_extension"
        elif key == "isRequestorJustificationRequired":
            suggest = "is_requestor_justification_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApprovalSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApprovalSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApprovalSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approval_mode: Optional[str] = None,
                 approval_stages: Optional[Sequence['outputs.ApprovalStageResponse']] = None,
                 is_approval_required: Optional[bool] = None,
                 is_approval_required_for_extension: Optional[bool] = None,
                 is_requestor_justification_required: Optional[bool] = None):
        """
        The approval settings.
        :param str approval_mode: The type of rule
        :param Sequence['ApprovalStageResponse'] approval_stages: The approval stages of the request.
        :param bool is_approval_required: Determines whether approval is required or not.
        :param bool is_approval_required_for_extension: Determines whether approval is required for assignment extension.
        :param bool is_requestor_justification_required: Determine whether requestor justification is required.
        """
        if approval_mode is not None:
            pulumi.set(__self__, "approval_mode", approval_mode)
        if approval_stages is not None:
            pulumi.set(__self__, "approval_stages", approval_stages)
        if is_approval_required is not None:
            pulumi.set(__self__, "is_approval_required", is_approval_required)
        if is_approval_required_for_extension is not None:
            pulumi.set(__self__, "is_approval_required_for_extension", is_approval_required_for_extension)
        if is_requestor_justification_required is not None:
            pulumi.set(__self__, "is_requestor_justification_required", is_requestor_justification_required)

    @property
    @pulumi.getter(name="approvalMode")
    def approval_mode(self) -> Optional[str]:
        """
        The type of rule
        """
        return pulumi.get(self, "approval_mode")

    @property
    @pulumi.getter(name="approvalStages")
    def approval_stages(self) -> Optional[Sequence['outputs.ApprovalStageResponse']]:
        """
        The approval stages of the request.
        """
        return pulumi.get(self, "approval_stages")

    @property
    @pulumi.getter(name="isApprovalRequired")
    def is_approval_required(self) -> Optional[bool]:
        """
        Determines whether approval is required or not.
        """
        return pulumi.get(self, "is_approval_required")

    @property
    @pulumi.getter(name="isApprovalRequiredForExtension")
    def is_approval_required_for_extension(self) -> Optional[bool]:
        """
        Determines whether approval is required for assignment extension.
        """
        return pulumi.get(self, "is_approval_required_for_extension")

    @property
    @pulumi.getter(name="isRequestorJustificationRequired")
    def is_requestor_justification_required(self) -> Optional[bool]:
        """
        Determine whether requestor justification is required.
        """
        return pulumi.get(self, "is_requestor_justification_required")


@pulumi.output_type
class ApprovalStageResponse(dict):
    """
    The approval stage.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "approvalStageTimeOutInDays":
            suggest = "approval_stage_time_out_in_days"
        elif key == "escalationApprovers":
            suggest = "escalation_approvers"
        elif key == "escalationTimeInMinutes":
            suggest = "escalation_time_in_minutes"
        elif key == "isApproverJustificationRequired":
            suggest = "is_approver_justification_required"
        elif key == "isEscalationEnabled":
            suggest = "is_escalation_enabled"
        elif key == "primaryApprovers":
            suggest = "primary_approvers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApprovalStageResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApprovalStageResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApprovalStageResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approval_stage_time_out_in_days: Optional[int] = None,
                 escalation_approvers: Optional[Sequence['outputs.UserSetResponse']] = None,
                 escalation_time_in_minutes: Optional[int] = None,
                 is_approver_justification_required: Optional[bool] = None,
                 is_escalation_enabled: Optional[bool] = None,
                 primary_approvers: Optional[Sequence['outputs.UserSetResponse']] = None):
        """
        The approval stage.
        :param int approval_stage_time_out_in_days: The time in days when approval request would be timed out
        :param Sequence['UserSetResponse'] escalation_approvers: The escalation approver of the request.
        :param int escalation_time_in_minutes: The time in minutes when the approval request would be escalated if the primary approver does not approve
        :param bool is_approver_justification_required: Determines whether approver need to provide justification for his decision.
        :param bool is_escalation_enabled: The value determine whether escalation feature is enabled.
        :param Sequence['UserSetResponse'] primary_approvers: The primary approver of the request.
        """
        if approval_stage_time_out_in_days is not None:
            pulumi.set(__self__, "approval_stage_time_out_in_days", approval_stage_time_out_in_days)
        if escalation_approvers is not None:
            pulumi.set(__self__, "escalation_approvers", escalation_approvers)
        if escalation_time_in_minutes is not None:
            pulumi.set(__self__, "escalation_time_in_minutes", escalation_time_in_minutes)
        if is_approver_justification_required is not None:
            pulumi.set(__self__, "is_approver_justification_required", is_approver_justification_required)
        if is_escalation_enabled is not None:
            pulumi.set(__self__, "is_escalation_enabled", is_escalation_enabled)
        if primary_approvers is not None:
            pulumi.set(__self__, "primary_approvers", primary_approvers)

    @property
    @pulumi.getter(name="approvalStageTimeOutInDays")
    def approval_stage_time_out_in_days(self) -> Optional[int]:
        """
        The time in days when approval request would be timed out
        """
        return pulumi.get(self, "approval_stage_time_out_in_days")

    @property
    @pulumi.getter(name="escalationApprovers")
    def escalation_approvers(self) -> Optional[Sequence['outputs.UserSetResponse']]:
        """
        The escalation approver of the request.
        """
        return pulumi.get(self, "escalation_approvers")

    @property
    @pulumi.getter(name="escalationTimeInMinutes")
    def escalation_time_in_minutes(self) -> Optional[int]:
        """
        The time in minutes when the approval request would be escalated if the primary approver does not approve
        """
        return pulumi.get(self, "escalation_time_in_minutes")

    @property
    @pulumi.getter(name="isApproverJustificationRequired")
    def is_approver_justification_required(self) -> Optional[bool]:
        """
        Determines whether approver need to provide justification for his decision.
        """
        return pulumi.get(self, "is_approver_justification_required")

    @property
    @pulumi.getter(name="isEscalationEnabled")
    def is_escalation_enabled(self) -> Optional[bool]:
        """
        The value determine whether escalation feature is enabled.
        """
        return pulumi.get(self, "is_escalation_enabled")

    @property
    @pulumi.getter(name="primaryApprovers")
    def primary_approvers(self) -> Optional[Sequence['outputs.UserSetResponse']]:
        """
        The primary approver of the request.
        """
        return pulumi.get(self, "primary_approvers")


@pulumi.output_type
class IdentityResponse(dict):
    """
    Identity for the resource.  Policy assignments support a maximum of one identity.  That is either a system assigned identity or a single user assigned identity.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: Optional[str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.IdentityResponseUserAssignedIdentities']] = None):
        """
        Identity for the resource.  Policy assignments support a maximum of one identity.  That is either a system assigned identity or a single user assigned identity.
        :param str principal_id: The principal ID of the resource identity.  This property will only be provided for a system assigned identity
        :param str tenant_id: The tenant ID of the resource identity.  This property will only be provided for a system assigned identity
        :param str type: The identity type. This is the only required field when adding a system or user assigned identity to a resource.
        :param Mapping[str, 'IdentityResponseUserAssignedIdentities'] user_assigned_identities: The user identity associated with the policy. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of the resource identity.  This property will only be provided for a system assigned identity
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of the resource identity.  This property will only be provided for a system assigned identity
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The identity type. This is the only required field when adding a system or user assigned identity to a resource.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.IdentityResponseUserAssignedIdentities']]:
        """
        The user identity associated with the policy. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class IdentityResponseUserAssignedIdentities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityResponseUserAssignedIdentities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityResponseUserAssignedIdentities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityResponseUserAssignedIdentities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str):
        """
        :param str client_id: The client id of user assigned identity.
        :param str principal_id: The principal id of user assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client id of user assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal id of user assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class ManagementLockOwnerResponse(dict):
    """
    Lock owner properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementLockOwnerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementLockOwnerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementLockOwnerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: Optional[str] = None):
        """
        Lock owner properties.
        :param str application_id: The application ID of the lock owner.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        The application ID of the lock owner.
        """
        return pulumi.get(self, "application_id")


@pulumi.output_type
class NonComplianceMessageResponse(dict):
    """
    A message that describes why a resource is non-compliant with the policy. This is shown in 'deny' error messages and on resource's non-compliant compliance results.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyDefinitionReferenceId":
            suggest = "policy_definition_reference_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NonComplianceMessageResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NonComplianceMessageResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NonComplianceMessageResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message: str,
                 policy_definition_reference_id: Optional[str] = None):
        """
        A message that describes why a resource is non-compliant with the policy. This is shown in 'deny' error messages and on resource's non-compliant compliance results.
        :param str message: A message that describes why a resource is non-compliant with the policy. This is shown in 'deny' error messages and on resource's non-compliant compliance results.
        :param str policy_definition_reference_id: The policy definition reference ID within a policy set definition the message is intended for. This is only applicable if the policy assignment assigns a policy set definition. If this is not provided the message applies to all policies assigned by this policy assignment.
        """
        pulumi.set(__self__, "message", message)
        if policy_definition_reference_id is not None:
            pulumi.set(__self__, "policy_definition_reference_id", policy_definition_reference_id)

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        A message that describes why a resource is non-compliant with the policy. This is shown in 'deny' error messages and on resource's non-compliant compliance results.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="policyDefinitionReferenceId")
    def policy_definition_reference_id(self) -> Optional[str]:
        """
        The policy definition reference ID within a policy set definition the message is intended for. This is only applicable if the policy assignment assigns a policy set definition. If this is not provided the message applies to all policies assigned by this policy assignment.
        """
        return pulumi.get(self, "policy_definition_reference_id")


@pulumi.output_type
class OverrideResponse(dict):
    """
    The policy property value override.
    """
    def __init__(__self__, *,
                 kind: Optional[str] = None,
                 selectors: Optional[Sequence['outputs.SelectorResponse']] = None,
                 value: Optional[str] = None):
        """
        The policy property value override.
        :param str kind: The override kind.
        :param Sequence['SelectorResponse'] selectors: The list of the selector expressions.
        :param str value: The value to override the policy property.
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if selectors is not None:
            pulumi.set(__self__, "selectors", selectors)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        The override kind.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def selectors(self) -> Optional[Sequence['outputs.SelectorResponse']]:
        """
        The list of the selector expressions.
        """
        return pulumi.get(self, "selectors")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to override the policy property.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ParameterDefinitionsValueResponse(dict):
    """
    The definition of a parameter that can be provided to the policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedValues":
            suggest = "allowed_values"
        elif key == "defaultValue":
            suggest = "default_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ParameterDefinitionsValueResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ParameterDefinitionsValueResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ParameterDefinitionsValueResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_values: Optional[Sequence[Any]] = None,
                 default_value: Optional[Any] = None,
                 metadata: Optional['outputs.ParameterDefinitionsValueResponseMetadata'] = None,
                 type: Optional[str] = None):
        """
        The definition of a parameter that can be provided to the policy.
        :param Sequence[Any] allowed_values: The allowed values for the parameter.
        :param Any default_value: The default value for the parameter if no value is provided.
        :param 'ParameterDefinitionsValueResponseMetadata' metadata: General metadata for the parameter.
        :param str type: The data type of the parameter.
        """
        if allowed_values is not None:
            pulumi.set(__self__, "allowed_values", allowed_values)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="allowedValues")
    def allowed_values(self) -> Optional[Sequence[Any]]:
        """
        The allowed values for the parameter.
        """
        return pulumi.get(self, "allowed_values")

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[Any]:
        """
        The default value for the parameter if no value is provided.
        """
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.ParameterDefinitionsValueResponseMetadata']:
        """
        General metadata for the parameter.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The data type of the parameter.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ParameterDefinitionsValueResponseMetadata(dict):
    """
    General metadata for the parameter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignPermissions":
            suggest = "assign_permissions"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "strongType":
            suggest = "strong_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ParameterDefinitionsValueResponseMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ParameterDefinitionsValueResponseMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ParameterDefinitionsValueResponseMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assign_permissions: Optional[bool] = None,
                 description: Optional[str] = None,
                 display_name: Optional[str] = None,
                 strong_type: Optional[str] = None):
        """
        General metadata for the parameter.
        :param bool assign_permissions: Set to true to have Azure portal create role assignments on the resource ID or resource scope value of this parameter during policy assignment. This property is useful in case you wish to assign permissions outside the assignment scope.
        :param str description: The description of the parameter.
        :param str display_name: The display name for the parameter.
        :param str strong_type: Used when assigning the policy definition through the portal. Provides a context aware list of values for the user to choose from.
        """
        if assign_permissions is not None:
            pulumi.set(__self__, "assign_permissions", assign_permissions)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if strong_type is not None:
            pulumi.set(__self__, "strong_type", strong_type)

    @property
    @pulumi.getter(name="assignPermissions")
    def assign_permissions(self) -> Optional[bool]:
        """
        Set to true to have Azure portal create role assignments on the resource ID or resource scope value of this parameter during policy assignment. This property is useful in case you wish to assign permissions outside the assignment scope.
        """
        return pulumi.get(self, "assign_permissions")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the parameter.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The display name for the parameter.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="strongType")
    def strong_type(self) -> Optional[str]:
        """
        Used when assigning the policy definition through the portal. Provides a context aware list of values for the user to choose from.
        """
        return pulumi.get(self, "strong_type")


@pulumi.output_type
class ParameterValuesValueResponse(dict):
    """
    The value of a parameter.
    """
    def __init__(__self__, *,
                 value: Optional[Any] = None):
        """
        The value of a parameter.
        :param Any value: The value of the parameter.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[Any]:
        """
        The value of the parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PermissionResponse(dict):
    """
    Role definition permissions.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataActions":
            suggest = "data_actions"
        elif key == "notActions":
            suggest = "not_actions"
        elif key == "notDataActions":
            suggest = "not_data_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Optional[Sequence[str]] = None,
                 data_actions: Optional[Sequence[str]] = None,
                 not_actions: Optional[Sequence[str]] = None,
                 not_data_actions: Optional[Sequence[str]] = None):
        """
        Role definition permissions.
        :param Sequence[str] actions: Allowed actions.
        :param Sequence[str] data_actions: Allowed Data actions.
        :param Sequence[str] not_actions: Denied actions.
        :param Sequence[str] not_data_actions: Denied Data actions.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if data_actions is not None:
            pulumi.set(__self__, "data_actions", data_actions)
        if not_actions is not None:
            pulumi.set(__self__, "not_actions", not_actions)
        if not_data_actions is not None:
            pulumi.set(__self__, "not_data_actions", not_data_actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[str]]:
        """
        Allowed actions.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="dataActions")
    def data_actions(self) -> Optional[Sequence[str]]:
        """
        Allowed Data actions.
        """
        return pulumi.get(self, "data_actions")

    @property
    @pulumi.getter(name="notActions")
    def not_actions(self) -> Optional[Sequence[str]]:
        """
        Denied actions.
        """
        return pulumi.get(self, "not_actions")

    @property
    @pulumi.getter(name="notDataActions")
    def not_data_actions(self) -> Optional[Sequence[str]]:
        """
        Denied Data actions.
        """
        return pulumi.get(self, "not_data_actions")


@pulumi.output_type
class PolicyAssignmentPropertiesResponse(dict):
    """
    Expanded info of resource scope, role definition and policy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleDefinition":
            suggest = "role_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyAssignmentPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyAssignmentPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyAssignmentPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy: Optional['outputs.PolicyAssignmentPropertiesResponsePolicy'] = None,
                 role_definition: Optional['outputs.PolicyAssignmentPropertiesResponseRoleDefinition'] = None,
                 scope: Optional['outputs.PolicyAssignmentPropertiesResponseScope'] = None):
        """
        Expanded info of resource scope, role definition and policy
        :param 'PolicyAssignmentPropertiesResponsePolicy' policy: Details of the policy
        :param 'PolicyAssignmentPropertiesResponseRoleDefinition' role_definition: Details of role definition
        :param 'PolicyAssignmentPropertiesResponseScope' scope: Details of the resource scope
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if role_definition is not None:
            pulumi.set(__self__, "role_definition", role_definition)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def policy(self) -> Optional['outputs.PolicyAssignmentPropertiesResponsePolicy']:
        """
        Details of the policy
        """
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter(name="roleDefinition")
    def role_definition(self) -> Optional['outputs.PolicyAssignmentPropertiesResponseRoleDefinition']:
        """
        Details of role definition
        """
        return pulumi.get(self, "role_definition")

    @property
    @pulumi.getter
    def scope(self) -> Optional['outputs.PolicyAssignmentPropertiesResponseScope']:
        """
        Details of the resource scope
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class PolicyAssignmentPropertiesResponsePolicy(dict):
    """
    Details of the policy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedDateTime":
            suggest = "last_modified_date_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyAssignmentPropertiesResponsePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyAssignmentPropertiesResponsePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyAssignmentPropertiesResponsePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_modified_by: 'outputs.PrincipalResponse',
                 id: Optional[str] = None,
                 last_modified_date_time: Optional[str] = None):
        """
        Details of the policy
        :param 'PrincipalResponse' last_modified_by: The name of the entity last modified it
        :param str id: Id of the policy
        :param str last_modified_date_time: The last modified date time.
        """
        pulumi.set(__self__, "last_modified_by", last_modified_by)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if last_modified_date_time is not None:
            pulumi.set(__self__, "last_modified_date_time", last_modified_date_time)

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> 'outputs.PrincipalResponse':
        """
        The name of the entity last modified it
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Id of the policy
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastModifiedDateTime")
    def last_modified_date_time(self) -> Optional[str]:
        """
        The last modified date time.
        """
        return pulumi.get(self, "last_modified_date_time")


@pulumi.output_type
class PolicyAssignmentPropertiesResponseRoleDefinition(dict):
    """
    Details of role definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyAssignmentPropertiesResponseRoleDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyAssignmentPropertiesResponseRoleDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyAssignmentPropertiesResponseRoleDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Details of role definition
        :param str display_name: Display name of the role definition
        :param str id: Id of the role definition
        :param str type: Type of the role definition
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Display name of the role definition
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Id of the role definition
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the role definition
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PolicyAssignmentPropertiesResponseScope(dict):
    """
    Details of the resource scope
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyAssignmentPropertiesResponseScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyAssignmentPropertiesResponseScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyAssignmentPropertiesResponseScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Details of the resource scope
        :param str display_name: Display name of the resource
        :param str id: Scope id of the resource
        :param str type: Type of the resource
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Display name of the resource
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Scope id of the resource
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the resource
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PolicyDefinitionGroupResponse(dict):
    """
    The policy definition group.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalMetadataId":
            suggest = "additional_metadata_id"
        elif key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyDefinitionGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyDefinitionGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyDefinitionGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 additional_metadata_id: Optional[str] = None,
                 category: Optional[str] = None,
                 description: Optional[str] = None,
                 display_name: Optional[str] = None):
        """
        The policy definition group.
        :param str name: The name of the group.
        :param str additional_metadata_id: A resource ID of a resource that contains additional metadata about the group.
        :param str category: The group's category.
        :param str description: The group's description.
        :param str display_name: The group's display name.
        """
        pulumi.set(__self__, "name", name)
        if additional_metadata_id is not None:
            pulumi.set(__self__, "additional_metadata_id", additional_metadata_id)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="additionalMetadataId")
    def additional_metadata_id(self) -> Optional[str]:
        """
        A resource ID of a resource that contains additional metadata about the group.
        """
        return pulumi.get(self, "additional_metadata_id")

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        The group's category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The group's description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The group's display name.
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class PolicyDefinitionReferenceResponse(dict):
    """
    The policy definition reference.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyDefinitionId":
            suggest = "policy_definition_id"
        elif key == "groupNames":
            suggest = "group_names"
        elif key == "policyDefinitionReferenceId":
            suggest = "policy_definition_reference_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyDefinitionReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyDefinitionReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyDefinitionReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_definition_id: str,
                 group_names: Optional[Sequence[str]] = None,
                 parameters: Optional[Mapping[str, 'outputs.ParameterValuesValueResponse']] = None,
                 policy_definition_reference_id: Optional[str] = None):
        """
        The policy definition reference.
        :param str policy_definition_id: The ID of the policy definition or policy set definition.
        :param Sequence[str] group_names: The name of the groups that this policy definition reference belongs to.
        :param Mapping[str, 'ParameterValuesValueResponse'] parameters: The parameter values for the referenced policy rule. The keys are the parameter names.
        :param str policy_definition_reference_id: A unique id (within the policy set definition) for this policy definition reference.
        """
        pulumi.set(__self__, "policy_definition_id", policy_definition_id)
        if group_names is not None:
            pulumi.set(__self__, "group_names", group_names)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if policy_definition_reference_id is not None:
            pulumi.set(__self__, "policy_definition_reference_id", policy_definition_reference_id)

    @property
    @pulumi.getter(name="policyDefinitionId")
    def policy_definition_id(self) -> str:
        """
        The ID of the policy definition or policy set definition.
        """
        return pulumi.get(self, "policy_definition_id")

    @property
    @pulumi.getter(name="groupNames")
    def group_names(self) -> Optional[Sequence[str]]:
        """
        The name of the groups that this policy definition reference belongs to.
        """
        return pulumi.get(self, "group_names")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.ParameterValuesValueResponse']]:
        """
        The parameter values for the referenced policy rule. The keys are the parameter names.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="policyDefinitionReferenceId")
    def policy_definition_reference_id(self) -> Optional[str]:
        """
        A unique id (within the policy set definition) for this policy definition reference.
        """
        return pulumi.get(self, "policy_definition_reference_id")


@pulumi.output_type
class PrincipalResponse(dict):
    """
    The name of the entity last modified it
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrincipalResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrincipalResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrincipalResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 email: Optional[str] = None,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        The name of the entity last modified it
        :param str display_name: The name of the principal made changes
        :param str email: Email of principal
        :param str id: The id of the principal made changes
        :param str type: Type of principal such as user , group etc
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The name of the principal made changes
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        Email of principal
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the principal made changes
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of principal such as user , group etc
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PrivateLinkAssociationPropertiesExpandedResponse(dict):
    """
    Private Link Association Properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateLink":
            suggest = "private_link"
        elif key == "publicNetworkAccess":
            suggest = "public_network_access"
        elif key == "tenantID":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkAssociationPropertiesExpandedResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkAssociationPropertiesExpandedResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkAssociationPropertiesExpandedResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_link: Optional[str] = None,
                 public_network_access: Optional[str] = None,
                 scope: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        Private Link Association Properties.
        :param str private_link: The rmpl Resource ID.
        :param str scope: The scope of the private link association.
        :param str tenant_id: The TenantID.
        """
        if private_link is not None:
            pulumi.set(__self__, "private_link", private_link)
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="privateLink")
    def private_link(self) -> Optional[str]:
        """
        The rmpl Resource ID.
        """
        return pulumi.get(self, "private_link")

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[str]:
        return pulumi.get(self, "public_network_access")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The scope of the private link association.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="tenantID")
    def tenant_id(self) -> Optional[str]:
        """
        The TenantID.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class ResourceManagementPrivateLinkEndpointConnectionsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateEndpointConnections":
            suggest = "private_endpoint_connections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceManagementPrivateLinkEndpointConnectionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceManagementPrivateLinkEndpointConnectionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceManagementPrivateLinkEndpointConnectionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_endpoint_connections: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] private_endpoint_connections: The private endpoint connections.
        """
        if private_endpoint_connections is not None:
            pulumi.set(__self__, "private_endpoint_connections", private_endpoint_connections)

    @property
    @pulumi.getter(name="privateEndpointConnections")
    def private_endpoint_connections(self) -> Optional[Sequence[str]]:
        """
        The private endpoint connections.
        """
        return pulumi.get(self, "private_endpoint_connections")


@pulumi.output_type
class ResourceSelectorResponse(dict):
    """
    The resource selector to filter policies by resource properties.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 selectors: Optional[Sequence['outputs.SelectorResponse']] = None):
        """
        The resource selector to filter policies by resource properties.
        :param str name: The name of the resource selector.
        :param Sequence['SelectorResponse'] selectors: The list of the selector expressions.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if selectors is not None:
            pulumi.set(__self__, "selectors", selectors)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the resource selector.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def selectors(self) -> Optional[Sequence['outputs.SelectorResponse']]:
        """
        The list of the selector expressions.
        """
        return pulumi.get(self, "selectors")


@pulumi.output_type
class RoleManagementPolicyApprovalRuleResponse(dict):
    """
    The role management policy approval rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleType":
            suggest = "rule_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoleManagementPolicyApprovalRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoleManagementPolicyApprovalRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoleManagementPolicyApprovalRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_type: str,
                 id: Optional[str] = None,
                 setting: Optional['outputs.ApprovalSettingsResponse'] = None,
                 target: Optional['outputs.RoleManagementPolicyRuleTargetResponse'] = None):
        """
        The role management policy approval rule.
        :param str rule_type: The type of rule
               Expected value is 'RoleManagementPolicyApprovalRule'.
        :param str id: The id of the rule.
        :param 'ApprovalSettingsResponse' setting: The approval setting
        :param 'RoleManagementPolicyRuleTargetResponse' target: The target of the current rule.
        """
        pulumi.set(__self__, "rule_type", 'RoleManagementPolicyApprovalRule')
        if id is not None:
            pulumi.set(__self__, "id", id)
        if setting is not None:
            pulumi.set(__self__, "setting", setting)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        The type of rule
        Expected value is 'RoleManagementPolicyApprovalRule'.
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def setting(self) -> Optional['outputs.ApprovalSettingsResponse']:
        """
        The approval setting
        """
        return pulumi.get(self, "setting")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.RoleManagementPolicyRuleTargetResponse']:
        """
        The target of the current rule.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class RoleManagementPolicyAuthenticationContextRuleResponse(dict):
    """
    The role management policy authentication context rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleType":
            suggest = "rule_type"
        elif key == "claimValue":
            suggest = "claim_value"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoleManagementPolicyAuthenticationContextRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoleManagementPolicyAuthenticationContextRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoleManagementPolicyAuthenticationContextRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_type: str,
                 claim_value: Optional[str] = None,
                 id: Optional[str] = None,
                 is_enabled: Optional[bool] = None,
                 target: Optional['outputs.RoleManagementPolicyRuleTargetResponse'] = None):
        """
        The role management policy authentication context rule.
        :param str rule_type: The type of rule
               Expected value is 'RoleManagementPolicyAuthenticationContextRule'.
        :param str claim_value: The claim value.
        :param str id: The id of the rule.
        :param bool is_enabled: The value indicating if rule is enabled.
        :param 'RoleManagementPolicyRuleTargetResponse' target: The target of the current rule.
        """
        pulumi.set(__self__, "rule_type", 'RoleManagementPolicyAuthenticationContextRule')
        if claim_value is not None:
            pulumi.set(__self__, "claim_value", claim_value)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        The type of rule
        Expected value is 'RoleManagementPolicyAuthenticationContextRule'.
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter(name="claimValue")
    def claim_value(self) -> Optional[str]:
        """
        The claim value.
        """
        return pulumi.get(self, "claim_value")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        The value indicating if rule is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.RoleManagementPolicyRuleTargetResponse']:
        """
        The target of the current rule.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class RoleManagementPolicyEnablementRuleResponse(dict):
    """
    The role management policy enablement rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleType":
            suggest = "rule_type"
        elif key == "enabledRules":
            suggest = "enabled_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoleManagementPolicyEnablementRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoleManagementPolicyEnablementRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoleManagementPolicyEnablementRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_type: str,
                 enabled_rules: Optional[Sequence[str]] = None,
                 id: Optional[str] = None,
                 target: Optional['outputs.RoleManagementPolicyRuleTargetResponse'] = None):
        """
        The role management policy enablement rule.
        :param str rule_type: The type of rule
               Expected value is 'RoleManagementPolicyEnablementRule'.
        :param Sequence[str] enabled_rules: The list of enabled rules.
        :param str id: The id of the rule.
        :param 'RoleManagementPolicyRuleTargetResponse' target: The target of the current rule.
        """
        pulumi.set(__self__, "rule_type", 'RoleManagementPolicyEnablementRule')
        if enabled_rules is not None:
            pulumi.set(__self__, "enabled_rules", enabled_rules)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        The type of rule
        Expected value is 'RoleManagementPolicyEnablementRule'.
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter(name="enabledRules")
    def enabled_rules(self) -> Optional[Sequence[str]]:
        """
        The list of enabled rules.
        """
        return pulumi.get(self, "enabled_rules")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.RoleManagementPolicyRuleTargetResponse']:
        """
        The target of the current rule.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class RoleManagementPolicyExpirationRuleResponse(dict):
    """
    The role management policy expiration rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleType":
            suggest = "rule_type"
        elif key == "isExpirationRequired":
            suggest = "is_expiration_required"
        elif key == "maximumDuration":
            suggest = "maximum_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoleManagementPolicyExpirationRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoleManagementPolicyExpirationRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoleManagementPolicyExpirationRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_type: str,
                 id: Optional[str] = None,
                 is_expiration_required: Optional[bool] = None,
                 maximum_duration: Optional[str] = None,
                 target: Optional['outputs.RoleManagementPolicyRuleTargetResponse'] = None):
        """
        The role management policy expiration rule.
        :param str rule_type: The type of rule
               Expected value is 'RoleManagementPolicyExpirationRule'.
        :param str id: The id of the rule.
        :param bool is_expiration_required: The value indicating whether expiration is required.
        :param str maximum_duration: The maximum duration of expiration in timespan.
        :param 'RoleManagementPolicyRuleTargetResponse' target: The target of the current rule.
        """
        pulumi.set(__self__, "rule_type", 'RoleManagementPolicyExpirationRule')
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_expiration_required is not None:
            pulumi.set(__self__, "is_expiration_required", is_expiration_required)
        if maximum_duration is not None:
            pulumi.set(__self__, "maximum_duration", maximum_duration)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        The type of rule
        Expected value is 'RoleManagementPolicyExpirationRule'.
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isExpirationRequired")
    def is_expiration_required(self) -> Optional[bool]:
        """
        The value indicating whether expiration is required.
        """
        return pulumi.get(self, "is_expiration_required")

    @property
    @pulumi.getter(name="maximumDuration")
    def maximum_duration(self) -> Optional[str]:
        """
        The maximum duration of expiration in timespan.
        """
        return pulumi.get(self, "maximum_duration")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.RoleManagementPolicyRuleTargetResponse']:
        """
        The target of the current rule.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class RoleManagementPolicyNotificationRuleResponse(dict):
    """
    The role management policy notification rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleType":
            suggest = "rule_type"
        elif key == "isDefaultRecipientsEnabled":
            suggest = "is_default_recipients_enabled"
        elif key == "notificationLevel":
            suggest = "notification_level"
        elif key == "notificationRecipients":
            suggest = "notification_recipients"
        elif key == "notificationType":
            suggest = "notification_type"
        elif key == "recipientType":
            suggest = "recipient_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoleManagementPolicyNotificationRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoleManagementPolicyNotificationRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoleManagementPolicyNotificationRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_type: str,
                 id: Optional[str] = None,
                 is_default_recipients_enabled: Optional[bool] = None,
                 notification_level: Optional[str] = None,
                 notification_recipients: Optional[Sequence[str]] = None,
                 notification_type: Optional[str] = None,
                 recipient_type: Optional[str] = None,
                 target: Optional['outputs.RoleManagementPolicyRuleTargetResponse'] = None):
        """
        The role management policy notification rule.
        :param str rule_type: The type of rule
               Expected value is 'RoleManagementPolicyNotificationRule'.
        :param str id: The id of the rule.
        :param bool is_default_recipients_enabled: Determines if the notification will be sent to the recipient type specified in the policy rule.
        :param str notification_level: The notification level.
        :param Sequence[str] notification_recipients: The list of notification recipients.
        :param str notification_type: The type of notification.
        :param str recipient_type: The recipient type.
        :param 'RoleManagementPolicyRuleTargetResponse' target: The target of the current rule.
        """
        pulumi.set(__self__, "rule_type", 'RoleManagementPolicyNotificationRule')
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_default_recipients_enabled is not None:
            pulumi.set(__self__, "is_default_recipients_enabled", is_default_recipients_enabled)
        if notification_level is not None:
            pulumi.set(__self__, "notification_level", notification_level)
        if notification_recipients is not None:
            pulumi.set(__self__, "notification_recipients", notification_recipients)
        if notification_type is not None:
            pulumi.set(__self__, "notification_type", notification_type)
        if recipient_type is not None:
            pulumi.set(__self__, "recipient_type", recipient_type)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        The type of rule
        Expected value is 'RoleManagementPolicyNotificationRule'.
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isDefaultRecipientsEnabled")
    def is_default_recipients_enabled(self) -> Optional[bool]:
        """
        Determines if the notification will be sent to the recipient type specified in the policy rule.
        """
        return pulumi.get(self, "is_default_recipients_enabled")

    @property
    @pulumi.getter(name="notificationLevel")
    def notification_level(self) -> Optional[str]:
        """
        The notification level.
        """
        return pulumi.get(self, "notification_level")

    @property
    @pulumi.getter(name="notificationRecipients")
    def notification_recipients(self) -> Optional[Sequence[str]]:
        """
        The list of notification recipients.
        """
        return pulumi.get(self, "notification_recipients")

    @property
    @pulumi.getter(name="notificationType")
    def notification_type(self) -> Optional[str]:
        """
        The type of notification.
        """
        return pulumi.get(self, "notification_type")

    @property
    @pulumi.getter(name="recipientType")
    def recipient_type(self) -> Optional[str]:
        """
        The recipient type.
        """
        return pulumi.get(self, "recipient_type")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.RoleManagementPolicyRuleTargetResponse']:
        """
        The target of the current rule.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class RoleManagementPolicyRuleTargetResponse(dict):
    """
    The role management policy rule target.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enforcedSettings":
            suggest = "enforced_settings"
        elif key == "inheritableSettings":
            suggest = "inheritable_settings"
        elif key == "targetObjects":
            suggest = "target_objects"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoleManagementPolicyRuleTargetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoleManagementPolicyRuleTargetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoleManagementPolicyRuleTargetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 caller: Optional[str] = None,
                 enforced_settings: Optional[Sequence[str]] = None,
                 inheritable_settings: Optional[Sequence[str]] = None,
                 level: Optional[str] = None,
                 operations: Optional[Sequence[str]] = None,
                 target_objects: Optional[Sequence[str]] = None):
        """
        The role management policy rule target.
        :param str caller: The caller of the setting.
        :param Sequence[str] enforced_settings: The list of enforced settings.
        :param Sequence[str] inheritable_settings: The list of inheritable settings.
        :param str level: The assignment level to which rule is applied.
        :param Sequence[str] operations: The type of operation.
        :param Sequence[str] target_objects: The list of target objects.
        """
        if caller is not None:
            pulumi.set(__self__, "caller", caller)
        if enforced_settings is not None:
            pulumi.set(__self__, "enforced_settings", enforced_settings)
        if inheritable_settings is not None:
            pulumi.set(__self__, "inheritable_settings", inheritable_settings)
        if level is not None:
            pulumi.set(__self__, "level", level)
        if operations is not None:
            pulumi.set(__self__, "operations", operations)
        if target_objects is not None:
            pulumi.set(__self__, "target_objects", target_objects)

    @property
    @pulumi.getter
    def caller(self) -> Optional[str]:
        """
        The caller of the setting.
        """
        return pulumi.get(self, "caller")

    @property
    @pulumi.getter(name="enforcedSettings")
    def enforced_settings(self) -> Optional[Sequence[str]]:
        """
        The list of enforced settings.
        """
        return pulumi.get(self, "enforced_settings")

    @property
    @pulumi.getter(name="inheritableSettings")
    def inheritable_settings(self) -> Optional[Sequence[str]]:
        """
        The list of inheritable settings.
        """
        return pulumi.get(self, "inheritable_settings")

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        The assignment level to which rule is applied.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def operations(self) -> Optional[Sequence[str]]:
        """
        The type of operation.
        """
        return pulumi.get(self, "operations")

    @property
    @pulumi.getter(name="targetObjects")
    def target_objects(self) -> Optional[Sequence[str]]:
        """
        The list of target objects.
        """
        return pulumi.get(self, "target_objects")


@pulumi.output_type
class SelectorResponse(dict):
    """
    The selector expression.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "in":
            suggest = "in_"
        elif key == "notIn":
            suggest = "not_in"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SelectorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SelectorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SelectorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 in_: Optional[Sequence[str]] = None,
                 kind: Optional[str] = None,
                 not_in: Optional[Sequence[str]] = None):
        """
        The selector expression.
        :param Sequence[str] in_: The list of values to filter in.
        :param str kind: The selector kind.
        :param Sequence[str] not_in: The list of values to filter out.
        """
        if in_ is not None:
            pulumi.set(__self__, "in_", in_)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if not_in is not None:
            pulumi.set(__self__, "not_in", not_in)

    @property
    @pulumi.getter(name="in")
    def in_(self) -> Optional[Sequence[str]]:
        """
        The list of values to filter in.
        """
        return pulumi.get(self, "in_")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        The selector kind.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="notIn")
    def not_in(self) -> Optional[Sequence[str]]:
        """
        The list of values to filter out.
        """
        return pulumi.get(self, "not_in")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class UserSetResponse(dict):
    """
    The detail of a user.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isBackup":
            suggest = "is_backup"
        elif key == "userType":
            suggest = "user_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserSetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserSetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserSetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 id: Optional[str] = None,
                 is_backup: Optional[bool] = None,
                 user_type: Optional[str] = None):
        """
        The detail of a user.
        :param str description: The description of the user.
        :param str id: The object id of the user.
        :param bool is_backup: The value indicating whether the user is a backup fallback approver
        :param str user_type: The type of user.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_backup is not None:
            pulumi.set(__self__, "is_backup", is_backup)
        if user_type is not None:
            pulumi.set(__self__, "user_type", user_type)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the user.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The object id of the user.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isBackup")
    def is_backup(self) -> Optional[bool]:
        """
        The value indicating whether the user is a backup fallback approver
        """
        return pulumi.get(self, "is_backup")

    @property
    @pulumi.getter(name="userType")
    def user_type(self) -> Optional[str]:
        """
        The type of user.
        """
        return pulumi.get(self, "user_type")


