# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AccessReviewHistoryInstanceArgs',
    'AccessReviewHistoryInstanceArgsDict',
    'AccessReviewInstanceArgs',
    'AccessReviewInstanceArgsDict',
    'AccessReviewRecurrenceRangeArgs',
    'AccessReviewRecurrenceRangeArgsDict',
    'AccessReviewReviewerArgs',
    'AccessReviewReviewerArgsDict',
    'AccessReviewScopeArgs',
    'AccessReviewScopeArgsDict',
    'ApprovalSettingsArgs',
    'ApprovalSettingsArgsDict',
    'ApprovalStageArgs',
    'ApprovalStageArgsDict',
    'IdentityArgs',
    'IdentityArgsDict',
    'ManagementLockOwnerArgs',
    'ManagementLockOwnerArgsDict',
    'NonComplianceMessageArgs',
    'NonComplianceMessageArgsDict',
    'OverrideArgs',
    'OverrideArgsDict',
    'PIMOnlyModeSettingsArgs',
    'PIMOnlyModeSettingsArgsDict',
    'ParameterDefinitionsValueMetadataArgs',
    'ParameterDefinitionsValueMetadataArgsDict',
    'ParameterDefinitionsValueArgs',
    'ParameterDefinitionsValueArgsDict',
    'ParameterValuesValueArgs',
    'ParameterValuesValueArgsDict',
    'PermissionArgs',
    'PermissionArgsDict',
    'PolicyDefinitionGroupArgs',
    'PolicyDefinitionGroupArgsDict',
    'PolicyDefinitionReferenceArgs',
    'PolicyDefinitionReferenceArgsDict',
    'PolicyVariableColumnArgs',
    'PolicyVariableColumnArgsDict',
    'PolicyVariableValueColumnValueArgs',
    'PolicyVariableValueColumnValueArgsDict',
    'PrivateLinkAssociationPropertiesArgs',
    'PrivateLinkAssociationPropertiesArgsDict',
    'ResourceSelectorArgs',
    'ResourceSelectorArgsDict',
    'RoleEligibilityScheduleRequestPropertiesExpirationArgs',
    'RoleEligibilityScheduleRequestPropertiesExpirationArgsDict',
    'RoleEligibilityScheduleRequestPropertiesScheduleInfoArgs',
    'RoleEligibilityScheduleRequestPropertiesScheduleInfoArgsDict',
    'RoleEligibilityScheduleRequestPropertiesTicketInfoArgs',
    'RoleEligibilityScheduleRequestPropertiesTicketInfoArgsDict',
    'RoleManagementPolicyApprovalRuleArgs',
    'RoleManagementPolicyApprovalRuleArgsDict',
    'RoleManagementPolicyAuthenticationContextRuleArgs',
    'RoleManagementPolicyAuthenticationContextRuleArgsDict',
    'RoleManagementPolicyEnablementRuleArgs',
    'RoleManagementPolicyEnablementRuleArgsDict',
    'RoleManagementPolicyExpirationRuleArgs',
    'RoleManagementPolicyExpirationRuleArgsDict',
    'RoleManagementPolicyNotificationRuleArgs',
    'RoleManagementPolicyNotificationRuleArgsDict',
    'RoleManagementPolicyPimOnlyModeRuleArgs',
    'RoleManagementPolicyPimOnlyModeRuleArgsDict',
    'RoleManagementPolicyRuleTargetArgs',
    'RoleManagementPolicyRuleTargetArgsDict',
    'SelectorArgs',
    'SelectorArgsDict',
    'UserSetArgs',
    'UserSetArgsDict',
    'UsersOrServicePrincipalSetArgs',
    'UsersOrServicePrincipalSetArgsDict',
]

MYPY = False

if not MYPY:
    class AccessReviewHistoryInstanceArgsDict(TypedDict):
        """
        Access Review History Definition Instance.
        """
        display_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The display name for the parent history definition.
        """
        expiration: NotRequired[pulumi.Input[builtins.str]]
        """
        Date time when history data report expires and the associated data is deleted.
        """
        fulfilled_date_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Date time when the history data report is scheduled to be generated.
        """
        review_history_period_end_date_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Date time used when selecting review data, all reviews included in data end on or before this date. For use only with one-time/non-recurring reports.
        """
        review_history_period_start_date_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Date time used when selecting review data, all reviews included in data start on or after this date. For use only with one-time/non-recurring reports.
        """
        run_date_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Date time when the history data report is scheduled to be generated.
        """
elif False:
    AccessReviewHistoryInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessReviewHistoryInstanceArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[builtins.str]] = None,
                 expiration: Optional[pulumi.Input[builtins.str]] = None,
                 fulfilled_date_time: Optional[pulumi.Input[builtins.str]] = None,
                 review_history_period_end_date_time: Optional[pulumi.Input[builtins.str]] = None,
                 review_history_period_start_date_time: Optional[pulumi.Input[builtins.str]] = None,
                 run_date_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        Access Review History Definition Instance.
        :param pulumi.Input[builtins.str] display_name: The display name for the parent history definition.
        :param pulumi.Input[builtins.str] expiration: Date time when history data report expires and the associated data is deleted.
        :param pulumi.Input[builtins.str] fulfilled_date_time: Date time when the history data report is scheduled to be generated.
        :param pulumi.Input[builtins.str] review_history_period_end_date_time: Date time used when selecting review data, all reviews included in data end on or before this date. For use only with one-time/non-recurring reports.
        :param pulumi.Input[builtins.str] review_history_period_start_date_time: Date time used when selecting review data, all reviews included in data start on or after this date. For use only with one-time/non-recurring reports.
        :param pulumi.Input[builtins.str] run_date_time: Date time when the history data report is scheduled to be generated.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if fulfilled_date_time is not None:
            pulumi.set(__self__, "fulfilled_date_time", fulfilled_date_time)
        if review_history_period_end_date_time is not None:
            pulumi.set(__self__, "review_history_period_end_date_time", review_history_period_end_date_time)
        if review_history_period_start_date_time is not None:
            pulumi.set(__self__, "review_history_period_start_date_time", review_history_period_start_date_time)
        if run_date_time is not None:
            pulumi.set(__self__, "run_date_time", run_date_time)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The display name for the parent history definition.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Date time when history data report expires and the associated data is deleted.
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "expiration", value)

    @property
    @pulumi.getter(name="fulfilledDateTime")
    def fulfilled_date_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Date time when the history data report is scheduled to be generated.
        """
        return pulumi.get(self, "fulfilled_date_time")

    @fulfilled_date_time.setter
    def fulfilled_date_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "fulfilled_date_time", value)

    @property
    @pulumi.getter(name="reviewHistoryPeriodEndDateTime")
    def review_history_period_end_date_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Date time used when selecting review data, all reviews included in data end on or before this date. For use only with one-time/non-recurring reports.
        """
        return pulumi.get(self, "review_history_period_end_date_time")

    @review_history_period_end_date_time.setter
    def review_history_period_end_date_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "review_history_period_end_date_time", value)

    @property
    @pulumi.getter(name="reviewHistoryPeriodStartDateTime")
    def review_history_period_start_date_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Date time used when selecting review data, all reviews included in data start on or after this date. For use only with one-time/non-recurring reports.
        """
        return pulumi.get(self, "review_history_period_start_date_time")

    @review_history_period_start_date_time.setter
    def review_history_period_start_date_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "review_history_period_start_date_time", value)

    @property
    @pulumi.getter(name="runDateTime")
    def run_date_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Date time when the history data report is scheduled to be generated.
        """
        return pulumi.get(self, "run_date_time")

    @run_date_time.setter
    def run_date_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "run_date_time", value)


if not MYPY:
    class AccessReviewInstanceArgsDict(TypedDict):
        """
        Access Review Instance.
        """
        backup_reviewers: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessReviewReviewerArgsDict']]]]
        """
        This is the collection of backup reviewers.
        """
        end_date_time: NotRequired[pulumi.Input[builtins.str]]
        """
        The DateTime when the review instance is scheduled to end.
        """
        reviewers: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessReviewReviewerArgsDict']]]]
        """
        This is the collection of reviewers.
        """
        start_date_time: NotRequired[pulumi.Input[builtins.str]]
        """
        The DateTime when the review instance is scheduled to be start.
        """
elif False:
    AccessReviewInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessReviewInstanceArgs:
    def __init__(__self__, *,
                 backup_reviewers: Optional[pulumi.Input[Sequence[pulumi.Input['AccessReviewReviewerArgs']]]] = None,
                 end_date_time: Optional[pulumi.Input[builtins.str]] = None,
                 reviewers: Optional[pulumi.Input[Sequence[pulumi.Input['AccessReviewReviewerArgs']]]] = None,
                 start_date_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        Access Review Instance.
        :param pulumi.Input[Sequence[pulumi.Input['AccessReviewReviewerArgs']]] backup_reviewers: This is the collection of backup reviewers.
        :param pulumi.Input[builtins.str] end_date_time: The DateTime when the review instance is scheduled to end.
        :param pulumi.Input[Sequence[pulumi.Input['AccessReviewReviewerArgs']]] reviewers: This is the collection of reviewers.
        :param pulumi.Input[builtins.str] start_date_time: The DateTime when the review instance is scheduled to be start.
        """
        if backup_reviewers is not None:
            pulumi.set(__self__, "backup_reviewers", backup_reviewers)
        if end_date_time is not None:
            pulumi.set(__self__, "end_date_time", end_date_time)
        if reviewers is not None:
            pulumi.set(__self__, "reviewers", reviewers)
        if start_date_time is not None:
            pulumi.set(__self__, "start_date_time", start_date_time)

    @property
    @pulumi.getter(name="backupReviewers")
    def backup_reviewers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessReviewReviewerArgs']]]]:
        """
        This is the collection of backup reviewers.
        """
        return pulumi.get(self, "backup_reviewers")

    @backup_reviewers.setter
    def backup_reviewers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessReviewReviewerArgs']]]]):
        pulumi.set(self, "backup_reviewers", value)

    @property
    @pulumi.getter(name="endDateTime")
    def end_date_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The DateTime when the review instance is scheduled to end.
        """
        return pulumi.get(self, "end_date_time")

    @end_date_time.setter
    def end_date_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_date_time", value)

    @property
    @pulumi.getter
    def reviewers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessReviewReviewerArgs']]]]:
        """
        This is the collection of reviewers.
        """
        return pulumi.get(self, "reviewers")

    @reviewers.setter
    def reviewers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessReviewReviewerArgs']]]]):
        pulumi.set(self, "reviewers", value)

    @property
    @pulumi.getter(name="startDateTime")
    def start_date_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The DateTime when the review instance is scheduled to be start.
        """
        return pulumi.get(self, "start_date_time")

    @start_date_time.setter
    def start_date_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_date_time", value)


if not MYPY:
    class AccessReviewRecurrenceRangeArgsDict(TypedDict):
        """
        Recurrence Range of an Access Review Schedule Definition.
        """
        end_date: NotRequired[pulumi.Input[builtins.str]]
        """
        The DateTime when the review is scheduled to end. Required if type is endDate
        """
        number_of_occurrences: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of times to repeat the access review. Required and must be positive if type is numbered.
        """
        start_date: NotRequired[pulumi.Input[builtins.str]]
        """
        The DateTime when the review is scheduled to be start. This could be a date in the future. Required on create.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'AccessReviewRecurrenceRangeType']]]
        """
        The recurrence range type. The possible values are: endDate, noEnd, numbered.
        """
elif False:
    AccessReviewRecurrenceRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessReviewRecurrenceRangeArgs:
    def __init__(__self__, *,
                 end_date: Optional[pulumi.Input[builtins.str]] = None,
                 number_of_occurrences: Optional[pulumi.Input[builtins.int]] = None,
                 start_date: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[Union[builtins.str, 'AccessReviewRecurrenceRangeType']]] = None):
        """
        Recurrence Range of an Access Review Schedule Definition.
        :param pulumi.Input[builtins.str] end_date: The DateTime when the review is scheduled to end. Required if type is endDate
        :param pulumi.Input[builtins.int] number_of_occurrences: The number of times to repeat the access review. Required and must be positive if type is numbered.
        :param pulumi.Input[builtins.str] start_date: The DateTime when the review is scheduled to be start. This could be a date in the future. Required on create.
        :param pulumi.Input[Union[builtins.str, 'AccessReviewRecurrenceRangeType']] type: The recurrence range type. The possible values are: endDate, noEnd, numbered.
        """
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if number_of_occurrences is not None:
            pulumi.set(__self__, "number_of_occurrences", number_of_occurrences)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The DateTime when the review is scheduled to end. Required if type is endDate
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="numberOfOccurrences")
    def number_of_occurrences(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of times to repeat the access review. Required and must be positive if type is numbered.
        """
        return pulumi.get(self, "number_of_occurrences")

    @number_of_occurrences.setter
    def number_of_occurrences(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "number_of_occurrences", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The DateTime when the review is scheduled to be start. This could be a date in the future. Required on create.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'AccessReviewRecurrenceRangeType']]]:
        """
        The recurrence range type. The possible values are: endDate, noEnd, numbered.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'AccessReviewRecurrenceRangeType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AccessReviewReviewerArgsDict(TypedDict):
        """
        Descriptor for what needs to be reviewed
        """
        principal_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The id of the reviewer(user/servicePrincipal)
        """
elif False:
    AccessReviewReviewerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessReviewReviewerArgs:
    def __init__(__self__, *,
                 principal_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Descriptor for what needs to be reviewed
        :param pulumi.Input[builtins.str] principal_id: The id of the reviewer(user/servicePrincipal)
        """
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The id of the reviewer(user/servicePrincipal)
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "principal_id", value)


if not MYPY:
    class AccessReviewScopeArgsDict(TypedDict):
        """
        Descriptor for what needs to be reviewed
        """
        exclude_resource_id: NotRequired[pulumi.Input[builtins.str]]
        """
        This is used to indicate the resource id(s) to exclude
        """
        exclude_role_definition_id: NotRequired[pulumi.Input[builtins.str]]
        """
        This is used to indicate the role definition id(s) to exclude
        """
        expand_nested_memberships: NotRequired[pulumi.Input[builtins.bool]]
        """
        Flag to indicate whether to expand nested memberships or not.
        """
        inactive_duration: NotRequired[pulumi.Input[builtins.str]]
        """
        Duration users are inactive for. The value should be in ISO  8601 format (http://en.wikipedia.org/wiki/ISO_8601#Durations).This code can be used to convert TimeSpan to a valid interval string: XmlConvert.ToString(new TimeSpan(hours, minutes, seconds))
        """
        include_access_below_resource: NotRequired[pulumi.Input[builtins.bool]]
        """
        Flag to indicate whether to expand nested memberships or not.
        """
        include_inherited_access: NotRequired[pulumi.Input[builtins.bool]]
        """
        Flag to indicate whether to expand nested memberships or not.
        """
elif False:
    AccessReviewScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessReviewScopeArgs:
    def __init__(__self__, *,
                 exclude_resource_id: Optional[pulumi.Input[builtins.str]] = None,
                 exclude_role_definition_id: Optional[pulumi.Input[builtins.str]] = None,
                 expand_nested_memberships: Optional[pulumi.Input[builtins.bool]] = None,
                 inactive_duration: Optional[pulumi.Input[builtins.str]] = None,
                 include_access_below_resource: Optional[pulumi.Input[builtins.bool]] = None,
                 include_inherited_access: Optional[pulumi.Input[builtins.bool]] = None):
        """
        Descriptor for what needs to be reviewed
        :param pulumi.Input[builtins.str] exclude_resource_id: This is used to indicate the resource id(s) to exclude
        :param pulumi.Input[builtins.str] exclude_role_definition_id: This is used to indicate the role definition id(s) to exclude
        :param pulumi.Input[builtins.bool] expand_nested_memberships: Flag to indicate whether to expand nested memberships or not.
        :param pulumi.Input[builtins.str] inactive_duration: Duration users are inactive for. The value should be in ISO  8601 format (http://en.wikipedia.org/wiki/ISO_8601#Durations).This code can be used to convert TimeSpan to a valid interval string: XmlConvert.ToString(new TimeSpan(hours, minutes, seconds))
        :param pulumi.Input[builtins.bool] include_access_below_resource: Flag to indicate whether to expand nested memberships or not.
        :param pulumi.Input[builtins.bool] include_inherited_access: Flag to indicate whether to expand nested memberships or not.
        """
        if exclude_resource_id is not None:
            pulumi.set(__self__, "exclude_resource_id", exclude_resource_id)
        if exclude_role_definition_id is not None:
            pulumi.set(__self__, "exclude_role_definition_id", exclude_role_definition_id)
        if expand_nested_memberships is not None:
            pulumi.set(__self__, "expand_nested_memberships", expand_nested_memberships)
        if inactive_duration is not None:
            pulumi.set(__self__, "inactive_duration", inactive_duration)
        if include_access_below_resource is not None:
            pulumi.set(__self__, "include_access_below_resource", include_access_below_resource)
        if include_inherited_access is not None:
            pulumi.set(__self__, "include_inherited_access", include_inherited_access)

    @property
    @pulumi.getter(name="excludeResourceId")
    def exclude_resource_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        This is used to indicate the resource id(s) to exclude
        """
        return pulumi.get(self, "exclude_resource_id")

    @exclude_resource_id.setter
    def exclude_resource_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "exclude_resource_id", value)

    @property
    @pulumi.getter(name="excludeRoleDefinitionId")
    def exclude_role_definition_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        This is used to indicate the role definition id(s) to exclude
        """
        return pulumi.get(self, "exclude_role_definition_id")

    @exclude_role_definition_id.setter
    def exclude_role_definition_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "exclude_role_definition_id", value)

    @property
    @pulumi.getter(name="expandNestedMemberships")
    def expand_nested_memberships(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag to indicate whether to expand nested memberships or not.
        """
        return pulumi.get(self, "expand_nested_memberships")

    @expand_nested_memberships.setter
    def expand_nested_memberships(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "expand_nested_memberships", value)

    @property
    @pulumi.getter(name="inactiveDuration")
    def inactive_duration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Duration users are inactive for. The value should be in ISO  8601 format (http://en.wikipedia.org/wiki/ISO_8601#Durations).This code can be used to convert TimeSpan to a valid interval string: XmlConvert.ToString(new TimeSpan(hours, minutes, seconds))
        """
        return pulumi.get(self, "inactive_duration")

    @inactive_duration.setter
    def inactive_duration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "inactive_duration", value)

    @property
    @pulumi.getter(name="includeAccessBelowResource")
    def include_access_below_resource(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag to indicate whether to expand nested memberships or not.
        """
        return pulumi.get(self, "include_access_below_resource")

    @include_access_below_resource.setter
    def include_access_below_resource(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "include_access_below_resource", value)

    @property
    @pulumi.getter(name="includeInheritedAccess")
    def include_inherited_access(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag to indicate whether to expand nested memberships or not.
        """
        return pulumi.get(self, "include_inherited_access")

    @include_inherited_access.setter
    def include_inherited_access(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "include_inherited_access", value)


if not MYPY:
    class ApprovalSettingsArgsDict(TypedDict):
        """
        The approval settings.
        """
        approval_mode: NotRequired[pulumi.Input[Union[builtins.str, 'ApprovalMode']]]
        """
        The type of rule
        """
        approval_stages: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApprovalStageArgsDict']]]]
        """
        The approval stages of the request.
        """
        is_approval_required: NotRequired[pulumi.Input[builtins.bool]]
        """
        Determines whether approval is required or not.
        """
        is_approval_required_for_extension: NotRequired[pulumi.Input[builtins.bool]]
        """
        Determines whether approval is required for assignment extension.
        """
        is_requestor_justification_required: NotRequired[pulumi.Input[builtins.bool]]
        """
        Determine whether requestor justification is required.
        """
elif False:
    ApprovalSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApprovalSettingsArgs:
    def __init__(__self__, *,
                 approval_mode: Optional[pulumi.Input[Union[builtins.str, 'ApprovalMode']]] = None,
                 approval_stages: Optional[pulumi.Input[Sequence[pulumi.Input['ApprovalStageArgs']]]] = None,
                 is_approval_required: Optional[pulumi.Input[builtins.bool]] = None,
                 is_approval_required_for_extension: Optional[pulumi.Input[builtins.bool]] = None,
                 is_requestor_justification_required: Optional[pulumi.Input[builtins.bool]] = None):
        """
        The approval settings.
        :param pulumi.Input[Union[builtins.str, 'ApprovalMode']] approval_mode: The type of rule
        :param pulumi.Input[Sequence[pulumi.Input['ApprovalStageArgs']]] approval_stages: The approval stages of the request.
        :param pulumi.Input[builtins.bool] is_approval_required: Determines whether approval is required or not.
        :param pulumi.Input[builtins.bool] is_approval_required_for_extension: Determines whether approval is required for assignment extension.
        :param pulumi.Input[builtins.bool] is_requestor_justification_required: Determine whether requestor justification is required.
        """
        if approval_mode is not None:
            pulumi.set(__self__, "approval_mode", approval_mode)
        if approval_stages is not None:
            pulumi.set(__self__, "approval_stages", approval_stages)
        if is_approval_required is not None:
            pulumi.set(__self__, "is_approval_required", is_approval_required)
        if is_approval_required_for_extension is not None:
            pulumi.set(__self__, "is_approval_required_for_extension", is_approval_required_for_extension)
        if is_requestor_justification_required is not None:
            pulumi.set(__self__, "is_requestor_justification_required", is_requestor_justification_required)

    @property
    @pulumi.getter(name="approvalMode")
    def approval_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'ApprovalMode']]]:
        """
        The type of rule
        """
        return pulumi.get(self, "approval_mode")

    @approval_mode.setter
    def approval_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'ApprovalMode']]]):
        pulumi.set(self, "approval_mode", value)

    @property
    @pulumi.getter(name="approvalStages")
    def approval_stages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApprovalStageArgs']]]]:
        """
        The approval stages of the request.
        """
        return pulumi.get(self, "approval_stages")

    @approval_stages.setter
    def approval_stages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApprovalStageArgs']]]]):
        pulumi.set(self, "approval_stages", value)

    @property
    @pulumi.getter(name="isApprovalRequired")
    def is_approval_required(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Determines whether approval is required or not.
        """
        return pulumi.get(self, "is_approval_required")

    @is_approval_required.setter
    def is_approval_required(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_approval_required", value)

    @property
    @pulumi.getter(name="isApprovalRequiredForExtension")
    def is_approval_required_for_extension(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Determines whether approval is required for assignment extension.
        """
        return pulumi.get(self, "is_approval_required_for_extension")

    @is_approval_required_for_extension.setter
    def is_approval_required_for_extension(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_approval_required_for_extension", value)

    @property
    @pulumi.getter(name="isRequestorJustificationRequired")
    def is_requestor_justification_required(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Determine whether requestor justification is required.
        """
        return pulumi.get(self, "is_requestor_justification_required")

    @is_requestor_justification_required.setter
    def is_requestor_justification_required(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_requestor_justification_required", value)


if not MYPY:
    class ApprovalStageArgsDict(TypedDict):
        """
        The approval stage.
        """
        approval_stage_time_out_in_days: NotRequired[pulumi.Input[builtins.int]]
        """
        The time in days when approval request would be timed out
        """
        escalation_approvers: NotRequired[pulumi.Input[Sequence[pulumi.Input['UserSetArgsDict']]]]
        """
        The escalation approver of the request.
        """
        escalation_time_in_minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        The time in minutes when the approval request would be escalated if the primary approver does not approve
        """
        is_approver_justification_required: NotRequired[pulumi.Input[builtins.bool]]
        """
        Determines whether approver need to provide justification for his decision.
        """
        is_escalation_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        The value determine whether escalation feature is enabled.
        """
        primary_approvers: NotRequired[pulumi.Input[Sequence[pulumi.Input['UserSetArgsDict']]]]
        """
        The primary approver of the request.
        """
elif False:
    ApprovalStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApprovalStageArgs:
    def __init__(__self__, *,
                 approval_stage_time_out_in_days: Optional[pulumi.Input[builtins.int]] = None,
                 escalation_approvers: Optional[pulumi.Input[Sequence[pulumi.Input['UserSetArgs']]]] = None,
                 escalation_time_in_minutes: Optional[pulumi.Input[builtins.int]] = None,
                 is_approver_justification_required: Optional[pulumi.Input[builtins.bool]] = None,
                 is_escalation_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 primary_approvers: Optional[pulumi.Input[Sequence[pulumi.Input['UserSetArgs']]]] = None):
        """
        The approval stage.
        :param pulumi.Input[builtins.int] approval_stage_time_out_in_days: The time in days when approval request would be timed out
        :param pulumi.Input[Sequence[pulumi.Input['UserSetArgs']]] escalation_approvers: The escalation approver of the request.
        :param pulumi.Input[builtins.int] escalation_time_in_minutes: The time in minutes when the approval request would be escalated if the primary approver does not approve
        :param pulumi.Input[builtins.bool] is_approver_justification_required: Determines whether approver need to provide justification for his decision.
        :param pulumi.Input[builtins.bool] is_escalation_enabled: The value determine whether escalation feature is enabled.
        :param pulumi.Input[Sequence[pulumi.Input['UserSetArgs']]] primary_approvers: The primary approver of the request.
        """
        if approval_stage_time_out_in_days is not None:
            pulumi.set(__self__, "approval_stage_time_out_in_days", approval_stage_time_out_in_days)
        if escalation_approvers is not None:
            pulumi.set(__self__, "escalation_approvers", escalation_approvers)
        if escalation_time_in_minutes is not None:
            pulumi.set(__self__, "escalation_time_in_minutes", escalation_time_in_minutes)
        if is_approver_justification_required is not None:
            pulumi.set(__self__, "is_approver_justification_required", is_approver_justification_required)
        if is_escalation_enabled is not None:
            pulumi.set(__self__, "is_escalation_enabled", is_escalation_enabled)
        if primary_approvers is not None:
            pulumi.set(__self__, "primary_approvers", primary_approvers)

    @property
    @pulumi.getter(name="approvalStageTimeOutInDays")
    def approval_stage_time_out_in_days(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The time in days when approval request would be timed out
        """
        return pulumi.get(self, "approval_stage_time_out_in_days")

    @approval_stage_time_out_in_days.setter
    def approval_stage_time_out_in_days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "approval_stage_time_out_in_days", value)

    @property
    @pulumi.getter(name="escalationApprovers")
    def escalation_approvers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserSetArgs']]]]:
        """
        The escalation approver of the request.
        """
        return pulumi.get(self, "escalation_approvers")

    @escalation_approvers.setter
    def escalation_approvers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserSetArgs']]]]):
        pulumi.set(self, "escalation_approvers", value)

    @property
    @pulumi.getter(name="escalationTimeInMinutes")
    def escalation_time_in_minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The time in minutes when the approval request would be escalated if the primary approver does not approve
        """
        return pulumi.get(self, "escalation_time_in_minutes")

    @escalation_time_in_minutes.setter
    def escalation_time_in_minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "escalation_time_in_minutes", value)

    @property
    @pulumi.getter(name="isApproverJustificationRequired")
    def is_approver_justification_required(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Determines whether approver need to provide justification for his decision.
        """
        return pulumi.get(self, "is_approver_justification_required")

    @is_approver_justification_required.setter
    def is_approver_justification_required(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_approver_justification_required", value)

    @property
    @pulumi.getter(name="isEscalationEnabled")
    def is_escalation_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        The value determine whether escalation feature is enabled.
        """
        return pulumi.get(self, "is_escalation_enabled")

    @is_escalation_enabled.setter
    def is_escalation_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_escalation_enabled", value)

    @property
    @pulumi.getter(name="primaryApprovers")
    def primary_approvers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserSetArgs']]]]:
        """
        The primary approver of the request.
        """
        return pulumi.get(self, "primary_approvers")

    @primary_approvers.setter
    def primary_approvers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserSetArgs']]]]):
        pulumi.set(self, "primary_approvers", value)


if not MYPY:
    class IdentityArgsDict(TypedDict):
        """
        Identity for the resource.  Policy assignments support a maximum of one identity.  That is either a system assigned identity or a single user assigned identity.
        """
        type: NotRequired[pulumi.Input['ResourceIdentityType']]
        """
        The identity type. This is the only required field when adding a system or user assigned identity to a resource.
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The user identity associated with the policy. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
elif False:
    IdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['ResourceIdentityType']] = None,
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Identity for the resource.  Policy assignments support a maximum of one identity.  That is either a system assigned identity or a single user assigned identity.
        :param pulumi.Input['ResourceIdentityType'] type: The identity type. This is the only required field when adding a system or user assigned identity to a resource.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_assigned_identities: The user identity associated with the policy. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['ResourceIdentityType']]:
        """
        The identity type. This is the only required field when adding a system or user assigned identity to a resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['ResourceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The user identity associated with the policy. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class ManagementLockOwnerArgsDict(TypedDict):
        """
        Lock owner properties.
        """
        application_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The application ID of the lock owner.
        """
elif False:
    ManagementLockOwnerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementLockOwnerArgs:
    def __init__(__self__, *,
                 application_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Lock owner properties.
        :param pulumi.Input[builtins.str] application_id: The application ID of the lock owner.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The application ID of the lock owner.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "application_id", value)


if not MYPY:
    class NonComplianceMessageArgsDict(TypedDict):
        """
        A message that describes why a resource is non-compliant with the policy. This is shown in 'deny' error messages and on resource's non-compliant compliance results.
        """
        message: pulumi.Input[builtins.str]
        """
        A message that describes why a resource is non-compliant with the policy. This is shown in 'deny' error messages and on resource's non-compliant compliance results.
        """
        policy_definition_reference_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The policy definition reference ID within a policy set definition the message is intended for. This is only applicable if the policy assignment assigns a policy set definition. If this is not provided the message applies to all policies assigned by this policy assignment.
        """
elif False:
    NonComplianceMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NonComplianceMessageArgs:
    def __init__(__self__, *,
                 message: pulumi.Input[builtins.str],
                 policy_definition_reference_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        A message that describes why a resource is non-compliant with the policy. This is shown in 'deny' error messages and on resource's non-compliant compliance results.
        :param pulumi.Input[builtins.str] message: A message that describes why a resource is non-compliant with the policy. This is shown in 'deny' error messages and on resource's non-compliant compliance results.
        :param pulumi.Input[builtins.str] policy_definition_reference_id: The policy definition reference ID within a policy set definition the message is intended for. This is only applicable if the policy assignment assigns a policy set definition. If this is not provided the message applies to all policies assigned by this policy assignment.
        """
        pulumi.set(__self__, "message", message)
        if policy_definition_reference_id is not None:
            pulumi.set(__self__, "policy_definition_reference_id", policy_definition_reference_id)

    @property
    @pulumi.getter
    def message(self) -> pulumi.Input[builtins.str]:
        """
        A message that describes why a resource is non-compliant with the policy. This is shown in 'deny' error messages and on resource's non-compliant compliance results.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="policyDefinitionReferenceId")
    def policy_definition_reference_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The policy definition reference ID within a policy set definition the message is intended for. This is only applicable if the policy assignment assigns a policy set definition. If this is not provided the message applies to all policies assigned by this policy assignment.
        """
        return pulumi.get(self, "policy_definition_reference_id")

    @policy_definition_reference_id.setter
    def policy_definition_reference_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "policy_definition_reference_id", value)


if not MYPY:
    class OverrideArgsDict(TypedDict):
        """
        The policy property value override.
        """
        kind: NotRequired[pulumi.Input[Union[builtins.str, 'OverrideKind']]]
        """
        The override kind.
        """
        selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input['SelectorArgsDict']]]]
        """
        The list of the selector expressions.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        The value to override the policy property.
        """
elif False:
    OverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OverrideArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[Union[builtins.str, 'OverrideKind']]] = None,
                 selectors: Optional[pulumi.Input[Sequence[pulumi.Input['SelectorArgs']]]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        The policy property value override.
        :param pulumi.Input[Union[builtins.str, 'OverrideKind']] kind: The override kind.
        :param pulumi.Input[Sequence[pulumi.Input['SelectorArgs']]] selectors: The list of the selector expressions.
        :param pulumi.Input[builtins.str] value: The value to override the policy property.
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if selectors is not None:
            pulumi.set(__self__, "selectors", selectors)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[Union[builtins.str, 'OverrideKind']]]:
        """
        The override kind.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[Union[builtins.str, 'OverrideKind']]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SelectorArgs']]]]:
        """
        The list of the selector expressions.
        """
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SelectorArgs']]]]):
        pulumi.set(self, "selectors", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The value to override the policy property.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PIMOnlyModeSettingsArgsDict(TypedDict):
        """
        The PIM Only Mode settings.
        """
        excluded_assignment_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'ExcludedPrincipalTypes']]]]]
        """
        The list of excluded assignment types allowed.
        """
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input['UsersOrServicePrincipalSetArgsDict']]]]
        """
        The list of excluded entities that the rule does not apply to.
        """
        mode: NotRequired[pulumi.Input[Union[builtins.str, 'PIMOnlyMode']]]
        """
        Determines whether the setting is enabled, disabled or report only.
        """
elif False:
    PIMOnlyModeSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PIMOnlyModeSettingsArgs:
    def __init__(__self__, *,
                 excluded_assignment_types: Optional[pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'ExcludedPrincipalTypes']]]]] = None,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input['UsersOrServicePrincipalSetArgs']]]] = None,
                 mode: Optional[pulumi.Input[Union[builtins.str, 'PIMOnlyMode']]] = None):
        """
        The PIM Only Mode settings.
        :param pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'ExcludedPrincipalTypes']]]] excluded_assignment_types: The list of excluded assignment types allowed.
        :param pulumi.Input[Sequence[pulumi.Input['UsersOrServicePrincipalSetArgs']]] excludes: The list of excluded entities that the rule does not apply to.
        :param pulumi.Input[Union[builtins.str, 'PIMOnlyMode']] mode: Determines whether the setting is enabled, disabled or report only.
        """
        if excluded_assignment_types is not None:
            pulumi.set(__self__, "excluded_assignment_types", excluded_assignment_types)
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="excludedAssignmentTypes")
    def excluded_assignment_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'ExcludedPrincipalTypes']]]]]:
        """
        The list of excluded assignment types allowed.
        """
        return pulumi.get(self, "excluded_assignment_types")

    @excluded_assignment_types.setter
    def excluded_assignment_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'ExcludedPrincipalTypes']]]]]):
        pulumi.set(self, "excluded_assignment_types", value)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UsersOrServicePrincipalSetArgs']]]]:
        """
        The list of excluded entities that the rule does not apply to.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UsersOrServicePrincipalSetArgs']]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'PIMOnlyMode']]]:
        """
        Determines whether the setting is enabled, disabled or report only.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'PIMOnlyMode']]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class ParameterDefinitionsValueMetadataArgsDict(TypedDict):
        """
        General metadata for the parameter.
        """
        assign_permissions: NotRequired[pulumi.Input[builtins.bool]]
        """
        Set to true to have Azure portal create role assignments on the resource ID or resource scope value of this parameter during policy assignment. This property is useful in case you wish to assign permissions outside the assignment scope.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The description of the parameter.
        """
        display_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The display name for the parameter.
        """
        strong_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Used when assigning the policy definition through the portal. Provides a context aware list of values for the user to choose from.
        """
elif False:
    ParameterDefinitionsValueMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ParameterDefinitionsValueMetadataArgs:
    def __init__(__self__, *,
                 assign_permissions: Optional[pulumi.Input[builtins.bool]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 display_name: Optional[pulumi.Input[builtins.str]] = None,
                 strong_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        General metadata for the parameter.
        :param pulumi.Input[builtins.bool] assign_permissions: Set to true to have Azure portal create role assignments on the resource ID or resource scope value of this parameter during policy assignment. This property is useful in case you wish to assign permissions outside the assignment scope.
        :param pulumi.Input[builtins.str] description: The description of the parameter.
        :param pulumi.Input[builtins.str] display_name: The display name for the parameter.
        :param pulumi.Input[builtins.str] strong_type: Used when assigning the policy definition through the portal. Provides a context aware list of values for the user to choose from.
        """
        if assign_permissions is not None:
            pulumi.set(__self__, "assign_permissions", assign_permissions)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if strong_type is not None:
            pulumi.set(__self__, "strong_type", strong_type)

    @property
    @pulumi.getter(name="assignPermissions")
    def assign_permissions(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Set to true to have Azure portal create role assignments on the resource ID or resource scope value of this parameter during policy assignment. This property is useful in case you wish to assign permissions outside the assignment scope.
        """
        return pulumi.get(self, "assign_permissions")

    @assign_permissions.setter
    def assign_permissions(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "assign_permissions", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description of the parameter.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The display name for the parameter.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="strongType")
    def strong_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Used when assigning the policy definition through the portal. Provides a context aware list of values for the user to choose from.
        """
        return pulumi.get(self, "strong_type")

    @strong_type.setter
    def strong_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "strong_type", value)


if not MYPY:
    class ParameterDefinitionsValueArgsDict(TypedDict):
        """
        The definition of a parameter that can be provided to the policy.
        """
        allowed_values: NotRequired[pulumi.Input[Sequence[Any]]]
        """
        The allowed values for the parameter.
        """
        default_value: NotRequired[Any]
        """
        The default value for the parameter if no value is provided.
        """
        metadata: NotRequired[pulumi.Input['ParameterDefinitionsValueMetadataArgsDict']]
        """
        General metadata for the parameter.
        """
        schema: NotRequired[Any]
        """
        Provides validation of parameter inputs during assignment using a self-defined JSON schema. This property is only supported for object-type parameters and follows the Json.NET Schema 2019-09 implementation. You can learn more about using schemas at https://json-schema.org/ and test draft schemas at https://www.jsonschemavalidator.net/.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'ParameterType']]]
        """
        The data type of the parameter.
        """
elif False:
    ParameterDefinitionsValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ParameterDefinitionsValueArgs:
    def __init__(__self__, *,
                 allowed_values: Optional[pulumi.Input[Sequence[Any]]] = None,
                 default_value: Optional[Any] = None,
                 metadata: Optional[pulumi.Input['ParameterDefinitionsValueMetadataArgs']] = None,
                 schema: Optional[Any] = None,
                 type: Optional[pulumi.Input[Union[builtins.str, 'ParameterType']]] = None):
        """
        The definition of a parameter that can be provided to the policy.
        :param pulumi.Input[Sequence[Any]] allowed_values: The allowed values for the parameter.
        :param Any default_value: The default value for the parameter if no value is provided.
        :param pulumi.Input['ParameterDefinitionsValueMetadataArgs'] metadata: General metadata for the parameter.
        :param Any schema: Provides validation of parameter inputs during assignment using a self-defined JSON schema. This property is only supported for object-type parameters and follows the Json.NET Schema 2019-09 implementation. You can learn more about using schemas at https://json-schema.org/ and test draft schemas at https://www.jsonschemavalidator.net/.
        :param pulumi.Input[Union[builtins.str, 'ParameterType']] type: The data type of the parameter.
        """
        if allowed_values is not None:
            pulumi.set(__self__, "allowed_values", allowed_values)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="allowedValues")
    def allowed_values(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        The allowed values for the parameter.
        """
        return pulumi.get(self, "allowed_values")

    @allowed_values.setter
    def allowed_values(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "allowed_values", value)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[Any]:
        """
        The default value for the parameter if no value is provided.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[Any]):
        pulumi.set(self, "default_value", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['ParameterDefinitionsValueMetadataArgs']]:
        """
        General metadata for the parameter.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['ParameterDefinitionsValueMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[Any]:
        """
        Provides validation of parameter inputs during assignment using a self-defined JSON schema. This property is only supported for object-type parameters and follows the Json.NET Schema 2019-09 implementation. You can learn more about using schemas at https://json-schema.org/ and test draft schemas at https://www.jsonschemavalidator.net/.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[Any]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'ParameterType']]]:
        """
        The data type of the parameter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'ParameterType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ParameterValuesValueArgsDict(TypedDict):
        """
        The value of a parameter.
        """
        value: NotRequired[Any]
        """
        The value of the parameter.
        """
elif False:
    ParameterValuesValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ParameterValuesValueArgs:
    def __init__(__self__, *,
                 value: Optional[Any] = None):
        """
        The value of a parameter.
        :param Any value: The value of the parameter.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[Any]:
        """
        The value of the parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[Any]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PermissionArgsDict(TypedDict):
        """
        Role definition permissions.
        """
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Allowed actions.
        """
        data_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Allowed Data actions.
        """
        not_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Denied actions.
        """
        not_data_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Denied Data actions.
        """
elif False:
    PermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 data_actions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 not_actions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 not_data_actions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Role definition permissions.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: Allowed actions.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] data_actions: Allowed Data actions.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] not_actions: Denied actions.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] not_data_actions: Denied Data actions.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if data_actions is not None:
            pulumi.set(__self__, "data_actions", data_actions)
        if not_actions is not None:
            pulumi.set(__self__, "not_actions", not_actions)
        if not_data_actions is not None:
            pulumi.set(__self__, "not_data_actions", not_data_actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Allowed actions.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="dataActions")
    def data_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Allowed Data actions.
        """
        return pulumi.get(self, "data_actions")

    @data_actions.setter
    def data_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "data_actions", value)

    @property
    @pulumi.getter(name="notActions")
    def not_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Denied actions.
        """
        return pulumi.get(self, "not_actions")

    @not_actions.setter
    def not_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "not_actions", value)

    @property
    @pulumi.getter(name="notDataActions")
    def not_data_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Denied Data actions.
        """
        return pulumi.get(self, "not_data_actions")

    @not_data_actions.setter
    def not_data_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "not_data_actions", value)


if not MYPY:
    class PolicyDefinitionGroupArgsDict(TypedDict):
        """
        The policy definition group.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the group.
        """
        additional_metadata_id: NotRequired[pulumi.Input[builtins.str]]
        """
        A resource ID of a resource that contains additional metadata about the group.
        """
        category: NotRequired[pulumi.Input[builtins.str]]
        """
        The group's category.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The group's description.
        """
        display_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The group's display name.
        """
elif False:
    PolicyDefinitionGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyDefinitionGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 additional_metadata_id: Optional[pulumi.Input[builtins.str]] = None,
                 category: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 display_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        The policy definition group.
        :param pulumi.Input[builtins.str] name: The name of the group.
        :param pulumi.Input[builtins.str] additional_metadata_id: A resource ID of a resource that contains additional metadata about the group.
        :param pulumi.Input[builtins.str] category: The group's category.
        :param pulumi.Input[builtins.str] description: The group's description.
        :param pulumi.Input[builtins.str] display_name: The group's display name.
        """
        pulumi.set(__self__, "name", name)
        if additional_metadata_id is not None:
            pulumi.set(__self__, "additional_metadata_id", additional_metadata_id)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="additionalMetadataId")
    def additional_metadata_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A resource ID of a resource that contains additional metadata about the group.
        """
        return pulumi.get(self, "additional_metadata_id")

    @additional_metadata_id.setter
    def additional_metadata_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "additional_metadata_id", value)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The group's category.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The group's description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The group's display name.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class PolicyDefinitionReferenceArgsDict(TypedDict):
        """
        The policy definition reference.
        """
        policy_definition_id: pulumi.Input[builtins.str]
        """
        The ID of the policy definition or policy set definition.
        """
        definition_version: NotRequired[pulumi.Input[builtins.str]]
        """
        The version of the policy definition to use.
        """
        group_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The name of the groups that this policy definition reference belongs to.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['ParameterValuesValueArgsDict']]]]
        """
        The parameter values for the referenced policy rule. The keys are the parameter names.
        """
        policy_definition_reference_id: NotRequired[pulumi.Input[builtins.str]]
        """
        A unique id (within the policy set definition) for this policy definition reference.
        """
elif False:
    PolicyDefinitionReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyDefinitionReferenceArgs:
    def __init__(__self__, *,
                 policy_definition_id: pulumi.Input[builtins.str],
                 definition_version: Optional[pulumi.Input[builtins.str]] = None,
                 group_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterValuesValueArgs']]]] = None,
                 policy_definition_reference_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        The policy definition reference.
        :param pulumi.Input[builtins.str] policy_definition_id: The ID of the policy definition or policy set definition.
        :param pulumi.Input[builtins.str] definition_version: The version of the policy definition to use.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] group_names: The name of the groups that this policy definition reference belongs to.
        :param pulumi.Input[Mapping[str, pulumi.Input['ParameterValuesValueArgs']]] parameters: The parameter values for the referenced policy rule. The keys are the parameter names.
        :param pulumi.Input[builtins.str] policy_definition_reference_id: A unique id (within the policy set definition) for this policy definition reference.
        """
        pulumi.set(__self__, "policy_definition_id", policy_definition_id)
        if definition_version is not None:
            pulumi.set(__self__, "definition_version", definition_version)
        if group_names is not None:
            pulumi.set(__self__, "group_names", group_names)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if policy_definition_reference_id is not None:
            pulumi.set(__self__, "policy_definition_reference_id", policy_definition_reference_id)

    @property
    @pulumi.getter(name="policyDefinitionId")
    def policy_definition_id(self) -> pulumi.Input[builtins.str]:
        """
        The ID of the policy definition or policy set definition.
        """
        return pulumi.get(self, "policy_definition_id")

    @policy_definition_id.setter
    def policy_definition_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "policy_definition_id", value)

    @property
    @pulumi.getter(name="definitionVersion")
    def definition_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The version of the policy definition to use.
        """
        return pulumi.get(self, "definition_version")

    @definition_version.setter
    def definition_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "definition_version", value)

    @property
    @pulumi.getter(name="groupNames")
    def group_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The name of the groups that this policy definition reference belongs to.
        """
        return pulumi.get(self, "group_names")

    @group_names.setter
    def group_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "group_names", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterValuesValueArgs']]]]:
        """
        The parameter values for the referenced policy rule. The keys are the parameter names.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ParameterValuesValueArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="policyDefinitionReferenceId")
    def policy_definition_reference_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A unique id (within the policy set definition) for this policy definition reference.
        """
        return pulumi.get(self, "policy_definition_reference_id")

    @policy_definition_reference_id.setter
    def policy_definition_reference_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "policy_definition_reference_id", value)


if not MYPY:
    class PolicyVariableColumnArgsDict(TypedDict):
        """
        The variable column.
        """
        column_name: pulumi.Input[builtins.str]
        """
        The name of this policy variable column.
        """
elif False:
    PolicyVariableColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyVariableColumnArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[builtins.str]):
        """
        The variable column.
        :param pulumi.Input[builtins.str] column_name: The name of this policy variable column.
        """
        pulumi.set(__self__, "column_name", column_name)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of this policy variable column.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "column_name", value)


if not MYPY:
    class PolicyVariableValueColumnValueArgsDict(TypedDict):
        """
        The name value tuple for this variable value column.
        """
        column_name: pulumi.Input[builtins.str]
        """
        Column name for the variable value
        """
        column_value: Any
        """
        Column value for the variable value; this can be an integer, double, boolean, null or a string.
        """
elif False:
    PolicyVariableValueColumnValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyVariableValueColumnValueArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[builtins.str],
                 column_value: Any):
        """
        The name value tuple for this variable value column.
        :param pulumi.Input[builtins.str] column_name: Column name for the variable value
        :param Any column_value: Column value for the variable value; this can be an integer, double, boolean, null or a string.
        """
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "column_value", column_value)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[builtins.str]:
        """
        Column name for the variable value
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter(name="columnValue")
    def column_value(self) -> Any:
        """
        Column value for the variable value; this can be an integer, double, boolean, null or a string.
        """
        return pulumi.get(self, "column_value")

    @column_value.setter
    def column_value(self, value: Any):
        pulumi.set(self, "column_value", value)


if not MYPY:
    class PrivateLinkAssociationPropertiesArgsDict(TypedDict):
        private_link: NotRequired[pulumi.Input[builtins.str]]
        """
        The rmpl Resource ID.
        """
        public_network_access: NotRequired[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessOptions']]]
elif False:
    PrivateLinkAssociationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateLinkAssociationPropertiesArgs:
    def __init__(__self__, *,
                 private_link: Optional[pulumi.Input[builtins.str]] = None,
                 public_network_access: Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessOptions']]] = None):
        """
        :param pulumi.Input[builtins.str] private_link: The rmpl Resource ID.
        """
        if private_link is not None:
            pulumi.set(__self__, "private_link", private_link)
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)

    @property
    @pulumi.getter(name="privateLink")
    def private_link(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The rmpl Resource ID.
        """
        return pulumi.get(self, "private_link")

    @private_link.setter
    def private_link(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "private_link", value)

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessOptions']]]:
        return pulumi.get(self, "public_network_access")

    @public_network_access.setter
    def public_network_access(self, value: Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessOptions']]]):
        pulumi.set(self, "public_network_access", value)


if not MYPY:
    class ResourceSelectorArgsDict(TypedDict):
        """
        The resource selector to filter policies by resource properties.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the resource selector.
        """
        selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input['SelectorArgsDict']]]]
        """
        The list of the selector expressions.
        """
elif False:
    ResourceSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceSelectorArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 selectors: Optional[pulumi.Input[Sequence[pulumi.Input['SelectorArgs']]]] = None):
        """
        The resource selector to filter policies by resource properties.
        :param pulumi.Input[builtins.str] name: The name of the resource selector.
        :param pulumi.Input[Sequence[pulumi.Input['SelectorArgs']]] selectors: The list of the selector expressions.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if selectors is not None:
            pulumi.set(__self__, "selectors", selectors)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the resource selector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SelectorArgs']]]]:
        """
        The list of the selector expressions.
        """
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SelectorArgs']]]]):
        pulumi.set(self, "selectors", value)


if not MYPY:
    class RoleEligibilityScheduleRequestPropertiesExpirationArgsDict(TypedDict):
        """
        Expiration of the role eligibility schedule
        """
        duration: NotRequired[pulumi.Input[builtins.str]]
        """
        Duration of the role eligibility schedule in TimeSpan.
        """
        end_date_time: NotRequired[pulumi.Input[builtins.str]]
        """
        End DateTime of the role eligibility schedule.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'Type']]]
        """
        Type of the role eligibility schedule expiration
        """
elif False:
    RoleEligibilityScheduleRequestPropertiesExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoleEligibilityScheduleRequestPropertiesExpirationArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[builtins.str]] = None,
                 end_date_time: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[Union[builtins.str, 'Type']]] = None):
        """
        Expiration of the role eligibility schedule
        :param pulumi.Input[builtins.str] duration: Duration of the role eligibility schedule in TimeSpan.
        :param pulumi.Input[builtins.str] end_date_time: End DateTime of the role eligibility schedule.
        :param pulumi.Input[Union[builtins.str, 'Type']] type: Type of the role eligibility schedule expiration
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if end_date_time is not None:
            pulumi.set(__self__, "end_date_time", end_date_time)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Duration of the role eligibility schedule in TimeSpan.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="endDateTime")
    def end_date_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        End DateTime of the role eligibility schedule.
        """
        return pulumi.get(self, "end_date_time")

    @end_date_time.setter
    def end_date_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_date_time", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'Type']]]:
        """
        Type of the role eligibility schedule expiration
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'Type']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RoleEligibilityScheduleRequestPropertiesScheduleInfoArgsDict(TypedDict):
        """
        Schedule info of the role eligibility schedule
        """
        expiration: NotRequired[pulumi.Input['RoleEligibilityScheduleRequestPropertiesExpirationArgsDict']]
        """
        Expiration of the role eligibility schedule
        """
        start_date_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Start DateTime of the role eligibility schedule.
        """
elif False:
    RoleEligibilityScheduleRequestPropertiesScheduleInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoleEligibilityScheduleRequestPropertiesScheduleInfoArgs:
    def __init__(__self__, *,
                 expiration: Optional[pulumi.Input['RoleEligibilityScheduleRequestPropertiesExpirationArgs']] = None,
                 start_date_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        Schedule info of the role eligibility schedule
        :param pulumi.Input['RoleEligibilityScheduleRequestPropertiesExpirationArgs'] expiration: Expiration of the role eligibility schedule
        :param pulumi.Input[builtins.str] start_date_time: Start DateTime of the role eligibility schedule.
        """
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if start_date_time is not None:
            pulumi.set(__self__, "start_date_time", start_date_time)

    @property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input['RoleEligibilityScheduleRequestPropertiesExpirationArgs']]:
        """
        Expiration of the role eligibility schedule
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input['RoleEligibilityScheduleRequestPropertiesExpirationArgs']]):
        pulumi.set(self, "expiration", value)

    @property
    @pulumi.getter(name="startDateTime")
    def start_date_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Start DateTime of the role eligibility schedule.
        """
        return pulumi.get(self, "start_date_time")

    @start_date_time.setter
    def start_date_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_date_time", value)


if not MYPY:
    class RoleEligibilityScheduleRequestPropertiesTicketInfoArgsDict(TypedDict):
        """
        Ticket Info of the role eligibility
        """
        ticket_number: NotRequired[pulumi.Input[builtins.str]]
        """
        Ticket number for the role eligibility
        """
        ticket_system: NotRequired[pulumi.Input[builtins.str]]
        """
        Ticket system name for the role eligibility
        """
elif False:
    RoleEligibilityScheduleRequestPropertiesTicketInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoleEligibilityScheduleRequestPropertiesTicketInfoArgs:
    def __init__(__self__, *,
                 ticket_number: Optional[pulumi.Input[builtins.str]] = None,
                 ticket_system: Optional[pulumi.Input[builtins.str]] = None):
        """
        Ticket Info of the role eligibility
        :param pulumi.Input[builtins.str] ticket_number: Ticket number for the role eligibility
        :param pulumi.Input[builtins.str] ticket_system: Ticket system name for the role eligibility
        """
        if ticket_number is not None:
            pulumi.set(__self__, "ticket_number", ticket_number)
        if ticket_system is not None:
            pulumi.set(__self__, "ticket_system", ticket_system)

    @property
    @pulumi.getter(name="ticketNumber")
    def ticket_number(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Ticket number for the role eligibility
        """
        return pulumi.get(self, "ticket_number")

    @ticket_number.setter
    def ticket_number(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ticket_number", value)

    @property
    @pulumi.getter(name="ticketSystem")
    def ticket_system(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Ticket system name for the role eligibility
        """
        return pulumi.get(self, "ticket_system")

    @ticket_system.setter
    def ticket_system(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ticket_system", value)


if not MYPY:
    class RoleManagementPolicyApprovalRuleArgsDict(TypedDict):
        """
        The role management policy approval rule.
        """
        rule_type: pulumi.Input[builtins.str]
        """
        The type of rule
        Expected value is 'RoleManagementPolicyApprovalRule'.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The id of the rule.
        """
        setting: NotRequired[pulumi.Input['ApprovalSettingsArgsDict']]
        """
        The approval setting
        """
        target: NotRequired[pulumi.Input['RoleManagementPolicyRuleTargetArgsDict']]
        """
        The target of the current rule.
        """
elif False:
    RoleManagementPolicyApprovalRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoleManagementPolicyApprovalRuleArgs:
    def __init__(__self__, *,
                 rule_type: pulumi.Input[builtins.str],
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 setting: Optional[pulumi.Input['ApprovalSettingsArgs']] = None,
                 target: Optional[pulumi.Input['RoleManagementPolicyRuleTargetArgs']] = None):
        """
        The role management policy approval rule.
        :param pulumi.Input[builtins.str] rule_type: The type of rule
               Expected value is 'RoleManagementPolicyApprovalRule'.
        :param pulumi.Input[builtins.str] id: The id of the rule.
        :param pulumi.Input['ApprovalSettingsArgs'] setting: The approval setting
        :param pulumi.Input['RoleManagementPolicyRuleTargetArgs'] target: The target of the current rule.
        """
        pulumi.set(__self__, "rule_type", 'RoleManagementPolicyApprovalRule')
        if id is not None:
            pulumi.set(__self__, "id", id)
        if setting is not None:
            pulumi.set(__self__, "setting", setting)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> pulumi.Input[builtins.str]:
        """
        The type of rule
        Expected value is 'RoleManagementPolicyApprovalRule'.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "rule_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The id of the rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def setting(self) -> Optional[pulumi.Input['ApprovalSettingsArgs']]:
        """
        The approval setting
        """
        return pulumi.get(self, "setting")

    @setting.setter
    def setting(self, value: Optional[pulumi.Input['ApprovalSettingsArgs']]):
        pulumi.set(self, "setting", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['RoleManagementPolicyRuleTargetArgs']]:
        """
        The target of the current rule.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['RoleManagementPolicyRuleTargetArgs']]):
        pulumi.set(self, "target", value)


if not MYPY:
    class RoleManagementPolicyAuthenticationContextRuleArgsDict(TypedDict):
        """
        The role management policy authentication context rule.
        """
        rule_type: pulumi.Input[builtins.str]
        """
        The type of rule
        Expected value is 'RoleManagementPolicyAuthenticationContextRule'.
        """
        claim_value: NotRequired[pulumi.Input[builtins.str]]
        """
        The claim value.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The id of the rule.
        """
        is_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        The value indicating if rule is enabled.
        """
        target: NotRequired[pulumi.Input['RoleManagementPolicyRuleTargetArgsDict']]
        """
        The target of the current rule.
        """
elif False:
    RoleManagementPolicyAuthenticationContextRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoleManagementPolicyAuthenticationContextRuleArgs:
    def __init__(__self__, *,
                 rule_type: pulumi.Input[builtins.str],
                 claim_value: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 is_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 target: Optional[pulumi.Input['RoleManagementPolicyRuleTargetArgs']] = None):
        """
        The role management policy authentication context rule.
        :param pulumi.Input[builtins.str] rule_type: The type of rule
               Expected value is 'RoleManagementPolicyAuthenticationContextRule'.
        :param pulumi.Input[builtins.str] claim_value: The claim value.
        :param pulumi.Input[builtins.str] id: The id of the rule.
        :param pulumi.Input[builtins.bool] is_enabled: The value indicating if rule is enabled.
        :param pulumi.Input['RoleManagementPolicyRuleTargetArgs'] target: The target of the current rule.
        """
        pulumi.set(__self__, "rule_type", 'RoleManagementPolicyAuthenticationContextRule')
        if claim_value is not None:
            pulumi.set(__self__, "claim_value", claim_value)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> pulumi.Input[builtins.str]:
        """
        The type of rule
        Expected value is 'RoleManagementPolicyAuthenticationContextRule'.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "rule_type", value)

    @property
    @pulumi.getter(name="claimValue")
    def claim_value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The claim value.
        """
        return pulumi.get(self, "claim_value")

    @claim_value.setter
    def claim_value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "claim_value", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The id of the rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        The value indicating if rule is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['RoleManagementPolicyRuleTargetArgs']]:
        """
        The target of the current rule.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['RoleManagementPolicyRuleTargetArgs']]):
        pulumi.set(self, "target", value)


if not MYPY:
    class RoleManagementPolicyEnablementRuleArgsDict(TypedDict):
        """
        The role management policy enablement rule.
        """
        rule_type: pulumi.Input[builtins.str]
        """
        The type of rule
        Expected value is 'RoleManagementPolicyEnablementRule'.
        """
        enabled_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'EnablementRules']]]]]
        """
        The list of enabled rules.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The id of the rule.
        """
        target: NotRequired[pulumi.Input['RoleManagementPolicyRuleTargetArgsDict']]
        """
        The target of the current rule.
        """
elif False:
    RoleManagementPolicyEnablementRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoleManagementPolicyEnablementRuleArgs:
    def __init__(__self__, *,
                 rule_type: pulumi.Input[builtins.str],
                 enabled_rules: Optional[pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'EnablementRules']]]]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 target: Optional[pulumi.Input['RoleManagementPolicyRuleTargetArgs']] = None):
        """
        The role management policy enablement rule.
        :param pulumi.Input[builtins.str] rule_type: The type of rule
               Expected value is 'RoleManagementPolicyEnablementRule'.
        :param pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'EnablementRules']]]] enabled_rules: The list of enabled rules.
        :param pulumi.Input[builtins.str] id: The id of the rule.
        :param pulumi.Input['RoleManagementPolicyRuleTargetArgs'] target: The target of the current rule.
        """
        pulumi.set(__self__, "rule_type", 'RoleManagementPolicyEnablementRule')
        if enabled_rules is not None:
            pulumi.set(__self__, "enabled_rules", enabled_rules)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> pulumi.Input[builtins.str]:
        """
        The type of rule
        Expected value is 'RoleManagementPolicyEnablementRule'.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "rule_type", value)

    @property
    @pulumi.getter(name="enabledRules")
    def enabled_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'EnablementRules']]]]]:
        """
        The list of enabled rules.
        """
        return pulumi.get(self, "enabled_rules")

    @enabled_rules.setter
    def enabled_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'EnablementRules']]]]]):
        pulumi.set(self, "enabled_rules", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The id of the rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['RoleManagementPolicyRuleTargetArgs']]:
        """
        The target of the current rule.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['RoleManagementPolicyRuleTargetArgs']]):
        pulumi.set(self, "target", value)


if not MYPY:
    class RoleManagementPolicyExpirationRuleArgsDict(TypedDict):
        """
        The role management policy expiration rule.
        """
        rule_type: pulumi.Input[builtins.str]
        """
        The type of rule
        Expected value is 'RoleManagementPolicyExpirationRule'.
        """
        exception_members: NotRequired[pulumi.Input[Sequence[pulumi.Input['UserSetArgsDict']]]]
        """
        The members not restricted by expiration rule.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The id of the rule.
        """
        is_expiration_required: NotRequired[pulumi.Input[builtins.bool]]
        """
        The value indicating whether expiration is required.
        """
        maximum_duration: NotRequired[pulumi.Input[builtins.str]]
        """
        The maximum duration of expiration in timespan.
        """
        target: NotRequired[pulumi.Input['RoleManagementPolicyRuleTargetArgsDict']]
        """
        The target of the current rule.
        """
elif False:
    RoleManagementPolicyExpirationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoleManagementPolicyExpirationRuleArgs:
    def __init__(__self__, *,
                 rule_type: pulumi.Input[builtins.str],
                 exception_members: Optional[pulumi.Input[Sequence[pulumi.Input['UserSetArgs']]]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 is_expiration_required: Optional[pulumi.Input[builtins.bool]] = None,
                 maximum_duration: Optional[pulumi.Input[builtins.str]] = None,
                 target: Optional[pulumi.Input['RoleManagementPolicyRuleTargetArgs']] = None):
        """
        The role management policy expiration rule.
        :param pulumi.Input[builtins.str] rule_type: The type of rule
               Expected value is 'RoleManagementPolicyExpirationRule'.
        :param pulumi.Input[Sequence[pulumi.Input['UserSetArgs']]] exception_members: The members not restricted by expiration rule.
        :param pulumi.Input[builtins.str] id: The id of the rule.
        :param pulumi.Input[builtins.bool] is_expiration_required: The value indicating whether expiration is required.
        :param pulumi.Input[builtins.str] maximum_duration: The maximum duration of expiration in timespan.
        :param pulumi.Input['RoleManagementPolicyRuleTargetArgs'] target: The target of the current rule.
        """
        pulumi.set(__self__, "rule_type", 'RoleManagementPolicyExpirationRule')
        if exception_members is not None:
            pulumi.set(__self__, "exception_members", exception_members)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_expiration_required is not None:
            pulumi.set(__self__, "is_expiration_required", is_expiration_required)
        if maximum_duration is not None:
            pulumi.set(__self__, "maximum_duration", maximum_duration)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> pulumi.Input[builtins.str]:
        """
        The type of rule
        Expected value is 'RoleManagementPolicyExpirationRule'.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "rule_type", value)

    @property
    @pulumi.getter(name="exceptionMembers")
    def exception_members(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserSetArgs']]]]:
        """
        The members not restricted by expiration rule.
        """
        return pulumi.get(self, "exception_members")

    @exception_members.setter
    def exception_members(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserSetArgs']]]]):
        pulumi.set(self, "exception_members", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The id of the rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isExpirationRequired")
    def is_expiration_required(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        The value indicating whether expiration is required.
        """
        return pulumi.get(self, "is_expiration_required")

    @is_expiration_required.setter
    def is_expiration_required(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_expiration_required", value)

    @property
    @pulumi.getter(name="maximumDuration")
    def maximum_duration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The maximum duration of expiration in timespan.
        """
        return pulumi.get(self, "maximum_duration")

    @maximum_duration.setter
    def maximum_duration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "maximum_duration", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['RoleManagementPolicyRuleTargetArgs']]:
        """
        The target of the current rule.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['RoleManagementPolicyRuleTargetArgs']]):
        pulumi.set(self, "target", value)


if not MYPY:
    class RoleManagementPolicyNotificationRuleArgsDict(TypedDict):
        """
        The role management policy notification rule.
        """
        rule_type: pulumi.Input[builtins.str]
        """
        The type of rule
        Expected value is 'RoleManagementPolicyNotificationRule'.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The id of the rule.
        """
        is_default_recipients_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Determines if the notification will be sent to the recipient type specified in the policy rule.
        """
        notification_level: NotRequired[pulumi.Input[Union[builtins.str, 'NotificationLevel']]]
        """
        The notification level.
        """
        notification_recipients: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of notification recipients.
        """
        notification_type: NotRequired[pulumi.Input[Union[builtins.str, 'NotificationDeliveryMechanism']]]
        """
        The type of notification.
        """
        recipient_type: NotRequired[pulumi.Input[Union[builtins.str, 'RecipientType']]]
        """
        The recipient type.
        """
        target: NotRequired[pulumi.Input['RoleManagementPolicyRuleTargetArgsDict']]
        """
        The target of the current rule.
        """
elif False:
    RoleManagementPolicyNotificationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoleManagementPolicyNotificationRuleArgs:
    def __init__(__self__, *,
                 rule_type: pulumi.Input[builtins.str],
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 is_default_recipients_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 notification_level: Optional[pulumi.Input[Union[builtins.str, 'NotificationLevel']]] = None,
                 notification_recipients: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 notification_type: Optional[pulumi.Input[Union[builtins.str, 'NotificationDeliveryMechanism']]] = None,
                 recipient_type: Optional[pulumi.Input[Union[builtins.str, 'RecipientType']]] = None,
                 target: Optional[pulumi.Input['RoleManagementPolicyRuleTargetArgs']] = None):
        """
        The role management policy notification rule.
        :param pulumi.Input[builtins.str] rule_type: The type of rule
               Expected value is 'RoleManagementPolicyNotificationRule'.
        :param pulumi.Input[builtins.str] id: The id of the rule.
        :param pulumi.Input[builtins.bool] is_default_recipients_enabled: Determines if the notification will be sent to the recipient type specified in the policy rule.
        :param pulumi.Input[Union[builtins.str, 'NotificationLevel']] notification_level: The notification level.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] notification_recipients: The list of notification recipients.
        :param pulumi.Input[Union[builtins.str, 'NotificationDeliveryMechanism']] notification_type: The type of notification.
        :param pulumi.Input[Union[builtins.str, 'RecipientType']] recipient_type: The recipient type.
        :param pulumi.Input['RoleManagementPolicyRuleTargetArgs'] target: The target of the current rule.
        """
        pulumi.set(__self__, "rule_type", 'RoleManagementPolicyNotificationRule')
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_default_recipients_enabled is not None:
            pulumi.set(__self__, "is_default_recipients_enabled", is_default_recipients_enabled)
        if notification_level is not None:
            pulumi.set(__self__, "notification_level", notification_level)
        if notification_recipients is not None:
            pulumi.set(__self__, "notification_recipients", notification_recipients)
        if notification_type is not None:
            pulumi.set(__self__, "notification_type", notification_type)
        if recipient_type is not None:
            pulumi.set(__self__, "recipient_type", recipient_type)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> pulumi.Input[builtins.str]:
        """
        The type of rule
        Expected value is 'RoleManagementPolicyNotificationRule'.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "rule_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The id of the rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isDefaultRecipientsEnabled")
    def is_default_recipients_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Determines if the notification will be sent to the recipient type specified in the policy rule.
        """
        return pulumi.get(self, "is_default_recipients_enabled")

    @is_default_recipients_enabled.setter
    def is_default_recipients_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_default_recipients_enabled", value)

    @property
    @pulumi.getter(name="notificationLevel")
    def notification_level(self) -> Optional[pulumi.Input[Union[builtins.str, 'NotificationLevel']]]:
        """
        The notification level.
        """
        return pulumi.get(self, "notification_level")

    @notification_level.setter
    def notification_level(self, value: Optional[pulumi.Input[Union[builtins.str, 'NotificationLevel']]]):
        pulumi.set(self, "notification_level", value)

    @property
    @pulumi.getter(name="notificationRecipients")
    def notification_recipients(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of notification recipients.
        """
        return pulumi.get(self, "notification_recipients")

    @notification_recipients.setter
    def notification_recipients(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "notification_recipients", value)

    @property
    @pulumi.getter(name="notificationType")
    def notification_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'NotificationDeliveryMechanism']]]:
        """
        The type of notification.
        """
        return pulumi.get(self, "notification_type")

    @notification_type.setter
    def notification_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'NotificationDeliveryMechanism']]]):
        pulumi.set(self, "notification_type", value)

    @property
    @pulumi.getter(name="recipientType")
    def recipient_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'RecipientType']]]:
        """
        The recipient type.
        """
        return pulumi.get(self, "recipient_type")

    @recipient_type.setter
    def recipient_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'RecipientType']]]):
        pulumi.set(self, "recipient_type", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['RoleManagementPolicyRuleTargetArgs']]:
        """
        The target of the current rule.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['RoleManagementPolicyRuleTargetArgs']]):
        pulumi.set(self, "target", value)


if not MYPY:
    class RoleManagementPolicyPimOnlyModeRuleArgsDict(TypedDict):
        """
        The role management policy PIM only mode rule.
        """
        rule_type: pulumi.Input[builtins.str]
        """
        The type of rule
        Expected value is 'RoleManagementPolicyPimOnlyModeRule'.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The id of the rule.
        """
        pim_only_mode_settings: NotRequired[pulumi.Input['PIMOnlyModeSettingsArgsDict']]
        """
        The PIM Only Mode settings
        """
        target: NotRequired[pulumi.Input['RoleManagementPolicyRuleTargetArgsDict']]
        """
        The target of the current rule.
        """
elif False:
    RoleManagementPolicyPimOnlyModeRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoleManagementPolicyPimOnlyModeRuleArgs:
    def __init__(__self__, *,
                 rule_type: pulumi.Input[builtins.str],
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 pim_only_mode_settings: Optional[pulumi.Input['PIMOnlyModeSettingsArgs']] = None,
                 target: Optional[pulumi.Input['RoleManagementPolicyRuleTargetArgs']] = None):
        """
        The role management policy PIM only mode rule.
        :param pulumi.Input[builtins.str] rule_type: The type of rule
               Expected value is 'RoleManagementPolicyPimOnlyModeRule'.
        :param pulumi.Input[builtins.str] id: The id of the rule.
        :param pulumi.Input['PIMOnlyModeSettingsArgs'] pim_only_mode_settings: The PIM Only Mode settings
        :param pulumi.Input['RoleManagementPolicyRuleTargetArgs'] target: The target of the current rule.
        """
        pulumi.set(__self__, "rule_type", 'RoleManagementPolicyPimOnlyModeRule')
        if id is not None:
            pulumi.set(__self__, "id", id)
        if pim_only_mode_settings is not None:
            pulumi.set(__self__, "pim_only_mode_settings", pim_only_mode_settings)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> pulumi.Input[builtins.str]:
        """
        The type of rule
        Expected value is 'RoleManagementPolicyPimOnlyModeRule'.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "rule_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The id of the rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="pimOnlyModeSettings")
    def pim_only_mode_settings(self) -> Optional[pulumi.Input['PIMOnlyModeSettingsArgs']]:
        """
        The PIM Only Mode settings
        """
        return pulumi.get(self, "pim_only_mode_settings")

    @pim_only_mode_settings.setter
    def pim_only_mode_settings(self, value: Optional[pulumi.Input['PIMOnlyModeSettingsArgs']]):
        pulumi.set(self, "pim_only_mode_settings", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['RoleManagementPolicyRuleTargetArgs']]:
        """
        The target of the current rule.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['RoleManagementPolicyRuleTargetArgs']]):
        pulumi.set(self, "target", value)


if not MYPY:
    class RoleManagementPolicyRuleTargetArgsDict(TypedDict):
        """
        The role management policy rule target.
        """
        caller: NotRequired[pulumi.Input[builtins.str]]
        """
        The caller of the setting.
        """
        enforced_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of enforced settings.
        """
        inheritable_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of inheritable settings.
        """
        level: NotRequired[pulumi.Input[builtins.str]]
        """
        The assignment level to which rule is applied.
        """
        operations: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The type of operation.
        """
        target_objects: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of target objects.
        """
elif False:
    RoleManagementPolicyRuleTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoleManagementPolicyRuleTargetArgs:
    def __init__(__self__, *,
                 caller: Optional[pulumi.Input[builtins.str]] = None,
                 enforced_settings: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 inheritable_settings: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 level: Optional[pulumi.Input[builtins.str]] = None,
                 operations: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 target_objects: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        The role management policy rule target.
        :param pulumi.Input[builtins.str] caller: The caller of the setting.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] enforced_settings: The list of enforced settings.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] inheritable_settings: The list of inheritable settings.
        :param pulumi.Input[builtins.str] level: The assignment level to which rule is applied.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] operations: The type of operation.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] target_objects: The list of target objects.
        """
        if caller is not None:
            pulumi.set(__self__, "caller", caller)
        if enforced_settings is not None:
            pulumi.set(__self__, "enforced_settings", enforced_settings)
        if inheritable_settings is not None:
            pulumi.set(__self__, "inheritable_settings", inheritable_settings)
        if level is not None:
            pulumi.set(__self__, "level", level)
        if operations is not None:
            pulumi.set(__self__, "operations", operations)
        if target_objects is not None:
            pulumi.set(__self__, "target_objects", target_objects)

    @property
    @pulumi.getter
    def caller(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The caller of the setting.
        """
        return pulumi.get(self, "caller")

    @caller.setter
    def caller(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "caller", value)

    @property
    @pulumi.getter(name="enforcedSettings")
    def enforced_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of enforced settings.
        """
        return pulumi.get(self, "enforced_settings")

    @enforced_settings.setter
    def enforced_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "enforced_settings", value)

    @property
    @pulumi.getter(name="inheritableSettings")
    def inheritable_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of inheritable settings.
        """
        return pulumi.get(self, "inheritable_settings")

    @inheritable_settings.setter
    def inheritable_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "inheritable_settings", value)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The assignment level to which rule is applied.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def operations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The type of operation.
        """
        return pulumi.get(self, "operations")

    @operations.setter
    def operations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "operations", value)

    @property
    @pulumi.getter(name="targetObjects")
    def target_objects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of target objects.
        """
        return pulumi.get(self, "target_objects")

    @target_objects.setter
    def target_objects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "target_objects", value)


if not MYPY:
    class SelectorArgsDict(TypedDict):
        """
        The selector expression.
        """
        in_: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of values to filter in.
        """
        kind: NotRequired[pulumi.Input[Union[builtins.str, 'SelectorKind']]]
        """
        The selector kind.
        """
        not_in: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of values to filter out.
        """
elif False:
    SelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SelectorArgs:
    def __init__(__self__, *,
                 in_: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 kind: Optional[pulumi.Input[Union[builtins.str, 'SelectorKind']]] = None,
                 not_in: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        The selector expression.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] in_: The list of values to filter in.
        :param pulumi.Input[Union[builtins.str, 'SelectorKind']] kind: The selector kind.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] not_in: The list of values to filter out.
        """
        if in_ is not None:
            pulumi.set(__self__, "in_", in_)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if not_in is not None:
            pulumi.set(__self__, "not_in", not_in)

    @property
    @pulumi.getter(name="in")
    def in_(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of values to filter in.
        """
        return pulumi.get(self, "in_")

    @in_.setter
    def in_(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "in_", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[Union[builtins.str, 'SelectorKind']]]:
        """
        The selector kind.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[Union[builtins.str, 'SelectorKind']]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="notIn")
    def not_in(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of values to filter out.
        """
        return pulumi.get(self, "not_in")

    @not_in.setter
    def not_in(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "not_in", value)


if not MYPY:
    class UserSetArgsDict(TypedDict):
        """
        The detail of a user.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The description of the user.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The object id of the user.
        """
        is_backup: NotRequired[pulumi.Input[builtins.bool]]
        """
        The value indicating whether the user is a backup fallback approver
        """
        user_type: NotRequired[pulumi.Input[Union[builtins.str, 'UserType']]]
        """
        The type of user.
        """
elif False:
    UserSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserSetArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 is_backup: Optional[pulumi.Input[builtins.bool]] = None,
                 user_type: Optional[pulumi.Input[Union[builtins.str, 'UserType']]] = None):
        """
        The detail of a user.
        :param pulumi.Input[builtins.str] description: The description of the user.
        :param pulumi.Input[builtins.str] id: The object id of the user.
        :param pulumi.Input[builtins.bool] is_backup: The value indicating whether the user is a backup fallback approver
        :param pulumi.Input[Union[builtins.str, 'UserType']] user_type: The type of user.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_backup is not None:
            pulumi.set(__self__, "is_backup", is_backup)
        if user_type is not None:
            pulumi.set(__self__, "user_type", user_type)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description of the user.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The object id of the user.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isBackup")
    def is_backup(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        The value indicating whether the user is a backup fallback approver
        """
        return pulumi.get(self, "is_backup")

    @is_backup.setter
    def is_backup(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_backup", value)

    @property
    @pulumi.getter(name="userType")
    def user_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'UserType']]]:
        """
        The type of user.
        """
        return pulumi.get(self, "user_type")

    @user_type.setter
    def user_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'UserType']]]):
        pulumi.set(self, "user_type", value)


if not MYPY:
    class UsersOrServicePrincipalSetArgsDict(TypedDict):
        """
        The detail of a subject.
        """
        display_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The display Name of the entity.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The object id of the entity.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'UserType']]]
        """
        The type of user.
        """
elif False:
    UsersOrServicePrincipalSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsersOrServicePrincipalSetArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[Union[builtins.str, 'UserType']]] = None):
        """
        The detail of a subject.
        :param pulumi.Input[builtins.str] display_name: The display Name of the entity.
        :param pulumi.Input[builtins.str] id: The object id of the entity.
        :param pulumi.Input[Union[builtins.str, 'UserType']] type: The type of user.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The display Name of the entity.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The object id of the entity.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'UserType']]]:
        """
        The type of user.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'UserType']]]):
        pulumi.set(self, "type", value)


