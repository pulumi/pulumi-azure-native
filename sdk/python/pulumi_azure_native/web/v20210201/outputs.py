# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AllowedAudiencesValidationResponse',
    'AllowedPrincipalsResponse',
    'AppRegistrationResponse',
    'AppleRegistrationResponse',
    'AppleResponse',
    'ArmIdWrapperResponse',
    'ArmPlanResponse',
    'AuthPlatformResponse',
    'AzureActiveDirectoryLoginResponse',
    'AzureActiveDirectoryRegistrationResponse',
    'AzureActiveDirectoryResponse',
    'AzureActiveDirectoryValidationResponse',
    'AzureStaticWebAppsRegistrationResponse',
    'AzureStaticWebAppsResponse',
    'BlobStorageTokenStoreResponse',
    'CapabilityResponse',
    'ClientRegistrationResponse',
    'CookieExpirationResponse',
    'CustomOpenIdConnectProviderResponse',
    'DefaultAuthorizationPolicyResponse',
    'ErrorEntityResponse',
    'FacebookResponse',
    'FileSystemTokenStoreResponse',
    'ForwardProxyResponse',
    'GitHubResponse',
    'GlobalValidationResponse',
    'GoogleResponse',
    'HttpSettingsResponse',
    'HttpSettingsRoutesResponse',
    'IdentifierResponse',
    'IdentityProvidersResponse',
    'JwtClaimChecksResponse',
    'LegacyMicrosoftAccountResponse',
    'LoginResponse',
    'LoginRoutesResponse',
    'LoginScopesResponse',
    'ManagedServiceIdentityResponse',
    'NonceResponse',
    'OpenIdConnectClientCredentialResponse',
    'OpenIdConnectConfigResponse',
    'OpenIdConnectLoginResponse',
    'OpenIdConnectRegistrationResponse',
    'PrivateLinkConnectionStateResponse',
    'RemotePrivateEndpointConnectionResponse',
    'ResponseMessageEnvelopeRemotePrivateEndpointConnectionResponse',
    'SkuCapacityResponse',
    'SkuDescriptionResponse',
    'StaticSiteBuildPropertiesResponse',
    'StaticSiteTemplateOptionsResponse',
    'StaticSiteUserARMResourceResponse',
    'StaticSiteUserProvidedFunctionAppResponse',
    'TokenStoreResponse',
    'TwitterRegistrationResponse',
    'TwitterResponse',
    'UserAssignedIdentityResponse',
]

@pulumi.output_type
class AllowedAudiencesValidationResponse(dict):
    """
    The configuration settings of the Allowed Audiences validation flow.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedAudiences":
            suggest = "allowed_audiences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AllowedAudiencesValidationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AllowedAudiencesValidationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AllowedAudiencesValidationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_audiences: Optional[Sequence[str]] = None):
        """
        The configuration settings of the Allowed Audiences validation flow.
        :param Sequence[str] allowed_audiences: The configuration settings of the allowed list of audiences from which to validate the JWT token.
        """
        AllowedAudiencesValidationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_audiences=allowed_audiences,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_audiences: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allowed_audiences is None and 'allowedAudiences' in kwargs:
            allowed_audiences = kwargs['allowedAudiences']

        if allowed_audiences is not None:
            _setter("allowed_audiences", allowed_audiences)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        The configuration settings of the allowed list of audiences from which to validate the JWT token.
        """
        return pulumi.get(self, "allowed_audiences")


@pulumi.output_type
class AllowedPrincipalsResponse(dict):
    """
    The configuration settings of the Azure Active Directory allowed principals.
    """
    def __init__(__self__, *,
                 groups: Optional[Sequence[str]] = None,
                 identities: Optional[Sequence[str]] = None):
        """
        The configuration settings of the Azure Active Directory allowed principals.
        :param Sequence[str] groups: The list of the allowed groups.
        :param Sequence[str] identities: The list of the allowed identities.
        """
        AllowedPrincipalsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            groups=groups,
            identities=identities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             groups: Optional[Sequence[str]] = None,
             identities: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if groups is not None:
            _setter("groups", groups)
        if identities is not None:
            _setter("identities", identities)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        """
        The list of the allowed groups.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def identities(self) -> Optional[Sequence[str]]:
        """
        The list of the allowed identities.
        """
        return pulumi.get(self, "identities")


@pulumi.output_type
class AppRegistrationResponse(dict):
    """
    The configuration settings of the app registration for providers that have app ids and app secrets
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: Optional[str] = None,
                 app_secret_setting_name: Optional[str] = None):
        """
        The configuration settings of the app registration for providers that have app ids and app secrets
        :param str app_id: The App ID of the app used for login.
        :param str app_secret_setting_name: The app setting name that contains the app secret.
        """
        AppRegistrationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            app_id=app_id,
            app_secret_setting_name=app_secret_setting_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             app_id: Optional[str] = None,
             app_secret_setting_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if app_id is None and 'appId' in kwargs:
            app_id = kwargs['appId']
        if app_secret_setting_name is None and 'appSecretSettingName' in kwargs:
            app_secret_setting_name = kwargs['appSecretSettingName']

        if app_id is not None:
            _setter("app_id", app_id)
        if app_secret_setting_name is not None:
            _setter("app_secret_setting_name", app_secret_setting_name)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[str]:
        """
        The App ID of the app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the app secret.
        """
        return pulumi.get(self, "app_secret_setting_name")


@pulumi.output_type
class AppleRegistrationResponse(dict):
    """
    The configuration settings of the registration for the Apple provider
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppleRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppleRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppleRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None):
        """
        The configuration settings of the registration for the Apple provider
        :param str client_id: The Client ID of the app used for login.
        :param str client_secret_setting_name: The app setting name that contains the client secret.
        """
        AppleRegistrationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            client_secret_setting_name=client_secret_setting_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[str] = None,
             client_secret_setting_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_secret_setting_name is None and 'clientSecretSettingName' in kwargs:
            client_secret_setting_name = kwargs['clientSecretSettingName']

        if client_id is not None:
            _setter("client_id", client_id)
        if client_secret_setting_name is not None:
            _setter("client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID of the app used for login.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the client secret.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class AppleResponse(dict):
    """
    The configuration settings of the Apple provider.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 login: Optional['outputs.LoginScopesResponse'] = None,
                 registration: Optional['outputs.AppleRegistrationResponse'] = None):
        """
        The configuration settings of the Apple provider.
        :param bool enabled: <code>false</code> if the Apple provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param 'LoginScopesResponse' login: The configuration settings of the login flow.
        :param 'AppleRegistrationResponse' registration: The configuration settings of the Apple registration.
        """
        AppleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            login=login,
            registration=registration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             login: Optional['outputs.LoginScopesResponse'] = None,
             registration: Optional['outputs.AppleRegistrationResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)
        if login is not None:
            _setter("login", login)
        if registration is not None:
            _setter("registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        <code>false</code> if the Apple provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def login(self) -> Optional['outputs.LoginScopesResponse']:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter
    def registration(self) -> Optional['outputs.AppleRegistrationResponse']:
        """
        The configuration settings of the Apple registration.
        """
        return pulumi.get(self, "registration")


@pulumi.output_type
class ArmIdWrapperResponse(dict):
    """
    A wrapper for an ARM resource id
    """
    def __init__(__self__, *,
                 id: str):
        """
        A wrapper for an ARM resource id
        """
        ArmIdWrapperResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class ArmPlanResponse(dict):
    """
    The plan object in Azure Resource Manager, represents a marketplace plan.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "promotionCode":
            suggest = "promotion_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArmPlanResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArmPlanResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArmPlanResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 product: Optional[str] = None,
                 promotion_code: Optional[str] = None,
                 publisher: Optional[str] = None,
                 version: Optional[str] = None):
        """
        The plan object in Azure Resource Manager, represents a marketplace plan.
        :param str name: The name.
        :param str product: The product.
        :param str promotion_code: The promotion code.
        :param str publisher: The publisher.
        :param str version: Version of product.
        """
        ArmPlanResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            product=product,
            promotion_code=promotion_code,
            publisher=publisher,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             product: Optional[str] = None,
             promotion_code: Optional[str] = None,
             publisher: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if promotion_code is None and 'promotionCode' in kwargs:
            promotion_code = kwargs['promotionCode']

        if name is not None:
            _setter("name", name)
        if product is not None:
            _setter("product", product)
        if promotion_code is not None:
            _setter("promotion_code", promotion_code)
        if publisher is not None:
            _setter("publisher", publisher)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def product(self) -> Optional[str]:
        """
        The product.
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter(name="promotionCode")
    def promotion_code(self) -> Optional[str]:
        """
        The promotion code.
        """
        return pulumi.get(self, "promotion_code")

    @property
    @pulumi.getter
    def publisher(self) -> Optional[str]:
        """
        The publisher.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of product.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class AuthPlatformResponse(dict):
    """
    The configuration settings of the platform of App Service Authentication/Authorization.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configFilePath":
            suggest = "config_file_path"
        elif key == "runtimeVersion":
            suggest = "runtime_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthPlatformResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthPlatformResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthPlatformResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_file_path: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 runtime_version: Optional[str] = None):
        """
        The configuration settings of the platform of App Service Authentication/Authorization.
        :param str config_file_path: The path of the config file containing auth settings if they come from a file.
               If the path is relative, base will the site's root directory.
        :param bool enabled: <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
        :param str runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
               The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
        """
        AuthPlatformResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_file_path=config_file_path,
            enabled=enabled,
            runtime_version=runtime_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_file_path: Optional[str] = None,
             enabled: Optional[bool] = None,
             runtime_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if config_file_path is None and 'configFilePath' in kwargs:
            config_file_path = kwargs['configFilePath']
        if runtime_version is None and 'runtimeVersion' in kwargs:
            runtime_version = kwargs['runtimeVersion']

        if config_file_path is not None:
            _setter("config_file_path", config_file_path)
        if enabled is not None:
            _setter("enabled", enabled)
        if runtime_version is not None:
            _setter("runtime_version", runtime_version)

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> Optional[str]:
        """
        The path of the config file containing auth settings if they come from a file.
        If the path is relative, base will the site's root directory.
        """
        return pulumi.get(self, "config_file_path")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[str]:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
        The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
        """
        return pulumi.get(self, "runtime_version")


@pulumi.output_type
class AzureActiveDirectoryLoginResponse(dict):
    """
    The configuration settings of the Azure Active Directory login flow.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableWWWAuthenticate":
            suggest = "disable_www_authenticate"
        elif key == "loginParameters":
            suggest = "login_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureActiveDirectoryLoginResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureActiveDirectoryLoginResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureActiveDirectoryLoginResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_www_authenticate: Optional[bool] = None,
                 login_parameters: Optional[Sequence[str]] = None):
        """
        The configuration settings of the Azure Active Directory login flow.
        :param bool disable_www_authenticate: <code>true</code> if the www-authenticate provider should be omitted from the request; otherwise, <code>false</code>.
        :param Sequence[str] login_parameters: Login parameters to send to the OpenID Connect authorization endpoint when
               a user logs in. Each parameter must be in the form "key=value".
        """
        AzureActiveDirectoryLoginResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disable_www_authenticate=disable_www_authenticate,
            login_parameters=login_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disable_www_authenticate: Optional[bool] = None,
             login_parameters: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if disable_www_authenticate is None and 'disableWWWAuthenticate' in kwargs:
            disable_www_authenticate = kwargs['disableWWWAuthenticate']
        if login_parameters is None and 'loginParameters' in kwargs:
            login_parameters = kwargs['loginParameters']

        if disable_www_authenticate is not None:
            _setter("disable_www_authenticate", disable_www_authenticate)
        if login_parameters is not None:
            _setter("login_parameters", login_parameters)

    @property
    @pulumi.getter(name="disableWWWAuthenticate")
    def disable_www_authenticate(self) -> Optional[bool]:
        """
        <code>true</code> if the www-authenticate provider should be omitted from the request; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "disable_www_authenticate")

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[Sequence[str]]:
        """
        Login parameters to send to the OpenID Connect authorization endpoint when
        a user logs in. Each parameter must be in the form "key=value".
        """
        return pulumi.get(self, "login_parameters")


@pulumi.output_type
class AzureActiveDirectoryRegistrationResponse(dict):
    """
    The configuration settings of the Azure Active Directory app registration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretCertificateIssuer":
            suggest = "client_secret_certificate_issuer"
        elif key == "clientSecretCertificateSubjectAlternativeName":
            suggest = "client_secret_certificate_subject_alternative_name"
        elif key == "clientSecretCertificateThumbprint":
            suggest = "client_secret_certificate_thumbprint"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "openIdIssuer":
            suggest = "open_id_issuer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureActiveDirectoryRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureActiveDirectoryRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureActiveDirectoryRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[str] = None,
                 client_secret_certificate_issuer: Optional[str] = None,
                 client_secret_certificate_subject_alternative_name: Optional[str] = None,
                 client_secret_certificate_thumbprint: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None,
                 open_id_issuer: Optional[str] = None):
        """
        The configuration settings of the Azure Active Directory app registration.
        :param str client_id: The Client ID of this relying party application, known as the client_id.
               This setting is required for enabling OpenID Connection authentication with Azure Active Directory or 
               other 3rd party OpenID Connect providers.
               More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
        :param str client_secret_certificate_issuer: An alternative to the client secret thumbprint, that is the issuer of a certificate used for signing purposes. This property acts as
               a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        :param str client_secret_certificate_subject_alternative_name: An alternative to the client secret thumbprint, that is the subject alternative name of a certificate used for signing purposes. This property acts as
               a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        :param str client_secret_certificate_thumbprint: An alternative to the client secret, that is the thumbprint of a certificate used for signing purposes. This property acts as
               a replacement for the Client Secret. It is also optional.
        :param str client_secret_setting_name: The app setting name that contains the client secret of the relying party application.
        :param str open_id_issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this application.
               When using Azure Active Directory, this value is the URI of the directory tenant, e.g. https://login.microsoftonline.com/v2.0/{tenant-guid}/.
               This URI is a case-sensitive identifier for the token issuer.
               More information on OpenID Connect Discovery: http://openid.net/specs/openid-connect-discovery-1_0.html
        """
        AzureActiveDirectoryRegistrationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            client_secret_certificate_issuer=client_secret_certificate_issuer,
            client_secret_certificate_subject_alternative_name=client_secret_certificate_subject_alternative_name,
            client_secret_certificate_thumbprint=client_secret_certificate_thumbprint,
            client_secret_setting_name=client_secret_setting_name,
            open_id_issuer=open_id_issuer,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[str] = None,
             client_secret_certificate_issuer: Optional[str] = None,
             client_secret_certificate_subject_alternative_name: Optional[str] = None,
             client_secret_certificate_thumbprint: Optional[str] = None,
             client_secret_setting_name: Optional[str] = None,
             open_id_issuer: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_secret_certificate_issuer is None and 'clientSecretCertificateIssuer' in kwargs:
            client_secret_certificate_issuer = kwargs['clientSecretCertificateIssuer']
        if client_secret_certificate_subject_alternative_name is None and 'clientSecretCertificateSubjectAlternativeName' in kwargs:
            client_secret_certificate_subject_alternative_name = kwargs['clientSecretCertificateSubjectAlternativeName']
        if client_secret_certificate_thumbprint is None and 'clientSecretCertificateThumbprint' in kwargs:
            client_secret_certificate_thumbprint = kwargs['clientSecretCertificateThumbprint']
        if client_secret_setting_name is None and 'clientSecretSettingName' in kwargs:
            client_secret_setting_name = kwargs['clientSecretSettingName']
        if open_id_issuer is None and 'openIdIssuer' in kwargs:
            open_id_issuer = kwargs['openIdIssuer']

        if client_id is not None:
            _setter("client_id", client_id)
        if client_secret_certificate_issuer is not None:
            _setter("client_secret_certificate_issuer", client_secret_certificate_issuer)
        if client_secret_certificate_subject_alternative_name is not None:
            _setter("client_secret_certificate_subject_alternative_name", client_secret_certificate_subject_alternative_name)
        if client_secret_certificate_thumbprint is not None:
            _setter("client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            _setter("client_secret_setting_name", client_secret_setting_name)
        if open_id_issuer is not None:
            _setter("open_id_issuer", open_id_issuer)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID of this relying party application, known as the client_id.
        This setting is required for enabling OpenID Connection authentication with Azure Active Directory or 
        other 3rd party OpenID Connect providers.
        More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretCertificateIssuer")
    def client_secret_certificate_issuer(self) -> Optional[str]:
        """
        An alternative to the client secret thumbprint, that is the issuer of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        """
        return pulumi.get(self, "client_secret_certificate_issuer")

    @property
    @pulumi.getter(name="clientSecretCertificateSubjectAlternativeName")
    def client_secret_certificate_subject_alternative_name(self) -> Optional[str]:
        """
        An alternative to the client secret thumbprint, that is the subject alternative name of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        """
        return pulumi.get(self, "client_secret_certificate_subject_alternative_name")

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[str]:
        """
        An alternative to the client secret, that is the thumbprint of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret. It is also optional.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the client secret of the relying party application.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="openIdIssuer")
    def open_id_issuer(self) -> Optional[str]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this application.
        When using Azure Active Directory, this value is the URI of the directory tenant, e.g. https://login.microsoftonline.com/v2.0/{tenant-guid}/.
        This URI is a case-sensitive identifier for the token issuer.
        More information on OpenID Connect Discovery: http://openid.net/specs/openid-connect-discovery-1_0.html
        """
        return pulumi.get(self, "open_id_issuer")


@pulumi.output_type
class AzureActiveDirectoryResponse(dict):
    """
    The configuration settings of the Azure Active directory provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isAutoProvisioned":
            suggest = "is_auto_provisioned"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureActiveDirectoryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureActiveDirectoryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureActiveDirectoryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 is_auto_provisioned: Optional[bool] = None,
                 login: Optional['outputs.AzureActiveDirectoryLoginResponse'] = None,
                 registration: Optional['outputs.AzureActiveDirectoryRegistrationResponse'] = None,
                 validation: Optional['outputs.AzureActiveDirectoryValidationResponse'] = None):
        """
        The configuration settings of the Azure Active directory provider.
        :param bool enabled: <code>false</code> if the Azure Active Directory provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param bool is_auto_provisioned: Gets a value indicating whether the Azure AD configuration was auto-provisioned using 1st party tooling.
               This is an internal flag primarily intended to support the Azure Management Portal. Users should not
               read or write to this property.
        :param 'AzureActiveDirectoryLoginResponse' login: The configuration settings of the Azure Active Directory login flow.
        :param 'AzureActiveDirectoryRegistrationResponse' registration: The configuration settings of the Azure Active Directory app registration.
        :param 'AzureActiveDirectoryValidationResponse' validation: The configuration settings of the Azure Active Directory token validation flow.
        """
        AzureActiveDirectoryResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            is_auto_provisioned=is_auto_provisioned,
            login=login,
            registration=registration,
            validation=validation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             is_auto_provisioned: Optional[bool] = None,
             login: Optional['outputs.AzureActiveDirectoryLoginResponse'] = None,
             registration: Optional['outputs.AzureActiveDirectoryRegistrationResponse'] = None,
             validation: Optional['outputs.AzureActiveDirectoryValidationResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if is_auto_provisioned is None and 'isAutoProvisioned' in kwargs:
            is_auto_provisioned = kwargs['isAutoProvisioned']

        if enabled is not None:
            _setter("enabled", enabled)
        if is_auto_provisioned is not None:
            _setter("is_auto_provisioned", is_auto_provisioned)
        if login is not None:
            _setter("login", login)
        if registration is not None:
            _setter("registration", registration)
        if validation is not None:
            _setter("validation", validation)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        <code>false</code> if the Azure Active Directory provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="isAutoProvisioned")
    def is_auto_provisioned(self) -> Optional[bool]:
        """
        Gets a value indicating whether the Azure AD configuration was auto-provisioned using 1st party tooling.
        This is an internal flag primarily intended to support the Azure Management Portal. Users should not
        read or write to this property.
        """
        return pulumi.get(self, "is_auto_provisioned")

    @property
    @pulumi.getter
    def login(self) -> Optional['outputs.AzureActiveDirectoryLoginResponse']:
        """
        The configuration settings of the Azure Active Directory login flow.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter
    def registration(self) -> Optional['outputs.AzureActiveDirectoryRegistrationResponse']:
        """
        The configuration settings of the Azure Active Directory app registration.
        """
        return pulumi.get(self, "registration")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.AzureActiveDirectoryValidationResponse']:
        """
        The configuration settings of the Azure Active Directory token validation flow.
        """
        return pulumi.get(self, "validation")


@pulumi.output_type
class AzureActiveDirectoryValidationResponse(dict):
    """
    The configuration settings of the Azure Active Directory token validation flow.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "defaultAuthorizationPolicy":
            suggest = "default_authorization_policy"
        elif key == "jwtClaimChecks":
            suggest = "jwt_claim_checks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureActiveDirectoryValidationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureActiveDirectoryValidationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureActiveDirectoryValidationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_audiences: Optional[Sequence[str]] = None,
                 default_authorization_policy: Optional['outputs.DefaultAuthorizationPolicyResponse'] = None,
                 jwt_claim_checks: Optional['outputs.JwtClaimChecksResponse'] = None):
        """
        The configuration settings of the Azure Active Directory token validation flow.
        :param Sequence[str] allowed_audiences: The list of audiences that can make successful authentication/authorization requests.
        :param 'DefaultAuthorizationPolicyResponse' default_authorization_policy: The configuration settings of the default authorization policy.
        :param 'JwtClaimChecksResponse' jwt_claim_checks: The configuration settings of the checks that should be made while validating the JWT Claims.
        """
        AzureActiveDirectoryValidationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_audiences=allowed_audiences,
            default_authorization_policy=default_authorization_policy,
            jwt_claim_checks=jwt_claim_checks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_audiences: Optional[Sequence[str]] = None,
             default_authorization_policy: Optional['outputs.DefaultAuthorizationPolicyResponse'] = None,
             jwt_claim_checks: Optional['outputs.JwtClaimChecksResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allowed_audiences is None and 'allowedAudiences' in kwargs:
            allowed_audiences = kwargs['allowedAudiences']
        if default_authorization_policy is None and 'defaultAuthorizationPolicy' in kwargs:
            default_authorization_policy = kwargs['defaultAuthorizationPolicy']
        if jwt_claim_checks is None and 'jwtClaimChecks' in kwargs:
            jwt_claim_checks = kwargs['jwtClaimChecks']

        if allowed_audiences is not None:
            _setter("allowed_audiences", allowed_audiences)
        if default_authorization_policy is not None:
            _setter("default_authorization_policy", default_authorization_policy)
        if jwt_claim_checks is not None:
            _setter("jwt_claim_checks", jwt_claim_checks)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[str]]:
        """
        The list of audiences that can make successful authentication/authorization requests.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="defaultAuthorizationPolicy")
    def default_authorization_policy(self) -> Optional['outputs.DefaultAuthorizationPolicyResponse']:
        """
        The configuration settings of the default authorization policy.
        """
        return pulumi.get(self, "default_authorization_policy")

    @property
    @pulumi.getter(name="jwtClaimChecks")
    def jwt_claim_checks(self) -> Optional['outputs.JwtClaimChecksResponse']:
        """
        The configuration settings of the checks that should be made while validating the JWT Claims.
        """
        return pulumi.get(self, "jwt_claim_checks")


@pulumi.output_type
class AzureStaticWebAppsRegistrationResponse(dict):
    """
    The configuration settings of the registration for the Azure Static Web Apps provider
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureStaticWebAppsRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureStaticWebAppsRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureStaticWebAppsRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[str] = None):
        """
        The configuration settings of the registration for the Azure Static Web Apps provider
        :param str client_id: The Client ID of the app used for login.
        """
        AzureStaticWebAppsRegistrationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']

        if client_id is not None:
            _setter("client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID of the app used for login.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class AzureStaticWebAppsResponse(dict):
    """
    The configuration settings of the Azure Static Web Apps provider.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 registration: Optional['outputs.AzureStaticWebAppsRegistrationResponse'] = None):
        """
        The configuration settings of the Azure Static Web Apps provider.
        :param bool enabled: <code>false</code> if the Azure Static Web Apps provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param 'AzureStaticWebAppsRegistrationResponse' registration: The configuration settings of the Azure Static Web Apps registration.
        """
        AzureStaticWebAppsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            registration=registration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             registration: Optional['outputs.AzureStaticWebAppsRegistrationResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)
        if registration is not None:
            _setter("registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        <code>false</code> if the Azure Static Web Apps provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def registration(self) -> Optional['outputs.AzureStaticWebAppsRegistrationResponse']:
        """
        The configuration settings of the Azure Static Web Apps registration.
        """
        return pulumi.get(self, "registration")


@pulumi.output_type
class BlobStorageTokenStoreResponse(dict):
    """
    The configuration settings of the storage of the tokens if blob storage is used.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sasUrlSettingName":
            suggest = "sas_url_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BlobStorageTokenStoreResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BlobStorageTokenStoreResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BlobStorageTokenStoreResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sas_url_setting_name: Optional[str] = None):
        """
        The configuration settings of the storage of the tokens if blob storage is used.
        :param str sas_url_setting_name: The name of the app setting containing the SAS URL of the blob storage containing the tokens.
        """
        BlobStorageTokenStoreResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sas_url_setting_name=sas_url_setting_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sas_url_setting_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if sas_url_setting_name is None and 'sasUrlSettingName' in kwargs:
            sas_url_setting_name = kwargs['sasUrlSettingName']

        if sas_url_setting_name is not None:
            _setter("sas_url_setting_name", sas_url_setting_name)

    @property
    @pulumi.getter(name="sasUrlSettingName")
    def sas_url_setting_name(self) -> Optional[str]:
        """
        The name of the app setting containing the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "sas_url_setting_name")


@pulumi.output_type
class CapabilityResponse(dict):
    """
    Describes the capabilities/features allowed for a specific SKU.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 reason: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Describes the capabilities/features allowed for a specific SKU.
        :param str name: Name of the SKU capability.
        :param str reason: Reason of the SKU capability.
        :param str value: Value of the SKU capability.
        """
        CapabilityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            reason=reason,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             reason: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if reason is not None:
            _setter("reason", reason)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the SKU capability.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        Reason of the SKU capability.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the SKU capability.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClientRegistrationResponse(dict):
    """
    The configuration settings of the app registration for providers that have client ids and client secrets
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[str] = None,
                 client_secret_setting_name: Optional[str] = None):
        """
        The configuration settings of the app registration for providers that have client ids and client secrets
        :param str client_id: The Client ID of the app used for login.
        :param str client_secret_setting_name: The app setting name that contains the client secret.
        """
        ClientRegistrationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            client_secret_setting_name=client_secret_setting_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[str] = None,
             client_secret_setting_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_secret_setting_name is None and 'clientSecretSettingName' in kwargs:
            client_secret_setting_name = kwargs['clientSecretSettingName']

        if client_id is not None:
            _setter("client_id", client_id)
        if client_secret_setting_name is not None:
            _setter("client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID of the app used for login.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the client secret.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class CookieExpirationResponse(dict):
    """
    The configuration settings of the session cookie's expiration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeToExpiration":
            suggest = "time_to_expiration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CookieExpirationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CookieExpirationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CookieExpirationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 convention: Optional[str] = None,
                 time_to_expiration: Optional[str] = None):
        """
        The configuration settings of the session cookie's expiration.
        :param str convention: The convention used when determining the session cookie's expiration.
        :param str time_to_expiration: The time after the request is made when the session cookie should expire.
        """
        CookieExpirationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            convention=convention,
            time_to_expiration=time_to_expiration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             convention: Optional[str] = None,
             time_to_expiration: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if time_to_expiration is None and 'timeToExpiration' in kwargs:
            time_to_expiration = kwargs['timeToExpiration']

        if convention is not None:
            _setter("convention", convention)
        if time_to_expiration is not None:
            _setter("time_to_expiration", time_to_expiration)

    @property
    @pulumi.getter
    def convention(self) -> Optional[str]:
        """
        The convention used when determining the session cookie's expiration.
        """
        return pulumi.get(self, "convention")

    @property
    @pulumi.getter(name="timeToExpiration")
    def time_to_expiration(self) -> Optional[str]:
        """
        The time after the request is made when the session cookie should expire.
        """
        return pulumi.get(self, "time_to_expiration")


@pulumi.output_type
class CustomOpenIdConnectProviderResponse(dict):
    """
    The configuration settings of the custom Open ID Connect provider.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 login: Optional['outputs.OpenIdConnectLoginResponse'] = None,
                 registration: Optional['outputs.OpenIdConnectRegistrationResponse'] = None):
        """
        The configuration settings of the custom Open ID Connect provider.
        :param bool enabled: <code>false</code> if the custom Open ID provider provider should not be enabled; otherwise, <code>true</code>.
        :param 'OpenIdConnectLoginResponse' login: The configuration settings of the login flow of the custom Open ID Connect provider.
        :param 'OpenIdConnectRegistrationResponse' registration: The configuration settings of the app registration for the custom Open ID Connect provider.
        """
        CustomOpenIdConnectProviderResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            login=login,
            registration=registration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             login: Optional['outputs.OpenIdConnectLoginResponse'] = None,
             registration: Optional['outputs.OpenIdConnectRegistrationResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)
        if login is not None:
            _setter("login", login)
        if registration is not None:
            _setter("registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        <code>false</code> if the custom Open ID provider provider should not be enabled; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def login(self) -> Optional['outputs.OpenIdConnectLoginResponse']:
        """
        The configuration settings of the login flow of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter
    def registration(self) -> Optional['outputs.OpenIdConnectRegistrationResponse']:
        """
        The configuration settings of the app registration for the custom Open ID Connect provider.
        """
        return pulumi.get(self, "registration")


@pulumi.output_type
class DefaultAuthorizationPolicyResponse(dict):
    """
    The configuration settings of the Azure Active Directory default authorization policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedApplications":
            suggest = "allowed_applications"
        elif key == "allowedPrincipals":
            suggest = "allowed_principals"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultAuthorizationPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultAuthorizationPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultAuthorizationPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_applications: Optional[Sequence[str]] = None,
                 allowed_principals: Optional['outputs.AllowedPrincipalsResponse'] = None):
        """
        The configuration settings of the Azure Active Directory default authorization policy.
        :param Sequence[str] allowed_applications: The configuration settings of the Azure Active Directory allowed applications.
        :param 'AllowedPrincipalsResponse' allowed_principals: The configuration settings of the Azure Active Directory allowed principals.
        """
        DefaultAuthorizationPolicyResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_applications=allowed_applications,
            allowed_principals=allowed_principals,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_applications: Optional[Sequence[str]] = None,
             allowed_principals: Optional['outputs.AllowedPrincipalsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allowed_applications is None and 'allowedApplications' in kwargs:
            allowed_applications = kwargs['allowedApplications']
        if allowed_principals is None and 'allowedPrincipals' in kwargs:
            allowed_principals = kwargs['allowedPrincipals']

        if allowed_applications is not None:
            _setter("allowed_applications", allowed_applications)
        if allowed_principals is not None:
            _setter("allowed_principals", allowed_principals)

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[Sequence[str]]:
        """
        The configuration settings of the Azure Active Directory allowed applications.
        """
        return pulumi.get(self, "allowed_applications")

    @property
    @pulumi.getter(name="allowedPrincipals")
    def allowed_principals(self) -> Optional['outputs.AllowedPrincipalsResponse']:
        """
        The configuration settings of the Azure Active Directory allowed principals.
        """
        return pulumi.get(self, "allowed_principals")


@pulumi.output_type
class ErrorEntityResponse(dict):
    """
    Body of the error response returned from the API.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extendedCode":
            suggest = "extended_code"
        elif key == "innerErrors":
            suggest = "inner_errors"
        elif key == "messageTemplate":
            suggest = "message_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ErrorEntityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ErrorEntityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ErrorEntityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code: Optional[str] = None,
                 details: Optional[Sequence['outputs.ErrorEntityResponse']] = None,
                 extended_code: Optional[str] = None,
                 inner_errors: Optional[Sequence['outputs.ErrorEntityResponse']] = None,
                 message: Optional[str] = None,
                 message_template: Optional[str] = None,
                 parameters: Optional[Sequence[str]] = None,
                 target: Optional[str] = None):
        """
        Body of the error response returned from the API.
        :param str code: Basic error code.
        :param Sequence['ErrorEntityResponse'] details: Error Details.
        :param str extended_code: Type of error.
        :param Sequence['ErrorEntityResponse'] inner_errors: Inner errors.
        :param str message: Any details of the error.
        :param str message_template: Message template.
        :param Sequence[str] parameters: Parameters for the template.
        :param str target: The error target.
        """
        ErrorEntityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            details=details,
            extended_code=extended_code,
            inner_errors=inner_errors,
            message=message,
            message_template=message_template,
            parameters=parameters,
            target=target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: Optional[str] = None,
             details: Optional[Sequence['outputs.ErrorEntityResponse']] = None,
             extended_code: Optional[str] = None,
             inner_errors: Optional[Sequence['outputs.ErrorEntityResponse']] = None,
             message: Optional[str] = None,
             message_template: Optional[str] = None,
             parameters: Optional[Sequence[str]] = None,
             target: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if extended_code is None and 'extendedCode' in kwargs:
            extended_code = kwargs['extendedCode']
        if inner_errors is None and 'innerErrors' in kwargs:
            inner_errors = kwargs['innerErrors']
        if message_template is None and 'messageTemplate' in kwargs:
            message_template = kwargs['messageTemplate']

        if code is not None:
            _setter("code", code)
        if details is not None:
            _setter("details", details)
        if extended_code is not None:
            _setter("extended_code", extended_code)
        if inner_errors is not None:
            _setter("inner_errors", inner_errors)
        if message is not None:
            _setter("message", message)
        if message_template is not None:
            _setter("message_template", message_template)
        if parameters is not None:
            _setter("parameters", parameters)
        if target is not None:
            _setter("target", target)

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        """
        Basic error code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def details(self) -> Optional[Sequence['outputs.ErrorEntityResponse']]:
        """
        Error Details.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter(name="extendedCode")
    def extended_code(self) -> Optional[str]:
        """
        Type of error.
        """
        return pulumi.get(self, "extended_code")

    @property
    @pulumi.getter(name="innerErrors")
    def inner_errors(self) -> Optional[Sequence['outputs.ErrorEntityResponse']]:
        """
        Inner errors.
        """
        return pulumi.get(self, "inner_errors")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Any details of the error.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="messageTemplate")
    def message_template(self) -> Optional[str]:
        """
        Message template.
        """
        return pulumi.get(self, "message_template")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        """
        Parameters for the template.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        The error target.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class FacebookResponse(dict):
    """
    The configuration settings of the Facebook provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "graphApiVersion":
            suggest = "graph_api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FacebookResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FacebookResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FacebookResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 graph_api_version: Optional[str] = None,
                 login: Optional['outputs.LoginScopesResponse'] = None,
                 registration: Optional['outputs.AppRegistrationResponse'] = None):
        """
        The configuration settings of the Facebook provider.
        :param bool enabled: <code>false</code> if the Facebook provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param str graph_api_version: The version of the Facebook api to be used while logging in.
        :param 'LoginScopesResponse' login: The configuration settings of the login flow.
        :param 'AppRegistrationResponse' registration: The configuration settings of the app registration for the Facebook provider.
        """
        FacebookResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            graph_api_version=graph_api_version,
            login=login,
            registration=registration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             graph_api_version: Optional[str] = None,
             login: Optional['outputs.LoginScopesResponse'] = None,
             registration: Optional['outputs.AppRegistrationResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if graph_api_version is None and 'graphApiVersion' in kwargs:
            graph_api_version = kwargs['graphApiVersion']

        if enabled is not None:
            _setter("enabled", enabled)
        if graph_api_version is not None:
            _setter("graph_api_version", graph_api_version)
        if login is not None:
            _setter("login", login)
        if registration is not None:
            _setter("registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        <code>false</code> if the Facebook provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[str]:
        """
        The version of the Facebook api to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @property
    @pulumi.getter
    def login(self) -> Optional['outputs.LoginScopesResponse']:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter
    def registration(self) -> Optional['outputs.AppRegistrationResponse']:
        """
        The configuration settings of the app registration for the Facebook provider.
        """
        return pulumi.get(self, "registration")


@pulumi.output_type
class FileSystemTokenStoreResponse(dict):
    """
    The configuration settings of the storage of the tokens if a file system is used.
    """
    def __init__(__self__, *,
                 directory: Optional[str] = None):
        """
        The configuration settings of the storage of the tokens if a file system is used.
        :param str directory: The directory in which the tokens will be stored.
        """
        FileSystemTokenStoreResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            directory=directory,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             directory: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if directory is not None:
            _setter("directory", directory)

    @property
    @pulumi.getter
    def directory(self) -> Optional[str]:
        """
        The directory in which the tokens will be stored.
        """
        return pulumi.get(self, "directory")


@pulumi.output_type
class ForwardProxyResponse(dict):
    """
    The configuration settings of a forward proxy used to make the requests.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHostHeaderName":
            suggest = "custom_host_header_name"
        elif key == "customProtoHeaderName":
            suggest = "custom_proto_header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ForwardProxyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ForwardProxyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ForwardProxyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 convention: Optional[str] = None,
                 custom_host_header_name: Optional[str] = None,
                 custom_proto_header_name: Optional[str] = None):
        """
        The configuration settings of a forward proxy used to make the requests.
        :param str convention: The convention used to determine the url of the request made.
        :param str custom_host_header_name: The name of the header containing the host of the request.
        :param str custom_proto_header_name: The name of the header containing the scheme of the request.
        """
        ForwardProxyResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            convention=convention,
            custom_host_header_name=custom_host_header_name,
            custom_proto_header_name=custom_proto_header_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             convention: Optional[str] = None,
             custom_host_header_name: Optional[str] = None,
             custom_proto_header_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_host_header_name is None and 'customHostHeaderName' in kwargs:
            custom_host_header_name = kwargs['customHostHeaderName']
        if custom_proto_header_name is None and 'customProtoHeaderName' in kwargs:
            custom_proto_header_name = kwargs['customProtoHeaderName']

        if convention is not None:
            _setter("convention", convention)
        if custom_host_header_name is not None:
            _setter("custom_host_header_name", custom_host_header_name)
        if custom_proto_header_name is not None:
            _setter("custom_proto_header_name", custom_proto_header_name)

    @property
    @pulumi.getter
    def convention(self) -> Optional[str]:
        """
        The convention used to determine the url of the request made.
        """
        return pulumi.get(self, "convention")

    @property
    @pulumi.getter(name="customHostHeaderName")
    def custom_host_header_name(self) -> Optional[str]:
        """
        The name of the header containing the host of the request.
        """
        return pulumi.get(self, "custom_host_header_name")

    @property
    @pulumi.getter(name="customProtoHeaderName")
    def custom_proto_header_name(self) -> Optional[str]:
        """
        The name of the header containing the scheme of the request.
        """
        return pulumi.get(self, "custom_proto_header_name")


@pulumi.output_type
class GitHubResponse(dict):
    """
    The configuration settings of the GitHub provider.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 login: Optional['outputs.LoginScopesResponse'] = None,
                 registration: Optional['outputs.ClientRegistrationResponse'] = None):
        """
        The configuration settings of the GitHub provider.
        :param bool enabled: <code>false</code> if the GitHub provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param 'LoginScopesResponse' login: The configuration settings of the login flow.
        :param 'ClientRegistrationResponse' registration: The configuration settings of the app registration for the GitHub provider.
        """
        GitHubResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            login=login,
            registration=registration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             login: Optional['outputs.LoginScopesResponse'] = None,
             registration: Optional['outputs.ClientRegistrationResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)
        if login is not None:
            _setter("login", login)
        if registration is not None:
            _setter("registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        <code>false</code> if the GitHub provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def login(self) -> Optional['outputs.LoginScopesResponse']:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter
    def registration(self) -> Optional['outputs.ClientRegistrationResponse']:
        """
        The configuration settings of the app registration for the GitHub provider.
        """
        return pulumi.get(self, "registration")


@pulumi.output_type
class GlobalValidationResponse(dict):
    """
    The configuration settings that determines the validation flow of users using App Service Authentication/Authorization.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedPaths":
            suggest = "excluded_paths"
        elif key == "redirectToProvider":
            suggest = "redirect_to_provider"
        elif key == "requireAuthentication":
            suggest = "require_authentication"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalValidationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalValidationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalValidationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 excluded_paths: Optional[Sequence[str]] = None,
                 redirect_to_provider: Optional[str] = None,
                 require_authentication: Optional[bool] = None,
                 unauthenticated_client_action: Optional[str] = None):
        """
        The configuration settings that determines the validation flow of users using App Service Authentication/Authorization.
        :param Sequence[str] excluded_paths: The paths for which unauthenticated flow would not be redirected to the login page.
        :param str redirect_to_provider: The default authentication provider to use when multiple providers are configured.
               This setting is only needed if multiple providers are configured and the unauthenticated client
               action is set to "RedirectToLoginPage".
        :param bool require_authentication: <code>true</code> if the authentication flow is required any request is made; otherwise, <code>false</code>.
        :param str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app.
        """
        GlobalValidationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            excluded_paths=excluded_paths,
            redirect_to_provider=redirect_to_provider,
            require_authentication=require_authentication,
            unauthenticated_client_action=unauthenticated_client_action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             excluded_paths: Optional[Sequence[str]] = None,
             redirect_to_provider: Optional[str] = None,
             require_authentication: Optional[bool] = None,
             unauthenticated_client_action: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_paths is None and 'excludedPaths' in kwargs:
            excluded_paths = kwargs['excludedPaths']
        if redirect_to_provider is None and 'redirectToProvider' in kwargs:
            redirect_to_provider = kwargs['redirectToProvider']
        if require_authentication is None and 'requireAuthentication' in kwargs:
            require_authentication = kwargs['requireAuthentication']
        if unauthenticated_client_action is None and 'unauthenticatedClientAction' in kwargs:
            unauthenticated_client_action = kwargs['unauthenticatedClientAction']

        if excluded_paths is not None:
            _setter("excluded_paths", excluded_paths)
        if redirect_to_provider is not None:
            _setter("redirect_to_provider", redirect_to_provider)
        if require_authentication is not None:
            _setter("require_authentication", require_authentication)
        if unauthenticated_client_action is not None:
            _setter("unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[Sequence[str]]:
        """
        The paths for which unauthenticated flow would not be redirected to the login page.
        """
        return pulumi.get(self, "excluded_paths")

    @property
    @pulumi.getter(name="redirectToProvider")
    def redirect_to_provider(self) -> Optional[str]:
        """
        The default authentication provider to use when multiple providers are configured.
        This setting is only needed if multiple providers are configured and the unauthenticated client
        action is set to "RedirectToLoginPage".
        """
        return pulumi.get(self, "redirect_to_provider")

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[bool]:
        """
        <code>true</code> if the authentication flow is required any request is made; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "require_authentication")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[str]:
        """
        The action to take when an unauthenticated client attempts to access the app.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class GoogleResponse(dict):
    """
    The configuration settings of the Google provider.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 login: Optional['outputs.LoginScopesResponse'] = None,
                 registration: Optional['outputs.ClientRegistrationResponse'] = None,
                 validation: Optional['outputs.AllowedAudiencesValidationResponse'] = None):
        """
        The configuration settings of the Google provider.
        :param bool enabled: <code>false</code> if the Google provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param 'LoginScopesResponse' login: The configuration settings of the login flow.
        :param 'ClientRegistrationResponse' registration: The configuration settings of the app registration for the Google provider.
        :param 'AllowedAudiencesValidationResponse' validation: The configuration settings of the Azure Active Directory token validation flow.
        """
        GoogleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            login=login,
            registration=registration,
            validation=validation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             login: Optional['outputs.LoginScopesResponse'] = None,
             registration: Optional['outputs.ClientRegistrationResponse'] = None,
             validation: Optional['outputs.AllowedAudiencesValidationResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)
        if login is not None:
            _setter("login", login)
        if registration is not None:
            _setter("registration", registration)
        if validation is not None:
            _setter("validation", validation)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        <code>false</code> if the Google provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def login(self) -> Optional['outputs.LoginScopesResponse']:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter
    def registration(self) -> Optional['outputs.ClientRegistrationResponse']:
        """
        The configuration settings of the app registration for the Google provider.
        """
        return pulumi.get(self, "registration")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.AllowedAudiencesValidationResponse']:
        """
        The configuration settings of the Azure Active Directory token validation flow.
        """
        return pulumi.get(self, "validation")


@pulumi.output_type
class HttpSettingsResponse(dict):
    """
    The configuration settings of the HTTP requests for authentication and authorization requests made against App Service Authentication/Authorization.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forwardProxy":
            suggest = "forward_proxy"
        elif key == "requireHttps":
            suggest = "require_https"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forward_proxy: Optional['outputs.ForwardProxyResponse'] = None,
                 require_https: Optional[bool] = None,
                 routes: Optional['outputs.HttpSettingsRoutesResponse'] = None):
        """
        The configuration settings of the HTTP requests for authentication and authorization requests made against App Service Authentication/Authorization.
        :param 'ForwardProxyResponse' forward_proxy: The configuration settings of a forward proxy used to make the requests.
        :param bool require_https: <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise, <code>true</code>.
        :param 'HttpSettingsRoutesResponse' routes: The configuration settings of the paths HTTP requests.
        """
        HttpSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            forward_proxy=forward_proxy,
            require_https=require_https,
            routes=routes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             forward_proxy: Optional['outputs.ForwardProxyResponse'] = None,
             require_https: Optional[bool] = None,
             routes: Optional['outputs.HttpSettingsRoutesResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if forward_proxy is None and 'forwardProxy' in kwargs:
            forward_proxy = kwargs['forwardProxy']
        if require_https is None and 'requireHttps' in kwargs:
            require_https = kwargs['requireHttps']

        if forward_proxy is not None:
            _setter("forward_proxy", forward_proxy)
        if require_https is not None:
            _setter("require_https", require_https)
        if routes is not None:
            _setter("routes", routes)

    @property
    @pulumi.getter(name="forwardProxy")
    def forward_proxy(self) -> Optional['outputs.ForwardProxyResponse']:
        """
        The configuration settings of a forward proxy used to make the requests.
        """
        return pulumi.get(self, "forward_proxy")

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[bool]:
        """
        <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "require_https")

    @property
    @pulumi.getter
    def routes(self) -> Optional['outputs.HttpSettingsRoutesResponse']:
        """
        The configuration settings of the paths HTTP requests.
        """
        return pulumi.get(self, "routes")


@pulumi.output_type
class HttpSettingsRoutesResponse(dict):
    """
    The configuration settings of the paths HTTP requests.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiPrefix":
            suggest = "api_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpSettingsRoutesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpSettingsRoutesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpSettingsRoutesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_prefix: Optional[str] = None):
        """
        The configuration settings of the paths HTTP requests.
        :param str api_prefix: The prefix that should precede all the authentication/authorization paths.
        """
        HttpSettingsRoutesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_prefix=api_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if api_prefix is None and 'apiPrefix' in kwargs:
            api_prefix = kwargs['apiPrefix']

        if api_prefix is not None:
            _setter("api_prefix", api_prefix)

    @property
    @pulumi.getter(name="apiPrefix")
    def api_prefix(self) -> Optional[str]:
        """
        The prefix that should precede all the authentication/authorization paths.
        """
        return pulumi.get(self, "api_prefix")


@pulumi.output_type
class IdentifierResponse(dict):
    """
    A domain specific resource identifier.
    """
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 type: str,
                 kind: Optional[str] = None,
                 value: Optional[str] = None):
        """
        A domain specific resource identifier.
        :param str id: Resource Id.
        :param str name: Resource Name.
        :param str type: Resource type.
        :param str kind: Kind of resource.
        :param str value: String representation of the identity.
        """
        IdentifierResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            type=type,
            kind=kind,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             type: Optional[str] = None,
             kind: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("id", id)
        _setter("name", name)
        _setter("type", type)
        if kind is not None:
            _setter("kind", kind)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Resource Id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Resource Name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        String representation of the identity.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IdentityProvidersResponse(dict):
    """
    The configuration settings of each of the identity providers used to configure App Service Authentication/Authorization.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureActiveDirectory":
            suggest = "azure_active_directory"
        elif key == "azureStaticWebApps":
            suggest = "azure_static_web_apps"
        elif key == "customOpenIdConnectProviders":
            suggest = "custom_open_id_connect_providers"
        elif key == "gitHub":
            suggest = "git_hub"
        elif key == "legacyMicrosoftAccount":
            suggest = "legacy_microsoft_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityProvidersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityProvidersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityProvidersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apple: Optional['outputs.AppleResponse'] = None,
                 azure_active_directory: Optional['outputs.AzureActiveDirectoryResponse'] = None,
                 azure_static_web_apps: Optional['outputs.AzureStaticWebAppsResponse'] = None,
                 custom_open_id_connect_providers: Optional[Mapping[str, 'outputs.CustomOpenIdConnectProviderResponse']] = None,
                 facebook: Optional['outputs.FacebookResponse'] = None,
                 git_hub: Optional['outputs.GitHubResponse'] = None,
                 google: Optional['outputs.GoogleResponse'] = None,
                 legacy_microsoft_account: Optional['outputs.LegacyMicrosoftAccountResponse'] = None,
                 twitter: Optional['outputs.TwitterResponse'] = None):
        """
        The configuration settings of each of the identity providers used to configure App Service Authentication/Authorization.
        :param 'AppleResponse' apple: The configuration settings of the Apple provider.
        :param 'AzureActiveDirectoryResponse' azure_active_directory: The configuration settings of the Azure Active directory provider.
        :param 'AzureStaticWebAppsResponse' azure_static_web_apps: The configuration settings of the Azure Static Web Apps provider.
        :param Mapping[str, 'CustomOpenIdConnectProviderResponse'] custom_open_id_connect_providers: The map of the name of the alias of each custom Open ID Connect provider to the
               configuration settings of the custom Open ID Connect provider.
        :param 'FacebookResponse' facebook: The configuration settings of the Facebook provider.
        :param 'GitHubResponse' git_hub: The configuration settings of the GitHub provider.
        :param 'GoogleResponse' google: The configuration settings of the Google provider.
        :param 'LegacyMicrosoftAccountResponse' legacy_microsoft_account: The configuration settings of the legacy Microsoft Account provider.
        :param 'TwitterResponse' twitter: The configuration settings of the Twitter provider.
        """
        IdentityProvidersResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apple=apple,
            azure_active_directory=azure_active_directory,
            azure_static_web_apps=azure_static_web_apps,
            custom_open_id_connect_providers=custom_open_id_connect_providers,
            facebook=facebook,
            git_hub=git_hub,
            google=google,
            legacy_microsoft_account=legacy_microsoft_account,
            twitter=twitter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apple: Optional['outputs.AppleResponse'] = None,
             azure_active_directory: Optional['outputs.AzureActiveDirectoryResponse'] = None,
             azure_static_web_apps: Optional['outputs.AzureStaticWebAppsResponse'] = None,
             custom_open_id_connect_providers: Optional[Mapping[str, 'outputs.CustomOpenIdConnectProviderResponse']] = None,
             facebook: Optional['outputs.FacebookResponse'] = None,
             git_hub: Optional['outputs.GitHubResponse'] = None,
             google: Optional['outputs.GoogleResponse'] = None,
             legacy_microsoft_account: Optional['outputs.LegacyMicrosoftAccountResponse'] = None,
             twitter: Optional['outputs.TwitterResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if azure_active_directory is None and 'azureActiveDirectory' in kwargs:
            azure_active_directory = kwargs['azureActiveDirectory']
        if azure_static_web_apps is None and 'azureStaticWebApps' in kwargs:
            azure_static_web_apps = kwargs['azureStaticWebApps']
        if custom_open_id_connect_providers is None and 'customOpenIdConnectProviders' in kwargs:
            custom_open_id_connect_providers = kwargs['customOpenIdConnectProviders']
        if git_hub is None and 'gitHub' in kwargs:
            git_hub = kwargs['gitHub']
        if legacy_microsoft_account is None and 'legacyMicrosoftAccount' in kwargs:
            legacy_microsoft_account = kwargs['legacyMicrosoftAccount']

        if apple is not None:
            _setter("apple", apple)
        if azure_active_directory is not None:
            _setter("azure_active_directory", azure_active_directory)
        if azure_static_web_apps is not None:
            _setter("azure_static_web_apps", azure_static_web_apps)
        if custom_open_id_connect_providers is not None:
            _setter("custom_open_id_connect_providers", custom_open_id_connect_providers)
        if facebook is not None:
            _setter("facebook", facebook)
        if git_hub is not None:
            _setter("git_hub", git_hub)
        if google is not None:
            _setter("google", google)
        if legacy_microsoft_account is not None:
            _setter("legacy_microsoft_account", legacy_microsoft_account)
        if twitter is not None:
            _setter("twitter", twitter)

    @property
    @pulumi.getter
    def apple(self) -> Optional['outputs.AppleResponse']:
        """
        The configuration settings of the Apple provider.
        """
        return pulumi.get(self, "apple")

    @property
    @pulumi.getter(name="azureActiveDirectory")
    def azure_active_directory(self) -> Optional['outputs.AzureActiveDirectoryResponse']:
        """
        The configuration settings of the Azure Active directory provider.
        """
        return pulumi.get(self, "azure_active_directory")

    @property
    @pulumi.getter(name="azureStaticWebApps")
    def azure_static_web_apps(self) -> Optional['outputs.AzureStaticWebAppsResponse']:
        """
        The configuration settings of the Azure Static Web Apps provider.
        """
        return pulumi.get(self, "azure_static_web_apps")

    @property
    @pulumi.getter(name="customOpenIdConnectProviders")
    def custom_open_id_connect_providers(self) -> Optional[Mapping[str, 'outputs.CustomOpenIdConnectProviderResponse']]:
        """
        The map of the name of the alias of each custom Open ID Connect provider to the
        configuration settings of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "custom_open_id_connect_providers")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.FacebookResponse']:
        """
        The configuration settings of the Facebook provider.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter(name="gitHub")
    def git_hub(self) -> Optional['outputs.GitHubResponse']:
        """
        The configuration settings of the GitHub provider.
        """
        return pulumi.get(self, "git_hub")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.GoogleResponse']:
        """
        The configuration settings of the Google provider.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter(name="legacyMicrosoftAccount")
    def legacy_microsoft_account(self) -> Optional['outputs.LegacyMicrosoftAccountResponse']:
        """
        The configuration settings of the legacy Microsoft Account provider.
        """
        return pulumi.get(self, "legacy_microsoft_account")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.TwitterResponse']:
        """
        The configuration settings of the Twitter provider.
        """
        return pulumi.get(self, "twitter")


@pulumi.output_type
class JwtClaimChecksResponse(dict):
    """
    The configuration settings of the checks that should be made while validating the JWT Claims.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedClientApplications":
            suggest = "allowed_client_applications"
        elif key == "allowedGroups":
            suggest = "allowed_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JwtClaimChecksResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JwtClaimChecksResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JwtClaimChecksResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_client_applications: Optional[Sequence[str]] = None,
                 allowed_groups: Optional[Sequence[str]] = None):
        """
        The configuration settings of the checks that should be made while validating the JWT Claims.
        :param Sequence[str] allowed_client_applications: The list of the allowed client applications.
        :param Sequence[str] allowed_groups: The list of the allowed groups.
        """
        JwtClaimChecksResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_client_applications=allowed_client_applications,
            allowed_groups=allowed_groups,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_client_applications: Optional[Sequence[str]] = None,
             allowed_groups: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allowed_client_applications is None and 'allowedClientApplications' in kwargs:
            allowed_client_applications = kwargs['allowedClientApplications']
        if allowed_groups is None and 'allowedGroups' in kwargs:
            allowed_groups = kwargs['allowedGroups']

        if allowed_client_applications is not None:
            _setter("allowed_client_applications", allowed_client_applications)
        if allowed_groups is not None:
            _setter("allowed_groups", allowed_groups)

    @property
    @pulumi.getter(name="allowedClientApplications")
    def allowed_client_applications(self) -> Optional[Sequence[str]]:
        """
        The list of the allowed client applications.
        """
        return pulumi.get(self, "allowed_client_applications")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[Sequence[str]]:
        """
        The list of the allowed groups.
        """
        return pulumi.get(self, "allowed_groups")


@pulumi.output_type
class LegacyMicrosoftAccountResponse(dict):
    """
    The configuration settings of the legacy Microsoft Account provider.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 login: Optional['outputs.LoginScopesResponse'] = None,
                 registration: Optional['outputs.ClientRegistrationResponse'] = None,
                 validation: Optional['outputs.AllowedAudiencesValidationResponse'] = None):
        """
        The configuration settings of the legacy Microsoft Account provider.
        :param bool enabled: <code>false</code> if the legacy Microsoft Account provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param 'LoginScopesResponse' login: The configuration settings of the login flow.
        :param 'ClientRegistrationResponse' registration: The configuration settings of the app registration for the legacy Microsoft Account provider.
        :param 'AllowedAudiencesValidationResponse' validation: The configuration settings of the legacy Microsoft Account provider token validation flow.
        """
        LegacyMicrosoftAccountResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            login=login,
            registration=registration,
            validation=validation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             login: Optional['outputs.LoginScopesResponse'] = None,
             registration: Optional['outputs.ClientRegistrationResponse'] = None,
             validation: Optional['outputs.AllowedAudiencesValidationResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)
        if login is not None:
            _setter("login", login)
        if registration is not None:
            _setter("registration", registration)
        if validation is not None:
            _setter("validation", validation)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        <code>false</code> if the legacy Microsoft Account provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def login(self) -> Optional['outputs.LoginScopesResponse']:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter
    def registration(self) -> Optional['outputs.ClientRegistrationResponse']:
        """
        The configuration settings of the app registration for the legacy Microsoft Account provider.
        """
        return pulumi.get(self, "registration")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.AllowedAudiencesValidationResponse']:
        """
        The configuration settings of the legacy Microsoft Account provider token validation flow.
        """
        return pulumi.get(self, "validation")


@pulumi.output_type
class LoginResponse(dict):
    """
    The configuration settings of the login flow of users using App Service Authentication/Authorization.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "cookieExpiration":
            suggest = "cookie_expiration"
        elif key == "preserveUrlFragmentsForLogins":
            suggest = "preserve_url_fragments_for_logins"
        elif key == "tokenStore":
            suggest = "token_store"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoginResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoginResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoginResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[Sequence[str]] = None,
                 cookie_expiration: Optional['outputs.CookieExpirationResponse'] = None,
                 nonce: Optional['outputs.NonceResponse'] = None,
                 preserve_url_fragments_for_logins: Optional[bool] = None,
                 routes: Optional['outputs.LoginRoutesResponse'] = None,
                 token_store: Optional['outputs.TokenStoreResponse'] = None):
        """
        The configuration settings of the login flow of users using App Service Authentication/Authorization.
        :param Sequence[str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part of the URL is ignored.
               This is an advanced setting typically only needed by Windows Store application backends.
               Note that URLs within the current domain are always implicitly allowed.
        :param 'CookieExpirationResponse' cookie_expiration: The configuration settings of the session cookie's expiration.
        :param 'NonceResponse' nonce: The configuration settings of the nonce used in the login flow.
        :param bool preserve_url_fragments_for_logins: <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        :param 'LoginRoutesResponse' routes: The routes that specify the endpoints used for login and logout requests.
        :param 'TokenStoreResponse' token_store: The configuration settings of the token store.
        """
        LoginResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_external_redirect_urls=allowed_external_redirect_urls,
            cookie_expiration=cookie_expiration,
            nonce=nonce,
            preserve_url_fragments_for_logins=preserve_url_fragments_for_logins,
            routes=routes,
            token_store=token_store,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_external_redirect_urls: Optional[Sequence[str]] = None,
             cookie_expiration: Optional['outputs.CookieExpirationResponse'] = None,
             nonce: Optional['outputs.NonceResponse'] = None,
             preserve_url_fragments_for_logins: Optional[bool] = None,
             routes: Optional['outputs.LoginRoutesResponse'] = None,
             token_store: Optional['outputs.TokenStoreResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allowed_external_redirect_urls is None and 'allowedExternalRedirectUrls' in kwargs:
            allowed_external_redirect_urls = kwargs['allowedExternalRedirectUrls']
        if cookie_expiration is None and 'cookieExpiration' in kwargs:
            cookie_expiration = kwargs['cookieExpiration']
        if preserve_url_fragments_for_logins is None and 'preserveUrlFragmentsForLogins' in kwargs:
            preserve_url_fragments_for_logins = kwargs['preserveUrlFragmentsForLogins']
        if token_store is None and 'tokenStore' in kwargs:
            token_store = kwargs['tokenStore']

        if allowed_external_redirect_urls is not None:
            _setter("allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration is not None:
            _setter("cookie_expiration", cookie_expiration)
        if nonce is not None:
            _setter("nonce", nonce)
        if preserve_url_fragments_for_logins is not None:
            _setter("preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if routes is not None:
            _setter("routes", routes)
        if token_store is not None:
            _setter("token_store", token_store)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[str]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part of the URL is ignored.
        This is an advanced setting typically only needed by Windows Store application backends.
        Note that URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="cookieExpiration")
    def cookie_expiration(self) -> Optional['outputs.CookieExpirationResponse']:
        """
        The configuration settings of the session cookie's expiration.
        """
        return pulumi.get(self, "cookie_expiration")

    @property
    @pulumi.getter
    def nonce(self) -> Optional['outputs.NonceResponse']:
        """
        The configuration settings of the nonce used in the login flow.
        """
        return pulumi.get(self, "nonce")

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[bool]:
        """
        <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @property
    @pulumi.getter
    def routes(self) -> Optional['outputs.LoginRoutesResponse']:
        """
        The routes that specify the endpoints used for login and logout requests.
        """
        return pulumi.get(self, "routes")

    @property
    @pulumi.getter(name="tokenStore")
    def token_store(self) -> Optional['outputs.TokenStoreResponse']:
        """
        The configuration settings of the token store.
        """
        return pulumi.get(self, "token_store")


@pulumi.output_type
class LoginRoutesResponse(dict):
    """
    The routes that specify the endpoints used for login and logout requests.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logoutEndpoint":
            suggest = "logout_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoginRoutesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoginRoutesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoginRoutesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logout_endpoint: Optional[str] = None):
        """
        The routes that specify the endpoints used for login and logout requests.
        :param str logout_endpoint: The endpoint at which a logout request should be made.
        """
        LoginRoutesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            logout_endpoint=logout_endpoint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             logout_endpoint: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if logout_endpoint is None and 'logoutEndpoint' in kwargs:
            logout_endpoint = kwargs['logoutEndpoint']

        if logout_endpoint is not None:
            _setter("logout_endpoint", logout_endpoint)

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[str]:
        """
        The endpoint at which a logout request should be made.
        """
        return pulumi.get(self, "logout_endpoint")


@pulumi.output_type
class LoginScopesResponse(dict):
    """
    The configuration settings of the login flow, including the scopes that should be requested.
    """
    def __init__(__self__, *,
                 scopes: Optional[Sequence[str]] = None):
        """
        The configuration settings of the login flow, including the scopes that should be requested.
        :param Sequence[str] scopes: A list of the scopes that should be requested while authenticating.
        """
        LoginScopesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scopes=scopes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scopes: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if scopes is not None:
            _setter("scopes", scopes)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        A list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: Optional[str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity.
        :param str principal_id: Principal Id of managed service identity.
        :param str tenant_id: Tenant of managed service identity.
        :param str type: Type of managed service identity.
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The list of user assigned identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
        """
        ManagedServiceIdentityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            principal_id=principal_id,
            tenant_id=tenant_id,
            type=type,
            user_assigned_identities=user_assigned_identities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             principal_id: Optional[str] = None,
             tenant_id: Optional[str] = None,
             type: Optional[str] = None,
             user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if principal_id is None and 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if principal_id is None:
            raise TypeError("Missing 'principal_id' argument")
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_id is None:
            raise TypeError("Missing 'tenant_id' argument")
        if user_assigned_identities is None and 'userAssignedIdentities' in kwargs:
            user_assigned_identities = kwargs['userAssignedIdentities']

        _setter("principal_id", principal_id)
        _setter("tenant_id", tenant_id)
        if type is not None:
            _setter("type", type)
        if user_assigned_identities is not None:
            _setter("user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        Principal Id of managed service identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Tenant of managed service identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of managed service identity.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The list of user assigned identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class NonceResponse(dict):
    """
    The configuration settings of the nonce used in the login flow.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nonceExpirationInterval":
            suggest = "nonce_expiration_interval"
        elif key == "validateNonce":
            suggest = "validate_nonce"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NonceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NonceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NonceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nonce_expiration_interval: Optional[str] = None,
                 validate_nonce: Optional[bool] = None):
        """
        The configuration settings of the nonce used in the login flow.
        :param str nonce_expiration_interval: The time after the request is made when the nonce should expire.
        :param bool validate_nonce: <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        """
        NonceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            nonce_expiration_interval=nonce_expiration_interval,
            validate_nonce=validate_nonce,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             nonce_expiration_interval: Optional[str] = None,
             validate_nonce: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if nonce_expiration_interval is None and 'nonceExpirationInterval' in kwargs:
            nonce_expiration_interval = kwargs['nonceExpirationInterval']
        if validate_nonce is None and 'validateNonce' in kwargs:
            validate_nonce = kwargs['validateNonce']

        if nonce_expiration_interval is not None:
            _setter("nonce_expiration_interval", nonce_expiration_interval)
        if validate_nonce is not None:
            _setter("validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="nonceExpirationInterval")
    def nonce_expiration_interval(self) -> Optional[str]:
        """
        The time after the request is made when the nonce should expire.
        """
        return pulumi.get(self, "nonce_expiration_interval")

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[bool]:
        """
        <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "validate_nonce")


@pulumi.output_type
class OpenIdConnectClientCredentialResponse(dict):
    """
    The authentication client credentials of the custom Open ID Connect provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenIdConnectClientCredentialResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenIdConnectClientCredentialResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenIdConnectClientCredentialResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_secret_setting_name: Optional[str] = None,
                 method: Optional[str] = None):
        """
        The authentication client credentials of the custom Open ID Connect provider.
        :param str client_secret_setting_name: The app setting that contains the client secret for the custom Open ID Connect provider.
        :param str method: The method that should be used to authenticate the user.
        """
        OpenIdConnectClientCredentialResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_secret_setting_name=client_secret_setting_name,
            method=method,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_secret_setting_name: Optional[str] = None,
             method: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_secret_setting_name is None and 'clientSecretSettingName' in kwargs:
            client_secret_setting_name = kwargs['clientSecretSettingName']

        if client_secret_setting_name is not None:
            _setter("client_secret_setting_name", client_secret_setting_name)
        if method is not None:
            _setter("method", method)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[str]:
        """
        The app setting that contains the client secret for the custom Open ID Connect provider.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The method that should be used to authenticate the user.
        """
        return pulumi.get(self, "method")


@pulumi.output_type
class OpenIdConnectConfigResponse(dict):
    """
    The configuration settings of the endpoints used for the custom Open ID Connect provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "certificationUri":
            suggest = "certification_uri"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "wellKnownOpenIdConfiguration":
            suggest = "well_known_open_id_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenIdConnectConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenIdConnectConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenIdConnectConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_endpoint: Optional[str] = None,
                 certification_uri: Optional[str] = None,
                 issuer: Optional[str] = None,
                 token_endpoint: Optional[str] = None,
                 well_known_open_id_configuration: Optional[str] = None):
        """
        The configuration settings of the endpoints used for the custom Open ID Connect provider.
        :param str authorization_endpoint: The endpoint to be used to make an authorization request.
        :param str certification_uri: The endpoint that provides the keys necessary to validate the token.
        :param str issuer: The endpoint that issues the token.
        :param str token_endpoint: The endpoint to be used to request a token.
        :param str well_known_open_id_configuration: The endpoint that contains all the configuration endpoints for the provider.
        """
        OpenIdConnectConfigResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authorization_endpoint=authorization_endpoint,
            certification_uri=certification_uri,
            issuer=issuer,
            token_endpoint=token_endpoint,
            well_known_open_id_configuration=well_known_open_id_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authorization_endpoint: Optional[str] = None,
             certification_uri: Optional[str] = None,
             issuer: Optional[str] = None,
             token_endpoint: Optional[str] = None,
             well_known_open_id_configuration: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if authorization_endpoint is None and 'authorizationEndpoint' in kwargs:
            authorization_endpoint = kwargs['authorizationEndpoint']
        if certification_uri is None and 'certificationUri' in kwargs:
            certification_uri = kwargs['certificationUri']
        if token_endpoint is None and 'tokenEndpoint' in kwargs:
            token_endpoint = kwargs['tokenEndpoint']
        if well_known_open_id_configuration is None and 'wellKnownOpenIdConfiguration' in kwargs:
            well_known_open_id_configuration = kwargs['wellKnownOpenIdConfiguration']

        if authorization_endpoint is not None:
            _setter("authorization_endpoint", authorization_endpoint)
        if certification_uri is not None:
            _setter("certification_uri", certification_uri)
        if issuer is not None:
            _setter("issuer", issuer)
        if token_endpoint is not None:
            _setter("token_endpoint", token_endpoint)
        if well_known_open_id_configuration is not None:
            _setter("well_known_open_id_configuration", well_known_open_id_configuration)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[str]:
        """
        The endpoint to be used to make an authorization request.
        """
        return pulumi.get(self, "authorization_endpoint")

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[str]:
        """
        The endpoint that provides the keys necessary to validate the token.
        """
        return pulumi.get(self, "certification_uri")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The endpoint that issues the token.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[str]:
        """
        The endpoint to be used to request a token.
        """
        return pulumi.get(self, "token_endpoint")

    @property
    @pulumi.getter(name="wellKnownOpenIdConfiguration")
    def well_known_open_id_configuration(self) -> Optional[str]:
        """
        The endpoint that contains all the configuration endpoints for the provider.
        """
        return pulumi.get(self, "well_known_open_id_configuration")


@pulumi.output_type
class OpenIdConnectLoginResponse(dict):
    """
    The configuration settings of the login flow of the custom Open ID Connect provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nameClaimType":
            suggest = "name_claim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenIdConnectLoginResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenIdConnectLoginResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenIdConnectLoginResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name_claim_type: Optional[str] = None,
                 scopes: Optional[Sequence[str]] = None):
        """
        The configuration settings of the login flow of the custom Open ID Connect provider.
        :param str name_claim_type: The name of the claim that contains the users name.
        :param Sequence[str] scopes: A list of the scopes that should be requested while authenticating.
        """
        OpenIdConnectLoginResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name_claim_type=name_claim_type,
            scopes=scopes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name_claim_type: Optional[str] = None,
             scopes: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name_claim_type is None and 'nameClaimType' in kwargs:
            name_claim_type = kwargs['nameClaimType']

        if name_claim_type is not None:
            _setter("name_claim_type", name_claim_type)
        if scopes is not None:
            _setter("scopes", scopes)

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[str]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        A list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class OpenIdConnectRegistrationResponse(dict):
    """
    The configuration settings of the app registration for the custom Open ID Connect provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCredential":
            suggest = "client_credential"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "openIdConnectConfiguration":
            suggest = "open_id_connect_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenIdConnectRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenIdConnectRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenIdConnectRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_credential: Optional['outputs.OpenIdConnectClientCredentialResponse'] = None,
                 client_id: Optional[str] = None,
                 open_id_connect_configuration: Optional['outputs.OpenIdConnectConfigResponse'] = None):
        """
        The configuration settings of the app registration for the custom Open ID Connect provider.
        :param 'OpenIdConnectClientCredentialResponse' client_credential: The authentication credentials of the custom Open ID Connect provider.
        :param str client_id: The client id of the custom Open ID Connect provider.
        :param 'OpenIdConnectConfigResponse' open_id_connect_configuration: The configuration settings of the endpoints used for the custom Open ID Connect provider.
        """
        OpenIdConnectRegistrationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_credential=client_credential,
            client_id=client_id,
            open_id_connect_configuration=open_id_connect_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_credential: Optional['outputs.OpenIdConnectClientCredentialResponse'] = None,
             client_id: Optional[str] = None,
             open_id_connect_configuration: Optional['outputs.OpenIdConnectConfigResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_credential is None and 'clientCredential' in kwargs:
            client_credential = kwargs['clientCredential']
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if open_id_connect_configuration is None and 'openIdConnectConfiguration' in kwargs:
            open_id_connect_configuration = kwargs['openIdConnectConfiguration']

        if client_credential is not None:
            _setter("client_credential", client_credential)
        if client_id is not None:
            _setter("client_id", client_id)
        if open_id_connect_configuration is not None:
            _setter("open_id_connect_configuration", open_id_connect_configuration)

    @property
    @pulumi.getter(name="clientCredential")
    def client_credential(self) -> Optional['outputs.OpenIdConnectClientCredentialResponse']:
        """
        The authentication credentials of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "client_credential")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The client id of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="openIdConnectConfiguration")
    def open_id_connect_configuration(self) -> Optional['outputs.OpenIdConnectConfigResponse']:
        """
        The configuration settings of the endpoints used for the custom Open ID Connect provider.
        """
        return pulumi.get(self, "open_id_connect_configuration")


@pulumi.output_type
class PrivateLinkConnectionStateResponse(dict):
    """
    The state of a private link connection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsRequired":
            suggest = "actions_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkConnectionStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkConnectionStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkConnectionStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_required: Optional[str] = None,
                 description: Optional[str] = None,
                 status: Optional[str] = None):
        """
        The state of a private link connection
        :param str actions_required: ActionsRequired for a private link connection
        :param str description: Description of a private link connection
        :param str status: Status of a private link connection
        """
        PrivateLinkConnectionStateResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions_required=actions_required,
            description=description,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions_required: Optional[str] = None,
             description: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions_required is None and 'actionsRequired' in kwargs:
            actions_required = kwargs['actionsRequired']

        if actions_required is not None:
            _setter("actions_required", actions_required)
        if description is not None:
            _setter("description", description)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[str]:
        """
        ActionsRequired for a private link connection
        """
        return pulumi.get(self, "actions_required")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of a private link connection
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of a private link connection
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class RemotePrivateEndpointConnectionResponse(dict):
    """
    A remote private endpoint connection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "ipAddresses":
            suggest = "ip_addresses"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"
        elif key == "privateLinkServiceConnectionState":
            suggest = "private_link_service_connection_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemotePrivateEndpointConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemotePrivateEndpointConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemotePrivateEndpointConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 name: str,
                 provisioning_state: str,
                 type: str,
                 ip_addresses: Optional[Sequence[str]] = None,
                 kind: Optional[str] = None,
                 private_endpoint: Optional['outputs.ArmIdWrapperResponse'] = None,
                 private_link_service_connection_state: Optional['outputs.PrivateLinkConnectionStateResponse'] = None):
        """
        A remote private endpoint connection
        :param str id: Resource Id.
        :param str name: Resource Name.
        :param str type: Resource type.
        :param Sequence[str] ip_addresses: Private IPAddresses mapped to the remote private endpoint
        :param str kind: Kind of resource.
        :param 'ArmIdWrapperResponse' private_endpoint: PrivateEndpoint of a remote private endpoint connection
        :param 'PrivateLinkConnectionStateResponse' private_link_service_connection_state: The state of a private link connection
        """
        RemotePrivateEndpointConnectionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            provisioning_state=provisioning_state,
            type=type,
            ip_addresses=ip_addresses,
            kind=kind,
            private_endpoint=private_endpoint,
            private_link_service_connection_state=private_link_service_connection_state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             type: Optional[str] = None,
             ip_addresses: Optional[Sequence[str]] = None,
             kind: Optional[str] = None,
             private_endpoint: Optional['outputs.ArmIdWrapperResponse'] = None,
             private_link_service_connection_state: Optional['outputs.PrivateLinkConnectionStateResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if ip_addresses is None and 'ipAddresses' in kwargs:
            ip_addresses = kwargs['ipAddresses']
        if private_endpoint is None and 'privateEndpoint' in kwargs:
            private_endpoint = kwargs['privateEndpoint']
        if private_link_service_connection_state is None and 'privateLinkServiceConnectionState' in kwargs:
            private_link_service_connection_state = kwargs['privateLinkServiceConnectionState']

        _setter("id", id)
        _setter("name", name)
        _setter("provisioning_state", provisioning_state)
        _setter("type", type)
        if ip_addresses is not None:
            _setter("ip_addresses", ip_addresses)
        if kind is not None:
            _setter("kind", kind)
        if private_endpoint is not None:
            _setter("private_endpoint", private_endpoint)
        if private_link_service_connection_state is not None:
            _setter("private_link_service_connection_state", private_link_service_connection_state)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Resource Id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Resource Name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[str]]:
        """
        Private IPAddresses mapped to the remote private endpoint
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.ArmIdWrapperResponse']:
        """
        PrivateEndpoint of a remote private endpoint connection
        """
        return pulumi.get(self, "private_endpoint")

    @property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> Optional['outputs.PrivateLinkConnectionStateResponse']:
        """
        The state of a private link connection
        """
        return pulumi.get(self, "private_link_service_connection_state")


@pulumi.output_type
class ResponseMessageEnvelopeRemotePrivateEndpointConnectionResponse(dict):
    """
    Message envelope that contains the common Azure resource manager properties and the resource provider specific content.
    """
    def __init__(__self__, *,
                 error: Optional['outputs.ErrorEntityResponse'] = None,
                 id: Optional[str] = None,
                 identity: Optional['outputs.ManagedServiceIdentityResponse'] = None,
                 location: Optional[str] = None,
                 name: Optional[str] = None,
                 plan: Optional['outputs.ArmPlanResponse'] = None,
                 properties: Optional['outputs.RemotePrivateEndpointConnectionResponse'] = None,
                 sku: Optional['outputs.SkuDescriptionResponse'] = None,
                 status: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 type: Optional[str] = None,
                 zones: Optional[Sequence[str]] = None):
        """
        Message envelope that contains the common Azure resource manager properties and the resource provider specific content.
        :param 'ErrorEntityResponse' error: Azure-AsyncOperation Error info.
        :param str id: Resource Id. Typically ID is populated only for responses to GET requests. Caller is responsible for passing in this
               value for GET requests only.
               For example: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupId}/providers/Microsoft.Web/sites/{sitename}
        :param 'ManagedServiceIdentityResponse' identity: MSI resource
        :param str location: Geographical region resource belongs to e.g. SouthCentralUS, SouthEastAsia.
        :param str name: Name of resource.
        :param 'ArmPlanResponse' plan: Azure resource manager plan.
        :param 'RemotePrivateEndpointConnectionResponse' properties: Resource specific properties.
        :param 'SkuDescriptionResponse' sku: SKU description of the resource.
        :param str status: Azure-AsyncOperation Status info.
        :param Mapping[str, str] tags: Tags associated with resource.
        :param str type: Type of resource e.g "Microsoft.Web/sites".
        :param Sequence[str] zones: Logical Availability Zones the service is hosted in
        """
        ResponseMessageEnvelopeRemotePrivateEndpointConnectionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error=error,
            id=id,
            identity=identity,
            location=location,
            name=name,
            plan=plan,
            properties=properties,
            sku=sku,
            status=status,
            tags=tags,
            type=type,
            zones=zones,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error: Optional['outputs.ErrorEntityResponse'] = None,
             id: Optional[str] = None,
             identity: Optional['outputs.ManagedServiceIdentityResponse'] = None,
             location: Optional[str] = None,
             name: Optional[str] = None,
             plan: Optional['outputs.ArmPlanResponse'] = None,
             properties: Optional['outputs.RemotePrivateEndpointConnectionResponse'] = None,
             sku: Optional['outputs.SkuDescriptionResponse'] = None,
             status: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             type: Optional[str] = None,
             zones: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if error is not None:
            _setter("error", error)
        if id is not None:
            _setter("id", id)
        if identity is not None:
            _setter("identity", identity)
        if location is not None:
            _setter("location", location)
        if name is not None:
            _setter("name", name)
        if plan is not None:
            _setter("plan", plan)
        if properties is not None:
            _setter("properties", properties)
        if sku is not None:
            _setter("sku", sku)
        if status is not None:
            _setter("status", status)
        if tags is not None:
            _setter("tags", tags)
        if type is not None:
            _setter("type", type)
        if zones is not None:
            _setter("zones", zones)

    @property
    @pulumi.getter
    def error(self) -> Optional['outputs.ErrorEntityResponse']:
        """
        Azure-AsyncOperation Error info.
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource Id. Typically ID is populated only for responses to GET requests. Caller is responsible for passing in this
        value for GET requests only.
        For example: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupId}/providers/Microsoft.Web/sites/{sitename}
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def identity(self) -> Optional['outputs.ManagedServiceIdentityResponse']:
        """
        MSI resource
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Geographical region resource belongs to e.g. SouthCentralUS, SouthEastAsia.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def plan(self) -> Optional['outputs.ArmPlanResponse']:
        """
        Azure resource manager plan.
        """
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.RemotePrivateEndpointConnectionResponse']:
        """
        Resource specific properties.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def sku(self) -> Optional['outputs.SkuDescriptionResponse']:
        """
        SKU description of the resource.
        """
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Azure-AsyncOperation Status info.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags associated with resource.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of resource e.g "Microsoft.Web/sites".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zones(self) -> Optional[Sequence[str]]:
        """
        Logical Availability Zones the service is hosted in
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class SkuCapacityResponse(dict):
    """
    Description of the App Service plan scale options.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elasticMaximum":
            suggest = "elastic_maximum"
        elif key == "scaleType":
            suggest = "scale_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SkuCapacityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SkuCapacityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SkuCapacityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default: Optional[int] = None,
                 elastic_maximum: Optional[int] = None,
                 maximum: Optional[int] = None,
                 minimum: Optional[int] = None,
                 scale_type: Optional[str] = None):
        """
        Description of the App Service plan scale options.
        :param int default: Default number of workers for this App Service plan SKU.
        :param int elastic_maximum: Maximum number of Elastic workers for this App Service plan SKU.
        :param int maximum: Maximum number of workers for this App Service plan SKU.
        :param int minimum: Minimum number of workers for this App Service plan SKU.
        :param str scale_type: Available scale configurations for an App Service plan.
        """
        SkuCapacityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default=default,
            elastic_maximum=elastic_maximum,
            maximum=maximum,
            minimum=minimum,
            scale_type=scale_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default: Optional[int] = None,
             elastic_maximum: Optional[int] = None,
             maximum: Optional[int] = None,
             minimum: Optional[int] = None,
             scale_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if elastic_maximum is None and 'elasticMaximum' in kwargs:
            elastic_maximum = kwargs['elasticMaximum']
        if scale_type is None and 'scaleType' in kwargs:
            scale_type = kwargs['scaleType']

        if default is not None:
            _setter("default", default)
        if elastic_maximum is not None:
            _setter("elastic_maximum", elastic_maximum)
        if maximum is not None:
            _setter("maximum", maximum)
        if minimum is not None:
            _setter("minimum", minimum)
        if scale_type is not None:
            _setter("scale_type", scale_type)

    @property
    @pulumi.getter
    def default(self) -> Optional[int]:
        """
        Default number of workers for this App Service plan SKU.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter(name="elasticMaximum")
    def elastic_maximum(self) -> Optional[int]:
        """
        Maximum number of Elastic workers for this App Service plan SKU.
        """
        return pulumi.get(self, "elastic_maximum")

    @property
    @pulumi.getter
    def maximum(self) -> Optional[int]:
        """
        Maximum number of workers for this App Service plan SKU.
        """
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[int]:
        """
        Minimum number of workers for this App Service plan SKU.
        """
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter(name="scaleType")
    def scale_type(self) -> Optional[str]:
        """
        Available scale configurations for an App Service plan.
        """
        return pulumi.get(self, "scale_type")


@pulumi.output_type
class SkuDescriptionResponse(dict):
    """
    Description of a SKU for a scalable resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skuCapacity":
            suggest = "sku_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SkuDescriptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SkuDescriptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SkuDescriptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capabilities: Optional[Sequence['outputs.CapabilityResponse']] = None,
                 capacity: Optional[int] = None,
                 family: Optional[str] = None,
                 locations: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 size: Optional[str] = None,
                 sku_capacity: Optional['outputs.SkuCapacityResponse'] = None,
                 tier: Optional[str] = None):
        """
        Description of a SKU for a scalable resource.
        :param Sequence['CapabilityResponse'] capabilities: Capabilities of the SKU, e.g., is traffic manager enabled?
        :param int capacity: Current number of instances assigned to the resource.
        :param str family: Family code of the resource SKU.
        :param Sequence[str] locations: Locations of the SKU.
        :param str name: Name of the resource SKU.
        :param str size: Size specifier of the resource SKU.
        :param 'SkuCapacityResponse' sku_capacity: Min, max, and default scale values of the SKU.
        :param str tier: Service tier of the resource SKU.
        """
        SkuDescriptionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capabilities=capabilities,
            capacity=capacity,
            family=family,
            locations=locations,
            name=name,
            size=size,
            sku_capacity=sku_capacity,
            tier=tier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capabilities: Optional[Sequence['outputs.CapabilityResponse']] = None,
             capacity: Optional[int] = None,
             family: Optional[str] = None,
             locations: Optional[Sequence[str]] = None,
             name: Optional[str] = None,
             size: Optional[str] = None,
             sku_capacity: Optional['outputs.SkuCapacityResponse'] = None,
             tier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if sku_capacity is None and 'skuCapacity' in kwargs:
            sku_capacity = kwargs['skuCapacity']

        if capabilities is not None:
            _setter("capabilities", capabilities)
        if capacity is not None:
            _setter("capacity", capacity)
        if family is not None:
            _setter("family", family)
        if locations is not None:
            _setter("locations", locations)
        if name is not None:
            _setter("name", name)
        if size is not None:
            _setter("size", size)
        if sku_capacity is not None:
            _setter("sku_capacity", sku_capacity)
        if tier is not None:
            _setter("tier", tier)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[Sequence['outputs.CapabilityResponse']]:
        """
        Capabilities of the SKU, e.g., is traffic manager enabled?
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def capacity(self) -> Optional[int]:
        """
        Current number of instances assigned to the resource.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def family(self) -> Optional[str]:
        """
        Family code of the resource SKU.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[str]]:
        """
        Locations of the SKU.
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the resource SKU.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        """
        Size specifier of the resource SKU.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="skuCapacity")
    def sku_capacity(self) -> Optional['outputs.SkuCapacityResponse']:
        """
        Min, max, and default scale values of the SKU.
        """
        return pulumi.get(self, "sku_capacity")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        """
        Service tier of the resource SKU.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class StaticSiteBuildPropertiesResponse(dict):
    """
    Build properties for the static site.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiBuildCommand":
            suggest = "api_build_command"
        elif key == "apiLocation":
            suggest = "api_location"
        elif key == "appArtifactLocation":
            suggest = "app_artifact_location"
        elif key == "appBuildCommand":
            suggest = "app_build_command"
        elif key == "appLocation":
            suggest = "app_location"
        elif key == "githubActionSecretNameOverride":
            suggest = "github_action_secret_name_override"
        elif key == "outputLocation":
            suggest = "output_location"
        elif key == "skipGithubActionWorkflowGeneration":
            suggest = "skip_github_action_workflow_generation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StaticSiteBuildPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StaticSiteBuildPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StaticSiteBuildPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_build_command: Optional[str] = None,
                 api_location: Optional[str] = None,
                 app_artifact_location: Optional[str] = None,
                 app_build_command: Optional[str] = None,
                 app_location: Optional[str] = None,
                 github_action_secret_name_override: Optional[str] = None,
                 output_location: Optional[str] = None,
                 skip_github_action_workflow_generation: Optional[bool] = None):
        """
        Build properties for the static site.
        :param str api_build_command: A custom command to run during deployment of the Azure Functions API application.
        :param str api_location: The path to the api code within the repository.
        :param str app_artifact_location: Deprecated: The path of the app artifacts after building (deprecated in favor of OutputLocation)
        :param str app_build_command: A custom command to run during deployment of the static content application.
        :param str app_location: The path to the app code within the repository.
        :param str github_action_secret_name_override: Github Action secret name override.
        :param str output_location: The output path of the app after building.
        :param bool skip_github_action_workflow_generation: Skip Github Action workflow generation.
        """
        StaticSiteBuildPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_build_command=api_build_command,
            api_location=api_location,
            app_artifact_location=app_artifact_location,
            app_build_command=app_build_command,
            app_location=app_location,
            github_action_secret_name_override=github_action_secret_name_override,
            output_location=output_location,
            skip_github_action_workflow_generation=skip_github_action_workflow_generation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_build_command: Optional[str] = None,
             api_location: Optional[str] = None,
             app_artifact_location: Optional[str] = None,
             app_build_command: Optional[str] = None,
             app_location: Optional[str] = None,
             github_action_secret_name_override: Optional[str] = None,
             output_location: Optional[str] = None,
             skip_github_action_workflow_generation: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if api_build_command is None and 'apiBuildCommand' in kwargs:
            api_build_command = kwargs['apiBuildCommand']
        if api_location is None and 'apiLocation' in kwargs:
            api_location = kwargs['apiLocation']
        if app_artifact_location is None and 'appArtifactLocation' in kwargs:
            app_artifact_location = kwargs['appArtifactLocation']
        if app_build_command is None and 'appBuildCommand' in kwargs:
            app_build_command = kwargs['appBuildCommand']
        if app_location is None and 'appLocation' in kwargs:
            app_location = kwargs['appLocation']
        if github_action_secret_name_override is None and 'githubActionSecretNameOverride' in kwargs:
            github_action_secret_name_override = kwargs['githubActionSecretNameOverride']
        if output_location is None and 'outputLocation' in kwargs:
            output_location = kwargs['outputLocation']
        if skip_github_action_workflow_generation is None and 'skipGithubActionWorkflowGeneration' in kwargs:
            skip_github_action_workflow_generation = kwargs['skipGithubActionWorkflowGeneration']

        if api_build_command is not None:
            _setter("api_build_command", api_build_command)
        if api_location is not None:
            _setter("api_location", api_location)
        if app_artifact_location is not None:
            _setter("app_artifact_location", app_artifact_location)
        if app_build_command is not None:
            _setter("app_build_command", app_build_command)
        if app_location is not None:
            _setter("app_location", app_location)
        if github_action_secret_name_override is not None:
            _setter("github_action_secret_name_override", github_action_secret_name_override)
        if output_location is not None:
            _setter("output_location", output_location)
        if skip_github_action_workflow_generation is not None:
            _setter("skip_github_action_workflow_generation", skip_github_action_workflow_generation)

    @property
    @pulumi.getter(name="apiBuildCommand")
    def api_build_command(self) -> Optional[str]:
        """
        A custom command to run during deployment of the Azure Functions API application.
        """
        return pulumi.get(self, "api_build_command")

    @property
    @pulumi.getter(name="apiLocation")
    def api_location(self) -> Optional[str]:
        """
        The path to the api code within the repository.
        """
        return pulumi.get(self, "api_location")

    @property
    @pulumi.getter(name="appArtifactLocation")
    def app_artifact_location(self) -> Optional[str]:
        """
        Deprecated: The path of the app artifacts after building (deprecated in favor of OutputLocation)
        """
        return pulumi.get(self, "app_artifact_location")

    @property
    @pulumi.getter(name="appBuildCommand")
    def app_build_command(self) -> Optional[str]:
        """
        A custom command to run during deployment of the static content application.
        """
        return pulumi.get(self, "app_build_command")

    @property
    @pulumi.getter(name="appLocation")
    def app_location(self) -> Optional[str]:
        """
        The path to the app code within the repository.
        """
        return pulumi.get(self, "app_location")

    @property
    @pulumi.getter(name="githubActionSecretNameOverride")
    def github_action_secret_name_override(self) -> Optional[str]:
        """
        Github Action secret name override.
        """
        return pulumi.get(self, "github_action_secret_name_override")

    @property
    @pulumi.getter(name="outputLocation")
    def output_location(self) -> Optional[str]:
        """
        The output path of the app after building.
        """
        return pulumi.get(self, "output_location")

    @property
    @pulumi.getter(name="skipGithubActionWorkflowGeneration")
    def skip_github_action_workflow_generation(self) -> Optional[bool]:
        """
        Skip Github Action workflow generation.
        """
        return pulumi.get(self, "skip_github_action_workflow_generation")


@pulumi.output_type
class StaticSiteTemplateOptionsResponse(dict):
    """
    Template Options for the static site.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isPrivate":
            suggest = "is_private"
        elif key == "repositoryName":
            suggest = "repository_name"
        elif key == "templateRepositoryUrl":
            suggest = "template_repository_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StaticSiteTemplateOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StaticSiteTemplateOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StaticSiteTemplateOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 is_private: Optional[bool] = None,
                 owner: Optional[str] = None,
                 repository_name: Optional[str] = None,
                 template_repository_url: Optional[str] = None):
        """
        Template Options for the static site.
        :param str description: Description of the newly generated repository.
        :param bool is_private: Whether or not the newly generated repository is a private repository. Defaults to false (i.e. public).
        :param str owner: Owner of the newly generated repository.
        :param str repository_name: Name of the newly generated repository.
        :param str template_repository_url: URL of the template repository. The newly generated repository will be based on this one.
        """
        StaticSiteTemplateOptionsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            is_private=is_private,
            owner=owner,
            repository_name=repository_name,
            template_repository_url=template_repository_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             is_private: Optional[bool] = None,
             owner: Optional[str] = None,
             repository_name: Optional[str] = None,
             template_repository_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if is_private is None and 'isPrivate' in kwargs:
            is_private = kwargs['isPrivate']
        if repository_name is None and 'repositoryName' in kwargs:
            repository_name = kwargs['repositoryName']
        if template_repository_url is None and 'templateRepositoryUrl' in kwargs:
            template_repository_url = kwargs['templateRepositoryUrl']

        if description is not None:
            _setter("description", description)
        if is_private is not None:
            _setter("is_private", is_private)
        if owner is not None:
            _setter("owner", owner)
        if repository_name is not None:
            _setter("repository_name", repository_name)
        if template_repository_url is not None:
            _setter("template_repository_url", template_repository_url)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the newly generated repository.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isPrivate")
    def is_private(self) -> Optional[bool]:
        """
        Whether or not the newly generated repository is a private repository. Defaults to false (i.e. public).
        """
        return pulumi.get(self, "is_private")

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        """
        Owner of the newly generated repository.
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> Optional[str]:
        """
        Name of the newly generated repository.
        """
        return pulumi.get(self, "repository_name")

    @property
    @pulumi.getter(name="templateRepositoryUrl")
    def template_repository_url(self) -> Optional[str]:
        """
        URL of the template repository. The newly generated repository will be based on this one.
        """
        return pulumi.get(self, "template_repository_url")


@pulumi.output_type
class StaticSiteUserARMResourceResponse(dict):
    """
    Static Site User ARM resource.
    """
    def __init__(__self__, *,
                 display_name: str,
                 id: str,
                 name: str,
                 provider: str,
                 type: str,
                 user_id: str,
                 kind: Optional[str] = None,
                 roles: Optional[str] = None):
        """
        Static Site User ARM resource.
        :param str display_name: The display name for the static site user.
        :param str id: Resource Id.
        :param str name: Resource Name.
        :param str provider: The identity provider for the static site user.
        :param str type: Resource type.
        :param str user_id: The user id for the static site user.
        :param str kind: Kind of resource.
        :param str roles: The roles for the static site user, in free-form string format
        """
        StaticSiteUserARMResourceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            id=id,
            name=name,
            provider=provider,
            type=type,
            user_id=user_id,
            kind=kind,
            roles=roles,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             provider: Optional[str] = None,
             type: Optional[str] = None,
             user_id: Optional[str] = None,
             kind: Optional[str] = None,
             roles: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if provider is None:
            raise TypeError("Missing 'provider' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if user_id is None and 'userId' in kwargs:
            user_id = kwargs['userId']
        if user_id is None:
            raise TypeError("Missing 'user_id' argument")

        _setter("display_name", display_name)
        _setter("id", id)
        _setter("name", name)
        _setter("provider", provider)
        _setter("type", type)
        _setter("user_id", user_id)
        if kind is not None:
            _setter("kind", kind)
        if roles is not None:
            _setter("roles", roles)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name for the static site user.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Resource Id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Resource Name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def provider(self) -> str:
        """
        The identity provider for the static site user.
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        The user id for the static site user.
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def roles(self) -> Optional[str]:
        """
        The roles for the static site user, in free-form string format
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class StaticSiteUserProvidedFunctionAppResponse(dict):
    """
    A static site user provided function.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdOn":
            suggest = "created_on"
        elif key == "functionAppRegion":
            suggest = "function_app_region"
        elif key == "functionAppResourceId":
            suggest = "function_app_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StaticSiteUserProvidedFunctionAppResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StaticSiteUserProvidedFunctionAppResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StaticSiteUserProvidedFunctionAppResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_on: str,
                 id: str,
                 name: str,
                 type: str,
                 function_app_region: Optional[str] = None,
                 function_app_resource_id: Optional[str] = None,
                 kind: Optional[str] = None):
        """
        A static site user provided function.
        :param str created_on: The date and time on which the function app was registered with the static site.
        :param str id: Resource Id.
        :param str name: Resource Name.
        :param str type: Resource type.
        :param str function_app_region: The region of the function app registered with the static site
        :param str function_app_resource_id: The resource id of the function app registered with the static site
        :param str kind: Kind of resource.
        """
        StaticSiteUserProvidedFunctionAppResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_on=created_on,
            id=id,
            name=name,
            type=type,
            function_app_region=function_app_region,
            function_app_resource_id=function_app_resource_id,
            kind=kind,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_on: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             type: Optional[str] = None,
             function_app_region: Optional[str] = None,
             function_app_resource_id: Optional[str] = None,
             kind: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if created_on is None and 'createdOn' in kwargs:
            created_on = kwargs['createdOn']
        if created_on is None:
            raise TypeError("Missing 'created_on' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if function_app_region is None and 'functionAppRegion' in kwargs:
            function_app_region = kwargs['functionAppRegion']
        if function_app_resource_id is None and 'functionAppResourceId' in kwargs:
            function_app_resource_id = kwargs['functionAppResourceId']

        _setter("created_on", created_on)
        _setter("id", id)
        _setter("name", name)
        _setter("type", type)
        if function_app_region is not None:
            _setter("function_app_region", function_app_region)
        if function_app_resource_id is not None:
            _setter("function_app_resource_id", function_app_resource_id)
        if kind is not None:
            _setter("kind", kind)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> str:
        """
        The date and time on which the function app was registered with the static site.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Resource Id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Resource Name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="functionAppRegion")
    def function_app_region(self) -> Optional[str]:
        """
        The region of the function app registered with the static site
        """
        return pulumi.get(self, "function_app_region")

    @property
    @pulumi.getter(name="functionAppResourceId")
    def function_app_resource_id(self) -> Optional[str]:
        """
        The resource id of the function app registered with the static site
        """
        return pulumi.get(self, "function_app_resource_id")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class TokenStoreResponse(dict):
    """
    The configuration settings of the token store.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "fileSystem":
            suggest = "file_system"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TokenStoreResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TokenStoreResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TokenStoreResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage: Optional['outputs.BlobStorageTokenStoreResponse'] = None,
                 enabled: Optional[bool] = None,
                 file_system: Optional['outputs.FileSystemTokenStoreResponse'] = None,
                 token_refresh_extension_hours: Optional[float] = None):
        """
        The configuration settings of the token store.
        :param 'BlobStorageTokenStoreResponse' azure_blob_storage: The configuration settings of the storage of the tokens if blob storage is used.
        :param bool enabled: <code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise, <code>false</code>.
                The default is <code>false</code>.
        :param 'FileSystemTokenStoreResponse' file_system: The configuration settings of the storage of the tokens if a file system is used.
        :param float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to
               call the token refresh API. The default is 72 hours.
        """
        TokenStoreResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_blob_storage=azure_blob_storage,
            enabled=enabled,
            file_system=file_system,
            token_refresh_extension_hours=token_refresh_extension_hours,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_blob_storage: Optional['outputs.BlobStorageTokenStoreResponse'] = None,
             enabled: Optional[bool] = None,
             file_system: Optional['outputs.FileSystemTokenStoreResponse'] = None,
             token_refresh_extension_hours: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if azure_blob_storage is None and 'azureBlobStorage' in kwargs:
            azure_blob_storage = kwargs['azureBlobStorage']
        if file_system is None and 'fileSystem' in kwargs:
            file_system = kwargs['fileSystem']
        if token_refresh_extension_hours is None and 'tokenRefreshExtensionHours' in kwargs:
            token_refresh_extension_hours = kwargs['tokenRefreshExtensionHours']

        if azure_blob_storage is not None:
            _setter("azure_blob_storage", azure_blob_storage)
        if enabled is not None:
            _setter("enabled", enabled)
        if file_system is not None:
            _setter("file_system", file_system)
        if token_refresh_extension_hours is not None:
            _setter("token_refresh_extension_hours", token_refresh_extension_hours)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.BlobStorageTokenStoreResponse']:
        """
        The configuration settings of the storage of the tokens if blob storage is used.
        """
        return pulumi.get(self, "azure_blob_storage")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        <code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise, <code>false</code>.
         The default is <code>false</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional['outputs.FileSystemTokenStoreResponse']:
        """
        The configuration settings of the storage of the tokens if a file system is used.
        """
        return pulumi.get(self, "file_system")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[float]:
        """
        The number of hours after session token expiration that a session token can be used to
        call the token refresh API. The default is 72 hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")


@pulumi.output_type
class TwitterRegistrationResponse(dict):
    """
    The configuration settings of the app registration for the Twitter provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TwitterRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TwitterRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TwitterRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: Optional[str] = None,
                 consumer_secret_setting_name: Optional[str] = None):
        """
        The configuration settings of the app registration for the Twitter provider.
        :param str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
               This setting is required for enabling Twitter Sign-In.
               Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
        :param str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter
               application used for sign-in.
        """
        TwitterRegistrationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            consumer_key=consumer_key,
            consumer_secret_setting_name=consumer_secret_setting_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             consumer_key: Optional[str] = None,
             consumer_secret_setting_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if consumer_key is None and 'consumerKey' in kwargs:
            consumer_key = kwargs['consumerKey']
        if consumer_secret_setting_name is None and 'consumerSecretSettingName' in kwargs:
            consumer_secret_setting_name = kwargs['consumerSecretSettingName']

        if consumer_key is not None:
            _setter("consumer_key", consumer_key)
        if consumer_secret_setting_name is not None:
            _setter("consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> Optional[str]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        This setting is required for enabling Twitter Sign-In.
        Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter
        application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class TwitterResponse(dict):
    """
    The configuration settings of the Twitter provider.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 registration: Optional['outputs.TwitterRegistrationResponse'] = None):
        """
        The configuration settings of the Twitter provider.
        :param bool enabled: <code>false</code> if the Twitter provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param 'TwitterRegistrationResponse' registration: The configuration settings of the app registration for the Twitter provider.
        """
        TwitterResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            registration=registration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             registration: Optional['outputs.TwitterRegistrationResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)
        if registration is not None:
            _setter("registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        <code>false</code> if the Twitter provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def registration(self) -> Optional['outputs.TwitterRegistrationResponse']:
        """
        The configuration settings of the app registration for the Twitter provider.
        """
        return pulumi.get(self, "registration")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User Assigned identity.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str):
        """
        User Assigned identity.
        :param str client_id: Client Id of user assigned identity
        :param str principal_id: Principal Id of user assigned identity
        """
        UserAssignedIdentityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            principal_id=principal_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[str] = None,
             principal_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_id is None:
            raise TypeError("Missing 'client_id' argument")
        if principal_id is None and 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if principal_id is None:
            raise TypeError("Missing 'principal_id' argument")

        _setter("client_id", client_id)
        _setter("principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client Id of user assigned identity
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        Principal Id of user assigned identity
        """
        return pulumi.get(self, "principal_id")


